
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:33:11.814] plan(): Setting new future strategy stack:
[10:33:11.815] List of future strategies:
[10:33:11.815] 1. sequential:
[10:33:11.815]    - args: function (..., envir = parent.frame())
[10:33:11.815]    - tweaked: FALSE
[10:33:11.815]    - call: future::plan("sequential")
[10:33:11.828] plan(): nbrOfWorkers() = 1
> library("listenv")
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Tricky use cases related to globals ...")
*** Tricky use cases related to globals ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   message("- Local variables with the same name as globals ...")
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     methods <- c("conservative", "ordered")
+     for (method in methods) {
+       options(future.globals.method = method)
+       message(sprintf("Method for identifying globals: '%s' ...", method))
+ 
+       a <- 3
+ 
+       yTruth <- local({
+         b <- a
+         a <- 2
+         a * b
+       })
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       }
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       a <- 3
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       } %lazy% TRUE
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         }
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         } %lazy% TRUE
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Assert that `a` is resolved and turned into a constant future
+       ## at the moment when future `b` is created.
+       ## Requires options(future.globals.resolve = TRUE).
+       a <- future(1)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+ 
+       ## BUG FIX: In future (<= 1.0.0) a global 'pkg' would be
+       ## overwritten by the name of the last package attached
+       ## by the future.
+       pkg <- "foo"
+       f <- sequential({ pkg })
+       v <- value(f)
+       message(sprintf("value(f) = %s", sQuote(v)))
+       stopifnot(pkg == "foo", v == "foo")
+       
+       message(sprintf("Method for identifying globals: '%s' ... DONE", method))
+     }
+ 
+     ## BUG FIX: In globals (<= 0.10.3) a global 'x' in LHS of an assignment
+     ## would be missed.
+     options(future.globals.method = "ordered")
+ 
+     ## A local
+     x <- 1
+     f <- future({ x <- 0; x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 1)
+     
+     ## A global
+     x <- 1
+     f <- future({ x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 2)
+ 
+     ## A global
+     x <- function() TRUE
+     f <- future({ x <- x(); x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == TRUE)
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- Local variables with the same name as globals ...
- plan('sequential') ...
[10:33:11.916] plan(): Setting new future strategy stack:
[10:33:11.916] List of future strategies:
[10:33:11.916] 1. sequential:
[10:33:11.916]    - args: function (..., envir = parent.frame())
[10:33:11.916]    - tweaked: FALSE
[10:33:11.916]    - call: plan(strategy)
[10:33:11.928] plan(): nbrOfWorkers() = 1
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:11.930] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:11.930] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:11.936] - globals found: [3] ‘{’, ‘<-’, ‘*’
[10:33:11.936] Searching for globals ... DONE
[10:33:11.936] Resolving globals: TRUE
[10:33:11.936] Resolving any globals that are futures ...
[10:33:11.937] - globals: [3] ‘{’, ‘<-’, ‘*’
[10:33:11.937] Resolving any globals that are futures ... DONE
[10:33:11.937] 
[10:33:11.937] 
[10:33:11.937] getGlobalsAndPackages() ... DONE
[10:33:11.938] run() for ‘Future’ ...
[10:33:11.938] - state: ‘created’
[10:33:11.938] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:11.939] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:11.939] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:11.939]   - Field: ‘label’
[10:33:11.939]   - Field: ‘local’
[10:33:11.939]   - Field: ‘owner’
[10:33:11.939]   - Field: ‘envir’
[10:33:11.939]   - Field: ‘packages’
[10:33:11.939]   - Field: ‘gc’
[10:33:11.939]   - Field: ‘conditions’
[10:33:11.940]   - Field: ‘expr’
[10:33:11.940]   - Field: ‘uuid’
[10:33:11.940]   - Field: ‘seed’
[10:33:11.940]   - Field: ‘version’
[10:33:11.940]   - Field: ‘result’
[10:33:11.940]   - Field: ‘asynchronous’
[10:33:11.940]   - Field: ‘calls’
[10:33:11.940]   - Field: ‘globals’
[10:33:11.940]   - Field: ‘stdout’
[10:33:11.940]   - Field: ‘earlySignal’
[10:33:11.940]   - Field: ‘lazy’
[10:33:11.941]   - Field: ‘state’
[10:33:11.941] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:11.941] - Launch lazy future ...
[10:33:11.941] Packages needed by the future expression (n = 0): <none>
[10:33:11.942] Packages needed by future strategies (n = 0): <none>
[10:33:11.942] {
[10:33:11.942]     {
[10:33:11.942]         {
[10:33:11.942]             ...future.startTime <- base::Sys.time()
[10:33:11.942]             {
[10:33:11.942]                 {
[10:33:11.942]                   {
[10:33:11.942]                     base::local({
[10:33:11.942]                       has_future <- base::requireNamespace("future", 
[10:33:11.942]                         quietly = TRUE)
[10:33:11.942]                       if (has_future) {
[10:33:11.942]                         ns <- base::getNamespace("future")
[10:33:11.942]                         version <- ns[[".package"]][["version"]]
[10:33:11.942]                         if (is.null(version)) 
[10:33:11.942]                           version <- utils::packageVersion("future")
[10:33:11.942]                       }
[10:33:11.942]                       else {
[10:33:11.942]                         version <- NULL
[10:33:11.942]                       }
[10:33:11.942]                       if (!has_future || version < "1.8.0") {
[10:33:11.942]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:11.942]                           "", base::R.version$version.string), 
[10:33:11.942]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:11.942]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:11.942]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:11.942]                             "release", "version")], collapse = " "), 
[10:33:11.942]                           hostname = base::Sys.info()[["nodename"]])
[10:33:11.942]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:11.942]                           info)
[10:33:11.942]                         info <- base::paste(info, collapse = "; ")
[10:33:11.942]                         if (!has_future) {
[10:33:11.942]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:11.942]                             info)
[10:33:11.942]                         }
[10:33:11.942]                         else {
[10:33:11.942]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:11.942]                             info, version)
[10:33:11.942]                         }
[10:33:11.942]                         base::stop(msg)
[10:33:11.942]                       }
[10:33:11.942]                     })
[10:33:11.942]                   }
[10:33:11.942]                   ...future.strategy.old <- future::plan("list")
[10:33:11.942]                   options(future.plan = NULL)
[10:33:11.942]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:11.942]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:11.942]                 }
[10:33:11.942]                 ...future.workdir <- getwd()
[10:33:11.942]             }
[10:33:11.942]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:11.942]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:11.942]         }
[10:33:11.942]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:11.942]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:11.942]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:11.942]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:11.942]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:11.942]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:11.942]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:11.942]             base::names(...future.oldOptions))
[10:33:11.942]     }
[10:33:11.942]     if (FALSE) {
[10:33:11.942]     }
[10:33:11.942]     else {
[10:33:11.942]         if (TRUE) {
[10:33:11.942]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:11.942]                 open = "w")
[10:33:11.942]         }
[10:33:11.942]         else {
[10:33:11.942]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:11.942]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:11.942]         }
[10:33:11.942]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:11.942]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:11.942]             base::sink(type = "output", split = FALSE)
[10:33:11.942]             base::close(...future.stdout)
[10:33:11.942]         }, add = TRUE)
[10:33:11.942]     }
[10:33:11.942]     ...future.frame <- base::sys.nframe()
[10:33:11.942]     ...future.conditions <- base::list()
[10:33:11.942]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:11.942]     if (FALSE) {
[10:33:11.942]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:11.942]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:11.942]     }
[10:33:11.942]     ...future.result <- base::tryCatch({
[10:33:11.942]         base::withCallingHandlers({
[10:33:11.942]             ...future.value <- base::withVisible(base::local({
[10:33:11.942]                 b <- a
[10:33:11.942]                 a <- 2
[10:33:11.942]                 a * b
[10:33:11.942]             }))
[10:33:11.942]             future::FutureResult(value = ...future.value$value, 
[10:33:11.942]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:11.942]                   ...future.rng), globalenv = if (FALSE) 
[10:33:11.942]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:11.942]                     ...future.globalenv.names))
[10:33:11.942]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:11.942]         }, condition = base::local({
[10:33:11.942]             c <- base::c
[10:33:11.942]             inherits <- base::inherits
[10:33:11.942]             invokeRestart <- base::invokeRestart
[10:33:11.942]             length <- base::length
[10:33:11.942]             list <- base::list
[10:33:11.942]             seq.int <- base::seq.int
[10:33:11.942]             signalCondition <- base::signalCondition
[10:33:11.942]             sys.calls <- base::sys.calls
[10:33:11.942]             `[[` <- base::`[[`
[10:33:11.942]             `+` <- base::`+`
[10:33:11.942]             `<<-` <- base::`<<-`
[10:33:11.942]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:11.942]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:11.942]                   3L)]
[10:33:11.942]             }
[10:33:11.942]             function(cond) {
[10:33:11.942]                 is_error <- inherits(cond, "error")
[10:33:11.942]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:11.942]                   NULL)
[10:33:11.942]                 if (is_error) {
[10:33:11.942]                   sessionInformation <- function() {
[10:33:11.942]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:11.942]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:11.942]                       search = base::search(), system = base::Sys.info())
[10:33:11.942]                   }
[10:33:11.942]                   ...future.conditions[[length(...future.conditions) + 
[10:33:11.942]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:11.942]                     cond$call), session = sessionInformation(), 
[10:33:11.942]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:11.942]                   signalCondition(cond)
[10:33:11.942]                 }
[10:33:11.942]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:11.942]                 "immediateCondition"))) {
[10:33:11.942]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:11.942]                   ...future.conditions[[length(...future.conditions) + 
[10:33:11.942]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:11.942]                   if (TRUE && !signal) {
[10:33:11.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:11.942]                     {
[10:33:11.942]                       inherits <- base::inherits
[10:33:11.942]                       invokeRestart <- base::invokeRestart
[10:33:11.942]                       is.null <- base::is.null
[10:33:11.942]                       muffled <- FALSE
[10:33:11.942]                       if (inherits(cond, "message")) {
[10:33:11.942]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:11.942]                         if (muffled) 
[10:33:11.942]                           invokeRestart("muffleMessage")
[10:33:11.942]                       }
[10:33:11.942]                       else if (inherits(cond, "warning")) {
[10:33:11.942]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:11.942]                         if (muffled) 
[10:33:11.942]                           invokeRestart("muffleWarning")
[10:33:11.942]                       }
[10:33:11.942]                       else if (inherits(cond, "condition")) {
[10:33:11.942]                         if (!is.null(pattern)) {
[10:33:11.942]                           computeRestarts <- base::computeRestarts
[10:33:11.942]                           grepl <- base::grepl
[10:33:11.942]                           restarts <- computeRestarts(cond)
[10:33:11.942]                           for (restart in restarts) {
[10:33:11.942]                             name <- restart$name
[10:33:11.942]                             if (is.null(name)) 
[10:33:11.942]                               next
[10:33:11.942]                             if (!grepl(pattern, name)) 
[10:33:11.942]                               next
[10:33:11.942]                             invokeRestart(restart)
[10:33:11.942]                             muffled <- TRUE
[10:33:11.942]                             break
[10:33:11.942]                           }
[10:33:11.942]                         }
[10:33:11.942]                       }
[10:33:11.942]                       invisible(muffled)
[10:33:11.942]                     }
[10:33:11.942]                     muffleCondition(cond, pattern = "^muffle")
[10:33:11.942]                   }
[10:33:11.942]                 }
[10:33:11.942]                 else {
[10:33:11.942]                   if (TRUE) {
[10:33:11.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:11.942]                     {
[10:33:11.942]                       inherits <- base::inherits
[10:33:11.942]                       invokeRestart <- base::invokeRestart
[10:33:11.942]                       is.null <- base::is.null
[10:33:11.942]                       muffled <- FALSE
[10:33:11.942]                       if (inherits(cond, "message")) {
[10:33:11.942]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:11.942]                         if (muffled) 
[10:33:11.942]                           invokeRestart("muffleMessage")
[10:33:11.942]                       }
[10:33:11.942]                       else if (inherits(cond, "warning")) {
[10:33:11.942]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:11.942]                         if (muffled) 
[10:33:11.942]                           invokeRestart("muffleWarning")
[10:33:11.942]                       }
[10:33:11.942]                       else if (inherits(cond, "condition")) {
[10:33:11.942]                         if (!is.null(pattern)) {
[10:33:11.942]                           computeRestarts <- base::computeRestarts
[10:33:11.942]                           grepl <- base::grepl
[10:33:11.942]                           restarts <- computeRestarts(cond)
[10:33:11.942]                           for (restart in restarts) {
[10:33:11.942]                             name <- restart$name
[10:33:11.942]                             if (is.null(name)) 
[10:33:11.942]                               next
[10:33:11.942]                             if (!grepl(pattern, name)) 
[10:33:11.942]                               next
[10:33:11.942]                             invokeRestart(restart)
[10:33:11.942]                             muffled <- TRUE
[10:33:11.942]                             break
[10:33:11.942]                           }
[10:33:11.942]                         }
[10:33:11.942]                       }
[10:33:11.942]                       invisible(muffled)
[10:33:11.942]                     }
[10:33:11.942]                     muffleCondition(cond, pattern = "^muffle")
[10:33:11.942]                   }
[10:33:11.942]                 }
[10:33:11.942]             }
[10:33:11.942]         }))
[10:33:11.942]     }, error = function(ex) {
[10:33:11.942]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:11.942]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:11.942]                 ...future.rng), started = ...future.startTime, 
[10:33:11.942]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:11.942]             version = "1.8"), class = "FutureResult")
[10:33:11.942]     }, finally = {
[10:33:11.942]         if (!identical(...future.workdir, getwd())) 
[10:33:11.942]             setwd(...future.workdir)
[10:33:11.942]         {
[10:33:11.942]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:11.942]                 ...future.oldOptions$nwarnings <- NULL
[10:33:11.942]             }
[10:33:11.942]             base::options(...future.oldOptions)
[10:33:11.942]             if (.Platform$OS.type == "windows") {
[10:33:11.942]                 old_names <- names(...future.oldEnvVars)
[10:33:11.942]                 envs <- base::Sys.getenv()
[10:33:11.942]                 names <- names(envs)
[10:33:11.942]                 common <- intersect(names, old_names)
[10:33:11.942]                 added <- setdiff(names, old_names)
[10:33:11.942]                 removed <- setdiff(old_names, names)
[10:33:11.942]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:11.942]                   envs[common]]
[10:33:11.942]                 NAMES <- toupper(changed)
[10:33:11.942]                 args <- list()
[10:33:11.942]                 for (kk in seq_along(NAMES)) {
[10:33:11.942]                   name <- changed[[kk]]
[10:33:11.942]                   NAME <- NAMES[[kk]]
[10:33:11.942]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:11.942]                     next
[10:33:11.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:11.942]                 }
[10:33:11.942]                 NAMES <- toupper(added)
[10:33:11.942]                 for (kk in seq_along(NAMES)) {
[10:33:11.942]                   name <- added[[kk]]
[10:33:11.942]                   NAME <- NAMES[[kk]]
[10:33:11.942]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:11.942]                     next
[10:33:11.942]                   args[[name]] <- ""
[10:33:11.942]                 }
[10:33:11.942]                 NAMES <- toupper(removed)
[10:33:11.942]                 for (kk in seq_along(NAMES)) {
[10:33:11.942]                   name <- removed[[kk]]
[10:33:11.942]                   NAME <- NAMES[[kk]]
[10:33:11.942]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:11.942]                     next
[10:33:11.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:11.942]                 }
[10:33:11.942]                 if (length(args) > 0) 
[10:33:11.942]                   base::do.call(base::Sys.setenv, args = args)
[10:33:11.942]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:11.942]             }
[10:33:11.942]             else {
[10:33:11.942]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:11.942]             }
[10:33:11.942]             {
[10:33:11.942]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:11.942]                   0L) {
[10:33:11.942]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:11.942]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:11.942]                   base::options(opts)
[10:33:11.942]                 }
[10:33:11.942]                 {
[10:33:11.942]                   {
[10:33:11.942]                     NULL
[10:33:11.942]                     RNGkind("Mersenne-Twister")
[10:33:11.942]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:11.942]                       inherits = FALSE)
[10:33:11.942]                   }
[10:33:11.942]                   options(future.plan = NULL)
[10:33:11.942]                   if (is.na(NA_character_)) 
[10:33:11.942]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:11.942]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:11.942]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:11.942]                     .init = FALSE)
[10:33:11.942]                 }
[10:33:11.942]             }
[10:33:11.942]         }
[10:33:11.942]     })
[10:33:11.942]     if (TRUE) {
[10:33:11.942]         base::sink(type = "output", split = FALSE)
[10:33:11.942]         if (TRUE) {
[10:33:11.942]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:11.942]         }
[10:33:11.942]         else {
[10:33:11.942]             ...future.result["stdout"] <- base::list(NULL)
[10:33:11.942]         }
[10:33:11.942]         base::close(...future.stdout)
[10:33:11.942]         ...future.stdout <- NULL
[10:33:11.942]     }
[10:33:11.942]     ...future.result$conditions <- ...future.conditions
[10:33:11.942]     ...future.result$finished <- base::Sys.time()
[10:33:11.942]     ...future.result
[10:33:11.942] }
[10:33:11.944] plan(): Setting new future strategy stack:
[10:33:11.944] List of future strategies:
[10:33:11.944] 1. sequential:
[10:33:11.944]    - args: function (..., envir = parent.frame())
[10:33:11.944]    - tweaked: FALSE
[10:33:11.944]    - call: NULL
[10:33:11.945] plan(): nbrOfWorkers() = 1
[10:33:11.946] plan(): Setting new future strategy stack:
[10:33:11.946] List of future strategies:
[10:33:11.946] 1. sequential:
[10:33:11.946]    - args: function (..., envir = parent.frame())
[10:33:11.946]    - tweaked: FALSE
[10:33:11.946]    - call: plan(strategy)
[10:33:11.946] plan(): nbrOfWorkers() = 1
[10:33:11.946] SequentialFuture started (and completed)
[10:33:11.947] - Launch lazy future ... done
[10:33:11.947] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:11.948] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:11.948] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:11.949] - globals found: [3] ‘{’, ‘<-’, ‘*’
[10:33:11.949] Searching for globals ... DONE
[10:33:11.949] Resolving globals: TRUE
[10:33:11.949] Resolving any globals that are futures ...
[10:33:11.950] - globals: [3] ‘{’, ‘<-’, ‘*’
[10:33:11.950] Resolving any globals that are futures ... DONE
[10:33:11.950] 
[10:33:11.950] 
[10:33:11.952] getGlobalsAndPackages() ... DONE
[10:33:11.952] run() for ‘Future’ ...
[10:33:11.952] - state: ‘created’
[10:33:11.952] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:11.952] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:11.952] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:11.953]   - Field: ‘label’
[10:33:11.953]   - Field: ‘local’
[10:33:11.953]   - Field: ‘owner’
[10:33:11.953]   - Field: ‘envir’
[10:33:11.953]   - Field: ‘packages’
[10:33:11.953]   - Field: ‘gc’
[10:33:11.953]   - Field: ‘conditions’
[10:33:11.953]   - Field: ‘expr’
[10:33:11.953]   - Field: ‘uuid’
[10:33:11.953]   - Field: ‘seed’
[10:33:11.954]   - Field: ‘version’
[10:33:11.954]   - Field: ‘result’
[10:33:11.954]   - Field: ‘asynchronous’
[10:33:11.954]   - Field: ‘calls’
[10:33:11.954]   - Field: ‘globals’
[10:33:11.954]   - Field: ‘stdout’
[10:33:11.954]   - Field: ‘earlySignal’
[10:33:11.954]   - Field: ‘lazy’
[10:33:11.954]   - Field: ‘state’
[10:33:11.954] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:11.954] - Launch lazy future ...
[10:33:11.955] Packages needed by the future expression (n = 0): <none>
[10:33:11.955] Packages needed by future strategies (n = 0): <none>
[10:33:11.955] {
[10:33:11.955]     {
[10:33:11.955]         {
[10:33:11.955]             ...future.startTime <- base::Sys.time()
[10:33:11.955]             {
[10:33:11.955]                 {
[10:33:11.955]                   {
[10:33:11.955]                     base::local({
[10:33:11.955]                       has_future <- base::requireNamespace("future", 
[10:33:11.955]                         quietly = TRUE)
[10:33:11.955]                       if (has_future) {
[10:33:11.955]                         ns <- base::getNamespace("future")
[10:33:11.955]                         version <- ns[[".package"]][["version"]]
[10:33:11.955]                         if (is.null(version)) 
[10:33:11.955]                           version <- utils::packageVersion("future")
[10:33:11.955]                       }
[10:33:11.955]                       else {
[10:33:11.955]                         version <- NULL
[10:33:11.955]                       }
[10:33:11.955]                       if (!has_future || version < "1.8.0") {
[10:33:11.955]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:11.955]                           "", base::R.version$version.string), 
[10:33:11.955]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:11.955]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:11.955]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:11.955]                             "release", "version")], collapse = " "), 
[10:33:11.955]                           hostname = base::Sys.info()[["nodename"]])
[10:33:11.955]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:11.955]                           info)
[10:33:11.955]                         info <- base::paste(info, collapse = "; ")
[10:33:11.955]                         if (!has_future) {
[10:33:11.955]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:11.955]                             info)
[10:33:11.955]                         }
[10:33:11.955]                         else {
[10:33:11.955]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:11.955]                             info, version)
[10:33:11.955]                         }
[10:33:11.955]                         base::stop(msg)
[10:33:11.955]                       }
[10:33:11.955]                     })
[10:33:11.955]                   }
[10:33:11.955]                   ...future.strategy.old <- future::plan("list")
[10:33:11.955]                   options(future.plan = NULL)
[10:33:11.955]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:11.955]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:11.955]                 }
[10:33:11.955]                 ...future.workdir <- getwd()
[10:33:11.955]             }
[10:33:11.955]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:11.955]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:11.955]         }
[10:33:11.955]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:11.955]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:11.955]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:11.955]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:11.955]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:11.955]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:11.955]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:11.955]             base::names(...future.oldOptions))
[10:33:11.955]     }
[10:33:11.955]     if (FALSE) {
[10:33:11.955]     }
[10:33:11.955]     else {
[10:33:11.955]         if (TRUE) {
[10:33:11.955]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:11.955]                 open = "w")
[10:33:11.955]         }
[10:33:11.955]         else {
[10:33:11.955]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:11.955]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:11.955]         }
[10:33:11.955]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:11.955]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:11.955]             base::sink(type = "output", split = FALSE)
[10:33:11.955]             base::close(...future.stdout)
[10:33:11.955]         }, add = TRUE)
[10:33:11.955]     }
[10:33:11.955]     ...future.frame <- base::sys.nframe()
[10:33:11.955]     ...future.conditions <- base::list()
[10:33:11.955]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:11.955]     if (FALSE) {
[10:33:11.955]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:11.955]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:11.955]     }
[10:33:11.955]     ...future.result <- base::tryCatch({
[10:33:11.955]         base::withCallingHandlers({
[10:33:11.955]             ...future.value <- base::withVisible(base::local({
[10:33:11.955]                 b <- a
[10:33:11.955]                 a <- 2
[10:33:11.955]                 a * b
[10:33:11.955]             }))
[10:33:11.955]             future::FutureResult(value = ...future.value$value, 
[10:33:11.955]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:11.955]                   ...future.rng), globalenv = if (FALSE) 
[10:33:11.955]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:11.955]                     ...future.globalenv.names))
[10:33:11.955]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:11.955]         }, condition = base::local({
[10:33:11.955]             c <- base::c
[10:33:11.955]             inherits <- base::inherits
[10:33:11.955]             invokeRestart <- base::invokeRestart
[10:33:11.955]             length <- base::length
[10:33:11.955]             list <- base::list
[10:33:11.955]             seq.int <- base::seq.int
[10:33:11.955]             signalCondition <- base::signalCondition
[10:33:11.955]             sys.calls <- base::sys.calls
[10:33:11.955]             `[[` <- base::`[[`
[10:33:11.955]             `+` <- base::`+`
[10:33:11.955]             `<<-` <- base::`<<-`
[10:33:11.955]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:11.955]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:11.955]                   3L)]
[10:33:11.955]             }
[10:33:11.955]             function(cond) {
[10:33:11.955]                 is_error <- inherits(cond, "error")
[10:33:11.955]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:11.955]                   NULL)
[10:33:11.955]                 if (is_error) {
[10:33:11.955]                   sessionInformation <- function() {
[10:33:11.955]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:11.955]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:11.955]                       search = base::search(), system = base::Sys.info())
[10:33:11.955]                   }
[10:33:11.955]                   ...future.conditions[[length(...future.conditions) + 
[10:33:11.955]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:11.955]                     cond$call), session = sessionInformation(), 
[10:33:11.955]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:11.955]                   signalCondition(cond)
[10:33:11.955]                 }
[10:33:11.955]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:11.955]                 "immediateCondition"))) {
[10:33:11.955]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:11.955]                   ...future.conditions[[length(...future.conditions) + 
[10:33:11.955]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:11.955]                   if (TRUE && !signal) {
[10:33:11.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:11.955]                     {
[10:33:11.955]                       inherits <- base::inherits
[10:33:11.955]                       invokeRestart <- base::invokeRestart
[10:33:11.955]                       is.null <- base::is.null
[10:33:11.955]                       muffled <- FALSE
[10:33:11.955]                       if (inherits(cond, "message")) {
[10:33:11.955]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:11.955]                         if (muffled) 
[10:33:11.955]                           invokeRestart("muffleMessage")
[10:33:11.955]                       }
[10:33:11.955]                       else if (inherits(cond, "warning")) {
[10:33:11.955]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:11.955]                         if (muffled) 
[10:33:11.955]                           invokeRestart("muffleWarning")
[10:33:11.955]                       }
[10:33:11.955]                       else if (inherits(cond, "condition")) {
[10:33:11.955]                         if (!is.null(pattern)) {
[10:33:11.955]                           computeRestarts <- base::computeRestarts
[10:33:11.955]                           grepl <- base::grepl
[10:33:11.955]                           restarts <- computeRestarts(cond)
[10:33:11.955]                           for (restart in restarts) {
[10:33:11.955]                             name <- restart$name
[10:33:11.955]                             if (is.null(name)) 
[10:33:11.955]                               next
[10:33:11.955]                             if (!grepl(pattern, name)) 
[10:33:11.955]                               next
[10:33:11.955]                             invokeRestart(restart)
[10:33:11.955]                             muffled <- TRUE
[10:33:11.955]                             break
[10:33:11.955]                           }
[10:33:11.955]                         }
[10:33:11.955]                       }
[10:33:11.955]                       invisible(muffled)
[10:33:11.955]                     }
[10:33:11.955]                     muffleCondition(cond, pattern = "^muffle")
[10:33:11.955]                   }
[10:33:11.955]                 }
[10:33:11.955]                 else {
[10:33:11.955]                   if (TRUE) {
[10:33:11.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:11.955]                     {
[10:33:11.955]                       inherits <- base::inherits
[10:33:11.955]                       invokeRestart <- base::invokeRestart
[10:33:11.955]                       is.null <- base::is.null
[10:33:11.955]                       muffled <- FALSE
[10:33:11.955]                       if (inherits(cond, "message")) {
[10:33:11.955]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:11.955]                         if (muffled) 
[10:33:11.955]                           invokeRestart("muffleMessage")
[10:33:11.955]                       }
[10:33:11.955]                       else if (inherits(cond, "warning")) {
[10:33:11.955]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:11.955]                         if (muffled) 
[10:33:11.955]                           invokeRestart("muffleWarning")
[10:33:11.955]                       }
[10:33:11.955]                       else if (inherits(cond, "condition")) {
[10:33:11.955]                         if (!is.null(pattern)) {
[10:33:11.955]                           computeRestarts <- base::computeRestarts
[10:33:11.955]                           grepl <- base::grepl
[10:33:11.955]                           restarts <- computeRestarts(cond)
[10:33:11.955]                           for (restart in restarts) {
[10:33:11.955]                             name <- restart$name
[10:33:11.955]                             if (is.null(name)) 
[10:33:11.955]                               next
[10:33:11.955]                             if (!grepl(pattern, name)) 
[10:33:11.955]                               next
[10:33:11.955]                             invokeRestart(restart)
[10:33:11.955]                             muffled <- TRUE
[10:33:11.955]                             break
[10:33:11.955]                           }
[10:33:11.955]                         }
[10:33:11.955]                       }
[10:33:11.955]                       invisible(muffled)
[10:33:11.955]                     }
[10:33:11.955]                     muffleCondition(cond, pattern = "^muffle")
[10:33:11.955]                   }
[10:33:11.955]                 }
[10:33:11.955]             }
[10:33:11.955]         }))
[10:33:11.955]     }, error = function(ex) {
[10:33:11.955]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:11.955]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:11.955]                 ...future.rng), started = ...future.startTime, 
[10:33:11.955]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:11.955]             version = "1.8"), class = "FutureResult")
[10:33:11.955]     }, finally = {
[10:33:11.955]         if (!identical(...future.workdir, getwd())) 
[10:33:11.955]             setwd(...future.workdir)
[10:33:11.955]         {
[10:33:11.955]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:11.955]                 ...future.oldOptions$nwarnings <- NULL
[10:33:11.955]             }
[10:33:11.955]             base::options(...future.oldOptions)
[10:33:11.955]             if (.Platform$OS.type == "windows") {
[10:33:11.955]                 old_names <- names(...future.oldEnvVars)
[10:33:11.955]                 envs <- base::Sys.getenv()
[10:33:11.955]                 names <- names(envs)
[10:33:11.955]                 common <- intersect(names, old_names)
[10:33:11.955]                 added <- setdiff(names, old_names)
[10:33:11.955]                 removed <- setdiff(old_names, names)
[10:33:11.955]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:11.955]                   envs[common]]
[10:33:11.955]                 NAMES <- toupper(changed)
[10:33:11.955]                 args <- list()
[10:33:11.955]                 for (kk in seq_along(NAMES)) {
[10:33:11.955]                   name <- changed[[kk]]
[10:33:11.955]                   NAME <- NAMES[[kk]]
[10:33:11.955]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:11.955]                     next
[10:33:11.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:11.955]                 }
[10:33:11.955]                 NAMES <- toupper(added)
[10:33:11.955]                 for (kk in seq_along(NAMES)) {
[10:33:11.955]                   name <- added[[kk]]
[10:33:11.955]                   NAME <- NAMES[[kk]]
[10:33:11.955]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:11.955]                     next
[10:33:11.955]                   args[[name]] <- ""
[10:33:11.955]                 }
[10:33:11.955]                 NAMES <- toupper(removed)
[10:33:11.955]                 for (kk in seq_along(NAMES)) {
[10:33:11.955]                   name <- removed[[kk]]
[10:33:11.955]                   NAME <- NAMES[[kk]]
[10:33:11.955]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:11.955]                     next
[10:33:11.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:11.955]                 }
[10:33:11.955]                 if (length(args) > 0) 
[10:33:11.955]                   base::do.call(base::Sys.setenv, args = args)
[10:33:11.955]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:11.955]             }
[10:33:11.955]             else {
[10:33:11.955]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:11.955]             }
[10:33:11.955]             {
[10:33:11.955]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:11.955]                   0L) {
[10:33:11.955]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:11.955]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:11.955]                   base::options(opts)
[10:33:11.955]                 }
[10:33:11.955]                 {
[10:33:11.955]                   {
[10:33:11.955]                     NULL
[10:33:11.955]                     RNGkind("Mersenne-Twister")
[10:33:11.955]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:11.955]                       inherits = FALSE)
[10:33:11.955]                   }
[10:33:11.955]                   options(future.plan = NULL)
[10:33:11.955]                   if (is.na(NA_character_)) 
[10:33:11.955]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:11.955]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:11.955]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:11.955]                     .init = FALSE)
[10:33:11.955]                 }
[10:33:11.955]             }
[10:33:11.955]         }
[10:33:11.955]     })
[10:33:11.955]     if (TRUE) {
[10:33:11.955]         base::sink(type = "output", split = FALSE)
[10:33:11.955]         if (TRUE) {
[10:33:11.955]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:11.955]         }
[10:33:11.955]         else {
[10:33:11.955]             ...future.result["stdout"] <- base::list(NULL)
[10:33:11.955]         }
[10:33:11.955]         base::close(...future.stdout)
[10:33:11.955]         ...future.stdout <- NULL
[10:33:11.955]     }
[10:33:11.955]     ...future.result$conditions <- ...future.conditions
[10:33:11.955]     ...future.result$finished <- base::Sys.time()
[10:33:11.955]     ...future.result
[10:33:11.955] }
[10:33:11.957] plan(): Setting new future strategy stack:
[10:33:11.957] List of future strategies:
[10:33:11.957] 1. sequential:
[10:33:11.957]    - args: function (..., envir = parent.frame())
[10:33:11.957]    - tweaked: FALSE
[10:33:11.957]    - call: NULL
[10:33:11.957] plan(): nbrOfWorkers() = 1
[10:33:11.958] plan(): Setting new future strategy stack:
[10:33:11.958] List of future strategies:
[10:33:11.958] 1. sequential:
[10:33:11.958]    - args: function (..., envir = parent.frame())
[10:33:11.958]    - tweaked: FALSE
[10:33:11.958]    - call: plan(strategy)
[10:33:11.958] plan(): nbrOfWorkers() = 1
[10:33:11.959] SequentialFuture started (and completed)
[10:33:11.959] signalConditions() ...
[10:33:11.959]  - include = ‘immediateCondition’
[10:33:11.959]  - exclude = 
[10:33:11.959]  - resignal = FALSE
[10:33:11.959]  - Number of conditions: 1
[10:33:11.959] signalConditions() ... done
[10:33:11.959] - Launch lazy future ... done
[10:33:11.959] run() for ‘SequentialFuture’ ... done
[10:33:11.960] signalConditions() ...
[10:33:11.960]  - include = ‘immediateCondition’
[10:33:11.960]  - exclude = 
[10:33:11.960]  - resignal = FALSE
[10:33:11.960]  - Number of conditions: 1
[10:33:11.960] signalConditions() ... done
[10:33:11.960] Future state: ‘finished’
[10:33:11.960] signalConditions() ...
[10:33:11.960]  - include = ‘condition’
[10:33:11.960]  - exclude = ‘immediateCondition’
[10:33:11.960]  - resignal = TRUE
[10:33:11.960]  - Number of conditions: 1
[10:33:11.961]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:33:11.961] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "c3bfbccbe859" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 10:33:11"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:11.976] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:11.977] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:11.978] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:11.978] Searching for globals ... DONE
[10:33:11.978] Resolving globals: TRUE
[10:33:11.978] Resolving any globals that are futures ...
[10:33:11.978] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:11.978] Resolving any globals that are futures ... DONE
[10:33:11.979] Resolving futures part of globals (recursively) ...
[10:33:11.981] resolve() on list ...
[10:33:11.981]  recursive: 99
[10:33:11.981]  length: 1
[10:33:11.981]  elements: ‘ii’
[10:33:11.981]  length: 0 (resolved future 1)
[10:33:11.981] resolve() on list ... DONE
[10:33:11.982] - globals: [1] ‘ii’
[10:33:11.982] Resolving futures part of globals (recursively) ... DONE
[10:33:11.982] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:11.983] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:11.983] - globals: [1] ‘ii’
[10:33:11.983] 
[10:33:11.983] getGlobalsAndPackages() ... DONE
[10:33:11.983] run() for ‘Future’ ...
[10:33:11.983] - state: ‘created’
[10:33:11.983] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:11.983] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:11.984] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:11.984]   - Field: ‘label’
[10:33:11.984]   - Field: ‘local’
[10:33:11.984]   - Field: ‘owner’
[10:33:11.984]   - Field: ‘envir’
[10:33:11.984]   - Field: ‘packages’
[10:33:11.984]   - Field: ‘gc’
[10:33:11.984]   - Field: ‘conditions’
[10:33:11.984]   - Field: ‘expr’
[10:33:11.984]   - Field: ‘uuid’
[10:33:11.984]   - Field: ‘seed’
[10:33:11.985]   - Field: ‘version’
[10:33:11.985]   - Field: ‘result’
[10:33:11.985]   - Field: ‘asynchronous’
[10:33:11.985]   - Field: ‘calls’
[10:33:11.985]   - Field: ‘globals’
[10:33:11.985]   - Field: ‘stdout’
[10:33:11.985]   - Field: ‘earlySignal’
[10:33:11.985]   - Field: ‘lazy’
[10:33:11.985]   - Field: ‘state’
[10:33:11.985] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:11.986] - Launch lazy future ...
[10:33:11.986] Packages needed by the future expression (n = 0): <none>
[10:33:11.986] Packages needed by future strategies (n = 0): <none>
[10:33:11.986] {
[10:33:11.986]     {
[10:33:11.986]         {
[10:33:11.986]             ...future.startTime <- base::Sys.time()
[10:33:11.986]             {
[10:33:11.986]                 {
[10:33:11.986]                   {
[10:33:11.986]                     base::local({
[10:33:11.986]                       has_future <- base::requireNamespace("future", 
[10:33:11.986]                         quietly = TRUE)
[10:33:11.986]                       if (has_future) {
[10:33:11.986]                         ns <- base::getNamespace("future")
[10:33:11.986]                         version <- ns[[".package"]][["version"]]
[10:33:11.986]                         if (is.null(version)) 
[10:33:11.986]                           version <- utils::packageVersion("future")
[10:33:11.986]                       }
[10:33:11.986]                       else {
[10:33:11.986]                         version <- NULL
[10:33:11.986]                       }
[10:33:11.986]                       if (!has_future || version < "1.8.0") {
[10:33:11.986]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:11.986]                           "", base::R.version$version.string), 
[10:33:11.986]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:11.986]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:11.986]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:11.986]                             "release", "version")], collapse = " "), 
[10:33:11.986]                           hostname = base::Sys.info()[["nodename"]])
[10:33:11.986]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:11.986]                           info)
[10:33:11.986]                         info <- base::paste(info, collapse = "; ")
[10:33:11.986]                         if (!has_future) {
[10:33:11.986]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:11.986]                             info)
[10:33:11.986]                         }
[10:33:11.986]                         else {
[10:33:11.986]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:11.986]                             info, version)
[10:33:11.986]                         }
[10:33:11.986]                         base::stop(msg)
[10:33:11.986]                       }
[10:33:11.986]                     })
[10:33:11.986]                   }
[10:33:11.986]                   ...future.strategy.old <- future::plan("list")
[10:33:11.986]                   options(future.plan = NULL)
[10:33:11.986]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:11.986]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:11.986]                 }
[10:33:11.986]                 ...future.workdir <- getwd()
[10:33:11.986]             }
[10:33:11.986]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:11.986]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:11.986]         }
[10:33:11.986]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:11.986]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:11.986]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:11.986]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:11.986]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:11.986]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:11.986]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:11.986]             base::names(...future.oldOptions))
[10:33:11.986]     }
[10:33:11.986]     if (FALSE) {
[10:33:11.986]     }
[10:33:11.986]     else {
[10:33:11.986]         if (TRUE) {
[10:33:11.986]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:11.986]                 open = "w")
[10:33:11.986]         }
[10:33:11.986]         else {
[10:33:11.986]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:11.986]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:11.986]         }
[10:33:11.986]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:11.986]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:11.986]             base::sink(type = "output", split = FALSE)
[10:33:11.986]             base::close(...future.stdout)
[10:33:11.986]         }, add = TRUE)
[10:33:11.986]     }
[10:33:11.986]     ...future.frame <- base::sys.nframe()
[10:33:11.986]     ...future.conditions <- base::list()
[10:33:11.986]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:11.986]     if (FALSE) {
[10:33:11.986]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:11.986]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:11.986]     }
[10:33:11.986]     ...future.result <- base::tryCatch({
[10:33:11.986]         base::withCallingHandlers({
[10:33:11.986]             ...future.value <- base::withVisible(base::local({
[10:33:11.986]                 b <- a * ii
[10:33:11.986]                 a <- 0
[10:33:11.986]                 b
[10:33:11.986]             }))
[10:33:11.986]             future::FutureResult(value = ...future.value$value, 
[10:33:11.986]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:11.986]                   ...future.rng), globalenv = if (FALSE) 
[10:33:11.986]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:11.986]                     ...future.globalenv.names))
[10:33:11.986]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:11.986]         }, condition = base::local({
[10:33:11.986]             c <- base::c
[10:33:11.986]             inherits <- base::inherits
[10:33:11.986]             invokeRestart <- base::invokeRestart
[10:33:11.986]             length <- base::length
[10:33:11.986]             list <- base::list
[10:33:11.986]             seq.int <- base::seq.int
[10:33:11.986]             signalCondition <- base::signalCondition
[10:33:11.986]             sys.calls <- base::sys.calls
[10:33:11.986]             `[[` <- base::`[[`
[10:33:11.986]             `+` <- base::`+`
[10:33:11.986]             `<<-` <- base::`<<-`
[10:33:11.986]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:11.986]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:11.986]                   3L)]
[10:33:11.986]             }
[10:33:11.986]             function(cond) {
[10:33:11.986]                 is_error <- inherits(cond, "error")
[10:33:11.986]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:11.986]                   NULL)
[10:33:11.986]                 if (is_error) {
[10:33:11.986]                   sessionInformation <- function() {
[10:33:11.986]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:11.986]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:11.986]                       search = base::search(), system = base::Sys.info())
[10:33:11.986]                   }
[10:33:11.986]                   ...future.conditions[[length(...future.conditions) + 
[10:33:11.986]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:11.986]                     cond$call), session = sessionInformation(), 
[10:33:11.986]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:11.986]                   signalCondition(cond)
[10:33:11.986]                 }
[10:33:11.986]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:11.986]                 "immediateCondition"))) {
[10:33:11.986]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:11.986]                   ...future.conditions[[length(...future.conditions) + 
[10:33:11.986]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:11.986]                   if (TRUE && !signal) {
[10:33:11.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:11.986]                     {
[10:33:11.986]                       inherits <- base::inherits
[10:33:11.986]                       invokeRestart <- base::invokeRestart
[10:33:11.986]                       is.null <- base::is.null
[10:33:11.986]                       muffled <- FALSE
[10:33:11.986]                       if (inherits(cond, "message")) {
[10:33:11.986]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:11.986]                         if (muffled) 
[10:33:11.986]                           invokeRestart("muffleMessage")
[10:33:11.986]                       }
[10:33:11.986]                       else if (inherits(cond, "warning")) {
[10:33:11.986]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:11.986]                         if (muffled) 
[10:33:11.986]                           invokeRestart("muffleWarning")
[10:33:11.986]                       }
[10:33:11.986]                       else if (inherits(cond, "condition")) {
[10:33:11.986]                         if (!is.null(pattern)) {
[10:33:11.986]                           computeRestarts <- base::computeRestarts
[10:33:11.986]                           grepl <- base::grepl
[10:33:11.986]                           restarts <- computeRestarts(cond)
[10:33:11.986]                           for (restart in restarts) {
[10:33:11.986]                             name <- restart$name
[10:33:11.986]                             if (is.null(name)) 
[10:33:11.986]                               next
[10:33:11.986]                             if (!grepl(pattern, name)) 
[10:33:11.986]                               next
[10:33:11.986]                             invokeRestart(restart)
[10:33:11.986]                             muffled <- TRUE
[10:33:11.986]                             break
[10:33:11.986]                           }
[10:33:11.986]                         }
[10:33:11.986]                       }
[10:33:11.986]                       invisible(muffled)
[10:33:11.986]                     }
[10:33:11.986]                     muffleCondition(cond, pattern = "^muffle")
[10:33:11.986]                   }
[10:33:11.986]                 }
[10:33:11.986]                 else {
[10:33:11.986]                   if (TRUE) {
[10:33:11.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:11.986]                     {
[10:33:11.986]                       inherits <- base::inherits
[10:33:11.986]                       invokeRestart <- base::invokeRestart
[10:33:11.986]                       is.null <- base::is.null
[10:33:11.986]                       muffled <- FALSE
[10:33:11.986]                       if (inherits(cond, "message")) {
[10:33:11.986]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:11.986]                         if (muffled) 
[10:33:11.986]                           invokeRestart("muffleMessage")
[10:33:11.986]                       }
[10:33:11.986]                       else if (inherits(cond, "warning")) {
[10:33:11.986]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:11.986]                         if (muffled) 
[10:33:11.986]                           invokeRestart("muffleWarning")
[10:33:11.986]                       }
[10:33:11.986]                       else if (inherits(cond, "condition")) {
[10:33:11.986]                         if (!is.null(pattern)) {
[10:33:11.986]                           computeRestarts <- base::computeRestarts
[10:33:11.986]                           grepl <- base::grepl
[10:33:11.986]                           restarts <- computeRestarts(cond)
[10:33:11.986]                           for (restart in restarts) {
[10:33:11.986]                             name <- restart$name
[10:33:11.986]                             if (is.null(name)) 
[10:33:11.986]                               next
[10:33:11.986]                             if (!grepl(pattern, name)) 
[10:33:11.986]                               next
[10:33:11.986]                             invokeRestart(restart)
[10:33:11.986]                             muffled <- TRUE
[10:33:11.986]                             break
[10:33:11.986]                           }
[10:33:11.986]                         }
[10:33:11.986]                       }
[10:33:11.986]                       invisible(muffled)
[10:33:11.986]                     }
[10:33:11.986]                     muffleCondition(cond, pattern = "^muffle")
[10:33:11.986]                   }
[10:33:11.986]                 }
[10:33:11.986]             }
[10:33:11.986]         }))
[10:33:11.986]     }, error = function(ex) {
[10:33:11.986]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:11.986]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:11.986]                 ...future.rng), started = ...future.startTime, 
[10:33:11.986]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:11.986]             version = "1.8"), class = "FutureResult")
[10:33:11.986]     }, finally = {
[10:33:11.986]         if (!identical(...future.workdir, getwd())) 
[10:33:11.986]             setwd(...future.workdir)
[10:33:11.986]         {
[10:33:11.986]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:11.986]                 ...future.oldOptions$nwarnings <- NULL
[10:33:11.986]             }
[10:33:11.986]             base::options(...future.oldOptions)
[10:33:11.986]             if (.Platform$OS.type == "windows") {
[10:33:11.986]                 old_names <- names(...future.oldEnvVars)
[10:33:11.986]                 envs <- base::Sys.getenv()
[10:33:11.986]                 names <- names(envs)
[10:33:11.986]                 common <- intersect(names, old_names)
[10:33:11.986]                 added <- setdiff(names, old_names)
[10:33:11.986]                 removed <- setdiff(old_names, names)
[10:33:11.986]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:11.986]                   envs[common]]
[10:33:11.986]                 NAMES <- toupper(changed)
[10:33:11.986]                 args <- list()
[10:33:11.986]                 for (kk in seq_along(NAMES)) {
[10:33:11.986]                   name <- changed[[kk]]
[10:33:11.986]                   NAME <- NAMES[[kk]]
[10:33:11.986]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:11.986]                     next
[10:33:11.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:11.986]                 }
[10:33:11.986]                 NAMES <- toupper(added)
[10:33:11.986]                 for (kk in seq_along(NAMES)) {
[10:33:11.986]                   name <- added[[kk]]
[10:33:11.986]                   NAME <- NAMES[[kk]]
[10:33:11.986]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:11.986]                     next
[10:33:11.986]                   args[[name]] <- ""
[10:33:11.986]                 }
[10:33:11.986]                 NAMES <- toupper(removed)
[10:33:11.986]                 for (kk in seq_along(NAMES)) {
[10:33:11.986]                   name <- removed[[kk]]
[10:33:11.986]                   NAME <- NAMES[[kk]]
[10:33:11.986]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:11.986]                     next
[10:33:11.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:11.986]                 }
[10:33:11.986]                 if (length(args) > 0) 
[10:33:11.986]                   base::do.call(base::Sys.setenv, args = args)
[10:33:11.986]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:11.986]             }
[10:33:11.986]             else {
[10:33:11.986]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:11.986]             }
[10:33:11.986]             {
[10:33:11.986]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:11.986]                   0L) {
[10:33:11.986]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:11.986]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:11.986]                   base::options(opts)
[10:33:11.986]                 }
[10:33:11.986]                 {
[10:33:11.986]                   {
[10:33:11.986]                     NULL
[10:33:11.986]                     RNGkind("Mersenne-Twister")
[10:33:11.986]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:11.986]                       inherits = FALSE)
[10:33:11.986]                   }
[10:33:11.986]                   options(future.plan = NULL)
[10:33:11.986]                   if (is.na(NA_character_)) 
[10:33:11.986]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:11.986]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:11.986]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:11.986]                     .init = FALSE)
[10:33:11.986]                 }
[10:33:11.986]             }
[10:33:11.986]         }
[10:33:11.986]     })
[10:33:11.986]     if (TRUE) {
[10:33:11.986]         base::sink(type = "output", split = FALSE)
[10:33:11.986]         if (TRUE) {
[10:33:11.986]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:11.986]         }
[10:33:11.986]         else {
[10:33:11.986]             ...future.result["stdout"] <- base::list(NULL)
[10:33:11.986]         }
[10:33:11.986]         base::close(...future.stdout)
[10:33:11.986]         ...future.stdout <- NULL
[10:33:11.986]     }
[10:33:11.986]     ...future.result$conditions <- ...future.conditions
[10:33:11.986]     ...future.result$finished <- base::Sys.time()
[10:33:11.986]     ...future.result
[10:33:11.986] }
[10:33:11.988] assign_globals() ...
[10:33:11.988] List of 1
[10:33:11.988]  $ ii: int 1
[10:33:11.988]  - attr(*, "where")=List of 1
[10:33:11.988]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:11.988]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:11.988]  - attr(*, "resolved")= logi TRUE
[10:33:11.988]  - attr(*, "total_size")= num 56
[10:33:11.988]  - attr(*, "already-done")= logi TRUE
[10:33:11.990] - copied ‘ii’ to environment
[10:33:11.990] assign_globals() ... done
[10:33:11.991] plan(): Setting new future strategy stack:
[10:33:11.991] List of future strategies:
[10:33:11.991] 1. sequential:
[10:33:11.991]    - args: function (..., envir = parent.frame())
[10:33:11.991]    - tweaked: FALSE
[10:33:11.991]    - call: NULL
[10:33:11.991] plan(): nbrOfWorkers() = 1
[10:33:11.992] plan(): Setting new future strategy stack:
[10:33:11.992] List of future strategies:
[10:33:11.992] 1. sequential:
[10:33:11.992]    - args: function (..., envir = parent.frame())
[10:33:11.992]    - tweaked: FALSE
[10:33:11.992]    - call: plan(strategy)
[10:33:11.992] plan(): nbrOfWorkers() = 1
[10:33:11.992] SequentialFuture started (and completed)
[10:33:11.992] - Launch lazy future ... done
[10:33:11.992] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:11.993] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:11.993] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:11.994] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:11.994] Searching for globals ... DONE
[10:33:11.994] Resolving globals: TRUE
[10:33:11.995] Resolving any globals that are futures ...
[10:33:11.995] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:11.995] Resolving any globals that are futures ... DONE
[10:33:11.995] Resolving futures part of globals (recursively) ...
[10:33:11.995] resolve() on list ...
[10:33:11.995]  recursive: 99
[10:33:11.995]  length: 1
[10:33:11.996]  elements: ‘ii’
[10:33:11.996]  length: 0 (resolved future 1)
[10:33:11.996] resolve() on list ... DONE
[10:33:11.996] - globals: [1] ‘ii’
[10:33:11.996] Resolving futures part of globals (recursively) ... DONE
[10:33:11.996] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:11.996] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:11.996] - globals: [1] ‘ii’
[10:33:11.997] 
[10:33:11.997] getGlobalsAndPackages() ... DONE
[10:33:11.997] run() for ‘Future’ ...
[10:33:11.997] - state: ‘created’
[10:33:11.997] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:11.997] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:11.997] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:11.998]   - Field: ‘label’
[10:33:11.998]   - Field: ‘local’
[10:33:11.998]   - Field: ‘owner’
[10:33:11.998]   - Field: ‘envir’
[10:33:11.998]   - Field: ‘packages’
[10:33:11.998]   - Field: ‘gc’
[10:33:11.998]   - Field: ‘conditions’
[10:33:11.998]   - Field: ‘expr’
[10:33:11.998]   - Field: ‘uuid’
[10:33:11.998]   - Field: ‘seed’
[10:33:11.998]   - Field: ‘version’
[10:33:11.998]   - Field: ‘result’
[10:33:11.999]   - Field: ‘asynchronous’
[10:33:11.999]   - Field: ‘calls’
[10:33:11.999]   - Field: ‘globals’
[10:33:11.999]   - Field: ‘stdout’
[10:33:11.999]   - Field: ‘earlySignal’
[10:33:11.999]   - Field: ‘lazy’
[10:33:11.999]   - Field: ‘state’
[10:33:11.999] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:11.999] - Launch lazy future ...
[10:33:11.999] Packages needed by the future expression (n = 0): <none>
[10:33:12.000] Packages needed by future strategies (n = 0): <none>
[10:33:12.000] {
[10:33:12.000]     {
[10:33:12.000]         {
[10:33:12.000]             ...future.startTime <- base::Sys.time()
[10:33:12.000]             {
[10:33:12.000]                 {
[10:33:12.000]                   {
[10:33:12.000]                     base::local({
[10:33:12.000]                       has_future <- base::requireNamespace("future", 
[10:33:12.000]                         quietly = TRUE)
[10:33:12.000]                       if (has_future) {
[10:33:12.000]                         ns <- base::getNamespace("future")
[10:33:12.000]                         version <- ns[[".package"]][["version"]]
[10:33:12.000]                         if (is.null(version)) 
[10:33:12.000]                           version <- utils::packageVersion("future")
[10:33:12.000]                       }
[10:33:12.000]                       else {
[10:33:12.000]                         version <- NULL
[10:33:12.000]                       }
[10:33:12.000]                       if (!has_future || version < "1.8.0") {
[10:33:12.000]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.000]                           "", base::R.version$version.string), 
[10:33:12.000]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.000]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.000]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.000]                             "release", "version")], collapse = " "), 
[10:33:12.000]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.000]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.000]                           info)
[10:33:12.000]                         info <- base::paste(info, collapse = "; ")
[10:33:12.000]                         if (!has_future) {
[10:33:12.000]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.000]                             info)
[10:33:12.000]                         }
[10:33:12.000]                         else {
[10:33:12.000]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.000]                             info, version)
[10:33:12.000]                         }
[10:33:12.000]                         base::stop(msg)
[10:33:12.000]                       }
[10:33:12.000]                     })
[10:33:12.000]                   }
[10:33:12.000]                   ...future.strategy.old <- future::plan("list")
[10:33:12.000]                   options(future.plan = NULL)
[10:33:12.000]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.000]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.000]                 }
[10:33:12.000]                 ...future.workdir <- getwd()
[10:33:12.000]             }
[10:33:12.000]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.000]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.000]         }
[10:33:12.000]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.000]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.000]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.000]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.000]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.000]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.000]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.000]             base::names(...future.oldOptions))
[10:33:12.000]     }
[10:33:12.000]     if (FALSE) {
[10:33:12.000]     }
[10:33:12.000]     else {
[10:33:12.000]         if (TRUE) {
[10:33:12.000]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.000]                 open = "w")
[10:33:12.000]         }
[10:33:12.000]         else {
[10:33:12.000]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.000]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.000]         }
[10:33:12.000]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.000]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.000]             base::sink(type = "output", split = FALSE)
[10:33:12.000]             base::close(...future.stdout)
[10:33:12.000]         }, add = TRUE)
[10:33:12.000]     }
[10:33:12.000]     ...future.frame <- base::sys.nframe()
[10:33:12.000]     ...future.conditions <- base::list()
[10:33:12.000]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.000]     if (FALSE) {
[10:33:12.000]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.000]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.000]     }
[10:33:12.000]     ...future.result <- base::tryCatch({
[10:33:12.000]         base::withCallingHandlers({
[10:33:12.000]             ...future.value <- base::withVisible(base::local({
[10:33:12.000]                 b <- a * ii
[10:33:12.000]                 a <- 0
[10:33:12.000]                 b
[10:33:12.000]             }))
[10:33:12.000]             future::FutureResult(value = ...future.value$value, 
[10:33:12.000]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.000]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.000]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.000]                     ...future.globalenv.names))
[10:33:12.000]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.000]         }, condition = base::local({
[10:33:12.000]             c <- base::c
[10:33:12.000]             inherits <- base::inherits
[10:33:12.000]             invokeRestart <- base::invokeRestart
[10:33:12.000]             length <- base::length
[10:33:12.000]             list <- base::list
[10:33:12.000]             seq.int <- base::seq.int
[10:33:12.000]             signalCondition <- base::signalCondition
[10:33:12.000]             sys.calls <- base::sys.calls
[10:33:12.000]             `[[` <- base::`[[`
[10:33:12.000]             `+` <- base::`+`
[10:33:12.000]             `<<-` <- base::`<<-`
[10:33:12.000]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.000]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.000]                   3L)]
[10:33:12.000]             }
[10:33:12.000]             function(cond) {
[10:33:12.000]                 is_error <- inherits(cond, "error")
[10:33:12.000]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.000]                   NULL)
[10:33:12.000]                 if (is_error) {
[10:33:12.000]                   sessionInformation <- function() {
[10:33:12.000]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.000]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.000]                       search = base::search(), system = base::Sys.info())
[10:33:12.000]                   }
[10:33:12.000]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.000]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.000]                     cond$call), session = sessionInformation(), 
[10:33:12.000]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.000]                   signalCondition(cond)
[10:33:12.000]                 }
[10:33:12.000]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.000]                 "immediateCondition"))) {
[10:33:12.000]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.000]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.000]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.000]                   if (TRUE && !signal) {
[10:33:12.000]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.000]                     {
[10:33:12.000]                       inherits <- base::inherits
[10:33:12.000]                       invokeRestart <- base::invokeRestart
[10:33:12.000]                       is.null <- base::is.null
[10:33:12.000]                       muffled <- FALSE
[10:33:12.000]                       if (inherits(cond, "message")) {
[10:33:12.000]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.000]                         if (muffled) 
[10:33:12.000]                           invokeRestart("muffleMessage")
[10:33:12.000]                       }
[10:33:12.000]                       else if (inherits(cond, "warning")) {
[10:33:12.000]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.000]                         if (muffled) 
[10:33:12.000]                           invokeRestart("muffleWarning")
[10:33:12.000]                       }
[10:33:12.000]                       else if (inherits(cond, "condition")) {
[10:33:12.000]                         if (!is.null(pattern)) {
[10:33:12.000]                           computeRestarts <- base::computeRestarts
[10:33:12.000]                           grepl <- base::grepl
[10:33:12.000]                           restarts <- computeRestarts(cond)
[10:33:12.000]                           for (restart in restarts) {
[10:33:12.000]                             name <- restart$name
[10:33:12.000]                             if (is.null(name)) 
[10:33:12.000]                               next
[10:33:12.000]                             if (!grepl(pattern, name)) 
[10:33:12.000]                               next
[10:33:12.000]                             invokeRestart(restart)
[10:33:12.000]                             muffled <- TRUE
[10:33:12.000]                             break
[10:33:12.000]                           }
[10:33:12.000]                         }
[10:33:12.000]                       }
[10:33:12.000]                       invisible(muffled)
[10:33:12.000]                     }
[10:33:12.000]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.000]                   }
[10:33:12.000]                 }
[10:33:12.000]                 else {
[10:33:12.000]                   if (TRUE) {
[10:33:12.000]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.000]                     {
[10:33:12.000]                       inherits <- base::inherits
[10:33:12.000]                       invokeRestart <- base::invokeRestart
[10:33:12.000]                       is.null <- base::is.null
[10:33:12.000]                       muffled <- FALSE
[10:33:12.000]                       if (inherits(cond, "message")) {
[10:33:12.000]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.000]                         if (muffled) 
[10:33:12.000]                           invokeRestart("muffleMessage")
[10:33:12.000]                       }
[10:33:12.000]                       else if (inherits(cond, "warning")) {
[10:33:12.000]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.000]                         if (muffled) 
[10:33:12.000]                           invokeRestart("muffleWarning")
[10:33:12.000]                       }
[10:33:12.000]                       else if (inherits(cond, "condition")) {
[10:33:12.000]                         if (!is.null(pattern)) {
[10:33:12.000]                           computeRestarts <- base::computeRestarts
[10:33:12.000]                           grepl <- base::grepl
[10:33:12.000]                           restarts <- computeRestarts(cond)
[10:33:12.000]                           for (restart in restarts) {
[10:33:12.000]                             name <- restart$name
[10:33:12.000]                             if (is.null(name)) 
[10:33:12.000]                               next
[10:33:12.000]                             if (!grepl(pattern, name)) 
[10:33:12.000]                               next
[10:33:12.000]                             invokeRestart(restart)
[10:33:12.000]                             muffled <- TRUE
[10:33:12.000]                             break
[10:33:12.000]                           }
[10:33:12.000]                         }
[10:33:12.000]                       }
[10:33:12.000]                       invisible(muffled)
[10:33:12.000]                     }
[10:33:12.000]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.000]                   }
[10:33:12.000]                 }
[10:33:12.000]             }
[10:33:12.000]         }))
[10:33:12.000]     }, error = function(ex) {
[10:33:12.000]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.000]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.000]                 ...future.rng), started = ...future.startTime, 
[10:33:12.000]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.000]             version = "1.8"), class = "FutureResult")
[10:33:12.000]     }, finally = {
[10:33:12.000]         if (!identical(...future.workdir, getwd())) 
[10:33:12.000]             setwd(...future.workdir)
[10:33:12.000]         {
[10:33:12.000]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.000]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.000]             }
[10:33:12.000]             base::options(...future.oldOptions)
[10:33:12.000]             if (.Platform$OS.type == "windows") {
[10:33:12.000]                 old_names <- names(...future.oldEnvVars)
[10:33:12.000]                 envs <- base::Sys.getenv()
[10:33:12.000]                 names <- names(envs)
[10:33:12.000]                 common <- intersect(names, old_names)
[10:33:12.000]                 added <- setdiff(names, old_names)
[10:33:12.000]                 removed <- setdiff(old_names, names)
[10:33:12.000]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.000]                   envs[common]]
[10:33:12.000]                 NAMES <- toupper(changed)
[10:33:12.000]                 args <- list()
[10:33:12.000]                 for (kk in seq_along(NAMES)) {
[10:33:12.000]                   name <- changed[[kk]]
[10:33:12.000]                   NAME <- NAMES[[kk]]
[10:33:12.000]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.000]                     next
[10:33:12.000]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.000]                 }
[10:33:12.000]                 NAMES <- toupper(added)
[10:33:12.000]                 for (kk in seq_along(NAMES)) {
[10:33:12.000]                   name <- added[[kk]]
[10:33:12.000]                   NAME <- NAMES[[kk]]
[10:33:12.000]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.000]                     next
[10:33:12.000]                   args[[name]] <- ""
[10:33:12.000]                 }
[10:33:12.000]                 NAMES <- toupper(removed)
[10:33:12.000]                 for (kk in seq_along(NAMES)) {
[10:33:12.000]                   name <- removed[[kk]]
[10:33:12.000]                   NAME <- NAMES[[kk]]
[10:33:12.000]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.000]                     next
[10:33:12.000]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.000]                 }
[10:33:12.000]                 if (length(args) > 0) 
[10:33:12.000]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.000]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.000]             }
[10:33:12.000]             else {
[10:33:12.000]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.000]             }
[10:33:12.000]             {
[10:33:12.000]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.000]                   0L) {
[10:33:12.000]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.000]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.000]                   base::options(opts)
[10:33:12.000]                 }
[10:33:12.000]                 {
[10:33:12.000]                   {
[10:33:12.000]                     NULL
[10:33:12.000]                     RNGkind("Mersenne-Twister")
[10:33:12.000]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.000]                       inherits = FALSE)
[10:33:12.000]                   }
[10:33:12.000]                   options(future.plan = NULL)
[10:33:12.000]                   if (is.na(NA_character_)) 
[10:33:12.000]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.000]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.000]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.000]                     .init = FALSE)
[10:33:12.000]                 }
[10:33:12.000]             }
[10:33:12.000]         }
[10:33:12.000]     })
[10:33:12.000]     if (TRUE) {
[10:33:12.000]         base::sink(type = "output", split = FALSE)
[10:33:12.000]         if (TRUE) {
[10:33:12.000]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.000]         }
[10:33:12.000]         else {
[10:33:12.000]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.000]         }
[10:33:12.000]         base::close(...future.stdout)
[10:33:12.000]         ...future.stdout <- NULL
[10:33:12.000]     }
[10:33:12.000]     ...future.result$conditions <- ...future.conditions
[10:33:12.000]     ...future.result$finished <- base::Sys.time()
[10:33:12.000]     ...future.result
[10:33:12.000] }
[10:33:12.001] assign_globals() ...
[10:33:12.002] List of 1
[10:33:12.002]  $ ii: int 2
[10:33:12.002]  - attr(*, "where")=List of 1
[10:33:12.002]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:12.002]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.002]  - attr(*, "resolved")= logi TRUE
[10:33:12.002]  - attr(*, "total_size")= num 56
[10:33:12.002]  - attr(*, "already-done")= logi TRUE
[10:33:12.004] - copied ‘ii’ to environment
[10:33:12.004] assign_globals() ... done
[10:33:12.004] plan(): Setting new future strategy stack:
[10:33:12.004] List of future strategies:
[10:33:12.004] 1. sequential:
[10:33:12.004]    - args: function (..., envir = parent.frame())
[10:33:12.004]    - tweaked: FALSE
[10:33:12.004]    - call: NULL
[10:33:12.005] plan(): nbrOfWorkers() = 1
[10:33:12.005] plan(): Setting new future strategy stack:
[10:33:12.005] List of future strategies:
[10:33:12.005] 1. sequential:
[10:33:12.005]    - args: function (..., envir = parent.frame())
[10:33:12.005]    - tweaked: FALSE
[10:33:12.005]    - call: plan(strategy)
[10:33:12.006] plan(): nbrOfWorkers() = 1
[10:33:12.006] SequentialFuture started (and completed)
[10:33:12.006] - Launch lazy future ... done
[10:33:12.006] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.006] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.007] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.010] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:12.010] Searching for globals ... DONE
[10:33:12.010] Resolving globals: TRUE
[10:33:12.010] Resolving any globals that are futures ...
[10:33:12.010] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:12.010] Resolving any globals that are futures ... DONE
[10:33:12.011] Resolving futures part of globals (recursively) ...
[10:33:12.011] resolve() on list ...
[10:33:12.011]  recursive: 99
[10:33:12.011]  length: 1
[10:33:12.011]  elements: ‘ii’
[10:33:12.012]  length: 0 (resolved future 1)
[10:33:12.012] resolve() on list ... DONE
[10:33:12.012] - globals: [1] ‘ii’
[10:33:12.012] Resolving futures part of globals (recursively) ... DONE
[10:33:12.012] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:12.012] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:12.012] - globals: [1] ‘ii’
[10:33:12.013] 
[10:33:12.013] getGlobalsAndPackages() ... DONE
[10:33:12.013] run() for ‘Future’ ...
[10:33:12.013] - state: ‘created’
[10:33:12.013] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.013] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.014] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.014]   - Field: ‘label’
[10:33:12.014]   - Field: ‘local’
[10:33:12.014]   - Field: ‘owner’
[10:33:12.014]   - Field: ‘envir’
[10:33:12.014]   - Field: ‘packages’
[10:33:12.014]   - Field: ‘gc’
[10:33:12.014]   - Field: ‘conditions’
[10:33:12.014]   - Field: ‘expr’
[10:33:12.014]   - Field: ‘uuid’
[10:33:12.014]   - Field: ‘seed’
[10:33:12.015]   - Field: ‘version’
[10:33:12.015]   - Field: ‘result’
[10:33:12.015]   - Field: ‘asynchronous’
[10:33:12.015]   - Field: ‘calls’
[10:33:12.015]   - Field: ‘globals’
[10:33:12.015]   - Field: ‘stdout’
[10:33:12.015]   - Field: ‘earlySignal’
[10:33:12.015]   - Field: ‘lazy’
[10:33:12.015]   - Field: ‘state’
[10:33:12.015] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.015] - Launch lazy future ...
[10:33:12.016] Packages needed by the future expression (n = 0): <none>
[10:33:12.016] Packages needed by future strategies (n = 0): <none>
[10:33:12.016] {
[10:33:12.016]     {
[10:33:12.016]         {
[10:33:12.016]             ...future.startTime <- base::Sys.time()
[10:33:12.016]             {
[10:33:12.016]                 {
[10:33:12.016]                   {
[10:33:12.016]                     base::local({
[10:33:12.016]                       has_future <- base::requireNamespace("future", 
[10:33:12.016]                         quietly = TRUE)
[10:33:12.016]                       if (has_future) {
[10:33:12.016]                         ns <- base::getNamespace("future")
[10:33:12.016]                         version <- ns[[".package"]][["version"]]
[10:33:12.016]                         if (is.null(version)) 
[10:33:12.016]                           version <- utils::packageVersion("future")
[10:33:12.016]                       }
[10:33:12.016]                       else {
[10:33:12.016]                         version <- NULL
[10:33:12.016]                       }
[10:33:12.016]                       if (!has_future || version < "1.8.0") {
[10:33:12.016]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.016]                           "", base::R.version$version.string), 
[10:33:12.016]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.016]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.016]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.016]                             "release", "version")], collapse = " "), 
[10:33:12.016]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.016]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.016]                           info)
[10:33:12.016]                         info <- base::paste(info, collapse = "; ")
[10:33:12.016]                         if (!has_future) {
[10:33:12.016]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.016]                             info)
[10:33:12.016]                         }
[10:33:12.016]                         else {
[10:33:12.016]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.016]                             info, version)
[10:33:12.016]                         }
[10:33:12.016]                         base::stop(msg)
[10:33:12.016]                       }
[10:33:12.016]                     })
[10:33:12.016]                   }
[10:33:12.016]                   ...future.strategy.old <- future::plan("list")
[10:33:12.016]                   options(future.plan = NULL)
[10:33:12.016]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.016]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.016]                 }
[10:33:12.016]                 ...future.workdir <- getwd()
[10:33:12.016]             }
[10:33:12.016]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.016]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.016]         }
[10:33:12.016]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.016]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.016]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.016]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.016]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.016]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.016]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.016]             base::names(...future.oldOptions))
[10:33:12.016]     }
[10:33:12.016]     if (FALSE) {
[10:33:12.016]     }
[10:33:12.016]     else {
[10:33:12.016]         if (TRUE) {
[10:33:12.016]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.016]                 open = "w")
[10:33:12.016]         }
[10:33:12.016]         else {
[10:33:12.016]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.016]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.016]         }
[10:33:12.016]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.016]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.016]             base::sink(type = "output", split = FALSE)
[10:33:12.016]             base::close(...future.stdout)
[10:33:12.016]         }, add = TRUE)
[10:33:12.016]     }
[10:33:12.016]     ...future.frame <- base::sys.nframe()
[10:33:12.016]     ...future.conditions <- base::list()
[10:33:12.016]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.016]     if (FALSE) {
[10:33:12.016]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.016]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.016]     }
[10:33:12.016]     ...future.result <- base::tryCatch({
[10:33:12.016]         base::withCallingHandlers({
[10:33:12.016]             ...future.value <- base::withVisible(base::local({
[10:33:12.016]                 b <- a * ii
[10:33:12.016]                 a <- 0
[10:33:12.016]                 b
[10:33:12.016]             }))
[10:33:12.016]             future::FutureResult(value = ...future.value$value, 
[10:33:12.016]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.016]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.016]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.016]                     ...future.globalenv.names))
[10:33:12.016]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.016]         }, condition = base::local({
[10:33:12.016]             c <- base::c
[10:33:12.016]             inherits <- base::inherits
[10:33:12.016]             invokeRestart <- base::invokeRestart
[10:33:12.016]             length <- base::length
[10:33:12.016]             list <- base::list
[10:33:12.016]             seq.int <- base::seq.int
[10:33:12.016]             signalCondition <- base::signalCondition
[10:33:12.016]             sys.calls <- base::sys.calls
[10:33:12.016]             `[[` <- base::`[[`
[10:33:12.016]             `+` <- base::`+`
[10:33:12.016]             `<<-` <- base::`<<-`
[10:33:12.016]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.016]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.016]                   3L)]
[10:33:12.016]             }
[10:33:12.016]             function(cond) {
[10:33:12.016]                 is_error <- inherits(cond, "error")
[10:33:12.016]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.016]                   NULL)
[10:33:12.016]                 if (is_error) {
[10:33:12.016]                   sessionInformation <- function() {
[10:33:12.016]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.016]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.016]                       search = base::search(), system = base::Sys.info())
[10:33:12.016]                   }
[10:33:12.016]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.016]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.016]                     cond$call), session = sessionInformation(), 
[10:33:12.016]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.016]                   signalCondition(cond)
[10:33:12.016]                 }
[10:33:12.016]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.016]                 "immediateCondition"))) {
[10:33:12.016]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.016]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.016]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.016]                   if (TRUE && !signal) {
[10:33:12.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.016]                     {
[10:33:12.016]                       inherits <- base::inherits
[10:33:12.016]                       invokeRestart <- base::invokeRestart
[10:33:12.016]                       is.null <- base::is.null
[10:33:12.016]                       muffled <- FALSE
[10:33:12.016]                       if (inherits(cond, "message")) {
[10:33:12.016]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.016]                         if (muffled) 
[10:33:12.016]                           invokeRestart("muffleMessage")
[10:33:12.016]                       }
[10:33:12.016]                       else if (inherits(cond, "warning")) {
[10:33:12.016]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.016]                         if (muffled) 
[10:33:12.016]                           invokeRestart("muffleWarning")
[10:33:12.016]                       }
[10:33:12.016]                       else if (inherits(cond, "condition")) {
[10:33:12.016]                         if (!is.null(pattern)) {
[10:33:12.016]                           computeRestarts <- base::computeRestarts
[10:33:12.016]                           grepl <- base::grepl
[10:33:12.016]                           restarts <- computeRestarts(cond)
[10:33:12.016]                           for (restart in restarts) {
[10:33:12.016]                             name <- restart$name
[10:33:12.016]                             if (is.null(name)) 
[10:33:12.016]                               next
[10:33:12.016]                             if (!grepl(pattern, name)) 
[10:33:12.016]                               next
[10:33:12.016]                             invokeRestart(restart)
[10:33:12.016]                             muffled <- TRUE
[10:33:12.016]                             break
[10:33:12.016]                           }
[10:33:12.016]                         }
[10:33:12.016]                       }
[10:33:12.016]                       invisible(muffled)
[10:33:12.016]                     }
[10:33:12.016]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.016]                   }
[10:33:12.016]                 }
[10:33:12.016]                 else {
[10:33:12.016]                   if (TRUE) {
[10:33:12.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.016]                     {
[10:33:12.016]                       inherits <- base::inherits
[10:33:12.016]                       invokeRestart <- base::invokeRestart
[10:33:12.016]                       is.null <- base::is.null
[10:33:12.016]                       muffled <- FALSE
[10:33:12.016]                       if (inherits(cond, "message")) {
[10:33:12.016]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.016]                         if (muffled) 
[10:33:12.016]                           invokeRestart("muffleMessage")
[10:33:12.016]                       }
[10:33:12.016]                       else if (inherits(cond, "warning")) {
[10:33:12.016]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.016]                         if (muffled) 
[10:33:12.016]                           invokeRestart("muffleWarning")
[10:33:12.016]                       }
[10:33:12.016]                       else if (inherits(cond, "condition")) {
[10:33:12.016]                         if (!is.null(pattern)) {
[10:33:12.016]                           computeRestarts <- base::computeRestarts
[10:33:12.016]                           grepl <- base::grepl
[10:33:12.016]                           restarts <- computeRestarts(cond)
[10:33:12.016]                           for (restart in restarts) {
[10:33:12.016]                             name <- restart$name
[10:33:12.016]                             if (is.null(name)) 
[10:33:12.016]                               next
[10:33:12.016]                             if (!grepl(pattern, name)) 
[10:33:12.016]                               next
[10:33:12.016]                             invokeRestart(restart)
[10:33:12.016]                             muffled <- TRUE
[10:33:12.016]                             break
[10:33:12.016]                           }
[10:33:12.016]                         }
[10:33:12.016]                       }
[10:33:12.016]                       invisible(muffled)
[10:33:12.016]                     }
[10:33:12.016]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.016]                   }
[10:33:12.016]                 }
[10:33:12.016]             }
[10:33:12.016]         }))
[10:33:12.016]     }, error = function(ex) {
[10:33:12.016]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.016]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.016]                 ...future.rng), started = ...future.startTime, 
[10:33:12.016]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.016]             version = "1.8"), class = "FutureResult")
[10:33:12.016]     }, finally = {
[10:33:12.016]         if (!identical(...future.workdir, getwd())) 
[10:33:12.016]             setwd(...future.workdir)
[10:33:12.016]         {
[10:33:12.016]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.016]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.016]             }
[10:33:12.016]             base::options(...future.oldOptions)
[10:33:12.016]             if (.Platform$OS.type == "windows") {
[10:33:12.016]                 old_names <- names(...future.oldEnvVars)
[10:33:12.016]                 envs <- base::Sys.getenv()
[10:33:12.016]                 names <- names(envs)
[10:33:12.016]                 common <- intersect(names, old_names)
[10:33:12.016]                 added <- setdiff(names, old_names)
[10:33:12.016]                 removed <- setdiff(old_names, names)
[10:33:12.016]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.016]                   envs[common]]
[10:33:12.016]                 NAMES <- toupper(changed)
[10:33:12.016]                 args <- list()
[10:33:12.016]                 for (kk in seq_along(NAMES)) {
[10:33:12.016]                   name <- changed[[kk]]
[10:33:12.016]                   NAME <- NAMES[[kk]]
[10:33:12.016]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.016]                     next
[10:33:12.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.016]                 }
[10:33:12.016]                 NAMES <- toupper(added)
[10:33:12.016]                 for (kk in seq_along(NAMES)) {
[10:33:12.016]                   name <- added[[kk]]
[10:33:12.016]                   NAME <- NAMES[[kk]]
[10:33:12.016]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.016]                     next
[10:33:12.016]                   args[[name]] <- ""
[10:33:12.016]                 }
[10:33:12.016]                 NAMES <- toupper(removed)
[10:33:12.016]                 for (kk in seq_along(NAMES)) {
[10:33:12.016]                   name <- removed[[kk]]
[10:33:12.016]                   NAME <- NAMES[[kk]]
[10:33:12.016]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.016]                     next
[10:33:12.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.016]                 }
[10:33:12.016]                 if (length(args) > 0) 
[10:33:12.016]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.016]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.016]             }
[10:33:12.016]             else {
[10:33:12.016]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.016]             }
[10:33:12.016]             {
[10:33:12.016]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.016]                   0L) {
[10:33:12.016]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.016]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.016]                   base::options(opts)
[10:33:12.016]                 }
[10:33:12.016]                 {
[10:33:12.016]                   {
[10:33:12.016]                     NULL
[10:33:12.016]                     RNGkind("Mersenne-Twister")
[10:33:12.016]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.016]                       inherits = FALSE)
[10:33:12.016]                   }
[10:33:12.016]                   options(future.plan = NULL)
[10:33:12.016]                   if (is.na(NA_character_)) 
[10:33:12.016]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.016]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.016]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.016]                     .init = FALSE)
[10:33:12.016]                 }
[10:33:12.016]             }
[10:33:12.016]         }
[10:33:12.016]     })
[10:33:12.016]     if (TRUE) {
[10:33:12.016]         base::sink(type = "output", split = FALSE)
[10:33:12.016]         if (TRUE) {
[10:33:12.016]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.016]         }
[10:33:12.016]         else {
[10:33:12.016]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.016]         }
[10:33:12.016]         base::close(...future.stdout)
[10:33:12.016]         ...future.stdout <- NULL
[10:33:12.016]     }
[10:33:12.016]     ...future.result$conditions <- ...future.conditions
[10:33:12.016]     ...future.result$finished <- base::Sys.time()
[10:33:12.016]     ...future.result
[10:33:12.016] }
[10:33:12.018] assign_globals() ...
[10:33:12.018] List of 1
[10:33:12.018]  $ ii: int 3
[10:33:12.018]  - attr(*, "where")=List of 1
[10:33:12.018]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:12.018]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.018]  - attr(*, "resolved")= logi TRUE
[10:33:12.018]  - attr(*, "total_size")= num 56
[10:33:12.018]  - attr(*, "already-done")= logi TRUE
[10:33:12.020] - copied ‘ii’ to environment
[10:33:12.020] assign_globals() ... done
[10:33:12.021] plan(): Setting new future strategy stack:
[10:33:12.021] List of future strategies:
[10:33:12.021] 1. sequential:
[10:33:12.021]    - args: function (..., envir = parent.frame())
[10:33:12.021]    - tweaked: FALSE
[10:33:12.021]    - call: NULL
[10:33:12.021] plan(): nbrOfWorkers() = 1
[10:33:12.022] plan(): Setting new future strategy stack:
[10:33:12.022] List of future strategies:
[10:33:12.022] 1. sequential:
[10:33:12.022]    - args: function (..., envir = parent.frame())
[10:33:12.022]    - tweaked: FALSE
[10:33:12.022]    - call: plan(strategy)
[10:33:12.022] plan(): nbrOfWorkers() = 1
[10:33:12.022] SequentialFuture started (and completed)
[10:33:12.022] - Launch lazy future ... done
[10:33:12.022] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.023] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.024] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.025] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:12.025] Searching for globals ... DONE
[10:33:12.025] Resolving globals: TRUE
[10:33:12.025] Resolving any globals that are futures ...
[10:33:12.025] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:12.025] Resolving any globals that are futures ... DONE
[10:33:12.026] Resolving futures part of globals (recursively) ...
[10:33:12.026] resolve() on list ...
[10:33:12.026]  recursive: 99
[10:33:12.026]  length: 1
[10:33:12.026]  elements: ‘ii’
[10:33:12.026]  length: 0 (resolved future 1)
[10:33:12.026] resolve() on list ... DONE
[10:33:12.026] - globals: [1] ‘ii’
[10:33:12.027] Resolving futures part of globals (recursively) ... DONE
[10:33:12.027] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:12.027] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:12.027] - globals: [1] ‘ii’
[10:33:12.027] 
[10:33:12.027] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.028] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.028] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.029] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:12.029] Searching for globals ... DONE
[10:33:12.030] Resolving globals: TRUE
[10:33:12.030] Resolving any globals that are futures ...
[10:33:12.030] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:12.030] Resolving any globals that are futures ... DONE
[10:33:12.030] Resolving futures part of globals (recursively) ...
[10:33:12.030] resolve() on list ...
[10:33:12.030]  recursive: 99
[10:33:12.030]  length: 1
[10:33:12.031]  elements: ‘ii’
[10:33:12.031]  length: 0 (resolved future 1)
[10:33:12.031] resolve() on list ... DONE
[10:33:12.031] - globals: [1] ‘ii’
[10:33:12.031] Resolving futures part of globals (recursively) ... DONE
[10:33:12.031] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:12.031] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:12.032] - globals: [1] ‘ii’
[10:33:12.032] 
[10:33:12.032] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.032] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.032] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.035] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:12.035] Searching for globals ... DONE
[10:33:12.035] Resolving globals: TRUE
[10:33:12.035] Resolving any globals that are futures ...
[10:33:12.035] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:12.035] Resolving any globals that are futures ... DONE
[10:33:12.036] Resolving futures part of globals (recursively) ...
[10:33:12.036] resolve() on list ...
[10:33:12.036]  recursive: 99
[10:33:12.036]  length: 1
[10:33:12.036]  elements: ‘ii’
[10:33:12.036]  length: 0 (resolved future 1)
[10:33:12.036] resolve() on list ... DONE
[10:33:12.036] - globals: [1] ‘ii’
[10:33:12.037] Resolving futures part of globals (recursively) ... DONE
[10:33:12.037] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:12.037] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:12.037] - globals: [1] ‘ii’
[10:33:12.037] 
[10:33:12.037] getGlobalsAndPackages() ... DONE
[10:33:12.038] run() for ‘Future’ ...
[10:33:12.038] - state: ‘created’
[10:33:12.038] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.038] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.038] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.038]   - Field: ‘label’
[10:33:12.038]   - Field: ‘local’
[10:33:12.038]   - Field: ‘owner’
[10:33:12.038]   - Field: ‘envir’
[10:33:12.039]   - Field: ‘packages’
[10:33:12.039]   - Field: ‘gc’
[10:33:12.039]   - Field: ‘conditions’
[10:33:12.039]   - Field: ‘expr’
[10:33:12.039]   - Field: ‘uuid’
[10:33:12.039]   - Field: ‘seed’
[10:33:12.039]   - Field: ‘version’
[10:33:12.039]   - Field: ‘result’
[10:33:12.039]   - Field: ‘asynchronous’
[10:33:12.039]   - Field: ‘calls’
[10:33:12.039]   - Field: ‘globals’
[10:33:12.040]   - Field: ‘stdout’
[10:33:12.040]   - Field: ‘earlySignal’
[10:33:12.040]   - Field: ‘lazy’
[10:33:12.040]   - Field: ‘state’
[10:33:12.040] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.040] - Launch lazy future ...
[10:33:12.040] Packages needed by the future expression (n = 0): <none>
[10:33:12.040] Packages needed by future strategies (n = 0): <none>
[10:33:12.041] {
[10:33:12.041]     {
[10:33:12.041]         {
[10:33:12.041]             ...future.startTime <- base::Sys.time()
[10:33:12.041]             {
[10:33:12.041]                 {
[10:33:12.041]                   {
[10:33:12.041]                     base::local({
[10:33:12.041]                       has_future <- base::requireNamespace("future", 
[10:33:12.041]                         quietly = TRUE)
[10:33:12.041]                       if (has_future) {
[10:33:12.041]                         ns <- base::getNamespace("future")
[10:33:12.041]                         version <- ns[[".package"]][["version"]]
[10:33:12.041]                         if (is.null(version)) 
[10:33:12.041]                           version <- utils::packageVersion("future")
[10:33:12.041]                       }
[10:33:12.041]                       else {
[10:33:12.041]                         version <- NULL
[10:33:12.041]                       }
[10:33:12.041]                       if (!has_future || version < "1.8.0") {
[10:33:12.041]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.041]                           "", base::R.version$version.string), 
[10:33:12.041]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.041]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.041]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.041]                             "release", "version")], collapse = " "), 
[10:33:12.041]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.041]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.041]                           info)
[10:33:12.041]                         info <- base::paste(info, collapse = "; ")
[10:33:12.041]                         if (!has_future) {
[10:33:12.041]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.041]                             info)
[10:33:12.041]                         }
[10:33:12.041]                         else {
[10:33:12.041]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.041]                             info, version)
[10:33:12.041]                         }
[10:33:12.041]                         base::stop(msg)
[10:33:12.041]                       }
[10:33:12.041]                     })
[10:33:12.041]                   }
[10:33:12.041]                   ...future.strategy.old <- future::plan("list")
[10:33:12.041]                   options(future.plan = NULL)
[10:33:12.041]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.041]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.041]                 }
[10:33:12.041]                 ...future.workdir <- getwd()
[10:33:12.041]             }
[10:33:12.041]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.041]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.041]         }
[10:33:12.041]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.041]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.041]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.041]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.041]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.041]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.041]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.041]             base::names(...future.oldOptions))
[10:33:12.041]     }
[10:33:12.041]     if (FALSE) {
[10:33:12.041]     }
[10:33:12.041]     else {
[10:33:12.041]         if (TRUE) {
[10:33:12.041]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.041]                 open = "w")
[10:33:12.041]         }
[10:33:12.041]         else {
[10:33:12.041]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.041]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.041]         }
[10:33:12.041]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.041]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.041]             base::sink(type = "output", split = FALSE)
[10:33:12.041]             base::close(...future.stdout)
[10:33:12.041]         }, add = TRUE)
[10:33:12.041]     }
[10:33:12.041]     ...future.frame <- base::sys.nframe()
[10:33:12.041]     ...future.conditions <- base::list()
[10:33:12.041]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.041]     if (FALSE) {
[10:33:12.041]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.041]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.041]     }
[10:33:12.041]     ...future.result <- base::tryCatch({
[10:33:12.041]         base::withCallingHandlers({
[10:33:12.041]             ...future.value <- base::withVisible(base::local({
[10:33:12.041]                 b <- a * ii
[10:33:12.041]                 a <- 0
[10:33:12.041]                 b
[10:33:12.041]             }))
[10:33:12.041]             future::FutureResult(value = ...future.value$value, 
[10:33:12.041]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.041]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.041]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.041]                     ...future.globalenv.names))
[10:33:12.041]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.041]         }, condition = base::local({
[10:33:12.041]             c <- base::c
[10:33:12.041]             inherits <- base::inherits
[10:33:12.041]             invokeRestart <- base::invokeRestart
[10:33:12.041]             length <- base::length
[10:33:12.041]             list <- base::list
[10:33:12.041]             seq.int <- base::seq.int
[10:33:12.041]             signalCondition <- base::signalCondition
[10:33:12.041]             sys.calls <- base::sys.calls
[10:33:12.041]             `[[` <- base::`[[`
[10:33:12.041]             `+` <- base::`+`
[10:33:12.041]             `<<-` <- base::`<<-`
[10:33:12.041]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.041]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.041]                   3L)]
[10:33:12.041]             }
[10:33:12.041]             function(cond) {
[10:33:12.041]                 is_error <- inherits(cond, "error")
[10:33:12.041]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.041]                   NULL)
[10:33:12.041]                 if (is_error) {
[10:33:12.041]                   sessionInformation <- function() {
[10:33:12.041]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.041]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.041]                       search = base::search(), system = base::Sys.info())
[10:33:12.041]                   }
[10:33:12.041]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.041]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.041]                     cond$call), session = sessionInformation(), 
[10:33:12.041]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.041]                   signalCondition(cond)
[10:33:12.041]                 }
[10:33:12.041]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.041]                 "immediateCondition"))) {
[10:33:12.041]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.041]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.041]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.041]                   if (TRUE && !signal) {
[10:33:12.041]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.041]                     {
[10:33:12.041]                       inherits <- base::inherits
[10:33:12.041]                       invokeRestart <- base::invokeRestart
[10:33:12.041]                       is.null <- base::is.null
[10:33:12.041]                       muffled <- FALSE
[10:33:12.041]                       if (inherits(cond, "message")) {
[10:33:12.041]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.041]                         if (muffled) 
[10:33:12.041]                           invokeRestart("muffleMessage")
[10:33:12.041]                       }
[10:33:12.041]                       else if (inherits(cond, "warning")) {
[10:33:12.041]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.041]                         if (muffled) 
[10:33:12.041]                           invokeRestart("muffleWarning")
[10:33:12.041]                       }
[10:33:12.041]                       else if (inherits(cond, "condition")) {
[10:33:12.041]                         if (!is.null(pattern)) {
[10:33:12.041]                           computeRestarts <- base::computeRestarts
[10:33:12.041]                           grepl <- base::grepl
[10:33:12.041]                           restarts <- computeRestarts(cond)
[10:33:12.041]                           for (restart in restarts) {
[10:33:12.041]                             name <- restart$name
[10:33:12.041]                             if (is.null(name)) 
[10:33:12.041]                               next
[10:33:12.041]                             if (!grepl(pattern, name)) 
[10:33:12.041]                               next
[10:33:12.041]                             invokeRestart(restart)
[10:33:12.041]                             muffled <- TRUE
[10:33:12.041]                             break
[10:33:12.041]                           }
[10:33:12.041]                         }
[10:33:12.041]                       }
[10:33:12.041]                       invisible(muffled)
[10:33:12.041]                     }
[10:33:12.041]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.041]                   }
[10:33:12.041]                 }
[10:33:12.041]                 else {
[10:33:12.041]                   if (TRUE) {
[10:33:12.041]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.041]                     {
[10:33:12.041]                       inherits <- base::inherits
[10:33:12.041]                       invokeRestart <- base::invokeRestart
[10:33:12.041]                       is.null <- base::is.null
[10:33:12.041]                       muffled <- FALSE
[10:33:12.041]                       if (inherits(cond, "message")) {
[10:33:12.041]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.041]                         if (muffled) 
[10:33:12.041]                           invokeRestart("muffleMessage")
[10:33:12.041]                       }
[10:33:12.041]                       else if (inherits(cond, "warning")) {
[10:33:12.041]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.041]                         if (muffled) 
[10:33:12.041]                           invokeRestart("muffleWarning")
[10:33:12.041]                       }
[10:33:12.041]                       else if (inherits(cond, "condition")) {
[10:33:12.041]                         if (!is.null(pattern)) {
[10:33:12.041]                           computeRestarts <- base::computeRestarts
[10:33:12.041]                           grepl <- base::grepl
[10:33:12.041]                           restarts <- computeRestarts(cond)
[10:33:12.041]                           for (restart in restarts) {
[10:33:12.041]                             name <- restart$name
[10:33:12.041]                             if (is.null(name)) 
[10:33:12.041]                               next
[10:33:12.041]                             if (!grepl(pattern, name)) 
[10:33:12.041]                               next
[10:33:12.041]                             invokeRestart(restart)
[10:33:12.041]                             muffled <- TRUE
[10:33:12.041]                             break
[10:33:12.041]                           }
[10:33:12.041]                         }
[10:33:12.041]                       }
[10:33:12.041]                       invisible(muffled)
[10:33:12.041]                     }
[10:33:12.041]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.041]                   }
[10:33:12.041]                 }
[10:33:12.041]             }
[10:33:12.041]         }))
[10:33:12.041]     }, error = function(ex) {
[10:33:12.041]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.041]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.041]                 ...future.rng), started = ...future.startTime, 
[10:33:12.041]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.041]             version = "1.8"), class = "FutureResult")
[10:33:12.041]     }, finally = {
[10:33:12.041]         if (!identical(...future.workdir, getwd())) 
[10:33:12.041]             setwd(...future.workdir)
[10:33:12.041]         {
[10:33:12.041]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.041]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.041]             }
[10:33:12.041]             base::options(...future.oldOptions)
[10:33:12.041]             if (.Platform$OS.type == "windows") {
[10:33:12.041]                 old_names <- names(...future.oldEnvVars)
[10:33:12.041]                 envs <- base::Sys.getenv()
[10:33:12.041]                 names <- names(envs)
[10:33:12.041]                 common <- intersect(names, old_names)
[10:33:12.041]                 added <- setdiff(names, old_names)
[10:33:12.041]                 removed <- setdiff(old_names, names)
[10:33:12.041]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.041]                   envs[common]]
[10:33:12.041]                 NAMES <- toupper(changed)
[10:33:12.041]                 args <- list()
[10:33:12.041]                 for (kk in seq_along(NAMES)) {
[10:33:12.041]                   name <- changed[[kk]]
[10:33:12.041]                   NAME <- NAMES[[kk]]
[10:33:12.041]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.041]                     next
[10:33:12.041]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.041]                 }
[10:33:12.041]                 NAMES <- toupper(added)
[10:33:12.041]                 for (kk in seq_along(NAMES)) {
[10:33:12.041]                   name <- added[[kk]]
[10:33:12.041]                   NAME <- NAMES[[kk]]
[10:33:12.041]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.041]                     next
[10:33:12.041]                   args[[name]] <- ""
[10:33:12.041]                 }
[10:33:12.041]                 NAMES <- toupper(removed)
[10:33:12.041]                 for (kk in seq_along(NAMES)) {
[10:33:12.041]                   name <- removed[[kk]]
[10:33:12.041]                   NAME <- NAMES[[kk]]
[10:33:12.041]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.041]                     next
[10:33:12.041]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.041]                 }
[10:33:12.041]                 if (length(args) > 0) 
[10:33:12.041]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.041]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.041]             }
[10:33:12.041]             else {
[10:33:12.041]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.041]             }
[10:33:12.041]             {
[10:33:12.041]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.041]                   0L) {
[10:33:12.041]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.041]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.041]                   base::options(opts)
[10:33:12.041]                 }
[10:33:12.041]                 {
[10:33:12.041]                   {
[10:33:12.041]                     NULL
[10:33:12.041]                     RNGkind("Mersenne-Twister")
[10:33:12.041]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.041]                       inherits = FALSE)
[10:33:12.041]                   }
[10:33:12.041]                   options(future.plan = NULL)
[10:33:12.041]                   if (is.na(NA_character_)) 
[10:33:12.041]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.041]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.041]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.041]                     .init = FALSE)
[10:33:12.041]                 }
[10:33:12.041]             }
[10:33:12.041]         }
[10:33:12.041]     })
[10:33:12.041]     if (TRUE) {
[10:33:12.041]         base::sink(type = "output", split = FALSE)
[10:33:12.041]         if (TRUE) {
[10:33:12.041]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.041]         }
[10:33:12.041]         else {
[10:33:12.041]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.041]         }
[10:33:12.041]         base::close(...future.stdout)
[10:33:12.041]         ...future.stdout <- NULL
[10:33:12.041]     }
[10:33:12.041]     ...future.result$conditions <- ...future.conditions
[10:33:12.041]     ...future.result$finished <- base::Sys.time()
[10:33:12.041]     ...future.result
[10:33:12.041] }
[10:33:12.042] assign_globals() ...
[10:33:12.042] List of 1
[10:33:12.042]  $ ii: int 1
[10:33:12.042]  - attr(*, "where")=List of 1
[10:33:12.042]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:12.042]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.042]  - attr(*, "resolved")= logi TRUE
[10:33:12.042]  - attr(*, "total_size")= num 56
[10:33:12.042]  - attr(*, "already-done")= logi TRUE
[10:33:12.045] - copied ‘ii’ to environment
[10:33:12.045] assign_globals() ... done
[10:33:12.045] plan(): Setting new future strategy stack:
[10:33:12.045] List of future strategies:
[10:33:12.045] 1. sequential:
[10:33:12.045]    - args: function (..., envir = parent.frame())
[10:33:12.045]    - tweaked: FALSE
[10:33:12.045]    - call: NULL
[10:33:12.045] plan(): nbrOfWorkers() = 1
[10:33:12.046] plan(): Setting new future strategy stack:
[10:33:12.046] List of future strategies:
[10:33:12.046] 1. sequential:
[10:33:12.046]    - args: function (..., envir = parent.frame())
[10:33:12.046]    - tweaked: FALSE
[10:33:12.046]    - call: plan(strategy)
[10:33:12.047] plan(): nbrOfWorkers() = 1
[10:33:12.047] SequentialFuture started (and completed)
[10:33:12.047] signalConditions() ...
[10:33:12.047]  - include = ‘immediateCondition’
[10:33:12.047]  - exclude = 
[10:33:12.047]  - resignal = FALSE
[10:33:12.047]  - Number of conditions: 1
[10:33:12.047] signalConditions() ... done
[10:33:12.048] - Launch lazy future ... done
[10:33:12.048] run() for ‘SequentialFuture’ ... done
[10:33:12.048] signalConditions() ...
[10:33:12.048]  - include = ‘immediateCondition’
[10:33:12.048]  - exclude = 
[10:33:12.048]  - resignal = FALSE
[10:33:12.048]  - Number of conditions: 1
[10:33:12.048] signalConditions() ... done
[10:33:12.048] Future state: ‘finished’
[10:33:12.048] signalConditions() ...
[10:33:12.048]  - include = ‘condition’
[10:33:12.049]  - exclude = ‘immediateCondition’
[10:33:12.049]  - resignal = TRUE
[10:33:12.049]  - Number of conditions: 1
[10:33:12.049]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:33:12.049] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a * ii ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a * ii ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "c3bfbccbe859" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 10:33:12"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.063] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.063] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.064] 
[10:33:12.064] Searching for globals ... DONE
[10:33:12.064] - globals: [0] <none>
[10:33:12.064] getGlobalsAndPackages() ... DONE
[10:33:12.064] run() for ‘Future’ ...
[10:33:12.064] - state: ‘created’
[10:33:12.065] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.065] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.065] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.065]   - Field: ‘label’
[10:33:12.065]   - Field: ‘local’
[10:33:12.065]   - Field: ‘owner’
[10:33:12.065]   - Field: ‘envir’
[10:33:12.065]   - Field: ‘packages’
[10:33:12.066]   - Field: ‘gc’
[10:33:12.066]   - Field: ‘conditions’
[10:33:12.066]   - Field: ‘expr’
[10:33:12.066]   - Field: ‘uuid’
[10:33:12.066]   - Field: ‘seed’
[10:33:12.066]   - Field: ‘version’
[10:33:12.066]   - Field: ‘result’
[10:33:12.066]   - Field: ‘asynchronous’
[10:33:12.066]   - Field: ‘calls’
[10:33:12.066]   - Field: ‘globals’
[10:33:12.066]   - Field: ‘stdout’
[10:33:12.066]   - Field: ‘earlySignal’
[10:33:12.067]   - Field: ‘lazy’
[10:33:12.067]   - Field: ‘state’
[10:33:12.067] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.067] - Launch lazy future ...
[10:33:12.067] Packages needed by the future expression (n = 0): <none>
[10:33:12.067] Packages needed by future strategies (n = 0): <none>
[10:33:12.067] {
[10:33:12.067]     {
[10:33:12.067]         {
[10:33:12.067]             ...future.startTime <- base::Sys.time()
[10:33:12.067]             {
[10:33:12.067]                 {
[10:33:12.067]                   {
[10:33:12.067]                     base::local({
[10:33:12.067]                       has_future <- base::requireNamespace("future", 
[10:33:12.067]                         quietly = TRUE)
[10:33:12.067]                       if (has_future) {
[10:33:12.067]                         ns <- base::getNamespace("future")
[10:33:12.067]                         version <- ns[[".package"]][["version"]]
[10:33:12.067]                         if (is.null(version)) 
[10:33:12.067]                           version <- utils::packageVersion("future")
[10:33:12.067]                       }
[10:33:12.067]                       else {
[10:33:12.067]                         version <- NULL
[10:33:12.067]                       }
[10:33:12.067]                       if (!has_future || version < "1.8.0") {
[10:33:12.067]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.067]                           "", base::R.version$version.string), 
[10:33:12.067]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.067]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.067]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.067]                             "release", "version")], collapse = " "), 
[10:33:12.067]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.067]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.067]                           info)
[10:33:12.067]                         info <- base::paste(info, collapse = "; ")
[10:33:12.067]                         if (!has_future) {
[10:33:12.067]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.067]                             info)
[10:33:12.067]                         }
[10:33:12.067]                         else {
[10:33:12.067]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.067]                             info, version)
[10:33:12.067]                         }
[10:33:12.067]                         base::stop(msg)
[10:33:12.067]                       }
[10:33:12.067]                     })
[10:33:12.067]                   }
[10:33:12.067]                   ...future.strategy.old <- future::plan("list")
[10:33:12.067]                   options(future.plan = NULL)
[10:33:12.067]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.067]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.067]                 }
[10:33:12.067]                 ...future.workdir <- getwd()
[10:33:12.067]             }
[10:33:12.067]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.067]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.067]         }
[10:33:12.067]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.067]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.067]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.067]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.067]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.067]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.067]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.067]             base::names(...future.oldOptions))
[10:33:12.067]     }
[10:33:12.067]     if (FALSE) {
[10:33:12.067]     }
[10:33:12.067]     else {
[10:33:12.067]         if (TRUE) {
[10:33:12.067]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.067]                 open = "w")
[10:33:12.067]         }
[10:33:12.067]         else {
[10:33:12.067]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.067]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.067]         }
[10:33:12.067]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.067]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.067]             base::sink(type = "output", split = FALSE)
[10:33:12.067]             base::close(...future.stdout)
[10:33:12.067]         }, add = TRUE)
[10:33:12.067]     }
[10:33:12.067]     ...future.frame <- base::sys.nframe()
[10:33:12.067]     ...future.conditions <- base::list()
[10:33:12.067]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.067]     if (FALSE) {
[10:33:12.067]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.067]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.067]     }
[10:33:12.067]     ...future.result <- base::tryCatch({
[10:33:12.067]         base::withCallingHandlers({
[10:33:12.067]             ...future.value <- base::withVisible(base::local(1))
[10:33:12.067]             future::FutureResult(value = ...future.value$value, 
[10:33:12.067]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.067]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.067]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.067]                     ...future.globalenv.names))
[10:33:12.067]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.067]         }, condition = base::local({
[10:33:12.067]             c <- base::c
[10:33:12.067]             inherits <- base::inherits
[10:33:12.067]             invokeRestart <- base::invokeRestart
[10:33:12.067]             length <- base::length
[10:33:12.067]             list <- base::list
[10:33:12.067]             seq.int <- base::seq.int
[10:33:12.067]             signalCondition <- base::signalCondition
[10:33:12.067]             sys.calls <- base::sys.calls
[10:33:12.067]             `[[` <- base::`[[`
[10:33:12.067]             `+` <- base::`+`
[10:33:12.067]             `<<-` <- base::`<<-`
[10:33:12.067]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.067]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.067]                   3L)]
[10:33:12.067]             }
[10:33:12.067]             function(cond) {
[10:33:12.067]                 is_error <- inherits(cond, "error")
[10:33:12.067]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.067]                   NULL)
[10:33:12.067]                 if (is_error) {
[10:33:12.067]                   sessionInformation <- function() {
[10:33:12.067]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.067]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.067]                       search = base::search(), system = base::Sys.info())
[10:33:12.067]                   }
[10:33:12.067]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.067]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.067]                     cond$call), session = sessionInformation(), 
[10:33:12.067]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.067]                   signalCondition(cond)
[10:33:12.067]                 }
[10:33:12.067]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.067]                 "immediateCondition"))) {
[10:33:12.067]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.067]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.067]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.067]                   if (TRUE && !signal) {
[10:33:12.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.067]                     {
[10:33:12.067]                       inherits <- base::inherits
[10:33:12.067]                       invokeRestart <- base::invokeRestart
[10:33:12.067]                       is.null <- base::is.null
[10:33:12.067]                       muffled <- FALSE
[10:33:12.067]                       if (inherits(cond, "message")) {
[10:33:12.067]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.067]                         if (muffled) 
[10:33:12.067]                           invokeRestart("muffleMessage")
[10:33:12.067]                       }
[10:33:12.067]                       else if (inherits(cond, "warning")) {
[10:33:12.067]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.067]                         if (muffled) 
[10:33:12.067]                           invokeRestart("muffleWarning")
[10:33:12.067]                       }
[10:33:12.067]                       else if (inherits(cond, "condition")) {
[10:33:12.067]                         if (!is.null(pattern)) {
[10:33:12.067]                           computeRestarts <- base::computeRestarts
[10:33:12.067]                           grepl <- base::grepl
[10:33:12.067]                           restarts <- computeRestarts(cond)
[10:33:12.067]                           for (restart in restarts) {
[10:33:12.067]                             name <- restart$name
[10:33:12.067]                             if (is.null(name)) 
[10:33:12.067]                               next
[10:33:12.067]                             if (!grepl(pattern, name)) 
[10:33:12.067]                               next
[10:33:12.067]                             invokeRestart(restart)
[10:33:12.067]                             muffled <- TRUE
[10:33:12.067]                             break
[10:33:12.067]                           }
[10:33:12.067]                         }
[10:33:12.067]                       }
[10:33:12.067]                       invisible(muffled)
[10:33:12.067]                     }
[10:33:12.067]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.067]                   }
[10:33:12.067]                 }
[10:33:12.067]                 else {
[10:33:12.067]                   if (TRUE) {
[10:33:12.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.067]                     {
[10:33:12.067]                       inherits <- base::inherits
[10:33:12.067]                       invokeRestart <- base::invokeRestart
[10:33:12.067]                       is.null <- base::is.null
[10:33:12.067]                       muffled <- FALSE
[10:33:12.067]                       if (inherits(cond, "message")) {
[10:33:12.067]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.067]                         if (muffled) 
[10:33:12.067]                           invokeRestart("muffleMessage")
[10:33:12.067]                       }
[10:33:12.067]                       else if (inherits(cond, "warning")) {
[10:33:12.067]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.067]                         if (muffled) 
[10:33:12.067]                           invokeRestart("muffleWarning")
[10:33:12.067]                       }
[10:33:12.067]                       else if (inherits(cond, "condition")) {
[10:33:12.067]                         if (!is.null(pattern)) {
[10:33:12.067]                           computeRestarts <- base::computeRestarts
[10:33:12.067]                           grepl <- base::grepl
[10:33:12.067]                           restarts <- computeRestarts(cond)
[10:33:12.067]                           for (restart in restarts) {
[10:33:12.067]                             name <- restart$name
[10:33:12.067]                             if (is.null(name)) 
[10:33:12.067]                               next
[10:33:12.067]                             if (!grepl(pattern, name)) 
[10:33:12.067]                               next
[10:33:12.067]                             invokeRestart(restart)
[10:33:12.067]                             muffled <- TRUE
[10:33:12.067]                             break
[10:33:12.067]                           }
[10:33:12.067]                         }
[10:33:12.067]                       }
[10:33:12.067]                       invisible(muffled)
[10:33:12.067]                     }
[10:33:12.067]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.067]                   }
[10:33:12.067]                 }
[10:33:12.067]             }
[10:33:12.067]         }))
[10:33:12.067]     }, error = function(ex) {
[10:33:12.067]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.067]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.067]                 ...future.rng), started = ...future.startTime, 
[10:33:12.067]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.067]             version = "1.8"), class = "FutureResult")
[10:33:12.067]     }, finally = {
[10:33:12.067]         if (!identical(...future.workdir, getwd())) 
[10:33:12.067]             setwd(...future.workdir)
[10:33:12.067]         {
[10:33:12.067]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.067]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.067]             }
[10:33:12.067]             base::options(...future.oldOptions)
[10:33:12.067]             if (.Platform$OS.type == "windows") {
[10:33:12.067]                 old_names <- names(...future.oldEnvVars)
[10:33:12.067]                 envs <- base::Sys.getenv()
[10:33:12.067]                 names <- names(envs)
[10:33:12.067]                 common <- intersect(names, old_names)
[10:33:12.067]                 added <- setdiff(names, old_names)
[10:33:12.067]                 removed <- setdiff(old_names, names)
[10:33:12.067]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.067]                   envs[common]]
[10:33:12.067]                 NAMES <- toupper(changed)
[10:33:12.067]                 args <- list()
[10:33:12.067]                 for (kk in seq_along(NAMES)) {
[10:33:12.067]                   name <- changed[[kk]]
[10:33:12.067]                   NAME <- NAMES[[kk]]
[10:33:12.067]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.067]                     next
[10:33:12.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.067]                 }
[10:33:12.067]                 NAMES <- toupper(added)
[10:33:12.067]                 for (kk in seq_along(NAMES)) {
[10:33:12.067]                   name <- added[[kk]]
[10:33:12.067]                   NAME <- NAMES[[kk]]
[10:33:12.067]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.067]                     next
[10:33:12.067]                   args[[name]] <- ""
[10:33:12.067]                 }
[10:33:12.067]                 NAMES <- toupper(removed)
[10:33:12.067]                 for (kk in seq_along(NAMES)) {
[10:33:12.067]                   name <- removed[[kk]]
[10:33:12.067]                   NAME <- NAMES[[kk]]
[10:33:12.067]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.067]                     next
[10:33:12.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.067]                 }
[10:33:12.067]                 if (length(args) > 0) 
[10:33:12.067]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.067]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.067]             }
[10:33:12.067]             else {
[10:33:12.067]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.067]             }
[10:33:12.067]             {
[10:33:12.067]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.067]                   0L) {
[10:33:12.067]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.067]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.067]                   base::options(opts)
[10:33:12.067]                 }
[10:33:12.067]                 {
[10:33:12.067]                   {
[10:33:12.067]                     NULL
[10:33:12.067]                     RNGkind("Mersenne-Twister")
[10:33:12.067]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.067]                       inherits = FALSE)
[10:33:12.067]                   }
[10:33:12.067]                   options(future.plan = NULL)
[10:33:12.067]                   if (is.na(NA_character_)) 
[10:33:12.067]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.067]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.067]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.067]                     .init = FALSE)
[10:33:12.067]                 }
[10:33:12.067]             }
[10:33:12.067]         }
[10:33:12.067]     })
[10:33:12.067]     if (TRUE) {
[10:33:12.067]         base::sink(type = "output", split = FALSE)
[10:33:12.067]         if (TRUE) {
[10:33:12.067]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.067]         }
[10:33:12.067]         else {
[10:33:12.067]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.067]         }
[10:33:12.067]         base::close(...future.stdout)
[10:33:12.067]         ...future.stdout <- NULL
[10:33:12.067]     }
[10:33:12.067]     ...future.result$conditions <- ...future.conditions
[10:33:12.067]     ...future.result$finished <- base::Sys.time()
[10:33:12.067]     ...future.result
[10:33:12.067] }
[10:33:12.069] plan(): Setting new future strategy stack:
[10:33:12.069] List of future strategies:
[10:33:12.069] 1. sequential:
[10:33:12.069]    - args: function (..., envir = parent.frame())
[10:33:12.069]    - tweaked: FALSE
[10:33:12.069]    - call: NULL
[10:33:12.070] plan(): nbrOfWorkers() = 1
[10:33:12.070] plan(): Setting new future strategy stack:
[10:33:12.070] List of future strategies:
[10:33:12.070] 1. sequential:
[10:33:12.070]    - args: function (..., envir = parent.frame())
[10:33:12.070]    - tweaked: FALSE
[10:33:12.070]    - call: plan(strategy)
[10:33:12.071] plan(): nbrOfWorkers() = 1
[10:33:12.071] SequentialFuture started (and completed)
[10:33:12.071] - Launch lazy future ... done
[10:33:12.071] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.071] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.071] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.072] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:12.072] Searching for globals ... DONE
[10:33:12.072] Resolving globals: TRUE
[10:33:12.073] Resolving any globals that are futures ...
[10:33:12.073] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:12.073] Resolving any globals that are futures ... DONE
[10:33:12.073] Resolving futures part of globals (recursively) ...
[10:33:12.073] resolve() on list ...
[10:33:12.073]  recursive: 99
[10:33:12.073]  length: 1
[10:33:12.074]  elements: ‘a’
[10:33:12.074] resolved() for ‘SequentialFuture’ ...
[10:33:12.074] - state: ‘finished’
[10:33:12.074] - run: TRUE
[10:33:12.074] - result: ‘FutureResult’
[10:33:12.074] resolved() for ‘SequentialFuture’ ... done
[10:33:12.074] Future #1
[10:33:12.075] resolved() for ‘SequentialFuture’ ...
[10:33:12.075] - state: ‘finished’
[10:33:12.075] - run: TRUE
[10:33:12.075] - result: ‘FutureResult’
[10:33:12.075] resolved() for ‘SequentialFuture’ ... done
[10:33:12.075] A SequentialFuture was resolved
[10:33:12.075]  length: 0 (resolved future 1)
[10:33:12.075] resolve() on list ... DONE
[10:33:12.075] - globals: [1] ‘a’
[10:33:12.075] Resolving futures part of globals (recursively) ... DONE
[10:33:12.076] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[10:33:12.076] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[10:33:12.077] - globals: [1] ‘a’
[10:33:12.077] - packages: [1] ‘future’
[10:33:12.077] getGlobalsAndPackages() ... DONE
[10:33:12.077] run() for ‘Future’ ...
[10:33:12.077] - state: ‘created’
[10:33:12.077] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.077] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.078] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.078]   - Field: ‘label’
[10:33:12.078]   - Field: ‘local’
[10:33:12.078]   - Field: ‘owner’
[10:33:12.078]   - Field: ‘envir’
[10:33:12.078]   - Field: ‘packages’
[10:33:12.078]   - Field: ‘gc’
[10:33:12.078]   - Field: ‘conditions’
[10:33:12.078]   - Field: ‘expr’
[10:33:12.078]   - Field: ‘uuid’
[10:33:12.078]   - Field: ‘seed’
[10:33:12.079]   - Field: ‘version’
[10:33:12.079]   - Field: ‘result’
[10:33:12.079]   - Field: ‘asynchronous’
[10:33:12.079]   - Field: ‘calls’
[10:33:12.079]   - Field: ‘globals’
[10:33:12.079]   - Field: ‘stdout’
[10:33:12.079]   - Field: ‘earlySignal’
[10:33:12.079]   - Field: ‘lazy’
[10:33:12.079]   - Field: ‘state’
[10:33:12.079] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.079] - Launch lazy future ...
[10:33:12.080] Packages needed by the future expression (n = 1): ‘future’
[10:33:12.080] Packages needed by future strategies (n = 0): <none>
[10:33:12.080] {
[10:33:12.080]     {
[10:33:12.080]         {
[10:33:12.080]             ...future.startTime <- base::Sys.time()
[10:33:12.080]             {
[10:33:12.080]                 {
[10:33:12.080]                   {
[10:33:12.080]                     {
[10:33:12.080]                       base::local({
[10:33:12.080]                         has_future <- base::requireNamespace("future", 
[10:33:12.080]                           quietly = TRUE)
[10:33:12.080]                         if (has_future) {
[10:33:12.080]                           ns <- base::getNamespace("future")
[10:33:12.080]                           version <- ns[[".package"]][["version"]]
[10:33:12.080]                           if (is.null(version)) 
[10:33:12.080]                             version <- utils::packageVersion("future")
[10:33:12.080]                         }
[10:33:12.080]                         else {
[10:33:12.080]                           version <- NULL
[10:33:12.080]                         }
[10:33:12.080]                         if (!has_future || version < "1.8.0") {
[10:33:12.080]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.080]                             "", base::R.version$version.string), 
[10:33:12.080]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:12.080]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.080]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.080]                               "release", "version")], collapse = " "), 
[10:33:12.080]                             hostname = base::Sys.info()[["nodename"]])
[10:33:12.080]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.080]                             info)
[10:33:12.080]                           info <- base::paste(info, collapse = "; ")
[10:33:12.080]                           if (!has_future) {
[10:33:12.080]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.080]                               info)
[10:33:12.080]                           }
[10:33:12.080]                           else {
[10:33:12.080]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.080]                               info, version)
[10:33:12.080]                           }
[10:33:12.080]                           base::stop(msg)
[10:33:12.080]                         }
[10:33:12.080]                       })
[10:33:12.080]                     }
[10:33:12.080]                     base::local({
[10:33:12.080]                       for (pkg in "future") {
[10:33:12.080]                         base::loadNamespace(pkg)
[10:33:12.080]                         base::library(pkg, character.only = TRUE)
[10:33:12.080]                       }
[10:33:12.080]                     })
[10:33:12.080]                   }
[10:33:12.080]                   ...future.strategy.old <- future::plan("list")
[10:33:12.080]                   options(future.plan = NULL)
[10:33:12.080]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.080]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.080]                 }
[10:33:12.080]                 ...future.workdir <- getwd()
[10:33:12.080]             }
[10:33:12.080]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.080]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.080]         }
[10:33:12.080]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.080]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.080]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.080]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.080]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.080]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.080]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.080]             base::names(...future.oldOptions))
[10:33:12.080]     }
[10:33:12.080]     if (FALSE) {
[10:33:12.080]     }
[10:33:12.080]     else {
[10:33:12.080]         if (TRUE) {
[10:33:12.080]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.080]                 open = "w")
[10:33:12.080]         }
[10:33:12.080]         else {
[10:33:12.080]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.080]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.080]         }
[10:33:12.080]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.080]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.080]             base::sink(type = "output", split = FALSE)
[10:33:12.080]             base::close(...future.stdout)
[10:33:12.080]         }, add = TRUE)
[10:33:12.080]     }
[10:33:12.080]     ...future.frame <- base::sys.nframe()
[10:33:12.080]     ...future.conditions <- base::list()
[10:33:12.080]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.080]     if (FALSE) {
[10:33:12.080]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.080]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.080]     }
[10:33:12.080]     ...future.result <- base::tryCatch({
[10:33:12.080]         base::withCallingHandlers({
[10:33:12.080]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:33:12.080]                 1))
[10:33:12.080]             future::FutureResult(value = ...future.value$value, 
[10:33:12.080]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.080]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.080]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.080]                     ...future.globalenv.names))
[10:33:12.080]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.080]         }, condition = base::local({
[10:33:12.080]             c <- base::c
[10:33:12.080]             inherits <- base::inherits
[10:33:12.080]             invokeRestart <- base::invokeRestart
[10:33:12.080]             length <- base::length
[10:33:12.080]             list <- base::list
[10:33:12.080]             seq.int <- base::seq.int
[10:33:12.080]             signalCondition <- base::signalCondition
[10:33:12.080]             sys.calls <- base::sys.calls
[10:33:12.080]             `[[` <- base::`[[`
[10:33:12.080]             `+` <- base::`+`
[10:33:12.080]             `<<-` <- base::`<<-`
[10:33:12.080]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.080]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.080]                   3L)]
[10:33:12.080]             }
[10:33:12.080]             function(cond) {
[10:33:12.080]                 is_error <- inherits(cond, "error")
[10:33:12.080]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.080]                   NULL)
[10:33:12.080]                 if (is_error) {
[10:33:12.080]                   sessionInformation <- function() {
[10:33:12.080]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.080]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.080]                       search = base::search(), system = base::Sys.info())
[10:33:12.080]                   }
[10:33:12.080]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.080]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.080]                     cond$call), session = sessionInformation(), 
[10:33:12.080]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.080]                   signalCondition(cond)
[10:33:12.080]                 }
[10:33:12.080]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.080]                 "immediateCondition"))) {
[10:33:12.080]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.080]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.080]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.080]                   if (TRUE && !signal) {
[10:33:12.080]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.080]                     {
[10:33:12.080]                       inherits <- base::inherits
[10:33:12.080]                       invokeRestart <- base::invokeRestart
[10:33:12.080]                       is.null <- base::is.null
[10:33:12.080]                       muffled <- FALSE
[10:33:12.080]                       if (inherits(cond, "message")) {
[10:33:12.080]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.080]                         if (muffled) 
[10:33:12.080]                           invokeRestart("muffleMessage")
[10:33:12.080]                       }
[10:33:12.080]                       else if (inherits(cond, "warning")) {
[10:33:12.080]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.080]                         if (muffled) 
[10:33:12.080]                           invokeRestart("muffleWarning")
[10:33:12.080]                       }
[10:33:12.080]                       else if (inherits(cond, "condition")) {
[10:33:12.080]                         if (!is.null(pattern)) {
[10:33:12.080]                           computeRestarts <- base::computeRestarts
[10:33:12.080]                           grepl <- base::grepl
[10:33:12.080]                           restarts <- computeRestarts(cond)
[10:33:12.080]                           for (restart in restarts) {
[10:33:12.080]                             name <- restart$name
[10:33:12.080]                             if (is.null(name)) 
[10:33:12.080]                               next
[10:33:12.080]                             if (!grepl(pattern, name)) 
[10:33:12.080]                               next
[10:33:12.080]                             invokeRestart(restart)
[10:33:12.080]                             muffled <- TRUE
[10:33:12.080]                             break
[10:33:12.080]                           }
[10:33:12.080]                         }
[10:33:12.080]                       }
[10:33:12.080]                       invisible(muffled)
[10:33:12.080]                     }
[10:33:12.080]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.080]                   }
[10:33:12.080]                 }
[10:33:12.080]                 else {
[10:33:12.080]                   if (TRUE) {
[10:33:12.080]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.080]                     {
[10:33:12.080]                       inherits <- base::inherits
[10:33:12.080]                       invokeRestart <- base::invokeRestart
[10:33:12.080]                       is.null <- base::is.null
[10:33:12.080]                       muffled <- FALSE
[10:33:12.080]                       if (inherits(cond, "message")) {
[10:33:12.080]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.080]                         if (muffled) 
[10:33:12.080]                           invokeRestart("muffleMessage")
[10:33:12.080]                       }
[10:33:12.080]                       else if (inherits(cond, "warning")) {
[10:33:12.080]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.080]                         if (muffled) 
[10:33:12.080]                           invokeRestart("muffleWarning")
[10:33:12.080]                       }
[10:33:12.080]                       else if (inherits(cond, "condition")) {
[10:33:12.080]                         if (!is.null(pattern)) {
[10:33:12.080]                           computeRestarts <- base::computeRestarts
[10:33:12.080]                           grepl <- base::grepl
[10:33:12.080]                           restarts <- computeRestarts(cond)
[10:33:12.080]                           for (restart in restarts) {
[10:33:12.080]                             name <- restart$name
[10:33:12.080]                             if (is.null(name)) 
[10:33:12.080]                               next
[10:33:12.080]                             if (!grepl(pattern, name)) 
[10:33:12.080]                               next
[10:33:12.080]                             invokeRestart(restart)
[10:33:12.080]                             muffled <- TRUE
[10:33:12.080]                             break
[10:33:12.080]                           }
[10:33:12.080]                         }
[10:33:12.080]                       }
[10:33:12.080]                       invisible(muffled)
[10:33:12.080]                     }
[10:33:12.080]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.080]                   }
[10:33:12.080]                 }
[10:33:12.080]             }
[10:33:12.080]         }))
[10:33:12.080]     }, error = function(ex) {
[10:33:12.080]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.080]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.080]                 ...future.rng), started = ...future.startTime, 
[10:33:12.080]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.080]             version = "1.8"), class = "FutureResult")
[10:33:12.080]     }, finally = {
[10:33:12.080]         if (!identical(...future.workdir, getwd())) 
[10:33:12.080]             setwd(...future.workdir)
[10:33:12.080]         {
[10:33:12.080]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.080]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.080]             }
[10:33:12.080]             base::options(...future.oldOptions)
[10:33:12.080]             if (.Platform$OS.type == "windows") {
[10:33:12.080]                 old_names <- names(...future.oldEnvVars)
[10:33:12.080]                 envs <- base::Sys.getenv()
[10:33:12.080]                 names <- names(envs)
[10:33:12.080]                 common <- intersect(names, old_names)
[10:33:12.080]                 added <- setdiff(names, old_names)
[10:33:12.080]                 removed <- setdiff(old_names, names)
[10:33:12.080]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.080]                   envs[common]]
[10:33:12.080]                 NAMES <- toupper(changed)
[10:33:12.080]                 args <- list()
[10:33:12.080]                 for (kk in seq_along(NAMES)) {
[10:33:12.080]                   name <- changed[[kk]]
[10:33:12.080]                   NAME <- NAMES[[kk]]
[10:33:12.080]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.080]                     next
[10:33:12.080]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.080]                 }
[10:33:12.080]                 NAMES <- toupper(added)
[10:33:12.080]                 for (kk in seq_along(NAMES)) {
[10:33:12.080]                   name <- added[[kk]]
[10:33:12.080]                   NAME <- NAMES[[kk]]
[10:33:12.080]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.080]                     next
[10:33:12.080]                   args[[name]] <- ""
[10:33:12.080]                 }
[10:33:12.080]                 NAMES <- toupper(removed)
[10:33:12.080]                 for (kk in seq_along(NAMES)) {
[10:33:12.080]                   name <- removed[[kk]]
[10:33:12.080]                   NAME <- NAMES[[kk]]
[10:33:12.080]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.080]                     next
[10:33:12.080]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.080]                 }
[10:33:12.080]                 if (length(args) > 0) 
[10:33:12.080]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.080]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.080]             }
[10:33:12.080]             else {
[10:33:12.080]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.080]             }
[10:33:12.080]             {
[10:33:12.080]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.080]                   0L) {
[10:33:12.080]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.080]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.080]                   base::options(opts)
[10:33:12.080]                 }
[10:33:12.080]                 {
[10:33:12.080]                   {
[10:33:12.080]                     NULL
[10:33:12.080]                     RNGkind("Mersenne-Twister")
[10:33:12.080]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.080]                       inherits = FALSE)
[10:33:12.080]                   }
[10:33:12.080]                   options(future.plan = NULL)
[10:33:12.080]                   if (is.na(NA_character_)) 
[10:33:12.080]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.080]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.080]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.080]                     .init = FALSE)
[10:33:12.080]                 }
[10:33:12.080]             }
[10:33:12.080]         }
[10:33:12.080]     })
[10:33:12.080]     if (TRUE) {
[10:33:12.080]         base::sink(type = "output", split = FALSE)
[10:33:12.080]         if (TRUE) {
[10:33:12.080]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.080]         }
[10:33:12.080]         else {
[10:33:12.080]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.080]         }
[10:33:12.080]         base::close(...future.stdout)
[10:33:12.080]         ...future.stdout <- NULL
[10:33:12.080]     }
[10:33:12.080]     ...future.result$conditions <- ...future.conditions
[10:33:12.080]     ...future.result$finished <- base::Sys.time()
[10:33:12.080]     ...future.result
[10:33:12.080] }
[10:33:12.082] assign_globals() ...
[10:33:12.082] List of 1
[10:33:12.082]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55aa51b09140> 
[10:33:12.082]  - attr(*, "where")=List of 1
[10:33:12.082]   ..$ a:<environment: R_EmptyEnv> 
[10:33:12.082]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.082]  - attr(*, "resolved")= logi TRUE
[10:33:12.082]  - attr(*, "total_size")= num 10424
[10:33:12.082]  - attr(*, "already-done")= logi TRUE
[10:33:12.085] - copied ‘a’ to environment
[10:33:12.085] assign_globals() ... done
[10:33:12.086] plan(): Setting new future strategy stack:
[10:33:12.086] List of future strategies:
[10:33:12.086] 1. sequential:
[10:33:12.086]    - args: function (..., envir = parent.frame())
[10:33:12.086]    - tweaked: FALSE
[10:33:12.086]    - call: NULL
[10:33:12.086] plan(): nbrOfWorkers() = 1
[10:33:12.087] plan(): Setting new future strategy stack:
[10:33:12.087] List of future strategies:
[10:33:12.087] 1. sequential:
[10:33:12.087]    - args: function (..., envir = parent.frame())
[10:33:12.087]    - tweaked: FALSE
[10:33:12.087]    - call: plan(strategy)
[10:33:12.087] plan(): nbrOfWorkers() = 1
[10:33:12.087] SequentialFuture started (and completed)
[10:33:12.088] - Launch lazy future ... done
[10:33:12.088] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.088] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.088] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.089] 
[10:33:12.089] Searching for globals ... DONE
[10:33:12.089] - globals: [0] <none>
[10:33:12.089] getGlobalsAndPackages() ... DONE
[10:33:12.089] run() for ‘Future’ ...
[10:33:12.089] - state: ‘created’
[10:33:12.089] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.090] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.090] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.090]   - Field: ‘label’
[10:33:12.090]   - Field: ‘local’
[10:33:12.090]   - Field: ‘owner’
[10:33:12.090]   - Field: ‘envir’
[10:33:12.090]   - Field: ‘packages’
[10:33:12.090]   - Field: ‘gc’
[10:33:12.090]   - Field: ‘conditions’
[10:33:12.090]   - Field: ‘expr’
[10:33:12.091]   - Field: ‘uuid’
[10:33:12.091]   - Field: ‘seed’
[10:33:12.091]   - Field: ‘version’
[10:33:12.091]   - Field: ‘result’
[10:33:12.091]   - Field: ‘asynchronous’
[10:33:12.091]   - Field: ‘calls’
[10:33:12.091]   - Field: ‘globals’
[10:33:12.091]   - Field: ‘stdout’
[10:33:12.091]   - Field: ‘earlySignal’
[10:33:12.091]   - Field: ‘lazy’
[10:33:12.091]   - Field: ‘state’
[10:33:12.092] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.092] - Launch lazy future ...
[10:33:12.092] Packages needed by the future expression (n = 0): <none>
[10:33:12.092] Packages needed by future strategies (n = 0): <none>
[10:33:12.092] {
[10:33:12.092]     {
[10:33:12.092]         {
[10:33:12.092]             ...future.startTime <- base::Sys.time()
[10:33:12.092]             {
[10:33:12.092]                 {
[10:33:12.092]                   {
[10:33:12.092]                     base::local({
[10:33:12.092]                       has_future <- base::requireNamespace("future", 
[10:33:12.092]                         quietly = TRUE)
[10:33:12.092]                       if (has_future) {
[10:33:12.092]                         ns <- base::getNamespace("future")
[10:33:12.092]                         version <- ns[[".package"]][["version"]]
[10:33:12.092]                         if (is.null(version)) 
[10:33:12.092]                           version <- utils::packageVersion("future")
[10:33:12.092]                       }
[10:33:12.092]                       else {
[10:33:12.092]                         version <- NULL
[10:33:12.092]                       }
[10:33:12.092]                       if (!has_future || version < "1.8.0") {
[10:33:12.092]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.092]                           "", base::R.version$version.string), 
[10:33:12.092]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.092]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.092]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.092]                             "release", "version")], collapse = " "), 
[10:33:12.092]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.092]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.092]                           info)
[10:33:12.092]                         info <- base::paste(info, collapse = "; ")
[10:33:12.092]                         if (!has_future) {
[10:33:12.092]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.092]                             info)
[10:33:12.092]                         }
[10:33:12.092]                         else {
[10:33:12.092]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.092]                             info, version)
[10:33:12.092]                         }
[10:33:12.092]                         base::stop(msg)
[10:33:12.092]                       }
[10:33:12.092]                     })
[10:33:12.092]                   }
[10:33:12.092]                   ...future.strategy.old <- future::plan("list")
[10:33:12.092]                   options(future.plan = NULL)
[10:33:12.092]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.092]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.092]                 }
[10:33:12.092]                 ...future.workdir <- getwd()
[10:33:12.092]             }
[10:33:12.092]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.092]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.092]         }
[10:33:12.092]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.092]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.092]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.092]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.092]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.092]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.092]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.092]             base::names(...future.oldOptions))
[10:33:12.092]     }
[10:33:12.092]     if (FALSE) {
[10:33:12.092]     }
[10:33:12.092]     else {
[10:33:12.092]         if (TRUE) {
[10:33:12.092]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.092]                 open = "w")
[10:33:12.092]         }
[10:33:12.092]         else {
[10:33:12.092]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.092]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.092]         }
[10:33:12.092]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.092]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.092]             base::sink(type = "output", split = FALSE)
[10:33:12.092]             base::close(...future.stdout)
[10:33:12.092]         }, add = TRUE)
[10:33:12.092]     }
[10:33:12.092]     ...future.frame <- base::sys.nframe()
[10:33:12.092]     ...future.conditions <- base::list()
[10:33:12.092]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.092]     if (FALSE) {
[10:33:12.092]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.092]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.092]     }
[10:33:12.092]     ...future.result <- base::tryCatch({
[10:33:12.092]         base::withCallingHandlers({
[10:33:12.092]             ...future.value <- base::withVisible(base::local(1))
[10:33:12.092]             future::FutureResult(value = ...future.value$value, 
[10:33:12.092]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.092]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.092]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.092]                     ...future.globalenv.names))
[10:33:12.092]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.092]         }, condition = base::local({
[10:33:12.092]             c <- base::c
[10:33:12.092]             inherits <- base::inherits
[10:33:12.092]             invokeRestart <- base::invokeRestart
[10:33:12.092]             length <- base::length
[10:33:12.092]             list <- base::list
[10:33:12.092]             seq.int <- base::seq.int
[10:33:12.092]             signalCondition <- base::signalCondition
[10:33:12.092]             sys.calls <- base::sys.calls
[10:33:12.092]             `[[` <- base::`[[`
[10:33:12.092]             `+` <- base::`+`
[10:33:12.092]             `<<-` <- base::`<<-`
[10:33:12.092]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.092]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.092]                   3L)]
[10:33:12.092]             }
[10:33:12.092]             function(cond) {
[10:33:12.092]                 is_error <- inherits(cond, "error")
[10:33:12.092]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.092]                   NULL)
[10:33:12.092]                 if (is_error) {
[10:33:12.092]                   sessionInformation <- function() {
[10:33:12.092]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.092]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.092]                       search = base::search(), system = base::Sys.info())
[10:33:12.092]                   }
[10:33:12.092]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.092]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.092]                     cond$call), session = sessionInformation(), 
[10:33:12.092]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.092]                   signalCondition(cond)
[10:33:12.092]                 }
[10:33:12.092]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.092]                 "immediateCondition"))) {
[10:33:12.092]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.092]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.092]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.092]                   if (TRUE && !signal) {
[10:33:12.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.092]                     {
[10:33:12.092]                       inherits <- base::inherits
[10:33:12.092]                       invokeRestart <- base::invokeRestart
[10:33:12.092]                       is.null <- base::is.null
[10:33:12.092]                       muffled <- FALSE
[10:33:12.092]                       if (inherits(cond, "message")) {
[10:33:12.092]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.092]                         if (muffled) 
[10:33:12.092]                           invokeRestart("muffleMessage")
[10:33:12.092]                       }
[10:33:12.092]                       else if (inherits(cond, "warning")) {
[10:33:12.092]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.092]                         if (muffled) 
[10:33:12.092]                           invokeRestart("muffleWarning")
[10:33:12.092]                       }
[10:33:12.092]                       else if (inherits(cond, "condition")) {
[10:33:12.092]                         if (!is.null(pattern)) {
[10:33:12.092]                           computeRestarts <- base::computeRestarts
[10:33:12.092]                           grepl <- base::grepl
[10:33:12.092]                           restarts <- computeRestarts(cond)
[10:33:12.092]                           for (restart in restarts) {
[10:33:12.092]                             name <- restart$name
[10:33:12.092]                             if (is.null(name)) 
[10:33:12.092]                               next
[10:33:12.092]                             if (!grepl(pattern, name)) 
[10:33:12.092]                               next
[10:33:12.092]                             invokeRestart(restart)
[10:33:12.092]                             muffled <- TRUE
[10:33:12.092]                             break
[10:33:12.092]                           }
[10:33:12.092]                         }
[10:33:12.092]                       }
[10:33:12.092]                       invisible(muffled)
[10:33:12.092]                     }
[10:33:12.092]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.092]                   }
[10:33:12.092]                 }
[10:33:12.092]                 else {
[10:33:12.092]                   if (TRUE) {
[10:33:12.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.092]                     {
[10:33:12.092]                       inherits <- base::inherits
[10:33:12.092]                       invokeRestart <- base::invokeRestart
[10:33:12.092]                       is.null <- base::is.null
[10:33:12.092]                       muffled <- FALSE
[10:33:12.092]                       if (inherits(cond, "message")) {
[10:33:12.092]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.092]                         if (muffled) 
[10:33:12.092]                           invokeRestart("muffleMessage")
[10:33:12.092]                       }
[10:33:12.092]                       else if (inherits(cond, "warning")) {
[10:33:12.092]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.092]                         if (muffled) 
[10:33:12.092]                           invokeRestart("muffleWarning")
[10:33:12.092]                       }
[10:33:12.092]                       else if (inherits(cond, "condition")) {
[10:33:12.092]                         if (!is.null(pattern)) {
[10:33:12.092]                           computeRestarts <- base::computeRestarts
[10:33:12.092]                           grepl <- base::grepl
[10:33:12.092]                           restarts <- computeRestarts(cond)
[10:33:12.092]                           for (restart in restarts) {
[10:33:12.092]                             name <- restart$name
[10:33:12.092]                             if (is.null(name)) 
[10:33:12.092]                               next
[10:33:12.092]                             if (!grepl(pattern, name)) 
[10:33:12.092]                               next
[10:33:12.092]                             invokeRestart(restart)
[10:33:12.092]                             muffled <- TRUE
[10:33:12.092]                             break
[10:33:12.092]                           }
[10:33:12.092]                         }
[10:33:12.092]                       }
[10:33:12.092]                       invisible(muffled)
[10:33:12.092]                     }
[10:33:12.092]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.092]                   }
[10:33:12.092]                 }
[10:33:12.092]             }
[10:33:12.092]         }))
[10:33:12.092]     }, error = function(ex) {
[10:33:12.092]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.092]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.092]                 ...future.rng), started = ...future.startTime, 
[10:33:12.092]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.092]             version = "1.8"), class = "FutureResult")
[10:33:12.092]     }, finally = {
[10:33:12.092]         if (!identical(...future.workdir, getwd())) 
[10:33:12.092]             setwd(...future.workdir)
[10:33:12.092]         {
[10:33:12.092]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.092]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.092]             }
[10:33:12.092]             base::options(...future.oldOptions)
[10:33:12.092]             if (.Platform$OS.type == "windows") {
[10:33:12.092]                 old_names <- names(...future.oldEnvVars)
[10:33:12.092]                 envs <- base::Sys.getenv()
[10:33:12.092]                 names <- names(envs)
[10:33:12.092]                 common <- intersect(names, old_names)
[10:33:12.092]                 added <- setdiff(names, old_names)
[10:33:12.092]                 removed <- setdiff(old_names, names)
[10:33:12.092]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.092]                   envs[common]]
[10:33:12.092]                 NAMES <- toupper(changed)
[10:33:12.092]                 args <- list()
[10:33:12.092]                 for (kk in seq_along(NAMES)) {
[10:33:12.092]                   name <- changed[[kk]]
[10:33:12.092]                   NAME <- NAMES[[kk]]
[10:33:12.092]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.092]                     next
[10:33:12.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.092]                 }
[10:33:12.092]                 NAMES <- toupper(added)
[10:33:12.092]                 for (kk in seq_along(NAMES)) {
[10:33:12.092]                   name <- added[[kk]]
[10:33:12.092]                   NAME <- NAMES[[kk]]
[10:33:12.092]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.092]                     next
[10:33:12.092]                   args[[name]] <- ""
[10:33:12.092]                 }
[10:33:12.092]                 NAMES <- toupper(removed)
[10:33:12.092]                 for (kk in seq_along(NAMES)) {
[10:33:12.092]                   name <- removed[[kk]]
[10:33:12.092]                   NAME <- NAMES[[kk]]
[10:33:12.092]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.092]                     next
[10:33:12.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.092]                 }
[10:33:12.092]                 if (length(args) > 0) 
[10:33:12.092]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.092]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.092]             }
[10:33:12.092]             else {
[10:33:12.092]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.092]             }
[10:33:12.092]             {
[10:33:12.092]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.092]                   0L) {
[10:33:12.092]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.092]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.092]                   base::options(opts)
[10:33:12.092]                 }
[10:33:12.092]                 {
[10:33:12.092]                   {
[10:33:12.092]                     NULL
[10:33:12.092]                     RNGkind("Mersenne-Twister")
[10:33:12.092]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.092]                       inherits = FALSE)
[10:33:12.092]                   }
[10:33:12.092]                   options(future.plan = NULL)
[10:33:12.092]                   if (is.na(NA_character_)) 
[10:33:12.092]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.092]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.092]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.092]                     .init = FALSE)
[10:33:12.092]                 }
[10:33:12.092]             }
[10:33:12.092]         }
[10:33:12.092]     })
[10:33:12.092]     if (TRUE) {
[10:33:12.092]         base::sink(type = "output", split = FALSE)
[10:33:12.092]         if (TRUE) {
[10:33:12.092]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.092]         }
[10:33:12.092]         else {
[10:33:12.092]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.092]         }
[10:33:12.092]         base::close(...future.stdout)
[10:33:12.092]         ...future.stdout <- NULL
[10:33:12.092]     }
[10:33:12.092]     ...future.result$conditions <- ...future.conditions
[10:33:12.092]     ...future.result$finished <- base::Sys.time()
[10:33:12.092]     ...future.result
[10:33:12.092] }
[10:33:12.094] plan(): Setting new future strategy stack:
[10:33:12.094] List of future strategies:
[10:33:12.094] 1. sequential:
[10:33:12.094]    - args: function (..., envir = parent.frame())
[10:33:12.094]    - tweaked: FALSE
[10:33:12.094]    - call: NULL
[10:33:12.094] plan(): nbrOfWorkers() = 1
[10:33:12.095] plan(): Setting new future strategy stack:
[10:33:12.095] List of future strategies:
[10:33:12.095] 1. sequential:
[10:33:12.095]    - args: function (..., envir = parent.frame())
[10:33:12.095]    - tweaked: FALSE
[10:33:12.095]    - call: plan(strategy)
[10:33:12.095] plan(): nbrOfWorkers() = 1
[10:33:12.096] SequentialFuture started (and completed)
[10:33:12.096] - Launch lazy future ... done
[10:33:12.096] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.096] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.096] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.097] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:12.097] Searching for globals ... DONE
[10:33:12.097] Resolving globals: TRUE
[10:33:12.097] Resolving any globals that are futures ...
[10:33:12.097] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:12.097] Resolving any globals that are futures ... DONE
[10:33:12.098] Resolving futures part of globals (recursively) ...
[10:33:12.098] resolve() on list ...
[10:33:12.098]  recursive: 99
[10:33:12.098]  length: 1
[10:33:12.098]  elements: ‘a’
[10:33:12.098] resolved() for ‘SequentialFuture’ ...
[10:33:12.098] - state: ‘finished’
[10:33:12.098] - run: TRUE
[10:33:12.099] - result: ‘FutureResult’
[10:33:12.099] resolved() for ‘SequentialFuture’ ... done
[10:33:12.099] Future #1
[10:33:12.099] resolved() for ‘SequentialFuture’ ...
[10:33:12.099] - state: ‘finished’
[10:33:12.099] - run: TRUE
[10:33:12.099] - result: ‘FutureResult’
[10:33:12.099] resolved() for ‘SequentialFuture’ ... done
[10:33:12.099] A SequentialFuture was resolved
[10:33:12.099]  length: 0 (resolved future 1)
[10:33:12.100] resolve() on list ... DONE
[10:33:12.100] - globals: [1] ‘a’
[10:33:12.100] Resolving futures part of globals (recursively) ... DONE
[10:33:12.100] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[10:33:12.101] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[10:33:12.101] - globals: [1] ‘a’
[10:33:12.101] - packages: [1] ‘future’
[10:33:12.101] getGlobalsAndPackages() ... DONE
[10:33:12.101] run() for ‘Future’ ...
[10:33:12.101] - state: ‘created’
[10:33:12.102] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.102] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.102] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.102]   - Field: ‘label’
[10:33:12.102]   - Field: ‘local’
[10:33:12.102]   - Field: ‘owner’
[10:33:12.102]   - Field: ‘envir’
[10:33:12.102]   - Field: ‘packages’
[10:33:12.102]   - Field: ‘gc’
[10:33:12.103]   - Field: ‘conditions’
[10:33:12.103]   - Field: ‘expr’
[10:33:12.103]   - Field: ‘uuid’
[10:33:12.103]   - Field: ‘seed’
[10:33:12.103]   - Field: ‘version’
[10:33:12.103]   - Field: ‘result’
[10:33:12.103]   - Field: ‘asynchronous’
[10:33:12.103]   - Field: ‘calls’
[10:33:12.103]   - Field: ‘globals’
[10:33:12.103]   - Field: ‘stdout’
[10:33:12.103]   - Field: ‘earlySignal’
[10:33:12.103]   - Field: ‘lazy’
[10:33:12.104]   - Field: ‘state’
[10:33:12.104] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.104] - Launch lazy future ...
[10:33:12.104] Packages needed by the future expression (n = 1): ‘future’
[10:33:12.104] Packages needed by future strategies (n = 0): <none>
[10:33:12.104] {
[10:33:12.104]     {
[10:33:12.104]         {
[10:33:12.104]             ...future.startTime <- base::Sys.time()
[10:33:12.104]             {
[10:33:12.104]                 {
[10:33:12.104]                   {
[10:33:12.104]                     {
[10:33:12.104]                       base::local({
[10:33:12.104]                         has_future <- base::requireNamespace("future", 
[10:33:12.104]                           quietly = TRUE)
[10:33:12.104]                         if (has_future) {
[10:33:12.104]                           ns <- base::getNamespace("future")
[10:33:12.104]                           version <- ns[[".package"]][["version"]]
[10:33:12.104]                           if (is.null(version)) 
[10:33:12.104]                             version <- utils::packageVersion("future")
[10:33:12.104]                         }
[10:33:12.104]                         else {
[10:33:12.104]                           version <- NULL
[10:33:12.104]                         }
[10:33:12.104]                         if (!has_future || version < "1.8.0") {
[10:33:12.104]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.104]                             "", base::R.version$version.string), 
[10:33:12.104]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:12.104]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.104]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.104]                               "release", "version")], collapse = " "), 
[10:33:12.104]                             hostname = base::Sys.info()[["nodename"]])
[10:33:12.104]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.104]                             info)
[10:33:12.104]                           info <- base::paste(info, collapse = "; ")
[10:33:12.104]                           if (!has_future) {
[10:33:12.104]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.104]                               info)
[10:33:12.104]                           }
[10:33:12.104]                           else {
[10:33:12.104]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.104]                               info, version)
[10:33:12.104]                           }
[10:33:12.104]                           base::stop(msg)
[10:33:12.104]                         }
[10:33:12.104]                       })
[10:33:12.104]                     }
[10:33:12.104]                     base::local({
[10:33:12.104]                       for (pkg in "future") {
[10:33:12.104]                         base::loadNamespace(pkg)
[10:33:12.104]                         base::library(pkg, character.only = TRUE)
[10:33:12.104]                       }
[10:33:12.104]                     })
[10:33:12.104]                   }
[10:33:12.104]                   ...future.strategy.old <- future::plan("list")
[10:33:12.104]                   options(future.plan = NULL)
[10:33:12.104]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.104]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.104]                 }
[10:33:12.104]                 ...future.workdir <- getwd()
[10:33:12.104]             }
[10:33:12.104]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.104]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.104]         }
[10:33:12.104]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.104]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.104]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.104]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.104]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.104]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.104]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.104]             base::names(...future.oldOptions))
[10:33:12.104]     }
[10:33:12.104]     if (FALSE) {
[10:33:12.104]     }
[10:33:12.104]     else {
[10:33:12.104]         if (TRUE) {
[10:33:12.104]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.104]                 open = "w")
[10:33:12.104]         }
[10:33:12.104]         else {
[10:33:12.104]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.104]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.104]         }
[10:33:12.104]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.104]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.104]             base::sink(type = "output", split = FALSE)
[10:33:12.104]             base::close(...future.stdout)
[10:33:12.104]         }, add = TRUE)
[10:33:12.104]     }
[10:33:12.104]     ...future.frame <- base::sys.nframe()
[10:33:12.104]     ...future.conditions <- base::list()
[10:33:12.104]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.104]     if (FALSE) {
[10:33:12.104]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.104]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.104]     }
[10:33:12.104]     ...future.result <- base::tryCatch({
[10:33:12.104]         base::withCallingHandlers({
[10:33:12.104]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:33:12.104]                 1))
[10:33:12.104]             future::FutureResult(value = ...future.value$value, 
[10:33:12.104]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.104]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.104]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.104]                     ...future.globalenv.names))
[10:33:12.104]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.104]         }, condition = base::local({
[10:33:12.104]             c <- base::c
[10:33:12.104]             inherits <- base::inherits
[10:33:12.104]             invokeRestart <- base::invokeRestart
[10:33:12.104]             length <- base::length
[10:33:12.104]             list <- base::list
[10:33:12.104]             seq.int <- base::seq.int
[10:33:12.104]             signalCondition <- base::signalCondition
[10:33:12.104]             sys.calls <- base::sys.calls
[10:33:12.104]             `[[` <- base::`[[`
[10:33:12.104]             `+` <- base::`+`
[10:33:12.104]             `<<-` <- base::`<<-`
[10:33:12.104]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.104]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.104]                   3L)]
[10:33:12.104]             }
[10:33:12.104]             function(cond) {
[10:33:12.104]                 is_error <- inherits(cond, "error")
[10:33:12.104]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.104]                   NULL)
[10:33:12.104]                 if (is_error) {
[10:33:12.104]                   sessionInformation <- function() {
[10:33:12.104]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.104]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.104]                       search = base::search(), system = base::Sys.info())
[10:33:12.104]                   }
[10:33:12.104]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.104]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.104]                     cond$call), session = sessionInformation(), 
[10:33:12.104]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.104]                   signalCondition(cond)
[10:33:12.104]                 }
[10:33:12.104]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.104]                 "immediateCondition"))) {
[10:33:12.104]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.104]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.104]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.104]                   if (TRUE && !signal) {
[10:33:12.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.104]                     {
[10:33:12.104]                       inherits <- base::inherits
[10:33:12.104]                       invokeRestart <- base::invokeRestart
[10:33:12.104]                       is.null <- base::is.null
[10:33:12.104]                       muffled <- FALSE
[10:33:12.104]                       if (inherits(cond, "message")) {
[10:33:12.104]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.104]                         if (muffled) 
[10:33:12.104]                           invokeRestart("muffleMessage")
[10:33:12.104]                       }
[10:33:12.104]                       else if (inherits(cond, "warning")) {
[10:33:12.104]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.104]                         if (muffled) 
[10:33:12.104]                           invokeRestart("muffleWarning")
[10:33:12.104]                       }
[10:33:12.104]                       else if (inherits(cond, "condition")) {
[10:33:12.104]                         if (!is.null(pattern)) {
[10:33:12.104]                           computeRestarts <- base::computeRestarts
[10:33:12.104]                           grepl <- base::grepl
[10:33:12.104]                           restarts <- computeRestarts(cond)
[10:33:12.104]                           for (restart in restarts) {
[10:33:12.104]                             name <- restart$name
[10:33:12.104]                             if (is.null(name)) 
[10:33:12.104]                               next
[10:33:12.104]                             if (!grepl(pattern, name)) 
[10:33:12.104]                               next
[10:33:12.104]                             invokeRestart(restart)
[10:33:12.104]                             muffled <- TRUE
[10:33:12.104]                             break
[10:33:12.104]                           }
[10:33:12.104]                         }
[10:33:12.104]                       }
[10:33:12.104]                       invisible(muffled)
[10:33:12.104]                     }
[10:33:12.104]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.104]                   }
[10:33:12.104]                 }
[10:33:12.104]                 else {
[10:33:12.104]                   if (TRUE) {
[10:33:12.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.104]                     {
[10:33:12.104]                       inherits <- base::inherits
[10:33:12.104]                       invokeRestart <- base::invokeRestart
[10:33:12.104]                       is.null <- base::is.null
[10:33:12.104]                       muffled <- FALSE
[10:33:12.104]                       if (inherits(cond, "message")) {
[10:33:12.104]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.104]                         if (muffled) 
[10:33:12.104]                           invokeRestart("muffleMessage")
[10:33:12.104]                       }
[10:33:12.104]                       else if (inherits(cond, "warning")) {
[10:33:12.104]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.104]                         if (muffled) 
[10:33:12.104]                           invokeRestart("muffleWarning")
[10:33:12.104]                       }
[10:33:12.104]                       else if (inherits(cond, "condition")) {
[10:33:12.104]                         if (!is.null(pattern)) {
[10:33:12.104]                           computeRestarts <- base::computeRestarts
[10:33:12.104]                           grepl <- base::grepl
[10:33:12.104]                           restarts <- computeRestarts(cond)
[10:33:12.104]                           for (restart in restarts) {
[10:33:12.104]                             name <- restart$name
[10:33:12.104]                             if (is.null(name)) 
[10:33:12.104]                               next
[10:33:12.104]                             if (!grepl(pattern, name)) 
[10:33:12.104]                               next
[10:33:12.104]                             invokeRestart(restart)
[10:33:12.104]                             muffled <- TRUE
[10:33:12.104]                             break
[10:33:12.104]                           }
[10:33:12.104]                         }
[10:33:12.104]                       }
[10:33:12.104]                       invisible(muffled)
[10:33:12.104]                     }
[10:33:12.104]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.104]                   }
[10:33:12.104]                 }
[10:33:12.104]             }
[10:33:12.104]         }))
[10:33:12.104]     }, error = function(ex) {
[10:33:12.104]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.104]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.104]                 ...future.rng), started = ...future.startTime, 
[10:33:12.104]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.104]             version = "1.8"), class = "FutureResult")
[10:33:12.104]     }, finally = {
[10:33:12.104]         if (!identical(...future.workdir, getwd())) 
[10:33:12.104]             setwd(...future.workdir)
[10:33:12.104]         {
[10:33:12.104]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.104]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.104]             }
[10:33:12.104]             base::options(...future.oldOptions)
[10:33:12.104]             if (.Platform$OS.type == "windows") {
[10:33:12.104]                 old_names <- names(...future.oldEnvVars)
[10:33:12.104]                 envs <- base::Sys.getenv()
[10:33:12.104]                 names <- names(envs)
[10:33:12.104]                 common <- intersect(names, old_names)
[10:33:12.104]                 added <- setdiff(names, old_names)
[10:33:12.104]                 removed <- setdiff(old_names, names)
[10:33:12.104]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.104]                   envs[common]]
[10:33:12.104]                 NAMES <- toupper(changed)
[10:33:12.104]                 args <- list()
[10:33:12.104]                 for (kk in seq_along(NAMES)) {
[10:33:12.104]                   name <- changed[[kk]]
[10:33:12.104]                   NAME <- NAMES[[kk]]
[10:33:12.104]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.104]                     next
[10:33:12.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.104]                 }
[10:33:12.104]                 NAMES <- toupper(added)
[10:33:12.104]                 for (kk in seq_along(NAMES)) {
[10:33:12.104]                   name <- added[[kk]]
[10:33:12.104]                   NAME <- NAMES[[kk]]
[10:33:12.104]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.104]                     next
[10:33:12.104]                   args[[name]] <- ""
[10:33:12.104]                 }
[10:33:12.104]                 NAMES <- toupper(removed)
[10:33:12.104]                 for (kk in seq_along(NAMES)) {
[10:33:12.104]                   name <- removed[[kk]]
[10:33:12.104]                   NAME <- NAMES[[kk]]
[10:33:12.104]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.104]                     next
[10:33:12.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.104]                 }
[10:33:12.104]                 if (length(args) > 0) 
[10:33:12.104]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.104]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.104]             }
[10:33:12.104]             else {
[10:33:12.104]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.104]             }
[10:33:12.104]             {
[10:33:12.104]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.104]                   0L) {
[10:33:12.104]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.104]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.104]                   base::options(opts)
[10:33:12.104]                 }
[10:33:12.104]                 {
[10:33:12.104]                   {
[10:33:12.104]                     NULL
[10:33:12.104]                     RNGkind("Mersenne-Twister")
[10:33:12.104]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.104]                       inherits = FALSE)
[10:33:12.104]                   }
[10:33:12.104]                   options(future.plan = NULL)
[10:33:12.104]                   if (is.na(NA_character_)) 
[10:33:12.104]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.104]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.104]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.104]                     .init = FALSE)
[10:33:12.104]                 }
[10:33:12.104]             }
[10:33:12.104]         }
[10:33:12.104]     })
[10:33:12.104]     if (TRUE) {
[10:33:12.104]         base::sink(type = "output", split = FALSE)
[10:33:12.104]         if (TRUE) {
[10:33:12.104]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.104]         }
[10:33:12.104]         else {
[10:33:12.104]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.104]         }
[10:33:12.104]         base::close(...future.stdout)
[10:33:12.104]         ...future.stdout <- NULL
[10:33:12.104]     }
[10:33:12.104]     ...future.result$conditions <- ...future.conditions
[10:33:12.104]     ...future.result$finished <- base::Sys.time()
[10:33:12.104]     ...future.result
[10:33:12.104] }
[10:33:12.106] assign_globals() ...
[10:33:12.106] List of 1
[10:33:12.106]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55aa513dcb20> 
[10:33:12.106]  - attr(*, "where")=List of 1
[10:33:12.106]   ..$ a:<environment: R_EmptyEnv> 
[10:33:12.106]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.106]  - attr(*, "resolved")= logi TRUE
[10:33:12.106]  - attr(*, "total_size")= num 10424
[10:33:12.106]  - attr(*, "already-done")= logi TRUE
[10:33:12.108] - copied ‘a’ to environment
[10:33:12.109] assign_globals() ... done
[10:33:12.109] plan(): Setting new future strategy stack:
[10:33:12.109] List of future strategies:
[10:33:12.109] 1. sequential:
[10:33:12.109]    - args: function (..., envir = parent.frame())
[10:33:12.109]    - tweaked: FALSE
[10:33:12.109]    - call: NULL
[10:33:12.109] plan(): nbrOfWorkers() = 1
[10:33:12.111] plan(): Setting new future strategy stack:
[10:33:12.111] List of future strategies:
[10:33:12.111] 1. sequential:
[10:33:12.111]    - args: function (..., envir = parent.frame())
[10:33:12.111]    - tweaked: FALSE
[10:33:12.111]    - call: plan(strategy)
[10:33:12.112] plan(): nbrOfWorkers() = 1
[10:33:12.112] SequentialFuture started (and completed)
[10:33:12.112] - Launch lazy future ... done
[10:33:12.112] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.112] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.113] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.113] 
[10:33:12.113] Searching for globals ... DONE
[10:33:12.113] - globals: [0] <none>
[10:33:12.113] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.114] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.114] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.115] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:12.115] Searching for globals ... DONE
[10:33:12.115] Resolving globals: TRUE
[10:33:12.115] Resolving any globals that are futures ...
[10:33:12.115] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:12.115] Resolving any globals that are futures ... DONE
[10:33:12.115] Resolving futures part of globals (recursively) ...
[10:33:12.116] resolve() on list ...
[10:33:12.116]  recursive: 99
[10:33:12.116]  length: 1
[10:33:12.116]  elements: ‘a’
[10:33:12.116] run() for ‘Future’ ...
[10:33:12.116] - state: ‘created’
[10:33:12.116] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.117] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.117] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.117]   - Field: ‘label’
[10:33:12.117]   - Field: ‘local’
[10:33:12.117]   - Field: ‘owner’
[10:33:12.117]   - Field: ‘envir’
[10:33:12.117]   - Field: ‘packages’
[10:33:12.117]   - Field: ‘gc’
[10:33:12.117]   - Field: ‘conditions’
[10:33:12.117]   - Field: ‘expr’
[10:33:12.118]   - Field: ‘uuid’
[10:33:12.118]   - Field: ‘seed’
[10:33:12.118]   - Field: ‘version’
[10:33:12.118]   - Field: ‘result’
[10:33:12.118]   - Field: ‘asynchronous’
[10:33:12.118]   - Field: ‘calls’
[10:33:12.118]   - Field: ‘globals’
[10:33:12.118]   - Field: ‘stdout’
[10:33:12.118]   - Field: ‘earlySignal’
[10:33:12.118]   - Field: ‘lazy’
[10:33:12.118]   - Field: ‘state’
[10:33:12.118] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.119] - Launch lazy future ...
[10:33:12.119] Packages needed by the future expression (n = 0): <none>
[10:33:12.119] Packages needed by future strategies (n = 0): <none>
[10:33:12.119] {
[10:33:12.119]     {
[10:33:12.119]         {
[10:33:12.119]             ...future.startTime <- base::Sys.time()
[10:33:12.119]             {
[10:33:12.119]                 {
[10:33:12.119]                   {
[10:33:12.119]                     base::local({
[10:33:12.119]                       has_future <- base::requireNamespace("future", 
[10:33:12.119]                         quietly = TRUE)
[10:33:12.119]                       if (has_future) {
[10:33:12.119]                         ns <- base::getNamespace("future")
[10:33:12.119]                         version <- ns[[".package"]][["version"]]
[10:33:12.119]                         if (is.null(version)) 
[10:33:12.119]                           version <- utils::packageVersion("future")
[10:33:12.119]                       }
[10:33:12.119]                       else {
[10:33:12.119]                         version <- NULL
[10:33:12.119]                       }
[10:33:12.119]                       if (!has_future || version < "1.8.0") {
[10:33:12.119]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.119]                           "", base::R.version$version.string), 
[10:33:12.119]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.119]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.119]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.119]                             "release", "version")], collapse = " "), 
[10:33:12.119]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.119]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.119]                           info)
[10:33:12.119]                         info <- base::paste(info, collapse = "; ")
[10:33:12.119]                         if (!has_future) {
[10:33:12.119]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.119]                             info)
[10:33:12.119]                         }
[10:33:12.119]                         else {
[10:33:12.119]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.119]                             info, version)
[10:33:12.119]                         }
[10:33:12.119]                         base::stop(msg)
[10:33:12.119]                       }
[10:33:12.119]                     })
[10:33:12.119]                   }
[10:33:12.119]                   ...future.strategy.old <- future::plan("list")
[10:33:12.119]                   options(future.plan = NULL)
[10:33:12.119]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.119]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.119]                 }
[10:33:12.119]                 ...future.workdir <- getwd()
[10:33:12.119]             }
[10:33:12.119]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.119]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.119]         }
[10:33:12.119]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.119]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.119]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.119]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.119]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.119]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.119]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.119]             base::names(...future.oldOptions))
[10:33:12.119]     }
[10:33:12.119]     if (FALSE) {
[10:33:12.119]     }
[10:33:12.119]     else {
[10:33:12.119]         if (TRUE) {
[10:33:12.119]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.119]                 open = "w")
[10:33:12.119]         }
[10:33:12.119]         else {
[10:33:12.119]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.119]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.119]         }
[10:33:12.119]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.119]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.119]             base::sink(type = "output", split = FALSE)
[10:33:12.119]             base::close(...future.stdout)
[10:33:12.119]         }, add = TRUE)
[10:33:12.119]     }
[10:33:12.119]     ...future.frame <- base::sys.nframe()
[10:33:12.119]     ...future.conditions <- base::list()
[10:33:12.119]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.119]     if (FALSE) {
[10:33:12.119]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.119]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.119]     }
[10:33:12.119]     ...future.result <- base::tryCatch({
[10:33:12.119]         base::withCallingHandlers({
[10:33:12.119]             ...future.value <- base::withVisible(base::local(1))
[10:33:12.119]             future::FutureResult(value = ...future.value$value, 
[10:33:12.119]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.119]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.119]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.119]                     ...future.globalenv.names))
[10:33:12.119]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.119]         }, condition = base::local({
[10:33:12.119]             c <- base::c
[10:33:12.119]             inherits <- base::inherits
[10:33:12.119]             invokeRestart <- base::invokeRestart
[10:33:12.119]             length <- base::length
[10:33:12.119]             list <- base::list
[10:33:12.119]             seq.int <- base::seq.int
[10:33:12.119]             signalCondition <- base::signalCondition
[10:33:12.119]             sys.calls <- base::sys.calls
[10:33:12.119]             `[[` <- base::`[[`
[10:33:12.119]             `+` <- base::`+`
[10:33:12.119]             `<<-` <- base::`<<-`
[10:33:12.119]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.119]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.119]                   3L)]
[10:33:12.119]             }
[10:33:12.119]             function(cond) {
[10:33:12.119]                 is_error <- inherits(cond, "error")
[10:33:12.119]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.119]                   NULL)
[10:33:12.119]                 if (is_error) {
[10:33:12.119]                   sessionInformation <- function() {
[10:33:12.119]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.119]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.119]                       search = base::search(), system = base::Sys.info())
[10:33:12.119]                   }
[10:33:12.119]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.119]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.119]                     cond$call), session = sessionInformation(), 
[10:33:12.119]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.119]                   signalCondition(cond)
[10:33:12.119]                 }
[10:33:12.119]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.119]                 "immediateCondition"))) {
[10:33:12.119]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.119]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.119]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.119]                   if (TRUE && !signal) {
[10:33:12.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.119]                     {
[10:33:12.119]                       inherits <- base::inherits
[10:33:12.119]                       invokeRestart <- base::invokeRestart
[10:33:12.119]                       is.null <- base::is.null
[10:33:12.119]                       muffled <- FALSE
[10:33:12.119]                       if (inherits(cond, "message")) {
[10:33:12.119]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.119]                         if (muffled) 
[10:33:12.119]                           invokeRestart("muffleMessage")
[10:33:12.119]                       }
[10:33:12.119]                       else if (inherits(cond, "warning")) {
[10:33:12.119]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.119]                         if (muffled) 
[10:33:12.119]                           invokeRestart("muffleWarning")
[10:33:12.119]                       }
[10:33:12.119]                       else if (inherits(cond, "condition")) {
[10:33:12.119]                         if (!is.null(pattern)) {
[10:33:12.119]                           computeRestarts <- base::computeRestarts
[10:33:12.119]                           grepl <- base::grepl
[10:33:12.119]                           restarts <- computeRestarts(cond)
[10:33:12.119]                           for (restart in restarts) {
[10:33:12.119]                             name <- restart$name
[10:33:12.119]                             if (is.null(name)) 
[10:33:12.119]                               next
[10:33:12.119]                             if (!grepl(pattern, name)) 
[10:33:12.119]                               next
[10:33:12.119]                             invokeRestart(restart)
[10:33:12.119]                             muffled <- TRUE
[10:33:12.119]                             break
[10:33:12.119]                           }
[10:33:12.119]                         }
[10:33:12.119]                       }
[10:33:12.119]                       invisible(muffled)
[10:33:12.119]                     }
[10:33:12.119]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.119]                   }
[10:33:12.119]                 }
[10:33:12.119]                 else {
[10:33:12.119]                   if (TRUE) {
[10:33:12.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.119]                     {
[10:33:12.119]                       inherits <- base::inherits
[10:33:12.119]                       invokeRestart <- base::invokeRestart
[10:33:12.119]                       is.null <- base::is.null
[10:33:12.119]                       muffled <- FALSE
[10:33:12.119]                       if (inherits(cond, "message")) {
[10:33:12.119]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.119]                         if (muffled) 
[10:33:12.119]                           invokeRestart("muffleMessage")
[10:33:12.119]                       }
[10:33:12.119]                       else if (inherits(cond, "warning")) {
[10:33:12.119]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.119]                         if (muffled) 
[10:33:12.119]                           invokeRestart("muffleWarning")
[10:33:12.119]                       }
[10:33:12.119]                       else if (inherits(cond, "condition")) {
[10:33:12.119]                         if (!is.null(pattern)) {
[10:33:12.119]                           computeRestarts <- base::computeRestarts
[10:33:12.119]                           grepl <- base::grepl
[10:33:12.119]                           restarts <- computeRestarts(cond)
[10:33:12.119]                           for (restart in restarts) {
[10:33:12.119]                             name <- restart$name
[10:33:12.119]                             if (is.null(name)) 
[10:33:12.119]                               next
[10:33:12.119]                             if (!grepl(pattern, name)) 
[10:33:12.119]                               next
[10:33:12.119]                             invokeRestart(restart)
[10:33:12.119]                             muffled <- TRUE
[10:33:12.119]                             break
[10:33:12.119]                           }
[10:33:12.119]                         }
[10:33:12.119]                       }
[10:33:12.119]                       invisible(muffled)
[10:33:12.119]                     }
[10:33:12.119]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.119]                   }
[10:33:12.119]                 }
[10:33:12.119]             }
[10:33:12.119]         }))
[10:33:12.119]     }, error = function(ex) {
[10:33:12.119]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.119]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.119]                 ...future.rng), started = ...future.startTime, 
[10:33:12.119]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.119]             version = "1.8"), class = "FutureResult")
[10:33:12.119]     }, finally = {
[10:33:12.119]         if (!identical(...future.workdir, getwd())) 
[10:33:12.119]             setwd(...future.workdir)
[10:33:12.119]         {
[10:33:12.119]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.119]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.119]             }
[10:33:12.119]             base::options(...future.oldOptions)
[10:33:12.119]             if (.Platform$OS.type == "windows") {
[10:33:12.119]                 old_names <- names(...future.oldEnvVars)
[10:33:12.119]                 envs <- base::Sys.getenv()
[10:33:12.119]                 names <- names(envs)
[10:33:12.119]                 common <- intersect(names, old_names)
[10:33:12.119]                 added <- setdiff(names, old_names)
[10:33:12.119]                 removed <- setdiff(old_names, names)
[10:33:12.119]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.119]                   envs[common]]
[10:33:12.119]                 NAMES <- toupper(changed)
[10:33:12.119]                 args <- list()
[10:33:12.119]                 for (kk in seq_along(NAMES)) {
[10:33:12.119]                   name <- changed[[kk]]
[10:33:12.119]                   NAME <- NAMES[[kk]]
[10:33:12.119]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.119]                     next
[10:33:12.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.119]                 }
[10:33:12.119]                 NAMES <- toupper(added)
[10:33:12.119]                 for (kk in seq_along(NAMES)) {
[10:33:12.119]                   name <- added[[kk]]
[10:33:12.119]                   NAME <- NAMES[[kk]]
[10:33:12.119]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.119]                     next
[10:33:12.119]                   args[[name]] <- ""
[10:33:12.119]                 }
[10:33:12.119]                 NAMES <- toupper(removed)
[10:33:12.119]                 for (kk in seq_along(NAMES)) {
[10:33:12.119]                   name <- removed[[kk]]
[10:33:12.119]                   NAME <- NAMES[[kk]]
[10:33:12.119]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.119]                     next
[10:33:12.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.119]                 }
[10:33:12.119]                 if (length(args) > 0) 
[10:33:12.119]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.119]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.119]             }
[10:33:12.119]             else {
[10:33:12.119]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.119]             }
[10:33:12.119]             {
[10:33:12.119]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.119]                   0L) {
[10:33:12.119]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.119]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.119]                   base::options(opts)
[10:33:12.119]                 }
[10:33:12.119]                 {
[10:33:12.119]                   {
[10:33:12.119]                     NULL
[10:33:12.119]                     RNGkind("Mersenne-Twister")
[10:33:12.119]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.119]                       inherits = FALSE)
[10:33:12.119]                   }
[10:33:12.119]                   options(future.plan = NULL)
[10:33:12.119]                   if (is.na(NA_character_)) 
[10:33:12.119]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.119]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.119]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.119]                     .init = FALSE)
[10:33:12.119]                 }
[10:33:12.119]             }
[10:33:12.119]         }
[10:33:12.119]     })
[10:33:12.119]     if (TRUE) {
[10:33:12.119]         base::sink(type = "output", split = FALSE)
[10:33:12.119]         if (TRUE) {
[10:33:12.119]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.119]         }
[10:33:12.119]         else {
[10:33:12.119]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.119]         }
[10:33:12.119]         base::close(...future.stdout)
[10:33:12.119]         ...future.stdout <- NULL
[10:33:12.119]     }
[10:33:12.119]     ...future.result$conditions <- ...future.conditions
[10:33:12.119]     ...future.result$finished <- base::Sys.time()
[10:33:12.119]     ...future.result
[10:33:12.119] }
[10:33:12.121] plan(): Setting new future strategy stack:
[10:33:12.121] List of future strategies:
[10:33:12.121] 1. sequential:
[10:33:12.121]    - args: function (..., envir = parent.frame())
[10:33:12.121]    - tweaked: FALSE
[10:33:12.121]    - call: NULL
[10:33:12.121] plan(): nbrOfWorkers() = 1
[10:33:12.122] plan(): Setting new future strategy stack:
[10:33:12.122] List of future strategies:
[10:33:12.122] 1. sequential:
[10:33:12.122]    - args: function (..., envir = parent.frame())
[10:33:12.122]    - tweaked: FALSE
[10:33:12.122]    - call: plan(strategy)
[10:33:12.122] plan(): nbrOfWorkers() = 1
[10:33:12.123] SequentialFuture started (and completed)
[10:33:12.123] - Launch lazy future ... done
[10:33:12.123] run() for ‘SequentialFuture’ ... done
[10:33:12.123] resolved() for ‘SequentialFuture’ ...
[10:33:12.123] - state: ‘finished’
[10:33:12.123] - run: TRUE
[10:33:12.123] - result: ‘FutureResult’
[10:33:12.123] resolved() for ‘SequentialFuture’ ... done
[10:33:12.123] Future #1
[10:33:12.123] resolved() for ‘SequentialFuture’ ...
[10:33:12.124] - state: ‘finished’
[10:33:12.124] - run: TRUE
[10:33:12.124] - result: ‘FutureResult’
[10:33:12.124] resolved() for ‘SequentialFuture’ ... done
[10:33:12.124] A SequentialFuture was resolved
[10:33:12.124]  length: 0 (resolved future 1)
[10:33:12.124] resolve() on list ... DONE
[10:33:12.124] - globals: [1] ‘a’
[10:33:12.124] Resolving futures part of globals (recursively) ... DONE
[10:33:12.125] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[10:33:12.125] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[10:33:12.125] - globals: [1] ‘a’
[10:33:12.126] - packages: [1] ‘future’
[10:33:12.126] getGlobalsAndPackages() ... DONE
[10:33:12.126] run() for ‘Future’ ...
[10:33:12.126] - state: ‘created’
[10:33:12.126] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.126] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.126] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.127]   - Field: ‘label’
[10:33:12.127]   - Field: ‘local’
[10:33:12.127]   - Field: ‘owner’
[10:33:12.127]   - Field: ‘envir’
[10:33:12.127]   - Field: ‘packages’
[10:33:12.127]   - Field: ‘gc’
[10:33:12.127]   - Field: ‘conditions’
[10:33:12.127]   - Field: ‘expr’
[10:33:12.127]   - Field: ‘uuid’
[10:33:12.127]   - Field: ‘seed’
[10:33:12.127]   - Field: ‘version’
[10:33:12.127]   - Field: ‘result’
[10:33:12.128]   - Field: ‘asynchronous’
[10:33:12.128]   - Field: ‘calls’
[10:33:12.128]   - Field: ‘globals’
[10:33:12.128]   - Field: ‘stdout’
[10:33:12.128]   - Field: ‘earlySignal’
[10:33:12.128]   - Field: ‘lazy’
[10:33:12.128]   - Field: ‘state’
[10:33:12.128] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.128] - Launch lazy future ...
[10:33:12.128] Packages needed by the future expression (n = 1): ‘future’
[10:33:12.129] Packages needed by future strategies (n = 0): <none>
[10:33:12.129] {
[10:33:12.129]     {
[10:33:12.129]         {
[10:33:12.129]             ...future.startTime <- base::Sys.time()
[10:33:12.129]             {
[10:33:12.129]                 {
[10:33:12.129]                   {
[10:33:12.129]                     {
[10:33:12.129]                       base::local({
[10:33:12.129]                         has_future <- base::requireNamespace("future", 
[10:33:12.129]                           quietly = TRUE)
[10:33:12.129]                         if (has_future) {
[10:33:12.129]                           ns <- base::getNamespace("future")
[10:33:12.129]                           version <- ns[[".package"]][["version"]]
[10:33:12.129]                           if (is.null(version)) 
[10:33:12.129]                             version <- utils::packageVersion("future")
[10:33:12.129]                         }
[10:33:12.129]                         else {
[10:33:12.129]                           version <- NULL
[10:33:12.129]                         }
[10:33:12.129]                         if (!has_future || version < "1.8.0") {
[10:33:12.129]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.129]                             "", base::R.version$version.string), 
[10:33:12.129]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:12.129]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.129]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.129]                               "release", "version")], collapse = " "), 
[10:33:12.129]                             hostname = base::Sys.info()[["nodename"]])
[10:33:12.129]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.129]                             info)
[10:33:12.129]                           info <- base::paste(info, collapse = "; ")
[10:33:12.129]                           if (!has_future) {
[10:33:12.129]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.129]                               info)
[10:33:12.129]                           }
[10:33:12.129]                           else {
[10:33:12.129]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.129]                               info, version)
[10:33:12.129]                           }
[10:33:12.129]                           base::stop(msg)
[10:33:12.129]                         }
[10:33:12.129]                       })
[10:33:12.129]                     }
[10:33:12.129]                     base::local({
[10:33:12.129]                       for (pkg in "future") {
[10:33:12.129]                         base::loadNamespace(pkg)
[10:33:12.129]                         base::library(pkg, character.only = TRUE)
[10:33:12.129]                       }
[10:33:12.129]                     })
[10:33:12.129]                   }
[10:33:12.129]                   ...future.strategy.old <- future::plan("list")
[10:33:12.129]                   options(future.plan = NULL)
[10:33:12.129]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.129]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.129]                 }
[10:33:12.129]                 ...future.workdir <- getwd()
[10:33:12.129]             }
[10:33:12.129]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.129]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.129]         }
[10:33:12.129]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.129]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.129]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.129]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.129]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.129]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.129]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.129]             base::names(...future.oldOptions))
[10:33:12.129]     }
[10:33:12.129]     if (FALSE) {
[10:33:12.129]     }
[10:33:12.129]     else {
[10:33:12.129]         if (TRUE) {
[10:33:12.129]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.129]                 open = "w")
[10:33:12.129]         }
[10:33:12.129]         else {
[10:33:12.129]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.129]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.129]         }
[10:33:12.129]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.129]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.129]             base::sink(type = "output", split = FALSE)
[10:33:12.129]             base::close(...future.stdout)
[10:33:12.129]         }, add = TRUE)
[10:33:12.129]     }
[10:33:12.129]     ...future.frame <- base::sys.nframe()
[10:33:12.129]     ...future.conditions <- base::list()
[10:33:12.129]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.129]     if (FALSE) {
[10:33:12.129]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.129]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.129]     }
[10:33:12.129]     ...future.result <- base::tryCatch({
[10:33:12.129]         base::withCallingHandlers({
[10:33:12.129]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:33:12.129]                 1))
[10:33:12.129]             future::FutureResult(value = ...future.value$value, 
[10:33:12.129]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.129]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.129]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.129]                     ...future.globalenv.names))
[10:33:12.129]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.129]         }, condition = base::local({
[10:33:12.129]             c <- base::c
[10:33:12.129]             inherits <- base::inherits
[10:33:12.129]             invokeRestart <- base::invokeRestart
[10:33:12.129]             length <- base::length
[10:33:12.129]             list <- base::list
[10:33:12.129]             seq.int <- base::seq.int
[10:33:12.129]             signalCondition <- base::signalCondition
[10:33:12.129]             sys.calls <- base::sys.calls
[10:33:12.129]             `[[` <- base::`[[`
[10:33:12.129]             `+` <- base::`+`
[10:33:12.129]             `<<-` <- base::`<<-`
[10:33:12.129]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.129]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.129]                   3L)]
[10:33:12.129]             }
[10:33:12.129]             function(cond) {
[10:33:12.129]                 is_error <- inherits(cond, "error")
[10:33:12.129]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.129]                   NULL)
[10:33:12.129]                 if (is_error) {
[10:33:12.129]                   sessionInformation <- function() {
[10:33:12.129]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.129]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.129]                       search = base::search(), system = base::Sys.info())
[10:33:12.129]                   }
[10:33:12.129]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.129]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.129]                     cond$call), session = sessionInformation(), 
[10:33:12.129]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.129]                   signalCondition(cond)
[10:33:12.129]                 }
[10:33:12.129]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.129]                 "immediateCondition"))) {
[10:33:12.129]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.129]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.129]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.129]                   if (TRUE && !signal) {
[10:33:12.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.129]                     {
[10:33:12.129]                       inherits <- base::inherits
[10:33:12.129]                       invokeRestart <- base::invokeRestart
[10:33:12.129]                       is.null <- base::is.null
[10:33:12.129]                       muffled <- FALSE
[10:33:12.129]                       if (inherits(cond, "message")) {
[10:33:12.129]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.129]                         if (muffled) 
[10:33:12.129]                           invokeRestart("muffleMessage")
[10:33:12.129]                       }
[10:33:12.129]                       else if (inherits(cond, "warning")) {
[10:33:12.129]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.129]                         if (muffled) 
[10:33:12.129]                           invokeRestart("muffleWarning")
[10:33:12.129]                       }
[10:33:12.129]                       else if (inherits(cond, "condition")) {
[10:33:12.129]                         if (!is.null(pattern)) {
[10:33:12.129]                           computeRestarts <- base::computeRestarts
[10:33:12.129]                           grepl <- base::grepl
[10:33:12.129]                           restarts <- computeRestarts(cond)
[10:33:12.129]                           for (restart in restarts) {
[10:33:12.129]                             name <- restart$name
[10:33:12.129]                             if (is.null(name)) 
[10:33:12.129]                               next
[10:33:12.129]                             if (!grepl(pattern, name)) 
[10:33:12.129]                               next
[10:33:12.129]                             invokeRestart(restart)
[10:33:12.129]                             muffled <- TRUE
[10:33:12.129]                             break
[10:33:12.129]                           }
[10:33:12.129]                         }
[10:33:12.129]                       }
[10:33:12.129]                       invisible(muffled)
[10:33:12.129]                     }
[10:33:12.129]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.129]                   }
[10:33:12.129]                 }
[10:33:12.129]                 else {
[10:33:12.129]                   if (TRUE) {
[10:33:12.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.129]                     {
[10:33:12.129]                       inherits <- base::inherits
[10:33:12.129]                       invokeRestart <- base::invokeRestart
[10:33:12.129]                       is.null <- base::is.null
[10:33:12.129]                       muffled <- FALSE
[10:33:12.129]                       if (inherits(cond, "message")) {
[10:33:12.129]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.129]                         if (muffled) 
[10:33:12.129]                           invokeRestart("muffleMessage")
[10:33:12.129]                       }
[10:33:12.129]                       else if (inherits(cond, "warning")) {
[10:33:12.129]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.129]                         if (muffled) 
[10:33:12.129]                           invokeRestart("muffleWarning")
[10:33:12.129]                       }
[10:33:12.129]                       else if (inherits(cond, "condition")) {
[10:33:12.129]                         if (!is.null(pattern)) {
[10:33:12.129]                           computeRestarts <- base::computeRestarts
[10:33:12.129]                           grepl <- base::grepl
[10:33:12.129]                           restarts <- computeRestarts(cond)
[10:33:12.129]                           for (restart in restarts) {
[10:33:12.129]                             name <- restart$name
[10:33:12.129]                             if (is.null(name)) 
[10:33:12.129]                               next
[10:33:12.129]                             if (!grepl(pattern, name)) 
[10:33:12.129]                               next
[10:33:12.129]                             invokeRestart(restart)
[10:33:12.129]                             muffled <- TRUE
[10:33:12.129]                             break
[10:33:12.129]                           }
[10:33:12.129]                         }
[10:33:12.129]                       }
[10:33:12.129]                       invisible(muffled)
[10:33:12.129]                     }
[10:33:12.129]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.129]                   }
[10:33:12.129]                 }
[10:33:12.129]             }
[10:33:12.129]         }))
[10:33:12.129]     }, error = function(ex) {
[10:33:12.129]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.129]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.129]                 ...future.rng), started = ...future.startTime, 
[10:33:12.129]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.129]             version = "1.8"), class = "FutureResult")
[10:33:12.129]     }, finally = {
[10:33:12.129]         if (!identical(...future.workdir, getwd())) 
[10:33:12.129]             setwd(...future.workdir)
[10:33:12.129]         {
[10:33:12.129]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.129]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.129]             }
[10:33:12.129]             base::options(...future.oldOptions)
[10:33:12.129]             if (.Platform$OS.type == "windows") {
[10:33:12.129]                 old_names <- names(...future.oldEnvVars)
[10:33:12.129]                 envs <- base::Sys.getenv()
[10:33:12.129]                 names <- names(envs)
[10:33:12.129]                 common <- intersect(names, old_names)
[10:33:12.129]                 added <- setdiff(names, old_names)
[10:33:12.129]                 removed <- setdiff(old_names, names)
[10:33:12.129]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.129]                   envs[common]]
[10:33:12.129]                 NAMES <- toupper(changed)
[10:33:12.129]                 args <- list()
[10:33:12.129]                 for (kk in seq_along(NAMES)) {
[10:33:12.129]                   name <- changed[[kk]]
[10:33:12.129]                   NAME <- NAMES[[kk]]
[10:33:12.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.129]                     next
[10:33:12.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.129]                 }
[10:33:12.129]                 NAMES <- toupper(added)
[10:33:12.129]                 for (kk in seq_along(NAMES)) {
[10:33:12.129]                   name <- added[[kk]]
[10:33:12.129]                   NAME <- NAMES[[kk]]
[10:33:12.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.129]                     next
[10:33:12.129]                   args[[name]] <- ""
[10:33:12.129]                 }
[10:33:12.129]                 NAMES <- toupper(removed)
[10:33:12.129]                 for (kk in seq_along(NAMES)) {
[10:33:12.129]                   name <- removed[[kk]]
[10:33:12.129]                   NAME <- NAMES[[kk]]
[10:33:12.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.129]                     next
[10:33:12.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.129]                 }
[10:33:12.129]                 if (length(args) > 0) 
[10:33:12.129]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.129]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.129]             }
[10:33:12.129]             else {
[10:33:12.129]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.129]             }
[10:33:12.129]             {
[10:33:12.129]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.129]                   0L) {
[10:33:12.129]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.129]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.129]                   base::options(opts)
[10:33:12.129]                 }
[10:33:12.129]                 {
[10:33:12.129]                   {
[10:33:12.129]                     NULL
[10:33:12.129]                     RNGkind("Mersenne-Twister")
[10:33:12.129]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.129]                       inherits = FALSE)
[10:33:12.129]                   }
[10:33:12.129]                   options(future.plan = NULL)
[10:33:12.129]                   if (is.na(NA_character_)) 
[10:33:12.129]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.129]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.129]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.129]                     .init = FALSE)
[10:33:12.129]                 }
[10:33:12.129]             }
[10:33:12.129]         }
[10:33:12.129]     })
[10:33:12.129]     if (TRUE) {
[10:33:12.129]         base::sink(type = "output", split = FALSE)
[10:33:12.129]         if (TRUE) {
[10:33:12.129]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.129]         }
[10:33:12.129]         else {
[10:33:12.129]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.129]         }
[10:33:12.129]         base::close(...future.stdout)
[10:33:12.129]         ...future.stdout <- NULL
[10:33:12.129]     }
[10:33:12.129]     ...future.result$conditions <- ...future.conditions
[10:33:12.129]     ...future.result$finished <- base::Sys.time()
[10:33:12.129]     ...future.result
[10:33:12.129] }
[10:33:12.131] assign_globals() ...
[10:33:12.131] List of 1
[10:33:12.131]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55aa51a8b278> 
[10:33:12.131]  - attr(*, "where")=List of 1
[10:33:12.131]   ..$ a:<environment: R_EmptyEnv> 
[10:33:12.131]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.131]  - attr(*, "resolved")= logi TRUE
[10:33:12.131]  - attr(*, "total_size")= num 10592
[10:33:12.131]  - attr(*, "already-done")= logi TRUE
[10:33:12.133] - copied ‘a’ to environment
[10:33:12.133] assign_globals() ... done
[10:33:12.133] plan(): Setting new future strategy stack:
[10:33:12.133] List of future strategies:
[10:33:12.133] 1. sequential:
[10:33:12.133]    - args: function (..., envir = parent.frame())
[10:33:12.133]    - tweaked: FALSE
[10:33:12.133]    - call: NULL
[10:33:12.134] plan(): nbrOfWorkers() = 1
[10:33:12.134] plan(): Setting new future strategy stack:
[10:33:12.135] List of future strategies:
[10:33:12.135] 1. sequential:
[10:33:12.135]    - args: function (..., envir = parent.frame())
[10:33:12.135]    - tweaked: FALSE
[10:33:12.135]    - call: plan(strategy)
[10:33:12.135] plan(): nbrOfWorkers() = 1
[10:33:12.135] SequentialFuture started (and completed)
[10:33:12.135] - Launch lazy future ... done
[10:33:12.135] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.137] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.137] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.137] 
[10:33:12.137] Searching for globals ... DONE
[10:33:12.138] - globals: [0] <none>
[10:33:12.138] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.138] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.138] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.139] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:12.139] Searching for globals ... DONE
[10:33:12.139] Resolving globals: TRUE
[10:33:12.139] Resolving any globals that are futures ...
[10:33:12.139] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:12.139] Resolving any globals that are futures ... DONE
[10:33:12.140] Resolving futures part of globals (recursively) ...
[10:33:12.140] resolve() on list ...
[10:33:12.140]  recursive: 99
[10:33:12.140]  length: 1
[10:33:12.140]  elements: ‘a’
[10:33:12.140] run() for ‘Future’ ...
[10:33:12.140] - state: ‘created’
[10:33:12.140] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.141] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.141] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.141]   - Field: ‘label’
[10:33:12.141]   - Field: ‘local’
[10:33:12.141]   - Field: ‘owner’
[10:33:12.141]   - Field: ‘envir’
[10:33:12.141]   - Field: ‘packages’
[10:33:12.141]   - Field: ‘gc’
[10:33:12.142]   - Field: ‘conditions’
[10:33:12.142]   - Field: ‘expr’
[10:33:12.142]   - Field: ‘uuid’
[10:33:12.142]   - Field: ‘seed’
[10:33:12.142]   - Field: ‘version’
[10:33:12.142]   - Field: ‘result’
[10:33:12.142]   - Field: ‘asynchronous’
[10:33:12.142]   - Field: ‘calls’
[10:33:12.142]   - Field: ‘globals’
[10:33:12.142]   - Field: ‘stdout’
[10:33:12.142]   - Field: ‘earlySignal’
[10:33:12.142]   - Field: ‘lazy’
[10:33:12.143]   - Field: ‘state’
[10:33:12.143] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.143] - Launch lazy future ...
[10:33:12.143] Packages needed by the future expression (n = 0): <none>
[10:33:12.143] Packages needed by future strategies (n = 0): <none>
[10:33:12.143] {
[10:33:12.143]     {
[10:33:12.143]         {
[10:33:12.143]             ...future.startTime <- base::Sys.time()
[10:33:12.143]             {
[10:33:12.143]                 {
[10:33:12.143]                   {
[10:33:12.143]                     base::local({
[10:33:12.143]                       has_future <- base::requireNamespace("future", 
[10:33:12.143]                         quietly = TRUE)
[10:33:12.143]                       if (has_future) {
[10:33:12.143]                         ns <- base::getNamespace("future")
[10:33:12.143]                         version <- ns[[".package"]][["version"]]
[10:33:12.143]                         if (is.null(version)) 
[10:33:12.143]                           version <- utils::packageVersion("future")
[10:33:12.143]                       }
[10:33:12.143]                       else {
[10:33:12.143]                         version <- NULL
[10:33:12.143]                       }
[10:33:12.143]                       if (!has_future || version < "1.8.0") {
[10:33:12.143]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.143]                           "", base::R.version$version.string), 
[10:33:12.143]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.143]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.143]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.143]                             "release", "version")], collapse = " "), 
[10:33:12.143]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.143]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.143]                           info)
[10:33:12.143]                         info <- base::paste(info, collapse = "; ")
[10:33:12.143]                         if (!has_future) {
[10:33:12.143]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.143]                             info)
[10:33:12.143]                         }
[10:33:12.143]                         else {
[10:33:12.143]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.143]                             info, version)
[10:33:12.143]                         }
[10:33:12.143]                         base::stop(msg)
[10:33:12.143]                       }
[10:33:12.143]                     })
[10:33:12.143]                   }
[10:33:12.143]                   ...future.strategy.old <- future::plan("list")
[10:33:12.143]                   options(future.plan = NULL)
[10:33:12.143]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.143]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.143]                 }
[10:33:12.143]                 ...future.workdir <- getwd()
[10:33:12.143]             }
[10:33:12.143]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.143]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.143]         }
[10:33:12.143]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.143]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.143]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.143]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.143]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.143]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.143]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.143]             base::names(...future.oldOptions))
[10:33:12.143]     }
[10:33:12.143]     if (FALSE) {
[10:33:12.143]     }
[10:33:12.143]     else {
[10:33:12.143]         if (TRUE) {
[10:33:12.143]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.143]                 open = "w")
[10:33:12.143]         }
[10:33:12.143]         else {
[10:33:12.143]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.143]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.143]         }
[10:33:12.143]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.143]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.143]             base::sink(type = "output", split = FALSE)
[10:33:12.143]             base::close(...future.stdout)
[10:33:12.143]         }, add = TRUE)
[10:33:12.143]     }
[10:33:12.143]     ...future.frame <- base::sys.nframe()
[10:33:12.143]     ...future.conditions <- base::list()
[10:33:12.143]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.143]     if (FALSE) {
[10:33:12.143]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.143]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.143]     }
[10:33:12.143]     ...future.result <- base::tryCatch({
[10:33:12.143]         base::withCallingHandlers({
[10:33:12.143]             ...future.value <- base::withVisible(base::local(1))
[10:33:12.143]             future::FutureResult(value = ...future.value$value, 
[10:33:12.143]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.143]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.143]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.143]                     ...future.globalenv.names))
[10:33:12.143]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.143]         }, condition = base::local({
[10:33:12.143]             c <- base::c
[10:33:12.143]             inherits <- base::inherits
[10:33:12.143]             invokeRestart <- base::invokeRestart
[10:33:12.143]             length <- base::length
[10:33:12.143]             list <- base::list
[10:33:12.143]             seq.int <- base::seq.int
[10:33:12.143]             signalCondition <- base::signalCondition
[10:33:12.143]             sys.calls <- base::sys.calls
[10:33:12.143]             `[[` <- base::`[[`
[10:33:12.143]             `+` <- base::`+`
[10:33:12.143]             `<<-` <- base::`<<-`
[10:33:12.143]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.143]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.143]                   3L)]
[10:33:12.143]             }
[10:33:12.143]             function(cond) {
[10:33:12.143]                 is_error <- inherits(cond, "error")
[10:33:12.143]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.143]                   NULL)
[10:33:12.143]                 if (is_error) {
[10:33:12.143]                   sessionInformation <- function() {
[10:33:12.143]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.143]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.143]                       search = base::search(), system = base::Sys.info())
[10:33:12.143]                   }
[10:33:12.143]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.143]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.143]                     cond$call), session = sessionInformation(), 
[10:33:12.143]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.143]                   signalCondition(cond)
[10:33:12.143]                 }
[10:33:12.143]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.143]                 "immediateCondition"))) {
[10:33:12.143]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.143]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.143]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.143]                   if (TRUE && !signal) {
[10:33:12.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.143]                     {
[10:33:12.143]                       inherits <- base::inherits
[10:33:12.143]                       invokeRestart <- base::invokeRestart
[10:33:12.143]                       is.null <- base::is.null
[10:33:12.143]                       muffled <- FALSE
[10:33:12.143]                       if (inherits(cond, "message")) {
[10:33:12.143]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.143]                         if (muffled) 
[10:33:12.143]                           invokeRestart("muffleMessage")
[10:33:12.143]                       }
[10:33:12.143]                       else if (inherits(cond, "warning")) {
[10:33:12.143]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.143]                         if (muffled) 
[10:33:12.143]                           invokeRestart("muffleWarning")
[10:33:12.143]                       }
[10:33:12.143]                       else if (inherits(cond, "condition")) {
[10:33:12.143]                         if (!is.null(pattern)) {
[10:33:12.143]                           computeRestarts <- base::computeRestarts
[10:33:12.143]                           grepl <- base::grepl
[10:33:12.143]                           restarts <- computeRestarts(cond)
[10:33:12.143]                           for (restart in restarts) {
[10:33:12.143]                             name <- restart$name
[10:33:12.143]                             if (is.null(name)) 
[10:33:12.143]                               next
[10:33:12.143]                             if (!grepl(pattern, name)) 
[10:33:12.143]                               next
[10:33:12.143]                             invokeRestart(restart)
[10:33:12.143]                             muffled <- TRUE
[10:33:12.143]                             break
[10:33:12.143]                           }
[10:33:12.143]                         }
[10:33:12.143]                       }
[10:33:12.143]                       invisible(muffled)
[10:33:12.143]                     }
[10:33:12.143]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.143]                   }
[10:33:12.143]                 }
[10:33:12.143]                 else {
[10:33:12.143]                   if (TRUE) {
[10:33:12.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.143]                     {
[10:33:12.143]                       inherits <- base::inherits
[10:33:12.143]                       invokeRestart <- base::invokeRestart
[10:33:12.143]                       is.null <- base::is.null
[10:33:12.143]                       muffled <- FALSE
[10:33:12.143]                       if (inherits(cond, "message")) {
[10:33:12.143]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.143]                         if (muffled) 
[10:33:12.143]                           invokeRestart("muffleMessage")
[10:33:12.143]                       }
[10:33:12.143]                       else if (inherits(cond, "warning")) {
[10:33:12.143]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.143]                         if (muffled) 
[10:33:12.143]                           invokeRestart("muffleWarning")
[10:33:12.143]                       }
[10:33:12.143]                       else if (inherits(cond, "condition")) {
[10:33:12.143]                         if (!is.null(pattern)) {
[10:33:12.143]                           computeRestarts <- base::computeRestarts
[10:33:12.143]                           grepl <- base::grepl
[10:33:12.143]                           restarts <- computeRestarts(cond)
[10:33:12.143]                           for (restart in restarts) {
[10:33:12.143]                             name <- restart$name
[10:33:12.143]                             if (is.null(name)) 
[10:33:12.143]                               next
[10:33:12.143]                             if (!grepl(pattern, name)) 
[10:33:12.143]                               next
[10:33:12.143]                             invokeRestart(restart)
[10:33:12.143]                             muffled <- TRUE
[10:33:12.143]                             break
[10:33:12.143]                           }
[10:33:12.143]                         }
[10:33:12.143]                       }
[10:33:12.143]                       invisible(muffled)
[10:33:12.143]                     }
[10:33:12.143]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.143]                   }
[10:33:12.143]                 }
[10:33:12.143]             }
[10:33:12.143]         }))
[10:33:12.143]     }, error = function(ex) {
[10:33:12.143]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.143]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.143]                 ...future.rng), started = ...future.startTime, 
[10:33:12.143]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.143]             version = "1.8"), class = "FutureResult")
[10:33:12.143]     }, finally = {
[10:33:12.143]         if (!identical(...future.workdir, getwd())) 
[10:33:12.143]             setwd(...future.workdir)
[10:33:12.143]         {
[10:33:12.143]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.143]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.143]             }
[10:33:12.143]             base::options(...future.oldOptions)
[10:33:12.143]             if (.Platform$OS.type == "windows") {
[10:33:12.143]                 old_names <- names(...future.oldEnvVars)
[10:33:12.143]                 envs <- base::Sys.getenv()
[10:33:12.143]                 names <- names(envs)
[10:33:12.143]                 common <- intersect(names, old_names)
[10:33:12.143]                 added <- setdiff(names, old_names)
[10:33:12.143]                 removed <- setdiff(old_names, names)
[10:33:12.143]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.143]                   envs[common]]
[10:33:12.143]                 NAMES <- toupper(changed)
[10:33:12.143]                 args <- list()
[10:33:12.143]                 for (kk in seq_along(NAMES)) {
[10:33:12.143]                   name <- changed[[kk]]
[10:33:12.143]                   NAME <- NAMES[[kk]]
[10:33:12.143]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.143]                     next
[10:33:12.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.143]                 }
[10:33:12.143]                 NAMES <- toupper(added)
[10:33:12.143]                 for (kk in seq_along(NAMES)) {
[10:33:12.143]                   name <- added[[kk]]
[10:33:12.143]                   NAME <- NAMES[[kk]]
[10:33:12.143]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.143]                     next
[10:33:12.143]                   args[[name]] <- ""
[10:33:12.143]                 }
[10:33:12.143]                 NAMES <- toupper(removed)
[10:33:12.143]                 for (kk in seq_along(NAMES)) {
[10:33:12.143]                   name <- removed[[kk]]
[10:33:12.143]                   NAME <- NAMES[[kk]]
[10:33:12.143]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.143]                     next
[10:33:12.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.143]                 }
[10:33:12.143]                 if (length(args) > 0) 
[10:33:12.143]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.143]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.143]             }
[10:33:12.143]             else {
[10:33:12.143]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.143]             }
[10:33:12.143]             {
[10:33:12.143]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.143]                   0L) {
[10:33:12.143]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.143]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.143]                   base::options(opts)
[10:33:12.143]                 }
[10:33:12.143]                 {
[10:33:12.143]                   {
[10:33:12.143]                     NULL
[10:33:12.143]                     RNGkind("Mersenne-Twister")
[10:33:12.143]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.143]                       inherits = FALSE)
[10:33:12.143]                   }
[10:33:12.143]                   options(future.plan = NULL)
[10:33:12.143]                   if (is.na(NA_character_)) 
[10:33:12.143]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.143]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.143]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.143]                     .init = FALSE)
[10:33:12.143]                 }
[10:33:12.143]             }
[10:33:12.143]         }
[10:33:12.143]     })
[10:33:12.143]     if (TRUE) {
[10:33:12.143]         base::sink(type = "output", split = FALSE)
[10:33:12.143]         if (TRUE) {
[10:33:12.143]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.143]         }
[10:33:12.143]         else {
[10:33:12.143]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.143]         }
[10:33:12.143]         base::close(...future.stdout)
[10:33:12.143]         ...future.stdout <- NULL
[10:33:12.143]     }
[10:33:12.143]     ...future.result$conditions <- ...future.conditions
[10:33:12.143]     ...future.result$finished <- base::Sys.time()
[10:33:12.143]     ...future.result
[10:33:12.143] }
[10:33:12.145] plan(): Setting new future strategy stack:
[10:33:12.145] List of future strategies:
[10:33:12.145] 1. sequential:
[10:33:12.145]    - args: function (..., envir = parent.frame())
[10:33:12.145]    - tweaked: FALSE
[10:33:12.145]    - call: NULL
[10:33:12.145] plan(): nbrOfWorkers() = 1
[10:33:12.146] plan(): Setting new future strategy stack:
[10:33:12.146] List of future strategies:
[10:33:12.146] 1. sequential:
[10:33:12.146]    - args: function (..., envir = parent.frame())
[10:33:12.146]    - tweaked: FALSE
[10:33:12.146]    - call: plan(strategy)
[10:33:12.147] plan(): nbrOfWorkers() = 1
[10:33:12.147] SequentialFuture started (and completed)
[10:33:12.147] - Launch lazy future ... done
[10:33:12.147] run() for ‘SequentialFuture’ ... done
[10:33:12.147] resolved() for ‘SequentialFuture’ ...
[10:33:12.147] - state: ‘finished’
[10:33:12.147] - run: TRUE
[10:33:12.147] - result: ‘FutureResult’
[10:33:12.147] resolved() for ‘SequentialFuture’ ... done
[10:33:12.148] Future #1
[10:33:12.148] resolved() for ‘SequentialFuture’ ...
[10:33:12.148] - state: ‘finished’
[10:33:12.148] - run: TRUE
[10:33:12.148] - result: ‘FutureResult’
[10:33:12.148] resolved() for ‘SequentialFuture’ ... done
[10:33:12.148] A SequentialFuture was resolved
[10:33:12.148]  length: 0 (resolved future 1)
[10:33:12.148] resolve() on list ... DONE
[10:33:12.148] - globals: [1] ‘a’
[10:33:12.149] Resolving futures part of globals (recursively) ... DONE
[10:33:12.149] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[10:33:12.150] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[10:33:12.150] - globals: [1] ‘a’
[10:33:12.150] - packages: [1] ‘future’
[10:33:12.150] getGlobalsAndPackages() ... DONE
[10:33:12.150] run() for ‘Future’ ...
[10:33:12.150] - state: ‘created’
[10:33:12.150] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.151] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.151] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.151]   - Field: ‘label’
[10:33:12.151]   - Field: ‘local’
[10:33:12.151]   - Field: ‘owner’
[10:33:12.151]   - Field: ‘envir’
[10:33:12.151]   - Field: ‘packages’
[10:33:12.151]   - Field: ‘gc’
[10:33:12.151]   - Field: ‘conditions’
[10:33:12.151]   - Field: ‘expr’
[10:33:12.151]   - Field: ‘uuid’
[10:33:12.152]   - Field: ‘seed’
[10:33:12.152]   - Field: ‘version’
[10:33:12.152]   - Field: ‘result’
[10:33:12.152]   - Field: ‘asynchronous’
[10:33:12.152]   - Field: ‘calls’
[10:33:12.152]   - Field: ‘globals’
[10:33:12.152]   - Field: ‘stdout’
[10:33:12.152]   - Field: ‘earlySignal’
[10:33:12.152]   - Field: ‘lazy’
[10:33:12.152]   - Field: ‘state’
[10:33:12.152] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.153] - Launch lazy future ...
[10:33:12.153] Packages needed by the future expression (n = 1): ‘future’
[10:33:12.153] Packages needed by future strategies (n = 0): <none>
[10:33:12.153] {
[10:33:12.153]     {
[10:33:12.153]         {
[10:33:12.153]             ...future.startTime <- base::Sys.time()
[10:33:12.153]             {
[10:33:12.153]                 {
[10:33:12.153]                   {
[10:33:12.153]                     {
[10:33:12.153]                       base::local({
[10:33:12.153]                         has_future <- base::requireNamespace("future", 
[10:33:12.153]                           quietly = TRUE)
[10:33:12.153]                         if (has_future) {
[10:33:12.153]                           ns <- base::getNamespace("future")
[10:33:12.153]                           version <- ns[[".package"]][["version"]]
[10:33:12.153]                           if (is.null(version)) 
[10:33:12.153]                             version <- utils::packageVersion("future")
[10:33:12.153]                         }
[10:33:12.153]                         else {
[10:33:12.153]                           version <- NULL
[10:33:12.153]                         }
[10:33:12.153]                         if (!has_future || version < "1.8.0") {
[10:33:12.153]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.153]                             "", base::R.version$version.string), 
[10:33:12.153]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:12.153]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.153]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.153]                               "release", "version")], collapse = " "), 
[10:33:12.153]                             hostname = base::Sys.info()[["nodename"]])
[10:33:12.153]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.153]                             info)
[10:33:12.153]                           info <- base::paste(info, collapse = "; ")
[10:33:12.153]                           if (!has_future) {
[10:33:12.153]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.153]                               info)
[10:33:12.153]                           }
[10:33:12.153]                           else {
[10:33:12.153]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.153]                               info, version)
[10:33:12.153]                           }
[10:33:12.153]                           base::stop(msg)
[10:33:12.153]                         }
[10:33:12.153]                       })
[10:33:12.153]                     }
[10:33:12.153]                     base::local({
[10:33:12.153]                       for (pkg in "future") {
[10:33:12.153]                         base::loadNamespace(pkg)
[10:33:12.153]                         base::library(pkg, character.only = TRUE)
[10:33:12.153]                       }
[10:33:12.153]                     })
[10:33:12.153]                   }
[10:33:12.153]                   ...future.strategy.old <- future::plan("list")
[10:33:12.153]                   options(future.plan = NULL)
[10:33:12.153]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.153]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.153]                 }
[10:33:12.153]                 ...future.workdir <- getwd()
[10:33:12.153]             }
[10:33:12.153]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.153]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.153]         }
[10:33:12.153]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.153]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.153]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.153]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.153]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.153]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.153]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.153]             base::names(...future.oldOptions))
[10:33:12.153]     }
[10:33:12.153]     if (FALSE) {
[10:33:12.153]     }
[10:33:12.153]     else {
[10:33:12.153]         if (TRUE) {
[10:33:12.153]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.153]                 open = "w")
[10:33:12.153]         }
[10:33:12.153]         else {
[10:33:12.153]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.153]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.153]         }
[10:33:12.153]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.153]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.153]             base::sink(type = "output", split = FALSE)
[10:33:12.153]             base::close(...future.stdout)
[10:33:12.153]         }, add = TRUE)
[10:33:12.153]     }
[10:33:12.153]     ...future.frame <- base::sys.nframe()
[10:33:12.153]     ...future.conditions <- base::list()
[10:33:12.153]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.153]     if (FALSE) {
[10:33:12.153]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.153]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.153]     }
[10:33:12.153]     ...future.result <- base::tryCatch({
[10:33:12.153]         base::withCallingHandlers({
[10:33:12.153]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:33:12.153]                 1))
[10:33:12.153]             future::FutureResult(value = ...future.value$value, 
[10:33:12.153]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.153]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.153]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.153]                     ...future.globalenv.names))
[10:33:12.153]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.153]         }, condition = base::local({
[10:33:12.153]             c <- base::c
[10:33:12.153]             inherits <- base::inherits
[10:33:12.153]             invokeRestart <- base::invokeRestart
[10:33:12.153]             length <- base::length
[10:33:12.153]             list <- base::list
[10:33:12.153]             seq.int <- base::seq.int
[10:33:12.153]             signalCondition <- base::signalCondition
[10:33:12.153]             sys.calls <- base::sys.calls
[10:33:12.153]             `[[` <- base::`[[`
[10:33:12.153]             `+` <- base::`+`
[10:33:12.153]             `<<-` <- base::`<<-`
[10:33:12.153]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.153]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.153]                   3L)]
[10:33:12.153]             }
[10:33:12.153]             function(cond) {
[10:33:12.153]                 is_error <- inherits(cond, "error")
[10:33:12.153]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.153]                   NULL)
[10:33:12.153]                 if (is_error) {
[10:33:12.153]                   sessionInformation <- function() {
[10:33:12.153]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.153]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.153]                       search = base::search(), system = base::Sys.info())
[10:33:12.153]                   }
[10:33:12.153]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.153]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.153]                     cond$call), session = sessionInformation(), 
[10:33:12.153]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.153]                   signalCondition(cond)
[10:33:12.153]                 }
[10:33:12.153]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.153]                 "immediateCondition"))) {
[10:33:12.153]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.153]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.153]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.153]                   if (TRUE && !signal) {
[10:33:12.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.153]                     {
[10:33:12.153]                       inherits <- base::inherits
[10:33:12.153]                       invokeRestart <- base::invokeRestart
[10:33:12.153]                       is.null <- base::is.null
[10:33:12.153]                       muffled <- FALSE
[10:33:12.153]                       if (inherits(cond, "message")) {
[10:33:12.153]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.153]                         if (muffled) 
[10:33:12.153]                           invokeRestart("muffleMessage")
[10:33:12.153]                       }
[10:33:12.153]                       else if (inherits(cond, "warning")) {
[10:33:12.153]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.153]                         if (muffled) 
[10:33:12.153]                           invokeRestart("muffleWarning")
[10:33:12.153]                       }
[10:33:12.153]                       else if (inherits(cond, "condition")) {
[10:33:12.153]                         if (!is.null(pattern)) {
[10:33:12.153]                           computeRestarts <- base::computeRestarts
[10:33:12.153]                           grepl <- base::grepl
[10:33:12.153]                           restarts <- computeRestarts(cond)
[10:33:12.153]                           for (restart in restarts) {
[10:33:12.153]                             name <- restart$name
[10:33:12.153]                             if (is.null(name)) 
[10:33:12.153]                               next
[10:33:12.153]                             if (!grepl(pattern, name)) 
[10:33:12.153]                               next
[10:33:12.153]                             invokeRestart(restart)
[10:33:12.153]                             muffled <- TRUE
[10:33:12.153]                             break
[10:33:12.153]                           }
[10:33:12.153]                         }
[10:33:12.153]                       }
[10:33:12.153]                       invisible(muffled)
[10:33:12.153]                     }
[10:33:12.153]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.153]                   }
[10:33:12.153]                 }
[10:33:12.153]                 else {
[10:33:12.153]                   if (TRUE) {
[10:33:12.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.153]                     {
[10:33:12.153]                       inherits <- base::inherits
[10:33:12.153]                       invokeRestart <- base::invokeRestart
[10:33:12.153]                       is.null <- base::is.null
[10:33:12.153]                       muffled <- FALSE
[10:33:12.153]                       if (inherits(cond, "message")) {
[10:33:12.153]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.153]                         if (muffled) 
[10:33:12.153]                           invokeRestart("muffleMessage")
[10:33:12.153]                       }
[10:33:12.153]                       else if (inherits(cond, "warning")) {
[10:33:12.153]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.153]                         if (muffled) 
[10:33:12.153]                           invokeRestart("muffleWarning")
[10:33:12.153]                       }
[10:33:12.153]                       else if (inherits(cond, "condition")) {
[10:33:12.153]                         if (!is.null(pattern)) {
[10:33:12.153]                           computeRestarts <- base::computeRestarts
[10:33:12.153]                           grepl <- base::grepl
[10:33:12.153]                           restarts <- computeRestarts(cond)
[10:33:12.153]                           for (restart in restarts) {
[10:33:12.153]                             name <- restart$name
[10:33:12.153]                             if (is.null(name)) 
[10:33:12.153]                               next
[10:33:12.153]                             if (!grepl(pattern, name)) 
[10:33:12.153]                               next
[10:33:12.153]                             invokeRestart(restart)
[10:33:12.153]                             muffled <- TRUE
[10:33:12.153]                             break
[10:33:12.153]                           }
[10:33:12.153]                         }
[10:33:12.153]                       }
[10:33:12.153]                       invisible(muffled)
[10:33:12.153]                     }
[10:33:12.153]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.153]                   }
[10:33:12.153]                 }
[10:33:12.153]             }
[10:33:12.153]         }))
[10:33:12.153]     }, error = function(ex) {
[10:33:12.153]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.153]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.153]                 ...future.rng), started = ...future.startTime, 
[10:33:12.153]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.153]             version = "1.8"), class = "FutureResult")
[10:33:12.153]     }, finally = {
[10:33:12.153]         if (!identical(...future.workdir, getwd())) 
[10:33:12.153]             setwd(...future.workdir)
[10:33:12.153]         {
[10:33:12.153]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.153]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.153]             }
[10:33:12.153]             base::options(...future.oldOptions)
[10:33:12.153]             if (.Platform$OS.type == "windows") {
[10:33:12.153]                 old_names <- names(...future.oldEnvVars)
[10:33:12.153]                 envs <- base::Sys.getenv()
[10:33:12.153]                 names <- names(envs)
[10:33:12.153]                 common <- intersect(names, old_names)
[10:33:12.153]                 added <- setdiff(names, old_names)
[10:33:12.153]                 removed <- setdiff(old_names, names)
[10:33:12.153]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.153]                   envs[common]]
[10:33:12.153]                 NAMES <- toupper(changed)
[10:33:12.153]                 args <- list()
[10:33:12.153]                 for (kk in seq_along(NAMES)) {
[10:33:12.153]                   name <- changed[[kk]]
[10:33:12.153]                   NAME <- NAMES[[kk]]
[10:33:12.153]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.153]                     next
[10:33:12.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.153]                 }
[10:33:12.153]                 NAMES <- toupper(added)
[10:33:12.153]                 for (kk in seq_along(NAMES)) {
[10:33:12.153]                   name <- added[[kk]]
[10:33:12.153]                   NAME <- NAMES[[kk]]
[10:33:12.153]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.153]                     next
[10:33:12.153]                   args[[name]] <- ""
[10:33:12.153]                 }
[10:33:12.153]                 NAMES <- toupper(removed)
[10:33:12.153]                 for (kk in seq_along(NAMES)) {
[10:33:12.153]                   name <- removed[[kk]]
[10:33:12.153]                   NAME <- NAMES[[kk]]
[10:33:12.153]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.153]                     next
[10:33:12.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.153]                 }
[10:33:12.153]                 if (length(args) > 0) 
[10:33:12.153]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.153]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.153]             }
[10:33:12.153]             else {
[10:33:12.153]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.153]             }
[10:33:12.153]             {
[10:33:12.153]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.153]                   0L) {
[10:33:12.153]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.153]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.153]                   base::options(opts)
[10:33:12.153]                 }
[10:33:12.153]                 {
[10:33:12.153]                   {
[10:33:12.153]                     NULL
[10:33:12.153]                     RNGkind("Mersenne-Twister")
[10:33:12.153]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.153]                       inherits = FALSE)
[10:33:12.153]                   }
[10:33:12.153]                   options(future.plan = NULL)
[10:33:12.153]                   if (is.na(NA_character_)) 
[10:33:12.153]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.153]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.153]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.153]                     .init = FALSE)
[10:33:12.153]                 }
[10:33:12.153]             }
[10:33:12.153]         }
[10:33:12.153]     })
[10:33:12.153]     if (TRUE) {
[10:33:12.153]         base::sink(type = "output", split = FALSE)
[10:33:12.153]         if (TRUE) {
[10:33:12.153]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.153]         }
[10:33:12.153]         else {
[10:33:12.153]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.153]         }
[10:33:12.153]         base::close(...future.stdout)
[10:33:12.153]         ...future.stdout <- NULL
[10:33:12.153]     }
[10:33:12.153]     ...future.result$conditions <- ...future.conditions
[10:33:12.153]     ...future.result$finished <- base::Sys.time()
[10:33:12.153]     ...future.result
[10:33:12.153] }
[10:33:12.155] assign_globals() ...
[10:33:12.155] List of 1
[10:33:12.155]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55aa51da6308> 
[10:33:12.155]  - attr(*, "where")=List of 1
[10:33:12.155]   ..$ a:<environment: R_EmptyEnv> 
[10:33:12.155]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.155]  - attr(*, "resolved")= logi TRUE
[10:33:12.155]  - attr(*, "total_size")= num 10592
[10:33:12.155]  - attr(*, "already-done")= logi TRUE
[10:33:12.157] - copied ‘a’ to environment
[10:33:12.157] assign_globals() ... done
[10:33:12.158] plan(): Setting new future strategy stack:
[10:33:12.158] List of future strategies:
[10:33:12.158] 1. sequential:
[10:33:12.158]    - args: function (..., envir = parent.frame())
[10:33:12.158]    - tweaked: FALSE
[10:33:12.158]    - call: NULL
[10:33:12.158] plan(): nbrOfWorkers() = 1
[10:33:12.159] plan(): Setting new future strategy stack:
[10:33:12.159] List of future strategies:
[10:33:12.159] 1. sequential:
[10:33:12.159]    - args: function (..., envir = parent.frame())
[10:33:12.159]    - tweaked: FALSE
[10:33:12.159]    - call: plan(strategy)
[10:33:12.159] plan(): nbrOfWorkers() = 1
[10:33:12.159] SequentialFuture started (and completed)
[10:33:12.159] - Launch lazy future ... done
[10:33:12.159] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.160] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.160] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.162] - globals found: [2] ‘{’, ‘pkg’
[10:33:12.162] Searching for globals ... DONE
[10:33:12.162] Resolving globals: TRUE
[10:33:12.162] Resolving any globals that are futures ...
[10:33:12.162] - globals: [2] ‘{’, ‘pkg’
[10:33:12.162] Resolving any globals that are futures ... DONE
[10:33:12.163] Resolving futures part of globals (recursively) ...
[10:33:12.163] resolve() on list ...
[10:33:12.163]  recursive: 99
[10:33:12.163]  length: 1
[10:33:12.163]  elements: ‘pkg’
[10:33:12.163]  length: 0 (resolved future 1)
[10:33:12.163] resolve() on list ... DONE
[10:33:12.163] - globals: [1] ‘pkg’
[10:33:12.163] Resolving futures part of globals (recursively) ... DONE
[10:33:12.164] The total size of the 1 globals is 112 bytes (112 bytes)
[10:33:12.164] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[10:33:12.164] - globals: [1] ‘pkg’
[10:33:12.164] 
[10:33:12.164] getGlobalsAndPackages() ... DONE
[10:33:12.164] Packages needed by the future expression (n = 0): <none>
[10:33:12.164] Packages needed by future strategies (n = 0): <none>
[10:33:12.165] {
[10:33:12.165]     {
[10:33:12.165]         {
[10:33:12.165]             ...future.startTime <- base::Sys.time()
[10:33:12.165]             {
[10:33:12.165]                 {
[10:33:12.165]                   {
[10:33:12.165]                     base::local({
[10:33:12.165]                       has_future <- base::requireNamespace("future", 
[10:33:12.165]                         quietly = TRUE)
[10:33:12.165]                       if (has_future) {
[10:33:12.165]                         ns <- base::getNamespace("future")
[10:33:12.165]                         version <- ns[[".package"]][["version"]]
[10:33:12.165]                         if (is.null(version)) 
[10:33:12.165]                           version <- utils::packageVersion("future")
[10:33:12.165]                       }
[10:33:12.165]                       else {
[10:33:12.165]                         version <- NULL
[10:33:12.165]                       }
[10:33:12.165]                       if (!has_future || version < "1.8.0") {
[10:33:12.165]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.165]                           "", base::R.version$version.string), 
[10:33:12.165]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.165]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.165]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.165]                             "release", "version")], collapse = " "), 
[10:33:12.165]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.165]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.165]                           info)
[10:33:12.165]                         info <- base::paste(info, collapse = "; ")
[10:33:12.165]                         if (!has_future) {
[10:33:12.165]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.165]                             info)
[10:33:12.165]                         }
[10:33:12.165]                         else {
[10:33:12.165]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.165]                             info, version)
[10:33:12.165]                         }
[10:33:12.165]                         base::stop(msg)
[10:33:12.165]                       }
[10:33:12.165]                     })
[10:33:12.165]                   }
[10:33:12.165]                   ...future.strategy.old <- future::plan("list")
[10:33:12.165]                   options(future.plan = NULL)
[10:33:12.165]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.165]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.165]                 }
[10:33:12.165]                 ...future.workdir <- getwd()
[10:33:12.165]             }
[10:33:12.165]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.165]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.165]         }
[10:33:12.165]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.165]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.165]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.165]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.165]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.165]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.165]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.165]             base::names(...future.oldOptions))
[10:33:12.165]     }
[10:33:12.165]     if (FALSE) {
[10:33:12.165]     }
[10:33:12.165]     else {
[10:33:12.165]         if (TRUE) {
[10:33:12.165]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.165]                 open = "w")
[10:33:12.165]         }
[10:33:12.165]         else {
[10:33:12.165]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.165]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.165]         }
[10:33:12.165]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.165]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.165]             base::sink(type = "output", split = FALSE)
[10:33:12.165]             base::close(...future.stdout)
[10:33:12.165]         }, add = TRUE)
[10:33:12.165]     }
[10:33:12.165]     ...future.frame <- base::sys.nframe()
[10:33:12.165]     ...future.conditions <- base::list()
[10:33:12.165]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.165]     if (FALSE) {
[10:33:12.165]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.165]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.165]     }
[10:33:12.165]     ...future.result <- base::tryCatch({
[10:33:12.165]         base::withCallingHandlers({
[10:33:12.165]             ...future.value <- base::withVisible(base::local({
[10:33:12.165]                 pkg
[10:33:12.165]             }))
[10:33:12.165]             future::FutureResult(value = ...future.value$value, 
[10:33:12.165]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.165]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.165]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.165]                     ...future.globalenv.names))
[10:33:12.165]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.165]         }, condition = base::local({
[10:33:12.165]             c <- base::c
[10:33:12.165]             inherits <- base::inherits
[10:33:12.165]             invokeRestart <- base::invokeRestart
[10:33:12.165]             length <- base::length
[10:33:12.165]             list <- base::list
[10:33:12.165]             seq.int <- base::seq.int
[10:33:12.165]             signalCondition <- base::signalCondition
[10:33:12.165]             sys.calls <- base::sys.calls
[10:33:12.165]             `[[` <- base::`[[`
[10:33:12.165]             `+` <- base::`+`
[10:33:12.165]             `<<-` <- base::`<<-`
[10:33:12.165]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.165]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.165]                   3L)]
[10:33:12.165]             }
[10:33:12.165]             function(cond) {
[10:33:12.165]                 is_error <- inherits(cond, "error")
[10:33:12.165]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.165]                   NULL)
[10:33:12.165]                 if (is_error) {
[10:33:12.165]                   sessionInformation <- function() {
[10:33:12.165]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.165]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.165]                       search = base::search(), system = base::Sys.info())
[10:33:12.165]                   }
[10:33:12.165]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.165]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.165]                     cond$call), session = sessionInformation(), 
[10:33:12.165]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.165]                   signalCondition(cond)
[10:33:12.165]                 }
[10:33:12.165]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.165]                 "immediateCondition"))) {
[10:33:12.165]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.165]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.165]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.165]                   if (TRUE && !signal) {
[10:33:12.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.165]                     {
[10:33:12.165]                       inherits <- base::inherits
[10:33:12.165]                       invokeRestart <- base::invokeRestart
[10:33:12.165]                       is.null <- base::is.null
[10:33:12.165]                       muffled <- FALSE
[10:33:12.165]                       if (inherits(cond, "message")) {
[10:33:12.165]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.165]                         if (muffled) 
[10:33:12.165]                           invokeRestart("muffleMessage")
[10:33:12.165]                       }
[10:33:12.165]                       else if (inherits(cond, "warning")) {
[10:33:12.165]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.165]                         if (muffled) 
[10:33:12.165]                           invokeRestart("muffleWarning")
[10:33:12.165]                       }
[10:33:12.165]                       else if (inherits(cond, "condition")) {
[10:33:12.165]                         if (!is.null(pattern)) {
[10:33:12.165]                           computeRestarts <- base::computeRestarts
[10:33:12.165]                           grepl <- base::grepl
[10:33:12.165]                           restarts <- computeRestarts(cond)
[10:33:12.165]                           for (restart in restarts) {
[10:33:12.165]                             name <- restart$name
[10:33:12.165]                             if (is.null(name)) 
[10:33:12.165]                               next
[10:33:12.165]                             if (!grepl(pattern, name)) 
[10:33:12.165]                               next
[10:33:12.165]                             invokeRestart(restart)
[10:33:12.165]                             muffled <- TRUE
[10:33:12.165]                             break
[10:33:12.165]                           }
[10:33:12.165]                         }
[10:33:12.165]                       }
[10:33:12.165]                       invisible(muffled)
[10:33:12.165]                     }
[10:33:12.165]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.165]                   }
[10:33:12.165]                 }
[10:33:12.165]                 else {
[10:33:12.165]                   if (TRUE) {
[10:33:12.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.165]                     {
[10:33:12.165]                       inherits <- base::inherits
[10:33:12.165]                       invokeRestart <- base::invokeRestart
[10:33:12.165]                       is.null <- base::is.null
[10:33:12.165]                       muffled <- FALSE
[10:33:12.165]                       if (inherits(cond, "message")) {
[10:33:12.165]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.165]                         if (muffled) 
[10:33:12.165]                           invokeRestart("muffleMessage")
[10:33:12.165]                       }
[10:33:12.165]                       else if (inherits(cond, "warning")) {
[10:33:12.165]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.165]                         if (muffled) 
[10:33:12.165]                           invokeRestart("muffleWarning")
[10:33:12.165]                       }
[10:33:12.165]                       else if (inherits(cond, "condition")) {
[10:33:12.165]                         if (!is.null(pattern)) {
[10:33:12.165]                           computeRestarts <- base::computeRestarts
[10:33:12.165]                           grepl <- base::grepl
[10:33:12.165]                           restarts <- computeRestarts(cond)
[10:33:12.165]                           for (restart in restarts) {
[10:33:12.165]                             name <- restart$name
[10:33:12.165]                             if (is.null(name)) 
[10:33:12.165]                               next
[10:33:12.165]                             if (!grepl(pattern, name)) 
[10:33:12.165]                               next
[10:33:12.165]                             invokeRestart(restart)
[10:33:12.165]                             muffled <- TRUE
[10:33:12.165]                             break
[10:33:12.165]                           }
[10:33:12.165]                         }
[10:33:12.165]                       }
[10:33:12.165]                       invisible(muffled)
[10:33:12.165]                     }
[10:33:12.165]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.165]                   }
[10:33:12.165]                 }
[10:33:12.165]             }
[10:33:12.165]         }))
[10:33:12.165]     }, error = function(ex) {
[10:33:12.165]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.165]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.165]                 ...future.rng), started = ...future.startTime, 
[10:33:12.165]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.165]             version = "1.8"), class = "FutureResult")
[10:33:12.165]     }, finally = {
[10:33:12.165]         if (!identical(...future.workdir, getwd())) 
[10:33:12.165]             setwd(...future.workdir)
[10:33:12.165]         {
[10:33:12.165]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.165]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.165]             }
[10:33:12.165]             base::options(...future.oldOptions)
[10:33:12.165]             if (.Platform$OS.type == "windows") {
[10:33:12.165]                 old_names <- names(...future.oldEnvVars)
[10:33:12.165]                 envs <- base::Sys.getenv()
[10:33:12.165]                 names <- names(envs)
[10:33:12.165]                 common <- intersect(names, old_names)
[10:33:12.165]                 added <- setdiff(names, old_names)
[10:33:12.165]                 removed <- setdiff(old_names, names)
[10:33:12.165]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.165]                   envs[common]]
[10:33:12.165]                 NAMES <- toupper(changed)
[10:33:12.165]                 args <- list()
[10:33:12.165]                 for (kk in seq_along(NAMES)) {
[10:33:12.165]                   name <- changed[[kk]]
[10:33:12.165]                   NAME <- NAMES[[kk]]
[10:33:12.165]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.165]                     next
[10:33:12.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.165]                 }
[10:33:12.165]                 NAMES <- toupper(added)
[10:33:12.165]                 for (kk in seq_along(NAMES)) {
[10:33:12.165]                   name <- added[[kk]]
[10:33:12.165]                   NAME <- NAMES[[kk]]
[10:33:12.165]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.165]                     next
[10:33:12.165]                   args[[name]] <- ""
[10:33:12.165]                 }
[10:33:12.165]                 NAMES <- toupper(removed)
[10:33:12.165]                 for (kk in seq_along(NAMES)) {
[10:33:12.165]                   name <- removed[[kk]]
[10:33:12.165]                   NAME <- NAMES[[kk]]
[10:33:12.165]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.165]                     next
[10:33:12.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.165]                 }
[10:33:12.165]                 if (length(args) > 0) 
[10:33:12.165]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.165]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.165]             }
[10:33:12.165]             else {
[10:33:12.165]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.165]             }
[10:33:12.165]             {
[10:33:12.165]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.165]                   0L) {
[10:33:12.165]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.165]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.165]                   base::options(opts)
[10:33:12.165]                 }
[10:33:12.165]                 {
[10:33:12.165]                   {
[10:33:12.165]                     NULL
[10:33:12.165]                     RNGkind("Mersenne-Twister")
[10:33:12.165]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.165]                       inherits = FALSE)
[10:33:12.165]                   }
[10:33:12.165]                   options(future.plan = NULL)
[10:33:12.165]                   if (is.na(NA_character_)) 
[10:33:12.165]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.165]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.165]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.165]                     .init = FALSE)
[10:33:12.165]                 }
[10:33:12.165]             }
[10:33:12.165]         }
[10:33:12.165]     })
[10:33:12.165]     if (TRUE) {
[10:33:12.165]         base::sink(type = "output", split = FALSE)
[10:33:12.165]         if (TRUE) {
[10:33:12.165]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.165]         }
[10:33:12.165]         else {
[10:33:12.165]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.165]         }
[10:33:12.165]         base::close(...future.stdout)
[10:33:12.165]         ...future.stdout <- NULL
[10:33:12.165]     }
[10:33:12.165]     ...future.result$conditions <- ...future.conditions
[10:33:12.165]     ...future.result$finished <- base::Sys.time()
[10:33:12.165]     ...future.result
[10:33:12.165] }
[10:33:12.166] assign_globals() ...
[10:33:12.166] List of 1
[10:33:12.166]  $ pkg: chr "foo"
[10:33:12.166]  - attr(*, "where")=List of 1
[10:33:12.166]   ..$ pkg:<environment: R_EmptyEnv> 
[10:33:12.166]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.166]  - attr(*, "resolved")= logi TRUE
[10:33:12.166]  - attr(*, "total_size")= num 112
[10:33:12.168] - copied ‘pkg’ to environment
[10:33:12.168] assign_globals() ... done
[10:33:12.169] plan(): Setting new future strategy stack:
[10:33:12.169] List of future strategies:
[10:33:12.169] 1. sequential:
[10:33:12.169]    - args: function (..., envir = parent.frame())
[10:33:12.169]    - tweaked: FALSE
[10:33:12.169]    - call: NULL
[10:33:12.169] plan(): nbrOfWorkers() = 1
[10:33:12.170] plan(): Setting new future strategy stack:
[10:33:12.170] List of future strategies:
[10:33:12.170] 1. sequential:
[10:33:12.170]    - args: function (..., envir = parent.frame())
[10:33:12.170]    - tweaked: FALSE
[10:33:12.170]    - call: plan(strategy)
[10:33:12.170] plan(): nbrOfWorkers() = 1
[10:33:12.170] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.171] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.171] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:12.173] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:33:12.173] Searching for globals ... DONE
[10:33:12.174] Resolving globals: TRUE
[10:33:12.174] Resolving any globals that are futures ...
[10:33:12.174] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:33:12.174] Resolving any globals that are futures ... DONE
[10:33:12.174] Resolving futures part of globals (recursively) ...
[10:33:12.174] resolve() on list ...
[10:33:12.174]  recursive: 99
[10:33:12.175]  length: 1
[10:33:12.175]  elements: ‘a’
[10:33:12.175]  length: 0 (resolved future 1)
[10:33:12.175] resolve() on list ... DONE
[10:33:12.175] - globals: [1] ‘a’
[10:33:12.175] Resolving futures part of globals (recursively) ... DONE
[10:33:12.175] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:12.175] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:33:12.176] - globals: [1] ‘a’
[10:33:12.176] 
[10:33:12.176] getGlobalsAndPackages() ... DONE
[10:33:12.176] run() for ‘Future’ ...
[10:33:12.176] - state: ‘created’
[10:33:12.176] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.176] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.176] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.177]   - Field: ‘label’
[10:33:12.177]   - Field: ‘local’
[10:33:12.177]   - Field: ‘owner’
[10:33:12.177]   - Field: ‘envir’
[10:33:12.177]   - Field: ‘packages’
[10:33:12.177]   - Field: ‘gc’
[10:33:12.177]   - Field: ‘conditions’
[10:33:12.177]   - Field: ‘expr’
[10:33:12.177]   - Field: ‘uuid’
[10:33:12.177]   - Field: ‘seed’
[10:33:12.178]   - Field: ‘version’
[10:33:12.178]   - Field: ‘result’
[10:33:12.178]   - Field: ‘asynchronous’
[10:33:12.178]   - Field: ‘calls’
[10:33:12.178]   - Field: ‘globals’
[10:33:12.178]   - Field: ‘stdout’
[10:33:12.178]   - Field: ‘earlySignal’
[10:33:12.178]   - Field: ‘lazy’
[10:33:12.178]   - Field: ‘state’
[10:33:12.178] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.178] - Launch lazy future ...
[10:33:12.179] Packages needed by the future expression (n = 0): <none>
[10:33:12.179] Packages needed by future strategies (n = 0): <none>
[10:33:12.179] {
[10:33:12.179]     {
[10:33:12.179]         {
[10:33:12.179]             ...future.startTime <- base::Sys.time()
[10:33:12.179]             {
[10:33:12.179]                 {
[10:33:12.179]                   {
[10:33:12.179]                     base::local({
[10:33:12.179]                       has_future <- base::requireNamespace("future", 
[10:33:12.179]                         quietly = TRUE)
[10:33:12.179]                       if (has_future) {
[10:33:12.179]                         ns <- base::getNamespace("future")
[10:33:12.179]                         version <- ns[[".package"]][["version"]]
[10:33:12.179]                         if (is.null(version)) 
[10:33:12.179]                           version <- utils::packageVersion("future")
[10:33:12.179]                       }
[10:33:12.179]                       else {
[10:33:12.179]                         version <- NULL
[10:33:12.179]                       }
[10:33:12.179]                       if (!has_future || version < "1.8.0") {
[10:33:12.179]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.179]                           "", base::R.version$version.string), 
[10:33:12.179]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.179]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.179]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.179]                             "release", "version")], collapse = " "), 
[10:33:12.179]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.179]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.179]                           info)
[10:33:12.179]                         info <- base::paste(info, collapse = "; ")
[10:33:12.179]                         if (!has_future) {
[10:33:12.179]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.179]                             info)
[10:33:12.179]                         }
[10:33:12.179]                         else {
[10:33:12.179]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.179]                             info, version)
[10:33:12.179]                         }
[10:33:12.179]                         base::stop(msg)
[10:33:12.179]                       }
[10:33:12.179]                     })
[10:33:12.179]                   }
[10:33:12.179]                   ...future.strategy.old <- future::plan("list")
[10:33:12.179]                   options(future.plan = NULL)
[10:33:12.179]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.179]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.179]                 }
[10:33:12.179]                 ...future.workdir <- getwd()
[10:33:12.179]             }
[10:33:12.179]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.179]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.179]         }
[10:33:12.179]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.179]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:12.179]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.179]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.179]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.179]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.179]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.179]             base::names(...future.oldOptions))
[10:33:12.179]     }
[10:33:12.179]     if (FALSE) {
[10:33:12.179]     }
[10:33:12.179]     else {
[10:33:12.179]         if (TRUE) {
[10:33:12.179]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.179]                 open = "w")
[10:33:12.179]         }
[10:33:12.179]         else {
[10:33:12.179]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.179]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.179]         }
[10:33:12.179]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.179]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.179]             base::sink(type = "output", split = FALSE)
[10:33:12.179]             base::close(...future.stdout)
[10:33:12.179]         }, add = TRUE)
[10:33:12.179]     }
[10:33:12.179]     ...future.frame <- base::sys.nframe()
[10:33:12.179]     ...future.conditions <- base::list()
[10:33:12.179]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.179]     if (FALSE) {
[10:33:12.179]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.179]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.179]     }
[10:33:12.179]     ...future.result <- base::tryCatch({
[10:33:12.179]         base::withCallingHandlers({
[10:33:12.179]             ...future.value <- base::withVisible(base::local({
[10:33:12.179]                 b <- a
[10:33:12.179]                 a <- 2
[10:33:12.179]                 a * b
[10:33:12.179]             }))
[10:33:12.179]             future::FutureResult(value = ...future.value$value, 
[10:33:12.179]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.179]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.179]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.179]                     ...future.globalenv.names))
[10:33:12.179]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.179]         }, condition = base::local({
[10:33:12.179]             c <- base::c
[10:33:12.179]             inherits <- base::inherits
[10:33:12.179]             invokeRestart <- base::invokeRestart
[10:33:12.179]             length <- base::length
[10:33:12.179]             list <- base::list
[10:33:12.179]             seq.int <- base::seq.int
[10:33:12.179]             signalCondition <- base::signalCondition
[10:33:12.179]             sys.calls <- base::sys.calls
[10:33:12.179]             `[[` <- base::`[[`
[10:33:12.179]             `+` <- base::`+`
[10:33:12.179]             `<<-` <- base::`<<-`
[10:33:12.179]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.179]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.179]                   3L)]
[10:33:12.179]             }
[10:33:12.179]             function(cond) {
[10:33:12.179]                 is_error <- inherits(cond, "error")
[10:33:12.179]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.179]                   NULL)
[10:33:12.179]                 if (is_error) {
[10:33:12.179]                   sessionInformation <- function() {
[10:33:12.179]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.179]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.179]                       search = base::search(), system = base::Sys.info())
[10:33:12.179]                   }
[10:33:12.179]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.179]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.179]                     cond$call), session = sessionInformation(), 
[10:33:12.179]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.179]                   signalCondition(cond)
[10:33:12.179]                 }
[10:33:12.179]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.179]                 "immediateCondition"))) {
[10:33:12.179]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.179]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.179]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.179]                   if (TRUE && !signal) {
[10:33:12.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.179]                     {
[10:33:12.179]                       inherits <- base::inherits
[10:33:12.179]                       invokeRestart <- base::invokeRestart
[10:33:12.179]                       is.null <- base::is.null
[10:33:12.179]                       muffled <- FALSE
[10:33:12.179]                       if (inherits(cond, "message")) {
[10:33:12.179]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.179]                         if (muffled) 
[10:33:12.179]                           invokeRestart("muffleMessage")
[10:33:12.179]                       }
[10:33:12.179]                       else if (inherits(cond, "warning")) {
[10:33:12.179]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.179]                         if (muffled) 
[10:33:12.179]                           invokeRestart("muffleWarning")
[10:33:12.179]                       }
[10:33:12.179]                       else if (inherits(cond, "condition")) {
[10:33:12.179]                         if (!is.null(pattern)) {
[10:33:12.179]                           computeRestarts <- base::computeRestarts
[10:33:12.179]                           grepl <- base::grepl
[10:33:12.179]                           restarts <- computeRestarts(cond)
[10:33:12.179]                           for (restart in restarts) {
[10:33:12.179]                             name <- restart$name
[10:33:12.179]                             if (is.null(name)) 
[10:33:12.179]                               next
[10:33:12.179]                             if (!grepl(pattern, name)) 
[10:33:12.179]                               next
[10:33:12.179]                             invokeRestart(restart)
[10:33:12.179]                             muffled <- TRUE
[10:33:12.179]                             break
[10:33:12.179]                           }
[10:33:12.179]                         }
[10:33:12.179]                       }
[10:33:12.179]                       invisible(muffled)
[10:33:12.179]                     }
[10:33:12.179]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.179]                   }
[10:33:12.179]                 }
[10:33:12.179]                 else {
[10:33:12.179]                   if (TRUE) {
[10:33:12.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.179]                     {
[10:33:12.179]                       inherits <- base::inherits
[10:33:12.179]                       invokeRestart <- base::invokeRestart
[10:33:12.179]                       is.null <- base::is.null
[10:33:12.179]                       muffled <- FALSE
[10:33:12.179]                       if (inherits(cond, "message")) {
[10:33:12.179]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.179]                         if (muffled) 
[10:33:12.179]                           invokeRestart("muffleMessage")
[10:33:12.179]                       }
[10:33:12.179]                       else if (inherits(cond, "warning")) {
[10:33:12.179]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.179]                         if (muffled) 
[10:33:12.179]                           invokeRestart("muffleWarning")
[10:33:12.179]                       }
[10:33:12.179]                       else if (inherits(cond, "condition")) {
[10:33:12.179]                         if (!is.null(pattern)) {
[10:33:12.179]                           computeRestarts <- base::computeRestarts
[10:33:12.179]                           grepl <- base::grepl
[10:33:12.179]                           restarts <- computeRestarts(cond)
[10:33:12.179]                           for (restart in restarts) {
[10:33:12.179]                             name <- restart$name
[10:33:12.179]                             if (is.null(name)) 
[10:33:12.179]                               next
[10:33:12.179]                             if (!grepl(pattern, name)) 
[10:33:12.179]                               next
[10:33:12.179]                             invokeRestart(restart)
[10:33:12.179]                             muffled <- TRUE
[10:33:12.179]                             break
[10:33:12.179]                           }
[10:33:12.179]                         }
[10:33:12.179]                       }
[10:33:12.179]                       invisible(muffled)
[10:33:12.179]                     }
[10:33:12.179]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.179]                   }
[10:33:12.179]                 }
[10:33:12.179]             }
[10:33:12.179]         }))
[10:33:12.179]     }, error = function(ex) {
[10:33:12.179]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.179]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.179]                 ...future.rng), started = ...future.startTime, 
[10:33:12.179]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.179]             version = "1.8"), class = "FutureResult")
[10:33:12.179]     }, finally = {
[10:33:12.179]         if (!identical(...future.workdir, getwd())) 
[10:33:12.179]             setwd(...future.workdir)
[10:33:12.179]         {
[10:33:12.179]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.179]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.179]             }
[10:33:12.179]             base::options(...future.oldOptions)
[10:33:12.179]             if (.Platform$OS.type == "windows") {
[10:33:12.179]                 old_names <- names(...future.oldEnvVars)
[10:33:12.179]                 envs <- base::Sys.getenv()
[10:33:12.179]                 names <- names(envs)
[10:33:12.179]                 common <- intersect(names, old_names)
[10:33:12.179]                 added <- setdiff(names, old_names)
[10:33:12.179]                 removed <- setdiff(old_names, names)
[10:33:12.179]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.179]                   envs[common]]
[10:33:12.179]                 NAMES <- toupper(changed)
[10:33:12.179]                 args <- list()
[10:33:12.179]                 for (kk in seq_along(NAMES)) {
[10:33:12.179]                   name <- changed[[kk]]
[10:33:12.179]                   NAME <- NAMES[[kk]]
[10:33:12.179]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.179]                     next
[10:33:12.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.179]                 }
[10:33:12.179]                 NAMES <- toupper(added)
[10:33:12.179]                 for (kk in seq_along(NAMES)) {
[10:33:12.179]                   name <- added[[kk]]
[10:33:12.179]                   NAME <- NAMES[[kk]]
[10:33:12.179]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.179]                     next
[10:33:12.179]                   args[[name]] <- ""
[10:33:12.179]                 }
[10:33:12.179]                 NAMES <- toupper(removed)
[10:33:12.179]                 for (kk in seq_along(NAMES)) {
[10:33:12.179]                   name <- removed[[kk]]
[10:33:12.179]                   NAME <- NAMES[[kk]]
[10:33:12.179]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.179]                     next
[10:33:12.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.179]                 }
[10:33:12.179]                 if (length(args) > 0) 
[10:33:12.179]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.179]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.179]             }
[10:33:12.179]             else {
[10:33:12.179]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.179]             }
[10:33:12.179]             {
[10:33:12.179]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.179]                   0L) {
[10:33:12.179]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.179]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.179]                   base::options(opts)
[10:33:12.179]                 }
[10:33:12.179]                 {
[10:33:12.179]                   {
[10:33:12.179]                     NULL
[10:33:12.179]                     RNGkind("Mersenne-Twister")
[10:33:12.179]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.179]                       inherits = FALSE)
[10:33:12.179]                   }
[10:33:12.179]                   options(future.plan = NULL)
[10:33:12.179]                   if (is.na(NA_character_)) 
[10:33:12.179]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.179]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.179]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.179]                     .init = FALSE)
[10:33:12.179]                 }
[10:33:12.179]             }
[10:33:12.179]         }
[10:33:12.179]     })
[10:33:12.179]     if (TRUE) {
[10:33:12.179]         base::sink(type = "output", split = FALSE)
[10:33:12.179]         if (TRUE) {
[10:33:12.179]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.179]         }
[10:33:12.179]         else {
[10:33:12.179]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.179]         }
[10:33:12.179]         base::close(...future.stdout)
[10:33:12.179]         ...future.stdout <- NULL
[10:33:12.179]     }
[10:33:12.179]     ...future.result$conditions <- ...future.conditions
[10:33:12.179]     ...future.result$finished <- base::Sys.time()
[10:33:12.179]     ...future.result
[10:33:12.179] }
[10:33:12.180] assign_globals() ...
[10:33:12.181] List of 1
[10:33:12.181]  $ a: num 3
[10:33:12.181]  - attr(*, "where")=List of 1
[10:33:12.181]   ..$ a:<environment: R_EmptyEnv> 
[10:33:12.181]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.181]  - attr(*, "resolved")= logi TRUE
[10:33:12.181]  - attr(*, "total_size")= num 56
[10:33:12.181]  - attr(*, "already-done")= logi TRUE
[10:33:12.183] - copied ‘a’ to environment
[10:33:12.183] assign_globals() ... done
[10:33:12.183] plan(): Setting new future strategy stack:
[10:33:12.183] List of future strategies:
[10:33:12.183] 1. sequential:
[10:33:12.183]    - args: function (..., envir = parent.frame())
[10:33:12.183]    - tweaked: FALSE
[10:33:12.183]    - call: NULL
[10:33:12.184] plan(): nbrOfWorkers() = 1
[10:33:12.184] plan(): Setting new future strategy stack:
[10:33:12.184] List of future strategies:
[10:33:12.184] 1. sequential:
[10:33:12.184]    - args: function (..., envir = parent.frame())
[10:33:12.184]    - tweaked: FALSE
[10:33:12.184]    - call: plan(strategy)
[10:33:12.185] plan(): nbrOfWorkers() = 1
[10:33:12.185] SequentialFuture started (and completed)
[10:33:12.185] - Launch lazy future ... done
[10:33:12.185] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.187] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.187] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:12.188] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:33:12.188] Searching for globals ... DONE
[10:33:12.189] Resolving globals: TRUE
[10:33:12.189] Resolving any globals that are futures ...
[10:33:12.189] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:33:12.189] Resolving any globals that are futures ... DONE
[10:33:12.189] Resolving futures part of globals (recursively) ...
[10:33:12.189] resolve() on list ...
[10:33:12.189]  recursive: 99
[10:33:12.190]  length: 1
[10:33:12.190]  elements: ‘a’
[10:33:12.190]  length: 0 (resolved future 1)
[10:33:12.190] resolve() on list ... DONE
[10:33:12.190] - globals: [1] ‘a’
[10:33:12.190] Resolving futures part of globals (recursively) ... DONE
[10:33:12.190] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:12.190] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:33:12.191] - globals: [1] ‘a’
[10:33:12.191] 
[10:33:12.191] getGlobalsAndPackages() ... DONE
[10:33:12.191] run() for ‘Future’ ...
[10:33:12.191] - state: ‘created’
[10:33:12.191] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.191] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.192] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.192]   - Field: ‘label’
[10:33:12.192]   - Field: ‘local’
[10:33:12.192]   - Field: ‘owner’
[10:33:12.192]   - Field: ‘envir’
[10:33:12.192]   - Field: ‘packages’
[10:33:12.192]   - Field: ‘gc’
[10:33:12.192]   - Field: ‘conditions’
[10:33:12.192]   - Field: ‘expr’
[10:33:12.192]   - Field: ‘uuid’
[10:33:12.192]   - Field: ‘seed’
[10:33:12.193]   - Field: ‘version’
[10:33:12.193]   - Field: ‘result’
[10:33:12.193]   - Field: ‘asynchronous’
[10:33:12.193]   - Field: ‘calls’
[10:33:12.193]   - Field: ‘globals’
[10:33:12.193]   - Field: ‘stdout’
[10:33:12.193]   - Field: ‘earlySignal’
[10:33:12.193]   - Field: ‘lazy’
[10:33:12.193]   - Field: ‘state’
[10:33:12.193] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.193] - Launch lazy future ...
[10:33:12.194] Packages needed by the future expression (n = 0): <none>
[10:33:12.194] Packages needed by future strategies (n = 0): <none>
[10:33:12.194] {
[10:33:12.194]     {
[10:33:12.194]         {
[10:33:12.194]             ...future.startTime <- base::Sys.time()
[10:33:12.194]             {
[10:33:12.194]                 {
[10:33:12.194]                   {
[10:33:12.194]                     base::local({
[10:33:12.194]                       has_future <- base::requireNamespace("future", 
[10:33:12.194]                         quietly = TRUE)
[10:33:12.194]                       if (has_future) {
[10:33:12.194]                         ns <- base::getNamespace("future")
[10:33:12.194]                         version <- ns[[".package"]][["version"]]
[10:33:12.194]                         if (is.null(version)) 
[10:33:12.194]                           version <- utils::packageVersion("future")
[10:33:12.194]                       }
[10:33:12.194]                       else {
[10:33:12.194]                         version <- NULL
[10:33:12.194]                       }
[10:33:12.194]                       if (!has_future || version < "1.8.0") {
[10:33:12.194]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.194]                           "", base::R.version$version.string), 
[10:33:12.194]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.194]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.194]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.194]                             "release", "version")], collapse = " "), 
[10:33:12.194]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.194]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.194]                           info)
[10:33:12.194]                         info <- base::paste(info, collapse = "; ")
[10:33:12.194]                         if (!has_future) {
[10:33:12.194]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.194]                             info)
[10:33:12.194]                         }
[10:33:12.194]                         else {
[10:33:12.194]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.194]                             info, version)
[10:33:12.194]                         }
[10:33:12.194]                         base::stop(msg)
[10:33:12.194]                       }
[10:33:12.194]                     })
[10:33:12.194]                   }
[10:33:12.194]                   ...future.strategy.old <- future::plan("list")
[10:33:12.194]                   options(future.plan = NULL)
[10:33:12.194]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.194]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.194]                 }
[10:33:12.194]                 ...future.workdir <- getwd()
[10:33:12.194]             }
[10:33:12.194]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.194]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.194]         }
[10:33:12.194]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.194]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:12.194]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.194]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.194]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.194]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.194]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.194]             base::names(...future.oldOptions))
[10:33:12.194]     }
[10:33:12.194]     if (FALSE) {
[10:33:12.194]     }
[10:33:12.194]     else {
[10:33:12.194]         if (TRUE) {
[10:33:12.194]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.194]                 open = "w")
[10:33:12.194]         }
[10:33:12.194]         else {
[10:33:12.194]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.194]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.194]         }
[10:33:12.194]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.194]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.194]             base::sink(type = "output", split = FALSE)
[10:33:12.194]             base::close(...future.stdout)
[10:33:12.194]         }, add = TRUE)
[10:33:12.194]     }
[10:33:12.194]     ...future.frame <- base::sys.nframe()
[10:33:12.194]     ...future.conditions <- base::list()
[10:33:12.194]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.194]     if (FALSE) {
[10:33:12.194]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.194]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.194]     }
[10:33:12.194]     ...future.result <- base::tryCatch({
[10:33:12.194]         base::withCallingHandlers({
[10:33:12.194]             ...future.value <- base::withVisible(base::local({
[10:33:12.194]                 b <- a
[10:33:12.194]                 a <- 2
[10:33:12.194]                 a * b
[10:33:12.194]             }))
[10:33:12.194]             future::FutureResult(value = ...future.value$value, 
[10:33:12.194]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.194]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.194]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.194]                     ...future.globalenv.names))
[10:33:12.194]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.194]         }, condition = base::local({
[10:33:12.194]             c <- base::c
[10:33:12.194]             inherits <- base::inherits
[10:33:12.194]             invokeRestart <- base::invokeRestart
[10:33:12.194]             length <- base::length
[10:33:12.194]             list <- base::list
[10:33:12.194]             seq.int <- base::seq.int
[10:33:12.194]             signalCondition <- base::signalCondition
[10:33:12.194]             sys.calls <- base::sys.calls
[10:33:12.194]             `[[` <- base::`[[`
[10:33:12.194]             `+` <- base::`+`
[10:33:12.194]             `<<-` <- base::`<<-`
[10:33:12.194]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.194]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.194]                   3L)]
[10:33:12.194]             }
[10:33:12.194]             function(cond) {
[10:33:12.194]                 is_error <- inherits(cond, "error")
[10:33:12.194]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.194]                   NULL)
[10:33:12.194]                 if (is_error) {
[10:33:12.194]                   sessionInformation <- function() {
[10:33:12.194]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.194]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.194]                       search = base::search(), system = base::Sys.info())
[10:33:12.194]                   }
[10:33:12.194]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.194]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.194]                     cond$call), session = sessionInformation(), 
[10:33:12.194]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.194]                   signalCondition(cond)
[10:33:12.194]                 }
[10:33:12.194]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.194]                 "immediateCondition"))) {
[10:33:12.194]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.194]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.194]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.194]                   if (TRUE && !signal) {
[10:33:12.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.194]                     {
[10:33:12.194]                       inherits <- base::inherits
[10:33:12.194]                       invokeRestart <- base::invokeRestart
[10:33:12.194]                       is.null <- base::is.null
[10:33:12.194]                       muffled <- FALSE
[10:33:12.194]                       if (inherits(cond, "message")) {
[10:33:12.194]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.194]                         if (muffled) 
[10:33:12.194]                           invokeRestart("muffleMessage")
[10:33:12.194]                       }
[10:33:12.194]                       else if (inherits(cond, "warning")) {
[10:33:12.194]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.194]                         if (muffled) 
[10:33:12.194]                           invokeRestart("muffleWarning")
[10:33:12.194]                       }
[10:33:12.194]                       else if (inherits(cond, "condition")) {
[10:33:12.194]                         if (!is.null(pattern)) {
[10:33:12.194]                           computeRestarts <- base::computeRestarts
[10:33:12.194]                           grepl <- base::grepl
[10:33:12.194]                           restarts <- computeRestarts(cond)
[10:33:12.194]                           for (restart in restarts) {
[10:33:12.194]                             name <- restart$name
[10:33:12.194]                             if (is.null(name)) 
[10:33:12.194]                               next
[10:33:12.194]                             if (!grepl(pattern, name)) 
[10:33:12.194]                               next
[10:33:12.194]                             invokeRestart(restart)
[10:33:12.194]                             muffled <- TRUE
[10:33:12.194]                             break
[10:33:12.194]                           }
[10:33:12.194]                         }
[10:33:12.194]                       }
[10:33:12.194]                       invisible(muffled)
[10:33:12.194]                     }
[10:33:12.194]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.194]                   }
[10:33:12.194]                 }
[10:33:12.194]                 else {
[10:33:12.194]                   if (TRUE) {
[10:33:12.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.194]                     {
[10:33:12.194]                       inherits <- base::inherits
[10:33:12.194]                       invokeRestart <- base::invokeRestart
[10:33:12.194]                       is.null <- base::is.null
[10:33:12.194]                       muffled <- FALSE
[10:33:12.194]                       if (inherits(cond, "message")) {
[10:33:12.194]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.194]                         if (muffled) 
[10:33:12.194]                           invokeRestart("muffleMessage")
[10:33:12.194]                       }
[10:33:12.194]                       else if (inherits(cond, "warning")) {
[10:33:12.194]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.194]                         if (muffled) 
[10:33:12.194]                           invokeRestart("muffleWarning")
[10:33:12.194]                       }
[10:33:12.194]                       else if (inherits(cond, "condition")) {
[10:33:12.194]                         if (!is.null(pattern)) {
[10:33:12.194]                           computeRestarts <- base::computeRestarts
[10:33:12.194]                           grepl <- base::grepl
[10:33:12.194]                           restarts <- computeRestarts(cond)
[10:33:12.194]                           for (restart in restarts) {
[10:33:12.194]                             name <- restart$name
[10:33:12.194]                             if (is.null(name)) 
[10:33:12.194]                               next
[10:33:12.194]                             if (!grepl(pattern, name)) 
[10:33:12.194]                               next
[10:33:12.194]                             invokeRestart(restart)
[10:33:12.194]                             muffled <- TRUE
[10:33:12.194]                             break
[10:33:12.194]                           }
[10:33:12.194]                         }
[10:33:12.194]                       }
[10:33:12.194]                       invisible(muffled)
[10:33:12.194]                     }
[10:33:12.194]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.194]                   }
[10:33:12.194]                 }
[10:33:12.194]             }
[10:33:12.194]         }))
[10:33:12.194]     }, error = function(ex) {
[10:33:12.194]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.194]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.194]                 ...future.rng), started = ...future.startTime, 
[10:33:12.194]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.194]             version = "1.8"), class = "FutureResult")
[10:33:12.194]     }, finally = {
[10:33:12.194]         if (!identical(...future.workdir, getwd())) 
[10:33:12.194]             setwd(...future.workdir)
[10:33:12.194]         {
[10:33:12.194]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.194]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.194]             }
[10:33:12.194]             base::options(...future.oldOptions)
[10:33:12.194]             if (.Platform$OS.type == "windows") {
[10:33:12.194]                 old_names <- names(...future.oldEnvVars)
[10:33:12.194]                 envs <- base::Sys.getenv()
[10:33:12.194]                 names <- names(envs)
[10:33:12.194]                 common <- intersect(names, old_names)
[10:33:12.194]                 added <- setdiff(names, old_names)
[10:33:12.194]                 removed <- setdiff(old_names, names)
[10:33:12.194]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.194]                   envs[common]]
[10:33:12.194]                 NAMES <- toupper(changed)
[10:33:12.194]                 args <- list()
[10:33:12.194]                 for (kk in seq_along(NAMES)) {
[10:33:12.194]                   name <- changed[[kk]]
[10:33:12.194]                   NAME <- NAMES[[kk]]
[10:33:12.194]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.194]                     next
[10:33:12.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.194]                 }
[10:33:12.194]                 NAMES <- toupper(added)
[10:33:12.194]                 for (kk in seq_along(NAMES)) {
[10:33:12.194]                   name <- added[[kk]]
[10:33:12.194]                   NAME <- NAMES[[kk]]
[10:33:12.194]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.194]                     next
[10:33:12.194]                   args[[name]] <- ""
[10:33:12.194]                 }
[10:33:12.194]                 NAMES <- toupper(removed)
[10:33:12.194]                 for (kk in seq_along(NAMES)) {
[10:33:12.194]                   name <- removed[[kk]]
[10:33:12.194]                   NAME <- NAMES[[kk]]
[10:33:12.194]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.194]                     next
[10:33:12.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.194]                 }
[10:33:12.194]                 if (length(args) > 0) 
[10:33:12.194]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.194]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.194]             }
[10:33:12.194]             else {
[10:33:12.194]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.194]             }
[10:33:12.194]             {
[10:33:12.194]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.194]                   0L) {
[10:33:12.194]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.194]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.194]                   base::options(opts)
[10:33:12.194]                 }
[10:33:12.194]                 {
[10:33:12.194]                   {
[10:33:12.194]                     NULL
[10:33:12.194]                     RNGkind("Mersenne-Twister")
[10:33:12.194]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.194]                       inherits = FALSE)
[10:33:12.194]                   }
[10:33:12.194]                   options(future.plan = NULL)
[10:33:12.194]                   if (is.na(NA_character_)) 
[10:33:12.194]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.194]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.194]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.194]                     .init = FALSE)
[10:33:12.194]                 }
[10:33:12.194]             }
[10:33:12.194]         }
[10:33:12.194]     })
[10:33:12.194]     if (TRUE) {
[10:33:12.194]         base::sink(type = "output", split = FALSE)
[10:33:12.194]         if (TRUE) {
[10:33:12.194]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.194]         }
[10:33:12.194]         else {
[10:33:12.194]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.194]         }
[10:33:12.194]         base::close(...future.stdout)
[10:33:12.194]         ...future.stdout <- NULL
[10:33:12.194]     }
[10:33:12.194]     ...future.result$conditions <- ...future.conditions
[10:33:12.194]     ...future.result$finished <- base::Sys.time()
[10:33:12.194]     ...future.result
[10:33:12.194] }
[10:33:12.196] assign_globals() ...
[10:33:12.196] List of 1
[10:33:12.196]  $ a: num 3
[10:33:12.196]  - attr(*, "where")=List of 1
[10:33:12.196]   ..$ a:<environment: R_EmptyEnv> 
[10:33:12.196]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.196]  - attr(*, "resolved")= logi TRUE
[10:33:12.196]  - attr(*, "total_size")= num 56
[10:33:12.196]  - attr(*, "already-done")= logi TRUE
[10:33:12.198] - copied ‘a’ to environment
[10:33:12.198] assign_globals() ... done
[10:33:12.198] plan(): Setting new future strategy stack:
[10:33:12.198] List of future strategies:
[10:33:12.198] 1. sequential:
[10:33:12.198]    - args: function (..., envir = parent.frame())
[10:33:12.198]    - tweaked: FALSE
[10:33:12.198]    - call: NULL
[10:33:12.199] plan(): nbrOfWorkers() = 1
[10:33:12.199] plan(): Setting new future strategy stack:
[10:33:12.199] List of future strategies:
[10:33:12.199] 1. sequential:
[10:33:12.199]    - args: function (..., envir = parent.frame())
[10:33:12.199]    - tweaked: FALSE
[10:33:12.199]    - call: plan(strategy)
[10:33:12.200] plan(): nbrOfWorkers() = 1
[10:33:12.200] SequentialFuture started (and completed)
[10:33:12.200] - Launch lazy future ... done
[10:33:12.200] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.201] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.201] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:12.202] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:12.203] Searching for globals ... DONE
[10:33:12.203] Resolving globals: TRUE
[10:33:12.203] Resolving any globals that are futures ...
[10:33:12.203] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:12.203] Resolving any globals that are futures ... DONE
[10:33:12.203] Resolving futures part of globals (recursively) ...
[10:33:12.204] resolve() on list ...
[10:33:12.204]  recursive: 99
[10:33:12.204]  length: 2
[10:33:12.204]  elements: ‘a’, ‘ii’
[10:33:12.204]  length: 1 (resolved future 1)
[10:33:12.204]  length: 0 (resolved future 2)
[10:33:12.204] resolve() on list ... DONE
[10:33:12.204] - globals: [2] ‘a’, ‘ii’
[10:33:12.204] Resolving futures part of globals (recursively) ... DONE
[10:33:12.204] The total size of the 2 globals is 112 bytes (112 bytes)
[10:33:12.205] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:33:12.205] - globals: [2] ‘a’, ‘ii’
[10:33:12.205] 
[10:33:12.205] getGlobalsAndPackages() ... DONE
[10:33:12.205] run() for ‘Future’ ...
[10:33:12.205] - state: ‘created’
[10:33:12.205] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.206] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.206] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.206]   - Field: ‘label’
[10:33:12.206]   - Field: ‘local’
[10:33:12.206]   - Field: ‘owner’
[10:33:12.206]   - Field: ‘envir’
[10:33:12.206]   - Field: ‘packages’
[10:33:12.206]   - Field: ‘gc’
[10:33:12.206]   - Field: ‘conditions’
[10:33:12.207]   - Field: ‘expr’
[10:33:12.207]   - Field: ‘uuid’
[10:33:12.207]   - Field: ‘seed’
[10:33:12.207]   - Field: ‘version’
[10:33:12.207]   - Field: ‘result’
[10:33:12.207]   - Field: ‘asynchronous’
[10:33:12.207]   - Field: ‘calls’
[10:33:12.207]   - Field: ‘globals’
[10:33:12.207]   - Field: ‘stdout’
[10:33:12.207]   - Field: ‘earlySignal’
[10:33:12.207]   - Field: ‘lazy’
[10:33:12.207]   - Field: ‘state’
[10:33:12.209] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.209] - Launch lazy future ...
[10:33:12.209] Packages needed by the future expression (n = 0): <none>
[10:33:12.209] Packages needed by future strategies (n = 0): <none>
[10:33:12.209] {
[10:33:12.209]     {
[10:33:12.209]         {
[10:33:12.209]             ...future.startTime <- base::Sys.time()
[10:33:12.209]             {
[10:33:12.209]                 {
[10:33:12.209]                   {
[10:33:12.209]                     base::local({
[10:33:12.209]                       has_future <- base::requireNamespace("future", 
[10:33:12.209]                         quietly = TRUE)
[10:33:12.209]                       if (has_future) {
[10:33:12.209]                         ns <- base::getNamespace("future")
[10:33:12.209]                         version <- ns[[".package"]][["version"]]
[10:33:12.209]                         if (is.null(version)) 
[10:33:12.209]                           version <- utils::packageVersion("future")
[10:33:12.209]                       }
[10:33:12.209]                       else {
[10:33:12.209]                         version <- NULL
[10:33:12.209]                       }
[10:33:12.209]                       if (!has_future || version < "1.8.0") {
[10:33:12.209]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.209]                           "", base::R.version$version.string), 
[10:33:12.209]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.209]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.209]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.209]                             "release", "version")], collapse = " "), 
[10:33:12.209]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.209]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.209]                           info)
[10:33:12.209]                         info <- base::paste(info, collapse = "; ")
[10:33:12.209]                         if (!has_future) {
[10:33:12.209]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.209]                             info)
[10:33:12.209]                         }
[10:33:12.209]                         else {
[10:33:12.209]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.209]                             info, version)
[10:33:12.209]                         }
[10:33:12.209]                         base::stop(msg)
[10:33:12.209]                       }
[10:33:12.209]                     })
[10:33:12.209]                   }
[10:33:12.209]                   ...future.strategy.old <- future::plan("list")
[10:33:12.209]                   options(future.plan = NULL)
[10:33:12.209]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.209]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.209]                 }
[10:33:12.209]                 ...future.workdir <- getwd()
[10:33:12.209]             }
[10:33:12.209]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.209]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.209]         }
[10:33:12.209]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.209]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:12.209]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.209]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.209]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.209]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.209]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.209]             base::names(...future.oldOptions))
[10:33:12.209]     }
[10:33:12.209]     if (FALSE) {
[10:33:12.209]     }
[10:33:12.209]     else {
[10:33:12.209]         if (TRUE) {
[10:33:12.209]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.209]                 open = "w")
[10:33:12.209]         }
[10:33:12.209]         else {
[10:33:12.209]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.209]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.209]         }
[10:33:12.209]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.209]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.209]             base::sink(type = "output", split = FALSE)
[10:33:12.209]             base::close(...future.stdout)
[10:33:12.209]         }, add = TRUE)
[10:33:12.209]     }
[10:33:12.209]     ...future.frame <- base::sys.nframe()
[10:33:12.209]     ...future.conditions <- base::list()
[10:33:12.209]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.209]     if (FALSE) {
[10:33:12.209]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.209]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.209]     }
[10:33:12.209]     ...future.result <- base::tryCatch({
[10:33:12.209]         base::withCallingHandlers({
[10:33:12.209]             ...future.value <- base::withVisible(base::local({
[10:33:12.209]                 b <- a * ii
[10:33:12.209]                 a <- 0
[10:33:12.209]                 b
[10:33:12.209]             }))
[10:33:12.209]             future::FutureResult(value = ...future.value$value, 
[10:33:12.209]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.209]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.209]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.209]                     ...future.globalenv.names))
[10:33:12.209]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.209]         }, condition = base::local({
[10:33:12.209]             c <- base::c
[10:33:12.209]             inherits <- base::inherits
[10:33:12.209]             invokeRestart <- base::invokeRestart
[10:33:12.209]             length <- base::length
[10:33:12.209]             list <- base::list
[10:33:12.209]             seq.int <- base::seq.int
[10:33:12.209]             signalCondition <- base::signalCondition
[10:33:12.209]             sys.calls <- base::sys.calls
[10:33:12.209]             `[[` <- base::`[[`
[10:33:12.209]             `+` <- base::`+`
[10:33:12.209]             `<<-` <- base::`<<-`
[10:33:12.209]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.209]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.209]                   3L)]
[10:33:12.209]             }
[10:33:12.209]             function(cond) {
[10:33:12.209]                 is_error <- inherits(cond, "error")
[10:33:12.209]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.209]                   NULL)
[10:33:12.209]                 if (is_error) {
[10:33:12.209]                   sessionInformation <- function() {
[10:33:12.209]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.209]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.209]                       search = base::search(), system = base::Sys.info())
[10:33:12.209]                   }
[10:33:12.209]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.209]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.209]                     cond$call), session = sessionInformation(), 
[10:33:12.209]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.209]                   signalCondition(cond)
[10:33:12.209]                 }
[10:33:12.209]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.209]                 "immediateCondition"))) {
[10:33:12.209]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.209]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.209]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.209]                   if (TRUE && !signal) {
[10:33:12.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.209]                     {
[10:33:12.209]                       inherits <- base::inherits
[10:33:12.209]                       invokeRestart <- base::invokeRestart
[10:33:12.209]                       is.null <- base::is.null
[10:33:12.209]                       muffled <- FALSE
[10:33:12.209]                       if (inherits(cond, "message")) {
[10:33:12.209]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.209]                         if (muffled) 
[10:33:12.209]                           invokeRestart("muffleMessage")
[10:33:12.209]                       }
[10:33:12.209]                       else if (inherits(cond, "warning")) {
[10:33:12.209]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.209]                         if (muffled) 
[10:33:12.209]                           invokeRestart("muffleWarning")
[10:33:12.209]                       }
[10:33:12.209]                       else if (inherits(cond, "condition")) {
[10:33:12.209]                         if (!is.null(pattern)) {
[10:33:12.209]                           computeRestarts <- base::computeRestarts
[10:33:12.209]                           grepl <- base::grepl
[10:33:12.209]                           restarts <- computeRestarts(cond)
[10:33:12.209]                           for (restart in restarts) {
[10:33:12.209]                             name <- restart$name
[10:33:12.209]                             if (is.null(name)) 
[10:33:12.209]                               next
[10:33:12.209]                             if (!grepl(pattern, name)) 
[10:33:12.209]                               next
[10:33:12.209]                             invokeRestart(restart)
[10:33:12.209]                             muffled <- TRUE
[10:33:12.209]                             break
[10:33:12.209]                           }
[10:33:12.209]                         }
[10:33:12.209]                       }
[10:33:12.209]                       invisible(muffled)
[10:33:12.209]                     }
[10:33:12.209]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.209]                   }
[10:33:12.209]                 }
[10:33:12.209]                 else {
[10:33:12.209]                   if (TRUE) {
[10:33:12.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.209]                     {
[10:33:12.209]                       inherits <- base::inherits
[10:33:12.209]                       invokeRestart <- base::invokeRestart
[10:33:12.209]                       is.null <- base::is.null
[10:33:12.209]                       muffled <- FALSE
[10:33:12.209]                       if (inherits(cond, "message")) {
[10:33:12.209]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.209]                         if (muffled) 
[10:33:12.209]                           invokeRestart("muffleMessage")
[10:33:12.209]                       }
[10:33:12.209]                       else if (inherits(cond, "warning")) {
[10:33:12.209]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.209]                         if (muffled) 
[10:33:12.209]                           invokeRestart("muffleWarning")
[10:33:12.209]                       }
[10:33:12.209]                       else if (inherits(cond, "condition")) {
[10:33:12.209]                         if (!is.null(pattern)) {
[10:33:12.209]                           computeRestarts <- base::computeRestarts
[10:33:12.209]                           grepl <- base::grepl
[10:33:12.209]                           restarts <- computeRestarts(cond)
[10:33:12.209]                           for (restart in restarts) {
[10:33:12.209]                             name <- restart$name
[10:33:12.209]                             if (is.null(name)) 
[10:33:12.209]                               next
[10:33:12.209]                             if (!grepl(pattern, name)) 
[10:33:12.209]                               next
[10:33:12.209]                             invokeRestart(restart)
[10:33:12.209]                             muffled <- TRUE
[10:33:12.209]                             break
[10:33:12.209]                           }
[10:33:12.209]                         }
[10:33:12.209]                       }
[10:33:12.209]                       invisible(muffled)
[10:33:12.209]                     }
[10:33:12.209]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.209]                   }
[10:33:12.209]                 }
[10:33:12.209]             }
[10:33:12.209]         }))
[10:33:12.209]     }, error = function(ex) {
[10:33:12.209]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.209]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.209]                 ...future.rng), started = ...future.startTime, 
[10:33:12.209]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.209]             version = "1.8"), class = "FutureResult")
[10:33:12.209]     }, finally = {
[10:33:12.209]         if (!identical(...future.workdir, getwd())) 
[10:33:12.209]             setwd(...future.workdir)
[10:33:12.209]         {
[10:33:12.209]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.209]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.209]             }
[10:33:12.209]             base::options(...future.oldOptions)
[10:33:12.209]             if (.Platform$OS.type == "windows") {
[10:33:12.209]                 old_names <- names(...future.oldEnvVars)
[10:33:12.209]                 envs <- base::Sys.getenv()
[10:33:12.209]                 names <- names(envs)
[10:33:12.209]                 common <- intersect(names, old_names)
[10:33:12.209]                 added <- setdiff(names, old_names)
[10:33:12.209]                 removed <- setdiff(old_names, names)
[10:33:12.209]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.209]                   envs[common]]
[10:33:12.209]                 NAMES <- toupper(changed)
[10:33:12.209]                 args <- list()
[10:33:12.209]                 for (kk in seq_along(NAMES)) {
[10:33:12.209]                   name <- changed[[kk]]
[10:33:12.209]                   NAME <- NAMES[[kk]]
[10:33:12.209]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.209]                     next
[10:33:12.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.209]                 }
[10:33:12.209]                 NAMES <- toupper(added)
[10:33:12.209]                 for (kk in seq_along(NAMES)) {
[10:33:12.209]                   name <- added[[kk]]
[10:33:12.209]                   NAME <- NAMES[[kk]]
[10:33:12.209]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.209]                     next
[10:33:12.209]                   args[[name]] <- ""
[10:33:12.209]                 }
[10:33:12.209]                 NAMES <- toupper(removed)
[10:33:12.209]                 for (kk in seq_along(NAMES)) {
[10:33:12.209]                   name <- removed[[kk]]
[10:33:12.209]                   NAME <- NAMES[[kk]]
[10:33:12.209]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.209]                     next
[10:33:12.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.209]                 }
[10:33:12.209]                 if (length(args) > 0) 
[10:33:12.209]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.209]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.209]             }
[10:33:12.209]             else {
[10:33:12.209]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.209]             }
[10:33:12.209]             {
[10:33:12.209]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.209]                   0L) {
[10:33:12.209]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.209]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.209]                   base::options(opts)
[10:33:12.209]                 }
[10:33:12.209]                 {
[10:33:12.209]                   {
[10:33:12.209]                     NULL
[10:33:12.209]                     RNGkind("Mersenne-Twister")
[10:33:12.209]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.209]                       inherits = FALSE)
[10:33:12.209]                   }
[10:33:12.209]                   options(future.plan = NULL)
[10:33:12.209]                   if (is.na(NA_character_)) 
[10:33:12.209]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.209]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.209]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.209]                     .init = FALSE)
[10:33:12.209]                 }
[10:33:12.209]             }
[10:33:12.209]         }
[10:33:12.209]     })
[10:33:12.209]     if (TRUE) {
[10:33:12.209]         base::sink(type = "output", split = FALSE)
[10:33:12.209]         if (TRUE) {
[10:33:12.209]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.209]         }
[10:33:12.209]         else {
[10:33:12.209]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.209]         }
[10:33:12.209]         base::close(...future.stdout)
[10:33:12.209]         ...future.stdout <- NULL
[10:33:12.209]     }
[10:33:12.209]     ...future.result$conditions <- ...future.conditions
[10:33:12.209]     ...future.result$finished <- base::Sys.time()
[10:33:12.209]     ...future.result
[10:33:12.209] }
[10:33:12.211] assign_globals() ...
[10:33:12.211] List of 2
[10:33:12.211]  $ a : num 1
[10:33:12.211]  $ ii: int 1
[10:33:12.211]  - attr(*, "where")=List of 2
[10:33:12.211]   ..$ a :<environment: R_EmptyEnv> 
[10:33:12.211]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:12.211]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.211]  - attr(*, "resolved")= logi TRUE
[10:33:12.211]  - attr(*, "total_size")= num 112
[10:33:12.211]  - attr(*, "already-done")= logi TRUE
[10:33:12.214] - copied ‘a’ to environment
[10:33:12.214] - copied ‘ii’ to environment
[10:33:12.214] assign_globals() ... done
[10:33:12.214] plan(): Setting new future strategy stack:
[10:33:12.214] List of future strategies:
[10:33:12.214] 1. sequential:
[10:33:12.214]    - args: function (..., envir = parent.frame())
[10:33:12.214]    - tweaked: FALSE
[10:33:12.214]    - call: NULL
[10:33:12.215] plan(): nbrOfWorkers() = 1
[10:33:12.215] plan(): Setting new future strategy stack:
[10:33:12.215] List of future strategies:
[10:33:12.215] 1. sequential:
[10:33:12.215]    - args: function (..., envir = parent.frame())
[10:33:12.215]    - tweaked: FALSE
[10:33:12.215]    - call: plan(strategy)
[10:33:12.216] plan(): nbrOfWorkers() = 1
[10:33:12.216] SequentialFuture started (and completed)
[10:33:12.216] - Launch lazy future ... done
[10:33:12.216] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.216] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.217] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:12.218] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:12.218] Searching for globals ... DONE
[10:33:12.218] Resolving globals: TRUE
[10:33:12.219] Resolving any globals that are futures ...
[10:33:12.219] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:12.219] Resolving any globals that are futures ... DONE
[10:33:12.219] Resolving futures part of globals (recursively) ...
[10:33:12.219] resolve() on list ...
[10:33:12.219]  recursive: 99
[10:33:12.219]  length: 2
[10:33:12.219]  elements: ‘a’, ‘ii’
[10:33:12.220]  length: 1 (resolved future 1)
[10:33:12.220]  length: 0 (resolved future 2)
[10:33:12.220] resolve() on list ... DONE
[10:33:12.220] - globals: [2] ‘a’, ‘ii’
[10:33:12.220] Resolving futures part of globals (recursively) ... DONE
[10:33:12.220] The total size of the 2 globals is 112 bytes (112 bytes)
[10:33:12.220] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:33:12.221] - globals: [2] ‘a’, ‘ii’
[10:33:12.221] 
[10:33:12.221] getGlobalsAndPackages() ... DONE
[10:33:12.221] run() for ‘Future’ ...
[10:33:12.221] - state: ‘created’
[10:33:12.221] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.221] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.222] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.222]   - Field: ‘label’
[10:33:12.222]   - Field: ‘local’
[10:33:12.222]   - Field: ‘owner’
[10:33:12.222]   - Field: ‘envir’
[10:33:12.222]   - Field: ‘packages’
[10:33:12.222]   - Field: ‘gc’
[10:33:12.222]   - Field: ‘conditions’
[10:33:12.222]   - Field: ‘expr’
[10:33:12.222]   - Field: ‘uuid’
[10:33:12.222]   - Field: ‘seed’
[10:33:12.222]   - Field: ‘version’
[10:33:12.223]   - Field: ‘result’
[10:33:12.223]   - Field: ‘asynchronous’
[10:33:12.223]   - Field: ‘calls’
[10:33:12.223]   - Field: ‘globals’
[10:33:12.223]   - Field: ‘stdout’
[10:33:12.223]   - Field: ‘earlySignal’
[10:33:12.223]   - Field: ‘lazy’
[10:33:12.223]   - Field: ‘state’
[10:33:12.223] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.223] - Launch lazy future ...
[10:33:12.224] Packages needed by the future expression (n = 0): <none>
[10:33:12.224] Packages needed by future strategies (n = 0): <none>
[10:33:12.224] {
[10:33:12.224]     {
[10:33:12.224]         {
[10:33:12.224]             ...future.startTime <- base::Sys.time()
[10:33:12.224]             {
[10:33:12.224]                 {
[10:33:12.224]                   {
[10:33:12.224]                     base::local({
[10:33:12.224]                       has_future <- base::requireNamespace("future", 
[10:33:12.224]                         quietly = TRUE)
[10:33:12.224]                       if (has_future) {
[10:33:12.224]                         ns <- base::getNamespace("future")
[10:33:12.224]                         version <- ns[[".package"]][["version"]]
[10:33:12.224]                         if (is.null(version)) 
[10:33:12.224]                           version <- utils::packageVersion("future")
[10:33:12.224]                       }
[10:33:12.224]                       else {
[10:33:12.224]                         version <- NULL
[10:33:12.224]                       }
[10:33:12.224]                       if (!has_future || version < "1.8.0") {
[10:33:12.224]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.224]                           "", base::R.version$version.string), 
[10:33:12.224]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.224]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.224]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.224]                             "release", "version")], collapse = " "), 
[10:33:12.224]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.224]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.224]                           info)
[10:33:12.224]                         info <- base::paste(info, collapse = "; ")
[10:33:12.224]                         if (!has_future) {
[10:33:12.224]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.224]                             info)
[10:33:12.224]                         }
[10:33:12.224]                         else {
[10:33:12.224]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.224]                             info, version)
[10:33:12.224]                         }
[10:33:12.224]                         base::stop(msg)
[10:33:12.224]                       }
[10:33:12.224]                     })
[10:33:12.224]                   }
[10:33:12.224]                   ...future.strategy.old <- future::plan("list")
[10:33:12.224]                   options(future.plan = NULL)
[10:33:12.224]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.224]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.224]                 }
[10:33:12.224]                 ...future.workdir <- getwd()
[10:33:12.224]             }
[10:33:12.224]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.224]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.224]         }
[10:33:12.224]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.224]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:12.224]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.224]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.224]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.224]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.224]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.224]             base::names(...future.oldOptions))
[10:33:12.224]     }
[10:33:12.224]     if (FALSE) {
[10:33:12.224]     }
[10:33:12.224]     else {
[10:33:12.224]         if (TRUE) {
[10:33:12.224]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.224]                 open = "w")
[10:33:12.224]         }
[10:33:12.224]         else {
[10:33:12.224]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.224]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.224]         }
[10:33:12.224]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.224]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.224]             base::sink(type = "output", split = FALSE)
[10:33:12.224]             base::close(...future.stdout)
[10:33:12.224]         }, add = TRUE)
[10:33:12.224]     }
[10:33:12.224]     ...future.frame <- base::sys.nframe()
[10:33:12.224]     ...future.conditions <- base::list()
[10:33:12.224]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.224]     if (FALSE) {
[10:33:12.224]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.224]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.224]     }
[10:33:12.224]     ...future.result <- base::tryCatch({
[10:33:12.224]         base::withCallingHandlers({
[10:33:12.224]             ...future.value <- base::withVisible(base::local({
[10:33:12.224]                 b <- a * ii
[10:33:12.224]                 a <- 0
[10:33:12.224]                 b
[10:33:12.224]             }))
[10:33:12.224]             future::FutureResult(value = ...future.value$value, 
[10:33:12.224]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.224]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.224]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.224]                     ...future.globalenv.names))
[10:33:12.224]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.224]         }, condition = base::local({
[10:33:12.224]             c <- base::c
[10:33:12.224]             inherits <- base::inherits
[10:33:12.224]             invokeRestart <- base::invokeRestart
[10:33:12.224]             length <- base::length
[10:33:12.224]             list <- base::list
[10:33:12.224]             seq.int <- base::seq.int
[10:33:12.224]             signalCondition <- base::signalCondition
[10:33:12.224]             sys.calls <- base::sys.calls
[10:33:12.224]             `[[` <- base::`[[`
[10:33:12.224]             `+` <- base::`+`
[10:33:12.224]             `<<-` <- base::`<<-`
[10:33:12.224]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.224]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.224]                   3L)]
[10:33:12.224]             }
[10:33:12.224]             function(cond) {
[10:33:12.224]                 is_error <- inherits(cond, "error")
[10:33:12.224]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.224]                   NULL)
[10:33:12.224]                 if (is_error) {
[10:33:12.224]                   sessionInformation <- function() {
[10:33:12.224]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.224]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.224]                       search = base::search(), system = base::Sys.info())
[10:33:12.224]                   }
[10:33:12.224]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.224]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.224]                     cond$call), session = sessionInformation(), 
[10:33:12.224]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.224]                   signalCondition(cond)
[10:33:12.224]                 }
[10:33:12.224]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.224]                 "immediateCondition"))) {
[10:33:12.224]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.224]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.224]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.224]                   if (TRUE && !signal) {
[10:33:12.224]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.224]                     {
[10:33:12.224]                       inherits <- base::inherits
[10:33:12.224]                       invokeRestart <- base::invokeRestart
[10:33:12.224]                       is.null <- base::is.null
[10:33:12.224]                       muffled <- FALSE
[10:33:12.224]                       if (inherits(cond, "message")) {
[10:33:12.224]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.224]                         if (muffled) 
[10:33:12.224]                           invokeRestart("muffleMessage")
[10:33:12.224]                       }
[10:33:12.224]                       else if (inherits(cond, "warning")) {
[10:33:12.224]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.224]                         if (muffled) 
[10:33:12.224]                           invokeRestart("muffleWarning")
[10:33:12.224]                       }
[10:33:12.224]                       else if (inherits(cond, "condition")) {
[10:33:12.224]                         if (!is.null(pattern)) {
[10:33:12.224]                           computeRestarts <- base::computeRestarts
[10:33:12.224]                           grepl <- base::grepl
[10:33:12.224]                           restarts <- computeRestarts(cond)
[10:33:12.224]                           for (restart in restarts) {
[10:33:12.224]                             name <- restart$name
[10:33:12.224]                             if (is.null(name)) 
[10:33:12.224]                               next
[10:33:12.224]                             if (!grepl(pattern, name)) 
[10:33:12.224]                               next
[10:33:12.224]                             invokeRestart(restart)
[10:33:12.224]                             muffled <- TRUE
[10:33:12.224]                             break
[10:33:12.224]                           }
[10:33:12.224]                         }
[10:33:12.224]                       }
[10:33:12.224]                       invisible(muffled)
[10:33:12.224]                     }
[10:33:12.224]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.224]                   }
[10:33:12.224]                 }
[10:33:12.224]                 else {
[10:33:12.224]                   if (TRUE) {
[10:33:12.224]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.224]                     {
[10:33:12.224]                       inherits <- base::inherits
[10:33:12.224]                       invokeRestart <- base::invokeRestart
[10:33:12.224]                       is.null <- base::is.null
[10:33:12.224]                       muffled <- FALSE
[10:33:12.224]                       if (inherits(cond, "message")) {
[10:33:12.224]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.224]                         if (muffled) 
[10:33:12.224]                           invokeRestart("muffleMessage")
[10:33:12.224]                       }
[10:33:12.224]                       else if (inherits(cond, "warning")) {
[10:33:12.224]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.224]                         if (muffled) 
[10:33:12.224]                           invokeRestart("muffleWarning")
[10:33:12.224]                       }
[10:33:12.224]                       else if (inherits(cond, "condition")) {
[10:33:12.224]                         if (!is.null(pattern)) {
[10:33:12.224]                           computeRestarts <- base::computeRestarts
[10:33:12.224]                           grepl <- base::grepl
[10:33:12.224]                           restarts <- computeRestarts(cond)
[10:33:12.224]                           for (restart in restarts) {
[10:33:12.224]                             name <- restart$name
[10:33:12.224]                             if (is.null(name)) 
[10:33:12.224]                               next
[10:33:12.224]                             if (!grepl(pattern, name)) 
[10:33:12.224]                               next
[10:33:12.224]                             invokeRestart(restart)
[10:33:12.224]                             muffled <- TRUE
[10:33:12.224]                             break
[10:33:12.224]                           }
[10:33:12.224]                         }
[10:33:12.224]                       }
[10:33:12.224]                       invisible(muffled)
[10:33:12.224]                     }
[10:33:12.224]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.224]                   }
[10:33:12.224]                 }
[10:33:12.224]             }
[10:33:12.224]         }))
[10:33:12.224]     }, error = function(ex) {
[10:33:12.224]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.224]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.224]                 ...future.rng), started = ...future.startTime, 
[10:33:12.224]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.224]             version = "1.8"), class = "FutureResult")
[10:33:12.224]     }, finally = {
[10:33:12.224]         if (!identical(...future.workdir, getwd())) 
[10:33:12.224]             setwd(...future.workdir)
[10:33:12.224]         {
[10:33:12.224]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.224]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.224]             }
[10:33:12.224]             base::options(...future.oldOptions)
[10:33:12.224]             if (.Platform$OS.type == "windows") {
[10:33:12.224]                 old_names <- names(...future.oldEnvVars)
[10:33:12.224]                 envs <- base::Sys.getenv()
[10:33:12.224]                 names <- names(envs)
[10:33:12.224]                 common <- intersect(names, old_names)
[10:33:12.224]                 added <- setdiff(names, old_names)
[10:33:12.224]                 removed <- setdiff(old_names, names)
[10:33:12.224]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.224]                   envs[common]]
[10:33:12.224]                 NAMES <- toupper(changed)
[10:33:12.224]                 args <- list()
[10:33:12.224]                 for (kk in seq_along(NAMES)) {
[10:33:12.224]                   name <- changed[[kk]]
[10:33:12.224]                   NAME <- NAMES[[kk]]
[10:33:12.224]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.224]                     next
[10:33:12.224]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.224]                 }
[10:33:12.224]                 NAMES <- toupper(added)
[10:33:12.224]                 for (kk in seq_along(NAMES)) {
[10:33:12.224]                   name <- added[[kk]]
[10:33:12.224]                   NAME <- NAMES[[kk]]
[10:33:12.224]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.224]                     next
[10:33:12.224]                   args[[name]] <- ""
[10:33:12.224]                 }
[10:33:12.224]                 NAMES <- toupper(removed)
[10:33:12.224]                 for (kk in seq_along(NAMES)) {
[10:33:12.224]                   name <- removed[[kk]]
[10:33:12.224]                   NAME <- NAMES[[kk]]
[10:33:12.224]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.224]                     next
[10:33:12.224]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.224]                 }
[10:33:12.224]                 if (length(args) > 0) 
[10:33:12.224]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.224]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.224]             }
[10:33:12.224]             else {
[10:33:12.224]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.224]             }
[10:33:12.224]             {
[10:33:12.224]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.224]                   0L) {
[10:33:12.224]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.224]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.224]                   base::options(opts)
[10:33:12.224]                 }
[10:33:12.224]                 {
[10:33:12.224]                   {
[10:33:12.224]                     NULL
[10:33:12.224]                     RNGkind("Mersenne-Twister")
[10:33:12.224]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.224]                       inherits = FALSE)
[10:33:12.224]                   }
[10:33:12.224]                   options(future.plan = NULL)
[10:33:12.224]                   if (is.na(NA_character_)) 
[10:33:12.224]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.224]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.224]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.224]                     .init = FALSE)
[10:33:12.224]                 }
[10:33:12.224]             }
[10:33:12.224]         }
[10:33:12.224]     })
[10:33:12.224]     if (TRUE) {
[10:33:12.224]         base::sink(type = "output", split = FALSE)
[10:33:12.224]         if (TRUE) {
[10:33:12.224]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.224]         }
[10:33:12.224]         else {
[10:33:12.224]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.224]         }
[10:33:12.224]         base::close(...future.stdout)
[10:33:12.224]         ...future.stdout <- NULL
[10:33:12.224]     }
[10:33:12.224]     ...future.result$conditions <- ...future.conditions
[10:33:12.224]     ...future.result$finished <- base::Sys.time()
[10:33:12.224]     ...future.result
[10:33:12.224] }
[10:33:12.226] assign_globals() ...
[10:33:12.226] List of 2
[10:33:12.226]  $ a : num 1
[10:33:12.226]  $ ii: int 2
[10:33:12.226]  - attr(*, "where")=List of 2
[10:33:12.226]   ..$ a :<environment: R_EmptyEnv> 
[10:33:12.226]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:12.226]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.226]  - attr(*, "resolved")= logi TRUE
[10:33:12.226]  - attr(*, "total_size")= num 112
[10:33:12.226]  - attr(*, "already-done")= logi TRUE
[10:33:12.228] - copied ‘a’ to environment
[10:33:12.229] - copied ‘ii’ to environment
[10:33:12.229] assign_globals() ... done
[10:33:12.229] plan(): Setting new future strategy stack:
[10:33:12.229] List of future strategies:
[10:33:12.229] 1. sequential:
[10:33:12.229]    - args: function (..., envir = parent.frame())
[10:33:12.229]    - tweaked: FALSE
[10:33:12.229]    - call: NULL
[10:33:12.229] plan(): nbrOfWorkers() = 1
[10:33:12.230] plan(): Setting new future strategy stack:
[10:33:12.230] List of future strategies:
[10:33:12.230] 1. sequential:
[10:33:12.230]    - args: function (..., envir = parent.frame())
[10:33:12.230]    - tweaked: FALSE
[10:33:12.230]    - call: plan(strategy)
[10:33:12.230] plan(): nbrOfWorkers() = 1
[10:33:12.231] SequentialFuture started (and completed)
[10:33:12.231] - Launch lazy future ... done
[10:33:12.231] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.231] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.233] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:12.235] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:12.235] Searching for globals ... DONE
[10:33:12.235] Resolving globals: TRUE
[10:33:12.235] Resolving any globals that are futures ...
[10:33:12.235] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:12.235] Resolving any globals that are futures ... DONE
[10:33:12.236] Resolving futures part of globals (recursively) ...
[10:33:12.236] resolve() on list ...
[10:33:12.236]  recursive: 99
[10:33:12.236]  length: 2
[10:33:12.236]  elements: ‘a’, ‘ii’
[10:33:12.236]  length: 1 (resolved future 1)
[10:33:12.236]  length: 0 (resolved future 2)
[10:33:12.236] resolve() on list ... DONE
[10:33:12.237] - globals: [2] ‘a’, ‘ii’
[10:33:12.237] Resolving futures part of globals (recursively) ... DONE
[10:33:12.237] The total size of the 2 globals is 112 bytes (112 bytes)
[10:33:12.237] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:33:12.237] - globals: [2] ‘a’, ‘ii’
[10:33:12.237] 
[10:33:12.237] getGlobalsAndPackages() ... DONE
[10:33:12.238] run() for ‘Future’ ...
[10:33:12.238] - state: ‘created’
[10:33:12.238] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.238] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.238] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.238]   - Field: ‘label’
[10:33:12.238]   - Field: ‘local’
[10:33:12.239]   - Field: ‘owner’
[10:33:12.239]   - Field: ‘envir’
[10:33:12.239]   - Field: ‘packages’
[10:33:12.239]   - Field: ‘gc’
[10:33:12.239]   - Field: ‘conditions’
[10:33:12.239]   - Field: ‘expr’
[10:33:12.239]   - Field: ‘uuid’
[10:33:12.239]   - Field: ‘seed’
[10:33:12.239]   - Field: ‘version’
[10:33:12.239]   - Field: ‘result’
[10:33:12.240]   - Field: ‘asynchronous’
[10:33:12.240]   - Field: ‘calls’
[10:33:12.240]   - Field: ‘globals’
[10:33:12.240]   - Field: ‘stdout’
[10:33:12.240]   - Field: ‘earlySignal’
[10:33:12.240]   - Field: ‘lazy’
[10:33:12.240]   - Field: ‘state’
[10:33:12.240] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.240] - Launch lazy future ...
[10:33:12.240] Packages needed by the future expression (n = 0): <none>
[10:33:12.240] Packages needed by future strategies (n = 0): <none>
[10:33:12.241] {
[10:33:12.241]     {
[10:33:12.241]         {
[10:33:12.241]             ...future.startTime <- base::Sys.time()
[10:33:12.241]             {
[10:33:12.241]                 {
[10:33:12.241]                   {
[10:33:12.241]                     base::local({
[10:33:12.241]                       has_future <- base::requireNamespace("future", 
[10:33:12.241]                         quietly = TRUE)
[10:33:12.241]                       if (has_future) {
[10:33:12.241]                         ns <- base::getNamespace("future")
[10:33:12.241]                         version <- ns[[".package"]][["version"]]
[10:33:12.241]                         if (is.null(version)) 
[10:33:12.241]                           version <- utils::packageVersion("future")
[10:33:12.241]                       }
[10:33:12.241]                       else {
[10:33:12.241]                         version <- NULL
[10:33:12.241]                       }
[10:33:12.241]                       if (!has_future || version < "1.8.0") {
[10:33:12.241]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.241]                           "", base::R.version$version.string), 
[10:33:12.241]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.241]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.241]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.241]                             "release", "version")], collapse = " "), 
[10:33:12.241]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.241]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.241]                           info)
[10:33:12.241]                         info <- base::paste(info, collapse = "; ")
[10:33:12.241]                         if (!has_future) {
[10:33:12.241]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.241]                             info)
[10:33:12.241]                         }
[10:33:12.241]                         else {
[10:33:12.241]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.241]                             info, version)
[10:33:12.241]                         }
[10:33:12.241]                         base::stop(msg)
[10:33:12.241]                       }
[10:33:12.241]                     })
[10:33:12.241]                   }
[10:33:12.241]                   ...future.strategy.old <- future::plan("list")
[10:33:12.241]                   options(future.plan = NULL)
[10:33:12.241]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.241]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.241]                 }
[10:33:12.241]                 ...future.workdir <- getwd()
[10:33:12.241]             }
[10:33:12.241]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.241]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.241]         }
[10:33:12.241]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.241]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:12.241]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.241]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.241]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.241]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.241]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.241]             base::names(...future.oldOptions))
[10:33:12.241]     }
[10:33:12.241]     if (FALSE) {
[10:33:12.241]     }
[10:33:12.241]     else {
[10:33:12.241]         if (TRUE) {
[10:33:12.241]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.241]                 open = "w")
[10:33:12.241]         }
[10:33:12.241]         else {
[10:33:12.241]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.241]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.241]         }
[10:33:12.241]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.241]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.241]             base::sink(type = "output", split = FALSE)
[10:33:12.241]             base::close(...future.stdout)
[10:33:12.241]         }, add = TRUE)
[10:33:12.241]     }
[10:33:12.241]     ...future.frame <- base::sys.nframe()
[10:33:12.241]     ...future.conditions <- base::list()
[10:33:12.241]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.241]     if (FALSE) {
[10:33:12.241]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.241]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.241]     }
[10:33:12.241]     ...future.result <- base::tryCatch({
[10:33:12.241]         base::withCallingHandlers({
[10:33:12.241]             ...future.value <- base::withVisible(base::local({
[10:33:12.241]                 b <- a * ii
[10:33:12.241]                 a <- 0
[10:33:12.241]                 b
[10:33:12.241]             }))
[10:33:12.241]             future::FutureResult(value = ...future.value$value, 
[10:33:12.241]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.241]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.241]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.241]                     ...future.globalenv.names))
[10:33:12.241]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.241]         }, condition = base::local({
[10:33:12.241]             c <- base::c
[10:33:12.241]             inherits <- base::inherits
[10:33:12.241]             invokeRestart <- base::invokeRestart
[10:33:12.241]             length <- base::length
[10:33:12.241]             list <- base::list
[10:33:12.241]             seq.int <- base::seq.int
[10:33:12.241]             signalCondition <- base::signalCondition
[10:33:12.241]             sys.calls <- base::sys.calls
[10:33:12.241]             `[[` <- base::`[[`
[10:33:12.241]             `+` <- base::`+`
[10:33:12.241]             `<<-` <- base::`<<-`
[10:33:12.241]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.241]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.241]                   3L)]
[10:33:12.241]             }
[10:33:12.241]             function(cond) {
[10:33:12.241]                 is_error <- inherits(cond, "error")
[10:33:12.241]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.241]                   NULL)
[10:33:12.241]                 if (is_error) {
[10:33:12.241]                   sessionInformation <- function() {
[10:33:12.241]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.241]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.241]                       search = base::search(), system = base::Sys.info())
[10:33:12.241]                   }
[10:33:12.241]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.241]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.241]                     cond$call), session = sessionInformation(), 
[10:33:12.241]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.241]                   signalCondition(cond)
[10:33:12.241]                 }
[10:33:12.241]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.241]                 "immediateCondition"))) {
[10:33:12.241]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.241]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.241]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.241]                   if (TRUE && !signal) {
[10:33:12.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.241]                     {
[10:33:12.241]                       inherits <- base::inherits
[10:33:12.241]                       invokeRestart <- base::invokeRestart
[10:33:12.241]                       is.null <- base::is.null
[10:33:12.241]                       muffled <- FALSE
[10:33:12.241]                       if (inherits(cond, "message")) {
[10:33:12.241]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.241]                         if (muffled) 
[10:33:12.241]                           invokeRestart("muffleMessage")
[10:33:12.241]                       }
[10:33:12.241]                       else if (inherits(cond, "warning")) {
[10:33:12.241]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.241]                         if (muffled) 
[10:33:12.241]                           invokeRestart("muffleWarning")
[10:33:12.241]                       }
[10:33:12.241]                       else if (inherits(cond, "condition")) {
[10:33:12.241]                         if (!is.null(pattern)) {
[10:33:12.241]                           computeRestarts <- base::computeRestarts
[10:33:12.241]                           grepl <- base::grepl
[10:33:12.241]                           restarts <- computeRestarts(cond)
[10:33:12.241]                           for (restart in restarts) {
[10:33:12.241]                             name <- restart$name
[10:33:12.241]                             if (is.null(name)) 
[10:33:12.241]                               next
[10:33:12.241]                             if (!grepl(pattern, name)) 
[10:33:12.241]                               next
[10:33:12.241]                             invokeRestart(restart)
[10:33:12.241]                             muffled <- TRUE
[10:33:12.241]                             break
[10:33:12.241]                           }
[10:33:12.241]                         }
[10:33:12.241]                       }
[10:33:12.241]                       invisible(muffled)
[10:33:12.241]                     }
[10:33:12.241]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.241]                   }
[10:33:12.241]                 }
[10:33:12.241]                 else {
[10:33:12.241]                   if (TRUE) {
[10:33:12.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.241]                     {
[10:33:12.241]                       inherits <- base::inherits
[10:33:12.241]                       invokeRestart <- base::invokeRestart
[10:33:12.241]                       is.null <- base::is.null
[10:33:12.241]                       muffled <- FALSE
[10:33:12.241]                       if (inherits(cond, "message")) {
[10:33:12.241]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.241]                         if (muffled) 
[10:33:12.241]                           invokeRestart("muffleMessage")
[10:33:12.241]                       }
[10:33:12.241]                       else if (inherits(cond, "warning")) {
[10:33:12.241]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.241]                         if (muffled) 
[10:33:12.241]                           invokeRestart("muffleWarning")
[10:33:12.241]                       }
[10:33:12.241]                       else if (inherits(cond, "condition")) {
[10:33:12.241]                         if (!is.null(pattern)) {
[10:33:12.241]                           computeRestarts <- base::computeRestarts
[10:33:12.241]                           grepl <- base::grepl
[10:33:12.241]                           restarts <- computeRestarts(cond)
[10:33:12.241]                           for (restart in restarts) {
[10:33:12.241]                             name <- restart$name
[10:33:12.241]                             if (is.null(name)) 
[10:33:12.241]                               next
[10:33:12.241]                             if (!grepl(pattern, name)) 
[10:33:12.241]                               next
[10:33:12.241]                             invokeRestart(restart)
[10:33:12.241]                             muffled <- TRUE
[10:33:12.241]                             break
[10:33:12.241]                           }
[10:33:12.241]                         }
[10:33:12.241]                       }
[10:33:12.241]                       invisible(muffled)
[10:33:12.241]                     }
[10:33:12.241]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.241]                   }
[10:33:12.241]                 }
[10:33:12.241]             }
[10:33:12.241]         }))
[10:33:12.241]     }, error = function(ex) {
[10:33:12.241]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.241]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.241]                 ...future.rng), started = ...future.startTime, 
[10:33:12.241]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.241]             version = "1.8"), class = "FutureResult")
[10:33:12.241]     }, finally = {
[10:33:12.241]         if (!identical(...future.workdir, getwd())) 
[10:33:12.241]             setwd(...future.workdir)
[10:33:12.241]         {
[10:33:12.241]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.241]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.241]             }
[10:33:12.241]             base::options(...future.oldOptions)
[10:33:12.241]             if (.Platform$OS.type == "windows") {
[10:33:12.241]                 old_names <- names(...future.oldEnvVars)
[10:33:12.241]                 envs <- base::Sys.getenv()
[10:33:12.241]                 names <- names(envs)
[10:33:12.241]                 common <- intersect(names, old_names)
[10:33:12.241]                 added <- setdiff(names, old_names)
[10:33:12.241]                 removed <- setdiff(old_names, names)
[10:33:12.241]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.241]                   envs[common]]
[10:33:12.241]                 NAMES <- toupper(changed)
[10:33:12.241]                 args <- list()
[10:33:12.241]                 for (kk in seq_along(NAMES)) {
[10:33:12.241]                   name <- changed[[kk]]
[10:33:12.241]                   NAME <- NAMES[[kk]]
[10:33:12.241]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.241]                     next
[10:33:12.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.241]                 }
[10:33:12.241]                 NAMES <- toupper(added)
[10:33:12.241]                 for (kk in seq_along(NAMES)) {
[10:33:12.241]                   name <- added[[kk]]
[10:33:12.241]                   NAME <- NAMES[[kk]]
[10:33:12.241]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.241]                     next
[10:33:12.241]                   args[[name]] <- ""
[10:33:12.241]                 }
[10:33:12.241]                 NAMES <- toupper(removed)
[10:33:12.241]                 for (kk in seq_along(NAMES)) {
[10:33:12.241]                   name <- removed[[kk]]
[10:33:12.241]                   NAME <- NAMES[[kk]]
[10:33:12.241]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.241]                     next
[10:33:12.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.241]                 }
[10:33:12.241]                 if (length(args) > 0) 
[10:33:12.241]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.241]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.241]             }
[10:33:12.241]             else {
[10:33:12.241]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.241]             }
[10:33:12.241]             {
[10:33:12.241]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.241]                   0L) {
[10:33:12.241]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.241]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.241]                   base::options(opts)
[10:33:12.241]                 }
[10:33:12.241]                 {
[10:33:12.241]                   {
[10:33:12.241]                     NULL
[10:33:12.241]                     RNGkind("Mersenne-Twister")
[10:33:12.241]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.241]                       inherits = FALSE)
[10:33:12.241]                   }
[10:33:12.241]                   options(future.plan = NULL)
[10:33:12.241]                   if (is.na(NA_character_)) 
[10:33:12.241]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.241]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.241]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.241]                     .init = FALSE)
[10:33:12.241]                 }
[10:33:12.241]             }
[10:33:12.241]         }
[10:33:12.241]     })
[10:33:12.241]     if (TRUE) {
[10:33:12.241]         base::sink(type = "output", split = FALSE)
[10:33:12.241]         if (TRUE) {
[10:33:12.241]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.241]         }
[10:33:12.241]         else {
[10:33:12.241]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.241]         }
[10:33:12.241]         base::close(...future.stdout)
[10:33:12.241]         ...future.stdout <- NULL
[10:33:12.241]     }
[10:33:12.241]     ...future.result$conditions <- ...future.conditions
[10:33:12.241]     ...future.result$finished <- base::Sys.time()
[10:33:12.241]     ...future.result
[10:33:12.241] }
[10:33:12.242] assign_globals() ...
[10:33:12.243] List of 2
[10:33:12.243]  $ a : num 1
[10:33:12.243]  $ ii: int 3
[10:33:12.243]  - attr(*, "where")=List of 2
[10:33:12.243]   ..$ a :<environment: R_EmptyEnv> 
[10:33:12.243]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:12.243]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.243]  - attr(*, "resolved")= logi TRUE
[10:33:12.243]  - attr(*, "total_size")= num 112
[10:33:12.243]  - attr(*, "already-done")= logi TRUE
[10:33:12.245] - copied ‘a’ to environment
[10:33:12.245] - copied ‘ii’ to environment
[10:33:12.246] assign_globals() ... done
[10:33:12.246] plan(): Setting new future strategy stack:
[10:33:12.246] List of future strategies:
[10:33:12.246] 1. sequential:
[10:33:12.246]    - args: function (..., envir = parent.frame())
[10:33:12.246]    - tweaked: FALSE
[10:33:12.246]    - call: NULL
[10:33:12.246] plan(): nbrOfWorkers() = 1
[10:33:12.247] plan(): Setting new future strategy stack:
[10:33:12.247] List of future strategies:
[10:33:12.247] 1. sequential:
[10:33:12.247]    - args: function (..., envir = parent.frame())
[10:33:12.247]    - tweaked: FALSE
[10:33:12.247]    - call: plan(strategy)
[10:33:12.247] plan(): nbrOfWorkers() = 1
[10:33:12.247] SequentialFuture started (and completed)
[10:33:12.248] - Launch lazy future ... done
[10:33:12.248] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.248] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.249] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:12.250] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:12.251] Searching for globals ... DONE
[10:33:12.251] Resolving globals: TRUE
[10:33:12.251] Resolving any globals that are futures ...
[10:33:12.251] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:12.251] Resolving any globals that are futures ... DONE
[10:33:12.251] Resolving futures part of globals (recursively) ...
[10:33:12.251] resolve() on list ...
[10:33:12.251]  recursive: 99
[10:33:12.252]  length: 2
[10:33:12.252]  elements: ‘a’, ‘ii’
[10:33:12.252]  length: 1 (resolved future 1)
[10:33:12.252]  length: 0 (resolved future 2)
[10:33:12.252] resolve() on list ... DONE
[10:33:12.252] - globals: [2] ‘a’, ‘ii’
[10:33:12.252] Resolving futures part of globals (recursively) ... DONE
[10:33:12.252] The total size of the 2 globals is 112 bytes (112 bytes)
[10:33:12.253] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:33:12.253] - globals: [2] ‘a’, ‘ii’
[10:33:12.253] 
[10:33:12.253] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.254] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.254] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:12.257] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:12.257] Searching for globals ... DONE
[10:33:12.257] Resolving globals: TRUE
[10:33:12.257] Resolving any globals that are futures ...
[10:33:12.257] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:12.257] Resolving any globals that are futures ... DONE
[10:33:12.258] Resolving futures part of globals (recursively) ...
[10:33:12.258] resolve() on list ...
[10:33:12.258]  recursive: 99
[10:33:12.258]  length: 2
[10:33:12.258]  elements: ‘a’, ‘ii’
[10:33:12.258]  length: 1 (resolved future 1)
[10:33:12.258]  length: 0 (resolved future 2)
[10:33:12.258] resolve() on list ... DONE
[10:33:12.258] - globals: [2] ‘a’, ‘ii’
[10:33:12.259] Resolving futures part of globals (recursively) ... DONE
[10:33:12.259] The total size of the 2 globals is 112 bytes (112 bytes)
[10:33:12.259] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:33:12.259] - globals: [2] ‘a’, ‘ii’
[10:33:12.259] 
[10:33:12.259] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.260] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.260] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:12.262] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:12.262] Searching for globals ... DONE
[10:33:12.262] Resolving globals: TRUE
[10:33:12.262] Resolving any globals that are futures ...
[10:33:12.262] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:12.262] Resolving any globals that are futures ... DONE
[10:33:12.263] Resolving futures part of globals (recursively) ...
[10:33:12.263] resolve() on list ...
[10:33:12.263]  recursive: 99
[10:33:12.263]  length: 2
[10:33:12.263]  elements: ‘a’, ‘ii’
[10:33:12.263]  length: 1 (resolved future 1)
[10:33:12.263]  length: 0 (resolved future 2)
[10:33:12.263] resolve() on list ... DONE
[10:33:12.263] - globals: [2] ‘a’, ‘ii’
[10:33:12.264] Resolving futures part of globals (recursively) ... DONE
[10:33:12.264] The total size of the 2 globals is 112 bytes (112 bytes)
[10:33:12.264] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:33:12.264] - globals: [2] ‘a’, ‘ii’
[10:33:12.264] 
[10:33:12.264] getGlobalsAndPackages() ... DONE
[10:33:12.265] run() for ‘Future’ ...
[10:33:12.265] - state: ‘created’
[10:33:12.265] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.265] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.265] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.265]   - Field: ‘label’
[10:33:12.265]   - Field: ‘local’
[10:33:12.265]   - Field: ‘owner’
[10:33:12.266]   - Field: ‘envir’
[10:33:12.266]   - Field: ‘packages’
[10:33:12.266]   - Field: ‘gc’
[10:33:12.266]   - Field: ‘conditions’
[10:33:12.266]   - Field: ‘expr’
[10:33:12.266]   - Field: ‘uuid’
[10:33:12.266]   - Field: ‘seed’
[10:33:12.266]   - Field: ‘version’
[10:33:12.266]   - Field: ‘result’
[10:33:12.266]   - Field: ‘asynchronous’
[10:33:12.266]   - Field: ‘calls’
[10:33:12.267]   - Field: ‘globals’
[10:33:12.267]   - Field: ‘stdout’
[10:33:12.267]   - Field: ‘earlySignal’
[10:33:12.267]   - Field: ‘lazy’
[10:33:12.267]   - Field: ‘state’
[10:33:12.267] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.267] - Launch lazy future ...
[10:33:12.267] Packages needed by the future expression (n = 0): <none>
[10:33:12.267] Packages needed by future strategies (n = 0): <none>
[10:33:12.268] {
[10:33:12.268]     {
[10:33:12.268]         {
[10:33:12.268]             ...future.startTime <- base::Sys.time()
[10:33:12.268]             {
[10:33:12.268]                 {
[10:33:12.268]                   {
[10:33:12.268]                     base::local({
[10:33:12.268]                       has_future <- base::requireNamespace("future", 
[10:33:12.268]                         quietly = TRUE)
[10:33:12.268]                       if (has_future) {
[10:33:12.268]                         ns <- base::getNamespace("future")
[10:33:12.268]                         version <- ns[[".package"]][["version"]]
[10:33:12.268]                         if (is.null(version)) 
[10:33:12.268]                           version <- utils::packageVersion("future")
[10:33:12.268]                       }
[10:33:12.268]                       else {
[10:33:12.268]                         version <- NULL
[10:33:12.268]                       }
[10:33:12.268]                       if (!has_future || version < "1.8.0") {
[10:33:12.268]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.268]                           "", base::R.version$version.string), 
[10:33:12.268]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.268]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.268]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.268]                             "release", "version")], collapse = " "), 
[10:33:12.268]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.268]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.268]                           info)
[10:33:12.268]                         info <- base::paste(info, collapse = "; ")
[10:33:12.268]                         if (!has_future) {
[10:33:12.268]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.268]                             info)
[10:33:12.268]                         }
[10:33:12.268]                         else {
[10:33:12.268]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.268]                             info, version)
[10:33:12.268]                         }
[10:33:12.268]                         base::stop(msg)
[10:33:12.268]                       }
[10:33:12.268]                     })
[10:33:12.268]                   }
[10:33:12.268]                   ...future.strategy.old <- future::plan("list")
[10:33:12.268]                   options(future.plan = NULL)
[10:33:12.268]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.268]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.268]                 }
[10:33:12.268]                 ...future.workdir <- getwd()
[10:33:12.268]             }
[10:33:12.268]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.268]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.268]         }
[10:33:12.268]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.268]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:12.268]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.268]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.268]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.268]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.268]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.268]             base::names(...future.oldOptions))
[10:33:12.268]     }
[10:33:12.268]     if (FALSE) {
[10:33:12.268]     }
[10:33:12.268]     else {
[10:33:12.268]         if (TRUE) {
[10:33:12.268]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.268]                 open = "w")
[10:33:12.268]         }
[10:33:12.268]         else {
[10:33:12.268]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.268]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.268]         }
[10:33:12.268]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.268]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.268]             base::sink(type = "output", split = FALSE)
[10:33:12.268]             base::close(...future.stdout)
[10:33:12.268]         }, add = TRUE)
[10:33:12.268]     }
[10:33:12.268]     ...future.frame <- base::sys.nframe()
[10:33:12.268]     ...future.conditions <- base::list()
[10:33:12.268]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.268]     if (FALSE) {
[10:33:12.268]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.268]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.268]     }
[10:33:12.268]     ...future.result <- base::tryCatch({
[10:33:12.268]         base::withCallingHandlers({
[10:33:12.268]             ...future.value <- base::withVisible(base::local({
[10:33:12.268]                 b <- a * ii
[10:33:12.268]                 a <- 0
[10:33:12.268]                 b
[10:33:12.268]             }))
[10:33:12.268]             future::FutureResult(value = ...future.value$value, 
[10:33:12.268]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.268]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.268]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.268]                     ...future.globalenv.names))
[10:33:12.268]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.268]         }, condition = base::local({
[10:33:12.268]             c <- base::c
[10:33:12.268]             inherits <- base::inherits
[10:33:12.268]             invokeRestart <- base::invokeRestart
[10:33:12.268]             length <- base::length
[10:33:12.268]             list <- base::list
[10:33:12.268]             seq.int <- base::seq.int
[10:33:12.268]             signalCondition <- base::signalCondition
[10:33:12.268]             sys.calls <- base::sys.calls
[10:33:12.268]             `[[` <- base::`[[`
[10:33:12.268]             `+` <- base::`+`
[10:33:12.268]             `<<-` <- base::`<<-`
[10:33:12.268]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.268]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.268]                   3L)]
[10:33:12.268]             }
[10:33:12.268]             function(cond) {
[10:33:12.268]                 is_error <- inherits(cond, "error")
[10:33:12.268]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.268]                   NULL)
[10:33:12.268]                 if (is_error) {
[10:33:12.268]                   sessionInformation <- function() {
[10:33:12.268]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.268]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.268]                       search = base::search(), system = base::Sys.info())
[10:33:12.268]                   }
[10:33:12.268]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.268]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.268]                     cond$call), session = sessionInformation(), 
[10:33:12.268]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.268]                   signalCondition(cond)
[10:33:12.268]                 }
[10:33:12.268]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.268]                 "immediateCondition"))) {
[10:33:12.268]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.268]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.268]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.268]                   if (TRUE && !signal) {
[10:33:12.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.268]                     {
[10:33:12.268]                       inherits <- base::inherits
[10:33:12.268]                       invokeRestart <- base::invokeRestart
[10:33:12.268]                       is.null <- base::is.null
[10:33:12.268]                       muffled <- FALSE
[10:33:12.268]                       if (inherits(cond, "message")) {
[10:33:12.268]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.268]                         if (muffled) 
[10:33:12.268]                           invokeRestart("muffleMessage")
[10:33:12.268]                       }
[10:33:12.268]                       else if (inherits(cond, "warning")) {
[10:33:12.268]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.268]                         if (muffled) 
[10:33:12.268]                           invokeRestart("muffleWarning")
[10:33:12.268]                       }
[10:33:12.268]                       else if (inherits(cond, "condition")) {
[10:33:12.268]                         if (!is.null(pattern)) {
[10:33:12.268]                           computeRestarts <- base::computeRestarts
[10:33:12.268]                           grepl <- base::grepl
[10:33:12.268]                           restarts <- computeRestarts(cond)
[10:33:12.268]                           for (restart in restarts) {
[10:33:12.268]                             name <- restart$name
[10:33:12.268]                             if (is.null(name)) 
[10:33:12.268]                               next
[10:33:12.268]                             if (!grepl(pattern, name)) 
[10:33:12.268]                               next
[10:33:12.268]                             invokeRestart(restart)
[10:33:12.268]                             muffled <- TRUE
[10:33:12.268]                             break
[10:33:12.268]                           }
[10:33:12.268]                         }
[10:33:12.268]                       }
[10:33:12.268]                       invisible(muffled)
[10:33:12.268]                     }
[10:33:12.268]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.268]                   }
[10:33:12.268]                 }
[10:33:12.268]                 else {
[10:33:12.268]                   if (TRUE) {
[10:33:12.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.268]                     {
[10:33:12.268]                       inherits <- base::inherits
[10:33:12.268]                       invokeRestart <- base::invokeRestart
[10:33:12.268]                       is.null <- base::is.null
[10:33:12.268]                       muffled <- FALSE
[10:33:12.268]                       if (inherits(cond, "message")) {
[10:33:12.268]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.268]                         if (muffled) 
[10:33:12.268]                           invokeRestart("muffleMessage")
[10:33:12.268]                       }
[10:33:12.268]                       else if (inherits(cond, "warning")) {
[10:33:12.268]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.268]                         if (muffled) 
[10:33:12.268]                           invokeRestart("muffleWarning")
[10:33:12.268]                       }
[10:33:12.268]                       else if (inherits(cond, "condition")) {
[10:33:12.268]                         if (!is.null(pattern)) {
[10:33:12.268]                           computeRestarts <- base::computeRestarts
[10:33:12.268]                           grepl <- base::grepl
[10:33:12.268]                           restarts <- computeRestarts(cond)
[10:33:12.268]                           for (restart in restarts) {
[10:33:12.268]                             name <- restart$name
[10:33:12.268]                             if (is.null(name)) 
[10:33:12.268]                               next
[10:33:12.268]                             if (!grepl(pattern, name)) 
[10:33:12.268]                               next
[10:33:12.268]                             invokeRestart(restart)
[10:33:12.268]                             muffled <- TRUE
[10:33:12.268]                             break
[10:33:12.268]                           }
[10:33:12.268]                         }
[10:33:12.268]                       }
[10:33:12.268]                       invisible(muffled)
[10:33:12.268]                     }
[10:33:12.268]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.268]                   }
[10:33:12.268]                 }
[10:33:12.268]             }
[10:33:12.268]         }))
[10:33:12.268]     }, error = function(ex) {
[10:33:12.268]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.268]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.268]                 ...future.rng), started = ...future.startTime, 
[10:33:12.268]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.268]             version = "1.8"), class = "FutureResult")
[10:33:12.268]     }, finally = {
[10:33:12.268]         if (!identical(...future.workdir, getwd())) 
[10:33:12.268]             setwd(...future.workdir)
[10:33:12.268]         {
[10:33:12.268]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.268]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.268]             }
[10:33:12.268]             base::options(...future.oldOptions)
[10:33:12.268]             if (.Platform$OS.type == "windows") {
[10:33:12.268]                 old_names <- names(...future.oldEnvVars)
[10:33:12.268]                 envs <- base::Sys.getenv()
[10:33:12.268]                 names <- names(envs)
[10:33:12.268]                 common <- intersect(names, old_names)
[10:33:12.268]                 added <- setdiff(names, old_names)
[10:33:12.268]                 removed <- setdiff(old_names, names)
[10:33:12.268]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.268]                   envs[common]]
[10:33:12.268]                 NAMES <- toupper(changed)
[10:33:12.268]                 args <- list()
[10:33:12.268]                 for (kk in seq_along(NAMES)) {
[10:33:12.268]                   name <- changed[[kk]]
[10:33:12.268]                   NAME <- NAMES[[kk]]
[10:33:12.268]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.268]                     next
[10:33:12.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.268]                 }
[10:33:12.268]                 NAMES <- toupper(added)
[10:33:12.268]                 for (kk in seq_along(NAMES)) {
[10:33:12.268]                   name <- added[[kk]]
[10:33:12.268]                   NAME <- NAMES[[kk]]
[10:33:12.268]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.268]                     next
[10:33:12.268]                   args[[name]] <- ""
[10:33:12.268]                 }
[10:33:12.268]                 NAMES <- toupper(removed)
[10:33:12.268]                 for (kk in seq_along(NAMES)) {
[10:33:12.268]                   name <- removed[[kk]]
[10:33:12.268]                   NAME <- NAMES[[kk]]
[10:33:12.268]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.268]                     next
[10:33:12.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.268]                 }
[10:33:12.268]                 if (length(args) > 0) 
[10:33:12.268]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.268]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.268]             }
[10:33:12.268]             else {
[10:33:12.268]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.268]             }
[10:33:12.268]             {
[10:33:12.268]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.268]                   0L) {
[10:33:12.268]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.268]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.268]                   base::options(opts)
[10:33:12.268]                 }
[10:33:12.268]                 {
[10:33:12.268]                   {
[10:33:12.268]                     NULL
[10:33:12.268]                     RNGkind("Mersenne-Twister")
[10:33:12.268]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.268]                       inherits = FALSE)
[10:33:12.268]                   }
[10:33:12.268]                   options(future.plan = NULL)
[10:33:12.268]                   if (is.na(NA_character_)) 
[10:33:12.268]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.268]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.268]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.268]                     .init = FALSE)
[10:33:12.268]                 }
[10:33:12.268]             }
[10:33:12.268]         }
[10:33:12.268]     })
[10:33:12.268]     if (TRUE) {
[10:33:12.268]         base::sink(type = "output", split = FALSE)
[10:33:12.268]         if (TRUE) {
[10:33:12.268]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.268]         }
[10:33:12.268]         else {
[10:33:12.268]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.268]         }
[10:33:12.268]         base::close(...future.stdout)
[10:33:12.268]         ...future.stdout <- NULL
[10:33:12.268]     }
[10:33:12.268]     ...future.result$conditions <- ...future.conditions
[10:33:12.268]     ...future.result$finished <- base::Sys.time()
[10:33:12.268]     ...future.result
[10:33:12.268] }
[10:33:12.269] assign_globals() ...
[10:33:12.269] List of 2
[10:33:12.269]  $ a : num 1
[10:33:12.269]  $ ii: int 1
[10:33:12.269]  - attr(*, "where")=List of 2
[10:33:12.269]   ..$ a :<environment: R_EmptyEnv> 
[10:33:12.269]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:12.269]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.269]  - attr(*, "resolved")= logi TRUE
[10:33:12.269]  - attr(*, "total_size")= num 112
[10:33:12.269]  - attr(*, "already-done")= logi TRUE
[10:33:12.272] - copied ‘a’ to environment
[10:33:12.272] - copied ‘ii’ to environment
[10:33:12.272] assign_globals() ... done
[10:33:12.273] plan(): Setting new future strategy stack:
[10:33:12.273] List of future strategies:
[10:33:12.273] 1. sequential:
[10:33:12.273]    - args: function (..., envir = parent.frame())
[10:33:12.273]    - tweaked: FALSE
[10:33:12.273]    - call: NULL
[10:33:12.273] plan(): nbrOfWorkers() = 1
[10:33:12.274] plan(): Setting new future strategy stack:
[10:33:12.274] List of future strategies:
[10:33:12.274] 1. sequential:
[10:33:12.274]    - args: function (..., envir = parent.frame())
[10:33:12.274]    - tweaked: FALSE
[10:33:12.274]    - call: plan(strategy)
[10:33:12.274] plan(): nbrOfWorkers() = 1
[10:33:12.274] SequentialFuture started (and completed)
[10:33:12.274] - Launch lazy future ... done
[10:33:12.274] run() for ‘SequentialFuture’ ... done
[10:33:12.275] run() for ‘Future’ ...
[10:33:12.275] - state: ‘created’
[10:33:12.275] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.275] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.275] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.275]   - Field: ‘label’
[10:33:12.275]   - Field: ‘local’
[10:33:12.275]   - Field: ‘owner’
[10:33:12.276]   - Field: ‘envir’
[10:33:12.276]   - Field: ‘packages’
[10:33:12.276]   - Field: ‘gc’
[10:33:12.276]   - Field: ‘conditions’
[10:33:12.276]   - Field: ‘expr’
[10:33:12.276]   - Field: ‘uuid’
[10:33:12.276]   - Field: ‘seed’
[10:33:12.276]   - Field: ‘version’
[10:33:12.276]   - Field: ‘result’
[10:33:12.278]   - Field: ‘asynchronous’
[10:33:12.278]   - Field: ‘calls’
[10:33:12.278]   - Field: ‘globals’
[10:33:12.278]   - Field: ‘stdout’
[10:33:12.278]   - Field: ‘earlySignal’
[10:33:12.278]   - Field: ‘lazy’
[10:33:12.278]   - Field: ‘state’
[10:33:12.278] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.278] - Launch lazy future ...
[10:33:12.278] Packages needed by the future expression (n = 0): <none>
[10:33:12.279] Packages needed by future strategies (n = 0): <none>
[10:33:12.279] {
[10:33:12.279]     {
[10:33:12.279]         {
[10:33:12.279]             ...future.startTime <- base::Sys.time()
[10:33:12.279]             {
[10:33:12.279]                 {
[10:33:12.279]                   {
[10:33:12.279]                     base::local({
[10:33:12.279]                       has_future <- base::requireNamespace("future", 
[10:33:12.279]                         quietly = TRUE)
[10:33:12.279]                       if (has_future) {
[10:33:12.279]                         ns <- base::getNamespace("future")
[10:33:12.279]                         version <- ns[[".package"]][["version"]]
[10:33:12.279]                         if (is.null(version)) 
[10:33:12.279]                           version <- utils::packageVersion("future")
[10:33:12.279]                       }
[10:33:12.279]                       else {
[10:33:12.279]                         version <- NULL
[10:33:12.279]                       }
[10:33:12.279]                       if (!has_future || version < "1.8.0") {
[10:33:12.279]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.279]                           "", base::R.version$version.string), 
[10:33:12.279]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.279]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.279]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.279]                             "release", "version")], collapse = " "), 
[10:33:12.279]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.279]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.279]                           info)
[10:33:12.279]                         info <- base::paste(info, collapse = "; ")
[10:33:12.279]                         if (!has_future) {
[10:33:12.279]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.279]                             info)
[10:33:12.279]                         }
[10:33:12.279]                         else {
[10:33:12.279]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.279]                             info, version)
[10:33:12.279]                         }
[10:33:12.279]                         base::stop(msg)
[10:33:12.279]                       }
[10:33:12.279]                     })
[10:33:12.279]                   }
[10:33:12.279]                   ...future.strategy.old <- future::plan("list")
[10:33:12.279]                   options(future.plan = NULL)
[10:33:12.279]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.279]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.279]                 }
[10:33:12.279]                 ...future.workdir <- getwd()
[10:33:12.279]             }
[10:33:12.279]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.279]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.279]         }
[10:33:12.279]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.279]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:12.279]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.279]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.279]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.279]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.279]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.279]             base::names(...future.oldOptions))
[10:33:12.279]     }
[10:33:12.279]     if (FALSE) {
[10:33:12.279]     }
[10:33:12.279]     else {
[10:33:12.279]         if (TRUE) {
[10:33:12.279]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.279]                 open = "w")
[10:33:12.279]         }
[10:33:12.279]         else {
[10:33:12.279]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.279]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.279]         }
[10:33:12.279]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.279]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.279]             base::sink(type = "output", split = FALSE)
[10:33:12.279]             base::close(...future.stdout)
[10:33:12.279]         }, add = TRUE)
[10:33:12.279]     }
[10:33:12.279]     ...future.frame <- base::sys.nframe()
[10:33:12.279]     ...future.conditions <- base::list()
[10:33:12.279]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.279]     if (FALSE) {
[10:33:12.279]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.279]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.279]     }
[10:33:12.279]     ...future.result <- base::tryCatch({
[10:33:12.279]         base::withCallingHandlers({
[10:33:12.279]             ...future.value <- base::withVisible(base::local({
[10:33:12.279]                 b <- a * ii
[10:33:12.279]                 a <- 0
[10:33:12.279]                 b
[10:33:12.279]             }))
[10:33:12.279]             future::FutureResult(value = ...future.value$value, 
[10:33:12.279]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.279]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.279]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.279]                     ...future.globalenv.names))
[10:33:12.279]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.279]         }, condition = base::local({
[10:33:12.279]             c <- base::c
[10:33:12.279]             inherits <- base::inherits
[10:33:12.279]             invokeRestart <- base::invokeRestart
[10:33:12.279]             length <- base::length
[10:33:12.279]             list <- base::list
[10:33:12.279]             seq.int <- base::seq.int
[10:33:12.279]             signalCondition <- base::signalCondition
[10:33:12.279]             sys.calls <- base::sys.calls
[10:33:12.279]             `[[` <- base::`[[`
[10:33:12.279]             `+` <- base::`+`
[10:33:12.279]             `<<-` <- base::`<<-`
[10:33:12.279]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.279]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.279]                   3L)]
[10:33:12.279]             }
[10:33:12.279]             function(cond) {
[10:33:12.279]                 is_error <- inherits(cond, "error")
[10:33:12.279]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.279]                   NULL)
[10:33:12.279]                 if (is_error) {
[10:33:12.279]                   sessionInformation <- function() {
[10:33:12.279]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.279]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.279]                       search = base::search(), system = base::Sys.info())
[10:33:12.279]                   }
[10:33:12.279]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.279]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.279]                     cond$call), session = sessionInformation(), 
[10:33:12.279]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.279]                   signalCondition(cond)
[10:33:12.279]                 }
[10:33:12.279]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.279]                 "immediateCondition"))) {
[10:33:12.279]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.279]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.279]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.279]                   if (TRUE && !signal) {
[10:33:12.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.279]                     {
[10:33:12.279]                       inherits <- base::inherits
[10:33:12.279]                       invokeRestart <- base::invokeRestart
[10:33:12.279]                       is.null <- base::is.null
[10:33:12.279]                       muffled <- FALSE
[10:33:12.279]                       if (inherits(cond, "message")) {
[10:33:12.279]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.279]                         if (muffled) 
[10:33:12.279]                           invokeRestart("muffleMessage")
[10:33:12.279]                       }
[10:33:12.279]                       else if (inherits(cond, "warning")) {
[10:33:12.279]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.279]                         if (muffled) 
[10:33:12.279]                           invokeRestart("muffleWarning")
[10:33:12.279]                       }
[10:33:12.279]                       else if (inherits(cond, "condition")) {
[10:33:12.279]                         if (!is.null(pattern)) {
[10:33:12.279]                           computeRestarts <- base::computeRestarts
[10:33:12.279]                           grepl <- base::grepl
[10:33:12.279]                           restarts <- computeRestarts(cond)
[10:33:12.279]                           for (restart in restarts) {
[10:33:12.279]                             name <- restart$name
[10:33:12.279]                             if (is.null(name)) 
[10:33:12.279]                               next
[10:33:12.279]                             if (!grepl(pattern, name)) 
[10:33:12.279]                               next
[10:33:12.279]                             invokeRestart(restart)
[10:33:12.279]                             muffled <- TRUE
[10:33:12.279]                             break
[10:33:12.279]                           }
[10:33:12.279]                         }
[10:33:12.279]                       }
[10:33:12.279]                       invisible(muffled)
[10:33:12.279]                     }
[10:33:12.279]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.279]                   }
[10:33:12.279]                 }
[10:33:12.279]                 else {
[10:33:12.279]                   if (TRUE) {
[10:33:12.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.279]                     {
[10:33:12.279]                       inherits <- base::inherits
[10:33:12.279]                       invokeRestart <- base::invokeRestart
[10:33:12.279]                       is.null <- base::is.null
[10:33:12.279]                       muffled <- FALSE
[10:33:12.279]                       if (inherits(cond, "message")) {
[10:33:12.279]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.279]                         if (muffled) 
[10:33:12.279]                           invokeRestart("muffleMessage")
[10:33:12.279]                       }
[10:33:12.279]                       else if (inherits(cond, "warning")) {
[10:33:12.279]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.279]                         if (muffled) 
[10:33:12.279]                           invokeRestart("muffleWarning")
[10:33:12.279]                       }
[10:33:12.279]                       else if (inherits(cond, "condition")) {
[10:33:12.279]                         if (!is.null(pattern)) {
[10:33:12.279]                           computeRestarts <- base::computeRestarts
[10:33:12.279]                           grepl <- base::grepl
[10:33:12.279]                           restarts <- computeRestarts(cond)
[10:33:12.279]                           for (restart in restarts) {
[10:33:12.279]                             name <- restart$name
[10:33:12.279]                             if (is.null(name)) 
[10:33:12.279]                               next
[10:33:12.279]                             if (!grepl(pattern, name)) 
[10:33:12.279]                               next
[10:33:12.279]                             invokeRestart(restart)
[10:33:12.279]                             muffled <- TRUE
[10:33:12.279]                             break
[10:33:12.279]                           }
[10:33:12.279]                         }
[10:33:12.279]                       }
[10:33:12.279]                       invisible(muffled)
[10:33:12.279]                     }
[10:33:12.279]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.279]                   }
[10:33:12.279]                 }
[10:33:12.279]             }
[10:33:12.279]         }))
[10:33:12.279]     }, error = function(ex) {
[10:33:12.279]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.279]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.279]                 ...future.rng), started = ...future.startTime, 
[10:33:12.279]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.279]             version = "1.8"), class = "FutureResult")
[10:33:12.279]     }, finally = {
[10:33:12.279]         if (!identical(...future.workdir, getwd())) 
[10:33:12.279]             setwd(...future.workdir)
[10:33:12.279]         {
[10:33:12.279]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.279]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.279]             }
[10:33:12.279]             base::options(...future.oldOptions)
[10:33:12.279]             if (.Platform$OS.type == "windows") {
[10:33:12.279]                 old_names <- names(...future.oldEnvVars)
[10:33:12.279]                 envs <- base::Sys.getenv()
[10:33:12.279]                 names <- names(envs)
[10:33:12.279]                 common <- intersect(names, old_names)
[10:33:12.279]                 added <- setdiff(names, old_names)
[10:33:12.279]                 removed <- setdiff(old_names, names)
[10:33:12.279]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.279]                   envs[common]]
[10:33:12.279]                 NAMES <- toupper(changed)
[10:33:12.279]                 args <- list()
[10:33:12.279]                 for (kk in seq_along(NAMES)) {
[10:33:12.279]                   name <- changed[[kk]]
[10:33:12.279]                   NAME <- NAMES[[kk]]
[10:33:12.279]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.279]                     next
[10:33:12.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.279]                 }
[10:33:12.279]                 NAMES <- toupper(added)
[10:33:12.279]                 for (kk in seq_along(NAMES)) {
[10:33:12.279]                   name <- added[[kk]]
[10:33:12.279]                   NAME <- NAMES[[kk]]
[10:33:12.279]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.279]                     next
[10:33:12.279]                   args[[name]] <- ""
[10:33:12.279]                 }
[10:33:12.279]                 NAMES <- toupper(removed)
[10:33:12.279]                 for (kk in seq_along(NAMES)) {
[10:33:12.279]                   name <- removed[[kk]]
[10:33:12.279]                   NAME <- NAMES[[kk]]
[10:33:12.279]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.279]                     next
[10:33:12.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.279]                 }
[10:33:12.279]                 if (length(args) > 0) 
[10:33:12.279]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.279]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.279]             }
[10:33:12.279]             else {
[10:33:12.279]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.279]             }
[10:33:12.279]             {
[10:33:12.279]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.279]                   0L) {
[10:33:12.279]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.279]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.279]                   base::options(opts)
[10:33:12.279]                 }
[10:33:12.279]                 {
[10:33:12.279]                   {
[10:33:12.279]                     NULL
[10:33:12.279]                     RNGkind("Mersenne-Twister")
[10:33:12.279]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.279]                       inherits = FALSE)
[10:33:12.279]                   }
[10:33:12.279]                   options(future.plan = NULL)
[10:33:12.279]                   if (is.na(NA_character_)) 
[10:33:12.279]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.279]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.279]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.279]                     .init = FALSE)
[10:33:12.279]                 }
[10:33:12.279]             }
[10:33:12.279]         }
[10:33:12.279]     })
[10:33:12.279]     if (TRUE) {
[10:33:12.279]         base::sink(type = "output", split = FALSE)
[10:33:12.279]         if (TRUE) {
[10:33:12.279]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.279]         }
[10:33:12.279]         else {
[10:33:12.279]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.279]         }
[10:33:12.279]         base::close(...future.stdout)
[10:33:12.279]         ...future.stdout <- NULL
[10:33:12.279]     }
[10:33:12.279]     ...future.result$conditions <- ...future.conditions
[10:33:12.279]     ...future.result$finished <- base::Sys.time()
[10:33:12.279]     ...future.result
[10:33:12.279] }
[10:33:12.280] assign_globals() ...
[10:33:12.281] List of 2
[10:33:12.281]  $ a : num 1
[10:33:12.281]  $ ii: int 2
[10:33:12.281]  - attr(*, "where")=List of 2
[10:33:12.281]   ..$ a :<environment: R_EmptyEnv> 
[10:33:12.281]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:12.281]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.281]  - attr(*, "resolved")= logi TRUE
[10:33:12.281]  - attr(*, "total_size")= num 112
[10:33:12.281]  - attr(*, "already-done")= logi TRUE
[10:33:12.283] - copied ‘a’ to environment
[10:33:12.283] - copied ‘ii’ to environment
[10:33:12.284] assign_globals() ... done
[10:33:12.284] plan(): Setting new future strategy stack:
[10:33:12.284] List of future strategies:
[10:33:12.284] 1. sequential:
[10:33:12.284]    - args: function (..., envir = parent.frame())
[10:33:12.284]    - tweaked: FALSE
[10:33:12.284]    - call: NULL
[10:33:12.284] plan(): nbrOfWorkers() = 1
[10:33:12.285] plan(): Setting new future strategy stack:
[10:33:12.285] List of future strategies:
[10:33:12.285] 1. sequential:
[10:33:12.285]    - args: function (..., envir = parent.frame())
[10:33:12.285]    - tweaked: FALSE
[10:33:12.285]    - call: plan(strategy)
[10:33:12.285] plan(): nbrOfWorkers() = 1
[10:33:12.285] SequentialFuture started (and completed)
[10:33:12.286] - Launch lazy future ... done
[10:33:12.286] run() for ‘SequentialFuture’ ... done
[10:33:12.286] run() for ‘Future’ ...
[10:33:12.286] - state: ‘created’
[10:33:12.286] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.286] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.286] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.287]   - Field: ‘label’
[10:33:12.287]   - Field: ‘local’
[10:33:12.287]   - Field: ‘owner’
[10:33:12.287]   - Field: ‘envir’
[10:33:12.287]   - Field: ‘packages’
[10:33:12.287]   - Field: ‘gc’
[10:33:12.287]   - Field: ‘conditions’
[10:33:12.287]   - Field: ‘expr’
[10:33:12.287]   - Field: ‘uuid’
[10:33:12.287]   - Field: ‘seed’
[10:33:12.287]   - Field: ‘version’
[10:33:12.287]   - Field: ‘result’
[10:33:12.288]   - Field: ‘asynchronous’
[10:33:12.288]   - Field: ‘calls’
[10:33:12.288]   - Field: ‘globals’
[10:33:12.288]   - Field: ‘stdout’
[10:33:12.288]   - Field: ‘earlySignal’
[10:33:12.288]   - Field: ‘lazy’
[10:33:12.288]   - Field: ‘state’
[10:33:12.288] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.288] - Launch lazy future ...
[10:33:12.288] Packages needed by the future expression (n = 0): <none>
[10:33:12.289] Packages needed by future strategies (n = 0): <none>
[10:33:12.289] {
[10:33:12.289]     {
[10:33:12.289]         {
[10:33:12.289]             ...future.startTime <- base::Sys.time()
[10:33:12.289]             {
[10:33:12.289]                 {
[10:33:12.289]                   {
[10:33:12.289]                     base::local({
[10:33:12.289]                       has_future <- base::requireNamespace("future", 
[10:33:12.289]                         quietly = TRUE)
[10:33:12.289]                       if (has_future) {
[10:33:12.289]                         ns <- base::getNamespace("future")
[10:33:12.289]                         version <- ns[[".package"]][["version"]]
[10:33:12.289]                         if (is.null(version)) 
[10:33:12.289]                           version <- utils::packageVersion("future")
[10:33:12.289]                       }
[10:33:12.289]                       else {
[10:33:12.289]                         version <- NULL
[10:33:12.289]                       }
[10:33:12.289]                       if (!has_future || version < "1.8.0") {
[10:33:12.289]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.289]                           "", base::R.version$version.string), 
[10:33:12.289]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.289]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.289]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.289]                             "release", "version")], collapse = " "), 
[10:33:12.289]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.289]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.289]                           info)
[10:33:12.289]                         info <- base::paste(info, collapse = "; ")
[10:33:12.289]                         if (!has_future) {
[10:33:12.289]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.289]                             info)
[10:33:12.289]                         }
[10:33:12.289]                         else {
[10:33:12.289]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.289]                             info, version)
[10:33:12.289]                         }
[10:33:12.289]                         base::stop(msg)
[10:33:12.289]                       }
[10:33:12.289]                     })
[10:33:12.289]                   }
[10:33:12.289]                   ...future.strategy.old <- future::plan("list")
[10:33:12.289]                   options(future.plan = NULL)
[10:33:12.289]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.289]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.289]                 }
[10:33:12.289]                 ...future.workdir <- getwd()
[10:33:12.289]             }
[10:33:12.289]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.289]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.289]         }
[10:33:12.289]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.289]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:12.289]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.289]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.289]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.289]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.289]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.289]             base::names(...future.oldOptions))
[10:33:12.289]     }
[10:33:12.289]     if (FALSE) {
[10:33:12.289]     }
[10:33:12.289]     else {
[10:33:12.289]         if (TRUE) {
[10:33:12.289]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.289]                 open = "w")
[10:33:12.289]         }
[10:33:12.289]         else {
[10:33:12.289]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.289]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.289]         }
[10:33:12.289]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.289]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.289]             base::sink(type = "output", split = FALSE)
[10:33:12.289]             base::close(...future.stdout)
[10:33:12.289]         }, add = TRUE)
[10:33:12.289]     }
[10:33:12.289]     ...future.frame <- base::sys.nframe()
[10:33:12.289]     ...future.conditions <- base::list()
[10:33:12.289]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.289]     if (FALSE) {
[10:33:12.289]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.289]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.289]     }
[10:33:12.289]     ...future.result <- base::tryCatch({
[10:33:12.289]         base::withCallingHandlers({
[10:33:12.289]             ...future.value <- base::withVisible(base::local({
[10:33:12.289]                 b <- a * ii
[10:33:12.289]                 a <- 0
[10:33:12.289]                 b
[10:33:12.289]             }))
[10:33:12.289]             future::FutureResult(value = ...future.value$value, 
[10:33:12.289]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.289]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.289]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.289]                     ...future.globalenv.names))
[10:33:12.289]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.289]         }, condition = base::local({
[10:33:12.289]             c <- base::c
[10:33:12.289]             inherits <- base::inherits
[10:33:12.289]             invokeRestart <- base::invokeRestart
[10:33:12.289]             length <- base::length
[10:33:12.289]             list <- base::list
[10:33:12.289]             seq.int <- base::seq.int
[10:33:12.289]             signalCondition <- base::signalCondition
[10:33:12.289]             sys.calls <- base::sys.calls
[10:33:12.289]             `[[` <- base::`[[`
[10:33:12.289]             `+` <- base::`+`
[10:33:12.289]             `<<-` <- base::`<<-`
[10:33:12.289]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.289]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.289]                   3L)]
[10:33:12.289]             }
[10:33:12.289]             function(cond) {
[10:33:12.289]                 is_error <- inherits(cond, "error")
[10:33:12.289]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.289]                   NULL)
[10:33:12.289]                 if (is_error) {
[10:33:12.289]                   sessionInformation <- function() {
[10:33:12.289]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.289]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.289]                       search = base::search(), system = base::Sys.info())
[10:33:12.289]                   }
[10:33:12.289]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.289]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.289]                     cond$call), session = sessionInformation(), 
[10:33:12.289]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.289]                   signalCondition(cond)
[10:33:12.289]                 }
[10:33:12.289]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.289]                 "immediateCondition"))) {
[10:33:12.289]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.289]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.289]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.289]                   if (TRUE && !signal) {
[10:33:12.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.289]                     {
[10:33:12.289]                       inherits <- base::inherits
[10:33:12.289]                       invokeRestart <- base::invokeRestart
[10:33:12.289]                       is.null <- base::is.null
[10:33:12.289]                       muffled <- FALSE
[10:33:12.289]                       if (inherits(cond, "message")) {
[10:33:12.289]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.289]                         if (muffled) 
[10:33:12.289]                           invokeRestart("muffleMessage")
[10:33:12.289]                       }
[10:33:12.289]                       else if (inherits(cond, "warning")) {
[10:33:12.289]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.289]                         if (muffled) 
[10:33:12.289]                           invokeRestart("muffleWarning")
[10:33:12.289]                       }
[10:33:12.289]                       else if (inherits(cond, "condition")) {
[10:33:12.289]                         if (!is.null(pattern)) {
[10:33:12.289]                           computeRestarts <- base::computeRestarts
[10:33:12.289]                           grepl <- base::grepl
[10:33:12.289]                           restarts <- computeRestarts(cond)
[10:33:12.289]                           for (restart in restarts) {
[10:33:12.289]                             name <- restart$name
[10:33:12.289]                             if (is.null(name)) 
[10:33:12.289]                               next
[10:33:12.289]                             if (!grepl(pattern, name)) 
[10:33:12.289]                               next
[10:33:12.289]                             invokeRestart(restart)
[10:33:12.289]                             muffled <- TRUE
[10:33:12.289]                             break
[10:33:12.289]                           }
[10:33:12.289]                         }
[10:33:12.289]                       }
[10:33:12.289]                       invisible(muffled)
[10:33:12.289]                     }
[10:33:12.289]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.289]                   }
[10:33:12.289]                 }
[10:33:12.289]                 else {
[10:33:12.289]                   if (TRUE) {
[10:33:12.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.289]                     {
[10:33:12.289]                       inherits <- base::inherits
[10:33:12.289]                       invokeRestart <- base::invokeRestart
[10:33:12.289]                       is.null <- base::is.null
[10:33:12.289]                       muffled <- FALSE
[10:33:12.289]                       if (inherits(cond, "message")) {
[10:33:12.289]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.289]                         if (muffled) 
[10:33:12.289]                           invokeRestart("muffleMessage")
[10:33:12.289]                       }
[10:33:12.289]                       else if (inherits(cond, "warning")) {
[10:33:12.289]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.289]                         if (muffled) 
[10:33:12.289]                           invokeRestart("muffleWarning")
[10:33:12.289]                       }
[10:33:12.289]                       else if (inherits(cond, "condition")) {
[10:33:12.289]                         if (!is.null(pattern)) {
[10:33:12.289]                           computeRestarts <- base::computeRestarts
[10:33:12.289]                           grepl <- base::grepl
[10:33:12.289]                           restarts <- computeRestarts(cond)
[10:33:12.289]                           for (restart in restarts) {
[10:33:12.289]                             name <- restart$name
[10:33:12.289]                             if (is.null(name)) 
[10:33:12.289]                               next
[10:33:12.289]                             if (!grepl(pattern, name)) 
[10:33:12.289]                               next
[10:33:12.289]                             invokeRestart(restart)
[10:33:12.289]                             muffled <- TRUE
[10:33:12.289]                             break
[10:33:12.289]                           }
[10:33:12.289]                         }
[10:33:12.289]                       }
[10:33:12.289]                       invisible(muffled)
[10:33:12.289]                     }
[10:33:12.289]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.289]                   }
[10:33:12.289]                 }
[10:33:12.289]             }
[10:33:12.289]         }))
[10:33:12.289]     }, error = function(ex) {
[10:33:12.289]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.289]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.289]                 ...future.rng), started = ...future.startTime, 
[10:33:12.289]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.289]             version = "1.8"), class = "FutureResult")
[10:33:12.289]     }, finally = {
[10:33:12.289]         if (!identical(...future.workdir, getwd())) 
[10:33:12.289]             setwd(...future.workdir)
[10:33:12.289]         {
[10:33:12.289]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.289]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.289]             }
[10:33:12.289]             base::options(...future.oldOptions)
[10:33:12.289]             if (.Platform$OS.type == "windows") {
[10:33:12.289]                 old_names <- names(...future.oldEnvVars)
[10:33:12.289]                 envs <- base::Sys.getenv()
[10:33:12.289]                 names <- names(envs)
[10:33:12.289]                 common <- intersect(names, old_names)
[10:33:12.289]                 added <- setdiff(names, old_names)
[10:33:12.289]                 removed <- setdiff(old_names, names)
[10:33:12.289]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.289]                   envs[common]]
[10:33:12.289]                 NAMES <- toupper(changed)
[10:33:12.289]                 args <- list()
[10:33:12.289]                 for (kk in seq_along(NAMES)) {
[10:33:12.289]                   name <- changed[[kk]]
[10:33:12.289]                   NAME <- NAMES[[kk]]
[10:33:12.289]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.289]                     next
[10:33:12.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.289]                 }
[10:33:12.289]                 NAMES <- toupper(added)
[10:33:12.289]                 for (kk in seq_along(NAMES)) {
[10:33:12.289]                   name <- added[[kk]]
[10:33:12.289]                   NAME <- NAMES[[kk]]
[10:33:12.289]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.289]                     next
[10:33:12.289]                   args[[name]] <- ""
[10:33:12.289]                 }
[10:33:12.289]                 NAMES <- toupper(removed)
[10:33:12.289]                 for (kk in seq_along(NAMES)) {
[10:33:12.289]                   name <- removed[[kk]]
[10:33:12.289]                   NAME <- NAMES[[kk]]
[10:33:12.289]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.289]                     next
[10:33:12.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.289]                 }
[10:33:12.289]                 if (length(args) > 0) 
[10:33:12.289]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.289]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.289]             }
[10:33:12.289]             else {
[10:33:12.289]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.289]             }
[10:33:12.289]             {
[10:33:12.289]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.289]                   0L) {
[10:33:12.289]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.289]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.289]                   base::options(opts)
[10:33:12.289]                 }
[10:33:12.289]                 {
[10:33:12.289]                   {
[10:33:12.289]                     NULL
[10:33:12.289]                     RNGkind("Mersenne-Twister")
[10:33:12.289]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.289]                       inherits = FALSE)
[10:33:12.289]                   }
[10:33:12.289]                   options(future.plan = NULL)
[10:33:12.289]                   if (is.na(NA_character_)) 
[10:33:12.289]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.289]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.289]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.289]                     .init = FALSE)
[10:33:12.289]                 }
[10:33:12.289]             }
[10:33:12.289]         }
[10:33:12.289]     })
[10:33:12.289]     if (TRUE) {
[10:33:12.289]         base::sink(type = "output", split = FALSE)
[10:33:12.289]         if (TRUE) {
[10:33:12.289]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.289]         }
[10:33:12.289]         else {
[10:33:12.289]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.289]         }
[10:33:12.289]         base::close(...future.stdout)
[10:33:12.289]         ...future.stdout <- NULL
[10:33:12.289]     }
[10:33:12.289]     ...future.result$conditions <- ...future.conditions
[10:33:12.289]     ...future.result$finished <- base::Sys.time()
[10:33:12.289]     ...future.result
[10:33:12.289] }
[10:33:12.290] assign_globals() ...
[10:33:12.291] List of 2
[10:33:12.291]  $ a : num 1
[10:33:12.291]  $ ii: int 3
[10:33:12.291]  - attr(*, "where")=List of 2
[10:33:12.291]   ..$ a :<environment: R_EmptyEnv> 
[10:33:12.291]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:12.291]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.291]  - attr(*, "resolved")= logi TRUE
[10:33:12.291]  - attr(*, "total_size")= num 112
[10:33:12.291]  - attr(*, "already-done")= logi TRUE
[10:33:12.293] - copied ‘a’ to environment
[10:33:12.293] - copied ‘ii’ to environment
[10:33:12.294] assign_globals() ... done
[10:33:12.294] plan(): Setting new future strategy stack:
[10:33:12.294] List of future strategies:
[10:33:12.294] 1. sequential:
[10:33:12.294]    - args: function (..., envir = parent.frame())
[10:33:12.294]    - tweaked: FALSE
[10:33:12.294]    - call: NULL
[10:33:12.294] plan(): nbrOfWorkers() = 1
[10:33:12.295] plan(): Setting new future strategy stack:
[10:33:12.295] List of future strategies:
[10:33:12.295] 1. sequential:
[10:33:12.295]    - args: function (..., envir = parent.frame())
[10:33:12.295]    - tweaked: FALSE
[10:33:12.295]    - call: plan(strategy)
[10:33:12.295] plan(): nbrOfWorkers() = 1
[10:33:12.295] SequentialFuture started (and completed)
[10:33:12.296] - Launch lazy future ... done
[10:33:12.296] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.296] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.296] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:12.297] 
[10:33:12.297] Searching for globals ... DONE
[10:33:12.297] - globals: [0] <none>
[10:33:12.297] getGlobalsAndPackages() ... DONE
[10:33:12.297] run() for ‘Future’ ...
[10:33:12.297] - state: ‘created’
[10:33:12.297] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.298] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.298] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.298]   - Field: ‘label’
[10:33:12.298]   - Field: ‘local’
[10:33:12.298]   - Field: ‘owner’
[10:33:12.298]   - Field: ‘envir’
[10:33:12.298]   - Field: ‘packages’
[10:33:12.298]   - Field: ‘gc’
[10:33:12.298]   - Field: ‘conditions’
[10:33:12.298]   - Field: ‘expr’
[10:33:12.298]   - Field: ‘uuid’
[10:33:12.299]   - Field: ‘seed’
[10:33:12.299]   - Field: ‘version’
[10:33:12.299]   - Field: ‘result’
[10:33:12.299]   - Field: ‘asynchronous’
[10:33:12.299]   - Field: ‘calls’
[10:33:12.299]   - Field: ‘globals’
[10:33:12.299]   - Field: ‘stdout’
[10:33:12.299]   - Field: ‘earlySignal’
[10:33:12.299]   - Field: ‘lazy’
[10:33:12.299]   - Field: ‘state’
[10:33:12.299] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.300] - Launch lazy future ...
[10:33:12.300] Packages needed by the future expression (n = 0): <none>
[10:33:12.300] Packages needed by future strategies (n = 0): <none>
[10:33:12.300] {
[10:33:12.300]     {
[10:33:12.300]         {
[10:33:12.300]             ...future.startTime <- base::Sys.time()
[10:33:12.300]             {
[10:33:12.300]                 {
[10:33:12.300]                   {
[10:33:12.300]                     base::local({
[10:33:12.300]                       has_future <- base::requireNamespace("future", 
[10:33:12.300]                         quietly = TRUE)
[10:33:12.300]                       if (has_future) {
[10:33:12.300]                         ns <- base::getNamespace("future")
[10:33:12.300]                         version <- ns[[".package"]][["version"]]
[10:33:12.300]                         if (is.null(version)) 
[10:33:12.300]                           version <- utils::packageVersion("future")
[10:33:12.300]                       }
[10:33:12.300]                       else {
[10:33:12.300]                         version <- NULL
[10:33:12.300]                       }
[10:33:12.300]                       if (!has_future || version < "1.8.0") {
[10:33:12.300]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.300]                           "", base::R.version$version.string), 
[10:33:12.300]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.300]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.300]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.300]                             "release", "version")], collapse = " "), 
[10:33:12.300]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.300]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.300]                           info)
[10:33:12.300]                         info <- base::paste(info, collapse = "; ")
[10:33:12.300]                         if (!has_future) {
[10:33:12.300]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.300]                             info)
[10:33:12.300]                         }
[10:33:12.300]                         else {
[10:33:12.300]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.300]                             info, version)
[10:33:12.300]                         }
[10:33:12.300]                         base::stop(msg)
[10:33:12.300]                       }
[10:33:12.300]                     })
[10:33:12.300]                   }
[10:33:12.300]                   ...future.strategy.old <- future::plan("list")
[10:33:12.300]                   options(future.plan = NULL)
[10:33:12.300]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.300]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.300]                 }
[10:33:12.300]                 ...future.workdir <- getwd()
[10:33:12.300]             }
[10:33:12.300]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.300]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.300]         }
[10:33:12.300]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.300]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:12.300]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.300]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.300]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.300]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.300]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.300]             base::names(...future.oldOptions))
[10:33:12.300]     }
[10:33:12.300]     if (FALSE) {
[10:33:12.300]     }
[10:33:12.300]     else {
[10:33:12.300]         if (TRUE) {
[10:33:12.300]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.300]                 open = "w")
[10:33:12.300]         }
[10:33:12.300]         else {
[10:33:12.300]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.300]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.300]         }
[10:33:12.300]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.300]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.300]             base::sink(type = "output", split = FALSE)
[10:33:12.300]             base::close(...future.stdout)
[10:33:12.300]         }, add = TRUE)
[10:33:12.300]     }
[10:33:12.300]     ...future.frame <- base::sys.nframe()
[10:33:12.300]     ...future.conditions <- base::list()
[10:33:12.300]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.300]     if (FALSE) {
[10:33:12.300]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.300]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.300]     }
[10:33:12.300]     ...future.result <- base::tryCatch({
[10:33:12.300]         base::withCallingHandlers({
[10:33:12.300]             ...future.value <- base::withVisible(base::local(1))
[10:33:12.300]             future::FutureResult(value = ...future.value$value, 
[10:33:12.300]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.300]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.300]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.300]                     ...future.globalenv.names))
[10:33:12.300]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.300]         }, condition = base::local({
[10:33:12.300]             c <- base::c
[10:33:12.300]             inherits <- base::inherits
[10:33:12.300]             invokeRestart <- base::invokeRestart
[10:33:12.300]             length <- base::length
[10:33:12.300]             list <- base::list
[10:33:12.300]             seq.int <- base::seq.int
[10:33:12.300]             signalCondition <- base::signalCondition
[10:33:12.300]             sys.calls <- base::sys.calls
[10:33:12.300]             `[[` <- base::`[[`
[10:33:12.300]             `+` <- base::`+`
[10:33:12.300]             `<<-` <- base::`<<-`
[10:33:12.300]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.300]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.300]                   3L)]
[10:33:12.300]             }
[10:33:12.300]             function(cond) {
[10:33:12.300]                 is_error <- inherits(cond, "error")
[10:33:12.300]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.300]                   NULL)
[10:33:12.300]                 if (is_error) {
[10:33:12.300]                   sessionInformation <- function() {
[10:33:12.300]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.300]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.300]                       search = base::search(), system = base::Sys.info())
[10:33:12.300]                   }
[10:33:12.300]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.300]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.300]                     cond$call), session = sessionInformation(), 
[10:33:12.300]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.300]                   signalCondition(cond)
[10:33:12.300]                 }
[10:33:12.300]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.300]                 "immediateCondition"))) {
[10:33:12.300]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.300]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.300]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.300]                   if (TRUE && !signal) {
[10:33:12.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.300]                     {
[10:33:12.300]                       inherits <- base::inherits
[10:33:12.300]                       invokeRestart <- base::invokeRestart
[10:33:12.300]                       is.null <- base::is.null
[10:33:12.300]                       muffled <- FALSE
[10:33:12.300]                       if (inherits(cond, "message")) {
[10:33:12.300]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.300]                         if (muffled) 
[10:33:12.300]                           invokeRestart("muffleMessage")
[10:33:12.300]                       }
[10:33:12.300]                       else if (inherits(cond, "warning")) {
[10:33:12.300]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.300]                         if (muffled) 
[10:33:12.300]                           invokeRestart("muffleWarning")
[10:33:12.300]                       }
[10:33:12.300]                       else if (inherits(cond, "condition")) {
[10:33:12.300]                         if (!is.null(pattern)) {
[10:33:12.300]                           computeRestarts <- base::computeRestarts
[10:33:12.300]                           grepl <- base::grepl
[10:33:12.300]                           restarts <- computeRestarts(cond)
[10:33:12.300]                           for (restart in restarts) {
[10:33:12.300]                             name <- restart$name
[10:33:12.300]                             if (is.null(name)) 
[10:33:12.300]                               next
[10:33:12.300]                             if (!grepl(pattern, name)) 
[10:33:12.300]                               next
[10:33:12.300]                             invokeRestart(restart)
[10:33:12.300]                             muffled <- TRUE
[10:33:12.300]                             break
[10:33:12.300]                           }
[10:33:12.300]                         }
[10:33:12.300]                       }
[10:33:12.300]                       invisible(muffled)
[10:33:12.300]                     }
[10:33:12.300]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.300]                   }
[10:33:12.300]                 }
[10:33:12.300]                 else {
[10:33:12.300]                   if (TRUE) {
[10:33:12.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.300]                     {
[10:33:12.300]                       inherits <- base::inherits
[10:33:12.300]                       invokeRestart <- base::invokeRestart
[10:33:12.300]                       is.null <- base::is.null
[10:33:12.300]                       muffled <- FALSE
[10:33:12.300]                       if (inherits(cond, "message")) {
[10:33:12.300]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.300]                         if (muffled) 
[10:33:12.300]                           invokeRestart("muffleMessage")
[10:33:12.300]                       }
[10:33:12.300]                       else if (inherits(cond, "warning")) {
[10:33:12.300]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.300]                         if (muffled) 
[10:33:12.300]                           invokeRestart("muffleWarning")
[10:33:12.300]                       }
[10:33:12.300]                       else if (inherits(cond, "condition")) {
[10:33:12.300]                         if (!is.null(pattern)) {
[10:33:12.300]                           computeRestarts <- base::computeRestarts
[10:33:12.300]                           grepl <- base::grepl
[10:33:12.300]                           restarts <- computeRestarts(cond)
[10:33:12.300]                           for (restart in restarts) {
[10:33:12.300]                             name <- restart$name
[10:33:12.300]                             if (is.null(name)) 
[10:33:12.300]                               next
[10:33:12.300]                             if (!grepl(pattern, name)) 
[10:33:12.300]                               next
[10:33:12.300]                             invokeRestart(restart)
[10:33:12.300]                             muffled <- TRUE
[10:33:12.300]                             break
[10:33:12.300]                           }
[10:33:12.300]                         }
[10:33:12.300]                       }
[10:33:12.300]                       invisible(muffled)
[10:33:12.300]                     }
[10:33:12.300]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.300]                   }
[10:33:12.300]                 }
[10:33:12.300]             }
[10:33:12.300]         }))
[10:33:12.300]     }, error = function(ex) {
[10:33:12.300]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.300]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.300]                 ...future.rng), started = ...future.startTime, 
[10:33:12.300]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.300]             version = "1.8"), class = "FutureResult")
[10:33:12.300]     }, finally = {
[10:33:12.300]         if (!identical(...future.workdir, getwd())) 
[10:33:12.300]             setwd(...future.workdir)
[10:33:12.300]         {
[10:33:12.300]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.300]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.300]             }
[10:33:12.300]             base::options(...future.oldOptions)
[10:33:12.300]             if (.Platform$OS.type == "windows") {
[10:33:12.300]                 old_names <- names(...future.oldEnvVars)
[10:33:12.300]                 envs <- base::Sys.getenv()
[10:33:12.300]                 names <- names(envs)
[10:33:12.300]                 common <- intersect(names, old_names)
[10:33:12.300]                 added <- setdiff(names, old_names)
[10:33:12.300]                 removed <- setdiff(old_names, names)
[10:33:12.300]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.300]                   envs[common]]
[10:33:12.300]                 NAMES <- toupper(changed)
[10:33:12.300]                 args <- list()
[10:33:12.300]                 for (kk in seq_along(NAMES)) {
[10:33:12.300]                   name <- changed[[kk]]
[10:33:12.300]                   NAME <- NAMES[[kk]]
[10:33:12.300]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.300]                     next
[10:33:12.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.300]                 }
[10:33:12.300]                 NAMES <- toupper(added)
[10:33:12.300]                 for (kk in seq_along(NAMES)) {
[10:33:12.300]                   name <- added[[kk]]
[10:33:12.300]                   NAME <- NAMES[[kk]]
[10:33:12.300]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.300]                     next
[10:33:12.300]                   args[[name]] <- ""
[10:33:12.300]                 }
[10:33:12.300]                 NAMES <- toupper(removed)
[10:33:12.300]                 for (kk in seq_along(NAMES)) {
[10:33:12.300]                   name <- removed[[kk]]
[10:33:12.300]                   NAME <- NAMES[[kk]]
[10:33:12.300]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.300]                     next
[10:33:12.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.300]                 }
[10:33:12.300]                 if (length(args) > 0) 
[10:33:12.300]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.300]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.300]             }
[10:33:12.300]             else {
[10:33:12.300]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.300]             }
[10:33:12.300]             {
[10:33:12.300]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.300]                   0L) {
[10:33:12.300]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.300]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.300]                   base::options(opts)
[10:33:12.300]                 }
[10:33:12.300]                 {
[10:33:12.300]                   {
[10:33:12.300]                     NULL
[10:33:12.300]                     RNGkind("Mersenne-Twister")
[10:33:12.300]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.300]                       inherits = FALSE)
[10:33:12.300]                   }
[10:33:12.300]                   options(future.plan = NULL)
[10:33:12.300]                   if (is.na(NA_character_)) 
[10:33:12.300]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.300]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.300]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.300]                     .init = FALSE)
[10:33:12.300]                 }
[10:33:12.300]             }
[10:33:12.300]         }
[10:33:12.300]     })
[10:33:12.300]     if (TRUE) {
[10:33:12.300]         base::sink(type = "output", split = FALSE)
[10:33:12.300]         if (TRUE) {
[10:33:12.300]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.300]         }
[10:33:12.300]         else {
[10:33:12.300]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.300]         }
[10:33:12.300]         base::close(...future.stdout)
[10:33:12.300]         ...future.stdout <- NULL
[10:33:12.300]     }
[10:33:12.300]     ...future.result$conditions <- ...future.conditions
[10:33:12.300]     ...future.result$finished <- base::Sys.time()
[10:33:12.300]     ...future.result
[10:33:12.300] }
[10:33:12.303] plan(): Setting new future strategy stack:
[10:33:12.303] List of future strategies:
[10:33:12.303] 1. sequential:
[10:33:12.303]    - args: function (..., envir = parent.frame())
[10:33:12.303]    - tweaked: FALSE
[10:33:12.303]    - call: NULL
[10:33:12.304] plan(): nbrOfWorkers() = 1
[10:33:12.304] plan(): Setting new future strategy stack:
[10:33:12.304] List of future strategies:
[10:33:12.304] 1. sequential:
[10:33:12.304]    - args: function (..., envir = parent.frame())
[10:33:12.304]    - tweaked: FALSE
[10:33:12.304]    - call: plan(strategy)
[10:33:12.305] plan(): nbrOfWorkers() = 1
[10:33:12.305] SequentialFuture started (and completed)
[10:33:12.305] - Launch lazy future ... done
[10:33:12.305] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.305] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.306] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:12.306] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:12.306] Searching for globals ... DONE
[10:33:12.306] Resolving globals: TRUE
[10:33:12.307] Resolving any globals that are futures ...
[10:33:12.307] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:12.307] Resolving any globals that are futures ... DONE
[10:33:12.307] Resolving futures part of globals (recursively) ...
[10:33:12.307] resolve() on list ...
[10:33:12.307]  recursive: 99
[10:33:12.307]  length: 1
[10:33:12.307]  elements: ‘a’
[10:33:12.308] resolved() for ‘SequentialFuture’ ...
[10:33:12.308] - state: ‘finished’
[10:33:12.308] - run: TRUE
[10:33:12.308] - result: ‘FutureResult’
[10:33:12.308] resolved() for ‘SequentialFuture’ ... done
[10:33:12.308] Future #1
[10:33:12.308] resolved() for ‘SequentialFuture’ ...
[10:33:12.308] - state: ‘finished’
[10:33:12.308] - run: TRUE
[10:33:12.308] - result: ‘FutureResult’
[10:33:12.309] resolved() for ‘SequentialFuture’ ... done
[10:33:12.309] A SequentialFuture was resolved
[10:33:12.309]  length: 0 (resolved future 1)
[10:33:12.309] resolve() on list ... DONE
[10:33:12.309] - globals: [1] ‘a’
[10:33:12.309] Resolving futures part of globals (recursively) ... DONE
[10:33:12.311] The total size of the 1 globals is 1.55 MiB (1621800 bytes)
[10:33:12.311] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[10:33:12.311] - globals: [1] ‘a’
[10:33:12.311] - packages: [1] ‘future’
[10:33:12.312] getGlobalsAndPackages() ... DONE
[10:33:12.312] run() for ‘Future’ ...
[10:33:12.312] - state: ‘created’
[10:33:12.312] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.312] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.312] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.312]   - Field: ‘label’
[10:33:12.313]   - Field: ‘local’
[10:33:12.313]   - Field: ‘owner’
[10:33:12.313]   - Field: ‘envir’
[10:33:12.313]   - Field: ‘packages’
[10:33:12.313]   - Field: ‘gc’
[10:33:12.313]   - Field: ‘conditions’
[10:33:12.313]   - Field: ‘expr’
[10:33:12.313]   - Field: ‘uuid’
[10:33:12.313]   - Field: ‘seed’
[10:33:12.313]   - Field: ‘version’
[10:33:12.313]   - Field: ‘result’
[10:33:12.313]   - Field: ‘asynchronous’
[10:33:12.314]   - Field: ‘calls’
[10:33:12.314]   - Field: ‘globals’
[10:33:12.314]   - Field: ‘stdout’
[10:33:12.314]   - Field: ‘earlySignal’
[10:33:12.314]   - Field: ‘lazy’
[10:33:12.314]   - Field: ‘state’
[10:33:12.314] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.314] - Launch lazy future ...
[10:33:12.314] Packages needed by the future expression (n = 1): ‘future’
[10:33:12.314] Packages needed by future strategies (n = 0): <none>
[10:33:12.315] {
[10:33:12.315]     {
[10:33:12.315]         {
[10:33:12.315]             ...future.startTime <- base::Sys.time()
[10:33:12.315]             {
[10:33:12.315]                 {
[10:33:12.315]                   {
[10:33:12.315]                     {
[10:33:12.315]                       base::local({
[10:33:12.315]                         has_future <- base::requireNamespace("future", 
[10:33:12.315]                           quietly = TRUE)
[10:33:12.315]                         if (has_future) {
[10:33:12.315]                           ns <- base::getNamespace("future")
[10:33:12.315]                           version <- ns[[".package"]][["version"]]
[10:33:12.315]                           if (is.null(version)) 
[10:33:12.315]                             version <- utils::packageVersion("future")
[10:33:12.315]                         }
[10:33:12.315]                         else {
[10:33:12.315]                           version <- NULL
[10:33:12.315]                         }
[10:33:12.315]                         if (!has_future || version < "1.8.0") {
[10:33:12.315]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.315]                             "", base::R.version$version.string), 
[10:33:12.315]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:12.315]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.315]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.315]                               "release", "version")], collapse = " "), 
[10:33:12.315]                             hostname = base::Sys.info()[["nodename"]])
[10:33:12.315]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.315]                             info)
[10:33:12.315]                           info <- base::paste(info, collapse = "; ")
[10:33:12.315]                           if (!has_future) {
[10:33:12.315]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.315]                               info)
[10:33:12.315]                           }
[10:33:12.315]                           else {
[10:33:12.315]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.315]                               info, version)
[10:33:12.315]                           }
[10:33:12.315]                           base::stop(msg)
[10:33:12.315]                         }
[10:33:12.315]                       })
[10:33:12.315]                     }
[10:33:12.315]                     base::local({
[10:33:12.315]                       for (pkg in "future") {
[10:33:12.315]                         base::loadNamespace(pkg)
[10:33:12.315]                         base::library(pkg, character.only = TRUE)
[10:33:12.315]                       }
[10:33:12.315]                     })
[10:33:12.315]                   }
[10:33:12.315]                   ...future.strategy.old <- future::plan("list")
[10:33:12.315]                   options(future.plan = NULL)
[10:33:12.315]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.315]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.315]                 }
[10:33:12.315]                 ...future.workdir <- getwd()
[10:33:12.315]             }
[10:33:12.315]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.315]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.315]         }
[10:33:12.315]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.315]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:12.315]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.315]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.315]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.315]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.315]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.315]             base::names(...future.oldOptions))
[10:33:12.315]     }
[10:33:12.315]     if (FALSE) {
[10:33:12.315]     }
[10:33:12.315]     else {
[10:33:12.315]         if (TRUE) {
[10:33:12.315]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.315]                 open = "w")
[10:33:12.315]         }
[10:33:12.315]         else {
[10:33:12.315]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.315]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.315]         }
[10:33:12.315]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.315]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.315]             base::sink(type = "output", split = FALSE)
[10:33:12.315]             base::close(...future.stdout)
[10:33:12.315]         }, add = TRUE)
[10:33:12.315]     }
[10:33:12.315]     ...future.frame <- base::sys.nframe()
[10:33:12.315]     ...future.conditions <- base::list()
[10:33:12.315]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.315]     if (FALSE) {
[10:33:12.315]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.315]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.315]     }
[10:33:12.315]     ...future.result <- base::tryCatch({
[10:33:12.315]         base::withCallingHandlers({
[10:33:12.315]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:33:12.315]                 1))
[10:33:12.315]             future::FutureResult(value = ...future.value$value, 
[10:33:12.315]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.315]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.315]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.315]                     ...future.globalenv.names))
[10:33:12.315]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.315]         }, condition = base::local({
[10:33:12.315]             c <- base::c
[10:33:12.315]             inherits <- base::inherits
[10:33:12.315]             invokeRestart <- base::invokeRestart
[10:33:12.315]             length <- base::length
[10:33:12.315]             list <- base::list
[10:33:12.315]             seq.int <- base::seq.int
[10:33:12.315]             signalCondition <- base::signalCondition
[10:33:12.315]             sys.calls <- base::sys.calls
[10:33:12.315]             `[[` <- base::`[[`
[10:33:12.315]             `+` <- base::`+`
[10:33:12.315]             `<<-` <- base::`<<-`
[10:33:12.315]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.315]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.315]                   3L)]
[10:33:12.315]             }
[10:33:12.315]             function(cond) {
[10:33:12.315]                 is_error <- inherits(cond, "error")
[10:33:12.315]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.315]                   NULL)
[10:33:12.315]                 if (is_error) {
[10:33:12.315]                   sessionInformation <- function() {
[10:33:12.315]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.315]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.315]                       search = base::search(), system = base::Sys.info())
[10:33:12.315]                   }
[10:33:12.315]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.315]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.315]                     cond$call), session = sessionInformation(), 
[10:33:12.315]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.315]                   signalCondition(cond)
[10:33:12.315]                 }
[10:33:12.315]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.315]                 "immediateCondition"))) {
[10:33:12.315]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.315]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.315]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.315]                   if (TRUE && !signal) {
[10:33:12.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.315]                     {
[10:33:12.315]                       inherits <- base::inherits
[10:33:12.315]                       invokeRestart <- base::invokeRestart
[10:33:12.315]                       is.null <- base::is.null
[10:33:12.315]                       muffled <- FALSE
[10:33:12.315]                       if (inherits(cond, "message")) {
[10:33:12.315]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.315]                         if (muffled) 
[10:33:12.315]                           invokeRestart("muffleMessage")
[10:33:12.315]                       }
[10:33:12.315]                       else if (inherits(cond, "warning")) {
[10:33:12.315]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.315]                         if (muffled) 
[10:33:12.315]                           invokeRestart("muffleWarning")
[10:33:12.315]                       }
[10:33:12.315]                       else if (inherits(cond, "condition")) {
[10:33:12.315]                         if (!is.null(pattern)) {
[10:33:12.315]                           computeRestarts <- base::computeRestarts
[10:33:12.315]                           grepl <- base::grepl
[10:33:12.315]                           restarts <- computeRestarts(cond)
[10:33:12.315]                           for (restart in restarts) {
[10:33:12.315]                             name <- restart$name
[10:33:12.315]                             if (is.null(name)) 
[10:33:12.315]                               next
[10:33:12.315]                             if (!grepl(pattern, name)) 
[10:33:12.315]                               next
[10:33:12.315]                             invokeRestart(restart)
[10:33:12.315]                             muffled <- TRUE
[10:33:12.315]                             break
[10:33:12.315]                           }
[10:33:12.315]                         }
[10:33:12.315]                       }
[10:33:12.315]                       invisible(muffled)
[10:33:12.315]                     }
[10:33:12.315]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.315]                   }
[10:33:12.315]                 }
[10:33:12.315]                 else {
[10:33:12.315]                   if (TRUE) {
[10:33:12.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.315]                     {
[10:33:12.315]                       inherits <- base::inherits
[10:33:12.315]                       invokeRestart <- base::invokeRestart
[10:33:12.315]                       is.null <- base::is.null
[10:33:12.315]                       muffled <- FALSE
[10:33:12.315]                       if (inherits(cond, "message")) {
[10:33:12.315]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.315]                         if (muffled) 
[10:33:12.315]                           invokeRestart("muffleMessage")
[10:33:12.315]                       }
[10:33:12.315]                       else if (inherits(cond, "warning")) {
[10:33:12.315]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.315]                         if (muffled) 
[10:33:12.315]                           invokeRestart("muffleWarning")
[10:33:12.315]                       }
[10:33:12.315]                       else if (inherits(cond, "condition")) {
[10:33:12.315]                         if (!is.null(pattern)) {
[10:33:12.315]                           computeRestarts <- base::computeRestarts
[10:33:12.315]                           grepl <- base::grepl
[10:33:12.315]                           restarts <- computeRestarts(cond)
[10:33:12.315]                           for (restart in restarts) {
[10:33:12.315]                             name <- restart$name
[10:33:12.315]                             if (is.null(name)) 
[10:33:12.315]                               next
[10:33:12.315]                             if (!grepl(pattern, name)) 
[10:33:12.315]                               next
[10:33:12.315]                             invokeRestart(restart)
[10:33:12.315]                             muffled <- TRUE
[10:33:12.315]                             break
[10:33:12.315]                           }
[10:33:12.315]                         }
[10:33:12.315]                       }
[10:33:12.315]                       invisible(muffled)
[10:33:12.315]                     }
[10:33:12.315]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.315]                   }
[10:33:12.315]                 }
[10:33:12.315]             }
[10:33:12.315]         }))
[10:33:12.315]     }, error = function(ex) {
[10:33:12.315]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.315]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.315]                 ...future.rng), started = ...future.startTime, 
[10:33:12.315]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.315]             version = "1.8"), class = "FutureResult")
[10:33:12.315]     }, finally = {
[10:33:12.315]         if (!identical(...future.workdir, getwd())) 
[10:33:12.315]             setwd(...future.workdir)
[10:33:12.315]         {
[10:33:12.315]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.315]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.315]             }
[10:33:12.315]             base::options(...future.oldOptions)
[10:33:12.315]             if (.Platform$OS.type == "windows") {
[10:33:12.315]                 old_names <- names(...future.oldEnvVars)
[10:33:12.315]                 envs <- base::Sys.getenv()
[10:33:12.315]                 names <- names(envs)
[10:33:12.315]                 common <- intersect(names, old_names)
[10:33:12.315]                 added <- setdiff(names, old_names)
[10:33:12.315]                 removed <- setdiff(old_names, names)
[10:33:12.315]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.315]                   envs[common]]
[10:33:12.315]                 NAMES <- toupper(changed)
[10:33:12.315]                 args <- list()
[10:33:12.315]                 for (kk in seq_along(NAMES)) {
[10:33:12.315]                   name <- changed[[kk]]
[10:33:12.315]                   NAME <- NAMES[[kk]]
[10:33:12.315]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.315]                     next
[10:33:12.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.315]                 }
[10:33:12.315]                 NAMES <- toupper(added)
[10:33:12.315]                 for (kk in seq_along(NAMES)) {
[10:33:12.315]                   name <- added[[kk]]
[10:33:12.315]                   NAME <- NAMES[[kk]]
[10:33:12.315]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.315]                     next
[10:33:12.315]                   args[[name]] <- ""
[10:33:12.315]                 }
[10:33:12.315]                 NAMES <- toupper(removed)
[10:33:12.315]                 for (kk in seq_along(NAMES)) {
[10:33:12.315]                   name <- removed[[kk]]
[10:33:12.315]                   NAME <- NAMES[[kk]]
[10:33:12.315]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.315]                     next
[10:33:12.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.315]                 }
[10:33:12.315]                 if (length(args) > 0) 
[10:33:12.315]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.315]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.315]             }
[10:33:12.315]             else {
[10:33:12.315]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.315]             }
[10:33:12.315]             {
[10:33:12.315]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.315]                   0L) {
[10:33:12.315]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.315]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.315]                   base::options(opts)
[10:33:12.315]                 }
[10:33:12.315]                 {
[10:33:12.315]                   {
[10:33:12.315]                     NULL
[10:33:12.315]                     RNGkind("Mersenne-Twister")
[10:33:12.315]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.315]                       inherits = FALSE)
[10:33:12.315]                   }
[10:33:12.315]                   options(future.plan = NULL)
[10:33:12.315]                   if (is.na(NA_character_)) 
[10:33:12.315]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.315]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.315]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.315]                     .init = FALSE)
[10:33:12.315]                 }
[10:33:12.315]             }
[10:33:12.315]         }
[10:33:12.315]     })
[10:33:12.315]     if (TRUE) {
[10:33:12.315]         base::sink(type = "output", split = FALSE)
[10:33:12.315]         if (TRUE) {
[10:33:12.315]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.315]         }
[10:33:12.315]         else {
[10:33:12.315]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.315]         }
[10:33:12.315]         base::close(...future.stdout)
[10:33:12.315]         ...future.stdout <- NULL
[10:33:12.315]     }
[10:33:12.315]     ...future.result$conditions <- ...future.conditions
[10:33:12.315]     ...future.result$finished <- base::Sys.time()
[10:33:12.315]     ...future.result
[10:33:12.315] }
[10:33:12.317] assign_globals() ...
[10:33:12.317] List of 1
[10:33:12.317]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55aa53575be8> 
[10:33:12.317]  - attr(*, "where")=List of 1
[10:33:12.317]   ..$ a:<environment: R_EmptyEnv> 
[10:33:12.317]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.317]  - attr(*, "resolved")= logi TRUE
[10:33:12.317]  - attr(*, "total_size")= num 1621800
[10:33:12.317]  - attr(*, "already-done")= logi TRUE
[10:33:12.319] - copied ‘a’ to environment
[10:33:12.319] assign_globals() ... done
[10:33:12.319] plan(): Setting new future strategy stack:
[10:33:12.319] List of future strategies:
[10:33:12.319] 1. sequential:
[10:33:12.319]    - args: function (..., envir = parent.frame())
[10:33:12.319]    - tweaked: FALSE
[10:33:12.319]    - call: NULL
[10:33:12.320] plan(): nbrOfWorkers() = 1
[10:33:12.320] plan(): Setting new future strategy stack:
[10:33:12.321] List of future strategies:
[10:33:12.321] 1. sequential:
[10:33:12.321]    - args: function (..., envir = parent.frame())
[10:33:12.321]    - tweaked: FALSE
[10:33:12.321]    - call: plan(strategy)
[10:33:12.321] plan(): nbrOfWorkers() = 1
[10:33:12.321] SequentialFuture started (and completed)
[10:33:12.321] - Launch lazy future ... done
[10:33:12.321] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.322] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.322] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:12.322] 
[10:33:12.322] Searching for globals ... DONE
[10:33:12.322] - globals: [0] <none>
[10:33:12.322] getGlobalsAndPackages() ... DONE
[10:33:12.323] run() for ‘Future’ ...
[10:33:12.323] - state: ‘created’
[10:33:12.323] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.323] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.323] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.323]   - Field: ‘label’
[10:33:12.323]   - Field: ‘local’
[10:33:12.323]   - Field: ‘owner’
[10:33:12.324]   - Field: ‘envir’
[10:33:12.324]   - Field: ‘packages’
[10:33:12.324]   - Field: ‘gc’
[10:33:12.324]   - Field: ‘conditions’
[10:33:12.324]   - Field: ‘expr’
[10:33:12.324]   - Field: ‘uuid’
[10:33:12.324]   - Field: ‘seed’
[10:33:12.324]   - Field: ‘version’
[10:33:12.324]   - Field: ‘result’
[10:33:12.324]   - Field: ‘asynchronous’
[10:33:12.324]   - Field: ‘calls’
[10:33:12.325]   - Field: ‘globals’
[10:33:12.348]   - Field: ‘stdout’
[10:33:12.348]   - Field: ‘earlySignal’
[10:33:12.348]   - Field: ‘lazy’
[10:33:12.348]   - Field: ‘state’
[10:33:12.348] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.348] - Launch lazy future ...
[10:33:12.348] Packages needed by the future expression (n = 0): <none>
[10:33:12.349] Packages needed by future strategies (n = 0): <none>
[10:33:12.349] {
[10:33:12.349]     {
[10:33:12.349]         {
[10:33:12.349]             ...future.startTime <- base::Sys.time()
[10:33:12.349]             {
[10:33:12.349]                 {
[10:33:12.349]                   {
[10:33:12.349]                     base::local({
[10:33:12.349]                       has_future <- base::requireNamespace("future", 
[10:33:12.349]                         quietly = TRUE)
[10:33:12.349]                       if (has_future) {
[10:33:12.349]                         ns <- base::getNamespace("future")
[10:33:12.349]                         version <- ns[[".package"]][["version"]]
[10:33:12.349]                         if (is.null(version)) 
[10:33:12.349]                           version <- utils::packageVersion("future")
[10:33:12.349]                       }
[10:33:12.349]                       else {
[10:33:12.349]                         version <- NULL
[10:33:12.349]                       }
[10:33:12.349]                       if (!has_future || version < "1.8.0") {
[10:33:12.349]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.349]                           "", base::R.version$version.string), 
[10:33:12.349]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.349]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.349]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.349]                             "release", "version")], collapse = " "), 
[10:33:12.349]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.349]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.349]                           info)
[10:33:12.349]                         info <- base::paste(info, collapse = "; ")
[10:33:12.349]                         if (!has_future) {
[10:33:12.349]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.349]                             info)
[10:33:12.349]                         }
[10:33:12.349]                         else {
[10:33:12.349]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.349]                             info, version)
[10:33:12.349]                         }
[10:33:12.349]                         base::stop(msg)
[10:33:12.349]                       }
[10:33:12.349]                     })
[10:33:12.349]                   }
[10:33:12.349]                   ...future.strategy.old <- future::plan("list")
[10:33:12.349]                   options(future.plan = NULL)
[10:33:12.349]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.349]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.349]                 }
[10:33:12.349]                 ...future.workdir <- getwd()
[10:33:12.349]             }
[10:33:12.349]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.349]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.349]         }
[10:33:12.349]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.349]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:12.349]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.349]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.349]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.349]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.349]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.349]             base::names(...future.oldOptions))
[10:33:12.349]     }
[10:33:12.349]     if (FALSE) {
[10:33:12.349]     }
[10:33:12.349]     else {
[10:33:12.349]         if (TRUE) {
[10:33:12.349]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.349]                 open = "w")
[10:33:12.349]         }
[10:33:12.349]         else {
[10:33:12.349]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.349]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.349]         }
[10:33:12.349]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.349]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.349]             base::sink(type = "output", split = FALSE)
[10:33:12.349]             base::close(...future.stdout)
[10:33:12.349]         }, add = TRUE)
[10:33:12.349]     }
[10:33:12.349]     ...future.frame <- base::sys.nframe()
[10:33:12.349]     ...future.conditions <- base::list()
[10:33:12.349]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.349]     if (FALSE) {
[10:33:12.349]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.349]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.349]     }
[10:33:12.349]     ...future.result <- base::tryCatch({
[10:33:12.349]         base::withCallingHandlers({
[10:33:12.349]             ...future.value <- base::withVisible(base::local(1))
[10:33:12.349]             future::FutureResult(value = ...future.value$value, 
[10:33:12.349]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.349]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.349]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.349]                     ...future.globalenv.names))
[10:33:12.349]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.349]         }, condition = base::local({
[10:33:12.349]             c <- base::c
[10:33:12.349]             inherits <- base::inherits
[10:33:12.349]             invokeRestart <- base::invokeRestart
[10:33:12.349]             length <- base::length
[10:33:12.349]             list <- base::list
[10:33:12.349]             seq.int <- base::seq.int
[10:33:12.349]             signalCondition <- base::signalCondition
[10:33:12.349]             sys.calls <- base::sys.calls
[10:33:12.349]             `[[` <- base::`[[`
[10:33:12.349]             `+` <- base::`+`
[10:33:12.349]             `<<-` <- base::`<<-`
[10:33:12.349]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.349]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.349]                   3L)]
[10:33:12.349]             }
[10:33:12.349]             function(cond) {
[10:33:12.349]                 is_error <- inherits(cond, "error")
[10:33:12.349]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.349]                   NULL)
[10:33:12.349]                 if (is_error) {
[10:33:12.349]                   sessionInformation <- function() {
[10:33:12.349]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.349]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.349]                       search = base::search(), system = base::Sys.info())
[10:33:12.349]                   }
[10:33:12.349]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.349]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.349]                     cond$call), session = sessionInformation(), 
[10:33:12.349]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.349]                   signalCondition(cond)
[10:33:12.349]                 }
[10:33:12.349]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.349]                 "immediateCondition"))) {
[10:33:12.349]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.349]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.349]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.349]                   if (TRUE && !signal) {
[10:33:12.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.349]                     {
[10:33:12.349]                       inherits <- base::inherits
[10:33:12.349]                       invokeRestart <- base::invokeRestart
[10:33:12.349]                       is.null <- base::is.null
[10:33:12.349]                       muffled <- FALSE
[10:33:12.349]                       if (inherits(cond, "message")) {
[10:33:12.349]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.349]                         if (muffled) 
[10:33:12.349]                           invokeRestart("muffleMessage")
[10:33:12.349]                       }
[10:33:12.349]                       else if (inherits(cond, "warning")) {
[10:33:12.349]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.349]                         if (muffled) 
[10:33:12.349]                           invokeRestart("muffleWarning")
[10:33:12.349]                       }
[10:33:12.349]                       else if (inherits(cond, "condition")) {
[10:33:12.349]                         if (!is.null(pattern)) {
[10:33:12.349]                           computeRestarts <- base::computeRestarts
[10:33:12.349]                           grepl <- base::grepl
[10:33:12.349]                           restarts <- computeRestarts(cond)
[10:33:12.349]                           for (restart in restarts) {
[10:33:12.349]                             name <- restart$name
[10:33:12.349]                             if (is.null(name)) 
[10:33:12.349]                               next
[10:33:12.349]                             if (!grepl(pattern, name)) 
[10:33:12.349]                               next
[10:33:12.349]                             invokeRestart(restart)
[10:33:12.349]                             muffled <- TRUE
[10:33:12.349]                             break
[10:33:12.349]                           }
[10:33:12.349]                         }
[10:33:12.349]                       }
[10:33:12.349]                       invisible(muffled)
[10:33:12.349]                     }
[10:33:12.349]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.349]                   }
[10:33:12.349]                 }
[10:33:12.349]                 else {
[10:33:12.349]                   if (TRUE) {
[10:33:12.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.349]                     {
[10:33:12.349]                       inherits <- base::inherits
[10:33:12.349]                       invokeRestart <- base::invokeRestart
[10:33:12.349]                       is.null <- base::is.null
[10:33:12.349]                       muffled <- FALSE
[10:33:12.349]                       if (inherits(cond, "message")) {
[10:33:12.349]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.349]                         if (muffled) 
[10:33:12.349]                           invokeRestart("muffleMessage")
[10:33:12.349]                       }
[10:33:12.349]                       else if (inherits(cond, "warning")) {
[10:33:12.349]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.349]                         if (muffled) 
[10:33:12.349]                           invokeRestart("muffleWarning")
[10:33:12.349]                       }
[10:33:12.349]                       else if (inherits(cond, "condition")) {
[10:33:12.349]                         if (!is.null(pattern)) {
[10:33:12.349]                           computeRestarts <- base::computeRestarts
[10:33:12.349]                           grepl <- base::grepl
[10:33:12.349]                           restarts <- computeRestarts(cond)
[10:33:12.349]                           for (restart in restarts) {
[10:33:12.349]                             name <- restart$name
[10:33:12.349]                             if (is.null(name)) 
[10:33:12.349]                               next
[10:33:12.349]                             if (!grepl(pattern, name)) 
[10:33:12.349]                               next
[10:33:12.349]                             invokeRestart(restart)
[10:33:12.349]                             muffled <- TRUE
[10:33:12.349]                             break
[10:33:12.349]                           }
[10:33:12.349]                         }
[10:33:12.349]                       }
[10:33:12.349]                       invisible(muffled)
[10:33:12.349]                     }
[10:33:12.349]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.349]                   }
[10:33:12.349]                 }
[10:33:12.349]             }
[10:33:12.349]         }))
[10:33:12.349]     }, error = function(ex) {
[10:33:12.349]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.349]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.349]                 ...future.rng), started = ...future.startTime, 
[10:33:12.349]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.349]             version = "1.8"), class = "FutureResult")
[10:33:12.349]     }, finally = {
[10:33:12.349]         if (!identical(...future.workdir, getwd())) 
[10:33:12.349]             setwd(...future.workdir)
[10:33:12.349]         {
[10:33:12.349]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.349]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.349]             }
[10:33:12.349]             base::options(...future.oldOptions)
[10:33:12.349]             if (.Platform$OS.type == "windows") {
[10:33:12.349]                 old_names <- names(...future.oldEnvVars)
[10:33:12.349]                 envs <- base::Sys.getenv()
[10:33:12.349]                 names <- names(envs)
[10:33:12.349]                 common <- intersect(names, old_names)
[10:33:12.349]                 added <- setdiff(names, old_names)
[10:33:12.349]                 removed <- setdiff(old_names, names)
[10:33:12.349]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.349]                   envs[common]]
[10:33:12.349]                 NAMES <- toupper(changed)
[10:33:12.349]                 args <- list()
[10:33:12.349]                 for (kk in seq_along(NAMES)) {
[10:33:12.349]                   name <- changed[[kk]]
[10:33:12.349]                   NAME <- NAMES[[kk]]
[10:33:12.349]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.349]                     next
[10:33:12.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.349]                 }
[10:33:12.349]                 NAMES <- toupper(added)
[10:33:12.349]                 for (kk in seq_along(NAMES)) {
[10:33:12.349]                   name <- added[[kk]]
[10:33:12.349]                   NAME <- NAMES[[kk]]
[10:33:12.349]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.349]                     next
[10:33:12.349]                   args[[name]] <- ""
[10:33:12.349]                 }
[10:33:12.349]                 NAMES <- toupper(removed)
[10:33:12.349]                 for (kk in seq_along(NAMES)) {
[10:33:12.349]                   name <- removed[[kk]]
[10:33:12.349]                   NAME <- NAMES[[kk]]
[10:33:12.349]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.349]                     next
[10:33:12.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.349]                 }
[10:33:12.349]                 if (length(args) > 0) 
[10:33:12.349]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.349]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.349]             }
[10:33:12.349]             else {
[10:33:12.349]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.349]             }
[10:33:12.349]             {
[10:33:12.349]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.349]                   0L) {
[10:33:12.349]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.349]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.349]                   base::options(opts)
[10:33:12.349]                 }
[10:33:12.349]                 {
[10:33:12.349]                   {
[10:33:12.349]                     NULL
[10:33:12.349]                     RNGkind("Mersenne-Twister")
[10:33:12.349]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.349]                       inherits = FALSE)
[10:33:12.349]                   }
[10:33:12.349]                   options(future.plan = NULL)
[10:33:12.349]                   if (is.na(NA_character_)) 
[10:33:12.349]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.349]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.349]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.349]                     .init = FALSE)
[10:33:12.349]                 }
[10:33:12.349]             }
[10:33:12.349]         }
[10:33:12.349]     })
[10:33:12.349]     if (TRUE) {
[10:33:12.349]         base::sink(type = "output", split = FALSE)
[10:33:12.349]         if (TRUE) {
[10:33:12.349]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.349]         }
[10:33:12.349]         else {
[10:33:12.349]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.349]         }
[10:33:12.349]         base::close(...future.stdout)
[10:33:12.349]         ...future.stdout <- NULL
[10:33:12.349]     }
[10:33:12.349]     ...future.result$conditions <- ...future.conditions
[10:33:12.349]     ...future.result$finished <- base::Sys.time()
[10:33:12.349]     ...future.result
[10:33:12.349] }
[10:33:12.351] plan(): Setting new future strategy stack:
[10:33:12.351] List of future strategies:
[10:33:12.351] 1. sequential:
[10:33:12.351]    - args: function (..., envir = parent.frame())
[10:33:12.351]    - tweaked: FALSE
[10:33:12.351]    - call: NULL
[10:33:12.351] plan(): nbrOfWorkers() = 1
[10:33:12.352] plan(): Setting new future strategy stack:
[10:33:12.352] List of future strategies:
[10:33:12.352] 1. sequential:
[10:33:12.352]    - args: function (..., envir = parent.frame())
[10:33:12.352]    - tweaked: FALSE
[10:33:12.352]    - call: plan(strategy)
[10:33:12.352] plan(): nbrOfWorkers() = 1
[10:33:12.353] SequentialFuture started (and completed)
[10:33:12.353] - Launch lazy future ... done
[10:33:12.353] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.353] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.353] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:12.354] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:12.354] Searching for globals ... DONE
[10:33:12.354] Resolving globals: TRUE
[10:33:12.354] Resolving any globals that are futures ...
[10:33:12.354] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:12.354] Resolving any globals that are futures ... DONE
[10:33:12.355] Resolving futures part of globals (recursively) ...
[10:33:12.355] resolve() on list ...
[10:33:12.355]  recursive: 99
[10:33:12.355]  length: 1
[10:33:12.355]  elements: ‘a’
[10:33:12.355] resolved() for ‘SequentialFuture’ ...
[10:33:12.355] - state: ‘finished’
[10:33:12.355] - run: TRUE
[10:33:12.355] - result: ‘FutureResult’
[10:33:12.356] resolved() for ‘SequentialFuture’ ... done
[10:33:12.356] Future #1
[10:33:12.356] resolved() for ‘SequentialFuture’ ...
[10:33:12.356] - state: ‘finished’
[10:33:12.356] - run: TRUE
[10:33:12.356] - result: ‘FutureResult’
[10:33:12.356] resolved() for ‘SequentialFuture’ ... done
[10:33:12.356] A SequentialFuture was resolved
[10:33:12.356]  length: 0 (resolved future 1)
[10:33:12.356] resolve() on list ... DONE
[10:33:12.357] - globals: [1] ‘a’
[10:33:12.357] Resolving futures part of globals (recursively) ... DONE
[10:33:12.358] The total size of the 1 globals is 1.55 MiB (1621800 bytes)
[10:33:12.359] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[10:33:12.359] - globals: [1] ‘a’
[10:33:12.359] - packages: [1] ‘future’
[10:33:12.359] getGlobalsAndPackages() ... DONE
[10:33:12.359] run() for ‘Future’ ...
[10:33:12.359] - state: ‘created’
[10:33:12.359] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.360] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.360] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.360]   - Field: ‘label’
[10:33:12.360]   - Field: ‘local’
[10:33:12.360]   - Field: ‘owner’
[10:33:12.360]   - Field: ‘envir’
[10:33:12.360]   - Field: ‘packages’
[10:33:12.360]   - Field: ‘gc’
[10:33:12.360]   - Field: ‘conditions’
[10:33:12.361]   - Field: ‘expr’
[10:33:12.361]   - Field: ‘uuid’
[10:33:12.361]   - Field: ‘seed’
[10:33:12.361]   - Field: ‘version’
[10:33:12.361]   - Field: ‘result’
[10:33:12.361]   - Field: ‘asynchronous’
[10:33:12.361]   - Field: ‘calls’
[10:33:12.361]   - Field: ‘globals’
[10:33:12.361]   - Field: ‘stdout’
[10:33:12.361]   - Field: ‘earlySignal’
[10:33:12.361]   - Field: ‘lazy’
[10:33:12.362]   - Field: ‘state’
[10:33:12.362] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.362] - Launch lazy future ...
[10:33:12.362] Packages needed by the future expression (n = 1): ‘future’
[10:33:12.362] Packages needed by future strategies (n = 0): <none>
[10:33:12.362] {
[10:33:12.362]     {
[10:33:12.362]         {
[10:33:12.362]             ...future.startTime <- base::Sys.time()
[10:33:12.362]             {
[10:33:12.362]                 {
[10:33:12.362]                   {
[10:33:12.362]                     {
[10:33:12.362]                       base::local({
[10:33:12.362]                         has_future <- base::requireNamespace("future", 
[10:33:12.362]                           quietly = TRUE)
[10:33:12.362]                         if (has_future) {
[10:33:12.362]                           ns <- base::getNamespace("future")
[10:33:12.362]                           version <- ns[[".package"]][["version"]]
[10:33:12.362]                           if (is.null(version)) 
[10:33:12.362]                             version <- utils::packageVersion("future")
[10:33:12.362]                         }
[10:33:12.362]                         else {
[10:33:12.362]                           version <- NULL
[10:33:12.362]                         }
[10:33:12.362]                         if (!has_future || version < "1.8.0") {
[10:33:12.362]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.362]                             "", base::R.version$version.string), 
[10:33:12.362]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:12.362]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.362]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.362]                               "release", "version")], collapse = " "), 
[10:33:12.362]                             hostname = base::Sys.info()[["nodename"]])
[10:33:12.362]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.362]                             info)
[10:33:12.362]                           info <- base::paste(info, collapse = "; ")
[10:33:12.362]                           if (!has_future) {
[10:33:12.362]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.362]                               info)
[10:33:12.362]                           }
[10:33:12.362]                           else {
[10:33:12.362]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.362]                               info, version)
[10:33:12.362]                           }
[10:33:12.362]                           base::stop(msg)
[10:33:12.362]                         }
[10:33:12.362]                       })
[10:33:12.362]                     }
[10:33:12.362]                     base::local({
[10:33:12.362]                       for (pkg in "future") {
[10:33:12.362]                         base::loadNamespace(pkg)
[10:33:12.362]                         base::library(pkg, character.only = TRUE)
[10:33:12.362]                       }
[10:33:12.362]                     })
[10:33:12.362]                   }
[10:33:12.362]                   ...future.strategy.old <- future::plan("list")
[10:33:12.362]                   options(future.plan = NULL)
[10:33:12.362]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.362]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.362]                 }
[10:33:12.362]                 ...future.workdir <- getwd()
[10:33:12.362]             }
[10:33:12.362]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.362]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.362]         }
[10:33:12.362]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.362]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:12.362]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.362]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.362]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.362]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.362]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.362]             base::names(...future.oldOptions))
[10:33:12.362]     }
[10:33:12.362]     if (FALSE) {
[10:33:12.362]     }
[10:33:12.362]     else {
[10:33:12.362]         if (TRUE) {
[10:33:12.362]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.362]                 open = "w")
[10:33:12.362]         }
[10:33:12.362]         else {
[10:33:12.362]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.362]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.362]         }
[10:33:12.362]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.362]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.362]             base::sink(type = "output", split = FALSE)
[10:33:12.362]             base::close(...future.stdout)
[10:33:12.362]         }, add = TRUE)
[10:33:12.362]     }
[10:33:12.362]     ...future.frame <- base::sys.nframe()
[10:33:12.362]     ...future.conditions <- base::list()
[10:33:12.362]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.362]     if (FALSE) {
[10:33:12.362]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.362]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.362]     }
[10:33:12.362]     ...future.result <- base::tryCatch({
[10:33:12.362]         base::withCallingHandlers({
[10:33:12.362]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:33:12.362]                 1))
[10:33:12.362]             future::FutureResult(value = ...future.value$value, 
[10:33:12.362]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.362]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.362]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.362]                     ...future.globalenv.names))
[10:33:12.362]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.362]         }, condition = base::local({
[10:33:12.362]             c <- base::c
[10:33:12.362]             inherits <- base::inherits
[10:33:12.362]             invokeRestart <- base::invokeRestart
[10:33:12.362]             length <- base::length
[10:33:12.362]             list <- base::list
[10:33:12.362]             seq.int <- base::seq.int
[10:33:12.362]             signalCondition <- base::signalCondition
[10:33:12.362]             sys.calls <- base::sys.calls
[10:33:12.362]             `[[` <- base::`[[`
[10:33:12.362]             `+` <- base::`+`
[10:33:12.362]             `<<-` <- base::`<<-`
[10:33:12.362]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.362]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.362]                   3L)]
[10:33:12.362]             }
[10:33:12.362]             function(cond) {
[10:33:12.362]                 is_error <- inherits(cond, "error")
[10:33:12.362]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.362]                   NULL)
[10:33:12.362]                 if (is_error) {
[10:33:12.362]                   sessionInformation <- function() {
[10:33:12.362]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.362]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.362]                       search = base::search(), system = base::Sys.info())
[10:33:12.362]                   }
[10:33:12.362]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.362]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.362]                     cond$call), session = sessionInformation(), 
[10:33:12.362]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.362]                   signalCondition(cond)
[10:33:12.362]                 }
[10:33:12.362]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.362]                 "immediateCondition"))) {
[10:33:12.362]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.362]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.362]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.362]                   if (TRUE && !signal) {
[10:33:12.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.362]                     {
[10:33:12.362]                       inherits <- base::inherits
[10:33:12.362]                       invokeRestart <- base::invokeRestart
[10:33:12.362]                       is.null <- base::is.null
[10:33:12.362]                       muffled <- FALSE
[10:33:12.362]                       if (inherits(cond, "message")) {
[10:33:12.362]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.362]                         if (muffled) 
[10:33:12.362]                           invokeRestart("muffleMessage")
[10:33:12.362]                       }
[10:33:12.362]                       else if (inherits(cond, "warning")) {
[10:33:12.362]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.362]                         if (muffled) 
[10:33:12.362]                           invokeRestart("muffleWarning")
[10:33:12.362]                       }
[10:33:12.362]                       else if (inherits(cond, "condition")) {
[10:33:12.362]                         if (!is.null(pattern)) {
[10:33:12.362]                           computeRestarts <- base::computeRestarts
[10:33:12.362]                           grepl <- base::grepl
[10:33:12.362]                           restarts <- computeRestarts(cond)
[10:33:12.362]                           for (restart in restarts) {
[10:33:12.362]                             name <- restart$name
[10:33:12.362]                             if (is.null(name)) 
[10:33:12.362]                               next
[10:33:12.362]                             if (!grepl(pattern, name)) 
[10:33:12.362]                               next
[10:33:12.362]                             invokeRestart(restart)
[10:33:12.362]                             muffled <- TRUE
[10:33:12.362]                             break
[10:33:12.362]                           }
[10:33:12.362]                         }
[10:33:12.362]                       }
[10:33:12.362]                       invisible(muffled)
[10:33:12.362]                     }
[10:33:12.362]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.362]                   }
[10:33:12.362]                 }
[10:33:12.362]                 else {
[10:33:12.362]                   if (TRUE) {
[10:33:12.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.362]                     {
[10:33:12.362]                       inherits <- base::inherits
[10:33:12.362]                       invokeRestart <- base::invokeRestart
[10:33:12.362]                       is.null <- base::is.null
[10:33:12.362]                       muffled <- FALSE
[10:33:12.362]                       if (inherits(cond, "message")) {
[10:33:12.362]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.362]                         if (muffled) 
[10:33:12.362]                           invokeRestart("muffleMessage")
[10:33:12.362]                       }
[10:33:12.362]                       else if (inherits(cond, "warning")) {
[10:33:12.362]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.362]                         if (muffled) 
[10:33:12.362]                           invokeRestart("muffleWarning")
[10:33:12.362]                       }
[10:33:12.362]                       else if (inherits(cond, "condition")) {
[10:33:12.362]                         if (!is.null(pattern)) {
[10:33:12.362]                           computeRestarts <- base::computeRestarts
[10:33:12.362]                           grepl <- base::grepl
[10:33:12.362]                           restarts <- computeRestarts(cond)
[10:33:12.362]                           for (restart in restarts) {
[10:33:12.362]                             name <- restart$name
[10:33:12.362]                             if (is.null(name)) 
[10:33:12.362]                               next
[10:33:12.362]                             if (!grepl(pattern, name)) 
[10:33:12.362]                               next
[10:33:12.362]                             invokeRestart(restart)
[10:33:12.362]                             muffled <- TRUE
[10:33:12.362]                             break
[10:33:12.362]                           }
[10:33:12.362]                         }
[10:33:12.362]                       }
[10:33:12.362]                       invisible(muffled)
[10:33:12.362]                     }
[10:33:12.362]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.362]                   }
[10:33:12.362]                 }
[10:33:12.362]             }
[10:33:12.362]         }))
[10:33:12.362]     }, error = function(ex) {
[10:33:12.362]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.362]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.362]                 ...future.rng), started = ...future.startTime, 
[10:33:12.362]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.362]             version = "1.8"), class = "FutureResult")
[10:33:12.362]     }, finally = {
[10:33:12.362]         if (!identical(...future.workdir, getwd())) 
[10:33:12.362]             setwd(...future.workdir)
[10:33:12.362]         {
[10:33:12.362]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.362]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.362]             }
[10:33:12.362]             base::options(...future.oldOptions)
[10:33:12.362]             if (.Platform$OS.type == "windows") {
[10:33:12.362]                 old_names <- names(...future.oldEnvVars)
[10:33:12.362]                 envs <- base::Sys.getenv()
[10:33:12.362]                 names <- names(envs)
[10:33:12.362]                 common <- intersect(names, old_names)
[10:33:12.362]                 added <- setdiff(names, old_names)
[10:33:12.362]                 removed <- setdiff(old_names, names)
[10:33:12.362]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.362]                   envs[common]]
[10:33:12.362]                 NAMES <- toupper(changed)
[10:33:12.362]                 args <- list()
[10:33:12.362]                 for (kk in seq_along(NAMES)) {
[10:33:12.362]                   name <- changed[[kk]]
[10:33:12.362]                   NAME <- NAMES[[kk]]
[10:33:12.362]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.362]                     next
[10:33:12.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.362]                 }
[10:33:12.362]                 NAMES <- toupper(added)
[10:33:12.362]                 for (kk in seq_along(NAMES)) {
[10:33:12.362]                   name <- added[[kk]]
[10:33:12.362]                   NAME <- NAMES[[kk]]
[10:33:12.362]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.362]                     next
[10:33:12.362]                   args[[name]] <- ""
[10:33:12.362]                 }
[10:33:12.362]                 NAMES <- toupper(removed)
[10:33:12.362]                 for (kk in seq_along(NAMES)) {
[10:33:12.362]                   name <- removed[[kk]]
[10:33:12.362]                   NAME <- NAMES[[kk]]
[10:33:12.362]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.362]                     next
[10:33:12.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.362]                 }
[10:33:12.362]                 if (length(args) > 0) 
[10:33:12.362]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.362]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.362]             }
[10:33:12.362]             else {
[10:33:12.362]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.362]             }
[10:33:12.362]             {
[10:33:12.362]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.362]                   0L) {
[10:33:12.362]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.362]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.362]                   base::options(opts)
[10:33:12.362]                 }
[10:33:12.362]                 {
[10:33:12.362]                   {
[10:33:12.362]                     NULL
[10:33:12.362]                     RNGkind("Mersenne-Twister")
[10:33:12.362]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.362]                       inherits = FALSE)
[10:33:12.362]                   }
[10:33:12.362]                   options(future.plan = NULL)
[10:33:12.362]                   if (is.na(NA_character_)) 
[10:33:12.362]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.362]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.362]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.362]                     .init = FALSE)
[10:33:12.362]                 }
[10:33:12.362]             }
[10:33:12.362]         }
[10:33:12.362]     })
[10:33:12.362]     if (TRUE) {
[10:33:12.362]         base::sink(type = "output", split = FALSE)
[10:33:12.362]         if (TRUE) {
[10:33:12.362]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.362]         }
[10:33:12.362]         else {
[10:33:12.362]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.362]         }
[10:33:12.362]         base::close(...future.stdout)
[10:33:12.362]         ...future.stdout <- NULL
[10:33:12.362]     }
[10:33:12.362]     ...future.result$conditions <- ...future.conditions
[10:33:12.362]     ...future.result$finished <- base::Sys.time()
[10:33:12.362]     ...future.result
[10:33:12.362] }
[10:33:12.364] assign_globals() ...
[10:33:12.364] List of 1
[10:33:12.364]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55aa5366fe40> 
[10:33:12.364]  - attr(*, "where")=List of 1
[10:33:12.364]   ..$ a:<environment: R_EmptyEnv> 
[10:33:12.364]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.364]  - attr(*, "resolved")= logi TRUE
[10:33:12.364]  - attr(*, "total_size")= num 1621800
[10:33:12.364]  - attr(*, "already-done")= logi TRUE
[10:33:12.366] - copied ‘a’ to environment
[10:33:12.367] assign_globals() ... done
[10:33:12.367] plan(): Setting new future strategy stack:
[10:33:12.367] List of future strategies:
[10:33:12.367] 1. sequential:
[10:33:12.367]    - args: function (..., envir = parent.frame())
[10:33:12.367]    - tweaked: FALSE
[10:33:12.367]    - call: NULL
[10:33:12.367] plan(): nbrOfWorkers() = 1
[10:33:12.368] plan(): Setting new future strategy stack:
[10:33:12.368] List of future strategies:
[10:33:12.368] 1. sequential:
[10:33:12.368]    - args: function (..., envir = parent.frame())
[10:33:12.368]    - tweaked: FALSE
[10:33:12.368]    - call: plan(strategy)
[10:33:12.369] plan(): nbrOfWorkers() = 1
[10:33:12.369] SequentialFuture started (and completed)
[10:33:12.369] - Launch lazy future ... done
[10:33:12.369] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.369] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.369] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:12.370] 
[10:33:12.370] Searching for globals ... DONE
[10:33:12.370] - globals: [0] <none>
[10:33:12.370] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.370] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.371] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:12.371] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:12.371] Searching for globals ... DONE
[10:33:12.371] Resolving globals: TRUE
[10:33:12.372] Resolving any globals that are futures ...
[10:33:12.372] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:12.372] Resolving any globals that are futures ... DONE
[10:33:12.372] Resolving futures part of globals (recursively) ...
[10:33:12.372] resolve() on list ...
[10:33:12.372]  recursive: 99
[10:33:12.372]  length: 1
[10:33:12.372]  elements: ‘a’
[10:33:12.373] run() for ‘Future’ ...
[10:33:12.373] - state: ‘created’
[10:33:12.373] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.373] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.373] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.373]   - Field: ‘label’
[10:33:12.373]   - Field: ‘local’
[10:33:12.374]   - Field: ‘owner’
[10:33:12.374]   - Field: ‘envir’
[10:33:12.374]   - Field: ‘packages’
[10:33:12.374]   - Field: ‘gc’
[10:33:12.374]   - Field: ‘conditions’
[10:33:12.374]   - Field: ‘expr’
[10:33:12.374]   - Field: ‘uuid’
[10:33:12.374]   - Field: ‘seed’
[10:33:12.375]   - Field: ‘version’
[10:33:12.375]   - Field: ‘result’
[10:33:12.375]   - Field: ‘asynchronous’
[10:33:12.375]   - Field: ‘calls’
[10:33:12.376]   - Field: ‘globals’
[10:33:12.376]   - Field: ‘stdout’
[10:33:12.376]   - Field: ‘earlySignal’
[10:33:12.376]   - Field: ‘lazy’
[10:33:12.376]   - Field: ‘state’
[10:33:12.376] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.376] - Launch lazy future ...
[10:33:12.376] Packages needed by the future expression (n = 0): <none>
[10:33:12.376] Packages needed by future strategies (n = 0): <none>
[10:33:12.377] {
[10:33:12.377]     {
[10:33:12.377]         {
[10:33:12.377]             ...future.startTime <- base::Sys.time()
[10:33:12.377]             {
[10:33:12.377]                 {
[10:33:12.377]                   {
[10:33:12.377]                     base::local({
[10:33:12.377]                       has_future <- base::requireNamespace("future", 
[10:33:12.377]                         quietly = TRUE)
[10:33:12.377]                       if (has_future) {
[10:33:12.377]                         ns <- base::getNamespace("future")
[10:33:12.377]                         version <- ns[[".package"]][["version"]]
[10:33:12.377]                         if (is.null(version)) 
[10:33:12.377]                           version <- utils::packageVersion("future")
[10:33:12.377]                       }
[10:33:12.377]                       else {
[10:33:12.377]                         version <- NULL
[10:33:12.377]                       }
[10:33:12.377]                       if (!has_future || version < "1.8.0") {
[10:33:12.377]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.377]                           "", base::R.version$version.string), 
[10:33:12.377]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.377]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.377]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.377]                             "release", "version")], collapse = " "), 
[10:33:12.377]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.377]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.377]                           info)
[10:33:12.377]                         info <- base::paste(info, collapse = "; ")
[10:33:12.377]                         if (!has_future) {
[10:33:12.377]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.377]                             info)
[10:33:12.377]                         }
[10:33:12.377]                         else {
[10:33:12.377]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.377]                             info, version)
[10:33:12.377]                         }
[10:33:12.377]                         base::stop(msg)
[10:33:12.377]                       }
[10:33:12.377]                     })
[10:33:12.377]                   }
[10:33:12.377]                   ...future.strategy.old <- future::plan("list")
[10:33:12.377]                   options(future.plan = NULL)
[10:33:12.377]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.377]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.377]                 }
[10:33:12.377]                 ...future.workdir <- getwd()
[10:33:12.377]             }
[10:33:12.377]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.377]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.377]         }
[10:33:12.377]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.377]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:12.377]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.377]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.377]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.377]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.377]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.377]             base::names(...future.oldOptions))
[10:33:12.377]     }
[10:33:12.377]     if (FALSE) {
[10:33:12.377]     }
[10:33:12.377]     else {
[10:33:12.377]         if (TRUE) {
[10:33:12.377]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.377]                 open = "w")
[10:33:12.377]         }
[10:33:12.377]         else {
[10:33:12.377]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.377]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.377]         }
[10:33:12.377]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.377]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.377]             base::sink(type = "output", split = FALSE)
[10:33:12.377]             base::close(...future.stdout)
[10:33:12.377]         }, add = TRUE)
[10:33:12.377]     }
[10:33:12.377]     ...future.frame <- base::sys.nframe()
[10:33:12.377]     ...future.conditions <- base::list()
[10:33:12.377]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.377]     if (FALSE) {
[10:33:12.377]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.377]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.377]     }
[10:33:12.377]     ...future.result <- base::tryCatch({
[10:33:12.377]         base::withCallingHandlers({
[10:33:12.377]             ...future.value <- base::withVisible(base::local(1))
[10:33:12.377]             future::FutureResult(value = ...future.value$value, 
[10:33:12.377]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.377]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.377]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.377]                     ...future.globalenv.names))
[10:33:12.377]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.377]         }, condition = base::local({
[10:33:12.377]             c <- base::c
[10:33:12.377]             inherits <- base::inherits
[10:33:12.377]             invokeRestart <- base::invokeRestart
[10:33:12.377]             length <- base::length
[10:33:12.377]             list <- base::list
[10:33:12.377]             seq.int <- base::seq.int
[10:33:12.377]             signalCondition <- base::signalCondition
[10:33:12.377]             sys.calls <- base::sys.calls
[10:33:12.377]             `[[` <- base::`[[`
[10:33:12.377]             `+` <- base::`+`
[10:33:12.377]             `<<-` <- base::`<<-`
[10:33:12.377]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.377]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.377]                   3L)]
[10:33:12.377]             }
[10:33:12.377]             function(cond) {
[10:33:12.377]                 is_error <- inherits(cond, "error")
[10:33:12.377]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.377]                   NULL)
[10:33:12.377]                 if (is_error) {
[10:33:12.377]                   sessionInformation <- function() {
[10:33:12.377]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.377]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.377]                       search = base::search(), system = base::Sys.info())
[10:33:12.377]                   }
[10:33:12.377]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.377]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.377]                     cond$call), session = sessionInformation(), 
[10:33:12.377]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.377]                   signalCondition(cond)
[10:33:12.377]                 }
[10:33:12.377]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.377]                 "immediateCondition"))) {
[10:33:12.377]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.377]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.377]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.377]                   if (TRUE && !signal) {
[10:33:12.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.377]                     {
[10:33:12.377]                       inherits <- base::inherits
[10:33:12.377]                       invokeRestart <- base::invokeRestart
[10:33:12.377]                       is.null <- base::is.null
[10:33:12.377]                       muffled <- FALSE
[10:33:12.377]                       if (inherits(cond, "message")) {
[10:33:12.377]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.377]                         if (muffled) 
[10:33:12.377]                           invokeRestart("muffleMessage")
[10:33:12.377]                       }
[10:33:12.377]                       else if (inherits(cond, "warning")) {
[10:33:12.377]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.377]                         if (muffled) 
[10:33:12.377]                           invokeRestart("muffleWarning")
[10:33:12.377]                       }
[10:33:12.377]                       else if (inherits(cond, "condition")) {
[10:33:12.377]                         if (!is.null(pattern)) {
[10:33:12.377]                           computeRestarts <- base::computeRestarts
[10:33:12.377]                           grepl <- base::grepl
[10:33:12.377]                           restarts <- computeRestarts(cond)
[10:33:12.377]                           for (restart in restarts) {
[10:33:12.377]                             name <- restart$name
[10:33:12.377]                             if (is.null(name)) 
[10:33:12.377]                               next
[10:33:12.377]                             if (!grepl(pattern, name)) 
[10:33:12.377]                               next
[10:33:12.377]                             invokeRestart(restart)
[10:33:12.377]                             muffled <- TRUE
[10:33:12.377]                             break
[10:33:12.377]                           }
[10:33:12.377]                         }
[10:33:12.377]                       }
[10:33:12.377]                       invisible(muffled)
[10:33:12.377]                     }
[10:33:12.377]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.377]                   }
[10:33:12.377]                 }
[10:33:12.377]                 else {
[10:33:12.377]                   if (TRUE) {
[10:33:12.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.377]                     {
[10:33:12.377]                       inherits <- base::inherits
[10:33:12.377]                       invokeRestart <- base::invokeRestart
[10:33:12.377]                       is.null <- base::is.null
[10:33:12.377]                       muffled <- FALSE
[10:33:12.377]                       if (inherits(cond, "message")) {
[10:33:12.377]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.377]                         if (muffled) 
[10:33:12.377]                           invokeRestart("muffleMessage")
[10:33:12.377]                       }
[10:33:12.377]                       else if (inherits(cond, "warning")) {
[10:33:12.377]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.377]                         if (muffled) 
[10:33:12.377]                           invokeRestart("muffleWarning")
[10:33:12.377]                       }
[10:33:12.377]                       else if (inherits(cond, "condition")) {
[10:33:12.377]                         if (!is.null(pattern)) {
[10:33:12.377]                           computeRestarts <- base::computeRestarts
[10:33:12.377]                           grepl <- base::grepl
[10:33:12.377]                           restarts <- computeRestarts(cond)
[10:33:12.377]                           for (restart in restarts) {
[10:33:12.377]                             name <- restart$name
[10:33:12.377]                             if (is.null(name)) 
[10:33:12.377]                               next
[10:33:12.377]                             if (!grepl(pattern, name)) 
[10:33:12.377]                               next
[10:33:12.377]                             invokeRestart(restart)
[10:33:12.377]                             muffled <- TRUE
[10:33:12.377]                             break
[10:33:12.377]                           }
[10:33:12.377]                         }
[10:33:12.377]                       }
[10:33:12.377]                       invisible(muffled)
[10:33:12.377]                     }
[10:33:12.377]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.377]                   }
[10:33:12.377]                 }
[10:33:12.377]             }
[10:33:12.377]         }))
[10:33:12.377]     }, error = function(ex) {
[10:33:12.377]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.377]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.377]                 ...future.rng), started = ...future.startTime, 
[10:33:12.377]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.377]             version = "1.8"), class = "FutureResult")
[10:33:12.377]     }, finally = {
[10:33:12.377]         if (!identical(...future.workdir, getwd())) 
[10:33:12.377]             setwd(...future.workdir)
[10:33:12.377]         {
[10:33:12.377]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.377]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.377]             }
[10:33:12.377]             base::options(...future.oldOptions)
[10:33:12.377]             if (.Platform$OS.type == "windows") {
[10:33:12.377]                 old_names <- names(...future.oldEnvVars)
[10:33:12.377]                 envs <- base::Sys.getenv()
[10:33:12.377]                 names <- names(envs)
[10:33:12.377]                 common <- intersect(names, old_names)
[10:33:12.377]                 added <- setdiff(names, old_names)
[10:33:12.377]                 removed <- setdiff(old_names, names)
[10:33:12.377]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.377]                   envs[common]]
[10:33:12.377]                 NAMES <- toupper(changed)
[10:33:12.377]                 args <- list()
[10:33:12.377]                 for (kk in seq_along(NAMES)) {
[10:33:12.377]                   name <- changed[[kk]]
[10:33:12.377]                   NAME <- NAMES[[kk]]
[10:33:12.377]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.377]                     next
[10:33:12.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.377]                 }
[10:33:12.377]                 NAMES <- toupper(added)
[10:33:12.377]                 for (kk in seq_along(NAMES)) {
[10:33:12.377]                   name <- added[[kk]]
[10:33:12.377]                   NAME <- NAMES[[kk]]
[10:33:12.377]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.377]                     next
[10:33:12.377]                   args[[name]] <- ""
[10:33:12.377]                 }
[10:33:12.377]                 NAMES <- toupper(removed)
[10:33:12.377]                 for (kk in seq_along(NAMES)) {
[10:33:12.377]                   name <- removed[[kk]]
[10:33:12.377]                   NAME <- NAMES[[kk]]
[10:33:12.377]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.377]                     next
[10:33:12.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.377]                 }
[10:33:12.377]                 if (length(args) > 0) 
[10:33:12.377]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.377]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.377]             }
[10:33:12.377]             else {
[10:33:12.377]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.377]             }
[10:33:12.377]             {
[10:33:12.377]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.377]                   0L) {
[10:33:12.377]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.377]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.377]                   base::options(opts)
[10:33:12.377]                 }
[10:33:12.377]                 {
[10:33:12.377]                   {
[10:33:12.377]                     NULL
[10:33:12.377]                     RNGkind("Mersenne-Twister")
[10:33:12.377]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.377]                       inherits = FALSE)
[10:33:12.377]                   }
[10:33:12.377]                   options(future.plan = NULL)
[10:33:12.377]                   if (is.na(NA_character_)) 
[10:33:12.377]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.377]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.377]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.377]                     .init = FALSE)
[10:33:12.377]                 }
[10:33:12.377]             }
[10:33:12.377]         }
[10:33:12.377]     })
[10:33:12.377]     if (TRUE) {
[10:33:12.377]         base::sink(type = "output", split = FALSE)
[10:33:12.377]         if (TRUE) {
[10:33:12.377]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.377]         }
[10:33:12.377]         else {
[10:33:12.377]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.377]         }
[10:33:12.377]         base::close(...future.stdout)
[10:33:12.377]         ...future.stdout <- NULL
[10:33:12.377]     }
[10:33:12.377]     ...future.result$conditions <- ...future.conditions
[10:33:12.377]     ...future.result$finished <- base::Sys.time()
[10:33:12.377]     ...future.result
[10:33:12.377] }
[10:33:12.378] plan(): Setting new future strategy stack:
[10:33:12.379] List of future strategies:
[10:33:12.379] 1. sequential:
[10:33:12.379]    - args: function (..., envir = parent.frame())
[10:33:12.379]    - tweaked: FALSE
[10:33:12.379]    - call: NULL
[10:33:12.379] plan(): nbrOfWorkers() = 1
[10:33:12.380] plan(): Setting new future strategy stack:
[10:33:12.380] List of future strategies:
[10:33:12.380] 1. sequential:
[10:33:12.380]    - args: function (..., envir = parent.frame())
[10:33:12.380]    - tweaked: FALSE
[10:33:12.380]    - call: plan(strategy)
[10:33:12.380] plan(): nbrOfWorkers() = 1
[10:33:12.380] SequentialFuture started (and completed)
[10:33:12.380] - Launch lazy future ... done
[10:33:12.380] run() for ‘SequentialFuture’ ... done
[10:33:12.380] resolved() for ‘SequentialFuture’ ...
[10:33:12.381] - state: ‘finished’
[10:33:12.381] - run: TRUE
[10:33:12.381] - result: ‘FutureResult’
[10:33:12.381] resolved() for ‘SequentialFuture’ ... done
[10:33:12.381] Future #1
[10:33:12.381] resolved() for ‘SequentialFuture’ ...
[10:33:12.381] - state: ‘finished’
[10:33:12.381] - run: TRUE
[10:33:12.381] - result: ‘FutureResult’
[10:33:12.381] resolved() for ‘SequentialFuture’ ... done
[10:33:12.382] A SequentialFuture was resolved
[10:33:12.382]  length: 0 (resolved future 1)
[10:33:12.382] resolve() on list ... DONE
[10:33:12.382] - globals: [1] ‘a’
[10:33:12.382] Resolving futures part of globals (recursively) ... DONE
[10:33:12.384] The total size of the 1 globals is 1.55 MiB (1621968 bytes)
[10:33:12.384] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[10:33:12.384] - globals: [1] ‘a’
[10:33:12.384] - packages: [1] ‘future’
[10:33:12.384] getGlobalsAndPackages() ... DONE
[10:33:12.385] run() for ‘Future’ ...
[10:33:12.385] - state: ‘created’
[10:33:12.385] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.385] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.385] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.385]   - Field: ‘label’
[10:33:12.385]   - Field: ‘local’
[10:33:12.385]   - Field: ‘owner’
[10:33:12.386]   - Field: ‘envir’
[10:33:12.386]   - Field: ‘packages’
[10:33:12.386]   - Field: ‘gc’
[10:33:12.386]   - Field: ‘conditions’
[10:33:12.386]   - Field: ‘expr’
[10:33:12.386]   - Field: ‘uuid’
[10:33:12.386]   - Field: ‘seed’
[10:33:12.386]   - Field: ‘version’
[10:33:12.386]   - Field: ‘result’
[10:33:12.386]   - Field: ‘asynchronous’
[10:33:12.386]   - Field: ‘calls’
[10:33:12.386]   - Field: ‘globals’
[10:33:12.387]   - Field: ‘stdout’
[10:33:12.387]   - Field: ‘earlySignal’
[10:33:12.387]   - Field: ‘lazy’
[10:33:12.387]   - Field: ‘state’
[10:33:12.387] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.387] - Launch lazy future ...
[10:33:12.387] Packages needed by the future expression (n = 1): ‘future’
[10:33:12.387] Packages needed by future strategies (n = 0): <none>
[10:33:12.388] {
[10:33:12.388]     {
[10:33:12.388]         {
[10:33:12.388]             ...future.startTime <- base::Sys.time()
[10:33:12.388]             {
[10:33:12.388]                 {
[10:33:12.388]                   {
[10:33:12.388]                     {
[10:33:12.388]                       base::local({
[10:33:12.388]                         has_future <- base::requireNamespace("future", 
[10:33:12.388]                           quietly = TRUE)
[10:33:12.388]                         if (has_future) {
[10:33:12.388]                           ns <- base::getNamespace("future")
[10:33:12.388]                           version <- ns[[".package"]][["version"]]
[10:33:12.388]                           if (is.null(version)) 
[10:33:12.388]                             version <- utils::packageVersion("future")
[10:33:12.388]                         }
[10:33:12.388]                         else {
[10:33:12.388]                           version <- NULL
[10:33:12.388]                         }
[10:33:12.388]                         if (!has_future || version < "1.8.0") {
[10:33:12.388]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.388]                             "", base::R.version$version.string), 
[10:33:12.388]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:12.388]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.388]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.388]                               "release", "version")], collapse = " "), 
[10:33:12.388]                             hostname = base::Sys.info()[["nodename"]])
[10:33:12.388]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.388]                             info)
[10:33:12.388]                           info <- base::paste(info, collapse = "; ")
[10:33:12.388]                           if (!has_future) {
[10:33:12.388]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.388]                               info)
[10:33:12.388]                           }
[10:33:12.388]                           else {
[10:33:12.388]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.388]                               info, version)
[10:33:12.388]                           }
[10:33:12.388]                           base::stop(msg)
[10:33:12.388]                         }
[10:33:12.388]                       })
[10:33:12.388]                     }
[10:33:12.388]                     base::local({
[10:33:12.388]                       for (pkg in "future") {
[10:33:12.388]                         base::loadNamespace(pkg)
[10:33:12.388]                         base::library(pkg, character.only = TRUE)
[10:33:12.388]                       }
[10:33:12.388]                     })
[10:33:12.388]                   }
[10:33:12.388]                   ...future.strategy.old <- future::plan("list")
[10:33:12.388]                   options(future.plan = NULL)
[10:33:12.388]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.388]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.388]                 }
[10:33:12.388]                 ...future.workdir <- getwd()
[10:33:12.388]             }
[10:33:12.388]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.388]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.388]         }
[10:33:12.388]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.388]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:12.388]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.388]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.388]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.388]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.388]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.388]             base::names(...future.oldOptions))
[10:33:12.388]     }
[10:33:12.388]     if (FALSE) {
[10:33:12.388]     }
[10:33:12.388]     else {
[10:33:12.388]         if (TRUE) {
[10:33:12.388]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.388]                 open = "w")
[10:33:12.388]         }
[10:33:12.388]         else {
[10:33:12.388]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.388]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.388]         }
[10:33:12.388]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.388]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.388]             base::sink(type = "output", split = FALSE)
[10:33:12.388]             base::close(...future.stdout)
[10:33:12.388]         }, add = TRUE)
[10:33:12.388]     }
[10:33:12.388]     ...future.frame <- base::sys.nframe()
[10:33:12.388]     ...future.conditions <- base::list()
[10:33:12.388]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.388]     if (FALSE) {
[10:33:12.388]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.388]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.388]     }
[10:33:12.388]     ...future.result <- base::tryCatch({
[10:33:12.388]         base::withCallingHandlers({
[10:33:12.388]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:33:12.388]                 1))
[10:33:12.388]             future::FutureResult(value = ...future.value$value, 
[10:33:12.388]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.388]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.388]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.388]                     ...future.globalenv.names))
[10:33:12.388]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.388]         }, condition = base::local({
[10:33:12.388]             c <- base::c
[10:33:12.388]             inherits <- base::inherits
[10:33:12.388]             invokeRestart <- base::invokeRestart
[10:33:12.388]             length <- base::length
[10:33:12.388]             list <- base::list
[10:33:12.388]             seq.int <- base::seq.int
[10:33:12.388]             signalCondition <- base::signalCondition
[10:33:12.388]             sys.calls <- base::sys.calls
[10:33:12.388]             `[[` <- base::`[[`
[10:33:12.388]             `+` <- base::`+`
[10:33:12.388]             `<<-` <- base::`<<-`
[10:33:12.388]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.388]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.388]                   3L)]
[10:33:12.388]             }
[10:33:12.388]             function(cond) {
[10:33:12.388]                 is_error <- inherits(cond, "error")
[10:33:12.388]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.388]                   NULL)
[10:33:12.388]                 if (is_error) {
[10:33:12.388]                   sessionInformation <- function() {
[10:33:12.388]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.388]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.388]                       search = base::search(), system = base::Sys.info())
[10:33:12.388]                   }
[10:33:12.388]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.388]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.388]                     cond$call), session = sessionInformation(), 
[10:33:12.388]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.388]                   signalCondition(cond)
[10:33:12.388]                 }
[10:33:12.388]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.388]                 "immediateCondition"))) {
[10:33:12.388]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.388]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.388]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.388]                   if (TRUE && !signal) {
[10:33:12.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.388]                     {
[10:33:12.388]                       inherits <- base::inherits
[10:33:12.388]                       invokeRestart <- base::invokeRestart
[10:33:12.388]                       is.null <- base::is.null
[10:33:12.388]                       muffled <- FALSE
[10:33:12.388]                       if (inherits(cond, "message")) {
[10:33:12.388]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.388]                         if (muffled) 
[10:33:12.388]                           invokeRestart("muffleMessage")
[10:33:12.388]                       }
[10:33:12.388]                       else if (inherits(cond, "warning")) {
[10:33:12.388]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.388]                         if (muffled) 
[10:33:12.388]                           invokeRestart("muffleWarning")
[10:33:12.388]                       }
[10:33:12.388]                       else if (inherits(cond, "condition")) {
[10:33:12.388]                         if (!is.null(pattern)) {
[10:33:12.388]                           computeRestarts <- base::computeRestarts
[10:33:12.388]                           grepl <- base::grepl
[10:33:12.388]                           restarts <- computeRestarts(cond)
[10:33:12.388]                           for (restart in restarts) {
[10:33:12.388]                             name <- restart$name
[10:33:12.388]                             if (is.null(name)) 
[10:33:12.388]                               next
[10:33:12.388]                             if (!grepl(pattern, name)) 
[10:33:12.388]                               next
[10:33:12.388]                             invokeRestart(restart)
[10:33:12.388]                             muffled <- TRUE
[10:33:12.388]                             break
[10:33:12.388]                           }
[10:33:12.388]                         }
[10:33:12.388]                       }
[10:33:12.388]                       invisible(muffled)
[10:33:12.388]                     }
[10:33:12.388]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.388]                   }
[10:33:12.388]                 }
[10:33:12.388]                 else {
[10:33:12.388]                   if (TRUE) {
[10:33:12.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.388]                     {
[10:33:12.388]                       inherits <- base::inherits
[10:33:12.388]                       invokeRestart <- base::invokeRestart
[10:33:12.388]                       is.null <- base::is.null
[10:33:12.388]                       muffled <- FALSE
[10:33:12.388]                       if (inherits(cond, "message")) {
[10:33:12.388]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.388]                         if (muffled) 
[10:33:12.388]                           invokeRestart("muffleMessage")
[10:33:12.388]                       }
[10:33:12.388]                       else if (inherits(cond, "warning")) {
[10:33:12.388]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.388]                         if (muffled) 
[10:33:12.388]                           invokeRestart("muffleWarning")
[10:33:12.388]                       }
[10:33:12.388]                       else if (inherits(cond, "condition")) {
[10:33:12.388]                         if (!is.null(pattern)) {
[10:33:12.388]                           computeRestarts <- base::computeRestarts
[10:33:12.388]                           grepl <- base::grepl
[10:33:12.388]                           restarts <- computeRestarts(cond)
[10:33:12.388]                           for (restart in restarts) {
[10:33:12.388]                             name <- restart$name
[10:33:12.388]                             if (is.null(name)) 
[10:33:12.388]                               next
[10:33:12.388]                             if (!grepl(pattern, name)) 
[10:33:12.388]                               next
[10:33:12.388]                             invokeRestart(restart)
[10:33:12.388]                             muffled <- TRUE
[10:33:12.388]                             break
[10:33:12.388]                           }
[10:33:12.388]                         }
[10:33:12.388]                       }
[10:33:12.388]                       invisible(muffled)
[10:33:12.388]                     }
[10:33:12.388]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.388]                   }
[10:33:12.388]                 }
[10:33:12.388]             }
[10:33:12.388]         }))
[10:33:12.388]     }, error = function(ex) {
[10:33:12.388]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.388]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.388]                 ...future.rng), started = ...future.startTime, 
[10:33:12.388]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.388]             version = "1.8"), class = "FutureResult")
[10:33:12.388]     }, finally = {
[10:33:12.388]         if (!identical(...future.workdir, getwd())) 
[10:33:12.388]             setwd(...future.workdir)
[10:33:12.388]         {
[10:33:12.388]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.388]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.388]             }
[10:33:12.388]             base::options(...future.oldOptions)
[10:33:12.388]             if (.Platform$OS.type == "windows") {
[10:33:12.388]                 old_names <- names(...future.oldEnvVars)
[10:33:12.388]                 envs <- base::Sys.getenv()
[10:33:12.388]                 names <- names(envs)
[10:33:12.388]                 common <- intersect(names, old_names)
[10:33:12.388]                 added <- setdiff(names, old_names)
[10:33:12.388]                 removed <- setdiff(old_names, names)
[10:33:12.388]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.388]                   envs[common]]
[10:33:12.388]                 NAMES <- toupper(changed)
[10:33:12.388]                 args <- list()
[10:33:12.388]                 for (kk in seq_along(NAMES)) {
[10:33:12.388]                   name <- changed[[kk]]
[10:33:12.388]                   NAME <- NAMES[[kk]]
[10:33:12.388]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.388]                     next
[10:33:12.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.388]                 }
[10:33:12.388]                 NAMES <- toupper(added)
[10:33:12.388]                 for (kk in seq_along(NAMES)) {
[10:33:12.388]                   name <- added[[kk]]
[10:33:12.388]                   NAME <- NAMES[[kk]]
[10:33:12.388]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.388]                     next
[10:33:12.388]                   args[[name]] <- ""
[10:33:12.388]                 }
[10:33:12.388]                 NAMES <- toupper(removed)
[10:33:12.388]                 for (kk in seq_along(NAMES)) {
[10:33:12.388]                   name <- removed[[kk]]
[10:33:12.388]                   NAME <- NAMES[[kk]]
[10:33:12.388]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.388]                     next
[10:33:12.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.388]                 }
[10:33:12.388]                 if (length(args) > 0) 
[10:33:12.388]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.388]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.388]             }
[10:33:12.388]             else {
[10:33:12.388]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.388]             }
[10:33:12.388]             {
[10:33:12.388]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.388]                   0L) {
[10:33:12.388]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.388]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.388]                   base::options(opts)
[10:33:12.388]                 }
[10:33:12.388]                 {
[10:33:12.388]                   {
[10:33:12.388]                     NULL
[10:33:12.388]                     RNGkind("Mersenne-Twister")
[10:33:12.388]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.388]                       inherits = FALSE)
[10:33:12.388]                   }
[10:33:12.388]                   options(future.plan = NULL)
[10:33:12.388]                   if (is.na(NA_character_)) 
[10:33:12.388]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.388]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.388]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.388]                     .init = FALSE)
[10:33:12.388]                 }
[10:33:12.388]             }
[10:33:12.388]         }
[10:33:12.388]     })
[10:33:12.388]     if (TRUE) {
[10:33:12.388]         base::sink(type = "output", split = FALSE)
[10:33:12.388]         if (TRUE) {
[10:33:12.388]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.388]         }
[10:33:12.388]         else {
[10:33:12.388]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.388]         }
[10:33:12.388]         base::close(...future.stdout)
[10:33:12.388]         ...future.stdout <- NULL
[10:33:12.388]     }
[10:33:12.388]     ...future.result$conditions <- ...future.conditions
[10:33:12.388]     ...future.result$finished <- base::Sys.time()
[10:33:12.388]     ...future.result
[10:33:12.388] }
[10:33:12.389] assign_globals() ...
[10:33:12.389] List of 1
[10:33:12.389]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55aa535a38b0> 
[10:33:12.389]  - attr(*, "where")=List of 1
[10:33:12.389]   ..$ a:<environment: R_EmptyEnv> 
[10:33:12.389]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.389]  - attr(*, "resolved")= logi TRUE
[10:33:12.389]  - attr(*, "total_size")= num 1621968
[10:33:12.389]  - attr(*, "already-done")= logi TRUE
[10:33:12.392] - copied ‘a’ to environment
[10:33:12.392] assign_globals() ... done
[10:33:12.392] plan(): Setting new future strategy stack:
[10:33:12.392] List of future strategies:
[10:33:12.392] 1. sequential:
[10:33:12.392]    - args: function (..., envir = parent.frame())
[10:33:12.392]    - tweaked: FALSE
[10:33:12.392]    - call: NULL
[10:33:12.392] plan(): nbrOfWorkers() = 1
[10:33:12.393] plan(): Setting new future strategy stack:
[10:33:12.393] List of future strategies:
[10:33:12.393] 1. sequential:
[10:33:12.393]    - args: function (..., envir = parent.frame())
[10:33:12.393]    - tweaked: FALSE
[10:33:12.393]    - call: plan(strategy)
[10:33:12.394] plan(): nbrOfWorkers() = 1
[10:33:12.394] SequentialFuture started (and completed)
[10:33:12.394] - Launch lazy future ... done
[10:33:12.394] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.394] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.395] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:12.395] 
[10:33:12.395] Searching for globals ... DONE
[10:33:12.395] - globals: [0] <none>
[10:33:12.395] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.395] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.396] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:12.396] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:12.396] Searching for globals ... DONE
[10:33:12.397] Resolving globals: TRUE
[10:33:12.397] Resolving any globals that are futures ...
[10:33:12.397] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:12.397] Resolving any globals that are futures ... DONE
[10:33:12.397] Resolving futures part of globals (recursively) ...
[10:33:12.397] resolve() on list ...
[10:33:12.397]  recursive: 99
[10:33:12.397]  length: 1
[10:33:12.398]  elements: ‘a’
[10:33:12.398] run() for ‘Future’ ...
[10:33:12.398] - state: ‘created’
[10:33:12.398] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.398] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.398] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.398]   - Field: ‘label’
[10:33:12.398]   - Field: ‘local’
[10:33:12.399]   - Field: ‘owner’
[10:33:12.399]   - Field: ‘envir’
[10:33:12.399]   - Field: ‘packages’
[10:33:12.399]   - Field: ‘gc’
[10:33:12.399]   - Field: ‘conditions’
[10:33:12.399]   - Field: ‘expr’
[10:33:12.399]   - Field: ‘uuid’
[10:33:12.399]   - Field: ‘seed’
[10:33:12.399]   - Field: ‘version’
[10:33:12.399]   - Field: ‘result’
[10:33:12.399]   - Field: ‘asynchronous’
[10:33:12.400]   - Field: ‘calls’
[10:33:12.400]   - Field: ‘globals’
[10:33:12.400]   - Field: ‘stdout’
[10:33:12.400]   - Field: ‘earlySignal’
[10:33:12.400]   - Field: ‘lazy’
[10:33:12.400]   - Field: ‘state’
[10:33:12.400] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.400] - Launch lazy future ...
[10:33:12.400] Packages needed by the future expression (n = 0): <none>
[10:33:12.400] Packages needed by future strategies (n = 0): <none>
[10:33:12.401] {
[10:33:12.401]     {
[10:33:12.401]         {
[10:33:12.401]             ...future.startTime <- base::Sys.time()
[10:33:12.401]             {
[10:33:12.401]                 {
[10:33:12.401]                   {
[10:33:12.401]                     base::local({
[10:33:12.401]                       has_future <- base::requireNamespace("future", 
[10:33:12.401]                         quietly = TRUE)
[10:33:12.401]                       if (has_future) {
[10:33:12.401]                         ns <- base::getNamespace("future")
[10:33:12.401]                         version <- ns[[".package"]][["version"]]
[10:33:12.401]                         if (is.null(version)) 
[10:33:12.401]                           version <- utils::packageVersion("future")
[10:33:12.401]                       }
[10:33:12.401]                       else {
[10:33:12.401]                         version <- NULL
[10:33:12.401]                       }
[10:33:12.401]                       if (!has_future || version < "1.8.0") {
[10:33:12.401]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.401]                           "", base::R.version$version.string), 
[10:33:12.401]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.401]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.401]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.401]                             "release", "version")], collapse = " "), 
[10:33:12.401]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.401]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.401]                           info)
[10:33:12.401]                         info <- base::paste(info, collapse = "; ")
[10:33:12.401]                         if (!has_future) {
[10:33:12.401]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.401]                             info)
[10:33:12.401]                         }
[10:33:12.401]                         else {
[10:33:12.401]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.401]                             info, version)
[10:33:12.401]                         }
[10:33:12.401]                         base::stop(msg)
[10:33:12.401]                       }
[10:33:12.401]                     })
[10:33:12.401]                   }
[10:33:12.401]                   ...future.strategy.old <- future::plan("list")
[10:33:12.401]                   options(future.plan = NULL)
[10:33:12.401]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.401]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.401]                 }
[10:33:12.401]                 ...future.workdir <- getwd()
[10:33:12.401]             }
[10:33:12.401]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.401]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.401]         }
[10:33:12.401]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.401]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:12.401]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.401]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.401]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.401]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.401]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.401]             base::names(...future.oldOptions))
[10:33:12.401]     }
[10:33:12.401]     if (FALSE) {
[10:33:12.401]     }
[10:33:12.401]     else {
[10:33:12.401]         if (TRUE) {
[10:33:12.401]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.401]                 open = "w")
[10:33:12.401]         }
[10:33:12.401]         else {
[10:33:12.401]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.401]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.401]         }
[10:33:12.401]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.401]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.401]             base::sink(type = "output", split = FALSE)
[10:33:12.401]             base::close(...future.stdout)
[10:33:12.401]         }, add = TRUE)
[10:33:12.401]     }
[10:33:12.401]     ...future.frame <- base::sys.nframe()
[10:33:12.401]     ...future.conditions <- base::list()
[10:33:12.401]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.401]     if (FALSE) {
[10:33:12.401]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.401]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.401]     }
[10:33:12.401]     ...future.result <- base::tryCatch({
[10:33:12.401]         base::withCallingHandlers({
[10:33:12.401]             ...future.value <- base::withVisible(base::local(1))
[10:33:12.401]             future::FutureResult(value = ...future.value$value, 
[10:33:12.401]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.401]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.401]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.401]                     ...future.globalenv.names))
[10:33:12.401]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.401]         }, condition = base::local({
[10:33:12.401]             c <- base::c
[10:33:12.401]             inherits <- base::inherits
[10:33:12.401]             invokeRestart <- base::invokeRestart
[10:33:12.401]             length <- base::length
[10:33:12.401]             list <- base::list
[10:33:12.401]             seq.int <- base::seq.int
[10:33:12.401]             signalCondition <- base::signalCondition
[10:33:12.401]             sys.calls <- base::sys.calls
[10:33:12.401]             `[[` <- base::`[[`
[10:33:12.401]             `+` <- base::`+`
[10:33:12.401]             `<<-` <- base::`<<-`
[10:33:12.401]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.401]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.401]                   3L)]
[10:33:12.401]             }
[10:33:12.401]             function(cond) {
[10:33:12.401]                 is_error <- inherits(cond, "error")
[10:33:12.401]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.401]                   NULL)
[10:33:12.401]                 if (is_error) {
[10:33:12.401]                   sessionInformation <- function() {
[10:33:12.401]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.401]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.401]                       search = base::search(), system = base::Sys.info())
[10:33:12.401]                   }
[10:33:12.401]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.401]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.401]                     cond$call), session = sessionInformation(), 
[10:33:12.401]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.401]                   signalCondition(cond)
[10:33:12.401]                 }
[10:33:12.401]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.401]                 "immediateCondition"))) {
[10:33:12.401]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.401]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.401]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.401]                   if (TRUE && !signal) {
[10:33:12.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.401]                     {
[10:33:12.401]                       inherits <- base::inherits
[10:33:12.401]                       invokeRestart <- base::invokeRestart
[10:33:12.401]                       is.null <- base::is.null
[10:33:12.401]                       muffled <- FALSE
[10:33:12.401]                       if (inherits(cond, "message")) {
[10:33:12.401]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.401]                         if (muffled) 
[10:33:12.401]                           invokeRestart("muffleMessage")
[10:33:12.401]                       }
[10:33:12.401]                       else if (inherits(cond, "warning")) {
[10:33:12.401]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.401]                         if (muffled) 
[10:33:12.401]                           invokeRestart("muffleWarning")
[10:33:12.401]                       }
[10:33:12.401]                       else if (inherits(cond, "condition")) {
[10:33:12.401]                         if (!is.null(pattern)) {
[10:33:12.401]                           computeRestarts <- base::computeRestarts
[10:33:12.401]                           grepl <- base::grepl
[10:33:12.401]                           restarts <- computeRestarts(cond)
[10:33:12.401]                           for (restart in restarts) {
[10:33:12.401]                             name <- restart$name
[10:33:12.401]                             if (is.null(name)) 
[10:33:12.401]                               next
[10:33:12.401]                             if (!grepl(pattern, name)) 
[10:33:12.401]                               next
[10:33:12.401]                             invokeRestart(restart)
[10:33:12.401]                             muffled <- TRUE
[10:33:12.401]                             break
[10:33:12.401]                           }
[10:33:12.401]                         }
[10:33:12.401]                       }
[10:33:12.401]                       invisible(muffled)
[10:33:12.401]                     }
[10:33:12.401]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.401]                   }
[10:33:12.401]                 }
[10:33:12.401]                 else {
[10:33:12.401]                   if (TRUE) {
[10:33:12.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.401]                     {
[10:33:12.401]                       inherits <- base::inherits
[10:33:12.401]                       invokeRestart <- base::invokeRestart
[10:33:12.401]                       is.null <- base::is.null
[10:33:12.401]                       muffled <- FALSE
[10:33:12.401]                       if (inherits(cond, "message")) {
[10:33:12.401]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.401]                         if (muffled) 
[10:33:12.401]                           invokeRestart("muffleMessage")
[10:33:12.401]                       }
[10:33:12.401]                       else if (inherits(cond, "warning")) {
[10:33:12.401]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.401]                         if (muffled) 
[10:33:12.401]                           invokeRestart("muffleWarning")
[10:33:12.401]                       }
[10:33:12.401]                       else if (inherits(cond, "condition")) {
[10:33:12.401]                         if (!is.null(pattern)) {
[10:33:12.401]                           computeRestarts <- base::computeRestarts
[10:33:12.401]                           grepl <- base::grepl
[10:33:12.401]                           restarts <- computeRestarts(cond)
[10:33:12.401]                           for (restart in restarts) {
[10:33:12.401]                             name <- restart$name
[10:33:12.401]                             if (is.null(name)) 
[10:33:12.401]                               next
[10:33:12.401]                             if (!grepl(pattern, name)) 
[10:33:12.401]                               next
[10:33:12.401]                             invokeRestart(restart)
[10:33:12.401]                             muffled <- TRUE
[10:33:12.401]                             break
[10:33:12.401]                           }
[10:33:12.401]                         }
[10:33:12.401]                       }
[10:33:12.401]                       invisible(muffled)
[10:33:12.401]                     }
[10:33:12.401]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.401]                   }
[10:33:12.401]                 }
[10:33:12.401]             }
[10:33:12.401]         }))
[10:33:12.401]     }, error = function(ex) {
[10:33:12.401]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.401]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.401]                 ...future.rng), started = ...future.startTime, 
[10:33:12.401]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.401]             version = "1.8"), class = "FutureResult")
[10:33:12.401]     }, finally = {
[10:33:12.401]         if (!identical(...future.workdir, getwd())) 
[10:33:12.401]             setwd(...future.workdir)
[10:33:12.401]         {
[10:33:12.401]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.401]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.401]             }
[10:33:12.401]             base::options(...future.oldOptions)
[10:33:12.401]             if (.Platform$OS.type == "windows") {
[10:33:12.401]                 old_names <- names(...future.oldEnvVars)
[10:33:12.401]                 envs <- base::Sys.getenv()
[10:33:12.401]                 names <- names(envs)
[10:33:12.401]                 common <- intersect(names, old_names)
[10:33:12.401]                 added <- setdiff(names, old_names)
[10:33:12.401]                 removed <- setdiff(old_names, names)
[10:33:12.401]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.401]                   envs[common]]
[10:33:12.401]                 NAMES <- toupper(changed)
[10:33:12.401]                 args <- list()
[10:33:12.401]                 for (kk in seq_along(NAMES)) {
[10:33:12.401]                   name <- changed[[kk]]
[10:33:12.401]                   NAME <- NAMES[[kk]]
[10:33:12.401]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.401]                     next
[10:33:12.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.401]                 }
[10:33:12.401]                 NAMES <- toupper(added)
[10:33:12.401]                 for (kk in seq_along(NAMES)) {
[10:33:12.401]                   name <- added[[kk]]
[10:33:12.401]                   NAME <- NAMES[[kk]]
[10:33:12.401]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.401]                     next
[10:33:12.401]                   args[[name]] <- ""
[10:33:12.401]                 }
[10:33:12.401]                 NAMES <- toupper(removed)
[10:33:12.401]                 for (kk in seq_along(NAMES)) {
[10:33:12.401]                   name <- removed[[kk]]
[10:33:12.401]                   NAME <- NAMES[[kk]]
[10:33:12.401]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.401]                     next
[10:33:12.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.401]                 }
[10:33:12.401]                 if (length(args) > 0) 
[10:33:12.401]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.401]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.401]             }
[10:33:12.401]             else {
[10:33:12.401]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.401]             }
[10:33:12.401]             {
[10:33:12.401]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.401]                   0L) {
[10:33:12.401]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.401]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.401]                   base::options(opts)
[10:33:12.401]                 }
[10:33:12.401]                 {
[10:33:12.401]                   {
[10:33:12.401]                     NULL
[10:33:12.401]                     RNGkind("Mersenne-Twister")
[10:33:12.401]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.401]                       inherits = FALSE)
[10:33:12.401]                   }
[10:33:12.401]                   options(future.plan = NULL)
[10:33:12.401]                   if (is.na(NA_character_)) 
[10:33:12.401]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.401]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.401]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.401]                     .init = FALSE)
[10:33:12.401]                 }
[10:33:12.401]             }
[10:33:12.401]         }
[10:33:12.401]     })
[10:33:12.401]     if (TRUE) {
[10:33:12.401]         base::sink(type = "output", split = FALSE)
[10:33:12.401]         if (TRUE) {
[10:33:12.401]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.401]         }
[10:33:12.401]         else {
[10:33:12.401]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.401]         }
[10:33:12.401]         base::close(...future.stdout)
[10:33:12.401]         ...future.stdout <- NULL
[10:33:12.401]     }
[10:33:12.401]     ...future.result$conditions <- ...future.conditions
[10:33:12.401]     ...future.result$finished <- base::Sys.time()
[10:33:12.401]     ...future.result
[10:33:12.401] }
[10:33:12.403] plan(): Setting new future strategy stack:
[10:33:12.403] List of future strategies:
[10:33:12.403] 1. sequential:
[10:33:12.403]    - args: function (..., envir = parent.frame())
[10:33:12.403]    - tweaked: FALSE
[10:33:12.403]    - call: NULL
[10:33:12.404] plan(): nbrOfWorkers() = 1
[10:33:12.404] plan(): Setting new future strategy stack:
[10:33:12.405] List of future strategies:
[10:33:12.405] 1. sequential:
[10:33:12.405]    - args: function (..., envir = parent.frame())
[10:33:12.405]    - tweaked: FALSE
[10:33:12.405]    - call: plan(strategy)
[10:33:12.405] plan(): nbrOfWorkers() = 1
[10:33:12.405] SequentialFuture started (and completed)
[10:33:12.405] - Launch lazy future ... done
[10:33:12.405] run() for ‘SequentialFuture’ ... done
[10:33:12.405] resolved() for ‘SequentialFuture’ ...
[10:33:12.405] - state: ‘finished’
[10:33:12.406] - run: TRUE
[10:33:12.406] - result: ‘FutureResult’
[10:33:12.406] resolved() for ‘SequentialFuture’ ... done
[10:33:12.406] Future #1
[10:33:12.406] resolved() for ‘SequentialFuture’ ...
[10:33:12.406] - state: ‘finished’
[10:33:12.406] - run: TRUE
[10:33:12.406] - result: ‘FutureResult’
[10:33:12.406] resolved() for ‘SequentialFuture’ ... done
[10:33:12.406] A SequentialFuture was resolved
[10:33:12.407]  length: 0 (resolved future 1)
[10:33:12.407] resolve() on list ... DONE
[10:33:12.407] - globals: [1] ‘a’
[10:33:12.407] Resolving futures part of globals (recursively) ... DONE
[10:33:12.408] The total size of the 1 globals is 1.55 MiB (1621968 bytes)
[10:33:12.409] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[10:33:12.409] - globals: [1] ‘a’
[10:33:12.409] - packages: [1] ‘future’
[10:33:12.409] getGlobalsAndPackages() ... DONE
[10:33:12.409] run() for ‘Future’ ...
[10:33:12.409] - state: ‘created’
[10:33:12.410] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.410] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.410] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.410]   - Field: ‘label’
[10:33:12.410]   - Field: ‘local’
[10:33:12.410]   - Field: ‘owner’
[10:33:12.410]   - Field: ‘envir’
[10:33:12.410]   - Field: ‘packages’
[10:33:12.410]   - Field: ‘gc’
[10:33:12.411]   - Field: ‘conditions’
[10:33:12.411]   - Field: ‘expr’
[10:33:12.411]   - Field: ‘uuid’
[10:33:12.411]   - Field: ‘seed’
[10:33:12.411]   - Field: ‘version’
[10:33:12.411]   - Field: ‘result’
[10:33:12.411]   - Field: ‘asynchronous’
[10:33:12.411]   - Field: ‘calls’
[10:33:12.411]   - Field: ‘globals’
[10:33:12.411]   - Field: ‘stdout’
[10:33:12.411]   - Field: ‘earlySignal’
[10:33:12.412]   - Field: ‘lazy’
[10:33:12.412]   - Field: ‘state’
[10:33:12.412] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.412] - Launch lazy future ...
[10:33:12.412] Packages needed by the future expression (n = 1): ‘future’
[10:33:12.412] Packages needed by future strategies (n = 0): <none>
[10:33:12.412] {
[10:33:12.412]     {
[10:33:12.412]         {
[10:33:12.412]             ...future.startTime <- base::Sys.time()
[10:33:12.412]             {
[10:33:12.412]                 {
[10:33:12.412]                   {
[10:33:12.412]                     {
[10:33:12.412]                       base::local({
[10:33:12.412]                         has_future <- base::requireNamespace("future", 
[10:33:12.412]                           quietly = TRUE)
[10:33:12.412]                         if (has_future) {
[10:33:12.412]                           ns <- base::getNamespace("future")
[10:33:12.412]                           version <- ns[[".package"]][["version"]]
[10:33:12.412]                           if (is.null(version)) 
[10:33:12.412]                             version <- utils::packageVersion("future")
[10:33:12.412]                         }
[10:33:12.412]                         else {
[10:33:12.412]                           version <- NULL
[10:33:12.412]                         }
[10:33:12.412]                         if (!has_future || version < "1.8.0") {
[10:33:12.412]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.412]                             "", base::R.version$version.string), 
[10:33:12.412]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:12.412]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.412]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.412]                               "release", "version")], collapse = " "), 
[10:33:12.412]                             hostname = base::Sys.info()[["nodename"]])
[10:33:12.412]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.412]                             info)
[10:33:12.412]                           info <- base::paste(info, collapse = "; ")
[10:33:12.412]                           if (!has_future) {
[10:33:12.412]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.412]                               info)
[10:33:12.412]                           }
[10:33:12.412]                           else {
[10:33:12.412]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.412]                               info, version)
[10:33:12.412]                           }
[10:33:12.412]                           base::stop(msg)
[10:33:12.412]                         }
[10:33:12.412]                       })
[10:33:12.412]                     }
[10:33:12.412]                     base::local({
[10:33:12.412]                       for (pkg in "future") {
[10:33:12.412]                         base::loadNamespace(pkg)
[10:33:12.412]                         base::library(pkg, character.only = TRUE)
[10:33:12.412]                       }
[10:33:12.412]                     })
[10:33:12.412]                   }
[10:33:12.412]                   ...future.strategy.old <- future::plan("list")
[10:33:12.412]                   options(future.plan = NULL)
[10:33:12.412]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.412]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.412]                 }
[10:33:12.412]                 ...future.workdir <- getwd()
[10:33:12.412]             }
[10:33:12.412]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.412]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.412]         }
[10:33:12.412]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.412]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:12.412]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.412]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.412]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.412]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.412]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.412]             base::names(...future.oldOptions))
[10:33:12.412]     }
[10:33:12.412]     if (FALSE) {
[10:33:12.412]     }
[10:33:12.412]     else {
[10:33:12.412]         if (TRUE) {
[10:33:12.412]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.412]                 open = "w")
[10:33:12.412]         }
[10:33:12.412]         else {
[10:33:12.412]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.412]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.412]         }
[10:33:12.412]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.412]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.412]             base::sink(type = "output", split = FALSE)
[10:33:12.412]             base::close(...future.stdout)
[10:33:12.412]         }, add = TRUE)
[10:33:12.412]     }
[10:33:12.412]     ...future.frame <- base::sys.nframe()
[10:33:12.412]     ...future.conditions <- base::list()
[10:33:12.412]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.412]     if (FALSE) {
[10:33:12.412]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.412]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.412]     }
[10:33:12.412]     ...future.result <- base::tryCatch({
[10:33:12.412]         base::withCallingHandlers({
[10:33:12.412]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:33:12.412]                 1))
[10:33:12.412]             future::FutureResult(value = ...future.value$value, 
[10:33:12.412]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.412]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.412]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.412]                     ...future.globalenv.names))
[10:33:12.412]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.412]         }, condition = base::local({
[10:33:12.412]             c <- base::c
[10:33:12.412]             inherits <- base::inherits
[10:33:12.412]             invokeRestart <- base::invokeRestart
[10:33:12.412]             length <- base::length
[10:33:12.412]             list <- base::list
[10:33:12.412]             seq.int <- base::seq.int
[10:33:12.412]             signalCondition <- base::signalCondition
[10:33:12.412]             sys.calls <- base::sys.calls
[10:33:12.412]             `[[` <- base::`[[`
[10:33:12.412]             `+` <- base::`+`
[10:33:12.412]             `<<-` <- base::`<<-`
[10:33:12.412]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.412]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.412]                   3L)]
[10:33:12.412]             }
[10:33:12.412]             function(cond) {
[10:33:12.412]                 is_error <- inherits(cond, "error")
[10:33:12.412]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.412]                   NULL)
[10:33:12.412]                 if (is_error) {
[10:33:12.412]                   sessionInformation <- function() {
[10:33:12.412]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.412]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.412]                       search = base::search(), system = base::Sys.info())
[10:33:12.412]                   }
[10:33:12.412]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.412]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.412]                     cond$call), session = sessionInformation(), 
[10:33:12.412]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.412]                   signalCondition(cond)
[10:33:12.412]                 }
[10:33:12.412]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.412]                 "immediateCondition"))) {
[10:33:12.412]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.412]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.412]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.412]                   if (TRUE && !signal) {
[10:33:12.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.412]                     {
[10:33:12.412]                       inherits <- base::inherits
[10:33:12.412]                       invokeRestart <- base::invokeRestart
[10:33:12.412]                       is.null <- base::is.null
[10:33:12.412]                       muffled <- FALSE
[10:33:12.412]                       if (inherits(cond, "message")) {
[10:33:12.412]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.412]                         if (muffled) 
[10:33:12.412]                           invokeRestart("muffleMessage")
[10:33:12.412]                       }
[10:33:12.412]                       else if (inherits(cond, "warning")) {
[10:33:12.412]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.412]                         if (muffled) 
[10:33:12.412]                           invokeRestart("muffleWarning")
[10:33:12.412]                       }
[10:33:12.412]                       else if (inherits(cond, "condition")) {
[10:33:12.412]                         if (!is.null(pattern)) {
[10:33:12.412]                           computeRestarts <- base::computeRestarts
[10:33:12.412]                           grepl <- base::grepl
[10:33:12.412]                           restarts <- computeRestarts(cond)
[10:33:12.412]                           for (restart in restarts) {
[10:33:12.412]                             name <- restart$name
[10:33:12.412]                             if (is.null(name)) 
[10:33:12.412]                               next
[10:33:12.412]                             if (!grepl(pattern, name)) 
[10:33:12.412]                               next
[10:33:12.412]                             invokeRestart(restart)
[10:33:12.412]                             muffled <- TRUE
[10:33:12.412]                             break
[10:33:12.412]                           }
[10:33:12.412]                         }
[10:33:12.412]                       }
[10:33:12.412]                       invisible(muffled)
[10:33:12.412]                     }
[10:33:12.412]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.412]                   }
[10:33:12.412]                 }
[10:33:12.412]                 else {
[10:33:12.412]                   if (TRUE) {
[10:33:12.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.412]                     {
[10:33:12.412]                       inherits <- base::inherits
[10:33:12.412]                       invokeRestart <- base::invokeRestart
[10:33:12.412]                       is.null <- base::is.null
[10:33:12.412]                       muffled <- FALSE
[10:33:12.412]                       if (inherits(cond, "message")) {
[10:33:12.412]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.412]                         if (muffled) 
[10:33:12.412]                           invokeRestart("muffleMessage")
[10:33:12.412]                       }
[10:33:12.412]                       else if (inherits(cond, "warning")) {
[10:33:12.412]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.412]                         if (muffled) 
[10:33:12.412]                           invokeRestart("muffleWarning")
[10:33:12.412]                       }
[10:33:12.412]                       else if (inherits(cond, "condition")) {
[10:33:12.412]                         if (!is.null(pattern)) {
[10:33:12.412]                           computeRestarts <- base::computeRestarts
[10:33:12.412]                           grepl <- base::grepl
[10:33:12.412]                           restarts <- computeRestarts(cond)
[10:33:12.412]                           for (restart in restarts) {
[10:33:12.412]                             name <- restart$name
[10:33:12.412]                             if (is.null(name)) 
[10:33:12.412]                               next
[10:33:12.412]                             if (!grepl(pattern, name)) 
[10:33:12.412]                               next
[10:33:12.412]                             invokeRestart(restart)
[10:33:12.412]                             muffled <- TRUE
[10:33:12.412]                             break
[10:33:12.412]                           }
[10:33:12.412]                         }
[10:33:12.412]                       }
[10:33:12.412]                       invisible(muffled)
[10:33:12.412]                     }
[10:33:12.412]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.412]                   }
[10:33:12.412]                 }
[10:33:12.412]             }
[10:33:12.412]         }))
[10:33:12.412]     }, error = function(ex) {
[10:33:12.412]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.412]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.412]                 ...future.rng), started = ...future.startTime, 
[10:33:12.412]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.412]             version = "1.8"), class = "FutureResult")
[10:33:12.412]     }, finally = {
[10:33:12.412]         if (!identical(...future.workdir, getwd())) 
[10:33:12.412]             setwd(...future.workdir)
[10:33:12.412]         {
[10:33:12.412]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.412]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.412]             }
[10:33:12.412]             base::options(...future.oldOptions)
[10:33:12.412]             if (.Platform$OS.type == "windows") {
[10:33:12.412]                 old_names <- names(...future.oldEnvVars)
[10:33:12.412]                 envs <- base::Sys.getenv()
[10:33:12.412]                 names <- names(envs)
[10:33:12.412]                 common <- intersect(names, old_names)
[10:33:12.412]                 added <- setdiff(names, old_names)
[10:33:12.412]                 removed <- setdiff(old_names, names)
[10:33:12.412]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.412]                   envs[common]]
[10:33:12.412]                 NAMES <- toupper(changed)
[10:33:12.412]                 args <- list()
[10:33:12.412]                 for (kk in seq_along(NAMES)) {
[10:33:12.412]                   name <- changed[[kk]]
[10:33:12.412]                   NAME <- NAMES[[kk]]
[10:33:12.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.412]                     next
[10:33:12.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.412]                 }
[10:33:12.412]                 NAMES <- toupper(added)
[10:33:12.412]                 for (kk in seq_along(NAMES)) {
[10:33:12.412]                   name <- added[[kk]]
[10:33:12.412]                   NAME <- NAMES[[kk]]
[10:33:12.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.412]                     next
[10:33:12.412]                   args[[name]] <- ""
[10:33:12.412]                 }
[10:33:12.412]                 NAMES <- toupper(removed)
[10:33:12.412]                 for (kk in seq_along(NAMES)) {
[10:33:12.412]                   name <- removed[[kk]]
[10:33:12.412]                   NAME <- NAMES[[kk]]
[10:33:12.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.412]                     next
[10:33:12.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.412]                 }
[10:33:12.412]                 if (length(args) > 0) 
[10:33:12.412]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.412]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.412]             }
[10:33:12.412]             else {
[10:33:12.412]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.412]             }
[10:33:12.412]             {
[10:33:12.412]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.412]                   0L) {
[10:33:12.412]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.412]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.412]                   base::options(opts)
[10:33:12.412]                 }
[10:33:12.412]                 {
[10:33:12.412]                   {
[10:33:12.412]                     NULL
[10:33:12.412]                     RNGkind("Mersenne-Twister")
[10:33:12.412]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.412]                       inherits = FALSE)
[10:33:12.412]                   }
[10:33:12.412]                   options(future.plan = NULL)
[10:33:12.412]                   if (is.na(NA_character_)) 
[10:33:12.412]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.412]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.412]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.412]                     .init = FALSE)
[10:33:12.412]                 }
[10:33:12.412]             }
[10:33:12.412]         }
[10:33:12.412]     })
[10:33:12.412]     if (TRUE) {
[10:33:12.412]         base::sink(type = "output", split = FALSE)
[10:33:12.412]         if (TRUE) {
[10:33:12.412]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.412]         }
[10:33:12.412]         else {
[10:33:12.412]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.412]         }
[10:33:12.412]         base::close(...future.stdout)
[10:33:12.412]         ...future.stdout <- NULL
[10:33:12.412]     }
[10:33:12.412]     ...future.result$conditions <- ...future.conditions
[10:33:12.412]     ...future.result$finished <- base::Sys.time()
[10:33:12.412]     ...future.result
[10:33:12.412] }
[10:33:12.414] assign_globals() ...
[10:33:12.414] List of 1
[10:33:12.414]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55aa534995f0> 
[10:33:12.414]  - attr(*, "where")=List of 1
[10:33:12.414]   ..$ a:<environment: R_EmptyEnv> 
[10:33:12.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.414]  - attr(*, "resolved")= logi TRUE
[10:33:12.414]  - attr(*, "total_size")= num 1621968
[10:33:12.414]  - attr(*, "already-done")= logi TRUE
[10:33:12.416] - copied ‘a’ to environment
[10:33:12.416] assign_globals() ... done
[10:33:12.417] plan(): Setting new future strategy stack:
[10:33:12.417] List of future strategies:
[10:33:12.417] 1. sequential:
[10:33:12.417]    - args: function (..., envir = parent.frame())
[10:33:12.417]    - tweaked: FALSE
[10:33:12.417]    - call: NULL
[10:33:12.417] plan(): nbrOfWorkers() = 1
[10:33:12.418] plan(): Setting new future strategy stack:
[10:33:12.418] List of future strategies:
[10:33:12.418] 1. sequential:
[10:33:12.418]    - args: function (..., envir = parent.frame())
[10:33:12.418]    - tweaked: FALSE
[10:33:12.418]    - call: plan(strategy)
[10:33:12.418] plan(): nbrOfWorkers() = 1
[10:33:12.419] SequentialFuture started (and completed)
[10:33:12.419] - Launch lazy future ... done
[10:33:12.419] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.419] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.419] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:12.420] - globals found: [2] ‘{’, ‘pkg’
[10:33:12.420] Searching for globals ... DONE
[10:33:12.420] Resolving globals: TRUE
[10:33:12.420] Resolving any globals that are futures ...
[10:33:12.420] - globals: [2] ‘{’, ‘pkg’
[10:33:12.420] Resolving any globals that are futures ... DONE
[10:33:12.421] Resolving futures part of globals (recursively) ...
[10:33:12.421] resolve() on list ...
[10:33:12.421]  recursive: 99
[10:33:12.421]  length: 1
[10:33:12.421]  elements: ‘pkg’
[10:33:12.421]  length: 0 (resolved future 1)
[10:33:12.421] resolve() on list ... DONE
[10:33:12.422] - globals: [1] ‘pkg’
[10:33:12.422] Resolving futures part of globals (recursively) ... DONE
[10:33:12.422] The total size of the 1 globals is 112 bytes (112 bytes)
[10:33:12.422] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[10:33:12.422] - globals: [1] ‘pkg’
[10:33:12.422] 
[10:33:12.422] getGlobalsAndPackages() ... DONE
[10:33:12.423] Packages needed by the future expression (n = 0): <none>
[10:33:12.423] Packages needed by future strategies (n = 0): <none>
[10:33:12.423] {
[10:33:12.423]     {
[10:33:12.423]         {
[10:33:12.423]             ...future.startTime <- base::Sys.time()
[10:33:12.423]             {
[10:33:12.423]                 {
[10:33:12.423]                   {
[10:33:12.423]                     base::local({
[10:33:12.423]                       has_future <- base::requireNamespace("future", 
[10:33:12.423]                         quietly = TRUE)
[10:33:12.423]                       if (has_future) {
[10:33:12.423]                         ns <- base::getNamespace("future")
[10:33:12.423]                         version <- ns[[".package"]][["version"]]
[10:33:12.423]                         if (is.null(version)) 
[10:33:12.423]                           version <- utils::packageVersion("future")
[10:33:12.423]                       }
[10:33:12.423]                       else {
[10:33:12.423]                         version <- NULL
[10:33:12.423]                       }
[10:33:12.423]                       if (!has_future || version < "1.8.0") {
[10:33:12.423]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.423]                           "", base::R.version$version.string), 
[10:33:12.423]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.423]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.423]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.423]                             "release", "version")], collapse = " "), 
[10:33:12.423]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.423]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.423]                           info)
[10:33:12.423]                         info <- base::paste(info, collapse = "; ")
[10:33:12.423]                         if (!has_future) {
[10:33:12.423]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.423]                             info)
[10:33:12.423]                         }
[10:33:12.423]                         else {
[10:33:12.423]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.423]                             info, version)
[10:33:12.423]                         }
[10:33:12.423]                         base::stop(msg)
[10:33:12.423]                       }
[10:33:12.423]                     })
[10:33:12.423]                   }
[10:33:12.423]                   ...future.strategy.old <- future::plan("list")
[10:33:12.423]                   options(future.plan = NULL)
[10:33:12.423]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.423]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.423]                 }
[10:33:12.423]                 ...future.workdir <- getwd()
[10:33:12.423]             }
[10:33:12.423]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.423]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.423]         }
[10:33:12.423]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.423]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:12.423]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.423]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.423]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.423]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.423]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.423]             base::names(...future.oldOptions))
[10:33:12.423]     }
[10:33:12.423]     if (FALSE) {
[10:33:12.423]     }
[10:33:12.423]     else {
[10:33:12.423]         if (TRUE) {
[10:33:12.423]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.423]                 open = "w")
[10:33:12.423]         }
[10:33:12.423]         else {
[10:33:12.423]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.423]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.423]         }
[10:33:12.423]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.423]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.423]             base::sink(type = "output", split = FALSE)
[10:33:12.423]             base::close(...future.stdout)
[10:33:12.423]         }, add = TRUE)
[10:33:12.423]     }
[10:33:12.423]     ...future.frame <- base::sys.nframe()
[10:33:12.423]     ...future.conditions <- base::list()
[10:33:12.423]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.423]     if (FALSE) {
[10:33:12.423]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.423]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.423]     }
[10:33:12.423]     ...future.result <- base::tryCatch({
[10:33:12.423]         base::withCallingHandlers({
[10:33:12.423]             ...future.value <- base::withVisible(base::local({
[10:33:12.423]                 pkg
[10:33:12.423]             }))
[10:33:12.423]             future::FutureResult(value = ...future.value$value, 
[10:33:12.423]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.423]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.423]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.423]                     ...future.globalenv.names))
[10:33:12.423]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.423]         }, condition = base::local({
[10:33:12.423]             c <- base::c
[10:33:12.423]             inherits <- base::inherits
[10:33:12.423]             invokeRestart <- base::invokeRestart
[10:33:12.423]             length <- base::length
[10:33:12.423]             list <- base::list
[10:33:12.423]             seq.int <- base::seq.int
[10:33:12.423]             signalCondition <- base::signalCondition
[10:33:12.423]             sys.calls <- base::sys.calls
[10:33:12.423]             `[[` <- base::`[[`
[10:33:12.423]             `+` <- base::`+`
[10:33:12.423]             `<<-` <- base::`<<-`
[10:33:12.423]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.423]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.423]                   3L)]
[10:33:12.423]             }
[10:33:12.423]             function(cond) {
[10:33:12.423]                 is_error <- inherits(cond, "error")
[10:33:12.423]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.423]                   NULL)
[10:33:12.423]                 if (is_error) {
[10:33:12.423]                   sessionInformation <- function() {
[10:33:12.423]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.423]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.423]                       search = base::search(), system = base::Sys.info())
[10:33:12.423]                   }
[10:33:12.423]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.423]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.423]                     cond$call), session = sessionInformation(), 
[10:33:12.423]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.423]                   signalCondition(cond)
[10:33:12.423]                 }
[10:33:12.423]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.423]                 "immediateCondition"))) {
[10:33:12.423]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.423]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.423]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.423]                   if (TRUE && !signal) {
[10:33:12.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.423]                     {
[10:33:12.423]                       inherits <- base::inherits
[10:33:12.423]                       invokeRestart <- base::invokeRestart
[10:33:12.423]                       is.null <- base::is.null
[10:33:12.423]                       muffled <- FALSE
[10:33:12.423]                       if (inherits(cond, "message")) {
[10:33:12.423]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.423]                         if (muffled) 
[10:33:12.423]                           invokeRestart("muffleMessage")
[10:33:12.423]                       }
[10:33:12.423]                       else if (inherits(cond, "warning")) {
[10:33:12.423]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.423]                         if (muffled) 
[10:33:12.423]                           invokeRestart("muffleWarning")
[10:33:12.423]                       }
[10:33:12.423]                       else if (inherits(cond, "condition")) {
[10:33:12.423]                         if (!is.null(pattern)) {
[10:33:12.423]                           computeRestarts <- base::computeRestarts
[10:33:12.423]                           grepl <- base::grepl
[10:33:12.423]                           restarts <- computeRestarts(cond)
[10:33:12.423]                           for (restart in restarts) {
[10:33:12.423]                             name <- restart$name
[10:33:12.423]                             if (is.null(name)) 
[10:33:12.423]                               next
[10:33:12.423]                             if (!grepl(pattern, name)) 
[10:33:12.423]                               next
[10:33:12.423]                             invokeRestart(restart)
[10:33:12.423]                             muffled <- TRUE
[10:33:12.423]                             break
[10:33:12.423]                           }
[10:33:12.423]                         }
[10:33:12.423]                       }
[10:33:12.423]                       invisible(muffled)
[10:33:12.423]                     }
[10:33:12.423]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.423]                   }
[10:33:12.423]                 }
[10:33:12.423]                 else {
[10:33:12.423]                   if (TRUE) {
[10:33:12.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.423]                     {
[10:33:12.423]                       inherits <- base::inherits
[10:33:12.423]                       invokeRestart <- base::invokeRestart
[10:33:12.423]                       is.null <- base::is.null
[10:33:12.423]                       muffled <- FALSE
[10:33:12.423]                       if (inherits(cond, "message")) {
[10:33:12.423]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.423]                         if (muffled) 
[10:33:12.423]                           invokeRestart("muffleMessage")
[10:33:12.423]                       }
[10:33:12.423]                       else if (inherits(cond, "warning")) {
[10:33:12.423]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.423]                         if (muffled) 
[10:33:12.423]                           invokeRestart("muffleWarning")
[10:33:12.423]                       }
[10:33:12.423]                       else if (inherits(cond, "condition")) {
[10:33:12.423]                         if (!is.null(pattern)) {
[10:33:12.423]                           computeRestarts <- base::computeRestarts
[10:33:12.423]                           grepl <- base::grepl
[10:33:12.423]                           restarts <- computeRestarts(cond)
[10:33:12.423]                           for (restart in restarts) {
[10:33:12.423]                             name <- restart$name
[10:33:12.423]                             if (is.null(name)) 
[10:33:12.423]                               next
[10:33:12.423]                             if (!grepl(pattern, name)) 
[10:33:12.423]                               next
[10:33:12.423]                             invokeRestart(restart)
[10:33:12.423]                             muffled <- TRUE
[10:33:12.423]                             break
[10:33:12.423]                           }
[10:33:12.423]                         }
[10:33:12.423]                       }
[10:33:12.423]                       invisible(muffled)
[10:33:12.423]                     }
[10:33:12.423]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.423]                   }
[10:33:12.423]                 }
[10:33:12.423]             }
[10:33:12.423]         }))
[10:33:12.423]     }, error = function(ex) {
[10:33:12.423]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.423]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.423]                 ...future.rng), started = ...future.startTime, 
[10:33:12.423]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.423]             version = "1.8"), class = "FutureResult")
[10:33:12.423]     }, finally = {
[10:33:12.423]         if (!identical(...future.workdir, getwd())) 
[10:33:12.423]             setwd(...future.workdir)
[10:33:12.423]         {
[10:33:12.423]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.423]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.423]             }
[10:33:12.423]             base::options(...future.oldOptions)
[10:33:12.423]             if (.Platform$OS.type == "windows") {
[10:33:12.423]                 old_names <- names(...future.oldEnvVars)
[10:33:12.423]                 envs <- base::Sys.getenv()
[10:33:12.423]                 names <- names(envs)
[10:33:12.423]                 common <- intersect(names, old_names)
[10:33:12.423]                 added <- setdiff(names, old_names)
[10:33:12.423]                 removed <- setdiff(old_names, names)
[10:33:12.423]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.423]                   envs[common]]
[10:33:12.423]                 NAMES <- toupper(changed)
[10:33:12.423]                 args <- list()
[10:33:12.423]                 for (kk in seq_along(NAMES)) {
[10:33:12.423]                   name <- changed[[kk]]
[10:33:12.423]                   NAME <- NAMES[[kk]]
[10:33:12.423]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.423]                     next
[10:33:12.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.423]                 }
[10:33:12.423]                 NAMES <- toupper(added)
[10:33:12.423]                 for (kk in seq_along(NAMES)) {
[10:33:12.423]                   name <- added[[kk]]
[10:33:12.423]                   NAME <- NAMES[[kk]]
[10:33:12.423]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.423]                     next
[10:33:12.423]                   args[[name]] <- ""
[10:33:12.423]                 }
[10:33:12.423]                 NAMES <- toupper(removed)
[10:33:12.423]                 for (kk in seq_along(NAMES)) {
[10:33:12.423]                   name <- removed[[kk]]
[10:33:12.423]                   NAME <- NAMES[[kk]]
[10:33:12.423]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.423]                     next
[10:33:12.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.423]                 }
[10:33:12.423]                 if (length(args) > 0) 
[10:33:12.423]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.423]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.423]             }
[10:33:12.423]             else {
[10:33:12.423]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.423]             }
[10:33:12.423]             {
[10:33:12.423]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.423]                   0L) {
[10:33:12.423]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.423]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.423]                   base::options(opts)
[10:33:12.423]                 }
[10:33:12.423]                 {
[10:33:12.423]                   {
[10:33:12.423]                     NULL
[10:33:12.423]                     RNGkind("Mersenne-Twister")
[10:33:12.423]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.423]                       inherits = FALSE)
[10:33:12.423]                   }
[10:33:12.423]                   options(future.plan = NULL)
[10:33:12.423]                   if (is.na(NA_character_)) 
[10:33:12.423]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.423]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.423]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.423]                     .init = FALSE)
[10:33:12.423]                 }
[10:33:12.423]             }
[10:33:12.423]         }
[10:33:12.423]     })
[10:33:12.423]     if (TRUE) {
[10:33:12.423]         base::sink(type = "output", split = FALSE)
[10:33:12.423]         if (TRUE) {
[10:33:12.423]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.423]         }
[10:33:12.423]         else {
[10:33:12.423]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.423]         }
[10:33:12.423]         base::close(...future.stdout)
[10:33:12.423]         ...future.stdout <- NULL
[10:33:12.423]     }
[10:33:12.423]     ...future.result$conditions <- ...future.conditions
[10:33:12.423]     ...future.result$finished <- base::Sys.time()
[10:33:12.423]     ...future.result
[10:33:12.423] }
[10:33:12.425] assign_globals() ...
[10:33:12.425] List of 1
[10:33:12.425]  $ pkg: chr "foo"
[10:33:12.425]  - attr(*, "where")=List of 1
[10:33:12.425]   ..$ pkg:<environment: R_EmptyEnv> 
[10:33:12.425]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.425]  - attr(*, "resolved")= logi TRUE
[10:33:12.425]  - attr(*, "total_size")= num 112
[10:33:12.427] - copied ‘pkg’ to environment
[10:33:12.427] assign_globals() ... done
[10:33:12.427] plan(): Setting new future strategy stack:
[10:33:12.427] List of future strategies:
[10:33:12.427] 1. sequential:
[10:33:12.427]    - args: function (..., envir = parent.frame())
[10:33:12.427]    - tweaked: FALSE
[10:33:12.427]    - call: NULL
[10:33:12.427] plan(): nbrOfWorkers() = 1
[10:33:12.428] plan(): Setting new future strategy stack:
[10:33:12.428] List of future strategies:
[10:33:12.428] 1. sequential:
[10:33:12.428]    - args: function (..., envir = parent.frame())
[10:33:12.428]    - tweaked: FALSE
[10:33:12.428]    - call: plan(strategy)
[10:33:12.429] plan(): nbrOfWorkers() = 1
[10:33:12.429] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.430] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.431] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:12.432] - globals found: [3] ‘{’, ‘<-’, ‘+’
[10:33:12.433] Searching for globals ... DONE
[10:33:12.433] Resolving globals: TRUE
[10:33:12.433] Resolving any globals that are futures ...
[10:33:12.433] - globals: [3] ‘{’, ‘<-’, ‘+’
[10:33:12.433] Resolving any globals that are futures ... DONE
[10:33:12.433] 
[10:33:12.433] 
[10:33:12.433] getGlobalsAndPackages() ... DONE
[10:33:12.434] run() for ‘Future’ ...
[10:33:12.434] - state: ‘created’
[10:33:12.434] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.434] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.434] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.434]   - Field: ‘label’
[10:33:12.434]   - Field: ‘local’
[10:33:12.435]   - Field: ‘owner’
[10:33:12.435]   - Field: ‘envir’
[10:33:12.435]   - Field: ‘packages’
[10:33:12.435]   - Field: ‘gc’
[10:33:12.435]   - Field: ‘conditions’
[10:33:12.435]   - Field: ‘expr’
[10:33:12.435]   - Field: ‘uuid’
[10:33:12.435]   - Field: ‘seed’
[10:33:12.435]   - Field: ‘version’
[10:33:12.435]   - Field: ‘result’
[10:33:12.435]   - Field: ‘asynchronous’
[10:33:12.436]   - Field: ‘calls’
[10:33:12.436]   - Field: ‘globals’
[10:33:12.436]   - Field: ‘stdout’
[10:33:12.436]   - Field: ‘earlySignal’
[10:33:12.436]   - Field: ‘lazy’
[10:33:12.436]   - Field: ‘state’
[10:33:12.436] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.436] - Launch lazy future ...
[10:33:12.436] Packages needed by the future expression (n = 0): <none>
[10:33:12.436] Packages needed by future strategies (n = 0): <none>
[10:33:12.437] {
[10:33:12.437]     {
[10:33:12.437]         {
[10:33:12.437]             ...future.startTime <- base::Sys.time()
[10:33:12.437]             {
[10:33:12.437]                 {
[10:33:12.437]                   {
[10:33:12.437]                     base::local({
[10:33:12.437]                       has_future <- base::requireNamespace("future", 
[10:33:12.437]                         quietly = TRUE)
[10:33:12.437]                       if (has_future) {
[10:33:12.437]                         ns <- base::getNamespace("future")
[10:33:12.437]                         version <- ns[[".package"]][["version"]]
[10:33:12.437]                         if (is.null(version)) 
[10:33:12.437]                           version <- utils::packageVersion("future")
[10:33:12.437]                       }
[10:33:12.437]                       else {
[10:33:12.437]                         version <- NULL
[10:33:12.437]                       }
[10:33:12.437]                       if (!has_future || version < "1.8.0") {
[10:33:12.437]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.437]                           "", base::R.version$version.string), 
[10:33:12.437]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.437]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.437]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.437]                             "release", "version")], collapse = " "), 
[10:33:12.437]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.437]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.437]                           info)
[10:33:12.437]                         info <- base::paste(info, collapse = "; ")
[10:33:12.437]                         if (!has_future) {
[10:33:12.437]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.437]                             info)
[10:33:12.437]                         }
[10:33:12.437]                         else {
[10:33:12.437]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.437]                             info, version)
[10:33:12.437]                         }
[10:33:12.437]                         base::stop(msg)
[10:33:12.437]                       }
[10:33:12.437]                     })
[10:33:12.437]                   }
[10:33:12.437]                   ...future.strategy.old <- future::plan("list")
[10:33:12.437]                   options(future.plan = NULL)
[10:33:12.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.437]                 }
[10:33:12.437]                 ...future.workdir <- getwd()
[10:33:12.437]             }
[10:33:12.437]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.437]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.437]         }
[10:33:12.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.437]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:12.437]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.437]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.437]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.437]             base::names(...future.oldOptions))
[10:33:12.437]     }
[10:33:12.437]     if (FALSE) {
[10:33:12.437]     }
[10:33:12.437]     else {
[10:33:12.437]         if (TRUE) {
[10:33:12.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.437]                 open = "w")
[10:33:12.437]         }
[10:33:12.437]         else {
[10:33:12.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.437]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.437]         }
[10:33:12.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.437]             base::sink(type = "output", split = FALSE)
[10:33:12.437]             base::close(...future.stdout)
[10:33:12.437]         }, add = TRUE)
[10:33:12.437]     }
[10:33:12.437]     ...future.frame <- base::sys.nframe()
[10:33:12.437]     ...future.conditions <- base::list()
[10:33:12.437]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.437]     if (FALSE) {
[10:33:12.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.437]     }
[10:33:12.437]     ...future.result <- base::tryCatch({
[10:33:12.437]         base::withCallingHandlers({
[10:33:12.437]             ...future.value <- base::withVisible(base::local({
[10:33:12.437]                 x <- 0
[10:33:12.437]                 x <- x + 1
[10:33:12.437]                 x
[10:33:12.437]             }))
[10:33:12.437]             future::FutureResult(value = ...future.value$value, 
[10:33:12.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.437]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.437]                     ...future.globalenv.names))
[10:33:12.437]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.437]         }, condition = base::local({
[10:33:12.437]             c <- base::c
[10:33:12.437]             inherits <- base::inherits
[10:33:12.437]             invokeRestart <- base::invokeRestart
[10:33:12.437]             length <- base::length
[10:33:12.437]             list <- base::list
[10:33:12.437]             seq.int <- base::seq.int
[10:33:12.437]             signalCondition <- base::signalCondition
[10:33:12.437]             sys.calls <- base::sys.calls
[10:33:12.437]             `[[` <- base::`[[`
[10:33:12.437]             `+` <- base::`+`
[10:33:12.437]             `<<-` <- base::`<<-`
[10:33:12.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.437]                   3L)]
[10:33:12.437]             }
[10:33:12.437]             function(cond) {
[10:33:12.437]                 is_error <- inherits(cond, "error")
[10:33:12.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.437]                   NULL)
[10:33:12.437]                 if (is_error) {
[10:33:12.437]                   sessionInformation <- function() {
[10:33:12.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.437]                       search = base::search(), system = base::Sys.info())
[10:33:12.437]                   }
[10:33:12.437]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.437]                     cond$call), session = sessionInformation(), 
[10:33:12.437]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.437]                   signalCondition(cond)
[10:33:12.437]                 }
[10:33:12.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.437]                 "immediateCondition"))) {
[10:33:12.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.437]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.437]                   if (TRUE && !signal) {
[10:33:12.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.437]                     {
[10:33:12.437]                       inherits <- base::inherits
[10:33:12.437]                       invokeRestart <- base::invokeRestart
[10:33:12.437]                       is.null <- base::is.null
[10:33:12.437]                       muffled <- FALSE
[10:33:12.437]                       if (inherits(cond, "message")) {
[10:33:12.437]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.437]                         if (muffled) 
[10:33:12.437]                           invokeRestart("muffleMessage")
[10:33:12.437]                       }
[10:33:12.437]                       else if (inherits(cond, "warning")) {
[10:33:12.437]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.437]                         if (muffled) 
[10:33:12.437]                           invokeRestart("muffleWarning")
[10:33:12.437]                       }
[10:33:12.437]                       else if (inherits(cond, "condition")) {
[10:33:12.437]                         if (!is.null(pattern)) {
[10:33:12.437]                           computeRestarts <- base::computeRestarts
[10:33:12.437]                           grepl <- base::grepl
[10:33:12.437]                           restarts <- computeRestarts(cond)
[10:33:12.437]                           for (restart in restarts) {
[10:33:12.437]                             name <- restart$name
[10:33:12.437]                             if (is.null(name)) 
[10:33:12.437]                               next
[10:33:12.437]                             if (!grepl(pattern, name)) 
[10:33:12.437]                               next
[10:33:12.437]                             invokeRestart(restart)
[10:33:12.437]                             muffled <- TRUE
[10:33:12.437]                             break
[10:33:12.437]                           }
[10:33:12.437]                         }
[10:33:12.437]                       }
[10:33:12.437]                       invisible(muffled)
[10:33:12.437]                     }
[10:33:12.437]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.437]                   }
[10:33:12.437]                 }
[10:33:12.437]                 else {
[10:33:12.437]                   if (TRUE) {
[10:33:12.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.437]                     {
[10:33:12.437]                       inherits <- base::inherits
[10:33:12.437]                       invokeRestart <- base::invokeRestart
[10:33:12.437]                       is.null <- base::is.null
[10:33:12.437]                       muffled <- FALSE
[10:33:12.437]                       if (inherits(cond, "message")) {
[10:33:12.437]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.437]                         if (muffled) 
[10:33:12.437]                           invokeRestart("muffleMessage")
[10:33:12.437]                       }
[10:33:12.437]                       else if (inherits(cond, "warning")) {
[10:33:12.437]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.437]                         if (muffled) 
[10:33:12.437]                           invokeRestart("muffleWarning")
[10:33:12.437]                       }
[10:33:12.437]                       else if (inherits(cond, "condition")) {
[10:33:12.437]                         if (!is.null(pattern)) {
[10:33:12.437]                           computeRestarts <- base::computeRestarts
[10:33:12.437]                           grepl <- base::grepl
[10:33:12.437]                           restarts <- computeRestarts(cond)
[10:33:12.437]                           for (restart in restarts) {
[10:33:12.437]                             name <- restart$name
[10:33:12.437]                             if (is.null(name)) 
[10:33:12.437]                               next
[10:33:12.437]                             if (!grepl(pattern, name)) 
[10:33:12.437]                               next
[10:33:12.437]                             invokeRestart(restart)
[10:33:12.437]                             muffled <- TRUE
[10:33:12.437]                             break
[10:33:12.437]                           }
[10:33:12.437]                         }
[10:33:12.437]                       }
[10:33:12.437]                       invisible(muffled)
[10:33:12.437]                     }
[10:33:12.437]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.437]                   }
[10:33:12.437]                 }
[10:33:12.437]             }
[10:33:12.437]         }))
[10:33:12.437]     }, error = function(ex) {
[10:33:12.437]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.437]                 ...future.rng), started = ...future.startTime, 
[10:33:12.437]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.437]             version = "1.8"), class = "FutureResult")
[10:33:12.437]     }, finally = {
[10:33:12.437]         if (!identical(...future.workdir, getwd())) 
[10:33:12.437]             setwd(...future.workdir)
[10:33:12.437]         {
[10:33:12.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.437]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.437]             }
[10:33:12.437]             base::options(...future.oldOptions)
[10:33:12.437]             if (.Platform$OS.type == "windows") {
[10:33:12.437]                 old_names <- names(...future.oldEnvVars)
[10:33:12.437]                 envs <- base::Sys.getenv()
[10:33:12.437]                 names <- names(envs)
[10:33:12.437]                 common <- intersect(names, old_names)
[10:33:12.437]                 added <- setdiff(names, old_names)
[10:33:12.437]                 removed <- setdiff(old_names, names)
[10:33:12.437]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.437]                   envs[common]]
[10:33:12.437]                 NAMES <- toupper(changed)
[10:33:12.437]                 args <- list()
[10:33:12.437]                 for (kk in seq_along(NAMES)) {
[10:33:12.437]                   name <- changed[[kk]]
[10:33:12.437]                   NAME <- NAMES[[kk]]
[10:33:12.437]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.437]                     next
[10:33:12.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.437]                 }
[10:33:12.437]                 NAMES <- toupper(added)
[10:33:12.437]                 for (kk in seq_along(NAMES)) {
[10:33:12.437]                   name <- added[[kk]]
[10:33:12.437]                   NAME <- NAMES[[kk]]
[10:33:12.437]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.437]                     next
[10:33:12.437]                   args[[name]] <- ""
[10:33:12.437]                 }
[10:33:12.437]                 NAMES <- toupper(removed)
[10:33:12.437]                 for (kk in seq_along(NAMES)) {
[10:33:12.437]                   name <- removed[[kk]]
[10:33:12.437]                   NAME <- NAMES[[kk]]
[10:33:12.437]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.437]                     next
[10:33:12.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.437]                 }
[10:33:12.437]                 if (length(args) > 0) 
[10:33:12.437]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.437]             }
[10:33:12.437]             else {
[10:33:12.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.437]             }
[10:33:12.437]             {
[10:33:12.437]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.437]                   0L) {
[10:33:12.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.437]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.437]                   base::options(opts)
[10:33:12.437]                 }
[10:33:12.437]                 {
[10:33:12.437]                   {
[10:33:12.437]                     NULL
[10:33:12.437]                     RNGkind("Mersenne-Twister")
[10:33:12.437]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.437]                       inherits = FALSE)
[10:33:12.437]                   }
[10:33:12.437]                   options(future.plan = NULL)
[10:33:12.437]                   if (is.na(NA_character_)) 
[10:33:12.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.437]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.437]                     .init = FALSE)
[10:33:12.437]                 }
[10:33:12.437]             }
[10:33:12.437]         }
[10:33:12.437]     })
[10:33:12.437]     if (TRUE) {
[10:33:12.437]         base::sink(type = "output", split = FALSE)
[10:33:12.437]         if (TRUE) {
[10:33:12.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.437]         }
[10:33:12.437]         else {
[10:33:12.437]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.437]         }
[10:33:12.437]         base::close(...future.stdout)
[10:33:12.437]         ...future.stdout <- NULL
[10:33:12.437]     }
[10:33:12.437]     ...future.result$conditions <- ...future.conditions
[10:33:12.437]     ...future.result$finished <- base::Sys.time()
[10:33:12.437]     ...future.result
[10:33:12.437] }
[10:33:12.439] plan(): Setting new future strategy stack:
[10:33:12.439] List of future strategies:
[10:33:12.439] 1. sequential:
[10:33:12.439]    - args: function (..., envir = parent.frame())
[10:33:12.439]    - tweaked: FALSE
[10:33:12.439]    - call: NULL
[10:33:12.439] plan(): nbrOfWorkers() = 1
[10:33:12.440] plan(): Setting new future strategy stack:
[10:33:12.440] List of future strategies:
[10:33:12.440] 1. sequential:
[10:33:12.440]    - args: function (..., envir = parent.frame())
[10:33:12.440]    - tweaked: FALSE
[10:33:12.440]    - call: plan(strategy)
[10:33:12.440] plan(): nbrOfWorkers() = 1
[10:33:12.440] SequentialFuture started (and completed)
[10:33:12.440] - Launch lazy future ... done
[10:33:12.440] run() for ‘SequentialFuture’ ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.441] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.441] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:12.442] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[10:33:12.443] Searching for globals ... DONE
[10:33:12.443] Resolving globals: TRUE
[10:33:12.443] Resolving any globals that are futures ...
[10:33:12.443] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[10:33:12.443] Resolving any globals that are futures ... DONE
[10:33:12.443] Resolving futures part of globals (recursively) ...
[10:33:12.443] resolve() on list ...
[10:33:12.444]  recursive: 99
[10:33:12.444]  length: 1
[10:33:12.444]  elements: ‘x’
[10:33:12.444]  length: 0 (resolved future 1)
[10:33:12.444] resolve() on list ... DONE
[10:33:12.444] - globals: [1] ‘x’
[10:33:12.444] Resolving futures part of globals (recursively) ... DONE
[10:33:12.444] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:12.445] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[10:33:12.445] - globals: [1] ‘x’
[10:33:12.445] 
[10:33:12.445] getGlobalsAndPackages() ... DONE
[10:33:12.445] run() for ‘Future’ ...
[10:33:12.445] - state: ‘created’
[10:33:12.445] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.446] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.446] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.446]   - Field: ‘label’
[10:33:12.446]   - Field: ‘local’
[10:33:12.446]   - Field: ‘owner’
[10:33:12.446]   - Field: ‘envir’
[10:33:12.446]   - Field: ‘packages’
[10:33:12.446]   - Field: ‘gc’
[10:33:12.446]   - Field: ‘conditions’
[10:33:12.446]   - Field: ‘expr’
[10:33:12.446]   - Field: ‘uuid’
[10:33:12.447]   - Field: ‘seed’
[10:33:12.447]   - Field: ‘version’
[10:33:12.447]   - Field: ‘result’
[10:33:12.447]   - Field: ‘asynchronous’
[10:33:12.447]   - Field: ‘calls’
[10:33:12.447]   - Field: ‘globals’
[10:33:12.447]   - Field: ‘stdout’
[10:33:12.447]   - Field: ‘earlySignal’
[10:33:12.447]   - Field: ‘lazy’
[10:33:12.447]   - Field: ‘state’
[10:33:12.447] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.448] - Launch lazy future ...
[10:33:12.448] Packages needed by the future expression (n = 0): <none>
[10:33:12.448] Packages needed by future strategies (n = 0): <none>
[10:33:12.448] {
[10:33:12.448]     {
[10:33:12.448]         {
[10:33:12.448]             ...future.startTime <- base::Sys.time()
[10:33:12.448]             {
[10:33:12.448]                 {
[10:33:12.448]                   {
[10:33:12.448]                     base::local({
[10:33:12.448]                       has_future <- base::requireNamespace("future", 
[10:33:12.448]                         quietly = TRUE)
[10:33:12.448]                       if (has_future) {
[10:33:12.448]                         ns <- base::getNamespace("future")
[10:33:12.448]                         version <- ns[[".package"]][["version"]]
[10:33:12.448]                         if (is.null(version)) 
[10:33:12.448]                           version <- utils::packageVersion("future")
[10:33:12.448]                       }
[10:33:12.448]                       else {
[10:33:12.448]                         version <- NULL
[10:33:12.448]                       }
[10:33:12.448]                       if (!has_future || version < "1.8.0") {
[10:33:12.448]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.448]                           "", base::R.version$version.string), 
[10:33:12.448]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.448]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.448]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.448]                             "release", "version")], collapse = " "), 
[10:33:12.448]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.448]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.448]                           info)
[10:33:12.448]                         info <- base::paste(info, collapse = "; ")
[10:33:12.448]                         if (!has_future) {
[10:33:12.448]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.448]                             info)
[10:33:12.448]                         }
[10:33:12.448]                         else {
[10:33:12.448]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.448]                             info, version)
[10:33:12.448]                         }
[10:33:12.448]                         base::stop(msg)
[10:33:12.448]                       }
[10:33:12.448]                     })
[10:33:12.448]                   }
[10:33:12.448]                   ...future.strategy.old <- future::plan("list")
[10:33:12.448]                   options(future.plan = NULL)
[10:33:12.448]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.448]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.448]                 }
[10:33:12.448]                 ...future.workdir <- getwd()
[10:33:12.448]             }
[10:33:12.448]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.448]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.448]         }
[10:33:12.448]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.448]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:12.448]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.448]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.448]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.448]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.448]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.448]             base::names(...future.oldOptions))
[10:33:12.448]     }
[10:33:12.448]     if (FALSE) {
[10:33:12.448]     }
[10:33:12.448]     else {
[10:33:12.448]         if (TRUE) {
[10:33:12.448]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.448]                 open = "w")
[10:33:12.448]         }
[10:33:12.448]         else {
[10:33:12.448]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.448]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.448]         }
[10:33:12.448]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.448]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.448]             base::sink(type = "output", split = FALSE)
[10:33:12.448]             base::close(...future.stdout)
[10:33:12.448]         }, add = TRUE)
[10:33:12.448]     }
[10:33:12.448]     ...future.frame <- base::sys.nframe()
[10:33:12.448]     ...future.conditions <- base::list()
[10:33:12.448]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.448]     if (FALSE) {
[10:33:12.448]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.448]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.448]     }
[10:33:12.448]     ...future.result <- base::tryCatch({
[10:33:12.448]         base::withCallingHandlers({
[10:33:12.448]             ...future.value <- base::withVisible(base::local({
[10:33:12.448]                 x <- x + 1
[10:33:12.448]                 x
[10:33:12.448]             }))
[10:33:12.448]             future::FutureResult(value = ...future.value$value, 
[10:33:12.448]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.448]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.448]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.448]                     ...future.globalenv.names))
[10:33:12.448]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.448]         }, condition = base::local({
[10:33:12.448]             c <- base::c
[10:33:12.448]             inherits <- base::inherits
[10:33:12.448]             invokeRestart <- base::invokeRestart
[10:33:12.448]             length <- base::length
[10:33:12.448]             list <- base::list
[10:33:12.448]             seq.int <- base::seq.int
[10:33:12.448]             signalCondition <- base::signalCondition
[10:33:12.448]             sys.calls <- base::sys.calls
[10:33:12.448]             `[[` <- base::`[[`
[10:33:12.448]             `+` <- base::`+`
[10:33:12.448]             `<<-` <- base::`<<-`
[10:33:12.448]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.448]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.448]                   3L)]
[10:33:12.448]             }
[10:33:12.448]             function(cond) {
[10:33:12.448]                 is_error <- inherits(cond, "error")
[10:33:12.448]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.448]                   NULL)
[10:33:12.448]                 if (is_error) {
[10:33:12.448]                   sessionInformation <- function() {
[10:33:12.448]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.448]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.448]                       search = base::search(), system = base::Sys.info())
[10:33:12.448]                   }
[10:33:12.448]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.448]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.448]                     cond$call), session = sessionInformation(), 
[10:33:12.448]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.448]                   signalCondition(cond)
[10:33:12.448]                 }
[10:33:12.448]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.448]                 "immediateCondition"))) {
[10:33:12.448]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.448]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.448]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.448]                   if (TRUE && !signal) {
[10:33:12.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.448]                     {
[10:33:12.448]                       inherits <- base::inherits
[10:33:12.448]                       invokeRestart <- base::invokeRestart
[10:33:12.448]                       is.null <- base::is.null
[10:33:12.448]                       muffled <- FALSE
[10:33:12.448]                       if (inherits(cond, "message")) {
[10:33:12.448]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.448]                         if (muffled) 
[10:33:12.448]                           invokeRestart("muffleMessage")
[10:33:12.448]                       }
[10:33:12.448]                       else if (inherits(cond, "warning")) {
[10:33:12.448]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.448]                         if (muffled) 
[10:33:12.448]                           invokeRestart("muffleWarning")
[10:33:12.448]                       }
[10:33:12.448]                       else if (inherits(cond, "condition")) {
[10:33:12.448]                         if (!is.null(pattern)) {
[10:33:12.448]                           computeRestarts <- base::computeRestarts
[10:33:12.448]                           grepl <- base::grepl
[10:33:12.448]                           restarts <- computeRestarts(cond)
[10:33:12.448]                           for (restart in restarts) {
[10:33:12.448]                             name <- restart$name
[10:33:12.448]                             if (is.null(name)) 
[10:33:12.448]                               next
[10:33:12.448]                             if (!grepl(pattern, name)) 
[10:33:12.448]                               next
[10:33:12.448]                             invokeRestart(restart)
[10:33:12.448]                             muffled <- TRUE
[10:33:12.448]                             break
[10:33:12.448]                           }
[10:33:12.448]                         }
[10:33:12.448]                       }
[10:33:12.448]                       invisible(muffled)
[10:33:12.448]                     }
[10:33:12.448]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.448]                   }
[10:33:12.448]                 }
[10:33:12.448]                 else {
[10:33:12.448]                   if (TRUE) {
[10:33:12.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.448]                     {
[10:33:12.448]                       inherits <- base::inherits
[10:33:12.448]                       invokeRestart <- base::invokeRestart
[10:33:12.448]                       is.null <- base::is.null
[10:33:12.448]                       muffled <- FALSE
[10:33:12.448]                       if (inherits(cond, "message")) {
[10:33:12.448]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.448]                         if (muffled) 
[10:33:12.448]                           invokeRestart("muffleMessage")
[10:33:12.448]                       }
[10:33:12.448]                       else if (inherits(cond, "warning")) {
[10:33:12.448]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.448]                         if (muffled) 
[10:33:12.448]                           invokeRestart("muffleWarning")
[10:33:12.448]                       }
[10:33:12.448]                       else if (inherits(cond, "condition")) {
[10:33:12.448]                         if (!is.null(pattern)) {
[10:33:12.448]                           computeRestarts <- base::computeRestarts
[10:33:12.448]                           grepl <- base::grepl
[10:33:12.448]                           restarts <- computeRestarts(cond)
[10:33:12.448]                           for (restart in restarts) {
[10:33:12.448]                             name <- restart$name
[10:33:12.448]                             if (is.null(name)) 
[10:33:12.448]                               next
[10:33:12.448]                             if (!grepl(pattern, name)) 
[10:33:12.448]                               next
[10:33:12.448]                             invokeRestart(restart)
[10:33:12.448]                             muffled <- TRUE
[10:33:12.448]                             break
[10:33:12.448]                           }
[10:33:12.448]                         }
[10:33:12.448]                       }
[10:33:12.448]                       invisible(muffled)
[10:33:12.448]                     }
[10:33:12.448]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.448]                   }
[10:33:12.448]                 }
[10:33:12.448]             }
[10:33:12.448]         }))
[10:33:12.448]     }, error = function(ex) {
[10:33:12.448]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.448]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.448]                 ...future.rng), started = ...future.startTime, 
[10:33:12.448]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.448]             version = "1.8"), class = "FutureResult")
[10:33:12.448]     }, finally = {
[10:33:12.448]         if (!identical(...future.workdir, getwd())) 
[10:33:12.448]             setwd(...future.workdir)
[10:33:12.448]         {
[10:33:12.448]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.448]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.448]             }
[10:33:12.448]             base::options(...future.oldOptions)
[10:33:12.448]             if (.Platform$OS.type == "windows") {
[10:33:12.448]                 old_names <- names(...future.oldEnvVars)
[10:33:12.448]                 envs <- base::Sys.getenv()
[10:33:12.448]                 names <- names(envs)
[10:33:12.448]                 common <- intersect(names, old_names)
[10:33:12.448]                 added <- setdiff(names, old_names)
[10:33:12.448]                 removed <- setdiff(old_names, names)
[10:33:12.448]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.448]                   envs[common]]
[10:33:12.448]                 NAMES <- toupper(changed)
[10:33:12.448]                 args <- list()
[10:33:12.448]                 for (kk in seq_along(NAMES)) {
[10:33:12.448]                   name <- changed[[kk]]
[10:33:12.448]                   NAME <- NAMES[[kk]]
[10:33:12.448]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.448]                     next
[10:33:12.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.448]                 }
[10:33:12.448]                 NAMES <- toupper(added)
[10:33:12.448]                 for (kk in seq_along(NAMES)) {
[10:33:12.448]                   name <- added[[kk]]
[10:33:12.448]                   NAME <- NAMES[[kk]]
[10:33:12.448]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.448]                     next
[10:33:12.448]                   args[[name]] <- ""
[10:33:12.448]                 }
[10:33:12.448]                 NAMES <- toupper(removed)
[10:33:12.448]                 for (kk in seq_along(NAMES)) {
[10:33:12.448]                   name <- removed[[kk]]
[10:33:12.448]                   NAME <- NAMES[[kk]]
[10:33:12.448]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.448]                     next
[10:33:12.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.448]                 }
[10:33:12.448]                 if (length(args) > 0) 
[10:33:12.448]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.448]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.448]             }
[10:33:12.448]             else {
[10:33:12.448]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.448]             }
[10:33:12.448]             {
[10:33:12.448]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.448]                   0L) {
[10:33:12.448]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.448]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.448]                   base::options(opts)
[10:33:12.448]                 }
[10:33:12.448]                 {
[10:33:12.448]                   {
[10:33:12.448]                     NULL
[10:33:12.448]                     RNGkind("Mersenne-Twister")
[10:33:12.448]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.448]                       inherits = FALSE)
[10:33:12.448]                   }
[10:33:12.448]                   options(future.plan = NULL)
[10:33:12.448]                   if (is.na(NA_character_)) 
[10:33:12.448]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.448]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.448]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.448]                     .init = FALSE)
[10:33:12.448]                 }
[10:33:12.448]             }
[10:33:12.448]         }
[10:33:12.448]     })
[10:33:12.448]     if (TRUE) {
[10:33:12.448]         base::sink(type = "output", split = FALSE)
[10:33:12.448]         if (TRUE) {
[10:33:12.448]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.448]         }
[10:33:12.448]         else {
[10:33:12.448]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.448]         }
[10:33:12.448]         base::close(...future.stdout)
[10:33:12.448]         ...future.stdout <- NULL
[10:33:12.448]     }
[10:33:12.448]     ...future.result$conditions <- ...future.conditions
[10:33:12.448]     ...future.result$finished <- base::Sys.time()
[10:33:12.448]     ...future.result
[10:33:12.448] }
[10:33:12.450] assign_globals() ...
[10:33:12.450] List of 1
[10:33:12.450]  $ x: num 1
[10:33:12.450]  - attr(*, "where")=List of 1
[10:33:12.450]   ..$ x:<environment: R_EmptyEnv> 
[10:33:12.450]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.450]  - attr(*, "resolved")= logi TRUE
[10:33:12.450]  - attr(*, "total_size")= num 56
[10:33:12.450]  - attr(*, "already-done")= logi TRUE
[10:33:12.452] - copied ‘x’ to environment
[10:33:12.452] assign_globals() ... done
[10:33:12.453] plan(): Setting new future strategy stack:
[10:33:12.453] List of future strategies:
[10:33:12.453] 1. sequential:
[10:33:12.453]    - args: function (..., envir = parent.frame())
[10:33:12.453]    - tweaked: FALSE
[10:33:12.453]    - call: NULL
[10:33:12.453] plan(): nbrOfWorkers() = 1
[10:33:12.454] plan(): Setting new future strategy stack:
[10:33:12.454] List of future strategies:
[10:33:12.454] 1. sequential:
[10:33:12.454]    - args: function (..., envir = parent.frame())
[10:33:12.454]    - tweaked: FALSE
[10:33:12.454]    - call: plan(strategy)
[10:33:12.454] plan(): nbrOfWorkers() = 1
[10:33:12.455] SequentialFuture started (and completed)
[10:33:12.455] - Launch lazy future ... done
[10:33:12.455] run() for ‘SequentialFuture’ ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.455] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.455] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:12.459] - globals found: [3] ‘{’, ‘<-’, ‘x’
[10:33:12.459] Searching for globals ... DONE
[10:33:12.459] Resolving globals: TRUE
[10:33:12.459] Resolving any globals that are futures ...
[10:33:12.459] - globals: [3] ‘{’, ‘<-’, ‘x’
[10:33:12.459] Resolving any globals that are futures ... DONE
[10:33:12.459] Resolving futures part of globals (recursively) ...
[10:33:12.460] resolve() on list ...
[10:33:12.460]  recursive: 99
[10:33:12.460]  length: 1
[10:33:12.460]  elements: ‘x’
[10:33:12.460]  length: 0 (resolved future 1)
[10:33:12.460] resolve() on list ... DONE
[10:33:12.460] - globals: [1] ‘x’
[10:33:12.460] Resolving futures part of globals (recursively) ... DONE
[10:33:12.461] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[10:33:12.461] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[10:33:12.461] - globals: [1] ‘x’
[10:33:12.461] 
[10:33:12.461] getGlobalsAndPackages() ... DONE
[10:33:12.461] run() for ‘Future’ ...
[10:33:12.462] - state: ‘created’
[10:33:12.462] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:12.462] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:12.462] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:12.462]   - Field: ‘label’
[10:33:12.462]   - Field: ‘local’
[10:33:12.462]   - Field: ‘owner’
[10:33:12.462]   - Field: ‘envir’
[10:33:12.462]   - Field: ‘packages’
[10:33:12.463]   - Field: ‘gc’
[10:33:12.463]   - Field: ‘conditions’
[10:33:12.463]   - Field: ‘expr’
[10:33:12.463]   - Field: ‘uuid’
[10:33:12.463]   - Field: ‘seed’
[10:33:12.463]   - Field: ‘version’
[10:33:12.463]   - Field: ‘result’
[10:33:12.463]   - Field: ‘asynchronous’
[10:33:12.463]   - Field: ‘calls’
[10:33:12.463]   - Field: ‘globals’
[10:33:12.463]   - Field: ‘stdout’
[10:33:12.464]   - Field: ‘earlySignal’
[10:33:12.464]   - Field: ‘lazy’
[10:33:12.464]   - Field: ‘state’
[10:33:12.464] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:12.464] - Launch lazy future ...
[10:33:12.464] Packages needed by the future expression (n = 0): <none>
[10:33:12.464] Packages needed by future strategies (n = 0): <none>
[10:33:12.465] {
[10:33:12.465]     {
[10:33:12.465]         {
[10:33:12.465]             ...future.startTime <- base::Sys.time()
[10:33:12.465]             {
[10:33:12.465]                 {
[10:33:12.465]                   {
[10:33:12.465]                     base::local({
[10:33:12.465]                       has_future <- base::requireNamespace("future", 
[10:33:12.465]                         quietly = TRUE)
[10:33:12.465]                       if (has_future) {
[10:33:12.465]                         ns <- base::getNamespace("future")
[10:33:12.465]                         version <- ns[[".package"]][["version"]]
[10:33:12.465]                         if (is.null(version)) 
[10:33:12.465]                           version <- utils::packageVersion("future")
[10:33:12.465]                       }
[10:33:12.465]                       else {
[10:33:12.465]                         version <- NULL
[10:33:12.465]                       }
[10:33:12.465]                       if (!has_future || version < "1.8.0") {
[10:33:12.465]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.465]                           "", base::R.version$version.string), 
[10:33:12.465]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:12.465]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.465]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.465]                             "release", "version")], collapse = " "), 
[10:33:12.465]                           hostname = base::Sys.info()[["nodename"]])
[10:33:12.465]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.465]                           info)
[10:33:12.465]                         info <- base::paste(info, collapse = "; ")
[10:33:12.465]                         if (!has_future) {
[10:33:12.465]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.465]                             info)
[10:33:12.465]                         }
[10:33:12.465]                         else {
[10:33:12.465]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.465]                             info, version)
[10:33:12.465]                         }
[10:33:12.465]                         base::stop(msg)
[10:33:12.465]                       }
[10:33:12.465]                     })
[10:33:12.465]                   }
[10:33:12.465]                   ...future.strategy.old <- future::plan("list")
[10:33:12.465]                   options(future.plan = NULL)
[10:33:12.465]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.465]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.465]                 }
[10:33:12.465]                 ...future.workdir <- getwd()
[10:33:12.465]             }
[10:33:12.465]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.465]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.465]         }
[10:33:12.465]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.465]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:12.465]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.465]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.465]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.465]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.465]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.465]             base::names(...future.oldOptions))
[10:33:12.465]     }
[10:33:12.465]     if (FALSE) {
[10:33:12.465]     }
[10:33:12.465]     else {
[10:33:12.465]         if (TRUE) {
[10:33:12.465]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.465]                 open = "w")
[10:33:12.465]         }
[10:33:12.465]         else {
[10:33:12.465]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.465]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.465]         }
[10:33:12.465]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.465]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.465]             base::sink(type = "output", split = FALSE)
[10:33:12.465]             base::close(...future.stdout)
[10:33:12.465]         }, add = TRUE)
[10:33:12.465]     }
[10:33:12.465]     ...future.frame <- base::sys.nframe()
[10:33:12.465]     ...future.conditions <- base::list()
[10:33:12.465]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.465]     if (FALSE) {
[10:33:12.465]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.465]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.465]     }
[10:33:12.465]     ...future.result <- base::tryCatch({
[10:33:12.465]         base::withCallingHandlers({
[10:33:12.465]             ...future.value <- base::withVisible(base::local({
[10:33:12.465]                 x <- x()
[10:33:12.465]                 x
[10:33:12.465]             }))
[10:33:12.465]             future::FutureResult(value = ...future.value$value, 
[10:33:12.465]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.465]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.465]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.465]                     ...future.globalenv.names))
[10:33:12.465]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.465]         }, condition = base::local({
[10:33:12.465]             c <- base::c
[10:33:12.465]             inherits <- base::inherits
[10:33:12.465]             invokeRestart <- base::invokeRestart
[10:33:12.465]             length <- base::length
[10:33:12.465]             list <- base::list
[10:33:12.465]             seq.int <- base::seq.int
[10:33:12.465]             signalCondition <- base::signalCondition
[10:33:12.465]             sys.calls <- base::sys.calls
[10:33:12.465]             `[[` <- base::`[[`
[10:33:12.465]             `+` <- base::`+`
[10:33:12.465]             `<<-` <- base::`<<-`
[10:33:12.465]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.465]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.465]                   3L)]
[10:33:12.465]             }
[10:33:12.465]             function(cond) {
[10:33:12.465]                 is_error <- inherits(cond, "error")
[10:33:12.465]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.465]                   NULL)
[10:33:12.465]                 if (is_error) {
[10:33:12.465]                   sessionInformation <- function() {
[10:33:12.465]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.465]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.465]                       search = base::search(), system = base::Sys.info())
[10:33:12.465]                   }
[10:33:12.465]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.465]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.465]                     cond$call), session = sessionInformation(), 
[10:33:12.465]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.465]                   signalCondition(cond)
[10:33:12.465]                 }
[10:33:12.465]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.465]                 "immediateCondition"))) {
[10:33:12.465]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.465]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.465]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.465]                   if (TRUE && !signal) {
[10:33:12.465]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.465]                     {
[10:33:12.465]                       inherits <- base::inherits
[10:33:12.465]                       invokeRestart <- base::invokeRestart
[10:33:12.465]                       is.null <- base::is.null
[10:33:12.465]                       muffled <- FALSE
[10:33:12.465]                       if (inherits(cond, "message")) {
[10:33:12.465]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.465]                         if (muffled) 
[10:33:12.465]                           invokeRestart("muffleMessage")
[10:33:12.465]                       }
[10:33:12.465]                       else if (inherits(cond, "warning")) {
[10:33:12.465]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.465]                         if (muffled) 
[10:33:12.465]                           invokeRestart("muffleWarning")
[10:33:12.465]                       }
[10:33:12.465]                       else if (inherits(cond, "condition")) {
[10:33:12.465]                         if (!is.null(pattern)) {
[10:33:12.465]                           computeRestarts <- base::computeRestarts
[10:33:12.465]                           grepl <- base::grepl
[10:33:12.465]                           restarts <- computeRestarts(cond)
[10:33:12.465]                           for (restart in restarts) {
[10:33:12.465]                             name <- restart$name
[10:33:12.465]                             if (is.null(name)) 
[10:33:12.465]                               next
[10:33:12.465]                             if (!grepl(pattern, name)) 
[10:33:12.465]                               next
[10:33:12.465]                             invokeRestart(restart)
[10:33:12.465]                             muffled <- TRUE
[10:33:12.465]                             break
[10:33:12.465]                           }
[10:33:12.465]                         }
[10:33:12.465]                       }
[10:33:12.465]                       invisible(muffled)
[10:33:12.465]                     }
[10:33:12.465]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.465]                   }
[10:33:12.465]                 }
[10:33:12.465]                 else {
[10:33:12.465]                   if (TRUE) {
[10:33:12.465]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.465]                     {
[10:33:12.465]                       inherits <- base::inherits
[10:33:12.465]                       invokeRestart <- base::invokeRestart
[10:33:12.465]                       is.null <- base::is.null
[10:33:12.465]                       muffled <- FALSE
[10:33:12.465]                       if (inherits(cond, "message")) {
[10:33:12.465]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.465]                         if (muffled) 
[10:33:12.465]                           invokeRestart("muffleMessage")
[10:33:12.465]                       }
[10:33:12.465]                       else if (inherits(cond, "warning")) {
[10:33:12.465]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.465]                         if (muffled) 
[10:33:12.465]                           invokeRestart("muffleWarning")
[10:33:12.465]                       }
[10:33:12.465]                       else if (inherits(cond, "condition")) {
[10:33:12.465]                         if (!is.null(pattern)) {
[10:33:12.465]                           computeRestarts <- base::computeRestarts
[10:33:12.465]                           grepl <- base::grepl
[10:33:12.465]                           restarts <- computeRestarts(cond)
[10:33:12.465]                           for (restart in restarts) {
[10:33:12.465]                             name <- restart$name
[10:33:12.465]                             if (is.null(name)) 
[10:33:12.465]                               next
[10:33:12.465]                             if (!grepl(pattern, name)) 
[10:33:12.465]                               next
[10:33:12.465]                             invokeRestart(restart)
[10:33:12.465]                             muffled <- TRUE
[10:33:12.465]                             break
[10:33:12.465]                           }
[10:33:12.465]                         }
[10:33:12.465]                       }
[10:33:12.465]                       invisible(muffled)
[10:33:12.465]                     }
[10:33:12.465]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.465]                   }
[10:33:12.465]                 }
[10:33:12.465]             }
[10:33:12.465]         }))
[10:33:12.465]     }, error = function(ex) {
[10:33:12.465]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.465]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.465]                 ...future.rng), started = ...future.startTime, 
[10:33:12.465]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.465]             version = "1.8"), class = "FutureResult")
[10:33:12.465]     }, finally = {
[10:33:12.465]         if (!identical(...future.workdir, getwd())) 
[10:33:12.465]             setwd(...future.workdir)
[10:33:12.465]         {
[10:33:12.465]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.465]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.465]             }
[10:33:12.465]             base::options(...future.oldOptions)
[10:33:12.465]             if (.Platform$OS.type == "windows") {
[10:33:12.465]                 old_names <- names(...future.oldEnvVars)
[10:33:12.465]                 envs <- base::Sys.getenv()
[10:33:12.465]                 names <- names(envs)
[10:33:12.465]                 common <- intersect(names, old_names)
[10:33:12.465]                 added <- setdiff(names, old_names)
[10:33:12.465]                 removed <- setdiff(old_names, names)
[10:33:12.465]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.465]                   envs[common]]
[10:33:12.465]                 NAMES <- toupper(changed)
[10:33:12.465]                 args <- list()
[10:33:12.465]                 for (kk in seq_along(NAMES)) {
[10:33:12.465]                   name <- changed[[kk]]
[10:33:12.465]                   NAME <- NAMES[[kk]]
[10:33:12.465]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.465]                     next
[10:33:12.465]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.465]                 }
[10:33:12.465]                 NAMES <- toupper(added)
[10:33:12.465]                 for (kk in seq_along(NAMES)) {
[10:33:12.465]                   name <- added[[kk]]
[10:33:12.465]                   NAME <- NAMES[[kk]]
[10:33:12.465]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.465]                     next
[10:33:12.465]                   args[[name]] <- ""
[10:33:12.465]                 }
[10:33:12.465]                 NAMES <- toupper(removed)
[10:33:12.465]                 for (kk in seq_along(NAMES)) {
[10:33:12.465]                   name <- removed[[kk]]
[10:33:12.465]                   NAME <- NAMES[[kk]]
[10:33:12.465]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.465]                     next
[10:33:12.465]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.465]                 }
[10:33:12.465]                 if (length(args) > 0) 
[10:33:12.465]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.465]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.465]             }
[10:33:12.465]             else {
[10:33:12.465]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.465]             }
[10:33:12.465]             {
[10:33:12.465]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.465]                   0L) {
[10:33:12.465]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.465]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.465]                   base::options(opts)
[10:33:12.465]                 }
[10:33:12.465]                 {
[10:33:12.465]                   {
[10:33:12.465]                     NULL
[10:33:12.465]                     RNGkind("Mersenne-Twister")
[10:33:12.465]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:12.465]                       inherits = FALSE)
[10:33:12.465]                   }
[10:33:12.465]                   options(future.plan = NULL)
[10:33:12.465]                   if (is.na(NA_character_)) 
[10:33:12.465]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.465]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.465]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.465]                     .init = FALSE)
[10:33:12.465]                 }
[10:33:12.465]             }
[10:33:12.465]         }
[10:33:12.465]     })
[10:33:12.465]     if (TRUE) {
[10:33:12.465]         base::sink(type = "output", split = FALSE)
[10:33:12.465]         if (TRUE) {
[10:33:12.465]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.465]         }
[10:33:12.465]         else {
[10:33:12.465]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.465]         }
[10:33:12.465]         base::close(...future.stdout)
[10:33:12.465]         ...future.stdout <- NULL
[10:33:12.465]     }
[10:33:12.465]     ...future.result$conditions <- ...future.conditions
[10:33:12.465]     ...future.result$finished <- base::Sys.time()
[10:33:12.465]     ...future.result
[10:33:12.465] }
[10:33:12.466] assign_globals() ...
[10:33:12.466] List of 1
[10:33:12.466]  $ x:function ()  
[10:33:12.466]  - attr(*, "where")=List of 1
[10:33:12.466]   ..$ x:<environment: R_EmptyEnv> 
[10:33:12.466]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.466]  - attr(*, "resolved")= logi TRUE
[10:33:12.466]  - attr(*, "total_size")= num 1032
[10:33:12.466]  - attr(*, "already-done")= logi TRUE
[10:33:12.469] - reassign environment for ‘x’
[10:33:12.469] - copied ‘x’ to environment
[10:33:12.469] assign_globals() ... done
[10:33:12.469] plan(): Setting new future strategy stack:
[10:33:12.469] List of future strategies:
[10:33:12.469] 1. sequential:
[10:33:12.469]    - args: function (..., envir = parent.frame())
[10:33:12.469]    - tweaked: FALSE
[10:33:12.469]    - call: NULL
[10:33:12.469] plan(): nbrOfWorkers() = 1
[10:33:12.470] plan(): Setting new future strategy stack:
[10:33:12.470] List of future strategies:
[10:33:12.470] 1. sequential:
[10:33:12.470]    - args: function (..., envir = parent.frame())
[10:33:12.470]    - tweaked: FALSE
[10:33:12.470]    - call: plan(strategy)
[10:33:12.471] plan(): nbrOfWorkers() = 1
[10:33:12.471] SequentialFuture started (and completed)
[10:33:12.471] - Launch lazy future ... done
[10:33:12.471] run() for ‘SequentialFuture’ ... done
value(f) = ‘TRUE’
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- Local variables with the same name as globals ...
- plan('multicore') ...
[10:33:12.480] plan(): Setting new future strategy stack:
[10:33:12.480] List of future strategies:
[10:33:12.480] 1. multicore:
[10:33:12.480]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:12.480]    - tweaked: FALSE
[10:33:12.480]    - call: plan(strategy)
[10:33:12.484] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.484] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.484] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.486] - globals found: [3] ‘{’, ‘<-’, ‘*’
[10:33:12.486] Searching for globals ... DONE
[10:33:12.486] Resolving globals: TRUE
[10:33:12.486] Resolving any globals that are futures ...
[10:33:12.487] - globals: [3] ‘{’, ‘<-’, ‘*’
[10:33:12.487] Resolving any globals that are futures ... DONE
[10:33:12.488] 
[10:33:12.488] 
[10:33:12.488] getGlobalsAndPackages() ... DONE
[10:33:12.488] run() for ‘Future’ ...
[10:33:12.488] - state: ‘created’
[10:33:12.488] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:12.492] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:12.492] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:12.492]   - Field: ‘label’
[10:33:12.492]   - Field: ‘local’
[10:33:12.492]   - Field: ‘owner’
[10:33:12.493]   - Field: ‘envir’
[10:33:12.493]   - Field: ‘workers’
[10:33:12.493]   - Field: ‘packages’
[10:33:12.493]   - Field: ‘gc’
[10:33:12.493]   - Field: ‘job’
[10:33:12.493]   - Field: ‘conditions’
[10:33:12.493]   - Field: ‘expr’
[10:33:12.493]   - Field: ‘uuid’
[10:33:12.493]   - Field: ‘seed’
[10:33:12.493]   - Field: ‘version’
[10:33:12.494]   - Field: ‘result’
[10:33:12.494]   - Field: ‘asynchronous’
[10:33:12.494]   - Field: ‘calls’
[10:33:12.494]   - Field: ‘globals’
[10:33:12.494]   - Field: ‘stdout’
[10:33:12.494]   - Field: ‘earlySignal’
[10:33:12.494]   - Field: ‘lazy’
[10:33:12.494]   - Field: ‘state’
[10:33:12.494] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:12.494] - Launch lazy future ...
[10:33:12.495] Packages needed by the future expression (n = 0): <none>
[10:33:12.495] Packages needed by future strategies (n = 0): <none>
[10:33:12.496] {
[10:33:12.496]     {
[10:33:12.496]         {
[10:33:12.496]             ...future.startTime <- base::Sys.time()
[10:33:12.496]             {
[10:33:12.496]                 {
[10:33:12.496]                   {
[10:33:12.496]                     {
[10:33:12.496]                       base::local({
[10:33:12.496]                         has_future <- base::requireNamespace("future", 
[10:33:12.496]                           quietly = TRUE)
[10:33:12.496]                         if (has_future) {
[10:33:12.496]                           ns <- base::getNamespace("future")
[10:33:12.496]                           version <- ns[[".package"]][["version"]]
[10:33:12.496]                           if (is.null(version)) 
[10:33:12.496]                             version <- utils::packageVersion("future")
[10:33:12.496]                         }
[10:33:12.496]                         else {
[10:33:12.496]                           version <- NULL
[10:33:12.496]                         }
[10:33:12.496]                         if (!has_future || version < "1.8.0") {
[10:33:12.496]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.496]                             "", base::R.version$version.string), 
[10:33:12.496]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:12.496]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.496]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.496]                               "release", "version")], collapse = " "), 
[10:33:12.496]                             hostname = base::Sys.info()[["nodename"]])
[10:33:12.496]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.496]                             info)
[10:33:12.496]                           info <- base::paste(info, collapse = "; ")
[10:33:12.496]                           if (!has_future) {
[10:33:12.496]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.496]                               info)
[10:33:12.496]                           }
[10:33:12.496]                           else {
[10:33:12.496]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.496]                               info, version)
[10:33:12.496]                           }
[10:33:12.496]                           base::stop(msg)
[10:33:12.496]                         }
[10:33:12.496]                       })
[10:33:12.496]                     }
[10:33:12.496]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:12.496]                     base::options(mc.cores = 1L)
[10:33:12.496]                   }
[10:33:12.496]                   ...future.strategy.old <- future::plan("list")
[10:33:12.496]                   options(future.plan = NULL)
[10:33:12.496]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.496]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.496]                 }
[10:33:12.496]                 ...future.workdir <- getwd()
[10:33:12.496]             }
[10:33:12.496]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.496]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.496]         }
[10:33:12.496]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.496]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.496]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.496]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.496]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.496]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.496]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.496]             base::names(...future.oldOptions))
[10:33:12.496]     }
[10:33:12.496]     if (FALSE) {
[10:33:12.496]     }
[10:33:12.496]     else {
[10:33:12.496]         if (TRUE) {
[10:33:12.496]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.496]                 open = "w")
[10:33:12.496]         }
[10:33:12.496]         else {
[10:33:12.496]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.496]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.496]         }
[10:33:12.496]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.496]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.496]             base::sink(type = "output", split = FALSE)
[10:33:12.496]             base::close(...future.stdout)
[10:33:12.496]         }, add = TRUE)
[10:33:12.496]     }
[10:33:12.496]     ...future.frame <- base::sys.nframe()
[10:33:12.496]     ...future.conditions <- base::list()
[10:33:12.496]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.496]     if (FALSE) {
[10:33:12.496]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.496]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.496]     }
[10:33:12.496]     ...future.result <- base::tryCatch({
[10:33:12.496]         base::withCallingHandlers({
[10:33:12.496]             ...future.value <- base::withVisible(base::local({
[10:33:12.496]                 withCallingHandlers({
[10:33:12.496]                   {
[10:33:12.496]                     b <- a
[10:33:12.496]                     a <- 2
[10:33:12.496]                     a * b
[10:33:12.496]                   }
[10:33:12.496]                 }, immediateCondition = function(cond) {
[10:33:12.496]                   save_rds <- function (object, pathname, ...) 
[10:33:12.496]                   {
[10:33:12.496]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:12.496]                     if (file_test("-f", pathname_tmp)) {
[10:33:12.496]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.496]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:12.496]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.496]                         fi_tmp[["mtime"]])
[10:33:12.496]                     }
[10:33:12.496]                     tryCatch({
[10:33:12.496]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:12.496]                     }, error = function(ex) {
[10:33:12.496]                       msg <- conditionMessage(ex)
[10:33:12.496]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.496]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:12.496]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.496]                         fi_tmp[["mtime"]], msg)
[10:33:12.496]                       ex$message <- msg
[10:33:12.496]                       stop(ex)
[10:33:12.496]                     })
[10:33:12.496]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:12.496]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:12.496]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:12.496]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.496]                       fi <- file.info(pathname)
[10:33:12.496]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:12.496]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.496]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:12.496]                         fi[["size"]], fi[["mtime"]])
[10:33:12.496]                       stop(msg)
[10:33:12.496]                     }
[10:33:12.496]                     invisible(pathname)
[10:33:12.496]                   }
[10:33:12.496]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:12.496]                     rootPath = tempdir()) 
[10:33:12.496]                   {
[10:33:12.496]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:12.496]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:12.496]                       tmpdir = path, fileext = ".rds")
[10:33:12.496]                     save_rds(obj, file)
[10:33:12.496]                   }
[10:33:12.496]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:12.496]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.496]                   {
[10:33:12.496]                     inherits <- base::inherits
[10:33:12.496]                     invokeRestart <- base::invokeRestart
[10:33:12.496]                     is.null <- base::is.null
[10:33:12.496]                     muffled <- FALSE
[10:33:12.496]                     if (inherits(cond, "message")) {
[10:33:12.496]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:12.496]                       if (muffled) 
[10:33:12.496]                         invokeRestart("muffleMessage")
[10:33:12.496]                     }
[10:33:12.496]                     else if (inherits(cond, "warning")) {
[10:33:12.496]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:12.496]                       if (muffled) 
[10:33:12.496]                         invokeRestart("muffleWarning")
[10:33:12.496]                     }
[10:33:12.496]                     else if (inherits(cond, "condition")) {
[10:33:12.496]                       if (!is.null(pattern)) {
[10:33:12.496]                         computeRestarts <- base::computeRestarts
[10:33:12.496]                         grepl <- base::grepl
[10:33:12.496]                         restarts <- computeRestarts(cond)
[10:33:12.496]                         for (restart in restarts) {
[10:33:12.496]                           name <- restart$name
[10:33:12.496]                           if (is.null(name)) 
[10:33:12.496]                             next
[10:33:12.496]                           if (!grepl(pattern, name)) 
[10:33:12.496]                             next
[10:33:12.496]                           invokeRestart(restart)
[10:33:12.496]                           muffled <- TRUE
[10:33:12.496]                           break
[10:33:12.496]                         }
[10:33:12.496]                       }
[10:33:12.496]                     }
[10:33:12.496]                     invisible(muffled)
[10:33:12.496]                   }
[10:33:12.496]                   muffleCondition(cond)
[10:33:12.496]                 })
[10:33:12.496]             }))
[10:33:12.496]             future::FutureResult(value = ...future.value$value, 
[10:33:12.496]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.496]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.496]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.496]                     ...future.globalenv.names))
[10:33:12.496]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.496]         }, condition = base::local({
[10:33:12.496]             c <- base::c
[10:33:12.496]             inherits <- base::inherits
[10:33:12.496]             invokeRestart <- base::invokeRestart
[10:33:12.496]             length <- base::length
[10:33:12.496]             list <- base::list
[10:33:12.496]             seq.int <- base::seq.int
[10:33:12.496]             signalCondition <- base::signalCondition
[10:33:12.496]             sys.calls <- base::sys.calls
[10:33:12.496]             `[[` <- base::`[[`
[10:33:12.496]             `+` <- base::`+`
[10:33:12.496]             `<<-` <- base::`<<-`
[10:33:12.496]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.496]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.496]                   3L)]
[10:33:12.496]             }
[10:33:12.496]             function(cond) {
[10:33:12.496]                 is_error <- inherits(cond, "error")
[10:33:12.496]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.496]                   NULL)
[10:33:12.496]                 if (is_error) {
[10:33:12.496]                   sessionInformation <- function() {
[10:33:12.496]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.496]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.496]                       search = base::search(), system = base::Sys.info())
[10:33:12.496]                   }
[10:33:12.496]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.496]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.496]                     cond$call), session = sessionInformation(), 
[10:33:12.496]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.496]                   signalCondition(cond)
[10:33:12.496]                 }
[10:33:12.496]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.496]                 "immediateCondition"))) {
[10:33:12.496]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.496]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.496]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.496]                   if (TRUE && !signal) {
[10:33:12.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.496]                     {
[10:33:12.496]                       inherits <- base::inherits
[10:33:12.496]                       invokeRestart <- base::invokeRestart
[10:33:12.496]                       is.null <- base::is.null
[10:33:12.496]                       muffled <- FALSE
[10:33:12.496]                       if (inherits(cond, "message")) {
[10:33:12.496]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.496]                         if (muffled) 
[10:33:12.496]                           invokeRestart("muffleMessage")
[10:33:12.496]                       }
[10:33:12.496]                       else if (inherits(cond, "warning")) {
[10:33:12.496]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.496]                         if (muffled) 
[10:33:12.496]                           invokeRestart("muffleWarning")
[10:33:12.496]                       }
[10:33:12.496]                       else if (inherits(cond, "condition")) {
[10:33:12.496]                         if (!is.null(pattern)) {
[10:33:12.496]                           computeRestarts <- base::computeRestarts
[10:33:12.496]                           grepl <- base::grepl
[10:33:12.496]                           restarts <- computeRestarts(cond)
[10:33:12.496]                           for (restart in restarts) {
[10:33:12.496]                             name <- restart$name
[10:33:12.496]                             if (is.null(name)) 
[10:33:12.496]                               next
[10:33:12.496]                             if (!grepl(pattern, name)) 
[10:33:12.496]                               next
[10:33:12.496]                             invokeRestart(restart)
[10:33:12.496]                             muffled <- TRUE
[10:33:12.496]                             break
[10:33:12.496]                           }
[10:33:12.496]                         }
[10:33:12.496]                       }
[10:33:12.496]                       invisible(muffled)
[10:33:12.496]                     }
[10:33:12.496]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.496]                   }
[10:33:12.496]                 }
[10:33:12.496]                 else {
[10:33:12.496]                   if (TRUE) {
[10:33:12.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.496]                     {
[10:33:12.496]                       inherits <- base::inherits
[10:33:12.496]                       invokeRestart <- base::invokeRestart
[10:33:12.496]                       is.null <- base::is.null
[10:33:12.496]                       muffled <- FALSE
[10:33:12.496]                       if (inherits(cond, "message")) {
[10:33:12.496]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.496]                         if (muffled) 
[10:33:12.496]                           invokeRestart("muffleMessage")
[10:33:12.496]                       }
[10:33:12.496]                       else if (inherits(cond, "warning")) {
[10:33:12.496]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.496]                         if (muffled) 
[10:33:12.496]                           invokeRestart("muffleWarning")
[10:33:12.496]                       }
[10:33:12.496]                       else if (inherits(cond, "condition")) {
[10:33:12.496]                         if (!is.null(pattern)) {
[10:33:12.496]                           computeRestarts <- base::computeRestarts
[10:33:12.496]                           grepl <- base::grepl
[10:33:12.496]                           restarts <- computeRestarts(cond)
[10:33:12.496]                           for (restart in restarts) {
[10:33:12.496]                             name <- restart$name
[10:33:12.496]                             if (is.null(name)) 
[10:33:12.496]                               next
[10:33:12.496]                             if (!grepl(pattern, name)) 
[10:33:12.496]                               next
[10:33:12.496]                             invokeRestart(restart)
[10:33:12.496]                             muffled <- TRUE
[10:33:12.496]                             break
[10:33:12.496]                           }
[10:33:12.496]                         }
[10:33:12.496]                       }
[10:33:12.496]                       invisible(muffled)
[10:33:12.496]                     }
[10:33:12.496]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.496]                   }
[10:33:12.496]                 }
[10:33:12.496]             }
[10:33:12.496]         }))
[10:33:12.496]     }, error = function(ex) {
[10:33:12.496]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.496]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.496]                 ...future.rng), started = ...future.startTime, 
[10:33:12.496]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.496]             version = "1.8"), class = "FutureResult")
[10:33:12.496]     }, finally = {
[10:33:12.496]         if (!identical(...future.workdir, getwd())) 
[10:33:12.496]             setwd(...future.workdir)
[10:33:12.496]         {
[10:33:12.496]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.496]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.496]             }
[10:33:12.496]             base::options(...future.oldOptions)
[10:33:12.496]             if (.Platform$OS.type == "windows") {
[10:33:12.496]                 old_names <- names(...future.oldEnvVars)
[10:33:12.496]                 envs <- base::Sys.getenv()
[10:33:12.496]                 names <- names(envs)
[10:33:12.496]                 common <- intersect(names, old_names)
[10:33:12.496]                 added <- setdiff(names, old_names)
[10:33:12.496]                 removed <- setdiff(old_names, names)
[10:33:12.496]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.496]                   envs[common]]
[10:33:12.496]                 NAMES <- toupper(changed)
[10:33:12.496]                 args <- list()
[10:33:12.496]                 for (kk in seq_along(NAMES)) {
[10:33:12.496]                   name <- changed[[kk]]
[10:33:12.496]                   NAME <- NAMES[[kk]]
[10:33:12.496]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.496]                     next
[10:33:12.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.496]                 }
[10:33:12.496]                 NAMES <- toupper(added)
[10:33:12.496]                 for (kk in seq_along(NAMES)) {
[10:33:12.496]                   name <- added[[kk]]
[10:33:12.496]                   NAME <- NAMES[[kk]]
[10:33:12.496]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.496]                     next
[10:33:12.496]                   args[[name]] <- ""
[10:33:12.496]                 }
[10:33:12.496]                 NAMES <- toupper(removed)
[10:33:12.496]                 for (kk in seq_along(NAMES)) {
[10:33:12.496]                   name <- removed[[kk]]
[10:33:12.496]                   NAME <- NAMES[[kk]]
[10:33:12.496]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.496]                     next
[10:33:12.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.496]                 }
[10:33:12.496]                 if (length(args) > 0) 
[10:33:12.496]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.496]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.496]             }
[10:33:12.496]             else {
[10:33:12.496]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.496]             }
[10:33:12.496]             {
[10:33:12.496]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.496]                   0L) {
[10:33:12.496]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.496]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.496]                   base::options(opts)
[10:33:12.496]                 }
[10:33:12.496]                 {
[10:33:12.496]                   {
[10:33:12.496]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:12.496]                     NULL
[10:33:12.496]                   }
[10:33:12.496]                   options(future.plan = NULL)
[10:33:12.496]                   if (is.na(NA_character_)) 
[10:33:12.496]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.496]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.496]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.496]                     .init = FALSE)
[10:33:12.496]                 }
[10:33:12.496]             }
[10:33:12.496]         }
[10:33:12.496]     })
[10:33:12.496]     if (TRUE) {
[10:33:12.496]         base::sink(type = "output", split = FALSE)
[10:33:12.496]         if (TRUE) {
[10:33:12.496]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.496]         }
[10:33:12.496]         else {
[10:33:12.496]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.496]         }
[10:33:12.496]         base::close(...future.stdout)
[10:33:12.496]         ...future.stdout <- NULL
[10:33:12.496]     }
[10:33:12.496]     ...future.result$conditions <- ...future.conditions
[10:33:12.496]     ...future.result$finished <- base::Sys.time()
[10:33:12.496]     ...future.result
[10:33:12.496] }
[10:33:12.498] requestCore(): workers = 2
[10:33:12.501] MulticoreFuture started
[10:33:12.502] - Launch lazy future ... done
[10:33:12.502] run() for ‘MulticoreFuture’ ... done
[10:33:12.502] plan(): Setting new future strategy stack:
[10:33:12.502] List of future strategies:
[10:33:12.502] 1. sequential:
[10:33:12.502]    - args: function (..., envir = parent.frame())
[10:33:12.502]    - tweaked: FALSE
[10:33:12.502]    - call: NULL
[10:33:12.503] plan(): nbrOfWorkers() = 1
[10:33:12.503] result() for MulticoreFuture ...
[10:33:12.505] plan(): Setting new future strategy stack:
[10:33:12.505] List of future strategies:
[10:33:12.505] 1. multicore:
[10:33:12.505]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:12.505]    - tweaked: FALSE
[10:33:12.505]    - call: plan(strategy)
[10:33:12.510] plan(): nbrOfWorkers() = 2
[10:33:12.515] result() for MulticoreFuture ...
[10:33:12.515] result() for MulticoreFuture ... done
[10:33:12.515] result() for MulticoreFuture ... done
[10:33:12.515] result() for MulticoreFuture ...
[10:33:12.515] result() for MulticoreFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.516] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.516] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.518] - globals found: [3] ‘{’, ‘<-’, ‘*’
[10:33:12.518] Searching for globals ... DONE
[10:33:12.518] Resolving globals: TRUE
[10:33:12.518] Resolving any globals that are futures ...
[10:33:12.518] - globals: [3] ‘{’, ‘<-’, ‘*’
[10:33:12.518] Resolving any globals that are futures ... DONE
[10:33:12.519] 
[10:33:12.519] 
[10:33:12.519] getGlobalsAndPackages() ... DONE
[10:33:12.519] run() for ‘Future’ ...
[10:33:12.520] - state: ‘created’
[10:33:12.520] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:12.524] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:12.524] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:12.524]   - Field: ‘label’
[10:33:12.524]   - Field: ‘local’
[10:33:12.525]   - Field: ‘owner’
[10:33:12.525]   - Field: ‘envir’
[10:33:12.525]   - Field: ‘workers’
[10:33:12.525]   - Field: ‘packages’
[10:33:12.525]   - Field: ‘gc’
[10:33:12.525]   - Field: ‘job’
[10:33:12.525]   - Field: ‘conditions’
[10:33:12.526]   - Field: ‘expr’
[10:33:12.526]   - Field: ‘uuid’
[10:33:12.526]   - Field: ‘seed’
[10:33:12.526]   - Field: ‘version’
[10:33:12.526]   - Field: ‘result’
[10:33:12.526]   - Field: ‘asynchronous’
[10:33:12.526]   - Field: ‘calls’
[10:33:12.526]   - Field: ‘globals’
[10:33:12.526]   - Field: ‘stdout’
[10:33:12.527]   - Field: ‘earlySignal’
[10:33:12.527]   - Field: ‘lazy’
[10:33:12.527]   - Field: ‘state’
[10:33:12.527] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:12.527] - Launch lazy future ...
[10:33:12.527] Packages needed by the future expression (n = 0): <none>
[10:33:12.528] Packages needed by future strategies (n = 0): <none>
[10:33:12.528] {
[10:33:12.528]     {
[10:33:12.528]         {
[10:33:12.528]             ...future.startTime <- base::Sys.time()
[10:33:12.528]             {
[10:33:12.528]                 {
[10:33:12.528]                   {
[10:33:12.528]                     {
[10:33:12.528]                       base::local({
[10:33:12.528]                         has_future <- base::requireNamespace("future", 
[10:33:12.528]                           quietly = TRUE)
[10:33:12.528]                         if (has_future) {
[10:33:12.528]                           ns <- base::getNamespace("future")
[10:33:12.528]                           version <- ns[[".package"]][["version"]]
[10:33:12.528]                           if (is.null(version)) 
[10:33:12.528]                             version <- utils::packageVersion("future")
[10:33:12.528]                         }
[10:33:12.528]                         else {
[10:33:12.528]                           version <- NULL
[10:33:12.528]                         }
[10:33:12.528]                         if (!has_future || version < "1.8.0") {
[10:33:12.528]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.528]                             "", base::R.version$version.string), 
[10:33:12.528]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:12.528]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.528]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.528]                               "release", "version")], collapse = " "), 
[10:33:12.528]                             hostname = base::Sys.info()[["nodename"]])
[10:33:12.528]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.528]                             info)
[10:33:12.528]                           info <- base::paste(info, collapse = "; ")
[10:33:12.528]                           if (!has_future) {
[10:33:12.528]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.528]                               info)
[10:33:12.528]                           }
[10:33:12.528]                           else {
[10:33:12.528]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.528]                               info, version)
[10:33:12.528]                           }
[10:33:12.528]                           base::stop(msg)
[10:33:12.528]                         }
[10:33:12.528]                       })
[10:33:12.528]                     }
[10:33:12.528]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:12.528]                     base::options(mc.cores = 1L)
[10:33:12.528]                   }
[10:33:12.528]                   ...future.strategy.old <- future::plan("list")
[10:33:12.528]                   options(future.plan = NULL)
[10:33:12.528]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.528]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.528]                 }
[10:33:12.528]                 ...future.workdir <- getwd()
[10:33:12.528]             }
[10:33:12.528]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.528]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.528]         }
[10:33:12.528]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.528]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.528]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.528]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.528]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.528]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.528]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.528]             base::names(...future.oldOptions))
[10:33:12.528]     }
[10:33:12.528]     if (FALSE) {
[10:33:12.528]     }
[10:33:12.528]     else {
[10:33:12.528]         if (TRUE) {
[10:33:12.528]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.528]                 open = "w")
[10:33:12.528]         }
[10:33:12.528]         else {
[10:33:12.528]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.528]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.528]         }
[10:33:12.528]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.528]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.528]             base::sink(type = "output", split = FALSE)
[10:33:12.528]             base::close(...future.stdout)
[10:33:12.528]         }, add = TRUE)
[10:33:12.528]     }
[10:33:12.528]     ...future.frame <- base::sys.nframe()
[10:33:12.528]     ...future.conditions <- base::list()
[10:33:12.528]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.528]     if (FALSE) {
[10:33:12.528]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.528]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.528]     }
[10:33:12.528]     ...future.result <- base::tryCatch({
[10:33:12.528]         base::withCallingHandlers({
[10:33:12.528]             ...future.value <- base::withVisible(base::local({
[10:33:12.528]                 withCallingHandlers({
[10:33:12.528]                   {
[10:33:12.528]                     b <- a
[10:33:12.528]                     a <- 2
[10:33:12.528]                     a * b
[10:33:12.528]                   }
[10:33:12.528]                 }, immediateCondition = function(cond) {
[10:33:12.528]                   save_rds <- function (object, pathname, ...) 
[10:33:12.528]                   {
[10:33:12.528]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:12.528]                     if (file_test("-f", pathname_tmp)) {
[10:33:12.528]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.528]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:12.528]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.528]                         fi_tmp[["mtime"]])
[10:33:12.528]                     }
[10:33:12.528]                     tryCatch({
[10:33:12.528]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:12.528]                     }, error = function(ex) {
[10:33:12.528]                       msg <- conditionMessage(ex)
[10:33:12.528]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.528]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:12.528]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.528]                         fi_tmp[["mtime"]], msg)
[10:33:12.528]                       ex$message <- msg
[10:33:12.528]                       stop(ex)
[10:33:12.528]                     })
[10:33:12.528]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:12.528]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:12.528]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:12.528]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.528]                       fi <- file.info(pathname)
[10:33:12.528]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:12.528]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.528]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:12.528]                         fi[["size"]], fi[["mtime"]])
[10:33:12.528]                       stop(msg)
[10:33:12.528]                     }
[10:33:12.528]                     invisible(pathname)
[10:33:12.528]                   }
[10:33:12.528]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:12.528]                     rootPath = tempdir()) 
[10:33:12.528]                   {
[10:33:12.528]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:12.528]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:12.528]                       tmpdir = path, fileext = ".rds")
[10:33:12.528]                     save_rds(obj, file)
[10:33:12.528]                   }
[10:33:12.528]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:12.528]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.528]                   {
[10:33:12.528]                     inherits <- base::inherits
[10:33:12.528]                     invokeRestart <- base::invokeRestart
[10:33:12.528]                     is.null <- base::is.null
[10:33:12.528]                     muffled <- FALSE
[10:33:12.528]                     if (inherits(cond, "message")) {
[10:33:12.528]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:12.528]                       if (muffled) 
[10:33:12.528]                         invokeRestart("muffleMessage")
[10:33:12.528]                     }
[10:33:12.528]                     else if (inherits(cond, "warning")) {
[10:33:12.528]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:12.528]                       if (muffled) 
[10:33:12.528]                         invokeRestart("muffleWarning")
[10:33:12.528]                     }
[10:33:12.528]                     else if (inherits(cond, "condition")) {
[10:33:12.528]                       if (!is.null(pattern)) {
[10:33:12.528]                         computeRestarts <- base::computeRestarts
[10:33:12.528]                         grepl <- base::grepl
[10:33:12.528]                         restarts <- computeRestarts(cond)
[10:33:12.528]                         for (restart in restarts) {
[10:33:12.528]                           name <- restart$name
[10:33:12.528]                           if (is.null(name)) 
[10:33:12.528]                             next
[10:33:12.528]                           if (!grepl(pattern, name)) 
[10:33:12.528]                             next
[10:33:12.528]                           invokeRestart(restart)
[10:33:12.528]                           muffled <- TRUE
[10:33:12.528]                           break
[10:33:12.528]                         }
[10:33:12.528]                       }
[10:33:12.528]                     }
[10:33:12.528]                     invisible(muffled)
[10:33:12.528]                   }
[10:33:12.528]                   muffleCondition(cond)
[10:33:12.528]                 })
[10:33:12.528]             }))
[10:33:12.528]             future::FutureResult(value = ...future.value$value, 
[10:33:12.528]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.528]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.528]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.528]                     ...future.globalenv.names))
[10:33:12.528]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.528]         }, condition = base::local({
[10:33:12.528]             c <- base::c
[10:33:12.528]             inherits <- base::inherits
[10:33:12.528]             invokeRestart <- base::invokeRestart
[10:33:12.528]             length <- base::length
[10:33:12.528]             list <- base::list
[10:33:12.528]             seq.int <- base::seq.int
[10:33:12.528]             signalCondition <- base::signalCondition
[10:33:12.528]             sys.calls <- base::sys.calls
[10:33:12.528]             `[[` <- base::`[[`
[10:33:12.528]             `+` <- base::`+`
[10:33:12.528]             `<<-` <- base::`<<-`
[10:33:12.528]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.528]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.528]                   3L)]
[10:33:12.528]             }
[10:33:12.528]             function(cond) {
[10:33:12.528]                 is_error <- inherits(cond, "error")
[10:33:12.528]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.528]                   NULL)
[10:33:12.528]                 if (is_error) {
[10:33:12.528]                   sessionInformation <- function() {
[10:33:12.528]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.528]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.528]                       search = base::search(), system = base::Sys.info())
[10:33:12.528]                   }
[10:33:12.528]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.528]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.528]                     cond$call), session = sessionInformation(), 
[10:33:12.528]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.528]                   signalCondition(cond)
[10:33:12.528]                 }
[10:33:12.528]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.528]                 "immediateCondition"))) {
[10:33:12.528]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.528]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.528]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.528]                   if (TRUE && !signal) {
[10:33:12.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.528]                     {
[10:33:12.528]                       inherits <- base::inherits
[10:33:12.528]                       invokeRestart <- base::invokeRestart
[10:33:12.528]                       is.null <- base::is.null
[10:33:12.528]                       muffled <- FALSE
[10:33:12.528]                       if (inherits(cond, "message")) {
[10:33:12.528]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.528]                         if (muffled) 
[10:33:12.528]                           invokeRestart("muffleMessage")
[10:33:12.528]                       }
[10:33:12.528]                       else if (inherits(cond, "warning")) {
[10:33:12.528]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.528]                         if (muffled) 
[10:33:12.528]                           invokeRestart("muffleWarning")
[10:33:12.528]                       }
[10:33:12.528]                       else if (inherits(cond, "condition")) {
[10:33:12.528]                         if (!is.null(pattern)) {
[10:33:12.528]                           computeRestarts <- base::computeRestarts
[10:33:12.528]                           grepl <- base::grepl
[10:33:12.528]                           restarts <- computeRestarts(cond)
[10:33:12.528]                           for (restart in restarts) {
[10:33:12.528]                             name <- restart$name
[10:33:12.528]                             if (is.null(name)) 
[10:33:12.528]                               next
[10:33:12.528]                             if (!grepl(pattern, name)) 
[10:33:12.528]                               next
[10:33:12.528]                             invokeRestart(restart)
[10:33:12.528]                             muffled <- TRUE
[10:33:12.528]                             break
[10:33:12.528]                           }
[10:33:12.528]                         }
[10:33:12.528]                       }
[10:33:12.528]                       invisible(muffled)
[10:33:12.528]                     }
[10:33:12.528]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.528]                   }
[10:33:12.528]                 }
[10:33:12.528]                 else {
[10:33:12.528]                   if (TRUE) {
[10:33:12.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.528]                     {
[10:33:12.528]                       inherits <- base::inherits
[10:33:12.528]                       invokeRestart <- base::invokeRestart
[10:33:12.528]                       is.null <- base::is.null
[10:33:12.528]                       muffled <- FALSE
[10:33:12.528]                       if (inherits(cond, "message")) {
[10:33:12.528]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.528]                         if (muffled) 
[10:33:12.528]                           invokeRestart("muffleMessage")
[10:33:12.528]                       }
[10:33:12.528]                       else if (inherits(cond, "warning")) {
[10:33:12.528]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.528]                         if (muffled) 
[10:33:12.528]                           invokeRestart("muffleWarning")
[10:33:12.528]                       }
[10:33:12.528]                       else if (inherits(cond, "condition")) {
[10:33:12.528]                         if (!is.null(pattern)) {
[10:33:12.528]                           computeRestarts <- base::computeRestarts
[10:33:12.528]                           grepl <- base::grepl
[10:33:12.528]                           restarts <- computeRestarts(cond)
[10:33:12.528]                           for (restart in restarts) {
[10:33:12.528]                             name <- restart$name
[10:33:12.528]                             if (is.null(name)) 
[10:33:12.528]                               next
[10:33:12.528]                             if (!grepl(pattern, name)) 
[10:33:12.528]                               next
[10:33:12.528]                             invokeRestart(restart)
[10:33:12.528]                             muffled <- TRUE
[10:33:12.528]                             break
[10:33:12.528]                           }
[10:33:12.528]                         }
[10:33:12.528]                       }
[10:33:12.528]                       invisible(muffled)
[10:33:12.528]                     }
[10:33:12.528]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.528]                   }
[10:33:12.528]                 }
[10:33:12.528]             }
[10:33:12.528]         }))
[10:33:12.528]     }, error = function(ex) {
[10:33:12.528]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.528]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.528]                 ...future.rng), started = ...future.startTime, 
[10:33:12.528]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.528]             version = "1.8"), class = "FutureResult")
[10:33:12.528]     }, finally = {
[10:33:12.528]         if (!identical(...future.workdir, getwd())) 
[10:33:12.528]             setwd(...future.workdir)
[10:33:12.528]         {
[10:33:12.528]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.528]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.528]             }
[10:33:12.528]             base::options(...future.oldOptions)
[10:33:12.528]             if (.Platform$OS.type == "windows") {
[10:33:12.528]                 old_names <- names(...future.oldEnvVars)
[10:33:12.528]                 envs <- base::Sys.getenv()
[10:33:12.528]                 names <- names(envs)
[10:33:12.528]                 common <- intersect(names, old_names)
[10:33:12.528]                 added <- setdiff(names, old_names)
[10:33:12.528]                 removed <- setdiff(old_names, names)
[10:33:12.528]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.528]                   envs[common]]
[10:33:12.528]                 NAMES <- toupper(changed)
[10:33:12.528]                 args <- list()
[10:33:12.528]                 for (kk in seq_along(NAMES)) {
[10:33:12.528]                   name <- changed[[kk]]
[10:33:12.528]                   NAME <- NAMES[[kk]]
[10:33:12.528]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.528]                     next
[10:33:12.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.528]                 }
[10:33:12.528]                 NAMES <- toupper(added)
[10:33:12.528]                 for (kk in seq_along(NAMES)) {
[10:33:12.528]                   name <- added[[kk]]
[10:33:12.528]                   NAME <- NAMES[[kk]]
[10:33:12.528]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.528]                     next
[10:33:12.528]                   args[[name]] <- ""
[10:33:12.528]                 }
[10:33:12.528]                 NAMES <- toupper(removed)
[10:33:12.528]                 for (kk in seq_along(NAMES)) {
[10:33:12.528]                   name <- removed[[kk]]
[10:33:12.528]                   NAME <- NAMES[[kk]]
[10:33:12.528]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.528]                     next
[10:33:12.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.528]                 }
[10:33:12.528]                 if (length(args) > 0) 
[10:33:12.528]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.528]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.528]             }
[10:33:12.528]             else {
[10:33:12.528]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.528]             }
[10:33:12.528]             {
[10:33:12.528]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.528]                   0L) {
[10:33:12.528]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.528]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.528]                   base::options(opts)
[10:33:12.528]                 }
[10:33:12.528]                 {
[10:33:12.528]                   {
[10:33:12.528]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:12.528]                     NULL
[10:33:12.528]                   }
[10:33:12.528]                   options(future.plan = NULL)
[10:33:12.528]                   if (is.na(NA_character_)) 
[10:33:12.528]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.528]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.528]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.528]                     .init = FALSE)
[10:33:12.528]                 }
[10:33:12.528]             }
[10:33:12.528]         }
[10:33:12.528]     })
[10:33:12.528]     if (TRUE) {
[10:33:12.528]         base::sink(type = "output", split = FALSE)
[10:33:12.528]         if (TRUE) {
[10:33:12.528]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.528]         }
[10:33:12.528]         else {
[10:33:12.528]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.528]         }
[10:33:12.528]         base::close(...future.stdout)
[10:33:12.528]         ...future.stdout <- NULL
[10:33:12.528]     }
[10:33:12.528]     ...future.result$conditions <- ...future.conditions
[10:33:12.528]     ...future.result$finished <- base::Sys.time()
[10:33:12.528]     ...future.result
[10:33:12.528] }
[10:33:12.531] requestCore(): workers = 2
[10:33:12.532] MulticoreFuture started
[10:33:12.533] - Launch lazy future ... done
[10:33:12.533] run() for ‘MulticoreFuture’ ... done
[10:33:12.533] result() for MulticoreFuture ...
[10:33:12.533] plan(): Setting new future strategy stack:
[10:33:12.534] List of future strategies:
[10:33:12.534] 1. sequential:
[10:33:12.534]    - args: function (..., envir = parent.frame())
[10:33:12.534]    - tweaked: FALSE
[10:33:12.534]    - call: NULL
[10:33:12.535] plan(): nbrOfWorkers() = 1
[10:33:12.537] plan(): Setting new future strategy stack:
[10:33:12.537] List of future strategies:
[10:33:12.537] 1. multicore:
[10:33:12.537]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:12.537]    - tweaked: FALSE
[10:33:12.537]    - call: plan(strategy)
[10:33:12.543] plan(): nbrOfWorkers() = 2
[10:33:12.549] result() for MulticoreFuture ...
[10:33:12.549] result() for MulticoreFuture ... done
[10:33:12.549] signalConditions() ...
[10:33:12.549]  - include = ‘immediateCondition’
[10:33:12.550]  - exclude = 
[10:33:12.550]  - resignal = FALSE
[10:33:12.550]  - Number of conditions: 1
[10:33:12.550] signalConditions() ... done
[10:33:12.550] result() for MulticoreFuture ... done
[10:33:12.550] result() for MulticoreFuture ...
[10:33:12.551] result() for MulticoreFuture ... done
[10:33:12.551] signalConditions() ...
[10:33:12.551]  - include = ‘immediateCondition’
[10:33:12.551]  - exclude = 
[10:33:12.551]  - resignal = FALSE
[10:33:12.551]  - Number of conditions: 1
[10:33:12.551] signalConditions() ... done
[10:33:12.552] Future state: ‘finished’
[10:33:12.552] result() for MulticoreFuture ...
[10:33:12.552] result() for MulticoreFuture ... done
[10:33:12.552] signalConditions() ...
[10:33:12.552]  - include = ‘condition’
[10:33:12.555]  - exclude = ‘immediateCondition’
[10:33:12.556]  - resignal = TRUE
[10:33:12.556]  - Number of conditions: 1
[10:33:12.556]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:33:12.556] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 39
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "c3bfbccbe859" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 10:33:12"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.587] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.587] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.589] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:12.590] Searching for globals ... DONE
[10:33:12.590] Resolving globals: TRUE
[10:33:12.590] Resolving any globals that are futures ...
[10:33:12.590] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:12.590] Resolving any globals that are futures ... DONE
[10:33:12.591] Resolving futures part of globals (recursively) ...
[10:33:12.591] resolve() on list ...
[10:33:12.591]  recursive: 99
[10:33:12.591]  length: 1
[10:33:12.591]  elements: ‘ii’
[10:33:12.591]  length: 0 (resolved future 1)
[10:33:12.591] resolve() on list ... DONE
[10:33:12.591] - globals: [1] ‘ii’
[10:33:12.592] Resolving futures part of globals (recursively) ... DONE
[10:33:12.592] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:12.592] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:12.592] - globals: [1] ‘ii’
[10:33:12.592] 
[10:33:12.592] getGlobalsAndPackages() ... DONE
[10:33:12.593] run() for ‘Future’ ...
[10:33:12.593] - state: ‘created’
[10:33:12.593] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:12.597] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:12.597] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:12.597]   - Field: ‘label’
[10:33:12.597]   - Field: ‘local’
[10:33:12.597]   - Field: ‘owner’
[10:33:12.598]   - Field: ‘envir’
[10:33:12.598]   - Field: ‘workers’
[10:33:12.598]   - Field: ‘packages’
[10:33:12.598]   - Field: ‘gc’
[10:33:12.598]   - Field: ‘job’
[10:33:12.598]   - Field: ‘conditions’
[10:33:12.598]   - Field: ‘expr’
[10:33:12.598]   - Field: ‘uuid’
[10:33:12.598]   - Field: ‘seed’
[10:33:12.598]   - Field: ‘version’
[10:33:12.598]   - Field: ‘result’
[10:33:12.599]   - Field: ‘asynchronous’
[10:33:12.599]   - Field: ‘calls’
[10:33:12.599]   - Field: ‘globals’
[10:33:12.599]   - Field: ‘stdout’
[10:33:12.599]   - Field: ‘earlySignal’
[10:33:12.599]   - Field: ‘lazy’
[10:33:12.599]   - Field: ‘state’
[10:33:12.599] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:12.599] - Launch lazy future ...
[10:33:12.600] Packages needed by the future expression (n = 0): <none>
[10:33:12.600] Packages needed by future strategies (n = 0): <none>
[10:33:12.600] {
[10:33:12.600]     {
[10:33:12.600]         {
[10:33:12.600]             ...future.startTime <- base::Sys.time()
[10:33:12.600]             {
[10:33:12.600]                 {
[10:33:12.600]                   {
[10:33:12.600]                     {
[10:33:12.600]                       base::local({
[10:33:12.600]                         has_future <- base::requireNamespace("future", 
[10:33:12.600]                           quietly = TRUE)
[10:33:12.600]                         if (has_future) {
[10:33:12.600]                           ns <- base::getNamespace("future")
[10:33:12.600]                           version <- ns[[".package"]][["version"]]
[10:33:12.600]                           if (is.null(version)) 
[10:33:12.600]                             version <- utils::packageVersion("future")
[10:33:12.600]                         }
[10:33:12.600]                         else {
[10:33:12.600]                           version <- NULL
[10:33:12.600]                         }
[10:33:12.600]                         if (!has_future || version < "1.8.0") {
[10:33:12.600]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.600]                             "", base::R.version$version.string), 
[10:33:12.600]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:12.600]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.600]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.600]                               "release", "version")], collapse = " "), 
[10:33:12.600]                             hostname = base::Sys.info()[["nodename"]])
[10:33:12.600]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.600]                             info)
[10:33:12.600]                           info <- base::paste(info, collapse = "; ")
[10:33:12.600]                           if (!has_future) {
[10:33:12.600]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.600]                               info)
[10:33:12.600]                           }
[10:33:12.600]                           else {
[10:33:12.600]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.600]                               info, version)
[10:33:12.600]                           }
[10:33:12.600]                           base::stop(msg)
[10:33:12.600]                         }
[10:33:12.600]                       })
[10:33:12.600]                     }
[10:33:12.600]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:12.600]                     base::options(mc.cores = 1L)
[10:33:12.600]                   }
[10:33:12.600]                   ...future.strategy.old <- future::plan("list")
[10:33:12.600]                   options(future.plan = NULL)
[10:33:12.600]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.600]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.600]                 }
[10:33:12.600]                 ...future.workdir <- getwd()
[10:33:12.600]             }
[10:33:12.600]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.600]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.600]         }
[10:33:12.600]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.600]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.600]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.600]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.600]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.600]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.600]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.600]             base::names(...future.oldOptions))
[10:33:12.600]     }
[10:33:12.600]     if (FALSE) {
[10:33:12.600]     }
[10:33:12.600]     else {
[10:33:12.600]         if (TRUE) {
[10:33:12.600]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.600]                 open = "w")
[10:33:12.600]         }
[10:33:12.600]         else {
[10:33:12.600]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.600]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.600]         }
[10:33:12.600]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.600]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.600]             base::sink(type = "output", split = FALSE)
[10:33:12.600]             base::close(...future.stdout)
[10:33:12.600]         }, add = TRUE)
[10:33:12.600]     }
[10:33:12.600]     ...future.frame <- base::sys.nframe()
[10:33:12.600]     ...future.conditions <- base::list()
[10:33:12.600]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.600]     if (FALSE) {
[10:33:12.600]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.600]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.600]     }
[10:33:12.600]     ...future.result <- base::tryCatch({
[10:33:12.600]         base::withCallingHandlers({
[10:33:12.600]             ...future.value <- base::withVisible(base::local({
[10:33:12.600]                 withCallingHandlers({
[10:33:12.600]                   {
[10:33:12.600]                     b <- a * ii
[10:33:12.600]                     a <- 0
[10:33:12.600]                     b
[10:33:12.600]                   }
[10:33:12.600]                 }, immediateCondition = function(cond) {
[10:33:12.600]                   save_rds <- function (object, pathname, ...) 
[10:33:12.600]                   {
[10:33:12.600]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:12.600]                     if (file_test("-f", pathname_tmp)) {
[10:33:12.600]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.600]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:12.600]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.600]                         fi_tmp[["mtime"]])
[10:33:12.600]                     }
[10:33:12.600]                     tryCatch({
[10:33:12.600]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:12.600]                     }, error = function(ex) {
[10:33:12.600]                       msg <- conditionMessage(ex)
[10:33:12.600]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.600]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:12.600]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.600]                         fi_tmp[["mtime"]], msg)
[10:33:12.600]                       ex$message <- msg
[10:33:12.600]                       stop(ex)
[10:33:12.600]                     })
[10:33:12.600]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:12.600]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:12.600]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:12.600]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.600]                       fi <- file.info(pathname)
[10:33:12.600]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:12.600]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.600]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:12.600]                         fi[["size"]], fi[["mtime"]])
[10:33:12.600]                       stop(msg)
[10:33:12.600]                     }
[10:33:12.600]                     invisible(pathname)
[10:33:12.600]                   }
[10:33:12.600]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:12.600]                     rootPath = tempdir()) 
[10:33:12.600]                   {
[10:33:12.600]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:12.600]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:12.600]                       tmpdir = path, fileext = ".rds")
[10:33:12.600]                     save_rds(obj, file)
[10:33:12.600]                   }
[10:33:12.600]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:12.600]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.600]                   {
[10:33:12.600]                     inherits <- base::inherits
[10:33:12.600]                     invokeRestart <- base::invokeRestart
[10:33:12.600]                     is.null <- base::is.null
[10:33:12.600]                     muffled <- FALSE
[10:33:12.600]                     if (inherits(cond, "message")) {
[10:33:12.600]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:12.600]                       if (muffled) 
[10:33:12.600]                         invokeRestart("muffleMessage")
[10:33:12.600]                     }
[10:33:12.600]                     else if (inherits(cond, "warning")) {
[10:33:12.600]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:12.600]                       if (muffled) 
[10:33:12.600]                         invokeRestart("muffleWarning")
[10:33:12.600]                     }
[10:33:12.600]                     else if (inherits(cond, "condition")) {
[10:33:12.600]                       if (!is.null(pattern)) {
[10:33:12.600]                         computeRestarts <- base::computeRestarts
[10:33:12.600]                         grepl <- base::grepl
[10:33:12.600]                         restarts <- computeRestarts(cond)
[10:33:12.600]                         for (restart in restarts) {
[10:33:12.600]                           name <- restart$name
[10:33:12.600]                           if (is.null(name)) 
[10:33:12.600]                             next
[10:33:12.600]                           if (!grepl(pattern, name)) 
[10:33:12.600]                             next
[10:33:12.600]                           invokeRestart(restart)
[10:33:12.600]                           muffled <- TRUE
[10:33:12.600]                           break
[10:33:12.600]                         }
[10:33:12.600]                       }
[10:33:12.600]                     }
[10:33:12.600]                     invisible(muffled)
[10:33:12.600]                   }
[10:33:12.600]                   muffleCondition(cond)
[10:33:12.600]                 })
[10:33:12.600]             }))
[10:33:12.600]             future::FutureResult(value = ...future.value$value, 
[10:33:12.600]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.600]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.600]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.600]                     ...future.globalenv.names))
[10:33:12.600]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.600]         }, condition = base::local({
[10:33:12.600]             c <- base::c
[10:33:12.600]             inherits <- base::inherits
[10:33:12.600]             invokeRestart <- base::invokeRestart
[10:33:12.600]             length <- base::length
[10:33:12.600]             list <- base::list
[10:33:12.600]             seq.int <- base::seq.int
[10:33:12.600]             signalCondition <- base::signalCondition
[10:33:12.600]             sys.calls <- base::sys.calls
[10:33:12.600]             `[[` <- base::`[[`
[10:33:12.600]             `+` <- base::`+`
[10:33:12.600]             `<<-` <- base::`<<-`
[10:33:12.600]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.600]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.600]                   3L)]
[10:33:12.600]             }
[10:33:12.600]             function(cond) {
[10:33:12.600]                 is_error <- inherits(cond, "error")
[10:33:12.600]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.600]                   NULL)
[10:33:12.600]                 if (is_error) {
[10:33:12.600]                   sessionInformation <- function() {
[10:33:12.600]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.600]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.600]                       search = base::search(), system = base::Sys.info())
[10:33:12.600]                   }
[10:33:12.600]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.600]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.600]                     cond$call), session = sessionInformation(), 
[10:33:12.600]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.600]                   signalCondition(cond)
[10:33:12.600]                 }
[10:33:12.600]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.600]                 "immediateCondition"))) {
[10:33:12.600]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.600]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.600]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.600]                   if (TRUE && !signal) {
[10:33:12.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.600]                     {
[10:33:12.600]                       inherits <- base::inherits
[10:33:12.600]                       invokeRestart <- base::invokeRestart
[10:33:12.600]                       is.null <- base::is.null
[10:33:12.600]                       muffled <- FALSE
[10:33:12.600]                       if (inherits(cond, "message")) {
[10:33:12.600]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.600]                         if (muffled) 
[10:33:12.600]                           invokeRestart("muffleMessage")
[10:33:12.600]                       }
[10:33:12.600]                       else if (inherits(cond, "warning")) {
[10:33:12.600]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.600]                         if (muffled) 
[10:33:12.600]                           invokeRestart("muffleWarning")
[10:33:12.600]                       }
[10:33:12.600]                       else if (inherits(cond, "condition")) {
[10:33:12.600]                         if (!is.null(pattern)) {
[10:33:12.600]                           computeRestarts <- base::computeRestarts
[10:33:12.600]                           grepl <- base::grepl
[10:33:12.600]                           restarts <- computeRestarts(cond)
[10:33:12.600]                           for (restart in restarts) {
[10:33:12.600]                             name <- restart$name
[10:33:12.600]                             if (is.null(name)) 
[10:33:12.600]                               next
[10:33:12.600]                             if (!grepl(pattern, name)) 
[10:33:12.600]                               next
[10:33:12.600]                             invokeRestart(restart)
[10:33:12.600]                             muffled <- TRUE
[10:33:12.600]                             break
[10:33:12.600]                           }
[10:33:12.600]                         }
[10:33:12.600]                       }
[10:33:12.600]                       invisible(muffled)
[10:33:12.600]                     }
[10:33:12.600]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.600]                   }
[10:33:12.600]                 }
[10:33:12.600]                 else {
[10:33:12.600]                   if (TRUE) {
[10:33:12.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.600]                     {
[10:33:12.600]                       inherits <- base::inherits
[10:33:12.600]                       invokeRestart <- base::invokeRestart
[10:33:12.600]                       is.null <- base::is.null
[10:33:12.600]                       muffled <- FALSE
[10:33:12.600]                       if (inherits(cond, "message")) {
[10:33:12.600]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.600]                         if (muffled) 
[10:33:12.600]                           invokeRestart("muffleMessage")
[10:33:12.600]                       }
[10:33:12.600]                       else if (inherits(cond, "warning")) {
[10:33:12.600]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.600]                         if (muffled) 
[10:33:12.600]                           invokeRestart("muffleWarning")
[10:33:12.600]                       }
[10:33:12.600]                       else if (inherits(cond, "condition")) {
[10:33:12.600]                         if (!is.null(pattern)) {
[10:33:12.600]                           computeRestarts <- base::computeRestarts
[10:33:12.600]                           grepl <- base::grepl
[10:33:12.600]                           restarts <- computeRestarts(cond)
[10:33:12.600]                           for (restart in restarts) {
[10:33:12.600]                             name <- restart$name
[10:33:12.600]                             if (is.null(name)) 
[10:33:12.600]                               next
[10:33:12.600]                             if (!grepl(pattern, name)) 
[10:33:12.600]                               next
[10:33:12.600]                             invokeRestart(restart)
[10:33:12.600]                             muffled <- TRUE
[10:33:12.600]                             break
[10:33:12.600]                           }
[10:33:12.600]                         }
[10:33:12.600]                       }
[10:33:12.600]                       invisible(muffled)
[10:33:12.600]                     }
[10:33:12.600]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.600]                   }
[10:33:12.600]                 }
[10:33:12.600]             }
[10:33:12.600]         }))
[10:33:12.600]     }, error = function(ex) {
[10:33:12.600]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.600]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.600]                 ...future.rng), started = ...future.startTime, 
[10:33:12.600]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.600]             version = "1.8"), class = "FutureResult")
[10:33:12.600]     }, finally = {
[10:33:12.600]         if (!identical(...future.workdir, getwd())) 
[10:33:12.600]             setwd(...future.workdir)
[10:33:12.600]         {
[10:33:12.600]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.600]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.600]             }
[10:33:12.600]             base::options(...future.oldOptions)
[10:33:12.600]             if (.Platform$OS.type == "windows") {
[10:33:12.600]                 old_names <- names(...future.oldEnvVars)
[10:33:12.600]                 envs <- base::Sys.getenv()
[10:33:12.600]                 names <- names(envs)
[10:33:12.600]                 common <- intersect(names, old_names)
[10:33:12.600]                 added <- setdiff(names, old_names)
[10:33:12.600]                 removed <- setdiff(old_names, names)
[10:33:12.600]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.600]                   envs[common]]
[10:33:12.600]                 NAMES <- toupper(changed)
[10:33:12.600]                 args <- list()
[10:33:12.600]                 for (kk in seq_along(NAMES)) {
[10:33:12.600]                   name <- changed[[kk]]
[10:33:12.600]                   NAME <- NAMES[[kk]]
[10:33:12.600]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.600]                     next
[10:33:12.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.600]                 }
[10:33:12.600]                 NAMES <- toupper(added)
[10:33:12.600]                 for (kk in seq_along(NAMES)) {
[10:33:12.600]                   name <- added[[kk]]
[10:33:12.600]                   NAME <- NAMES[[kk]]
[10:33:12.600]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.600]                     next
[10:33:12.600]                   args[[name]] <- ""
[10:33:12.600]                 }
[10:33:12.600]                 NAMES <- toupper(removed)
[10:33:12.600]                 for (kk in seq_along(NAMES)) {
[10:33:12.600]                   name <- removed[[kk]]
[10:33:12.600]                   NAME <- NAMES[[kk]]
[10:33:12.600]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.600]                     next
[10:33:12.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.600]                 }
[10:33:12.600]                 if (length(args) > 0) 
[10:33:12.600]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.600]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.600]             }
[10:33:12.600]             else {
[10:33:12.600]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.600]             }
[10:33:12.600]             {
[10:33:12.600]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.600]                   0L) {
[10:33:12.600]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.600]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.600]                   base::options(opts)
[10:33:12.600]                 }
[10:33:12.600]                 {
[10:33:12.600]                   {
[10:33:12.600]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:12.600]                     NULL
[10:33:12.600]                   }
[10:33:12.600]                   options(future.plan = NULL)
[10:33:12.600]                   if (is.na(NA_character_)) 
[10:33:12.600]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.600]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.600]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.600]                     .init = FALSE)
[10:33:12.600]                 }
[10:33:12.600]             }
[10:33:12.600]         }
[10:33:12.600]     })
[10:33:12.600]     if (TRUE) {
[10:33:12.600]         base::sink(type = "output", split = FALSE)
[10:33:12.600]         if (TRUE) {
[10:33:12.600]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.600]         }
[10:33:12.600]         else {
[10:33:12.600]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.600]         }
[10:33:12.600]         base::close(...future.stdout)
[10:33:12.600]         ...future.stdout <- NULL
[10:33:12.600]     }
[10:33:12.600]     ...future.result$conditions <- ...future.conditions
[10:33:12.600]     ...future.result$finished <- base::Sys.time()
[10:33:12.600]     ...future.result
[10:33:12.600] }
[10:33:12.603] assign_globals() ...
[10:33:12.603] List of 1
[10:33:12.603]  $ ii: int 1
[10:33:12.603]  - attr(*, "where")=List of 1
[10:33:12.603]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:12.603]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.603]  - attr(*, "resolved")= logi TRUE
[10:33:12.603]  - attr(*, "total_size")= num 56
[10:33:12.603]  - attr(*, "already-done")= logi TRUE
[10:33:12.606] - copied ‘ii’ to environment
[10:33:12.606] assign_globals() ... done
[10:33:12.606] requestCore(): workers = 2
[10:33:12.608] MulticoreFuture started
[10:33:12.609] - Launch lazy future ... done
[10:33:12.609] run() for ‘MulticoreFuture’ ... done
[10:33:12.610] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.610] List of future strategies:
[10:33:12.610] 1. sequential:
[10:33:12.610]    - args: function (..., envir = parent.frame())
[10:33:12.610]    - tweaked: FALSE
[10:33:12.610]    - call: NULL
[10:33:12.611] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.611] plan(): nbrOfWorkers() = 1
[10:33:12.611] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.614] plan(): Setting new future strategy stack:
[10:33:12.614] List of future strategies:
[10:33:12.614] 1. multicore:
[10:33:12.614]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:12.614]    - tweaked: FALSE
[10:33:12.614]    - call: plan(strategy)
[10:33:12.615] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:12.615] Searching for globals ... DONE
[10:33:12.616] Resolving globals: TRUE
[10:33:12.616] Resolving any globals that are futures ...
[10:33:12.616] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:12.616] Resolving any globals that are futures ... DONE
[10:33:12.617] Resolving futures part of globals (recursively) ...
[10:33:12.618] resolve() on list ...
[10:33:12.618]  recursive: 99
[10:33:12.618]  length: 1
[10:33:12.618]  elements: ‘ii’
[10:33:12.619]  length: 0 (resolved future 1)
[10:33:12.619] resolve() on list ... DONE
[10:33:12.619] - globals: [1] ‘ii’
[10:33:12.619] Resolving futures part of globals (recursively) ... DONE
[10:33:12.619] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:12.620] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:12.620] - globals: [1] ‘ii’
[10:33:12.620] 
[10:33:12.621] getGlobalsAndPackages() ... DONE
[10:33:12.621] plan(): nbrOfWorkers() = 2
[10:33:12.624] run() for ‘Future’ ...
[10:33:12.625] - state: ‘created’
[10:33:12.625] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:12.633] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:12.634] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:12.634]   - Field: ‘label’
[10:33:12.634]   - Field: ‘local’
[10:33:12.634]   - Field: ‘owner’
[10:33:12.635]   - Field: ‘envir’
[10:33:12.635]   - Field: ‘workers’
[10:33:12.635]   - Field: ‘packages’
[10:33:12.635]   - Field: ‘gc’
[10:33:12.635]   - Field: ‘job’
[10:33:12.636]   - Field: ‘conditions’
[10:33:12.636]   - Field: ‘expr’
[10:33:12.636]   - Field: ‘uuid’
[10:33:12.636]   - Field: ‘seed’
[10:33:12.637]   - Field: ‘version’
[10:33:12.637]   - Field: ‘result’
[10:33:12.637]   - Field: ‘asynchronous’
[10:33:12.637]   - Field: ‘calls’
[10:33:12.638]   - Field: ‘globals’
[10:33:12.638]   - Field: ‘stdout’
[10:33:12.638]   - Field: ‘earlySignal’
[10:33:12.639]   - Field: ‘lazy’
[10:33:12.639]   - Field: ‘state’
[10:33:12.639] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:12.639] - Launch lazy future ...
[10:33:12.640] Packages needed by the future expression (n = 0): <none>
[10:33:12.640] Packages needed by future strategies (n = 0): <none>
[10:33:12.641] {
[10:33:12.641]     {
[10:33:12.641]         {
[10:33:12.641]             ...future.startTime <- base::Sys.time()
[10:33:12.641]             {
[10:33:12.641]                 {
[10:33:12.641]                   {
[10:33:12.641]                     {
[10:33:12.641]                       base::local({
[10:33:12.641]                         has_future <- base::requireNamespace("future", 
[10:33:12.641]                           quietly = TRUE)
[10:33:12.641]                         if (has_future) {
[10:33:12.641]                           ns <- base::getNamespace("future")
[10:33:12.641]                           version <- ns[[".package"]][["version"]]
[10:33:12.641]                           if (is.null(version)) 
[10:33:12.641]                             version <- utils::packageVersion("future")
[10:33:12.641]                         }
[10:33:12.641]                         else {
[10:33:12.641]                           version <- NULL
[10:33:12.641]                         }
[10:33:12.641]                         if (!has_future || version < "1.8.0") {
[10:33:12.641]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.641]                             "", base::R.version$version.string), 
[10:33:12.641]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:12.641]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.641]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.641]                               "release", "version")], collapse = " "), 
[10:33:12.641]                             hostname = base::Sys.info()[["nodename"]])
[10:33:12.641]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.641]                             info)
[10:33:12.641]                           info <- base::paste(info, collapse = "; ")
[10:33:12.641]                           if (!has_future) {
[10:33:12.641]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.641]                               info)
[10:33:12.641]                           }
[10:33:12.641]                           else {
[10:33:12.641]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.641]                               info, version)
[10:33:12.641]                           }
[10:33:12.641]                           base::stop(msg)
[10:33:12.641]                         }
[10:33:12.641]                       })
[10:33:12.641]                     }
[10:33:12.641]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:12.641]                     base::options(mc.cores = 1L)
[10:33:12.641]                   }
[10:33:12.641]                   ...future.strategy.old <- future::plan("list")
[10:33:12.641]                   options(future.plan = NULL)
[10:33:12.641]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.641]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.641]                 }
[10:33:12.641]                 ...future.workdir <- getwd()
[10:33:12.641]             }
[10:33:12.641]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.641]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.641]         }
[10:33:12.641]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.641]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.641]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.641]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.641]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.641]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.641]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.641]             base::names(...future.oldOptions))
[10:33:12.641]     }
[10:33:12.641]     if (FALSE) {
[10:33:12.641]     }
[10:33:12.641]     else {
[10:33:12.641]         if (TRUE) {
[10:33:12.641]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.641]                 open = "w")
[10:33:12.641]         }
[10:33:12.641]         else {
[10:33:12.641]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.641]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.641]         }
[10:33:12.641]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.641]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.641]             base::sink(type = "output", split = FALSE)
[10:33:12.641]             base::close(...future.stdout)
[10:33:12.641]         }, add = TRUE)
[10:33:12.641]     }
[10:33:12.641]     ...future.frame <- base::sys.nframe()
[10:33:12.641]     ...future.conditions <- base::list()
[10:33:12.641]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.641]     if (FALSE) {
[10:33:12.641]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.641]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.641]     }
[10:33:12.641]     ...future.result <- base::tryCatch({
[10:33:12.641]         base::withCallingHandlers({
[10:33:12.641]             ...future.value <- base::withVisible(base::local({
[10:33:12.641]                 withCallingHandlers({
[10:33:12.641]                   {
[10:33:12.641]                     b <- a * ii
[10:33:12.641]                     a <- 0
[10:33:12.641]                     b
[10:33:12.641]                   }
[10:33:12.641]                 }, immediateCondition = function(cond) {
[10:33:12.641]                   save_rds <- function (object, pathname, ...) 
[10:33:12.641]                   {
[10:33:12.641]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:12.641]                     if (file_test("-f", pathname_tmp)) {
[10:33:12.641]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.641]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:12.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.641]                         fi_tmp[["mtime"]])
[10:33:12.641]                     }
[10:33:12.641]                     tryCatch({
[10:33:12.641]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:12.641]                     }, error = function(ex) {
[10:33:12.641]                       msg <- conditionMessage(ex)
[10:33:12.641]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.641]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:12.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.641]                         fi_tmp[["mtime"]], msg)
[10:33:12.641]                       ex$message <- msg
[10:33:12.641]                       stop(ex)
[10:33:12.641]                     })
[10:33:12.641]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:12.641]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:12.641]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:12.641]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.641]                       fi <- file.info(pathname)
[10:33:12.641]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:12.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.641]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:12.641]                         fi[["size"]], fi[["mtime"]])
[10:33:12.641]                       stop(msg)
[10:33:12.641]                     }
[10:33:12.641]                     invisible(pathname)
[10:33:12.641]                   }
[10:33:12.641]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:12.641]                     rootPath = tempdir()) 
[10:33:12.641]                   {
[10:33:12.641]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:12.641]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:12.641]                       tmpdir = path, fileext = ".rds")
[10:33:12.641]                     save_rds(obj, file)
[10:33:12.641]                   }
[10:33:12.641]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:12.641]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.641]                   {
[10:33:12.641]                     inherits <- base::inherits
[10:33:12.641]                     invokeRestart <- base::invokeRestart
[10:33:12.641]                     is.null <- base::is.null
[10:33:12.641]                     muffled <- FALSE
[10:33:12.641]                     if (inherits(cond, "message")) {
[10:33:12.641]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:12.641]                       if (muffled) 
[10:33:12.641]                         invokeRestart("muffleMessage")
[10:33:12.641]                     }
[10:33:12.641]                     else if (inherits(cond, "warning")) {
[10:33:12.641]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:12.641]                       if (muffled) 
[10:33:12.641]                         invokeRestart("muffleWarning")
[10:33:12.641]                     }
[10:33:12.641]                     else if (inherits(cond, "condition")) {
[10:33:12.641]                       if (!is.null(pattern)) {
[10:33:12.641]                         computeRestarts <- base::computeRestarts
[10:33:12.641]                         grepl <- base::grepl
[10:33:12.641]                         restarts <- computeRestarts(cond)
[10:33:12.641]                         for (restart in restarts) {
[10:33:12.641]                           name <- restart$name
[10:33:12.641]                           if (is.null(name)) 
[10:33:12.641]                             next
[10:33:12.641]                           if (!grepl(pattern, name)) 
[10:33:12.641]                             next
[10:33:12.641]                           invokeRestart(restart)
[10:33:12.641]                           muffled <- TRUE
[10:33:12.641]                           break
[10:33:12.641]                         }
[10:33:12.641]                       }
[10:33:12.641]                     }
[10:33:12.641]                     invisible(muffled)
[10:33:12.641]                   }
[10:33:12.641]                   muffleCondition(cond)
[10:33:12.641]                 })
[10:33:12.641]             }))
[10:33:12.641]             future::FutureResult(value = ...future.value$value, 
[10:33:12.641]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.641]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.641]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.641]                     ...future.globalenv.names))
[10:33:12.641]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.641]         }, condition = base::local({
[10:33:12.641]             c <- base::c
[10:33:12.641]             inherits <- base::inherits
[10:33:12.641]             invokeRestart <- base::invokeRestart
[10:33:12.641]             length <- base::length
[10:33:12.641]             list <- base::list
[10:33:12.641]             seq.int <- base::seq.int
[10:33:12.641]             signalCondition <- base::signalCondition
[10:33:12.641]             sys.calls <- base::sys.calls
[10:33:12.641]             `[[` <- base::`[[`
[10:33:12.641]             `+` <- base::`+`
[10:33:12.641]             `<<-` <- base::`<<-`
[10:33:12.641]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.641]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.641]                   3L)]
[10:33:12.641]             }
[10:33:12.641]             function(cond) {
[10:33:12.641]                 is_error <- inherits(cond, "error")
[10:33:12.641]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.641]                   NULL)
[10:33:12.641]                 if (is_error) {
[10:33:12.641]                   sessionInformation <- function() {
[10:33:12.641]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.641]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.641]                       search = base::search(), system = base::Sys.info())
[10:33:12.641]                   }
[10:33:12.641]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.641]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.641]                     cond$call), session = sessionInformation(), 
[10:33:12.641]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.641]                   signalCondition(cond)
[10:33:12.641]                 }
[10:33:12.641]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.641]                 "immediateCondition"))) {
[10:33:12.641]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.641]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.641]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.641]                   if (TRUE && !signal) {
[10:33:12.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.641]                     {
[10:33:12.641]                       inherits <- base::inherits
[10:33:12.641]                       invokeRestart <- base::invokeRestart
[10:33:12.641]                       is.null <- base::is.null
[10:33:12.641]                       muffled <- FALSE
[10:33:12.641]                       if (inherits(cond, "message")) {
[10:33:12.641]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.641]                         if (muffled) 
[10:33:12.641]                           invokeRestart("muffleMessage")
[10:33:12.641]                       }
[10:33:12.641]                       else if (inherits(cond, "warning")) {
[10:33:12.641]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.641]                         if (muffled) 
[10:33:12.641]                           invokeRestart("muffleWarning")
[10:33:12.641]                       }
[10:33:12.641]                       else if (inherits(cond, "condition")) {
[10:33:12.641]                         if (!is.null(pattern)) {
[10:33:12.641]                           computeRestarts <- base::computeRestarts
[10:33:12.641]                           grepl <- base::grepl
[10:33:12.641]                           restarts <- computeRestarts(cond)
[10:33:12.641]                           for (restart in restarts) {
[10:33:12.641]                             name <- restart$name
[10:33:12.641]                             if (is.null(name)) 
[10:33:12.641]                               next
[10:33:12.641]                             if (!grepl(pattern, name)) 
[10:33:12.641]                               next
[10:33:12.641]                             invokeRestart(restart)
[10:33:12.641]                             muffled <- TRUE
[10:33:12.641]                             break
[10:33:12.641]                           }
[10:33:12.641]                         }
[10:33:12.641]                       }
[10:33:12.641]                       invisible(muffled)
[10:33:12.641]                     }
[10:33:12.641]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.641]                   }
[10:33:12.641]                 }
[10:33:12.641]                 else {
[10:33:12.641]                   if (TRUE) {
[10:33:12.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.641]                     {
[10:33:12.641]                       inherits <- base::inherits
[10:33:12.641]                       invokeRestart <- base::invokeRestart
[10:33:12.641]                       is.null <- base::is.null
[10:33:12.641]                       muffled <- FALSE
[10:33:12.641]                       if (inherits(cond, "message")) {
[10:33:12.641]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.641]                         if (muffled) 
[10:33:12.641]                           invokeRestart("muffleMessage")
[10:33:12.641]                       }
[10:33:12.641]                       else if (inherits(cond, "warning")) {
[10:33:12.641]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.641]                         if (muffled) 
[10:33:12.641]                           invokeRestart("muffleWarning")
[10:33:12.641]                       }
[10:33:12.641]                       else if (inherits(cond, "condition")) {
[10:33:12.641]                         if (!is.null(pattern)) {
[10:33:12.641]                           computeRestarts <- base::computeRestarts
[10:33:12.641]                           grepl <- base::grepl
[10:33:12.641]                           restarts <- computeRestarts(cond)
[10:33:12.641]                           for (restart in restarts) {
[10:33:12.641]                             name <- restart$name
[10:33:12.641]                             if (is.null(name)) 
[10:33:12.641]                               next
[10:33:12.641]                             if (!grepl(pattern, name)) 
[10:33:12.641]                               next
[10:33:12.641]                             invokeRestart(restart)
[10:33:12.641]                             muffled <- TRUE
[10:33:12.641]                             break
[10:33:12.641]                           }
[10:33:12.641]                         }
[10:33:12.641]                       }
[10:33:12.641]                       invisible(muffled)
[10:33:12.641]                     }
[10:33:12.641]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.641]                   }
[10:33:12.641]                 }
[10:33:12.641]             }
[10:33:12.641]         }))
[10:33:12.641]     }, error = function(ex) {
[10:33:12.641]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.641]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.641]                 ...future.rng), started = ...future.startTime, 
[10:33:12.641]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.641]             version = "1.8"), class = "FutureResult")
[10:33:12.641]     }, finally = {
[10:33:12.641]         if (!identical(...future.workdir, getwd())) 
[10:33:12.641]             setwd(...future.workdir)
[10:33:12.641]         {
[10:33:12.641]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.641]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.641]             }
[10:33:12.641]             base::options(...future.oldOptions)
[10:33:12.641]             if (.Platform$OS.type == "windows") {
[10:33:12.641]                 old_names <- names(...future.oldEnvVars)
[10:33:12.641]                 envs <- base::Sys.getenv()
[10:33:12.641]                 names <- names(envs)
[10:33:12.641]                 common <- intersect(names, old_names)
[10:33:12.641]                 added <- setdiff(names, old_names)
[10:33:12.641]                 removed <- setdiff(old_names, names)
[10:33:12.641]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.641]                   envs[common]]
[10:33:12.641]                 NAMES <- toupper(changed)
[10:33:12.641]                 args <- list()
[10:33:12.641]                 for (kk in seq_along(NAMES)) {
[10:33:12.641]                   name <- changed[[kk]]
[10:33:12.641]                   NAME <- NAMES[[kk]]
[10:33:12.641]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.641]                     next
[10:33:12.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.641]                 }
[10:33:12.641]                 NAMES <- toupper(added)
[10:33:12.641]                 for (kk in seq_along(NAMES)) {
[10:33:12.641]                   name <- added[[kk]]
[10:33:12.641]                   NAME <- NAMES[[kk]]
[10:33:12.641]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.641]                     next
[10:33:12.641]                   args[[name]] <- ""
[10:33:12.641]                 }
[10:33:12.641]                 NAMES <- toupper(removed)
[10:33:12.641]                 for (kk in seq_along(NAMES)) {
[10:33:12.641]                   name <- removed[[kk]]
[10:33:12.641]                   NAME <- NAMES[[kk]]
[10:33:12.641]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.641]                     next
[10:33:12.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.641]                 }
[10:33:12.641]                 if (length(args) > 0) 
[10:33:12.641]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.641]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.641]             }
[10:33:12.641]             else {
[10:33:12.641]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.641]             }
[10:33:12.641]             {
[10:33:12.641]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.641]                   0L) {
[10:33:12.641]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.641]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.641]                   base::options(opts)
[10:33:12.641]                 }
[10:33:12.641]                 {
[10:33:12.641]                   {
[10:33:12.641]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:12.641]                     NULL
[10:33:12.641]                   }
[10:33:12.641]                   options(future.plan = NULL)
[10:33:12.641]                   if (is.na(NA_character_)) 
[10:33:12.641]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.641]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.641]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.641]                     .init = FALSE)
[10:33:12.641]                 }
[10:33:12.641]             }
[10:33:12.641]         }
[10:33:12.641]     })
[10:33:12.641]     if (TRUE) {
[10:33:12.641]         base::sink(type = "output", split = FALSE)
[10:33:12.641]         if (TRUE) {
[10:33:12.641]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.641]         }
[10:33:12.641]         else {
[10:33:12.641]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.641]         }
[10:33:12.641]         base::close(...future.stdout)
[10:33:12.641]         ...future.stdout <- NULL
[10:33:12.641]     }
[10:33:12.641]     ...future.result$conditions <- ...future.conditions
[10:33:12.641]     ...future.result$finished <- base::Sys.time()
[10:33:12.641]     ...future.result
[10:33:12.641] }
[10:33:12.645] assign_globals() ...
[10:33:12.645] List of 1
[10:33:12.645]  $ ii: int 2
[10:33:12.645]  - attr(*, "where")=List of 1
[10:33:12.645]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:12.645]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.645]  - attr(*, "resolved")= logi TRUE
[10:33:12.645]  - attr(*, "total_size")= num 56
[10:33:12.645]  - attr(*, "already-done")= logi TRUE
[10:33:12.649] - copied ‘ii’ to environment
[10:33:12.649] assign_globals() ... done
[10:33:12.649] requestCore(): workers = 2
[10:33:12.652] MulticoreFuture started
[10:33:12.652] - Launch lazy future ... done
[10:33:12.652] run() for ‘MulticoreFuture’ ... done
[10:33:12.653] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.653] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.653] List of future strategies:
[10:33:12.653] 1. sequential:
[10:33:12.653]    - args: function (..., envir = parent.frame())
[10:33:12.653]    - tweaked: FALSE
[10:33:12.653]    - call: NULL
[10:33:12.654] Searching for globals...
[10:33:12.654] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.656] plan(): Setting new future strategy stack:
[10:33:12.656] List of future strategies:
[10:33:12.656] 1. multicore:
[10:33:12.656]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:12.656]    - tweaked: FALSE
[10:33:12.656]    - call: plan(strategy)
[10:33:12.657] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:12.657] Searching for globals ... DONE
[10:33:12.657] Resolving globals: TRUE
[10:33:12.657] Resolving any globals that are futures ...
[10:33:12.657] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:12.658] Resolving any globals that are futures ... DONE
[10:33:12.658] Resolving futures part of globals (recursively) ...
[10:33:12.659] resolve() on list ...
[10:33:12.659]  recursive: 99
[10:33:12.659]  length: 1
[10:33:12.659]  elements: ‘ii’
[10:33:12.660]  length: 0 (resolved future 1)
[10:33:12.660] resolve() on list ... DONE
[10:33:12.660] - globals: [1] ‘ii’
[10:33:12.660] Resolving futures part of globals (recursively) ... DONE
[10:33:12.661] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:12.661] plan(): nbrOfWorkers() = 2
[10:33:12.661] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:12.661] - globals: [1] ‘ii’
[10:33:12.662] 
[10:33:12.662] getGlobalsAndPackages() ... DONE
[10:33:12.662] run() for ‘Future’ ...
[10:33:12.663] - state: ‘created’
[10:33:12.663] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:12.667] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:12.667] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:12.668]   - Field: ‘label’
[10:33:12.668]   - Field: ‘local’
[10:33:12.668]   - Field: ‘owner’
[10:33:12.668]   - Field: ‘envir’
[10:33:12.668]   - Field: ‘workers’
[10:33:12.668]   - Field: ‘packages’
[10:33:12.669]   - Field: ‘gc’
[10:33:12.669]   - Field: ‘job’
[10:33:12.669]   - Field: ‘conditions’
[10:33:12.669]   - Field: ‘expr’
[10:33:12.669]   - Field: ‘uuid’
[10:33:12.669]   - Field: ‘seed’
[10:33:12.669]   - Field: ‘version’
[10:33:12.670]   - Field: ‘result’
[10:33:12.670]   - Field: ‘asynchronous’
[10:33:12.670]   - Field: ‘calls’
[10:33:12.670]   - Field: ‘globals’
[10:33:12.670]   - Field: ‘stdout’
[10:33:12.670]   - Field: ‘earlySignal’
[10:33:12.670]   - Field: ‘lazy’
[10:33:12.671]   - Field: ‘state’
[10:33:12.671] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:12.671] - Launch lazy future ...
[10:33:12.671] Packages needed by the future expression (n = 0): <none>
[10:33:12.671] Packages needed by future strategies (n = 0): <none>
[10:33:12.672] {
[10:33:12.672]     {
[10:33:12.672]         {
[10:33:12.672]             ...future.startTime <- base::Sys.time()
[10:33:12.672]             {
[10:33:12.672]                 {
[10:33:12.672]                   {
[10:33:12.672]                     {
[10:33:12.672]                       base::local({
[10:33:12.672]                         has_future <- base::requireNamespace("future", 
[10:33:12.672]                           quietly = TRUE)
[10:33:12.672]                         if (has_future) {
[10:33:12.672]                           ns <- base::getNamespace("future")
[10:33:12.672]                           version <- ns[[".package"]][["version"]]
[10:33:12.672]                           if (is.null(version)) 
[10:33:12.672]                             version <- utils::packageVersion("future")
[10:33:12.672]                         }
[10:33:12.672]                         else {
[10:33:12.672]                           version <- NULL
[10:33:12.672]                         }
[10:33:12.672]                         if (!has_future || version < "1.8.0") {
[10:33:12.672]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.672]                             "", base::R.version$version.string), 
[10:33:12.672]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:12.672]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.672]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.672]                               "release", "version")], collapse = " "), 
[10:33:12.672]                             hostname = base::Sys.info()[["nodename"]])
[10:33:12.672]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.672]                             info)
[10:33:12.672]                           info <- base::paste(info, collapse = "; ")
[10:33:12.672]                           if (!has_future) {
[10:33:12.672]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.672]                               info)
[10:33:12.672]                           }
[10:33:12.672]                           else {
[10:33:12.672]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.672]                               info, version)
[10:33:12.672]                           }
[10:33:12.672]                           base::stop(msg)
[10:33:12.672]                         }
[10:33:12.672]                       })
[10:33:12.672]                     }
[10:33:12.672]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:12.672]                     base::options(mc.cores = 1L)
[10:33:12.672]                   }
[10:33:12.672]                   ...future.strategy.old <- future::plan("list")
[10:33:12.672]                   options(future.plan = NULL)
[10:33:12.672]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.672]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.672]                 }
[10:33:12.672]                 ...future.workdir <- getwd()
[10:33:12.672]             }
[10:33:12.672]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.672]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.672]         }
[10:33:12.672]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.672]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.672]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.672]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.672]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.672]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.672]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.672]             base::names(...future.oldOptions))
[10:33:12.672]     }
[10:33:12.672]     if (FALSE) {
[10:33:12.672]     }
[10:33:12.672]     else {
[10:33:12.672]         if (TRUE) {
[10:33:12.672]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.672]                 open = "w")
[10:33:12.672]         }
[10:33:12.672]         else {
[10:33:12.672]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.672]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.672]         }
[10:33:12.672]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.672]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.672]             base::sink(type = "output", split = FALSE)
[10:33:12.672]             base::close(...future.stdout)
[10:33:12.672]         }, add = TRUE)
[10:33:12.672]     }
[10:33:12.672]     ...future.frame <- base::sys.nframe()
[10:33:12.672]     ...future.conditions <- base::list()
[10:33:12.672]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.672]     if (FALSE) {
[10:33:12.672]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.672]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.672]     }
[10:33:12.672]     ...future.result <- base::tryCatch({
[10:33:12.672]         base::withCallingHandlers({
[10:33:12.672]             ...future.value <- base::withVisible(base::local({
[10:33:12.672]                 withCallingHandlers({
[10:33:12.672]                   {
[10:33:12.672]                     b <- a * ii
[10:33:12.672]                     a <- 0
[10:33:12.672]                     b
[10:33:12.672]                   }
[10:33:12.672]                 }, immediateCondition = function(cond) {
[10:33:12.672]                   save_rds <- function (object, pathname, ...) 
[10:33:12.672]                   {
[10:33:12.672]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:12.672]                     if (file_test("-f", pathname_tmp)) {
[10:33:12.672]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.672]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:12.672]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.672]                         fi_tmp[["mtime"]])
[10:33:12.672]                     }
[10:33:12.672]                     tryCatch({
[10:33:12.672]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:12.672]                     }, error = function(ex) {
[10:33:12.672]                       msg <- conditionMessage(ex)
[10:33:12.672]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.672]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:12.672]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.672]                         fi_tmp[["mtime"]], msg)
[10:33:12.672]                       ex$message <- msg
[10:33:12.672]                       stop(ex)
[10:33:12.672]                     })
[10:33:12.672]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:12.672]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:12.672]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:12.672]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.672]                       fi <- file.info(pathname)
[10:33:12.672]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:12.672]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.672]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:12.672]                         fi[["size"]], fi[["mtime"]])
[10:33:12.672]                       stop(msg)
[10:33:12.672]                     }
[10:33:12.672]                     invisible(pathname)
[10:33:12.672]                   }
[10:33:12.672]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:12.672]                     rootPath = tempdir()) 
[10:33:12.672]                   {
[10:33:12.672]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:12.672]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:12.672]                       tmpdir = path, fileext = ".rds")
[10:33:12.672]                     save_rds(obj, file)
[10:33:12.672]                   }
[10:33:12.672]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:12.672]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.672]                   {
[10:33:12.672]                     inherits <- base::inherits
[10:33:12.672]                     invokeRestart <- base::invokeRestart
[10:33:12.672]                     is.null <- base::is.null
[10:33:12.672]                     muffled <- FALSE
[10:33:12.672]                     if (inherits(cond, "message")) {
[10:33:12.672]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:12.672]                       if (muffled) 
[10:33:12.672]                         invokeRestart("muffleMessage")
[10:33:12.672]                     }
[10:33:12.672]                     else if (inherits(cond, "warning")) {
[10:33:12.672]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:12.672]                       if (muffled) 
[10:33:12.672]                         invokeRestart("muffleWarning")
[10:33:12.672]                     }
[10:33:12.672]                     else if (inherits(cond, "condition")) {
[10:33:12.672]                       if (!is.null(pattern)) {
[10:33:12.672]                         computeRestarts <- base::computeRestarts
[10:33:12.672]                         grepl <- base::grepl
[10:33:12.672]                         restarts <- computeRestarts(cond)
[10:33:12.672]                         for (restart in restarts) {
[10:33:12.672]                           name <- restart$name
[10:33:12.672]                           if (is.null(name)) 
[10:33:12.672]                             next
[10:33:12.672]                           if (!grepl(pattern, name)) 
[10:33:12.672]                             next
[10:33:12.672]                           invokeRestart(restart)
[10:33:12.672]                           muffled <- TRUE
[10:33:12.672]                           break
[10:33:12.672]                         }
[10:33:12.672]                       }
[10:33:12.672]                     }
[10:33:12.672]                     invisible(muffled)
[10:33:12.672]                   }
[10:33:12.672]                   muffleCondition(cond)
[10:33:12.672]                 })
[10:33:12.672]             }))
[10:33:12.672]             future::FutureResult(value = ...future.value$value, 
[10:33:12.672]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.672]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.672]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.672]                     ...future.globalenv.names))
[10:33:12.672]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.672]         }, condition = base::local({
[10:33:12.672]             c <- base::c
[10:33:12.672]             inherits <- base::inherits
[10:33:12.672]             invokeRestart <- base::invokeRestart
[10:33:12.672]             length <- base::length
[10:33:12.672]             list <- base::list
[10:33:12.672]             seq.int <- base::seq.int
[10:33:12.672]             signalCondition <- base::signalCondition
[10:33:12.672]             sys.calls <- base::sys.calls
[10:33:12.672]             `[[` <- base::`[[`
[10:33:12.672]             `+` <- base::`+`
[10:33:12.672]             `<<-` <- base::`<<-`
[10:33:12.672]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.672]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.672]                   3L)]
[10:33:12.672]             }
[10:33:12.672]             function(cond) {
[10:33:12.672]                 is_error <- inherits(cond, "error")
[10:33:12.672]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.672]                   NULL)
[10:33:12.672]                 if (is_error) {
[10:33:12.672]                   sessionInformation <- function() {
[10:33:12.672]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.672]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.672]                       search = base::search(), system = base::Sys.info())
[10:33:12.672]                   }
[10:33:12.672]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.672]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.672]                     cond$call), session = sessionInformation(), 
[10:33:12.672]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.672]                   signalCondition(cond)
[10:33:12.672]                 }
[10:33:12.672]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.672]                 "immediateCondition"))) {
[10:33:12.672]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.672]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.672]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.672]                   if (TRUE && !signal) {
[10:33:12.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.672]                     {
[10:33:12.672]                       inherits <- base::inherits
[10:33:12.672]                       invokeRestart <- base::invokeRestart
[10:33:12.672]                       is.null <- base::is.null
[10:33:12.672]                       muffled <- FALSE
[10:33:12.672]                       if (inherits(cond, "message")) {
[10:33:12.672]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.672]                         if (muffled) 
[10:33:12.672]                           invokeRestart("muffleMessage")
[10:33:12.672]                       }
[10:33:12.672]                       else if (inherits(cond, "warning")) {
[10:33:12.672]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.672]                         if (muffled) 
[10:33:12.672]                           invokeRestart("muffleWarning")
[10:33:12.672]                       }
[10:33:12.672]                       else if (inherits(cond, "condition")) {
[10:33:12.672]                         if (!is.null(pattern)) {
[10:33:12.672]                           computeRestarts <- base::computeRestarts
[10:33:12.672]                           grepl <- base::grepl
[10:33:12.672]                           restarts <- computeRestarts(cond)
[10:33:12.672]                           for (restart in restarts) {
[10:33:12.672]                             name <- restart$name
[10:33:12.672]                             if (is.null(name)) 
[10:33:12.672]                               next
[10:33:12.672]                             if (!grepl(pattern, name)) 
[10:33:12.672]                               next
[10:33:12.672]                             invokeRestart(restart)
[10:33:12.672]                             muffled <- TRUE
[10:33:12.672]                             break
[10:33:12.672]                           }
[10:33:12.672]                         }
[10:33:12.672]                       }
[10:33:12.672]                       invisible(muffled)
[10:33:12.672]                     }
[10:33:12.672]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.672]                   }
[10:33:12.672]                 }
[10:33:12.672]                 else {
[10:33:12.672]                   if (TRUE) {
[10:33:12.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.672]                     {
[10:33:12.672]                       inherits <- base::inherits
[10:33:12.672]                       invokeRestart <- base::invokeRestart
[10:33:12.672]                       is.null <- base::is.null
[10:33:12.672]                       muffled <- FALSE
[10:33:12.672]                       if (inherits(cond, "message")) {
[10:33:12.672]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.672]                         if (muffled) 
[10:33:12.672]                           invokeRestart("muffleMessage")
[10:33:12.672]                       }
[10:33:12.672]                       else if (inherits(cond, "warning")) {
[10:33:12.672]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.672]                         if (muffled) 
[10:33:12.672]                           invokeRestart("muffleWarning")
[10:33:12.672]                       }
[10:33:12.672]                       else if (inherits(cond, "condition")) {
[10:33:12.672]                         if (!is.null(pattern)) {
[10:33:12.672]                           computeRestarts <- base::computeRestarts
[10:33:12.672]                           grepl <- base::grepl
[10:33:12.672]                           restarts <- computeRestarts(cond)
[10:33:12.672]                           for (restart in restarts) {
[10:33:12.672]                             name <- restart$name
[10:33:12.672]                             if (is.null(name)) 
[10:33:12.672]                               next
[10:33:12.672]                             if (!grepl(pattern, name)) 
[10:33:12.672]                               next
[10:33:12.672]                             invokeRestart(restart)
[10:33:12.672]                             muffled <- TRUE
[10:33:12.672]                             break
[10:33:12.672]                           }
[10:33:12.672]                         }
[10:33:12.672]                       }
[10:33:12.672]                       invisible(muffled)
[10:33:12.672]                     }
[10:33:12.672]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.672]                   }
[10:33:12.672]                 }
[10:33:12.672]             }
[10:33:12.672]         }))
[10:33:12.672]     }, error = function(ex) {
[10:33:12.672]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.672]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.672]                 ...future.rng), started = ...future.startTime, 
[10:33:12.672]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.672]             version = "1.8"), class = "FutureResult")
[10:33:12.672]     }, finally = {
[10:33:12.672]         if (!identical(...future.workdir, getwd())) 
[10:33:12.672]             setwd(...future.workdir)
[10:33:12.672]         {
[10:33:12.672]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.672]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.672]             }
[10:33:12.672]             base::options(...future.oldOptions)
[10:33:12.672]             if (.Platform$OS.type == "windows") {
[10:33:12.672]                 old_names <- names(...future.oldEnvVars)
[10:33:12.672]                 envs <- base::Sys.getenv()
[10:33:12.672]                 names <- names(envs)
[10:33:12.672]                 common <- intersect(names, old_names)
[10:33:12.672]                 added <- setdiff(names, old_names)
[10:33:12.672]                 removed <- setdiff(old_names, names)
[10:33:12.672]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.672]                   envs[common]]
[10:33:12.672]                 NAMES <- toupper(changed)
[10:33:12.672]                 args <- list()
[10:33:12.672]                 for (kk in seq_along(NAMES)) {
[10:33:12.672]                   name <- changed[[kk]]
[10:33:12.672]                   NAME <- NAMES[[kk]]
[10:33:12.672]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.672]                     next
[10:33:12.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.672]                 }
[10:33:12.672]                 NAMES <- toupper(added)
[10:33:12.672]                 for (kk in seq_along(NAMES)) {
[10:33:12.672]                   name <- added[[kk]]
[10:33:12.672]                   NAME <- NAMES[[kk]]
[10:33:12.672]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.672]                     next
[10:33:12.672]                   args[[name]] <- ""
[10:33:12.672]                 }
[10:33:12.672]                 NAMES <- toupper(removed)
[10:33:12.672]                 for (kk in seq_along(NAMES)) {
[10:33:12.672]                   name <- removed[[kk]]
[10:33:12.672]                   NAME <- NAMES[[kk]]
[10:33:12.672]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.672]                     next
[10:33:12.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.672]                 }
[10:33:12.672]                 if (length(args) > 0) 
[10:33:12.672]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.672]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.672]             }
[10:33:12.672]             else {
[10:33:12.672]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.672]             }
[10:33:12.672]             {
[10:33:12.672]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.672]                   0L) {
[10:33:12.672]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.672]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.672]                   base::options(opts)
[10:33:12.672]                 }
[10:33:12.672]                 {
[10:33:12.672]                   {
[10:33:12.672]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:12.672]                     NULL
[10:33:12.672]                   }
[10:33:12.672]                   options(future.plan = NULL)
[10:33:12.672]                   if (is.na(NA_character_)) 
[10:33:12.672]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.672]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.672]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.672]                     .init = FALSE)
[10:33:12.672]                 }
[10:33:12.672]             }
[10:33:12.672]         }
[10:33:12.672]     })
[10:33:12.672]     if (TRUE) {
[10:33:12.672]         base::sink(type = "output", split = FALSE)
[10:33:12.672]         if (TRUE) {
[10:33:12.672]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.672]         }
[10:33:12.672]         else {
[10:33:12.672]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.672]         }
[10:33:12.672]         base::close(...future.stdout)
[10:33:12.672]         ...future.stdout <- NULL
[10:33:12.672]     }
[10:33:12.672]     ...future.result$conditions <- ...future.conditions
[10:33:12.672]     ...future.result$finished <- base::Sys.time()
[10:33:12.672]     ...future.result
[10:33:12.672] }
[10:33:12.676] assign_globals() ...
[10:33:12.676] List of 1
[10:33:12.676]  $ ii: int 3
[10:33:12.676]  - attr(*, "where")=List of 1
[10:33:12.676]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:12.676]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.676]  - attr(*, "resolved")= logi TRUE
[10:33:12.676]  - attr(*, "total_size")= num 56
[10:33:12.676]  - attr(*, "already-done")= logi TRUE
[10:33:12.683] - copied ‘ii’ to environment
[10:33:12.683] assign_globals() ... done
[10:33:12.684] requestCore(): workers = 2
[10:33:12.684] Poll #1 (0): usedCores() = 2, workers = 2
[10:33:12.696] result() for MulticoreFuture ...
[10:33:12.696] result() for MulticoreFuture ...
[10:33:12.697] result() for MulticoreFuture ... done
[10:33:12.697] result() for MulticoreFuture ... done
[10:33:12.697] result() for MulticoreFuture ...
[10:33:12.697] result() for MulticoreFuture ... done
[10:33:12.700] MulticoreFuture started
[10:33:12.701] - Launch lazy future ... done
[10:33:12.701] run() for ‘MulticoreFuture’ ... done
[10:33:12.702] plan(): Setting new future strategy stack:
[10:33:12.702] result() for MulticoreFuture ...
[10:33:12.703] result() for MulticoreFuture ... done
[10:33:12.702] List of future strategies:
[10:33:12.702] 1. sequential:
[10:33:12.702]    - args: function (..., envir = parent.frame())
[10:33:12.702]    - tweaked: FALSE
[10:33:12.702]    - call: NULL
[10:33:12.703] result() for MulticoreFuture ...
[10:33:12.703] result() for MulticoreFuture ... done
[10:33:12.703] plan(): nbrOfWorkers() = 1
[10:33:12.704] result() for MulticoreFuture ...
[10:33:12.706] result() for MulticoreFuture ...
[10:33:12.706] result() for MulticoreFuture ... done
[10:33:12.706] result() for MulticoreFuture ... done
[10:33:12.707] plan(): Setting new future strategy stack:
[10:33:12.707] result() for MulticoreFuture ...
[10:33:12.707] result() for MulticoreFuture ... done
[10:33:12.707] List of future strategies:
[10:33:12.707] 1. multicore:
[10:33:12.707]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:12.707]    - tweaked: FALSE
[10:33:12.707]    - call: plan(strategy)
[10:33:12.707] result() for MulticoreFuture ...
[10:33:12.713] plan(): nbrOfWorkers() = 2
[10:33:12.713] result() for MulticoreFuture ...
[10:33:12.714] result() for MulticoreFuture ... done
[10:33:12.714] result() for MulticoreFuture ... done
[10:33:12.714] result() for MulticoreFuture ...
[10:33:12.714] result() for MulticoreFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.715] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.716] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.718] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:12.718] Searching for globals ... DONE
[10:33:12.718] Resolving globals: TRUE
[10:33:12.718] Resolving any globals that are futures ...
[10:33:12.718] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:12.719] Resolving any globals that are futures ... DONE
[10:33:12.719] Resolving futures part of globals (recursively) ...
[10:33:12.719] resolve() on list ...
[10:33:12.719]  recursive: 99
[10:33:12.720]  length: 1
[10:33:12.720]  elements: ‘ii’
[10:33:12.720]  length: 0 (resolved future 1)
[10:33:12.720] resolve() on list ... DONE
[10:33:12.720] - globals: [1] ‘ii’
[10:33:12.720] Resolving futures part of globals (recursively) ... DONE
[10:33:12.720] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:12.721] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:12.721] - globals: [1] ‘ii’
[10:33:12.721] 
[10:33:12.721] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.722] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.722] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.724] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:12.724] Searching for globals ... DONE
[10:33:12.724] Resolving globals: TRUE
[10:33:12.724] Resolving any globals that are futures ...
[10:33:12.724] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:12.724] Resolving any globals that are futures ... DONE
[10:33:12.725] Resolving futures part of globals (recursively) ...
[10:33:12.725] resolve() on list ...
[10:33:12.725]  recursive: 99
[10:33:12.725]  length: 1
[10:33:12.725]  elements: ‘ii’
[10:33:12.726]  length: 0 (resolved future 1)
[10:33:12.726] resolve() on list ... DONE
[10:33:12.726] - globals: [1] ‘ii’
[10:33:12.726] Resolving futures part of globals (recursively) ... DONE
[10:33:12.726] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:12.726] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:12.727] - globals: [1] ‘ii’
[10:33:12.727] 
[10:33:12.727] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.727] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.728] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.729] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:12.730] Searching for globals ... DONE
[10:33:12.730] Resolving globals: TRUE
[10:33:12.730] Resolving any globals that are futures ...
[10:33:12.730] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:12.730] Resolving any globals that are futures ... DONE
[10:33:12.730] Resolving futures part of globals (recursively) ...
[10:33:12.731] resolve() on list ...
[10:33:12.731]  recursive: 99
[10:33:12.731]  length: 1
[10:33:12.731]  elements: ‘ii’
[10:33:12.731]  length: 0 (resolved future 1)
[10:33:12.731] resolve() on list ... DONE
[10:33:12.731] - globals: [1] ‘ii’
[10:33:12.731] Resolving futures part of globals (recursively) ... DONE
[10:33:12.732] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:12.732] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:12.732] - globals: [1] ‘ii’
[10:33:12.732] 
[10:33:12.732] getGlobalsAndPackages() ... DONE
[10:33:12.733] run() for ‘Future’ ...
[10:33:12.733] - state: ‘created’
[10:33:12.735] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:12.739] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:12.739] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:12.740]   - Field: ‘label’
[10:33:12.740]   - Field: ‘local’
[10:33:12.740]   - Field: ‘owner’
[10:33:12.740]   - Field: ‘envir’
[10:33:12.740]   - Field: ‘workers’
[10:33:12.740]   - Field: ‘packages’
[10:33:12.740]   - Field: ‘gc’
[10:33:12.741]   - Field: ‘job’
[10:33:12.741]   - Field: ‘conditions’
[10:33:12.741]   - Field: ‘expr’
[10:33:12.741]   - Field: ‘uuid’
[10:33:12.741]   - Field: ‘seed’
[10:33:12.741]   - Field: ‘version’
[10:33:12.741]   - Field: ‘result’
[10:33:12.741]   - Field: ‘asynchronous’
[10:33:12.741]   - Field: ‘calls’
[10:33:12.742]   - Field: ‘globals’
[10:33:12.742]   - Field: ‘stdout’
[10:33:12.742]   - Field: ‘earlySignal’
[10:33:12.742]   - Field: ‘lazy’
[10:33:12.742]   - Field: ‘state’
[10:33:12.742] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:12.742] - Launch lazy future ...
[10:33:12.742] Packages needed by the future expression (n = 0): <none>
[10:33:12.743] Packages needed by future strategies (n = 0): <none>
[10:33:12.743] {
[10:33:12.743]     {
[10:33:12.743]         {
[10:33:12.743]             ...future.startTime <- base::Sys.time()
[10:33:12.743]             {
[10:33:12.743]                 {
[10:33:12.743]                   {
[10:33:12.743]                     {
[10:33:12.743]                       base::local({
[10:33:12.743]                         has_future <- base::requireNamespace("future", 
[10:33:12.743]                           quietly = TRUE)
[10:33:12.743]                         if (has_future) {
[10:33:12.743]                           ns <- base::getNamespace("future")
[10:33:12.743]                           version <- ns[[".package"]][["version"]]
[10:33:12.743]                           if (is.null(version)) 
[10:33:12.743]                             version <- utils::packageVersion("future")
[10:33:12.743]                         }
[10:33:12.743]                         else {
[10:33:12.743]                           version <- NULL
[10:33:12.743]                         }
[10:33:12.743]                         if (!has_future || version < "1.8.0") {
[10:33:12.743]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.743]                             "", base::R.version$version.string), 
[10:33:12.743]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:12.743]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.743]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.743]                               "release", "version")], collapse = " "), 
[10:33:12.743]                             hostname = base::Sys.info()[["nodename"]])
[10:33:12.743]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.743]                             info)
[10:33:12.743]                           info <- base::paste(info, collapse = "; ")
[10:33:12.743]                           if (!has_future) {
[10:33:12.743]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.743]                               info)
[10:33:12.743]                           }
[10:33:12.743]                           else {
[10:33:12.743]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.743]                               info, version)
[10:33:12.743]                           }
[10:33:12.743]                           base::stop(msg)
[10:33:12.743]                         }
[10:33:12.743]                       })
[10:33:12.743]                     }
[10:33:12.743]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:12.743]                     base::options(mc.cores = 1L)
[10:33:12.743]                   }
[10:33:12.743]                   ...future.strategy.old <- future::plan("list")
[10:33:12.743]                   options(future.plan = NULL)
[10:33:12.743]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.743]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.743]                 }
[10:33:12.743]                 ...future.workdir <- getwd()
[10:33:12.743]             }
[10:33:12.743]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.743]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.743]         }
[10:33:12.743]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.743]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.743]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.743]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.743]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.743]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.743]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.743]             base::names(...future.oldOptions))
[10:33:12.743]     }
[10:33:12.743]     if (FALSE) {
[10:33:12.743]     }
[10:33:12.743]     else {
[10:33:12.743]         if (TRUE) {
[10:33:12.743]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.743]                 open = "w")
[10:33:12.743]         }
[10:33:12.743]         else {
[10:33:12.743]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.743]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.743]         }
[10:33:12.743]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.743]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.743]             base::sink(type = "output", split = FALSE)
[10:33:12.743]             base::close(...future.stdout)
[10:33:12.743]         }, add = TRUE)
[10:33:12.743]     }
[10:33:12.743]     ...future.frame <- base::sys.nframe()
[10:33:12.743]     ...future.conditions <- base::list()
[10:33:12.743]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.743]     if (FALSE) {
[10:33:12.743]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.743]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.743]     }
[10:33:12.743]     ...future.result <- base::tryCatch({
[10:33:12.743]         base::withCallingHandlers({
[10:33:12.743]             ...future.value <- base::withVisible(base::local({
[10:33:12.743]                 withCallingHandlers({
[10:33:12.743]                   {
[10:33:12.743]                     b <- a * ii
[10:33:12.743]                     a <- 0
[10:33:12.743]                     b
[10:33:12.743]                   }
[10:33:12.743]                 }, immediateCondition = function(cond) {
[10:33:12.743]                   save_rds <- function (object, pathname, ...) 
[10:33:12.743]                   {
[10:33:12.743]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:12.743]                     if (file_test("-f", pathname_tmp)) {
[10:33:12.743]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.743]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:12.743]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.743]                         fi_tmp[["mtime"]])
[10:33:12.743]                     }
[10:33:12.743]                     tryCatch({
[10:33:12.743]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:12.743]                     }, error = function(ex) {
[10:33:12.743]                       msg <- conditionMessage(ex)
[10:33:12.743]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.743]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:12.743]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.743]                         fi_tmp[["mtime"]], msg)
[10:33:12.743]                       ex$message <- msg
[10:33:12.743]                       stop(ex)
[10:33:12.743]                     })
[10:33:12.743]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:12.743]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:12.743]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:12.743]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.743]                       fi <- file.info(pathname)
[10:33:12.743]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:12.743]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.743]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:12.743]                         fi[["size"]], fi[["mtime"]])
[10:33:12.743]                       stop(msg)
[10:33:12.743]                     }
[10:33:12.743]                     invisible(pathname)
[10:33:12.743]                   }
[10:33:12.743]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:12.743]                     rootPath = tempdir()) 
[10:33:12.743]                   {
[10:33:12.743]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:12.743]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:12.743]                       tmpdir = path, fileext = ".rds")
[10:33:12.743]                     save_rds(obj, file)
[10:33:12.743]                   }
[10:33:12.743]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:12.743]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.743]                   {
[10:33:12.743]                     inherits <- base::inherits
[10:33:12.743]                     invokeRestart <- base::invokeRestart
[10:33:12.743]                     is.null <- base::is.null
[10:33:12.743]                     muffled <- FALSE
[10:33:12.743]                     if (inherits(cond, "message")) {
[10:33:12.743]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:12.743]                       if (muffled) 
[10:33:12.743]                         invokeRestart("muffleMessage")
[10:33:12.743]                     }
[10:33:12.743]                     else if (inherits(cond, "warning")) {
[10:33:12.743]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:12.743]                       if (muffled) 
[10:33:12.743]                         invokeRestart("muffleWarning")
[10:33:12.743]                     }
[10:33:12.743]                     else if (inherits(cond, "condition")) {
[10:33:12.743]                       if (!is.null(pattern)) {
[10:33:12.743]                         computeRestarts <- base::computeRestarts
[10:33:12.743]                         grepl <- base::grepl
[10:33:12.743]                         restarts <- computeRestarts(cond)
[10:33:12.743]                         for (restart in restarts) {
[10:33:12.743]                           name <- restart$name
[10:33:12.743]                           if (is.null(name)) 
[10:33:12.743]                             next
[10:33:12.743]                           if (!grepl(pattern, name)) 
[10:33:12.743]                             next
[10:33:12.743]                           invokeRestart(restart)
[10:33:12.743]                           muffled <- TRUE
[10:33:12.743]                           break
[10:33:12.743]                         }
[10:33:12.743]                       }
[10:33:12.743]                     }
[10:33:12.743]                     invisible(muffled)
[10:33:12.743]                   }
[10:33:12.743]                   muffleCondition(cond)
[10:33:12.743]                 })
[10:33:12.743]             }))
[10:33:12.743]             future::FutureResult(value = ...future.value$value, 
[10:33:12.743]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.743]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.743]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.743]                     ...future.globalenv.names))
[10:33:12.743]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.743]         }, condition = base::local({
[10:33:12.743]             c <- base::c
[10:33:12.743]             inherits <- base::inherits
[10:33:12.743]             invokeRestart <- base::invokeRestart
[10:33:12.743]             length <- base::length
[10:33:12.743]             list <- base::list
[10:33:12.743]             seq.int <- base::seq.int
[10:33:12.743]             signalCondition <- base::signalCondition
[10:33:12.743]             sys.calls <- base::sys.calls
[10:33:12.743]             `[[` <- base::`[[`
[10:33:12.743]             `+` <- base::`+`
[10:33:12.743]             `<<-` <- base::`<<-`
[10:33:12.743]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.743]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.743]                   3L)]
[10:33:12.743]             }
[10:33:12.743]             function(cond) {
[10:33:12.743]                 is_error <- inherits(cond, "error")
[10:33:12.743]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.743]                   NULL)
[10:33:12.743]                 if (is_error) {
[10:33:12.743]                   sessionInformation <- function() {
[10:33:12.743]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.743]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.743]                       search = base::search(), system = base::Sys.info())
[10:33:12.743]                   }
[10:33:12.743]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.743]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.743]                     cond$call), session = sessionInformation(), 
[10:33:12.743]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.743]                   signalCondition(cond)
[10:33:12.743]                 }
[10:33:12.743]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.743]                 "immediateCondition"))) {
[10:33:12.743]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.743]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.743]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.743]                   if (TRUE && !signal) {
[10:33:12.743]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.743]                     {
[10:33:12.743]                       inherits <- base::inherits
[10:33:12.743]                       invokeRestart <- base::invokeRestart
[10:33:12.743]                       is.null <- base::is.null
[10:33:12.743]                       muffled <- FALSE
[10:33:12.743]                       if (inherits(cond, "message")) {
[10:33:12.743]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.743]                         if (muffled) 
[10:33:12.743]                           invokeRestart("muffleMessage")
[10:33:12.743]                       }
[10:33:12.743]                       else if (inherits(cond, "warning")) {
[10:33:12.743]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.743]                         if (muffled) 
[10:33:12.743]                           invokeRestart("muffleWarning")
[10:33:12.743]                       }
[10:33:12.743]                       else if (inherits(cond, "condition")) {
[10:33:12.743]                         if (!is.null(pattern)) {
[10:33:12.743]                           computeRestarts <- base::computeRestarts
[10:33:12.743]                           grepl <- base::grepl
[10:33:12.743]                           restarts <- computeRestarts(cond)
[10:33:12.743]                           for (restart in restarts) {
[10:33:12.743]                             name <- restart$name
[10:33:12.743]                             if (is.null(name)) 
[10:33:12.743]                               next
[10:33:12.743]                             if (!grepl(pattern, name)) 
[10:33:12.743]                               next
[10:33:12.743]                             invokeRestart(restart)
[10:33:12.743]                             muffled <- TRUE
[10:33:12.743]                             break
[10:33:12.743]                           }
[10:33:12.743]                         }
[10:33:12.743]                       }
[10:33:12.743]                       invisible(muffled)
[10:33:12.743]                     }
[10:33:12.743]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.743]                   }
[10:33:12.743]                 }
[10:33:12.743]                 else {
[10:33:12.743]                   if (TRUE) {
[10:33:12.743]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.743]                     {
[10:33:12.743]                       inherits <- base::inherits
[10:33:12.743]                       invokeRestart <- base::invokeRestart
[10:33:12.743]                       is.null <- base::is.null
[10:33:12.743]                       muffled <- FALSE
[10:33:12.743]                       if (inherits(cond, "message")) {
[10:33:12.743]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.743]                         if (muffled) 
[10:33:12.743]                           invokeRestart("muffleMessage")
[10:33:12.743]                       }
[10:33:12.743]                       else if (inherits(cond, "warning")) {
[10:33:12.743]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.743]                         if (muffled) 
[10:33:12.743]                           invokeRestart("muffleWarning")
[10:33:12.743]                       }
[10:33:12.743]                       else if (inherits(cond, "condition")) {
[10:33:12.743]                         if (!is.null(pattern)) {
[10:33:12.743]                           computeRestarts <- base::computeRestarts
[10:33:12.743]                           grepl <- base::grepl
[10:33:12.743]                           restarts <- computeRestarts(cond)
[10:33:12.743]                           for (restart in restarts) {
[10:33:12.743]                             name <- restart$name
[10:33:12.743]                             if (is.null(name)) 
[10:33:12.743]                               next
[10:33:12.743]                             if (!grepl(pattern, name)) 
[10:33:12.743]                               next
[10:33:12.743]                             invokeRestart(restart)
[10:33:12.743]                             muffled <- TRUE
[10:33:12.743]                             break
[10:33:12.743]                           }
[10:33:12.743]                         }
[10:33:12.743]                       }
[10:33:12.743]                       invisible(muffled)
[10:33:12.743]                     }
[10:33:12.743]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.743]                   }
[10:33:12.743]                 }
[10:33:12.743]             }
[10:33:12.743]         }))
[10:33:12.743]     }, error = function(ex) {
[10:33:12.743]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.743]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.743]                 ...future.rng), started = ...future.startTime, 
[10:33:12.743]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.743]             version = "1.8"), class = "FutureResult")
[10:33:12.743]     }, finally = {
[10:33:12.743]         if (!identical(...future.workdir, getwd())) 
[10:33:12.743]             setwd(...future.workdir)
[10:33:12.743]         {
[10:33:12.743]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.743]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.743]             }
[10:33:12.743]             base::options(...future.oldOptions)
[10:33:12.743]             if (.Platform$OS.type == "windows") {
[10:33:12.743]                 old_names <- names(...future.oldEnvVars)
[10:33:12.743]                 envs <- base::Sys.getenv()
[10:33:12.743]                 names <- names(envs)
[10:33:12.743]                 common <- intersect(names, old_names)
[10:33:12.743]                 added <- setdiff(names, old_names)
[10:33:12.743]                 removed <- setdiff(old_names, names)
[10:33:12.743]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.743]                   envs[common]]
[10:33:12.743]                 NAMES <- toupper(changed)
[10:33:12.743]                 args <- list()
[10:33:12.743]                 for (kk in seq_along(NAMES)) {
[10:33:12.743]                   name <- changed[[kk]]
[10:33:12.743]                   NAME <- NAMES[[kk]]
[10:33:12.743]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.743]                     next
[10:33:12.743]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.743]                 }
[10:33:12.743]                 NAMES <- toupper(added)
[10:33:12.743]                 for (kk in seq_along(NAMES)) {
[10:33:12.743]                   name <- added[[kk]]
[10:33:12.743]                   NAME <- NAMES[[kk]]
[10:33:12.743]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.743]                     next
[10:33:12.743]                   args[[name]] <- ""
[10:33:12.743]                 }
[10:33:12.743]                 NAMES <- toupper(removed)
[10:33:12.743]                 for (kk in seq_along(NAMES)) {
[10:33:12.743]                   name <- removed[[kk]]
[10:33:12.743]                   NAME <- NAMES[[kk]]
[10:33:12.743]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.743]                     next
[10:33:12.743]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.743]                 }
[10:33:12.743]                 if (length(args) > 0) 
[10:33:12.743]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.743]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.743]             }
[10:33:12.743]             else {
[10:33:12.743]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.743]             }
[10:33:12.743]             {
[10:33:12.743]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.743]                   0L) {
[10:33:12.743]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.743]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.743]                   base::options(opts)
[10:33:12.743]                 }
[10:33:12.743]                 {
[10:33:12.743]                   {
[10:33:12.743]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:12.743]                     NULL
[10:33:12.743]                   }
[10:33:12.743]                   options(future.plan = NULL)
[10:33:12.743]                   if (is.na(NA_character_)) 
[10:33:12.743]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.743]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.743]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.743]                     .init = FALSE)
[10:33:12.743]                 }
[10:33:12.743]             }
[10:33:12.743]         }
[10:33:12.743]     })
[10:33:12.743]     if (TRUE) {
[10:33:12.743]         base::sink(type = "output", split = FALSE)
[10:33:12.743]         if (TRUE) {
[10:33:12.743]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.743]         }
[10:33:12.743]         else {
[10:33:12.743]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.743]         }
[10:33:12.743]         base::close(...future.stdout)
[10:33:12.743]         ...future.stdout <- NULL
[10:33:12.743]     }
[10:33:12.743]     ...future.result$conditions <- ...future.conditions
[10:33:12.743]     ...future.result$finished <- base::Sys.time()
[10:33:12.743]     ...future.result
[10:33:12.743] }
[10:33:12.745] assign_globals() ...
[10:33:12.745] List of 1
[10:33:12.745]  $ ii: int 1
[10:33:12.745]  - attr(*, "where")=List of 1
[10:33:12.745]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:12.745]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.745]  - attr(*, "resolved")= logi TRUE
[10:33:12.745]  - attr(*, "total_size")= num 56
[10:33:12.745]  - attr(*, "already-done")= logi TRUE
[10:33:12.748] - copied ‘ii’ to environment
[10:33:12.748] assign_globals() ... done
[10:33:12.748] requestCore(): workers = 2
[10:33:12.750] MulticoreFuture started
[10:33:12.750] - Launch lazy future ... done
[10:33:12.751] run() for ‘MulticoreFuture’ ... done
[10:33:12.751] result() for MulticoreFuture ...
[10:33:12.751] plan(): Setting new future strategy stack:
[10:33:12.751] List of future strategies:
[10:33:12.751] 1. sequential:
[10:33:12.751]    - args: function (..., envir = parent.frame())
[10:33:12.751]    - tweaked: FALSE
[10:33:12.751]    - call: NULL
[10:33:12.752] plan(): nbrOfWorkers() = 1
[10:33:12.754] plan(): Setting new future strategy stack:
[10:33:12.754] List of future strategies:
[10:33:12.754] 1. multicore:
[10:33:12.754]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:12.754]    - tweaked: FALSE
[10:33:12.754]    - call: plan(strategy)
[10:33:12.760] plan(): nbrOfWorkers() = 2
[10:33:12.766] result() for MulticoreFuture ...
[10:33:12.766] result() for MulticoreFuture ... done
[10:33:12.766] signalConditions() ...
[10:33:12.766]  - include = ‘immediateCondition’
[10:33:12.767]  - exclude = 
[10:33:12.767]  - resignal = FALSE
[10:33:12.767]  - Number of conditions: 1
[10:33:12.767] signalConditions() ... done
[10:33:12.767] result() for MulticoreFuture ... done
[10:33:12.767] result() for MulticoreFuture ...
[10:33:12.767] result() for MulticoreFuture ... done
[10:33:12.767] signalConditions() ...
[10:33:12.768]  - include = ‘immediateCondition’
[10:33:12.768]  - exclude = 
[10:33:12.768]  - resignal = FALSE
[10:33:12.768]  - Number of conditions: 1
[10:33:12.768] signalConditions() ... done
[10:33:12.768] Future state: ‘finished’
[10:33:12.768] result() for MulticoreFuture ...
[10:33:12.768] result() for MulticoreFuture ... done
[10:33:12.769] signalConditions() ...
[10:33:12.769]  - include = ‘condition’
[10:33:12.769]  - exclude = ‘immediateCondition’
[10:33:12.769]  - resignal = TRUE
[10:33:12.769]  - Number of conditions: 1
[10:33:12.769]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:33:12.769] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 45
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language local({     value <- value(future) ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "c3bfbccbe859" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 10:33:12"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.800] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.801] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.801] 
[10:33:12.801] Searching for globals ... DONE
[10:33:12.801] - globals: [0] <none>
[10:33:12.802] getGlobalsAndPackages() ... DONE
[10:33:12.802] run() for ‘Future’ ...
[10:33:12.802] - state: ‘created’
[10:33:12.802] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:12.806] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:12.806] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:12.806]   - Field: ‘label’
[10:33:12.806]   - Field: ‘local’
[10:33:12.806]   - Field: ‘owner’
[10:33:12.806]   - Field: ‘envir’
[10:33:12.806]   - Field: ‘workers’
[10:33:12.807]   - Field: ‘packages’
[10:33:12.807]   - Field: ‘gc’
[10:33:12.807]   - Field: ‘job’
[10:33:12.807]   - Field: ‘conditions’
[10:33:12.807]   - Field: ‘expr’
[10:33:12.807]   - Field: ‘uuid’
[10:33:12.807]   - Field: ‘seed’
[10:33:12.807]   - Field: ‘version’
[10:33:12.807]   - Field: ‘result’
[10:33:12.807]   - Field: ‘asynchronous’
[10:33:12.807]   - Field: ‘calls’
[10:33:12.808]   - Field: ‘globals’
[10:33:12.808]   - Field: ‘stdout’
[10:33:12.808]   - Field: ‘earlySignal’
[10:33:12.808]   - Field: ‘lazy’
[10:33:12.808]   - Field: ‘state’
[10:33:12.808] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:12.808] - Launch lazy future ...
[10:33:12.808] Packages needed by the future expression (n = 0): <none>
[10:33:12.808] Packages needed by future strategies (n = 0): <none>
[10:33:12.809] {
[10:33:12.809]     {
[10:33:12.809]         {
[10:33:12.809]             ...future.startTime <- base::Sys.time()
[10:33:12.809]             {
[10:33:12.809]                 {
[10:33:12.809]                   {
[10:33:12.809]                     {
[10:33:12.809]                       base::local({
[10:33:12.809]                         has_future <- base::requireNamespace("future", 
[10:33:12.809]                           quietly = TRUE)
[10:33:12.809]                         if (has_future) {
[10:33:12.809]                           ns <- base::getNamespace("future")
[10:33:12.809]                           version <- ns[[".package"]][["version"]]
[10:33:12.809]                           if (is.null(version)) 
[10:33:12.809]                             version <- utils::packageVersion("future")
[10:33:12.809]                         }
[10:33:12.809]                         else {
[10:33:12.809]                           version <- NULL
[10:33:12.809]                         }
[10:33:12.809]                         if (!has_future || version < "1.8.0") {
[10:33:12.809]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.809]                             "", base::R.version$version.string), 
[10:33:12.809]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:12.809]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.809]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.809]                               "release", "version")], collapse = " "), 
[10:33:12.809]                             hostname = base::Sys.info()[["nodename"]])
[10:33:12.809]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.809]                             info)
[10:33:12.809]                           info <- base::paste(info, collapse = "; ")
[10:33:12.809]                           if (!has_future) {
[10:33:12.809]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.809]                               info)
[10:33:12.809]                           }
[10:33:12.809]                           else {
[10:33:12.809]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.809]                               info, version)
[10:33:12.809]                           }
[10:33:12.809]                           base::stop(msg)
[10:33:12.809]                         }
[10:33:12.809]                       })
[10:33:12.809]                     }
[10:33:12.809]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:12.809]                     base::options(mc.cores = 1L)
[10:33:12.809]                   }
[10:33:12.809]                   ...future.strategy.old <- future::plan("list")
[10:33:12.809]                   options(future.plan = NULL)
[10:33:12.809]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.809]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.809]                 }
[10:33:12.809]                 ...future.workdir <- getwd()
[10:33:12.809]             }
[10:33:12.809]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.809]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.809]         }
[10:33:12.809]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.809]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.809]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.809]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.809]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.809]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.809]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.809]             base::names(...future.oldOptions))
[10:33:12.809]     }
[10:33:12.809]     if (FALSE) {
[10:33:12.809]     }
[10:33:12.809]     else {
[10:33:12.809]         if (TRUE) {
[10:33:12.809]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.809]                 open = "w")
[10:33:12.809]         }
[10:33:12.809]         else {
[10:33:12.809]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.809]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.809]         }
[10:33:12.809]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.809]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.809]             base::sink(type = "output", split = FALSE)
[10:33:12.809]             base::close(...future.stdout)
[10:33:12.809]         }, add = TRUE)
[10:33:12.809]     }
[10:33:12.809]     ...future.frame <- base::sys.nframe()
[10:33:12.809]     ...future.conditions <- base::list()
[10:33:12.809]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.809]     if (FALSE) {
[10:33:12.809]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.809]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.809]     }
[10:33:12.809]     ...future.result <- base::tryCatch({
[10:33:12.809]         base::withCallingHandlers({
[10:33:12.809]             ...future.value <- base::withVisible(base::local({
[10:33:12.809]                 withCallingHandlers({
[10:33:12.809]                   1
[10:33:12.809]                 }, immediateCondition = function(cond) {
[10:33:12.809]                   save_rds <- function (object, pathname, ...) 
[10:33:12.809]                   {
[10:33:12.809]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:12.809]                     if (file_test("-f", pathname_tmp)) {
[10:33:12.809]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.809]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:12.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.809]                         fi_tmp[["mtime"]])
[10:33:12.809]                     }
[10:33:12.809]                     tryCatch({
[10:33:12.809]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:12.809]                     }, error = function(ex) {
[10:33:12.809]                       msg <- conditionMessage(ex)
[10:33:12.809]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.809]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:12.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.809]                         fi_tmp[["mtime"]], msg)
[10:33:12.809]                       ex$message <- msg
[10:33:12.809]                       stop(ex)
[10:33:12.809]                     })
[10:33:12.809]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:12.809]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:12.809]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:12.809]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.809]                       fi <- file.info(pathname)
[10:33:12.809]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:12.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.809]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:12.809]                         fi[["size"]], fi[["mtime"]])
[10:33:12.809]                       stop(msg)
[10:33:12.809]                     }
[10:33:12.809]                     invisible(pathname)
[10:33:12.809]                   }
[10:33:12.809]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:12.809]                     rootPath = tempdir()) 
[10:33:12.809]                   {
[10:33:12.809]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:12.809]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:12.809]                       tmpdir = path, fileext = ".rds")
[10:33:12.809]                     save_rds(obj, file)
[10:33:12.809]                   }
[10:33:12.809]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:12.809]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.809]                   {
[10:33:12.809]                     inherits <- base::inherits
[10:33:12.809]                     invokeRestart <- base::invokeRestart
[10:33:12.809]                     is.null <- base::is.null
[10:33:12.809]                     muffled <- FALSE
[10:33:12.809]                     if (inherits(cond, "message")) {
[10:33:12.809]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:12.809]                       if (muffled) 
[10:33:12.809]                         invokeRestart("muffleMessage")
[10:33:12.809]                     }
[10:33:12.809]                     else if (inherits(cond, "warning")) {
[10:33:12.809]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:12.809]                       if (muffled) 
[10:33:12.809]                         invokeRestart("muffleWarning")
[10:33:12.809]                     }
[10:33:12.809]                     else if (inherits(cond, "condition")) {
[10:33:12.809]                       if (!is.null(pattern)) {
[10:33:12.809]                         computeRestarts <- base::computeRestarts
[10:33:12.809]                         grepl <- base::grepl
[10:33:12.809]                         restarts <- computeRestarts(cond)
[10:33:12.809]                         for (restart in restarts) {
[10:33:12.809]                           name <- restart$name
[10:33:12.809]                           if (is.null(name)) 
[10:33:12.809]                             next
[10:33:12.809]                           if (!grepl(pattern, name)) 
[10:33:12.809]                             next
[10:33:12.809]                           invokeRestart(restart)
[10:33:12.809]                           muffled <- TRUE
[10:33:12.809]                           break
[10:33:12.809]                         }
[10:33:12.809]                       }
[10:33:12.809]                     }
[10:33:12.809]                     invisible(muffled)
[10:33:12.809]                   }
[10:33:12.809]                   muffleCondition(cond)
[10:33:12.809]                 })
[10:33:12.809]             }))
[10:33:12.809]             future::FutureResult(value = ...future.value$value, 
[10:33:12.809]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.809]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.809]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.809]                     ...future.globalenv.names))
[10:33:12.809]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.809]         }, condition = base::local({
[10:33:12.809]             c <- base::c
[10:33:12.809]             inherits <- base::inherits
[10:33:12.809]             invokeRestart <- base::invokeRestart
[10:33:12.809]             length <- base::length
[10:33:12.809]             list <- base::list
[10:33:12.809]             seq.int <- base::seq.int
[10:33:12.809]             signalCondition <- base::signalCondition
[10:33:12.809]             sys.calls <- base::sys.calls
[10:33:12.809]             `[[` <- base::`[[`
[10:33:12.809]             `+` <- base::`+`
[10:33:12.809]             `<<-` <- base::`<<-`
[10:33:12.809]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.809]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.809]                   3L)]
[10:33:12.809]             }
[10:33:12.809]             function(cond) {
[10:33:12.809]                 is_error <- inherits(cond, "error")
[10:33:12.809]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.809]                   NULL)
[10:33:12.809]                 if (is_error) {
[10:33:12.809]                   sessionInformation <- function() {
[10:33:12.809]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.809]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.809]                       search = base::search(), system = base::Sys.info())
[10:33:12.809]                   }
[10:33:12.809]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.809]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.809]                     cond$call), session = sessionInformation(), 
[10:33:12.809]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.809]                   signalCondition(cond)
[10:33:12.809]                 }
[10:33:12.809]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.809]                 "immediateCondition"))) {
[10:33:12.809]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.809]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.809]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.809]                   if (TRUE && !signal) {
[10:33:12.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.809]                     {
[10:33:12.809]                       inherits <- base::inherits
[10:33:12.809]                       invokeRestart <- base::invokeRestart
[10:33:12.809]                       is.null <- base::is.null
[10:33:12.809]                       muffled <- FALSE
[10:33:12.809]                       if (inherits(cond, "message")) {
[10:33:12.809]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.809]                         if (muffled) 
[10:33:12.809]                           invokeRestart("muffleMessage")
[10:33:12.809]                       }
[10:33:12.809]                       else if (inherits(cond, "warning")) {
[10:33:12.809]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.809]                         if (muffled) 
[10:33:12.809]                           invokeRestart("muffleWarning")
[10:33:12.809]                       }
[10:33:12.809]                       else if (inherits(cond, "condition")) {
[10:33:12.809]                         if (!is.null(pattern)) {
[10:33:12.809]                           computeRestarts <- base::computeRestarts
[10:33:12.809]                           grepl <- base::grepl
[10:33:12.809]                           restarts <- computeRestarts(cond)
[10:33:12.809]                           for (restart in restarts) {
[10:33:12.809]                             name <- restart$name
[10:33:12.809]                             if (is.null(name)) 
[10:33:12.809]                               next
[10:33:12.809]                             if (!grepl(pattern, name)) 
[10:33:12.809]                               next
[10:33:12.809]                             invokeRestart(restart)
[10:33:12.809]                             muffled <- TRUE
[10:33:12.809]                             break
[10:33:12.809]                           }
[10:33:12.809]                         }
[10:33:12.809]                       }
[10:33:12.809]                       invisible(muffled)
[10:33:12.809]                     }
[10:33:12.809]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.809]                   }
[10:33:12.809]                 }
[10:33:12.809]                 else {
[10:33:12.809]                   if (TRUE) {
[10:33:12.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.809]                     {
[10:33:12.809]                       inherits <- base::inherits
[10:33:12.809]                       invokeRestart <- base::invokeRestart
[10:33:12.809]                       is.null <- base::is.null
[10:33:12.809]                       muffled <- FALSE
[10:33:12.809]                       if (inherits(cond, "message")) {
[10:33:12.809]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.809]                         if (muffled) 
[10:33:12.809]                           invokeRestart("muffleMessage")
[10:33:12.809]                       }
[10:33:12.809]                       else if (inherits(cond, "warning")) {
[10:33:12.809]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.809]                         if (muffled) 
[10:33:12.809]                           invokeRestart("muffleWarning")
[10:33:12.809]                       }
[10:33:12.809]                       else if (inherits(cond, "condition")) {
[10:33:12.809]                         if (!is.null(pattern)) {
[10:33:12.809]                           computeRestarts <- base::computeRestarts
[10:33:12.809]                           grepl <- base::grepl
[10:33:12.809]                           restarts <- computeRestarts(cond)
[10:33:12.809]                           for (restart in restarts) {
[10:33:12.809]                             name <- restart$name
[10:33:12.809]                             if (is.null(name)) 
[10:33:12.809]                               next
[10:33:12.809]                             if (!grepl(pattern, name)) 
[10:33:12.809]                               next
[10:33:12.809]                             invokeRestart(restart)
[10:33:12.809]                             muffled <- TRUE
[10:33:12.809]                             break
[10:33:12.809]                           }
[10:33:12.809]                         }
[10:33:12.809]                       }
[10:33:12.809]                       invisible(muffled)
[10:33:12.809]                     }
[10:33:12.809]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.809]                   }
[10:33:12.809]                 }
[10:33:12.809]             }
[10:33:12.809]         }))
[10:33:12.809]     }, error = function(ex) {
[10:33:12.809]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.809]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.809]                 ...future.rng), started = ...future.startTime, 
[10:33:12.809]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.809]             version = "1.8"), class = "FutureResult")
[10:33:12.809]     }, finally = {
[10:33:12.809]         if (!identical(...future.workdir, getwd())) 
[10:33:12.809]             setwd(...future.workdir)
[10:33:12.809]         {
[10:33:12.809]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.809]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.809]             }
[10:33:12.809]             base::options(...future.oldOptions)
[10:33:12.809]             if (.Platform$OS.type == "windows") {
[10:33:12.809]                 old_names <- names(...future.oldEnvVars)
[10:33:12.809]                 envs <- base::Sys.getenv()
[10:33:12.809]                 names <- names(envs)
[10:33:12.809]                 common <- intersect(names, old_names)
[10:33:12.809]                 added <- setdiff(names, old_names)
[10:33:12.809]                 removed <- setdiff(old_names, names)
[10:33:12.809]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.809]                   envs[common]]
[10:33:12.809]                 NAMES <- toupper(changed)
[10:33:12.809]                 args <- list()
[10:33:12.809]                 for (kk in seq_along(NAMES)) {
[10:33:12.809]                   name <- changed[[kk]]
[10:33:12.809]                   NAME <- NAMES[[kk]]
[10:33:12.809]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.809]                     next
[10:33:12.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.809]                 }
[10:33:12.809]                 NAMES <- toupper(added)
[10:33:12.809]                 for (kk in seq_along(NAMES)) {
[10:33:12.809]                   name <- added[[kk]]
[10:33:12.809]                   NAME <- NAMES[[kk]]
[10:33:12.809]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.809]                     next
[10:33:12.809]                   args[[name]] <- ""
[10:33:12.809]                 }
[10:33:12.809]                 NAMES <- toupper(removed)
[10:33:12.809]                 for (kk in seq_along(NAMES)) {
[10:33:12.809]                   name <- removed[[kk]]
[10:33:12.809]                   NAME <- NAMES[[kk]]
[10:33:12.809]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.809]                     next
[10:33:12.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.809]                 }
[10:33:12.809]                 if (length(args) > 0) 
[10:33:12.809]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.809]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.809]             }
[10:33:12.809]             else {
[10:33:12.809]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.809]             }
[10:33:12.809]             {
[10:33:12.809]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.809]                   0L) {
[10:33:12.809]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.809]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.809]                   base::options(opts)
[10:33:12.809]                 }
[10:33:12.809]                 {
[10:33:12.809]                   {
[10:33:12.809]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:12.809]                     NULL
[10:33:12.809]                   }
[10:33:12.809]                   options(future.plan = NULL)
[10:33:12.809]                   if (is.na(NA_character_)) 
[10:33:12.809]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.809]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.809]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.809]                     .init = FALSE)
[10:33:12.809]                 }
[10:33:12.809]             }
[10:33:12.809]         }
[10:33:12.809]     })
[10:33:12.809]     if (TRUE) {
[10:33:12.809]         base::sink(type = "output", split = FALSE)
[10:33:12.809]         if (TRUE) {
[10:33:12.809]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.809]         }
[10:33:12.809]         else {
[10:33:12.809]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.809]         }
[10:33:12.809]         base::close(...future.stdout)
[10:33:12.809]         ...future.stdout <- NULL
[10:33:12.809]     }
[10:33:12.809]     ...future.result$conditions <- ...future.conditions
[10:33:12.809]     ...future.result$finished <- base::Sys.time()
[10:33:12.809]     ...future.result
[10:33:12.809] }
[10:33:12.811] requestCore(): workers = 2
[10:33:12.813] MulticoreFuture started
[10:33:12.813] - Launch lazy future ... done
[10:33:12.813] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.814] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.814] plan(): Setting new future strategy stack:
[10:33:12.814] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.814] List of future strategies:
[10:33:12.814] 1. sequential:
[10:33:12.814]    - args: function (..., envir = parent.frame())
[10:33:12.814]    - tweaked: FALSE
[10:33:12.814]    - call: NULL
[10:33:12.815] plan(): nbrOfWorkers() = 1
[10:33:12.816] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:12.817] Searching for globals ... DONE
[10:33:12.817] Resolving globals: TRUE
[10:33:12.817] Resolving any globals that are futures ...
[10:33:12.817] plan(): Setting new future strategy stack:
[10:33:12.817] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:12.817] Resolving any globals that are futures ... DONE
[10:33:12.817] List of future strategies:
[10:33:12.817] 1. multicore:
[10:33:12.817]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:12.817]    - tweaked: FALSE
[10:33:12.817]    - call: plan(strategy)
[10:33:12.818] Resolving futures part of globals (recursively) ...
[10:33:12.819] resolve() on list ...
[10:33:12.819]  recursive: 99
[10:33:12.819]  length: 1
[10:33:12.819]  elements: ‘a’
[10:33:12.822] plan(): nbrOfWorkers() = 2
[10:33:12.822] Future #1
[10:33:12.823] result() for MulticoreFuture ...
[10:33:12.824] result() for MulticoreFuture ...
[10:33:12.824] result() for MulticoreFuture ... done
[10:33:12.824] result() for MulticoreFuture ... done
[10:33:12.824] result() for MulticoreFuture ...
[10:33:12.824] result() for MulticoreFuture ... done
[10:33:12.825] A MulticoreFuture was resolved
[10:33:12.825]  length: 0 (resolved future 1)
[10:33:12.825] resolve() on list ... DONE
[10:33:12.825] - globals: [1] ‘a’
[10:33:12.825] Resolving futures part of globals (recursively) ... DONE
[10:33:12.826] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[10:33:12.827] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[10:33:12.827] - globals: [1] ‘a’
[10:33:12.827] - packages: [1] ‘future’
[10:33:12.827] getGlobalsAndPackages() ... DONE
[10:33:12.828] run() for ‘Future’ ...
[10:33:12.828] - state: ‘created’
[10:33:12.828] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:12.832] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:12.832] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:12.832]   - Field: ‘label’
[10:33:12.832]   - Field: ‘local’
[10:33:12.832]   - Field: ‘owner’
[10:33:12.833]   - Field: ‘envir’
[10:33:12.833]   - Field: ‘workers’
[10:33:12.833]   - Field: ‘packages’
[10:33:12.833]   - Field: ‘gc’
[10:33:12.833]   - Field: ‘job’
[10:33:12.833]   - Field: ‘conditions’
[10:33:12.833]   - Field: ‘expr’
[10:33:12.833]   - Field: ‘uuid’
[10:33:12.834]   - Field: ‘seed’
[10:33:12.834]   - Field: ‘version’
[10:33:12.834]   - Field: ‘result’
[10:33:12.834]   - Field: ‘asynchronous’
[10:33:12.834]   - Field: ‘calls’
[10:33:12.834]   - Field: ‘globals’
[10:33:12.834]   - Field: ‘stdout’
[10:33:12.834]   - Field: ‘earlySignal’
[10:33:12.835]   - Field: ‘lazy’
[10:33:12.835]   - Field: ‘state’
[10:33:12.835] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:12.835] - Launch lazy future ...
[10:33:12.835] Packages needed by the future expression (n = 1): ‘future’
[10:33:12.837] Packages needed by future strategies (n = 0): <none>
[10:33:12.838] {
[10:33:12.838]     {
[10:33:12.838]         {
[10:33:12.838]             ...future.startTime <- base::Sys.time()
[10:33:12.838]             {
[10:33:12.838]                 {
[10:33:12.838]                   {
[10:33:12.838]                     {
[10:33:12.838]                       {
[10:33:12.838]                         base::local({
[10:33:12.838]                           has_future <- base::requireNamespace("future", 
[10:33:12.838]                             quietly = TRUE)
[10:33:12.838]                           if (has_future) {
[10:33:12.838]                             ns <- base::getNamespace("future")
[10:33:12.838]                             version <- ns[[".package"]][["version"]]
[10:33:12.838]                             if (is.null(version)) 
[10:33:12.838]                               version <- utils::packageVersion("future")
[10:33:12.838]                           }
[10:33:12.838]                           else {
[10:33:12.838]                             version <- NULL
[10:33:12.838]                           }
[10:33:12.838]                           if (!has_future || version < "1.8.0") {
[10:33:12.838]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.838]                               "", base::R.version$version.string), 
[10:33:12.838]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:12.838]                                 base::R.version$platform, 8 * 
[10:33:12.838]                                   base::.Machine$sizeof.pointer), 
[10:33:12.838]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.838]                                 "release", "version")], collapse = " "), 
[10:33:12.838]                               hostname = base::Sys.info()[["nodename"]])
[10:33:12.838]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.838]                               info)
[10:33:12.838]                             info <- base::paste(info, collapse = "; ")
[10:33:12.838]                             if (!has_future) {
[10:33:12.838]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.838]                                 info)
[10:33:12.838]                             }
[10:33:12.838]                             else {
[10:33:12.838]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.838]                                 info, version)
[10:33:12.838]                             }
[10:33:12.838]                             base::stop(msg)
[10:33:12.838]                           }
[10:33:12.838]                         })
[10:33:12.838]                       }
[10:33:12.838]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:12.838]                       base::options(mc.cores = 1L)
[10:33:12.838]                     }
[10:33:12.838]                     base::local({
[10:33:12.838]                       for (pkg in "future") {
[10:33:12.838]                         base::loadNamespace(pkg)
[10:33:12.838]                         base::library(pkg, character.only = TRUE)
[10:33:12.838]                       }
[10:33:12.838]                     })
[10:33:12.838]                   }
[10:33:12.838]                   ...future.strategy.old <- future::plan("list")
[10:33:12.838]                   options(future.plan = NULL)
[10:33:12.838]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.838]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.838]                 }
[10:33:12.838]                 ...future.workdir <- getwd()
[10:33:12.838]             }
[10:33:12.838]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.838]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.838]         }
[10:33:12.838]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.838]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.838]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.838]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.838]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.838]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.838]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.838]             base::names(...future.oldOptions))
[10:33:12.838]     }
[10:33:12.838]     if (FALSE) {
[10:33:12.838]     }
[10:33:12.838]     else {
[10:33:12.838]         if (TRUE) {
[10:33:12.838]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.838]                 open = "w")
[10:33:12.838]         }
[10:33:12.838]         else {
[10:33:12.838]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.838]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.838]         }
[10:33:12.838]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.838]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.838]             base::sink(type = "output", split = FALSE)
[10:33:12.838]             base::close(...future.stdout)
[10:33:12.838]         }, add = TRUE)
[10:33:12.838]     }
[10:33:12.838]     ...future.frame <- base::sys.nframe()
[10:33:12.838]     ...future.conditions <- base::list()
[10:33:12.838]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.838]     if (FALSE) {
[10:33:12.838]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.838]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.838]     }
[10:33:12.838]     ...future.result <- base::tryCatch({
[10:33:12.838]         base::withCallingHandlers({
[10:33:12.838]             ...future.value <- base::withVisible(base::local({
[10:33:12.838]                 withCallingHandlers({
[10:33:12.838]                   value(a) + 1
[10:33:12.838]                 }, immediateCondition = function(cond) {
[10:33:12.838]                   save_rds <- function (object, pathname, ...) 
[10:33:12.838]                   {
[10:33:12.838]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:12.838]                     if (file_test("-f", pathname_tmp)) {
[10:33:12.838]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.838]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:12.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.838]                         fi_tmp[["mtime"]])
[10:33:12.838]                     }
[10:33:12.838]                     tryCatch({
[10:33:12.838]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:12.838]                     }, error = function(ex) {
[10:33:12.838]                       msg <- conditionMessage(ex)
[10:33:12.838]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.838]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:12.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.838]                         fi_tmp[["mtime"]], msg)
[10:33:12.838]                       ex$message <- msg
[10:33:12.838]                       stop(ex)
[10:33:12.838]                     })
[10:33:12.838]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:12.838]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:12.838]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:12.838]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.838]                       fi <- file.info(pathname)
[10:33:12.838]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:12.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.838]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:12.838]                         fi[["size"]], fi[["mtime"]])
[10:33:12.838]                       stop(msg)
[10:33:12.838]                     }
[10:33:12.838]                     invisible(pathname)
[10:33:12.838]                   }
[10:33:12.838]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:12.838]                     rootPath = tempdir()) 
[10:33:12.838]                   {
[10:33:12.838]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:12.838]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:12.838]                       tmpdir = path, fileext = ".rds")
[10:33:12.838]                     save_rds(obj, file)
[10:33:12.838]                   }
[10:33:12.838]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:12.838]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.838]                   {
[10:33:12.838]                     inherits <- base::inherits
[10:33:12.838]                     invokeRestart <- base::invokeRestart
[10:33:12.838]                     is.null <- base::is.null
[10:33:12.838]                     muffled <- FALSE
[10:33:12.838]                     if (inherits(cond, "message")) {
[10:33:12.838]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:12.838]                       if (muffled) 
[10:33:12.838]                         invokeRestart("muffleMessage")
[10:33:12.838]                     }
[10:33:12.838]                     else if (inherits(cond, "warning")) {
[10:33:12.838]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:12.838]                       if (muffled) 
[10:33:12.838]                         invokeRestart("muffleWarning")
[10:33:12.838]                     }
[10:33:12.838]                     else if (inherits(cond, "condition")) {
[10:33:12.838]                       if (!is.null(pattern)) {
[10:33:12.838]                         computeRestarts <- base::computeRestarts
[10:33:12.838]                         grepl <- base::grepl
[10:33:12.838]                         restarts <- computeRestarts(cond)
[10:33:12.838]                         for (restart in restarts) {
[10:33:12.838]                           name <- restart$name
[10:33:12.838]                           if (is.null(name)) 
[10:33:12.838]                             next
[10:33:12.838]                           if (!grepl(pattern, name)) 
[10:33:12.838]                             next
[10:33:12.838]                           invokeRestart(restart)
[10:33:12.838]                           muffled <- TRUE
[10:33:12.838]                           break
[10:33:12.838]                         }
[10:33:12.838]                       }
[10:33:12.838]                     }
[10:33:12.838]                     invisible(muffled)
[10:33:12.838]                   }
[10:33:12.838]                   muffleCondition(cond)
[10:33:12.838]                 })
[10:33:12.838]             }))
[10:33:12.838]             future::FutureResult(value = ...future.value$value, 
[10:33:12.838]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.838]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.838]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.838]                     ...future.globalenv.names))
[10:33:12.838]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.838]         }, condition = base::local({
[10:33:12.838]             c <- base::c
[10:33:12.838]             inherits <- base::inherits
[10:33:12.838]             invokeRestart <- base::invokeRestart
[10:33:12.838]             length <- base::length
[10:33:12.838]             list <- base::list
[10:33:12.838]             seq.int <- base::seq.int
[10:33:12.838]             signalCondition <- base::signalCondition
[10:33:12.838]             sys.calls <- base::sys.calls
[10:33:12.838]             `[[` <- base::`[[`
[10:33:12.838]             `+` <- base::`+`
[10:33:12.838]             `<<-` <- base::`<<-`
[10:33:12.838]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.838]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.838]                   3L)]
[10:33:12.838]             }
[10:33:12.838]             function(cond) {
[10:33:12.838]                 is_error <- inherits(cond, "error")
[10:33:12.838]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.838]                   NULL)
[10:33:12.838]                 if (is_error) {
[10:33:12.838]                   sessionInformation <- function() {
[10:33:12.838]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.838]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.838]                       search = base::search(), system = base::Sys.info())
[10:33:12.838]                   }
[10:33:12.838]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.838]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.838]                     cond$call), session = sessionInformation(), 
[10:33:12.838]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.838]                   signalCondition(cond)
[10:33:12.838]                 }
[10:33:12.838]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.838]                 "immediateCondition"))) {
[10:33:12.838]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.838]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.838]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.838]                   if (TRUE && !signal) {
[10:33:12.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.838]                     {
[10:33:12.838]                       inherits <- base::inherits
[10:33:12.838]                       invokeRestart <- base::invokeRestart
[10:33:12.838]                       is.null <- base::is.null
[10:33:12.838]                       muffled <- FALSE
[10:33:12.838]                       if (inherits(cond, "message")) {
[10:33:12.838]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.838]                         if (muffled) 
[10:33:12.838]                           invokeRestart("muffleMessage")
[10:33:12.838]                       }
[10:33:12.838]                       else if (inherits(cond, "warning")) {
[10:33:12.838]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.838]                         if (muffled) 
[10:33:12.838]                           invokeRestart("muffleWarning")
[10:33:12.838]                       }
[10:33:12.838]                       else if (inherits(cond, "condition")) {
[10:33:12.838]                         if (!is.null(pattern)) {
[10:33:12.838]                           computeRestarts <- base::computeRestarts
[10:33:12.838]                           grepl <- base::grepl
[10:33:12.838]                           restarts <- computeRestarts(cond)
[10:33:12.838]                           for (restart in restarts) {
[10:33:12.838]                             name <- restart$name
[10:33:12.838]                             if (is.null(name)) 
[10:33:12.838]                               next
[10:33:12.838]                             if (!grepl(pattern, name)) 
[10:33:12.838]                               next
[10:33:12.838]                             invokeRestart(restart)
[10:33:12.838]                             muffled <- TRUE
[10:33:12.838]                             break
[10:33:12.838]                           }
[10:33:12.838]                         }
[10:33:12.838]                       }
[10:33:12.838]                       invisible(muffled)
[10:33:12.838]                     }
[10:33:12.838]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.838]                   }
[10:33:12.838]                 }
[10:33:12.838]                 else {
[10:33:12.838]                   if (TRUE) {
[10:33:12.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.838]                     {
[10:33:12.838]                       inherits <- base::inherits
[10:33:12.838]                       invokeRestart <- base::invokeRestart
[10:33:12.838]                       is.null <- base::is.null
[10:33:12.838]                       muffled <- FALSE
[10:33:12.838]                       if (inherits(cond, "message")) {
[10:33:12.838]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.838]                         if (muffled) 
[10:33:12.838]                           invokeRestart("muffleMessage")
[10:33:12.838]                       }
[10:33:12.838]                       else if (inherits(cond, "warning")) {
[10:33:12.838]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.838]                         if (muffled) 
[10:33:12.838]                           invokeRestart("muffleWarning")
[10:33:12.838]                       }
[10:33:12.838]                       else if (inherits(cond, "condition")) {
[10:33:12.838]                         if (!is.null(pattern)) {
[10:33:12.838]                           computeRestarts <- base::computeRestarts
[10:33:12.838]                           grepl <- base::grepl
[10:33:12.838]                           restarts <- computeRestarts(cond)
[10:33:12.838]                           for (restart in restarts) {
[10:33:12.838]                             name <- restart$name
[10:33:12.838]                             if (is.null(name)) 
[10:33:12.838]                               next
[10:33:12.838]                             if (!grepl(pattern, name)) 
[10:33:12.838]                               next
[10:33:12.838]                             invokeRestart(restart)
[10:33:12.838]                             muffled <- TRUE
[10:33:12.838]                             break
[10:33:12.838]                           }
[10:33:12.838]                         }
[10:33:12.838]                       }
[10:33:12.838]                       invisible(muffled)
[10:33:12.838]                     }
[10:33:12.838]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.838]                   }
[10:33:12.838]                 }
[10:33:12.838]             }
[10:33:12.838]         }))
[10:33:12.838]     }, error = function(ex) {
[10:33:12.838]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.838]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.838]                 ...future.rng), started = ...future.startTime, 
[10:33:12.838]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.838]             version = "1.8"), class = "FutureResult")
[10:33:12.838]     }, finally = {
[10:33:12.838]         if (!identical(...future.workdir, getwd())) 
[10:33:12.838]             setwd(...future.workdir)
[10:33:12.838]         {
[10:33:12.838]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.838]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.838]             }
[10:33:12.838]             base::options(...future.oldOptions)
[10:33:12.838]             if (.Platform$OS.type == "windows") {
[10:33:12.838]                 old_names <- names(...future.oldEnvVars)
[10:33:12.838]                 envs <- base::Sys.getenv()
[10:33:12.838]                 names <- names(envs)
[10:33:12.838]                 common <- intersect(names, old_names)
[10:33:12.838]                 added <- setdiff(names, old_names)
[10:33:12.838]                 removed <- setdiff(old_names, names)
[10:33:12.838]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.838]                   envs[common]]
[10:33:12.838]                 NAMES <- toupper(changed)
[10:33:12.838]                 args <- list()
[10:33:12.838]                 for (kk in seq_along(NAMES)) {
[10:33:12.838]                   name <- changed[[kk]]
[10:33:12.838]                   NAME <- NAMES[[kk]]
[10:33:12.838]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.838]                     next
[10:33:12.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.838]                 }
[10:33:12.838]                 NAMES <- toupper(added)
[10:33:12.838]                 for (kk in seq_along(NAMES)) {
[10:33:12.838]                   name <- added[[kk]]
[10:33:12.838]                   NAME <- NAMES[[kk]]
[10:33:12.838]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.838]                     next
[10:33:12.838]                   args[[name]] <- ""
[10:33:12.838]                 }
[10:33:12.838]                 NAMES <- toupper(removed)
[10:33:12.838]                 for (kk in seq_along(NAMES)) {
[10:33:12.838]                   name <- removed[[kk]]
[10:33:12.838]                   NAME <- NAMES[[kk]]
[10:33:12.838]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.838]                     next
[10:33:12.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.838]                 }
[10:33:12.838]                 if (length(args) > 0) 
[10:33:12.838]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.838]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.838]             }
[10:33:12.838]             else {
[10:33:12.838]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.838]             }
[10:33:12.838]             {
[10:33:12.838]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.838]                   0L) {
[10:33:12.838]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.838]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.838]                   base::options(opts)
[10:33:12.838]                 }
[10:33:12.838]                 {
[10:33:12.838]                   {
[10:33:12.838]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:12.838]                     NULL
[10:33:12.838]                   }
[10:33:12.838]                   options(future.plan = NULL)
[10:33:12.838]                   if (is.na(NA_character_)) 
[10:33:12.838]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.838]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.838]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.838]                     .init = FALSE)
[10:33:12.838]                 }
[10:33:12.838]             }
[10:33:12.838]         }
[10:33:12.838]     })
[10:33:12.838]     if (TRUE) {
[10:33:12.838]         base::sink(type = "output", split = FALSE)
[10:33:12.838]         if (TRUE) {
[10:33:12.838]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.838]         }
[10:33:12.838]         else {
[10:33:12.838]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.838]         }
[10:33:12.838]         base::close(...future.stdout)
[10:33:12.838]         ...future.stdout <- NULL
[10:33:12.838]     }
[10:33:12.838]     ...future.result$conditions <- ...future.conditions
[10:33:12.838]     ...future.result$finished <- base::Sys.time()
[10:33:12.838]     ...future.result
[10:33:12.838] }
[10:33:12.841] assign_globals() ...
[10:33:12.841] List of 1
[10:33:12.841]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55aa5282e940> 
[10:33:12.841]  - attr(*, "where")=List of 1
[10:33:12.841]   ..$ a:<environment: R_EmptyEnv> 
[10:33:12.841]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.841]  - attr(*, "resolved")= logi TRUE
[10:33:12.841]  - attr(*, "total_size")= num 10816
[10:33:12.841]  - attr(*, "already-done")= logi TRUE
[10:33:12.844] - copied ‘a’ to environment
[10:33:12.844] assign_globals() ... done
[10:33:12.844] requestCore(): workers = 2
[10:33:12.846] MulticoreFuture started
[10:33:12.847] - Launch lazy future ... done
[10:33:12.847] run() for ‘MulticoreFuture’ ... done
[10:33:12.848] result() for MulticoreFuture ...
[10:33:12.848] plan(): Setting new future strategy stack:
[10:33:12.848] List of future strategies:
[10:33:12.848] 1. sequential:
[10:33:12.848]    - args: function (..., envir = parent.frame())
[10:33:12.848]    - tweaked: FALSE
[10:33:12.848]    - call: NULL
[10:33:12.849] plan(): nbrOfWorkers() = 1
[10:33:12.852] plan(): Setting new future strategy stack:
[10:33:12.853] List of future strategies:
[10:33:12.853] 1. multicore:
[10:33:12.853]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:12.853]    - tweaked: FALSE
[10:33:12.853]    - call: plan(strategy)
[10:33:12.858] plan(): nbrOfWorkers() = 2
[10:33:12.859] result() for MulticoreFuture ...
[10:33:12.859] result() for MulticoreFuture ... done
[10:33:12.859] signalConditions() ...
[10:33:12.859]  - include = ‘immediateCondition’
[10:33:12.859]  - exclude = 
[10:33:12.859]  - resignal = FALSE
[10:33:12.860]  - Number of conditions: 4
[10:33:12.860] signalConditions() ... done
[10:33:12.860] result() for MulticoreFuture ... done
[10:33:12.860] result() for MulticoreFuture ...
[10:33:12.860] result() for MulticoreFuture ... done
[10:33:12.860] signalConditions() ...
[10:33:12.860]  - include = ‘immediateCondition’
[10:33:12.860]  - exclude = 
[10:33:12.861]  - resignal = FALSE
[10:33:12.861]  - Number of conditions: 4
[10:33:12.861] signalConditions() ... done
[10:33:12.861] Future state: ‘finished’
[10:33:12.861] result() for MulticoreFuture ...
[10:33:12.861] result() for MulticoreFuture ... done
[10:33:12.861] signalConditions() ...
[10:33:12.862]  - include = ‘condition’
[10:33:12.862]  - exclude = ‘immediateCondition’
[10:33:12.862]  - resignal = TRUE
[10:33:12.862]  - Number of conditions: 4
[10:33:12.862]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:12.850] result() for MulticoreFuture ...
[10:33:12.862]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:12.851] result() for MulticoreFuture ... done
[10:33:12.862]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:12.851] result() for MulticoreFuture ...
[10:33:12.863]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:12.851] result() for MulticoreFuture ... done
[10:33:12.863] signalConditions() ... done
value(b) = 2
[10:33:12.863] result() for MulticoreFuture ...
[10:33:12.863] result() for MulticoreFuture ... done
[10:33:12.863] result() for MulticoreFuture ...
[10:33:12.863] result() for MulticoreFuture ... done
[10:33:12.863] signalConditions() ...
[10:33:12.863]  - include = ‘immediateCondition’
[10:33:12.864]  - exclude = 
[10:33:12.864]  - resignal = FALSE
[10:33:12.864]  - Number of conditions: 4
[10:33:12.864] signalConditions() ... done
[10:33:12.864] Future state: ‘finished’
[10:33:12.864] result() for MulticoreFuture ...
[10:33:12.864] result() for MulticoreFuture ... done
[10:33:12.864] signalConditions() ...
[10:33:12.865]  - include = ‘condition’
[10:33:12.865]  - exclude = ‘immediateCondition’
[10:33:12.865]  - resignal = TRUE
[10:33:12.865]  - Number of conditions: 4
[10:33:12.865]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:12.850] result() for MulticoreFuture ...
[10:33:12.865]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:12.851] result() for MulticoreFuture ... done
[10:33:12.865]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:12.851] result() for MulticoreFuture ...
[10:33:12.866]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:12.851] result() for MulticoreFuture ... done
[10:33:12.866] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.866] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.866] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.867] 
[10:33:12.867] Searching for globals ... DONE
[10:33:12.867] - globals: [0] <none>
[10:33:12.867] getGlobalsAndPackages() ... DONE
[10:33:12.868] run() for ‘Future’ ...
[10:33:12.868] - state: ‘created’
[10:33:12.868] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:12.872] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:12.872] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:12.872]   - Field: ‘label’
[10:33:12.872]   - Field: ‘local’
[10:33:12.872]   - Field: ‘owner’
[10:33:12.873]   - Field: ‘envir’
[10:33:12.873]   - Field: ‘workers’
[10:33:12.873]   - Field: ‘packages’
[10:33:12.873]   - Field: ‘gc’
[10:33:12.873]   - Field: ‘job’
[10:33:12.873]   - Field: ‘conditions’
[10:33:12.873]   - Field: ‘expr’
[10:33:12.873]   - Field: ‘uuid’
[10:33:12.874]   - Field: ‘seed’
[10:33:12.874]   - Field: ‘version’
[10:33:12.874]   - Field: ‘result’
[10:33:12.874]   - Field: ‘asynchronous’
[10:33:12.874]   - Field: ‘calls’
[10:33:12.874]   - Field: ‘globals’
[10:33:12.874]   - Field: ‘stdout’
[10:33:12.874]   - Field: ‘earlySignal’
[10:33:12.874]   - Field: ‘lazy’
[10:33:12.875]   - Field: ‘state’
[10:33:12.875] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:12.875] - Launch lazy future ...
[10:33:12.875] Packages needed by the future expression (n = 0): <none>
[10:33:12.875] Packages needed by future strategies (n = 0): <none>
[10:33:12.876] {
[10:33:12.876]     {
[10:33:12.876]         {
[10:33:12.876]             ...future.startTime <- base::Sys.time()
[10:33:12.876]             {
[10:33:12.876]                 {
[10:33:12.876]                   {
[10:33:12.876]                     {
[10:33:12.876]                       base::local({
[10:33:12.876]                         has_future <- base::requireNamespace("future", 
[10:33:12.876]                           quietly = TRUE)
[10:33:12.876]                         if (has_future) {
[10:33:12.876]                           ns <- base::getNamespace("future")
[10:33:12.876]                           version <- ns[[".package"]][["version"]]
[10:33:12.876]                           if (is.null(version)) 
[10:33:12.876]                             version <- utils::packageVersion("future")
[10:33:12.876]                         }
[10:33:12.876]                         else {
[10:33:12.876]                           version <- NULL
[10:33:12.876]                         }
[10:33:12.876]                         if (!has_future || version < "1.8.0") {
[10:33:12.876]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.876]                             "", base::R.version$version.string), 
[10:33:12.876]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:12.876]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.876]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.876]                               "release", "version")], collapse = " "), 
[10:33:12.876]                             hostname = base::Sys.info()[["nodename"]])
[10:33:12.876]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.876]                             info)
[10:33:12.876]                           info <- base::paste(info, collapse = "; ")
[10:33:12.876]                           if (!has_future) {
[10:33:12.876]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.876]                               info)
[10:33:12.876]                           }
[10:33:12.876]                           else {
[10:33:12.876]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.876]                               info, version)
[10:33:12.876]                           }
[10:33:12.876]                           base::stop(msg)
[10:33:12.876]                         }
[10:33:12.876]                       })
[10:33:12.876]                     }
[10:33:12.876]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:12.876]                     base::options(mc.cores = 1L)
[10:33:12.876]                   }
[10:33:12.876]                   ...future.strategy.old <- future::plan("list")
[10:33:12.876]                   options(future.plan = NULL)
[10:33:12.876]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.876]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.876]                 }
[10:33:12.876]                 ...future.workdir <- getwd()
[10:33:12.876]             }
[10:33:12.876]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.876]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.876]         }
[10:33:12.876]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.876]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.876]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.876]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.876]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.876]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.876]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.876]             base::names(...future.oldOptions))
[10:33:12.876]     }
[10:33:12.876]     if (FALSE) {
[10:33:12.876]     }
[10:33:12.876]     else {
[10:33:12.876]         if (TRUE) {
[10:33:12.876]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.876]                 open = "w")
[10:33:12.876]         }
[10:33:12.876]         else {
[10:33:12.876]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.876]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.876]         }
[10:33:12.876]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.876]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.876]             base::sink(type = "output", split = FALSE)
[10:33:12.876]             base::close(...future.stdout)
[10:33:12.876]         }, add = TRUE)
[10:33:12.876]     }
[10:33:12.876]     ...future.frame <- base::sys.nframe()
[10:33:12.876]     ...future.conditions <- base::list()
[10:33:12.876]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.876]     if (FALSE) {
[10:33:12.876]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.876]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.876]     }
[10:33:12.876]     ...future.result <- base::tryCatch({
[10:33:12.876]         base::withCallingHandlers({
[10:33:12.876]             ...future.value <- base::withVisible(base::local({
[10:33:12.876]                 withCallingHandlers({
[10:33:12.876]                   1
[10:33:12.876]                 }, immediateCondition = function(cond) {
[10:33:12.876]                   save_rds <- function (object, pathname, ...) 
[10:33:12.876]                   {
[10:33:12.876]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:12.876]                     if (file_test("-f", pathname_tmp)) {
[10:33:12.876]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.876]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:12.876]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.876]                         fi_tmp[["mtime"]])
[10:33:12.876]                     }
[10:33:12.876]                     tryCatch({
[10:33:12.876]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:12.876]                     }, error = function(ex) {
[10:33:12.876]                       msg <- conditionMessage(ex)
[10:33:12.876]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.876]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:12.876]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.876]                         fi_tmp[["mtime"]], msg)
[10:33:12.876]                       ex$message <- msg
[10:33:12.876]                       stop(ex)
[10:33:12.876]                     })
[10:33:12.876]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:12.876]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:12.876]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:12.876]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.876]                       fi <- file.info(pathname)
[10:33:12.876]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:12.876]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.876]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:12.876]                         fi[["size"]], fi[["mtime"]])
[10:33:12.876]                       stop(msg)
[10:33:12.876]                     }
[10:33:12.876]                     invisible(pathname)
[10:33:12.876]                   }
[10:33:12.876]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:12.876]                     rootPath = tempdir()) 
[10:33:12.876]                   {
[10:33:12.876]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:12.876]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:12.876]                       tmpdir = path, fileext = ".rds")
[10:33:12.876]                     save_rds(obj, file)
[10:33:12.876]                   }
[10:33:12.876]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:12.876]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.876]                   {
[10:33:12.876]                     inherits <- base::inherits
[10:33:12.876]                     invokeRestart <- base::invokeRestart
[10:33:12.876]                     is.null <- base::is.null
[10:33:12.876]                     muffled <- FALSE
[10:33:12.876]                     if (inherits(cond, "message")) {
[10:33:12.876]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:12.876]                       if (muffled) 
[10:33:12.876]                         invokeRestart("muffleMessage")
[10:33:12.876]                     }
[10:33:12.876]                     else if (inherits(cond, "warning")) {
[10:33:12.876]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:12.876]                       if (muffled) 
[10:33:12.876]                         invokeRestart("muffleWarning")
[10:33:12.876]                     }
[10:33:12.876]                     else if (inherits(cond, "condition")) {
[10:33:12.876]                       if (!is.null(pattern)) {
[10:33:12.876]                         computeRestarts <- base::computeRestarts
[10:33:12.876]                         grepl <- base::grepl
[10:33:12.876]                         restarts <- computeRestarts(cond)
[10:33:12.876]                         for (restart in restarts) {
[10:33:12.876]                           name <- restart$name
[10:33:12.876]                           if (is.null(name)) 
[10:33:12.876]                             next
[10:33:12.876]                           if (!grepl(pattern, name)) 
[10:33:12.876]                             next
[10:33:12.876]                           invokeRestart(restart)
[10:33:12.876]                           muffled <- TRUE
[10:33:12.876]                           break
[10:33:12.876]                         }
[10:33:12.876]                       }
[10:33:12.876]                     }
[10:33:12.876]                     invisible(muffled)
[10:33:12.876]                   }
[10:33:12.876]                   muffleCondition(cond)
[10:33:12.876]                 })
[10:33:12.876]             }))
[10:33:12.876]             future::FutureResult(value = ...future.value$value, 
[10:33:12.876]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.876]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.876]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.876]                     ...future.globalenv.names))
[10:33:12.876]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.876]         }, condition = base::local({
[10:33:12.876]             c <- base::c
[10:33:12.876]             inherits <- base::inherits
[10:33:12.876]             invokeRestart <- base::invokeRestart
[10:33:12.876]             length <- base::length
[10:33:12.876]             list <- base::list
[10:33:12.876]             seq.int <- base::seq.int
[10:33:12.876]             signalCondition <- base::signalCondition
[10:33:12.876]             sys.calls <- base::sys.calls
[10:33:12.876]             `[[` <- base::`[[`
[10:33:12.876]             `+` <- base::`+`
[10:33:12.876]             `<<-` <- base::`<<-`
[10:33:12.876]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.876]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.876]                   3L)]
[10:33:12.876]             }
[10:33:12.876]             function(cond) {
[10:33:12.876]                 is_error <- inherits(cond, "error")
[10:33:12.876]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.876]                   NULL)
[10:33:12.876]                 if (is_error) {
[10:33:12.876]                   sessionInformation <- function() {
[10:33:12.876]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.876]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.876]                       search = base::search(), system = base::Sys.info())
[10:33:12.876]                   }
[10:33:12.876]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.876]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.876]                     cond$call), session = sessionInformation(), 
[10:33:12.876]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.876]                   signalCondition(cond)
[10:33:12.876]                 }
[10:33:12.876]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.876]                 "immediateCondition"))) {
[10:33:12.876]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.876]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.876]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.876]                   if (TRUE && !signal) {
[10:33:12.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.876]                     {
[10:33:12.876]                       inherits <- base::inherits
[10:33:12.876]                       invokeRestart <- base::invokeRestart
[10:33:12.876]                       is.null <- base::is.null
[10:33:12.876]                       muffled <- FALSE
[10:33:12.876]                       if (inherits(cond, "message")) {
[10:33:12.876]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.876]                         if (muffled) 
[10:33:12.876]                           invokeRestart("muffleMessage")
[10:33:12.876]                       }
[10:33:12.876]                       else if (inherits(cond, "warning")) {
[10:33:12.876]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.876]                         if (muffled) 
[10:33:12.876]                           invokeRestart("muffleWarning")
[10:33:12.876]                       }
[10:33:12.876]                       else if (inherits(cond, "condition")) {
[10:33:12.876]                         if (!is.null(pattern)) {
[10:33:12.876]                           computeRestarts <- base::computeRestarts
[10:33:12.876]                           grepl <- base::grepl
[10:33:12.876]                           restarts <- computeRestarts(cond)
[10:33:12.876]                           for (restart in restarts) {
[10:33:12.876]                             name <- restart$name
[10:33:12.876]                             if (is.null(name)) 
[10:33:12.876]                               next
[10:33:12.876]                             if (!grepl(pattern, name)) 
[10:33:12.876]                               next
[10:33:12.876]                             invokeRestart(restart)
[10:33:12.876]                             muffled <- TRUE
[10:33:12.876]                             break
[10:33:12.876]                           }
[10:33:12.876]                         }
[10:33:12.876]                       }
[10:33:12.876]                       invisible(muffled)
[10:33:12.876]                     }
[10:33:12.876]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.876]                   }
[10:33:12.876]                 }
[10:33:12.876]                 else {
[10:33:12.876]                   if (TRUE) {
[10:33:12.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.876]                     {
[10:33:12.876]                       inherits <- base::inherits
[10:33:12.876]                       invokeRestart <- base::invokeRestart
[10:33:12.876]                       is.null <- base::is.null
[10:33:12.876]                       muffled <- FALSE
[10:33:12.876]                       if (inherits(cond, "message")) {
[10:33:12.876]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.876]                         if (muffled) 
[10:33:12.876]                           invokeRestart("muffleMessage")
[10:33:12.876]                       }
[10:33:12.876]                       else if (inherits(cond, "warning")) {
[10:33:12.876]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.876]                         if (muffled) 
[10:33:12.876]                           invokeRestart("muffleWarning")
[10:33:12.876]                       }
[10:33:12.876]                       else if (inherits(cond, "condition")) {
[10:33:12.876]                         if (!is.null(pattern)) {
[10:33:12.876]                           computeRestarts <- base::computeRestarts
[10:33:12.876]                           grepl <- base::grepl
[10:33:12.876]                           restarts <- computeRestarts(cond)
[10:33:12.876]                           for (restart in restarts) {
[10:33:12.876]                             name <- restart$name
[10:33:12.876]                             if (is.null(name)) 
[10:33:12.876]                               next
[10:33:12.876]                             if (!grepl(pattern, name)) 
[10:33:12.876]                               next
[10:33:12.876]                             invokeRestart(restart)
[10:33:12.876]                             muffled <- TRUE
[10:33:12.876]                             break
[10:33:12.876]                           }
[10:33:12.876]                         }
[10:33:12.876]                       }
[10:33:12.876]                       invisible(muffled)
[10:33:12.876]                     }
[10:33:12.876]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.876]                   }
[10:33:12.876]                 }
[10:33:12.876]             }
[10:33:12.876]         }))
[10:33:12.876]     }, error = function(ex) {
[10:33:12.876]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.876]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.876]                 ...future.rng), started = ...future.startTime, 
[10:33:12.876]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.876]             version = "1.8"), class = "FutureResult")
[10:33:12.876]     }, finally = {
[10:33:12.876]         if (!identical(...future.workdir, getwd())) 
[10:33:12.876]             setwd(...future.workdir)
[10:33:12.876]         {
[10:33:12.876]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.876]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.876]             }
[10:33:12.876]             base::options(...future.oldOptions)
[10:33:12.876]             if (.Platform$OS.type == "windows") {
[10:33:12.876]                 old_names <- names(...future.oldEnvVars)
[10:33:12.876]                 envs <- base::Sys.getenv()
[10:33:12.876]                 names <- names(envs)
[10:33:12.876]                 common <- intersect(names, old_names)
[10:33:12.876]                 added <- setdiff(names, old_names)
[10:33:12.876]                 removed <- setdiff(old_names, names)
[10:33:12.876]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.876]                   envs[common]]
[10:33:12.876]                 NAMES <- toupper(changed)
[10:33:12.876]                 args <- list()
[10:33:12.876]                 for (kk in seq_along(NAMES)) {
[10:33:12.876]                   name <- changed[[kk]]
[10:33:12.876]                   NAME <- NAMES[[kk]]
[10:33:12.876]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.876]                     next
[10:33:12.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.876]                 }
[10:33:12.876]                 NAMES <- toupper(added)
[10:33:12.876]                 for (kk in seq_along(NAMES)) {
[10:33:12.876]                   name <- added[[kk]]
[10:33:12.876]                   NAME <- NAMES[[kk]]
[10:33:12.876]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.876]                     next
[10:33:12.876]                   args[[name]] <- ""
[10:33:12.876]                 }
[10:33:12.876]                 NAMES <- toupper(removed)
[10:33:12.876]                 for (kk in seq_along(NAMES)) {
[10:33:12.876]                   name <- removed[[kk]]
[10:33:12.876]                   NAME <- NAMES[[kk]]
[10:33:12.876]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.876]                     next
[10:33:12.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.876]                 }
[10:33:12.876]                 if (length(args) > 0) 
[10:33:12.876]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.876]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.876]             }
[10:33:12.876]             else {
[10:33:12.876]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.876]             }
[10:33:12.876]             {
[10:33:12.876]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.876]                   0L) {
[10:33:12.876]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.876]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.876]                   base::options(opts)
[10:33:12.876]                 }
[10:33:12.876]                 {
[10:33:12.876]                   {
[10:33:12.876]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:12.876]                     NULL
[10:33:12.876]                   }
[10:33:12.876]                   options(future.plan = NULL)
[10:33:12.876]                   if (is.na(NA_character_)) 
[10:33:12.876]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.876]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.876]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.876]                     .init = FALSE)
[10:33:12.876]                 }
[10:33:12.876]             }
[10:33:12.876]         }
[10:33:12.876]     })
[10:33:12.876]     if (TRUE) {
[10:33:12.876]         base::sink(type = "output", split = FALSE)
[10:33:12.876]         if (TRUE) {
[10:33:12.876]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.876]         }
[10:33:12.876]         else {
[10:33:12.876]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.876]         }
[10:33:12.876]         base::close(...future.stdout)
[10:33:12.876]         ...future.stdout <- NULL
[10:33:12.876]     }
[10:33:12.876]     ...future.result$conditions <- ...future.conditions
[10:33:12.876]     ...future.result$finished <- base::Sys.time()
[10:33:12.876]     ...future.result
[10:33:12.876] }
[10:33:12.878] requestCore(): workers = 2
[10:33:12.880] MulticoreFuture started
[10:33:12.880] - Launch lazy future ... done
[10:33:12.881] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.881] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.882] Searching for globals...
[10:33:12.881] plan(): Setting new future strategy stack:
[10:33:12.882] List of future strategies:
[10:33:12.882] 1. sequential:
[10:33:12.882]    - args: function (..., envir = parent.frame())
[10:33:12.882]    - tweaked: FALSE
[10:33:12.882]    - call: NULL
[10:33:12.883] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.890] plan(): Setting new future strategy stack:
[10:33:12.890] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:12.890] List of future strategies:
[10:33:12.890] 1. multicore:
[10:33:12.890]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:12.890]    - tweaked: FALSE
[10:33:12.890]    - call: plan(strategy)
[10:33:12.891] Searching for globals ... DONE
[10:33:12.891] Resolving globals: TRUE
[10:33:12.892] Resolving any globals that are futures ...
[10:33:12.892] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:12.892] Resolving any globals that are futures ... DONE
[10:33:12.893] Resolving futures part of globals (recursively) ...
[10:33:12.894] resolve() on list ...
[10:33:12.894]  recursive: 99
[10:33:12.895]  length: 1
[10:33:12.895]  elements: ‘a’
[10:33:12.896] plan(): nbrOfWorkers() = 2
[10:33:12.896] Future #1
[10:33:12.897] result() for MulticoreFuture ...
[10:33:12.898] result() for MulticoreFuture ...
[10:33:12.898] result() for MulticoreFuture ... done
[10:33:12.899] result() for MulticoreFuture ... done
[10:33:12.899] result() for MulticoreFuture ...
[10:33:12.899] result() for MulticoreFuture ... done
[10:33:12.899] A MulticoreFuture was resolved
[10:33:12.900]  length: 0 (resolved future 1)
[10:33:12.900] resolve() on list ... DONE
[10:33:12.900] - globals: [1] ‘a’
[10:33:12.900] Resolving futures part of globals (recursively) ... DONE
[10:33:12.902] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[10:33:12.903] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[10:33:12.903] - globals: [1] ‘a’
[10:33:12.903] - packages: [1] ‘future’
[10:33:12.903] getGlobalsAndPackages() ... DONE
[10:33:12.904] run() for ‘Future’ ...
[10:33:12.904] - state: ‘created’
[10:33:12.904] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:12.909] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:12.909] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:12.909]   - Field: ‘label’
[10:33:12.909]   - Field: ‘local’
[10:33:12.909]   - Field: ‘owner’
[10:33:12.909]   - Field: ‘envir’
[10:33:12.910]   - Field: ‘workers’
[10:33:12.910]   - Field: ‘packages’
[10:33:12.910]   - Field: ‘gc’
[10:33:12.910]   - Field: ‘job’
[10:33:12.910]   - Field: ‘conditions’
[10:33:12.910]   - Field: ‘expr’
[10:33:12.910]   - Field: ‘uuid’
[10:33:12.910]   - Field: ‘seed’
[10:33:12.911]   - Field: ‘version’
[10:33:12.911]   - Field: ‘result’
[10:33:12.911]   - Field: ‘asynchronous’
[10:33:12.911]   - Field: ‘calls’
[10:33:12.911]   - Field: ‘globals’
[10:33:12.911]   - Field: ‘stdout’
[10:33:12.911]   - Field: ‘earlySignal’
[10:33:12.911]   - Field: ‘lazy’
[10:33:12.912]   - Field: ‘state’
[10:33:12.912] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:12.912] - Launch lazy future ...
[10:33:12.912] Packages needed by the future expression (n = 1): ‘future’
[10:33:12.912] Packages needed by future strategies (n = 0): <none>
[10:33:12.913] {
[10:33:12.913]     {
[10:33:12.913]         {
[10:33:12.913]             ...future.startTime <- base::Sys.time()
[10:33:12.913]             {
[10:33:12.913]                 {
[10:33:12.913]                   {
[10:33:12.913]                     {
[10:33:12.913]                       {
[10:33:12.913]                         base::local({
[10:33:12.913]                           has_future <- base::requireNamespace("future", 
[10:33:12.913]                             quietly = TRUE)
[10:33:12.913]                           if (has_future) {
[10:33:12.913]                             ns <- base::getNamespace("future")
[10:33:12.913]                             version <- ns[[".package"]][["version"]]
[10:33:12.913]                             if (is.null(version)) 
[10:33:12.913]                               version <- utils::packageVersion("future")
[10:33:12.913]                           }
[10:33:12.913]                           else {
[10:33:12.913]                             version <- NULL
[10:33:12.913]                           }
[10:33:12.913]                           if (!has_future || version < "1.8.0") {
[10:33:12.913]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.913]                               "", base::R.version$version.string), 
[10:33:12.913]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:12.913]                                 base::R.version$platform, 8 * 
[10:33:12.913]                                   base::.Machine$sizeof.pointer), 
[10:33:12.913]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.913]                                 "release", "version")], collapse = " "), 
[10:33:12.913]                               hostname = base::Sys.info()[["nodename"]])
[10:33:12.913]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.913]                               info)
[10:33:12.913]                             info <- base::paste(info, collapse = "; ")
[10:33:12.913]                             if (!has_future) {
[10:33:12.913]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.913]                                 info)
[10:33:12.913]                             }
[10:33:12.913]                             else {
[10:33:12.913]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.913]                                 info, version)
[10:33:12.913]                             }
[10:33:12.913]                             base::stop(msg)
[10:33:12.913]                           }
[10:33:12.913]                         })
[10:33:12.913]                       }
[10:33:12.913]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:12.913]                       base::options(mc.cores = 1L)
[10:33:12.913]                     }
[10:33:12.913]                     base::local({
[10:33:12.913]                       for (pkg in "future") {
[10:33:12.913]                         base::loadNamespace(pkg)
[10:33:12.913]                         base::library(pkg, character.only = TRUE)
[10:33:12.913]                       }
[10:33:12.913]                     })
[10:33:12.913]                   }
[10:33:12.913]                   ...future.strategy.old <- future::plan("list")
[10:33:12.913]                   options(future.plan = NULL)
[10:33:12.913]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.913]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.913]                 }
[10:33:12.913]                 ...future.workdir <- getwd()
[10:33:12.913]             }
[10:33:12.913]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.913]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.913]         }
[10:33:12.913]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.913]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.913]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.913]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.913]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.913]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.913]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.913]             base::names(...future.oldOptions))
[10:33:12.913]     }
[10:33:12.913]     if (FALSE) {
[10:33:12.913]     }
[10:33:12.913]     else {
[10:33:12.913]         if (TRUE) {
[10:33:12.913]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.913]                 open = "w")
[10:33:12.913]         }
[10:33:12.913]         else {
[10:33:12.913]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.913]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.913]         }
[10:33:12.913]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.913]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.913]             base::sink(type = "output", split = FALSE)
[10:33:12.913]             base::close(...future.stdout)
[10:33:12.913]         }, add = TRUE)
[10:33:12.913]     }
[10:33:12.913]     ...future.frame <- base::sys.nframe()
[10:33:12.913]     ...future.conditions <- base::list()
[10:33:12.913]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.913]     if (FALSE) {
[10:33:12.913]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.913]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.913]     }
[10:33:12.913]     ...future.result <- base::tryCatch({
[10:33:12.913]         base::withCallingHandlers({
[10:33:12.913]             ...future.value <- base::withVisible(base::local({
[10:33:12.913]                 withCallingHandlers({
[10:33:12.913]                   value(a) + 1
[10:33:12.913]                 }, immediateCondition = function(cond) {
[10:33:12.913]                   save_rds <- function (object, pathname, ...) 
[10:33:12.913]                   {
[10:33:12.913]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:12.913]                     if (file_test("-f", pathname_tmp)) {
[10:33:12.913]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.913]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:12.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.913]                         fi_tmp[["mtime"]])
[10:33:12.913]                     }
[10:33:12.913]                     tryCatch({
[10:33:12.913]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:12.913]                     }, error = function(ex) {
[10:33:12.913]                       msg <- conditionMessage(ex)
[10:33:12.913]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.913]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:12.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.913]                         fi_tmp[["mtime"]], msg)
[10:33:12.913]                       ex$message <- msg
[10:33:12.913]                       stop(ex)
[10:33:12.913]                     })
[10:33:12.913]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:12.913]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:12.913]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:12.913]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.913]                       fi <- file.info(pathname)
[10:33:12.913]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:12.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.913]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:12.913]                         fi[["size"]], fi[["mtime"]])
[10:33:12.913]                       stop(msg)
[10:33:12.913]                     }
[10:33:12.913]                     invisible(pathname)
[10:33:12.913]                   }
[10:33:12.913]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:12.913]                     rootPath = tempdir()) 
[10:33:12.913]                   {
[10:33:12.913]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:12.913]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:12.913]                       tmpdir = path, fileext = ".rds")
[10:33:12.913]                     save_rds(obj, file)
[10:33:12.913]                   }
[10:33:12.913]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:12.913]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.913]                   {
[10:33:12.913]                     inherits <- base::inherits
[10:33:12.913]                     invokeRestart <- base::invokeRestart
[10:33:12.913]                     is.null <- base::is.null
[10:33:12.913]                     muffled <- FALSE
[10:33:12.913]                     if (inherits(cond, "message")) {
[10:33:12.913]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:12.913]                       if (muffled) 
[10:33:12.913]                         invokeRestart("muffleMessage")
[10:33:12.913]                     }
[10:33:12.913]                     else if (inherits(cond, "warning")) {
[10:33:12.913]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:12.913]                       if (muffled) 
[10:33:12.913]                         invokeRestart("muffleWarning")
[10:33:12.913]                     }
[10:33:12.913]                     else if (inherits(cond, "condition")) {
[10:33:12.913]                       if (!is.null(pattern)) {
[10:33:12.913]                         computeRestarts <- base::computeRestarts
[10:33:12.913]                         grepl <- base::grepl
[10:33:12.913]                         restarts <- computeRestarts(cond)
[10:33:12.913]                         for (restart in restarts) {
[10:33:12.913]                           name <- restart$name
[10:33:12.913]                           if (is.null(name)) 
[10:33:12.913]                             next
[10:33:12.913]                           if (!grepl(pattern, name)) 
[10:33:12.913]                             next
[10:33:12.913]                           invokeRestart(restart)
[10:33:12.913]                           muffled <- TRUE
[10:33:12.913]                           break
[10:33:12.913]                         }
[10:33:12.913]                       }
[10:33:12.913]                     }
[10:33:12.913]                     invisible(muffled)
[10:33:12.913]                   }
[10:33:12.913]                   muffleCondition(cond)
[10:33:12.913]                 })
[10:33:12.913]             }))
[10:33:12.913]             future::FutureResult(value = ...future.value$value, 
[10:33:12.913]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.913]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.913]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.913]                     ...future.globalenv.names))
[10:33:12.913]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.913]         }, condition = base::local({
[10:33:12.913]             c <- base::c
[10:33:12.913]             inherits <- base::inherits
[10:33:12.913]             invokeRestart <- base::invokeRestart
[10:33:12.913]             length <- base::length
[10:33:12.913]             list <- base::list
[10:33:12.913]             seq.int <- base::seq.int
[10:33:12.913]             signalCondition <- base::signalCondition
[10:33:12.913]             sys.calls <- base::sys.calls
[10:33:12.913]             `[[` <- base::`[[`
[10:33:12.913]             `+` <- base::`+`
[10:33:12.913]             `<<-` <- base::`<<-`
[10:33:12.913]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.913]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.913]                   3L)]
[10:33:12.913]             }
[10:33:12.913]             function(cond) {
[10:33:12.913]                 is_error <- inherits(cond, "error")
[10:33:12.913]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.913]                   NULL)
[10:33:12.913]                 if (is_error) {
[10:33:12.913]                   sessionInformation <- function() {
[10:33:12.913]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.913]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.913]                       search = base::search(), system = base::Sys.info())
[10:33:12.913]                   }
[10:33:12.913]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.913]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.913]                     cond$call), session = sessionInformation(), 
[10:33:12.913]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.913]                   signalCondition(cond)
[10:33:12.913]                 }
[10:33:12.913]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.913]                 "immediateCondition"))) {
[10:33:12.913]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.913]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.913]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.913]                   if (TRUE && !signal) {
[10:33:12.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.913]                     {
[10:33:12.913]                       inherits <- base::inherits
[10:33:12.913]                       invokeRestart <- base::invokeRestart
[10:33:12.913]                       is.null <- base::is.null
[10:33:12.913]                       muffled <- FALSE
[10:33:12.913]                       if (inherits(cond, "message")) {
[10:33:12.913]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.913]                         if (muffled) 
[10:33:12.913]                           invokeRestart("muffleMessage")
[10:33:12.913]                       }
[10:33:12.913]                       else if (inherits(cond, "warning")) {
[10:33:12.913]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.913]                         if (muffled) 
[10:33:12.913]                           invokeRestart("muffleWarning")
[10:33:12.913]                       }
[10:33:12.913]                       else if (inherits(cond, "condition")) {
[10:33:12.913]                         if (!is.null(pattern)) {
[10:33:12.913]                           computeRestarts <- base::computeRestarts
[10:33:12.913]                           grepl <- base::grepl
[10:33:12.913]                           restarts <- computeRestarts(cond)
[10:33:12.913]                           for (restart in restarts) {
[10:33:12.913]                             name <- restart$name
[10:33:12.913]                             if (is.null(name)) 
[10:33:12.913]                               next
[10:33:12.913]                             if (!grepl(pattern, name)) 
[10:33:12.913]                               next
[10:33:12.913]                             invokeRestart(restart)
[10:33:12.913]                             muffled <- TRUE
[10:33:12.913]                             break
[10:33:12.913]                           }
[10:33:12.913]                         }
[10:33:12.913]                       }
[10:33:12.913]                       invisible(muffled)
[10:33:12.913]                     }
[10:33:12.913]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.913]                   }
[10:33:12.913]                 }
[10:33:12.913]                 else {
[10:33:12.913]                   if (TRUE) {
[10:33:12.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.913]                     {
[10:33:12.913]                       inherits <- base::inherits
[10:33:12.913]                       invokeRestart <- base::invokeRestart
[10:33:12.913]                       is.null <- base::is.null
[10:33:12.913]                       muffled <- FALSE
[10:33:12.913]                       if (inherits(cond, "message")) {
[10:33:12.913]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.913]                         if (muffled) 
[10:33:12.913]                           invokeRestart("muffleMessage")
[10:33:12.913]                       }
[10:33:12.913]                       else if (inherits(cond, "warning")) {
[10:33:12.913]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.913]                         if (muffled) 
[10:33:12.913]                           invokeRestart("muffleWarning")
[10:33:12.913]                       }
[10:33:12.913]                       else if (inherits(cond, "condition")) {
[10:33:12.913]                         if (!is.null(pattern)) {
[10:33:12.913]                           computeRestarts <- base::computeRestarts
[10:33:12.913]                           grepl <- base::grepl
[10:33:12.913]                           restarts <- computeRestarts(cond)
[10:33:12.913]                           for (restart in restarts) {
[10:33:12.913]                             name <- restart$name
[10:33:12.913]                             if (is.null(name)) 
[10:33:12.913]                               next
[10:33:12.913]                             if (!grepl(pattern, name)) 
[10:33:12.913]                               next
[10:33:12.913]                             invokeRestart(restart)
[10:33:12.913]                             muffled <- TRUE
[10:33:12.913]                             break
[10:33:12.913]                           }
[10:33:12.913]                         }
[10:33:12.913]                       }
[10:33:12.913]                       invisible(muffled)
[10:33:12.913]                     }
[10:33:12.913]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.913]                   }
[10:33:12.913]                 }
[10:33:12.913]             }
[10:33:12.913]         }))
[10:33:12.913]     }, error = function(ex) {
[10:33:12.913]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.913]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.913]                 ...future.rng), started = ...future.startTime, 
[10:33:12.913]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.913]             version = "1.8"), class = "FutureResult")
[10:33:12.913]     }, finally = {
[10:33:12.913]         if (!identical(...future.workdir, getwd())) 
[10:33:12.913]             setwd(...future.workdir)
[10:33:12.913]         {
[10:33:12.913]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.913]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.913]             }
[10:33:12.913]             base::options(...future.oldOptions)
[10:33:12.913]             if (.Platform$OS.type == "windows") {
[10:33:12.913]                 old_names <- names(...future.oldEnvVars)
[10:33:12.913]                 envs <- base::Sys.getenv()
[10:33:12.913]                 names <- names(envs)
[10:33:12.913]                 common <- intersect(names, old_names)
[10:33:12.913]                 added <- setdiff(names, old_names)
[10:33:12.913]                 removed <- setdiff(old_names, names)
[10:33:12.913]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.913]                   envs[common]]
[10:33:12.913]                 NAMES <- toupper(changed)
[10:33:12.913]                 args <- list()
[10:33:12.913]                 for (kk in seq_along(NAMES)) {
[10:33:12.913]                   name <- changed[[kk]]
[10:33:12.913]                   NAME <- NAMES[[kk]]
[10:33:12.913]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.913]                     next
[10:33:12.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.913]                 }
[10:33:12.913]                 NAMES <- toupper(added)
[10:33:12.913]                 for (kk in seq_along(NAMES)) {
[10:33:12.913]                   name <- added[[kk]]
[10:33:12.913]                   NAME <- NAMES[[kk]]
[10:33:12.913]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.913]                     next
[10:33:12.913]                   args[[name]] <- ""
[10:33:12.913]                 }
[10:33:12.913]                 NAMES <- toupper(removed)
[10:33:12.913]                 for (kk in seq_along(NAMES)) {
[10:33:12.913]                   name <- removed[[kk]]
[10:33:12.913]                   NAME <- NAMES[[kk]]
[10:33:12.913]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.913]                     next
[10:33:12.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.913]                 }
[10:33:12.913]                 if (length(args) > 0) 
[10:33:12.913]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.913]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.913]             }
[10:33:12.913]             else {
[10:33:12.913]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.913]             }
[10:33:12.913]             {
[10:33:12.913]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.913]                   0L) {
[10:33:12.913]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.913]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.913]                   base::options(opts)
[10:33:12.913]                 }
[10:33:12.913]                 {
[10:33:12.913]                   {
[10:33:12.913]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:12.913]                     NULL
[10:33:12.913]                   }
[10:33:12.913]                   options(future.plan = NULL)
[10:33:12.913]                   if (is.na(NA_character_)) 
[10:33:12.913]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.913]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.913]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.913]                     .init = FALSE)
[10:33:12.913]                 }
[10:33:12.913]             }
[10:33:12.913]         }
[10:33:12.913]     })
[10:33:12.913]     if (TRUE) {
[10:33:12.913]         base::sink(type = "output", split = FALSE)
[10:33:12.913]         if (TRUE) {
[10:33:12.913]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.913]         }
[10:33:12.913]         else {
[10:33:12.913]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.913]         }
[10:33:12.913]         base::close(...future.stdout)
[10:33:12.913]         ...future.stdout <- NULL
[10:33:12.913]     }
[10:33:12.913]     ...future.result$conditions <- ...future.conditions
[10:33:12.913]     ...future.result$finished <- base::Sys.time()
[10:33:12.913]     ...future.result
[10:33:12.913] }
[10:33:12.915] assign_globals() ...
[10:33:12.915] List of 1
[10:33:12.915]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55aa531ec938> 
[10:33:12.915]  - attr(*, "where")=List of 1
[10:33:12.915]   ..$ a:<environment: R_EmptyEnv> 
[10:33:12.915]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.915]  - attr(*, "resolved")= logi TRUE
[10:33:12.915]  - attr(*, "total_size")= num 10816
[10:33:12.915]  - attr(*, "already-done")= logi TRUE
[10:33:12.919] - copied ‘a’ to environment
[10:33:12.919] assign_globals() ... done
[10:33:12.919] requestCore(): workers = 2
[10:33:12.921] MulticoreFuture started
[10:33:12.921] - Launch lazy future ... done
[10:33:12.922] run() for ‘MulticoreFuture’ ... done
[10:33:12.922] result() for MulticoreFuture ...
[10:33:12.923] plan(): Setting new future strategy stack:
[10:33:12.923] List of future strategies:
[10:33:12.923] 1. sequential:
[10:33:12.923]    - args: function (..., envir = parent.frame())
[10:33:12.923]    - tweaked: FALSE
[10:33:12.923]    - call: NULL
[10:33:12.924] plan(): nbrOfWorkers() = 1
[10:33:12.927] plan(): Setting new future strategy stack:
[10:33:12.928] List of future strategies:
[10:33:12.928] 1. multicore:
[10:33:12.928]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:12.928]    - tweaked: FALSE
[10:33:12.928]    - call: plan(strategy)
[10:33:12.933] plan(): nbrOfWorkers() = 2
[10:33:12.934] result() for MulticoreFuture ...
[10:33:12.934] result() for MulticoreFuture ... done
[10:33:12.934] signalConditions() ...
[10:33:12.934]  - include = ‘immediateCondition’
[10:33:12.934]  - exclude = 
[10:33:12.934]  - resignal = FALSE
[10:33:12.935]  - Number of conditions: 4
[10:33:12.935] signalConditions() ... done
[10:33:12.935] result() for MulticoreFuture ... done
[10:33:12.935] result() for MulticoreFuture ...
[10:33:12.935] result() for MulticoreFuture ... done
[10:33:12.936] signalConditions() ...
[10:33:12.936]  - include = ‘immediateCondition’
[10:33:12.936]  - exclude = 
[10:33:12.936]  - resignal = FALSE
[10:33:12.936]  - Number of conditions: 4
[10:33:12.936] signalConditions() ... done
[10:33:12.936] Future state: ‘finished’
[10:33:12.937] result() for MulticoreFuture ...
[10:33:12.937] result() for MulticoreFuture ... done
[10:33:12.937] signalConditions() ...
[10:33:12.937]  - include = ‘condition’
[10:33:12.937]  - exclude = ‘immediateCondition’
[10:33:12.937]  - resignal = TRUE
[10:33:12.937]  - Number of conditions: 4
[10:33:12.937]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:12.925] result() for MulticoreFuture ...
[10:33:12.938]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:12.926] result() for MulticoreFuture ... done
[10:33:12.938]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:12.926] result() for MulticoreFuture ...
[10:33:12.941]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:12.926] result() for MulticoreFuture ... done
[10:33:12.941] signalConditions() ... done
value(b) = 2
[10:33:12.941] result() for MulticoreFuture ...
[10:33:12.942] result() for MulticoreFuture ... done
[10:33:12.942] result() for MulticoreFuture ...
[10:33:12.942] result() for MulticoreFuture ... done
[10:33:12.942] signalConditions() ...
[10:33:12.942]  - include = ‘immediateCondition’
[10:33:12.943]  - exclude = 
[10:33:12.943]  - resignal = FALSE
[10:33:12.943]  - Number of conditions: 4
[10:33:12.943] signalConditions() ... done
[10:33:12.943] Future state: ‘finished’
[10:33:12.944] result() for MulticoreFuture ...
[10:33:12.944] result() for MulticoreFuture ... done
[10:33:12.944] signalConditions() ...
[10:33:12.944]  - include = ‘condition’
[10:33:12.944]  - exclude = ‘immediateCondition’
[10:33:12.944]  - resignal = TRUE
[10:33:12.944]  - Number of conditions: 4
[10:33:12.945]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:12.925] result() for MulticoreFuture ...
[10:33:12.945]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:12.926] result() for MulticoreFuture ... done
[10:33:12.945]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:12.926] result() for MulticoreFuture ...
[10:33:12.945]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:12.926] result() for MulticoreFuture ... done
[10:33:12.945] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.946] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.946] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.947] 
[10:33:12.947] Searching for globals ... DONE
[10:33:12.947] - globals: [0] <none>
[10:33:12.947] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:12.948] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:12.948] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:12.949] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:12.949] Searching for globals ... DONE
[10:33:12.950] Resolving globals: TRUE
[10:33:12.950] Resolving any globals that are futures ...
[10:33:12.950] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:12.950] Resolving any globals that are futures ... DONE
[10:33:12.950] Resolving futures part of globals (recursively) ...
[10:33:12.951] resolve() on list ...
[10:33:12.951]  recursive: 99
[10:33:12.951]  length: 1
[10:33:12.951]  elements: ‘a’
[10:33:12.951] run() for ‘Future’ ...
[10:33:12.951] - state: ‘created’
[10:33:12.951] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:12.955] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:12.955] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:12.956]   - Field: ‘label’
[10:33:12.956]   - Field: ‘local’
[10:33:12.956]   - Field: ‘owner’
[10:33:12.956]   - Field: ‘envir’
[10:33:12.956]   - Field: ‘workers’
[10:33:12.956]   - Field: ‘packages’
[10:33:12.956]   - Field: ‘gc’
[10:33:12.956]   - Field: ‘job’
[10:33:12.957]   - Field: ‘conditions’
[10:33:12.957]   - Field: ‘expr’
[10:33:12.957]   - Field: ‘uuid’
[10:33:12.957]   - Field: ‘seed’
[10:33:12.957]   - Field: ‘version’
[10:33:12.957]   - Field: ‘result’
[10:33:12.957]   - Field: ‘asynchronous’
[10:33:12.957]   - Field: ‘calls’
[10:33:12.958]   - Field: ‘globals’
[10:33:12.958]   - Field: ‘stdout’
[10:33:12.958]   - Field: ‘earlySignal’
[10:33:12.958]   - Field: ‘lazy’
[10:33:12.958]   - Field: ‘state’
[10:33:12.958] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:12.958] - Launch lazy future ...
[10:33:12.959] Packages needed by the future expression (n = 0): <none>
[10:33:12.959] Packages needed by future strategies (n = 0): <none>
[10:33:12.959] {
[10:33:12.959]     {
[10:33:12.959]         {
[10:33:12.959]             ...future.startTime <- base::Sys.time()
[10:33:12.959]             {
[10:33:12.959]                 {
[10:33:12.959]                   {
[10:33:12.959]                     {
[10:33:12.959]                       base::local({
[10:33:12.959]                         has_future <- base::requireNamespace("future", 
[10:33:12.959]                           quietly = TRUE)
[10:33:12.959]                         if (has_future) {
[10:33:12.959]                           ns <- base::getNamespace("future")
[10:33:12.959]                           version <- ns[[".package"]][["version"]]
[10:33:12.959]                           if (is.null(version)) 
[10:33:12.959]                             version <- utils::packageVersion("future")
[10:33:12.959]                         }
[10:33:12.959]                         else {
[10:33:12.959]                           version <- NULL
[10:33:12.959]                         }
[10:33:12.959]                         if (!has_future || version < "1.8.0") {
[10:33:12.959]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.959]                             "", base::R.version$version.string), 
[10:33:12.959]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:12.959]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:12.959]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.959]                               "release", "version")], collapse = " "), 
[10:33:12.959]                             hostname = base::Sys.info()[["nodename"]])
[10:33:12.959]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.959]                             info)
[10:33:12.959]                           info <- base::paste(info, collapse = "; ")
[10:33:12.959]                           if (!has_future) {
[10:33:12.959]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.959]                               info)
[10:33:12.959]                           }
[10:33:12.959]                           else {
[10:33:12.959]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.959]                               info, version)
[10:33:12.959]                           }
[10:33:12.959]                           base::stop(msg)
[10:33:12.959]                         }
[10:33:12.959]                       })
[10:33:12.959]                     }
[10:33:12.959]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:12.959]                     base::options(mc.cores = 1L)
[10:33:12.959]                   }
[10:33:12.959]                   ...future.strategy.old <- future::plan("list")
[10:33:12.959]                   options(future.plan = NULL)
[10:33:12.959]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.959]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.959]                 }
[10:33:12.959]                 ...future.workdir <- getwd()
[10:33:12.959]             }
[10:33:12.959]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.959]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.959]         }
[10:33:12.959]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.959]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.959]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.959]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.959]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.959]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.959]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.959]             base::names(...future.oldOptions))
[10:33:12.959]     }
[10:33:12.959]     if (FALSE) {
[10:33:12.959]     }
[10:33:12.959]     else {
[10:33:12.959]         if (TRUE) {
[10:33:12.959]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.959]                 open = "w")
[10:33:12.959]         }
[10:33:12.959]         else {
[10:33:12.959]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.959]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.959]         }
[10:33:12.959]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.959]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.959]             base::sink(type = "output", split = FALSE)
[10:33:12.959]             base::close(...future.stdout)
[10:33:12.959]         }, add = TRUE)
[10:33:12.959]     }
[10:33:12.959]     ...future.frame <- base::sys.nframe()
[10:33:12.959]     ...future.conditions <- base::list()
[10:33:12.959]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.959]     if (FALSE) {
[10:33:12.959]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.959]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.959]     }
[10:33:12.959]     ...future.result <- base::tryCatch({
[10:33:12.959]         base::withCallingHandlers({
[10:33:12.959]             ...future.value <- base::withVisible(base::local({
[10:33:12.959]                 withCallingHandlers({
[10:33:12.959]                   1
[10:33:12.959]                 }, immediateCondition = function(cond) {
[10:33:12.959]                   save_rds <- function (object, pathname, ...) 
[10:33:12.959]                   {
[10:33:12.959]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:12.959]                     if (file_test("-f", pathname_tmp)) {
[10:33:12.959]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.959]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:12.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.959]                         fi_tmp[["mtime"]])
[10:33:12.959]                     }
[10:33:12.959]                     tryCatch({
[10:33:12.959]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:12.959]                     }, error = function(ex) {
[10:33:12.959]                       msg <- conditionMessage(ex)
[10:33:12.959]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.959]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:12.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.959]                         fi_tmp[["mtime"]], msg)
[10:33:12.959]                       ex$message <- msg
[10:33:12.959]                       stop(ex)
[10:33:12.959]                     })
[10:33:12.959]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:12.959]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:12.959]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:12.959]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.959]                       fi <- file.info(pathname)
[10:33:12.959]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:12.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.959]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:12.959]                         fi[["size"]], fi[["mtime"]])
[10:33:12.959]                       stop(msg)
[10:33:12.959]                     }
[10:33:12.959]                     invisible(pathname)
[10:33:12.959]                   }
[10:33:12.959]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:12.959]                     rootPath = tempdir()) 
[10:33:12.959]                   {
[10:33:12.959]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:12.959]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:12.959]                       tmpdir = path, fileext = ".rds")
[10:33:12.959]                     save_rds(obj, file)
[10:33:12.959]                   }
[10:33:12.959]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:12.959]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.959]                   {
[10:33:12.959]                     inherits <- base::inherits
[10:33:12.959]                     invokeRestart <- base::invokeRestart
[10:33:12.959]                     is.null <- base::is.null
[10:33:12.959]                     muffled <- FALSE
[10:33:12.959]                     if (inherits(cond, "message")) {
[10:33:12.959]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:12.959]                       if (muffled) 
[10:33:12.959]                         invokeRestart("muffleMessage")
[10:33:12.959]                     }
[10:33:12.959]                     else if (inherits(cond, "warning")) {
[10:33:12.959]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:12.959]                       if (muffled) 
[10:33:12.959]                         invokeRestart("muffleWarning")
[10:33:12.959]                     }
[10:33:12.959]                     else if (inherits(cond, "condition")) {
[10:33:12.959]                       if (!is.null(pattern)) {
[10:33:12.959]                         computeRestarts <- base::computeRestarts
[10:33:12.959]                         grepl <- base::grepl
[10:33:12.959]                         restarts <- computeRestarts(cond)
[10:33:12.959]                         for (restart in restarts) {
[10:33:12.959]                           name <- restart$name
[10:33:12.959]                           if (is.null(name)) 
[10:33:12.959]                             next
[10:33:12.959]                           if (!grepl(pattern, name)) 
[10:33:12.959]                             next
[10:33:12.959]                           invokeRestart(restart)
[10:33:12.959]                           muffled <- TRUE
[10:33:12.959]                           break
[10:33:12.959]                         }
[10:33:12.959]                       }
[10:33:12.959]                     }
[10:33:12.959]                     invisible(muffled)
[10:33:12.959]                   }
[10:33:12.959]                   muffleCondition(cond)
[10:33:12.959]                 })
[10:33:12.959]             }))
[10:33:12.959]             future::FutureResult(value = ...future.value$value, 
[10:33:12.959]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.959]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.959]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.959]                     ...future.globalenv.names))
[10:33:12.959]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.959]         }, condition = base::local({
[10:33:12.959]             c <- base::c
[10:33:12.959]             inherits <- base::inherits
[10:33:12.959]             invokeRestart <- base::invokeRestart
[10:33:12.959]             length <- base::length
[10:33:12.959]             list <- base::list
[10:33:12.959]             seq.int <- base::seq.int
[10:33:12.959]             signalCondition <- base::signalCondition
[10:33:12.959]             sys.calls <- base::sys.calls
[10:33:12.959]             `[[` <- base::`[[`
[10:33:12.959]             `+` <- base::`+`
[10:33:12.959]             `<<-` <- base::`<<-`
[10:33:12.959]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.959]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.959]                   3L)]
[10:33:12.959]             }
[10:33:12.959]             function(cond) {
[10:33:12.959]                 is_error <- inherits(cond, "error")
[10:33:12.959]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.959]                   NULL)
[10:33:12.959]                 if (is_error) {
[10:33:12.959]                   sessionInformation <- function() {
[10:33:12.959]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.959]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.959]                       search = base::search(), system = base::Sys.info())
[10:33:12.959]                   }
[10:33:12.959]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.959]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.959]                     cond$call), session = sessionInformation(), 
[10:33:12.959]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.959]                   signalCondition(cond)
[10:33:12.959]                 }
[10:33:12.959]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.959]                 "immediateCondition"))) {
[10:33:12.959]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.959]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.959]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.959]                   if (TRUE && !signal) {
[10:33:12.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.959]                     {
[10:33:12.959]                       inherits <- base::inherits
[10:33:12.959]                       invokeRestart <- base::invokeRestart
[10:33:12.959]                       is.null <- base::is.null
[10:33:12.959]                       muffled <- FALSE
[10:33:12.959]                       if (inherits(cond, "message")) {
[10:33:12.959]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.959]                         if (muffled) 
[10:33:12.959]                           invokeRestart("muffleMessage")
[10:33:12.959]                       }
[10:33:12.959]                       else if (inherits(cond, "warning")) {
[10:33:12.959]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.959]                         if (muffled) 
[10:33:12.959]                           invokeRestart("muffleWarning")
[10:33:12.959]                       }
[10:33:12.959]                       else if (inherits(cond, "condition")) {
[10:33:12.959]                         if (!is.null(pattern)) {
[10:33:12.959]                           computeRestarts <- base::computeRestarts
[10:33:12.959]                           grepl <- base::grepl
[10:33:12.959]                           restarts <- computeRestarts(cond)
[10:33:12.959]                           for (restart in restarts) {
[10:33:12.959]                             name <- restart$name
[10:33:12.959]                             if (is.null(name)) 
[10:33:12.959]                               next
[10:33:12.959]                             if (!grepl(pattern, name)) 
[10:33:12.959]                               next
[10:33:12.959]                             invokeRestart(restart)
[10:33:12.959]                             muffled <- TRUE
[10:33:12.959]                             break
[10:33:12.959]                           }
[10:33:12.959]                         }
[10:33:12.959]                       }
[10:33:12.959]                       invisible(muffled)
[10:33:12.959]                     }
[10:33:12.959]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.959]                   }
[10:33:12.959]                 }
[10:33:12.959]                 else {
[10:33:12.959]                   if (TRUE) {
[10:33:12.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.959]                     {
[10:33:12.959]                       inherits <- base::inherits
[10:33:12.959]                       invokeRestart <- base::invokeRestart
[10:33:12.959]                       is.null <- base::is.null
[10:33:12.959]                       muffled <- FALSE
[10:33:12.959]                       if (inherits(cond, "message")) {
[10:33:12.959]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.959]                         if (muffled) 
[10:33:12.959]                           invokeRestart("muffleMessage")
[10:33:12.959]                       }
[10:33:12.959]                       else if (inherits(cond, "warning")) {
[10:33:12.959]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.959]                         if (muffled) 
[10:33:12.959]                           invokeRestart("muffleWarning")
[10:33:12.959]                       }
[10:33:12.959]                       else if (inherits(cond, "condition")) {
[10:33:12.959]                         if (!is.null(pattern)) {
[10:33:12.959]                           computeRestarts <- base::computeRestarts
[10:33:12.959]                           grepl <- base::grepl
[10:33:12.959]                           restarts <- computeRestarts(cond)
[10:33:12.959]                           for (restart in restarts) {
[10:33:12.959]                             name <- restart$name
[10:33:12.959]                             if (is.null(name)) 
[10:33:12.959]                               next
[10:33:12.959]                             if (!grepl(pattern, name)) 
[10:33:12.959]                               next
[10:33:12.959]                             invokeRestart(restart)
[10:33:12.959]                             muffled <- TRUE
[10:33:12.959]                             break
[10:33:12.959]                           }
[10:33:12.959]                         }
[10:33:12.959]                       }
[10:33:12.959]                       invisible(muffled)
[10:33:12.959]                     }
[10:33:12.959]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.959]                   }
[10:33:12.959]                 }
[10:33:12.959]             }
[10:33:12.959]         }))
[10:33:12.959]     }, error = function(ex) {
[10:33:12.959]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.959]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.959]                 ...future.rng), started = ...future.startTime, 
[10:33:12.959]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.959]             version = "1.8"), class = "FutureResult")
[10:33:12.959]     }, finally = {
[10:33:12.959]         if (!identical(...future.workdir, getwd())) 
[10:33:12.959]             setwd(...future.workdir)
[10:33:12.959]         {
[10:33:12.959]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.959]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.959]             }
[10:33:12.959]             base::options(...future.oldOptions)
[10:33:12.959]             if (.Platform$OS.type == "windows") {
[10:33:12.959]                 old_names <- names(...future.oldEnvVars)
[10:33:12.959]                 envs <- base::Sys.getenv()
[10:33:12.959]                 names <- names(envs)
[10:33:12.959]                 common <- intersect(names, old_names)
[10:33:12.959]                 added <- setdiff(names, old_names)
[10:33:12.959]                 removed <- setdiff(old_names, names)
[10:33:12.959]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.959]                   envs[common]]
[10:33:12.959]                 NAMES <- toupper(changed)
[10:33:12.959]                 args <- list()
[10:33:12.959]                 for (kk in seq_along(NAMES)) {
[10:33:12.959]                   name <- changed[[kk]]
[10:33:12.959]                   NAME <- NAMES[[kk]]
[10:33:12.959]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.959]                     next
[10:33:12.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.959]                 }
[10:33:12.959]                 NAMES <- toupper(added)
[10:33:12.959]                 for (kk in seq_along(NAMES)) {
[10:33:12.959]                   name <- added[[kk]]
[10:33:12.959]                   NAME <- NAMES[[kk]]
[10:33:12.959]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.959]                     next
[10:33:12.959]                   args[[name]] <- ""
[10:33:12.959]                 }
[10:33:12.959]                 NAMES <- toupper(removed)
[10:33:12.959]                 for (kk in seq_along(NAMES)) {
[10:33:12.959]                   name <- removed[[kk]]
[10:33:12.959]                   NAME <- NAMES[[kk]]
[10:33:12.959]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.959]                     next
[10:33:12.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.959]                 }
[10:33:12.959]                 if (length(args) > 0) 
[10:33:12.959]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.959]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.959]             }
[10:33:12.959]             else {
[10:33:12.959]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.959]             }
[10:33:12.959]             {
[10:33:12.959]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.959]                   0L) {
[10:33:12.959]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.959]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.959]                   base::options(opts)
[10:33:12.959]                 }
[10:33:12.959]                 {
[10:33:12.959]                   {
[10:33:12.959]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:12.959]                     NULL
[10:33:12.959]                   }
[10:33:12.959]                   options(future.plan = NULL)
[10:33:12.959]                   if (is.na(NA_character_)) 
[10:33:12.959]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.959]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.959]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.959]                     .init = FALSE)
[10:33:12.959]                 }
[10:33:12.959]             }
[10:33:12.959]         }
[10:33:12.959]     })
[10:33:12.959]     if (TRUE) {
[10:33:12.959]         base::sink(type = "output", split = FALSE)
[10:33:12.959]         if (TRUE) {
[10:33:12.959]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.959]         }
[10:33:12.959]         else {
[10:33:12.959]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.959]         }
[10:33:12.959]         base::close(...future.stdout)
[10:33:12.959]         ...future.stdout <- NULL
[10:33:12.959]     }
[10:33:12.959]     ...future.result$conditions <- ...future.conditions
[10:33:12.959]     ...future.result$finished <- base::Sys.time()
[10:33:12.959]     ...future.result
[10:33:12.959] }
[10:33:12.962] requestCore(): workers = 2
[10:33:12.964] MulticoreFuture started
[10:33:12.964] - Launch lazy future ... done
[10:33:12.964] run() for ‘MulticoreFuture’ ... done
[10:33:12.965] plan(): Setting new future strategy stack:
[10:33:12.965] List of future strategies:
[10:33:12.965] 1. sequential:
[10:33:12.965]    - args: function (..., envir = parent.frame())
[10:33:12.965]    - tweaked: FALSE
[10:33:12.965]    - call: NULL
[10:33:12.966] plan(): nbrOfWorkers() = 1
[10:33:12.968] plan(): Setting new future strategy stack:
[10:33:12.968] List of future strategies:
[10:33:12.968] 1. multicore:
[10:33:12.968]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:12.968]    - tweaked: FALSE
[10:33:12.968]    - call: plan(strategy)
[10:33:12.973] plan(): nbrOfWorkers() = 2
[10:33:12.974] Future #1
[10:33:12.974] result() for MulticoreFuture ...
[10:33:12.975] result() for MulticoreFuture ...
[10:33:12.975] result() for MulticoreFuture ... done
[10:33:12.976] result() for MulticoreFuture ... done
[10:33:12.976] result() for MulticoreFuture ...
[10:33:12.976] result() for MulticoreFuture ... done
[10:33:12.976] A MulticoreFuture was resolved
[10:33:12.976]  length: 0 (resolved future 1)
[10:33:12.977] resolve() on list ... DONE
[10:33:12.977] - globals: [1] ‘a’
[10:33:12.977] Resolving futures part of globals (recursively) ... DONE
[10:33:12.978] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[10:33:12.979] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[10:33:12.979] - globals: [1] ‘a’
[10:33:12.979] - packages: [1] ‘future’
[10:33:12.979] getGlobalsAndPackages() ... DONE
[10:33:12.980] run() for ‘Future’ ...
[10:33:12.980] - state: ‘created’
[10:33:12.980] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:12.984] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:12.987] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:12.987]   - Field: ‘label’
[10:33:12.987]   - Field: ‘local’
[10:33:12.987]   - Field: ‘owner’
[10:33:12.987]   - Field: ‘envir’
[10:33:12.988]   - Field: ‘workers’
[10:33:12.988]   - Field: ‘packages’
[10:33:12.988]   - Field: ‘gc’
[10:33:12.988]   - Field: ‘job’
[10:33:12.988]   - Field: ‘conditions’
[10:33:12.988]   - Field: ‘expr’
[10:33:12.989]   - Field: ‘uuid’
[10:33:12.989]   - Field: ‘seed’
[10:33:12.989]   - Field: ‘version’
[10:33:12.989]   - Field: ‘result’
[10:33:12.989]   - Field: ‘asynchronous’
[10:33:12.989]   - Field: ‘calls’
[10:33:12.989]   - Field: ‘globals’
[10:33:12.990]   - Field: ‘stdout’
[10:33:12.990]   - Field: ‘earlySignal’
[10:33:12.990]   - Field: ‘lazy’
[10:33:12.990]   - Field: ‘state’
[10:33:12.990] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:12.990] - Launch lazy future ...
[10:33:12.991] Packages needed by the future expression (n = 1): ‘future’
[10:33:12.991] Packages needed by future strategies (n = 0): <none>
[10:33:12.991] {
[10:33:12.991]     {
[10:33:12.991]         {
[10:33:12.991]             ...future.startTime <- base::Sys.time()
[10:33:12.991]             {
[10:33:12.991]                 {
[10:33:12.991]                   {
[10:33:12.991]                     {
[10:33:12.991]                       {
[10:33:12.991]                         base::local({
[10:33:12.991]                           has_future <- base::requireNamespace("future", 
[10:33:12.991]                             quietly = TRUE)
[10:33:12.991]                           if (has_future) {
[10:33:12.991]                             ns <- base::getNamespace("future")
[10:33:12.991]                             version <- ns[[".package"]][["version"]]
[10:33:12.991]                             if (is.null(version)) 
[10:33:12.991]                               version <- utils::packageVersion("future")
[10:33:12.991]                           }
[10:33:12.991]                           else {
[10:33:12.991]                             version <- NULL
[10:33:12.991]                           }
[10:33:12.991]                           if (!has_future || version < "1.8.0") {
[10:33:12.991]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:12.991]                               "", base::R.version$version.string), 
[10:33:12.991]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:12.991]                                 base::R.version$platform, 8 * 
[10:33:12.991]                                   base::.Machine$sizeof.pointer), 
[10:33:12.991]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:12.991]                                 "release", "version")], collapse = " "), 
[10:33:12.991]                               hostname = base::Sys.info()[["nodename"]])
[10:33:12.991]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:12.991]                               info)
[10:33:12.991]                             info <- base::paste(info, collapse = "; ")
[10:33:12.991]                             if (!has_future) {
[10:33:12.991]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:12.991]                                 info)
[10:33:12.991]                             }
[10:33:12.991]                             else {
[10:33:12.991]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:12.991]                                 info, version)
[10:33:12.991]                             }
[10:33:12.991]                             base::stop(msg)
[10:33:12.991]                           }
[10:33:12.991]                         })
[10:33:12.991]                       }
[10:33:12.991]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:12.991]                       base::options(mc.cores = 1L)
[10:33:12.991]                     }
[10:33:12.991]                     base::local({
[10:33:12.991]                       for (pkg in "future") {
[10:33:12.991]                         base::loadNamespace(pkg)
[10:33:12.991]                         base::library(pkg, character.only = TRUE)
[10:33:12.991]                       }
[10:33:12.991]                     })
[10:33:12.991]                   }
[10:33:12.991]                   ...future.strategy.old <- future::plan("list")
[10:33:12.991]                   options(future.plan = NULL)
[10:33:12.991]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.991]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:12.991]                 }
[10:33:12.991]                 ...future.workdir <- getwd()
[10:33:12.991]             }
[10:33:12.991]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:12.991]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:12.991]         }
[10:33:12.991]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:12.991]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:12.991]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:12.991]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:12.991]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:12.991]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:12.991]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:12.991]             base::names(...future.oldOptions))
[10:33:12.991]     }
[10:33:12.991]     if (FALSE) {
[10:33:12.991]     }
[10:33:12.991]     else {
[10:33:12.991]         if (TRUE) {
[10:33:12.991]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:12.991]                 open = "w")
[10:33:12.991]         }
[10:33:12.991]         else {
[10:33:12.991]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:12.991]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:12.991]         }
[10:33:12.991]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:12.991]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:12.991]             base::sink(type = "output", split = FALSE)
[10:33:12.991]             base::close(...future.stdout)
[10:33:12.991]         }, add = TRUE)
[10:33:12.991]     }
[10:33:12.991]     ...future.frame <- base::sys.nframe()
[10:33:12.991]     ...future.conditions <- base::list()
[10:33:12.991]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:12.991]     if (FALSE) {
[10:33:12.991]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:12.991]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:12.991]     }
[10:33:12.991]     ...future.result <- base::tryCatch({
[10:33:12.991]         base::withCallingHandlers({
[10:33:12.991]             ...future.value <- base::withVisible(base::local({
[10:33:12.991]                 withCallingHandlers({
[10:33:12.991]                   value(a) + 1
[10:33:12.991]                 }, immediateCondition = function(cond) {
[10:33:12.991]                   save_rds <- function (object, pathname, ...) 
[10:33:12.991]                   {
[10:33:12.991]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:12.991]                     if (file_test("-f", pathname_tmp)) {
[10:33:12.991]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.991]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:12.991]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.991]                         fi_tmp[["mtime"]])
[10:33:12.991]                     }
[10:33:12.991]                     tryCatch({
[10:33:12.991]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:12.991]                     }, error = function(ex) {
[10:33:12.991]                       msg <- conditionMessage(ex)
[10:33:12.991]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.991]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:12.991]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.991]                         fi_tmp[["mtime"]], msg)
[10:33:12.991]                       ex$message <- msg
[10:33:12.991]                       stop(ex)
[10:33:12.991]                     })
[10:33:12.991]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:12.991]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:12.991]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:12.991]                       fi_tmp <- file.info(pathname_tmp)
[10:33:12.991]                       fi <- file.info(pathname)
[10:33:12.991]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:12.991]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:12.991]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:12.991]                         fi[["size"]], fi[["mtime"]])
[10:33:12.991]                       stop(msg)
[10:33:12.991]                     }
[10:33:12.991]                     invisible(pathname)
[10:33:12.991]                   }
[10:33:12.991]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:12.991]                     rootPath = tempdir()) 
[10:33:12.991]                   {
[10:33:12.991]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:12.991]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:12.991]                       tmpdir = path, fileext = ".rds")
[10:33:12.991]                     save_rds(obj, file)
[10:33:12.991]                   }
[10:33:12.991]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:12.991]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.991]                   {
[10:33:12.991]                     inherits <- base::inherits
[10:33:12.991]                     invokeRestart <- base::invokeRestart
[10:33:12.991]                     is.null <- base::is.null
[10:33:12.991]                     muffled <- FALSE
[10:33:12.991]                     if (inherits(cond, "message")) {
[10:33:12.991]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:12.991]                       if (muffled) 
[10:33:12.991]                         invokeRestart("muffleMessage")
[10:33:12.991]                     }
[10:33:12.991]                     else if (inherits(cond, "warning")) {
[10:33:12.991]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:12.991]                       if (muffled) 
[10:33:12.991]                         invokeRestart("muffleWarning")
[10:33:12.991]                     }
[10:33:12.991]                     else if (inherits(cond, "condition")) {
[10:33:12.991]                       if (!is.null(pattern)) {
[10:33:12.991]                         computeRestarts <- base::computeRestarts
[10:33:12.991]                         grepl <- base::grepl
[10:33:12.991]                         restarts <- computeRestarts(cond)
[10:33:12.991]                         for (restart in restarts) {
[10:33:12.991]                           name <- restart$name
[10:33:12.991]                           if (is.null(name)) 
[10:33:12.991]                             next
[10:33:12.991]                           if (!grepl(pattern, name)) 
[10:33:12.991]                             next
[10:33:12.991]                           invokeRestart(restart)
[10:33:12.991]                           muffled <- TRUE
[10:33:12.991]                           break
[10:33:12.991]                         }
[10:33:12.991]                       }
[10:33:12.991]                     }
[10:33:12.991]                     invisible(muffled)
[10:33:12.991]                   }
[10:33:12.991]                   muffleCondition(cond)
[10:33:12.991]                 })
[10:33:12.991]             }))
[10:33:12.991]             future::FutureResult(value = ...future.value$value, 
[10:33:12.991]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.991]                   ...future.rng), globalenv = if (FALSE) 
[10:33:12.991]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:12.991]                     ...future.globalenv.names))
[10:33:12.991]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:12.991]         }, condition = base::local({
[10:33:12.991]             c <- base::c
[10:33:12.991]             inherits <- base::inherits
[10:33:12.991]             invokeRestart <- base::invokeRestart
[10:33:12.991]             length <- base::length
[10:33:12.991]             list <- base::list
[10:33:12.991]             seq.int <- base::seq.int
[10:33:12.991]             signalCondition <- base::signalCondition
[10:33:12.991]             sys.calls <- base::sys.calls
[10:33:12.991]             `[[` <- base::`[[`
[10:33:12.991]             `+` <- base::`+`
[10:33:12.991]             `<<-` <- base::`<<-`
[10:33:12.991]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:12.991]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:12.991]                   3L)]
[10:33:12.991]             }
[10:33:12.991]             function(cond) {
[10:33:12.991]                 is_error <- inherits(cond, "error")
[10:33:12.991]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:12.991]                   NULL)
[10:33:12.991]                 if (is_error) {
[10:33:12.991]                   sessionInformation <- function() {
[10:33:12.991]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:12.991]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:12.991]                       search = base::search(), system = base::Sys.info())
[10:33:12.991]                   }
[10:33:12.991]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.991]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:12.991]                     cond$call), session = sessionInformation(), 
[10:33:12.991]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:12.991]                   signalCondition(cond)
[10:33:12.991]                 }
[10:33:12.991]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:12.991]                 "immediateCondition"))) {
[10:33:12.991]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:12.991]                   ...future.conditions[[length(...future.conditions) + 
[10:33:12.991]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:12.991]                   if (TRUE && !signal) {
[10:33:12.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.991]                     {
[10:33:12.991]                       inherits <- base::inherits
[10:33:12.991]                       invokeRestart <- base::invokeRestart
[10:33:12.991]                       is.null <- base::is.null
[10:33:12.991]                       muffled <- FALSE
[10:33:12.991]                       if (inherits(cond, "message")) {
[10:33:12.991]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.991]                         if (muffled) 
[10:33:12.991]                           invokeRestart("muffleMessage")
[10:33:12.991]                       }
[10:33:12.991]                       else if (inherits(cond, "warning")) {
[10:33:12.991]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.991]                         if (muffled) 
[10:33:12.991]                           invokeRestart("muffleWarning")
[10:33:12.991]                       }
[10:33:12.991]                       else if (inherits(cond, "condition")) {
[10:33:12.991]                         if (!is.null(pattern)) {
[10:33:12.991]                           computeRestarts <- base::computeRestarts
[10:33:12.991]                           grepl <- base::grepl
[10:33:12.991]                           restarts <- computeRestarts(cond)
[10:33:12.991]                           for (restart in restarts) {
[10:33:12.991]                             name <- restart$name
[10:33:12.991]                             if (is.null(name)) 
[10:33:12.991]                               next
[10:33:12.991]                             if (!grepl(pattern, name)) 
[10:33:12.991]                               next
[10:33:12.991]                             invokeRestart(restart)
[10:33:12.991]                             muffled <- TRUE
[10:33:12.991]                             break
[10:33:12.991]                           }
[10:33:12.991]                         }
[10:33:12.991]                       }
[10:33:12.991]                       invisible(muffled)
[10:33:12.991]                     }
[10:33:12.991]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.991]                   }
[10:33:12.991]                 }
[10:33:12.991]                 else {
[10:33:12.991]                   if (TRUE) {
[10:33:12.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:12.991]                     {
[10:33:12.991]                       inherits <- base::inherits
[10:33:12.991]                       invokeRestart <- base::invokeRestart
[10:33:12.991]                       is.null <- base::is.null
[10:33:12.991]                       muffled <- FALSE
[10:33:12.991]                       if (inherits(cond, "message")) {
[10:33:12.991]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:12.991]                         if (muffled) 
[10:33:12.991]                           invokeRestart("muffleMessage")
[10:33:12.991]                       }
[10:33:12.991]                       else if (inherits(cond, "warning")) {
[10:33:12.991]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:12.991]                         if (muffled) 
[10:33:12.991]                           invokeRestart("muffleWarning")
[10:33:12.991]                       }
[10:33:12.991]                       else if (inherits(cond, "condition")) {
[10:33:12.991]                         if (!is.null(pattern)) {
[10:33:12.991]                           computeRestarts <- base::computeRestarts
[10:33:12.991]                           grepl <- base::grepl
[10:33:12.991]                           restarts <- computeRestarts(cond)
[10:33:12.991]                           for (restart in restarts) {
[10:33:12.991]                             name <- restart$name
[10:33:12.991]                             if (is.null(name)) 
[10:33:12.991]                               next
[10:33:12.991]                             if (!grepl(pattern, name)) 
[10:33:12.991]                               next
[10:33:12.991]                             invokeRestart(restart)
[10:33:12.991]                             muffled <- TRUE
[10:33:12.991]                             break
[10:33:12.991]                           }
[10:33:12.991]                         }
[10:33:12.991]                       }
[10:33:12.991]                       invisible(muffled)
[10:33:12.991]                     }
[10:33:12.991]                     muffleCondition(cond, pattern = "^muffle")
[10:33:12.991]                   }
[10:33:12.991]                 }
[10:33:12.991]             }
[10:33:12.991]         }))
[10:33:12.991]     }, error = function(ex) {
[10:33:12.991]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:12.991]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:12.991]                 ...future.rng), started = ...future.startTime, 
[10:33:12.991]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:12.991]             version = "1.8"), class = "FutureResult")
[10:33:12.991]     }, finally = {
[10:33:12.991]         if (!identical(...future.workdir, getwd())) 
[10:33:12.991]             setwd(...future.workdir)
[10:33:12.991]         {
[10:33:12.991]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:12.991]                 ...future.oldOptions$nwarnings <- NULL
[10:33:12.991]             }
[10:33:12.991]             base::options(...future.oldOptions)
[10:33:12.991]             if (.Platform$OS.type == "windows") {
[10:33:12.991]                 old_names <- names(...future.oldEnvVars)
[10:33:12.991]                 envs <- base::Sys.getenv()
[10:33:12.991]                 names <- names(envs)
[10:33:12.991]                 common <- intersect(names, old_names)
[10:33:12.991]                 added <- setdiff(names, old_names)
[10:33:12.991]                 removed <- setdiff(old_names, names)
[10:33:12.991]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:12.991]                   envs[common]]
[10:33:12.991]                 NAMES <- toupper(changed)
[10:33:12.991]                 args <- list()
[10:33:12.991]                 for (kk in seq_along(NAMES)) {
[10:33:12.991]                   name <- changed[[kk]]
[10:33:12.991]                   NAME <- NAMES[[kk]]
[10:33:12.991]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.991]                     next
[10:33:12.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.991]                 }
[10:33:12.991]                 NAMES <- toupper(added)
[10:33:12.991]                 for (kk in seq_along(NAMES)) {
[10:33:12.991]                   name <- added[[kk]]
[10:33:12.991]                   NAME <- NAMES[[kk]]
[10:33:12.991]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.991]                     next
[10:33:12.991]                   args[[name]] <- ""
[10:33:12.991]                 }
[10:33:12.991]                 NAMES <- toupper(removed)
[10:33:12.991]                 for (kk in seq_along(NAMES)) {
[10:33:12.991]                   name <- removed[[kk]]
[10:33:12.991]                   NAME <- NAMES[[kk]]
[10:33:12.991]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:12.991]                     next
[10:33:12.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:12.991]                 }
[10:33:12.991]                 if (length(args) > 0) 
[10:33:12.991]                   base::do.call(base::Sys.setenv, args = args)
[10:33:12.991]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:12.991]             }
[10:33:12.991]             else {
[10:33:12.991]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:12.991]             }
[10:33:12.991]             {
[10:33:12.991]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:12.991]                   0L) {
[10:33:12.991]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:12.991]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:12.991]                   base::options(opts)
[10:33:12.991]                 }
[10:33:12.991]                 {
[10:33:12.991]                   {
[10:33:12.991]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:12.991]                     NULL
[10:33:12.991]                   }
[10:33:12.991]                   options(future.plan = NULL)
[10:33:12.991]                   if (is.na(NA_character_)) 
[10:33:12.991]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:12.991]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:12.991]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:12.991]                     .init = FALSE)
[10:33:12.991]                 }
[10:33:12.991]             }
[10:33:12.991]         }
[10:33:12.991]     })
[10:33:12.991]     if (TRUE) {
[10:33:12.991]         base::sink(type = "output", split = FALSE)
[10:33:12.991]         if (TRUE) {
[10:33:12.991]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:12.991]         }
[10:33:12.991]         else {
[10:33:12.991]             ...future.result["stdout"] <- base::list(NULL)
[10:33:12.991]         }
[10:33:12.991]         base::close(...future.stdout)
[10:33:12.991]         ...future.stdout <- NULL
[10:33:12.991]     }
[10:33:12.991]     ...future.result$conditions <- ...future.conditions
[10:33:12.991]     ...future.result$finished <- base::Sys.time()
[10:33:12.991]     ...future.result
[10:33:12.991] }
[10:33:12.994] assign_globals() ...
[10:33:12.994] List of 1
[10:33:12.994]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55aa51668c60> 
[10:33:12.994]  - attr(*, "where")=List of 1
[10:33:12.994]   ..$ a:<environment: R_EmptyEnv> 
[10:33:12.994]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:12.994]  - attr(*, "resolved")= logi TRUE
[10:33:12.994]  - attr(*, "total_size")= num 10984
[10:33:12.994]  - attr(*, "already-done")= logi TRUE
[10:33:12.997] - copied ‘a’ to environment
[10:33:12.997] assign_globals() ... done
[10:33:12.997] requestCore(): workers = 2
[10:33:12.999] MulticoreFuture started
[10:33:13.000] - Launch lazy future ... done
[10:33:13.000] run() for ‘MulticoreFuture’ ... done
[10:33:13.000] result() for MulticoreFuture ...
[10:33:13.000] plan(): Setting new future strategy stack:
[10:33:13.001] List of future strategies:
[10:33:13.001] 1. sequential:
[10:33:13.001]    - args: function (..., envir = parent.frame())
[10:33:13.001]    - tweaked: FALSE
[10:33:13.001]    - call: NULL
[10:33:13.002] plan(): nbrOfWorkers() = 1
[10:33:13.005] plan(): Setting new future strategy stack:
[10:33:13.005] List of future strategies:
[10:33:13.005] 1. multicore:
[10:33:13.005]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.005]    - tweaked: FALSE
[10:33:13.005]    - call: plan(strategy)
[10:33:13.010] plan(): nbrOfWorkers() = 2
[10:33:13.011] result() for MulticoreFuture ...
[10:33:13.011] result() for MulticoreFuture ... done
[10:33:13.011] signalConditions() ...
[10:33:13.011]  - include = ‘immediateCondition’
[10:33:13.012]  - exclude = 
[10:33:13.012]  - resignal = FALSE
[10:33:13.012]  - Number of conditions: 4
[10:33:13.012] signalConditions() ... done
[10:33:13.012] result() for MulticoreFuture ... done
[10:33:13.012] result() for MulticoreFuture ...
[10:33:13.012] result() for MulticoreFuture ... done
[10:33:13.013] signalConditions() ...
[10:33:13.013]  - include = ‘immediateCondition’
[10:33:13.013]  - exclude = 
[10:33:13.013]  - resignal = FALSE
[10:33:13.013]  - Number of conditions: 4
[10:33:13.013] signalConditions() ... done
[10:33:13.014] Future state: ‘finished’
[10:33:13.014] result() for MulticoreFuture ...
[10:33:13.014] result() for MulticoreFuture ... done
[10:33:13.014] signalConditions() ...
[10:33:13.014]  - include = ‘condition’
[10:33:13.014]  - exclude = ‘immediateCondition’
[10:33:13.015]  - resignal = TRUE
[10:33:13.015]  - Number of conditions: 4
[10:33:13.015]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.003] result() for MulticoreFuture ...
[10:33:13.015]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.003] result() for MulticoreFuture ... done
[10:33:13.015]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.003] result() for MulticoreFuture ...
[10:33:13.016]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.004] result() for MulticoreFuture ... done
[10:33:13.016] signalConditions() ... done
value(b) = 2
[10:33:13.016] result() for MulticoreFuture ...
[10:33:13.016] result() for MulticoreFuture ... done
[10:33:13.017] result() for MulticoreFuture ...
[10:33:13.017] result() for MulticoreFuture ... done
[10:33:13.017] signalConditions() ...
[10:33:13.017]  - include = ‘immediateCondition’
[10:33:13.017]  - exclude = 
[10:33:13.017]  - resignal = FALSE
[10:33:13.017]  - Number of conditions: 4
[10:33:13.018] signalConditions() ... done
[10:33:13.018] Future state: ‘finished’
[10:33:13.018] result() for MulticoreFuture ...
[10:33:13.018] result() for MulticoreFuture ... done
[10:33:13.018] signalConditions() ...
[10:33:13.018]  - include = ‘condition’
[10:33:13.019]  - exclude = ‘immediateCondition’
[10:33:13.019]  - resignal = TRUE
[10:33:13.019]  - Number of conditions: 4
[10:33:13.019]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.003] result() for MulticoreFuture ...
[10:33:13.019]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.003] result() for MulticoreFuture ... done
[10:33:13.020]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.003] result() for MulticoreFuture ...
[10:33:13.020]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.004] result() for MulticoreFuture ... done
[10:33:13.020] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.020] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.021] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:13.022] 
[10:33:13.022] Searching for globals ... DONE
[10:33:13.022] - globals: [0] <none>
[10:33:13.022] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.022] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.023] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:13.024] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:13.024] Searching for globals ... DONE
[10:33:13.024] Resolving globals: TRUE
[10:33:13.024] Resolving any globals that are futures ...
[10:33:13.024] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:13.024] Resolving any globals that are futures ... DONE
[10:33:13.025] Resolving futures part of globals (recursively) ...
[10:33:13.025] resolve() on list ...
[10:33:13.025]  recursive: 99
[10:33:13.025]  length: 1
[10:33:13.025]  elements: ‘a’
[10:33:13.026] run() for ‘Future’ ...
[10:33:13.028] - state: ‘created’
[10:33:13.028] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:13.033] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:13.033] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:13.033]   - Field: ‘label’
[10:33:13.033]   - Field: ‘local’
[10:33:13.033]   - Field: ‘owner’
[10:33:13.033]   - Field: ‘envir’
[10:33:13.034]   - Field: ‘workers’
[10:33:13.034]   - Field: ‘packages’
[10:33:13.034]   - Field: ‘gc’
[10:33:13.034]   - Field: ‘job’
[10:33:13.034]   - Field: ‘conditions’
[10:33:13.034]   - Field: ‘expr’
[10:33:13.034]   - Field: ‘uuid’
[10:33:13.034]   - Field: ‘seed’
[10:33:13.035]   - Field: ‘version’
[10:33:13.035]   - Field: ‘result’
[10:33:13.035]   - Field: ‘asynchronous’
[10:33:13.035]   - Field: ‘calls’
[10:33:13.035]   - Field: ‘globals’
[10:33:13.035]   - Field: ‘stdout’
[10:33:13.035]   - Field: ‘earlySignal’
[10:33:13.035]   - Field: ‘lazy’
[10:33:13.036]   - Field: ‘state’
[10:33:13.036] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:13.036] - Launch lazy future ...
[10:33:13.036] Packages needed by the future expression (n = 0): <none>
[10:33:13.036] Packages needed by future strategies (n = 0): <none>
[10:33:13.037] {
[10:33:13.037]     {
[10:33:13.037]         {
[10:33:13.037]             ...future.startTime <- base::Sys.time()
[10:33:13.037]             {
[10:33:13.037]                 {
[10:33:13.037]                   {
[10:33:13.037]                     {
[10:33:13.037]                       base::local({
[10:33:13.037]                         has_future <- base::requireNamespace("future", 
[10:33:13.037]                           quietly = TRUE)
[10:33:13.037]                         if (has_future) {
[10:33:13.037]                           ns <- base::getNamespace("future")
[10:33:13.037]                           version <- ns[[".package"]][["version"]]
[10:33:13.037]                           if (is.null(version)) 
[10:33:13.037]                             version <- utils::packageVersion("future")
[10:33:13.037]                         }
[10:33:13.037]                         else {
[10:33:13.037]                           version <- NULL
[10:33:13.037]                         }
[10:33:13.037]                         if (!has_future || version < "1.8.0") {
[10:33:13.037]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:13.037]                             "", base::R.version$version.string), 
[10:33:13.037]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:13.037]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:13.037]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:13.037]                               "release", "version")], collapse = " "), 
[10:33:13.037]                             hostname = base::Sys.info()[["nodename"]])
[10:33:13.037]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:13.037]                             info)
[10:33:13.037]                           info <- base::paste(info, collapse = "; ")
[10:33:13.037]                           if (!has_future) {
[10:33:13.037]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:13.037]                               info)
[10:33:13.037]                           }
[10:33:13.037]                           else {
[10:33:13.037]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:13.037]                               info, version)
[10:33:13.037]                           }
[10:33:13.037]                           base::stop(msg)
[10:33:13.037]                         }
[10:33:13.037]                       })
[10:33:13.037]                     }
[10:33:13.037]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:13.037]                     base::options(mc.cores = 1L)
[10:33:13.037]                   }
[10:33:13.037]                   ...future.strategy.old <- future::plan("list")
[10:33:13.037]                   options(future.plan = NULL)
[10:33:13.037]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.037]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:13.037]                 }
[10:33:13.037]                 ...future.workdir <- getwd()
[10:33:13.037]             }
[10:33:13.037]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:13.037]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:13.037]         }
[10:33:13.037]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:13.037]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:13.037]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:13.037]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:13.037]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:13.037]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:13.037]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:13.037]             base::names(...future.oldOptions))
[10:33:13.037]     }
[10:33:13.037]     if (FALSE) {
[10:33:13.037]     }
[10:33:13.037]     else {
[10:33:13.037]         if (TRUE) {
[10:33:13.037]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:13.037]                 open = "w")
[10:33:13.037]         }
[10:33:13.037]         else {
[10:33:13.037]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:13.037]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:13.037]         }
[10:33:13.037]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:13.037]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:13.037]             base::sink(type = "output", split = FALSE)
[10:33:13.037]             base::close(...future.stdout)
[10:33:13.037]         }, add = TRUE)
[10:33:13.037]     }
[10:33:13.037]     ...future.frame <- base::sys.nframe()
[10:33:13.037]     ...future.conditions <- base::list()
[10:33:13.037]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:13.037]     if (FALSE) {
[10:33:13.037]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:13.037]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:13.037]     }
[10:33:13.037]     ...future.result <- base::tryCatch({
[10:33:13.037]         base::withCallingHandlers({
[10:33:13.037]             ...future.value <- base::withVisible(base::local({
[10:33:13.037]                 withCallingHandlers({
[10:33:13.037]                   1
[10:33:13.037]                 }, immediateCondition = function(cond) {
[10:33:13.037]                   save_rds <- function (object, pathname, ...) 
[10:33:13.037]                   {
[10:33:13.037]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:13.037]                     if (file_test("-f", pathname_tmp)) {
[10:33:13.037]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.037]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:13.037]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.037]                         fi_tmp[["mtime"]])
[10:33:13.037]                     }
[10:33:13.037]                     tryCatch({
[10:33:13.037]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:13.037]                     }, error = function(ex) {
[10:33:13.037]                       msg <- conditionMessage(ex)
[10:33:13.037]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.037]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:13.037]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.037]                         fi_tmp[["mtime"]], msg)
[10:33:13.037]                       ex$message <- msg
[10:33:13.037]                       stop(ex)
[10:33:13.037]                     })
[10:33:13.037]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:13.037]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:13.037]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:13.037]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.037]                       fi <- file.info(pathname)
[10:33:13.037]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:13.037]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.037]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:13.037]                         fi[["size"]], fi[["mtime"]])
[10:33:13.037]                       stop(msg)
[10:33:13.037]                     }
[10:33:13.037]                     invisible(pathname)
[10:33:13.037]                   }
[10:33:13.037]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:13.037]                     rootPath = tempdir()) 
[10:33:13.037]                   {
[10:33:13.037]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:13.037]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:13.037]                       tmpdir = path, fileext = ".rds")
[10:33:13.037]                     save_rds(obj, file)
[10:33:13.037]                   }
[10:33:13.037]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:13.037]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.037]                   {
[10:33:13.037]                     inherits <- base::inherits
[10:33:13.037]                     invokeRestart <- base::invokeRestart
[10:33:13.037]                     is.null <- base::is.null
[10:33:13.037]                     muffled <- FALSE
[10:33:13.037]                     if (inherits(cond, "message")) {
[10:33:13.037]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:13.037]                       if (muffled) 
[10:33:13.037]                         invokeRestart("muffleMessage")
[10:33:13.037]                     }
[10:33:13.037]                     else if (inherits(cond, "warning")) {
[10:33:13.037]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:13.037]                       if (muffled) 
[10:33:13.037]                         invokeRestart("muffleWarning")
[10:33:13.037]                     }
[10:33:13.037]                     else if (inherits(cond, "condition")) {
[10:33:13.037]                       if (!is.null(pattern)) {
[10:33:13.037]                         computeRestarts <- base::computeRestarts
[10:33:13.037]                         grepl <- base::grepl
[10:33:13.037]                         restarts <- computeRestarts(cond)
[10:33:13.037]                         for (restart in restarts) {
[10:33:13.037]                           name <- restart$name
[10:33:13.037]                           if (is.null(name)) 
[10:33:13.037]                             next
[10:33:13.037]                           if (!grepl(pattern, name)) 
[10:33:13.037]                             next
[10:33:13.037]                           invokeRestart(restart)
[10:33:13.037]                           muffled <- TRUE
[10:33:13.037]                           break
[10:33:13.037]                         }
[10:33:13.037]                       }
[10:33:13.037]                     }
[10:33:13.037]                     invisible(muffled)
[10:33:13.037]                   }
[10:33:13.037]                   muffleCondition(cond)
[10:33:13.037]                 })
[10:33:13.037]             }))
[10:33:13.037]             future::FutureResult(value = ...future.value$value, 
[10:33:13.037]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.037]                   ...future.rng), globalenv = if (FALSE) 
[10:33:13.037]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:13.037]                     ...future.globalenv.names))
[10:33:13.037]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:13.037]         }, condition = base::local({
[10:33:13.037]             c <- base::c
[10:33:13.037]             inherits <- base::inherits
[10:33:13.037]             invokeRestart <- base::invokeRestart
[10:33:13.037]             length <- base::length
[10:33:13.037]             list <- base::list
[10:33:13.037]             seq.int <- base::seq.int
[10:33:13.037]             signalCondition <- base::signalCondition
[10:33:13.037]             sys.calls <- base::sys.calls
[10:33:13.037]             `[[` <- base::`[[`
[10:33:13.037]             `+` <- base::`+`
[10:33:13.037]             `<<-` <- base::`<<-`
[10:33:13.037]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:13.037]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:13.037]                   3L)]
[10:33:13.037]             }
[10:33:13.037]             function(cond) {
[10:33:13.037]                 is_error <- inherits(cond, "error")
[10:33:13.037]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:13.037]                   NULL)
[10:33:13.037]                 if (is_error) {
[10:33:13.037]                   sessionInformation <- function() {
[10:33:13.037]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:13.037]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:13.037]                       search = base::search(), system = base::Sys.info())
[10:33:13.037]                   }
[10:33:13.037]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.037]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:13.037]                     cond$call), session = sessionInformation(), 
[10:33:13.037]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:13.037]                   signalCondition(cond)
[10:33:13.037]                 }
[10:33:13.037]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:13.037]                 "immediateCondition"))) {
[10:33:13.037]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:13.037]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.037]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:13.037]                   if (TRUE && !signal) {
[10:33:13.037]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.037]                     {
[10:33:13.037]                       inherits <- base::inherits
[10:33:13.037]                       invokeRestart <- base::invokeRestart
[10:33:13.037]                       is.null <- base::is.null
[10:33:13.037]                       muffled <- FALSE
[10:33:13.037]                       if (inherits(cond, "message")) {
[10:33:13.037]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.037]                         if (muffled) 
[10:33:13.037]                           invokeRestart("muffleMessage")
[10:33:13.037]                       }
[10:33:13.037]                       else if (inherits(cond, "warning")) {
[10:33:13.037]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.037]                         if (muffled) 
[10:33:13.037]                           invokeRestart("muffleWarning")
[10:33:13.037]                       }
[10:33:13.037]                       else if (inherits(cond, "condition")) {
[10:33:13.037]                         if (!is.null(pattern)) {
[10:33:13.037]                           computeRestarts <- base::computeRestarts
[10:33:13.037]                           grepl <- base::grepl
[10:33:13.037]                           restarts <- computeRestarts(cond)
[10:33:13.037]                           for (restart in restarts) {
[10:33:13.037]                             name <- restart$name
[10:33:13.037]                             if (is.null(name)) 
[10:33:13.037]                               next
[10:33:13.037]                             if (!grepl(pattern, name)) 
[10:33:13.037]                               next
[10:33:13.037]                             invokeRestart(restart)
[10:33:13.037]                             muffled <- TRUE
[10:33:13.037]                             break
[10:33:13.037]                           }
[10:33:13.037]                         }
[10:33:13.037]                       }
[10:33:13.037]                       invisible(muffled)
[10:33:13.037]                     }
[10:33:13.037]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.037]                   }
[10:33:13.037]                 }
[10:33:13.037]                 else {
[10:33:13.037]                   if (TRUE) {
[10:33:13.037]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.037]                     {
[10:33:13.037]                       inherits <- base::inherits
[10:33:13.037]                       invokeRestart <- base::invokeRestart
[10:33:13.037]                       is.null <- base::is.null
[10:33:13.037]                       muffled <- FALSE
[10:33:13.037]                       if (inherits(cond, "message")) {
[10:33:13.037]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.037]                         if (muffled) 
[10:33:13.037]                           invokeRestart("muffleMessage")
[10:33:13.037]                       }
[10:33:13.037]                       else if (inherits(cond, "warning")) {
[10:33:13.037]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.037]                         if (muffled) 
[10:33:13.037]                           invokeRestart("muffleWarning")
[10:33:13.037]                       }
[10:33:13.037]                       else if (inherits(cond, "condition")) {
[10:33:13.037]                         if (!is.null(pattern)) {
[10:33:13.037]                           computeRestarts <- base::computeRestarts
[10:33:13.037]                           grepl <- base::grepl
[10:33:13.037]                           restarts <- computeRestarts(cond)
[10:33:13.037]                           for (restart in restarts) {
[10:33:13.037]                             name <- restart$name
[10:33:13.037]                             if (is.null(name)) 
[10:33:13.037]                               next
[10:33:13.037]                             if (!grepl(pattern, name)) 
[10:33:13.037]                               next
[10:33:13.037]                             invokeRestart(restart)
[10:33:13.037]                             muffled <- TRUE
[10:33:13.037]                             break
[10:33:13.037]                           }
[10:33:13.037]                         }
[10:33:13.037]                       }
[10:33:13.037]                       invisible(muffled)
[10:33:13.037]                     }
[10:33:13.037]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.037]                   }
[10:33:13.037]                 }
[10:33:13.037]             }
[10:33:13.037]         }))
[10:33:13.037]     }, error = function(ex) {
[10:33:13.037]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:13.037]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.037]                 ...future.rng), started = ...future.startTime, 
[10:33:13.037]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:13.037]             version = "1.8"), class = "FutureResult")
[10:33:13.037]     }, finally = {
[10:33:13.037]         if (!identical(...future.workdir, getwd())) 
[10:33:13.037]             setwd(...future.workdir)
[10:33:13.037]         {
[10:33:13.037]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:13.037]                 ...future.oldOptions$nwarnings <- NULL
[10:33:13.037]             }
[10:33:13.037]             base::options(...future.oldOptions)
[10:33:13.037]             if (.Platform$OS.type == "windows") {
[10:33:13.037]                 old_names <- names(...future.oldEnvVars)
[10:33:13.037]                 envs <- base::Sys.getenv()
[10:33:13.037]                 names <- names(envs)
[10:33:13.037]                 common <- intersect(names, old_names)
[10:33:13.037]                 added <- setdiff(names, old_names)
[10:33:13.037]                 removed <- setdiff(old_names, names)
[10:33:13.037]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:13.037]                   envs[common]]
[10:33:13.037]                 NAMES <- toupper(changed)
[10:33:13.037]                 args <- list()
[10:33:13.037]                 for (kk in seq_along(NAMES)) {
[10:33:13.037]                   name <- changed[[kk]]
[10:33:13.037]                   NAME <- NAMES[[kk]]
[10:33:13.037]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.037]                     next
[10:33:13.037]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.037]                 }
[10:33:13.037]                 NAMES <- toupper(added)
[10:33:13.037]                 for (kk in seq_along(NAMES)) {
[10:33:13.037]                   name <- added[[kk]]
[10:33:13.037]                   NAME <- NAMES[[kk]]
[10:33:13.037]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.037]                     next
[10:33:13.037]                   args[[name]] <- ""
[10:33:13.037]                 }
[10:33:13.037]                 NAMES <- toupper(removed)
[10:33:13.037]                 for (kk in seq_along(NAMES)) {
[10:33:13.037]                   name <- removed[[kk]]
[10:33:13.037]                   NAME <- NAMES[[kk]]
[10:33:13.037]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.037]                     next
[10:33:13.037]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.037]                 }
[10:33:13.037]                 if (length(args) > 0) 
[10:33:13.037]                   base::do.call(base::Sys.setenv, args = args)
[10:33:13.037]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:13.037]             }
[10:33:13.037]             else {
[10:33:13.037]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:13.037]             }
[10:33:13.037]             {
[10:33:13.037]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:13.037]                   0L) {
[10:33:13.037]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:13.037]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:13.037]                   base::options(opts)
[10:33:13.037]                 }
[10:33:13.037]                 {
[10:33:13.037]                   {
[10:33:13.037]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:13.037]                     NULL
[10:33:13.037]                   }
[10:33:13.037]                   options(future.plan = NULL)
[10:33:13.037]                   if (is.na(NA_character_)) 
[10:33:13.037]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.037]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:13.037]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:13.037]                     .init = FALSE)
[10:33:13.037]                 }
[10:33:13.037]             }
[10:33:13.037]         }
[10:33:13.037]     })
[10:33:13.037]     if (TRUE) {
[10:33:13.037]         base::sink(type = "output", split = FALSE)
[10:33:13.037]         if (TRUE) {
[10:33:13.037]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:13.037]         }
[10:33:13.037]         else {
[10:33:13.037]             ...future.result["stdout"] <- base::list(NULL)
[10:33:13.037]         }
[10:33:13.037]         base::close(...future.stdout)
[10:33:13.037]         ...future.stdout <- NULL
[10:33:13.037]     }
[10:33:13.037]     ...future.result$conditions <- ...future.conditions
[10:33:13.037]     ...future.result$finished <- base::Sys.time()
[10:33:13.037]     ...future.result
[10:33:13.037] }
[10:33:13.039] requestCore(): workers = 2
[10:33:13.041] MulticoreFuture started
[10:33:13.041] - Launch lazy future ... done
[10:33:13.041] run() for ‘MulticoreFuture’ ... done
[10:33:13.042] plan(): Setting new future strategy stack:
[10:33:13.042] List of future strategies:
[10:33:13.042] 1. sequential:
[10:33:13.042]    - args: function (..., envir = parent.frame())
[10:33:13.042]    - tweaked: FALSE
[10:33:13.042]    - call: NULL
[10:33:13.043] plan(): nbrOfWorkers() = 1
[10:33:13.046] plan(): Setting new future strategy stack:
[10:33:13.046] List of future strategies:
[10:33:13.046] 1. multicore:
[10:33:13.046]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.046]    - tweaked: FALSE
[10:33:13.046]    - call: plan(strategy)
[10:33:13.051] plan(): nbrOfWorkers() = 2
[10:33:13.051] Future #1
[10:33:13.052] result() for MulticoreFuture ...
[10:33:13.053] result() for MulticoreFuture ...
[10:33:13.053] result() for MulticoreFuture ... done
[10:33:13.053] result() for MulticoreFuture ... done
[10:33:13.053] result() for MulticoreFuture ...
[10:33:13.053] result() for MulticoreFuture ... done
[10:33:13.054] A MulticoreFuture was resolved
[10:33:13.054]  length: 0 (resolved future 1)
[10:33:13.054] resolve() on list ... DONE
[10:33:13.054] - globals: [1] ‘a’
[10:33:13.055] Resolving futures part of globals (recursively) ... DONE
[10:33:13.056] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[10:33:13.056] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[10:33:13.057] - globals: [1] ‘a’
[10:33:13.057] - packages: [1] ‘future’
[10:33:13.057] getGlobalsAndPackages() ... DONE
[10:33:13.057] run() for ‘Future’ ...
[10:33:13.058] - state: ‘created’
[10:33:13.058] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:13.062] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:13.062] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:13.062]   - Field: ‘label’
[10:33:13.062]   - Field: ‘local’
[10:33:13.062]   - Field: ‘owner’
[10:33:13.062]   - Field: ‘envir’
[10:33:13.063]   - Field: ‘workers’
[10:33:13.063]   - Field: ‘packages’
[10:33:13.063]   - Field: ‘gc’
[10:33:13.063]   - Field: ‘job’
[10:33:13.063]   - Field: ‘conditions’
[10:33:13.063]   - Field: ‘expr’
[10:33:13.063]   - Field: ‘uuid’
[10:33:13.063]   - Field: ‘seed’
[10:33:13.063]   - Field: ‘version’
[10:33:13.064]   - Field: ‘result’
[10:33:13.064]   - Field: ‘asynchronous’
[10:33:13.064]   - Field: ‘calls’
[10:33:13.064]   - Field: ‘globals’
[10:33:13.064]   - Field: ‘stdout’
[10:33:13.064]   - Field: ‘earlySignal’
[10:33:13.064]   - Field: ‘lazy’
[10:33:13.064]   - Field: ‘state’
[10:33:13.064] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:13.065] - Launch lazy future ...
[10:33:13.065] Packages needed by the future expression (n = 1): ‘future’
[10:33:13.065] Packages needed by future strategies (n = 0): <none>
[10:33:13.066] {
[10:33:13.066]     {
[10:33:13.066]         {
[10:33:13.066]             ...future.startTime <- base::Sys.time()
[10:33:13.066]             {
[10:33:13.066]                 {
[10:33:13.066]                   {
[10:33:13.066]                     {
[10:33:13.066]                       {
[10:33:13.066]                         base::local({
[10:33:13.066]                           has_future <- base::requireNamespace("future", 
[10:33:13.066]                             quietly = TRUE)
[10:33:13.066]                           if (has_future) {
[10:33:13.066]                             ns <- base::getNamespace("future")
[10:33:13.066]                             version <- ns[[".package"]][["version"]]
[10:33:13.066]                             if (is.null(version)) 
[10:33:13.066]                               version <- utils::packageVersion("future")
[10:33:13.066]                           }
[10:33:13.066]                           else {
[10:33:13.066]                             version <- NULL
[10:33:13.066]                           }
[10:33:13.066]                           if (!has_future || version < "1.8.0") {
[10:33:13.066]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:13.066]                               "", base::R.version$version.string), 
[10:33:13.066]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:13.066]                                 base::R.version$platform, 8 * 
[10:33:13.066]                                   base::.Machine$sizeof.pointer), 
[10:33:13.066]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:13.066]                                 "release", "version")], collapse = " "), 
[10:33:13.066]                               hostname = base::Sys.info()[["nodename"]])
[10:33:13.066]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:13.066]                               info)
[10:33:13.066]                             info <- base::paste(info, collapse = "; ")
[10:33:13.066]                             if (!has_future) {
[10:33:13.066]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:13.066]                                 info)
[10:33:13.066]                             }
[10:33:13.066]                             else {
[10:33:13.066]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:13.066]                                 info, version)
[10:33:13.066]                             }
[10:33:13.066]                             base::stop(msg)
[10:33:13.066]                           }
[10:33:13.066]                         })
[10:33:13.066]                       }
[10:33:13.066]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:13.066]                       base::options(mc.cores = 1L)
[10:33:13.066]                     }
[10:33:13.066]                     base::local({
[10:33:13.066]                       for (pkg in "future") {
[10:33:13.066]                         base::loadNamespace(pkg)
[10:33:13.066]                         base::library(pkg, character.only = TRUE)
[10:33:13.066]                       }
[10:33:13.066]                     })
[10:33:13.066]                   }
[10:33:13.066]                   ...future.strategy.old <- future::plan("list")
[10:33:13.066]                   options(future.plan = NULL)
[10:33:13.066]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.066]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:13.066]                 }
[10:33:13.066]                 ...future.workdir <- getwd()
[10:33:13.066]             }
[10:33:13.066]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:13.066]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:13.066]         }
[10:33:13.066]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:13.066]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:13.066]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:13.066]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:13.066]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:13.066]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:13.066]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:13.066]             base::names(...future.oldOptions))
[10:33:13.066]     }
[10:33:13.066]     if (FALSE) {
[10:33:13.066]     }
[10:33:13.066]     else {
[10:33:13.066]         if (TRUE) {
[10:33:13.066]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:13.066]                 open = "w")
[10:33:13.066]         }
[10:33:13.066]         else {
[10:33:13.066]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:13.066]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:13.066]         }
[10:33:13.066]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:13.066]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:13.066]             base::sink(type = "output", split = FALSE)
[10:33:13.066]             base::close(...future.stdout)
[10:33:13.066]         }, add = TRUE)
[10:33:13.066]     }
[10:33:13.066]     ...future.frame <- base::sys.nframe()
[10:33:13.066]     ...future.conditions <- base::list()
[10:33:13.066]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:13.066]     if (FALSE) {
[10:33:13.066]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:13.066]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:13.066]     }
[10:33:13.066]     ...future.result <- base::tryCatch({
[10:33:13.066]         base::withCallingHandlers({
[10:33:13.066]             ...future.value <- base::withVisible(base::local({
[10:33:13.066]                 withCallingHandlers({
[10:33:13.066]                   value(a) + 1
[10:33:13.066]                 }, immediateCondition = function(cond) {
[10:33:13.066]                   save_rds <- function (object, pathname, ...) 
[10:33:13.066]                   {
[10:33:13.066]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:13.066]                     if (file_test("-f", pathname_tmp)) {
[10:33:13.066]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.066]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:13.066]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.066]                         fi_tmp[["mtime"]])
[10:33:13.066]                     }
[10:33:13.066]                     tryCatch({
[10:33:13.066]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:13.066]                     }, error = function(ex) {
[10:33:13.066]                       msg <- conditionMessage(ex)
[10:33:13.066]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.066]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:13.066]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.066]                         fi_tmp[["mtime"]], msg)
[10:33:13.066]                       ex$message <- msg
[10:33:13.066]                       stop(ex)
[10:33:13.066]                     })
[10:33:13.066]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:13.066]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:13.066]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:13.066]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.066]                       fi <- file.info(pathname)
[10:33:13.066]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:13.066]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.066]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:13.066]                         fi[["size"]], fi[["mtime"]])
[10:33:13.066]                       stop(msg)
[10:33:13.066]                     }
[10:33:13.066]                     invisible(pathname)
[10:33:13.066]                   }
[10:33:13.066]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:13.066]                     rootPath = tempdir()) 
[10:33:13.066]                   {
[10:33:13.066]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:13.066]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:13.066]                       tmpdir = path, fileext = ".rds")
[10:33:13.066]                     save_rds(obj, file)
[10:33:13.066]                   }
[10:33:13.066]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:13.066]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.066]                   {
[10:33:13.066]                     inherits <- base::inherits
[10:33:13.066]                     invokeRestart <- base::invokeRestart
[10:33:13.066]                     is.null <- base::is.null
[10:33:13.066]                     muffled <- FALSE
[10:33:13.066]                     if (inherits(cond, "message")) {
[10:33:13.066]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:13.066]                       if (muffled) 
[10:33:13.066]                         invokeRestart("muffleMessage")
[10:33:13.066]                     }
[10:33:13.066]                     else if (inherits(cond, "warning")) {
[10:33:13.066]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:13.066]                       if (muffled) 
[10:33:13.066]                         invokeRestart("muffleWarning")
[10:33:13.066]                     }
[10:33:13.066]                     else if (inherits(cond, "condition")) {
[10:33:13.066]                       if (!is.null(pattern)) {
[10:33:13.066]                         computeRestarts <- base::computeRestarts
[10:33:13.066]                         grepl <- base::grepl
[10:33:13.066]                         restarts <- computeRestarts(cond)
[10:33:13.066]                         for (restart in restarts) {
[10:33:13.066]                           name <- restart$name
[10:33:13.066]                           if (is.null(name)) 
[10:33:13.066]                             next
[10:33:13.066]                           if (!grepl(pattern, name)) 
[10:33:13.066]                             next
[10:33:13.066]                           invokeRestart(restart)
[10:33:13.066]                           muffled <- TRUE
[10:33:13.066]                           break
[10:33:13.066]                         }
[10:33:13.066]                       }
[10:33:13.066]                     }
[10:33:13.066]                     invisible(muffled)
[10:33:13.066]                   }
[10:33:13.066]                   muffleCondition(cond)
[10:33:13.066]                 })
[10:33:13.066]             }))
[10:33:13.066]             future::FutureResult(value = ...future.value$value, 
[10:33:13.066]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.066]                   ...future.rng), globalenv = if (FALSE) 
[10:33:13.066]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:13.066]                     ...future.globalenv.names))
[10:33:13.066]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:13.066]         }, condition = base::local({
[10:33:13.066]             c <- base::c
[10:33:13.066]             inherits <- base::inherits
[10:33:13.066]             invokeRestart <- base::invokeRestart
[10:33:13.066]             length <- base::length
[10:33:13.066]             list <- base::list
[10:33:13.066]             seq.int <- base::seq.int
[10:33:13.066]             signalCondition <- base::signalCondition
[10:33:13.066]             sys.calls <- base::sys.calls
[10:33:13.066]             `[[` <- base::`[[`
[10:33:13.066]             `+` <- base::`+`
[10:33:13.066]             `<<-` <- base::`<<-`
[10:33:13.066]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:13.066]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:13.066]                   3L)]
[10:33:13.066]             }
[10:33:13.066]             function(cond) {
[10:33:13.066]                 is_error <- inherits(cond, "error")
[10:33:13.066]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:13.066]                   NULL)
[10:33:13.066]                 if (is_error) {
[10:33:13.066]                   sessionInformation <- function() {
[10:33:13.066]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:13.066]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:13.066]                       search = base::search(), system = base::Sys.info())
[10:33:13.066]                   }
[10:33:13.066]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.066]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:13.066]                     cond$call), session = sessionInformation(), 
[10:33:13.066]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:13.066]                   signalCondition(cond)
[10:33:13.066]                 }
[10:33:13.066]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:13.066]                 "immediateCondition"))) {
[10:33:13.066]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:13.066]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.066]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:13.066]                   if (TRUE && !signal) {
[10:33:13.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.066]                     {
[10:33:13.066]                       inherits <- base::inherits
[10:33:13.066]                       invokeRestart <- base::invokeRestart
[10:33:13.066]                       is.null <- base::is.null
[10:33:13.066]                       muffled <- FALSE
[10:33:13.066]                       if (inherits(cond, "message")) {
[10:33:13.066]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.066]                         if (muffled) 
[10:33:13.066]                           invokeRestart("muffleMessage")
[10:33:13.066]                       }
[10:33:13.066]                       else if (inherits(cond, "warning")) {
[10:33:13.066]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.066]                         if (muffled) 
[10:33:13.066]                           invokeRestart("muffleWarning")
[10:33:13.066]                       }
[10:33:13.066]                       else if (inherits(cond, "condition")) {
[10:33:13.066]                         if (!is.null(pattern)) {
[10:33:13.066]                           computeRestarts <- base::computeRestarts
[10:33:13.066]                           grepl <- base::grepl
[10:33:13.066]                           restarts <- computeRestarts(cond)
[10:33:13.066]                           for (restart in restarts) {
[10:33:13.066]                             name <- restart$name
[10:33:13.066]                             if (is.null(name)) 
[10:33:13.066]                               next
[10:33:13.066]                             if (!grepl(pattern, name)) 
[10:33:13.066]                               next
[10:33:13.066]                             invokeRestart(restart)
[10:33:13.066]                             muffled <- TRUE
[10:33:13.066]                             break
[10:33:13.066]                           }
[10:33:13.066]                         }
[10:33:13.066]                       }
[10:33:13.066]                       invisible(muffled)
[10:33:13.066]                     }
[10:33:13.066]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.066]                   }
[10:33:13.066]                 }
[10:33:13.066]                 else {
[10:33:13.066]                   if (TRUE) {
[10:33:13.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.066]                     {
[10:33:13.066]                       inherits <- base::inherits
[10:33:13.066]                       invokeRestart <- base::invokeRestart
[10:33:13.066]                       is.null <- base::is.null
[10:33:13.066]                       muffled <- FALSE
[10:33:13.066]                       if (inherits(cond, "message")) {
[10:33:13.066]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.066]                         if (muffled) 
[10:33:13.066]                           invokeRestart("muffleMessage")
[10:33:13.066]                       }
[10:33:13.066]                       else if (inherits(cond, "warning")) {
[10:33:13.066]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.066]                         if (muffled) 
[10:33:13.066]                           invokeRestart("muffleWarning")
[10:33:13.066]                       }
[10:33:13.066]                       else if (inherits(cond, "condition")) {
[10:33:13.066]                         if (!is.null(pattern)) {
[10:33:13.066]                           computeRestarts <- base::computeRestarts
[10:33:13.066]                           grepl <- base::grepl
[10:33:13.066]                           restarts <- computeRestarts(cond)
[10:33:13.066]                           for (restart in restarts) {
[10:33:13.066]                             name <- restart$name
[10:33:13.066]                             if (is.null(name)) 
[10:33:13.066]                               next
[10:33:13.066]                             if (!grepl(pattern, name)) 
[10:33:13.066]                               next
[10:33:13.066]                             invokeRestart(restart)
[10:33:13.066]                             muffled <- TRUE
[10:33:13.066]                             break
[10:33:13.066]                           }
[10:33:13.066]                         }
[10:33:13.066]                       }
[10:33:13.066]                       invisible(muffled)
[10:33:13.066]                     }
[10:33:13.066]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.066]                   }
[10:33:13.066]                 }
[10:33:13.066]             }
[10:33:13.066]         }))
[10:33:13.066]     }, error = function(ex) {
[10:33:13.066]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:13.066]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.066]                 ...future.rng), started = ...future.startTime, 
[10:33:13.066]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:13.066]             version = "1.8"), class = "FutureResult")
[10:33:13.066]     }, finally = {
[10:33:13.066]         if (!identical(...future.workdir, getwd())) 
[10:33:13.066]             setwd(...future.workdir)
[10:33:13.066]         {
[10:33:13.066]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:13.066]                 ...future.oldOptions$nwarnings <- NULL
[10:33:13.066]             }
[10:33:13.066]             base::options(...future.oldOptions)
[10:33:13.066]             if (.Platform$OS.type == "windows") {
[10:33:13.066]                 old_names <- names(...future.oldEnvVars)
[10:33:13.066]                 envs <- base::Sys.getenv()
[10:33:13.066]                 names <- names(envs)
[10:33:13.066]                 common <- intersect(names, old_names)
[10:33:13.066]                 added <- setdiff(names, old_names)
[10:33:13.066]                 removed <- setdiff(old_names, names)
[10:33:13.066]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:13.066]                   envs[common]]
[10:33:13.066]                 NAMES <- toupper(changed)
[10:33:13.066]                 args <- list()
[10:33:13.066]                 for (kk in seq_along(NAMES)) {
[10:33:13.066]                   name <- changed[[kk]]
[10:33:13.066]                   NAME <- NAMES[[kk]]
[10:33:13.066]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.066]                     next
[10:33:13.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.066]                 }
[10:33:13.066]                 NAMES <- toupper(added)
[10:33:13.066]                 for (kk in seq_along(NAMES)) {
[10:33:13.066]                   name <- added[[kk]]
[10:33:13.066]                   NAME <- NAMES[[kk]]
[10:33:13.066]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.066]                     next
[10:33:13.066]                   args[[name]] <- ""
[10:33:13.066]                 }
[10:33:13.066]                 NAMES <- toupper(removed)
[10:33:13.066]                 for (kk in seq_along(NAMES)) {
[10:33:13.066]                   name <- removed[[kk]]
[10:33:13.066]                   NAME <- NAMES[[kk]]
[10:33:13.066]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.066]                     next
[10:33:13.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.066]                 }
[10:33:13.066]                 if (length(args) > 0) 
[10:33:13.066]                   base::do.call(base::Sys.setenv, args = args)
[10:33:13.066]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:13.066]             }
[10:33:13.066]             else {
[10:33:13.066]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:13.066]             }
[10:33:13.066]             {
[10:33:13.066]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:13.066]                   0L) {
[10:33:13.066]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:13.066]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:13.066]                   base::options(opts)
[10:33:13.066]                 }
[10:33:13.066]                 {
[10:33:13.066]                   {
[10:33:13.066]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:13.066]                     NULL
[10:33:13.066]                   }
[10:33:13.066]                   options(future.plan = NULL)
[10:33:13.066]                   if (is.na(NA_character_)) 
[10:33:13.066]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.066]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:13.066]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:13.066]                     .init = FALSE)
[10:33:13.066]                 }
[10:33:13.066]             }
[10:33:13.066]         }
[10:33:13.066]     })
[10:33:13.066]     if (TRUE) {
[10:33:13.066]         base::sink(type = "output", split = FALSE)
[10:33:13.066]         if (TRUE) {
[10:33:13.066]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:13.066]         }
[10:33:13.066]         else {
[10:33:13.066]             ...future.result["stdout"] <- base::list(NULL)
[10:33:13.066]         }
[10:33:13.066]         base::close(...future.stdout)
[10:33:13.066]         ...future.stdout <- NULL
[10:33:13.066]     }
[10:33:13.066]     ...future.result$conditions <- ...future.conditions
[10:33:13.066]     ...future.result$finished <- base::Sys.time()
[10:33:13.066]     ...future.result
[10:33:13.066] }
[10:33:13.068] assign_globals() ...
[10:33:13.068] List of 1
[10:33:13.068]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55aa5349f938> 
[10:33:13.068]  - attr(*, "where")=List of 1
[10:33:13.068]   ..$ a:<environment: R_EmptyEnv> 
[10:33:13.068]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:13.068]  - attr(*, "resolved")= logi TRUE
[10:33:13.068]  - attr(*, "total_size")= num 10984
[10:33:13.068]  - attr(*, "already-done")= logi TRUE
[10:33:13.071] - copied ‘a’ to environment
[10:33:13.072] assign_globals() ... done
[10:33:13.072] requestCore(): workers = 2
[10:33:13.076] MulticoreFuture started
[10:33:13.076] - Launch lazy future ... done
[10:33:13.077] run() for ‘MulticoreFuture’ ... done
[10:33:13.077] result() for MulticoreFuture ...
[10:33:13.078] plan(): Setting new future strategy stack:
[10:33:13.079] List of future strategies:
[10:33:13.079] 1. sequential:
[10:33:13.079]    - args: function (..., envir = parent.frame())
[10:33:13.079]    - tweaked: FALSE
[10:33:13.079]    - call: NULL
[10:33:13.080] plan(): nbrOfWorkers() = 1
[10:33:13.085] plan(): Setting new future strategy stack:
[10:33:13.085] List of future strategies:
[10:33:13.085] 1. multicore:
[10:33:13.085]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.085]    - tweaked: FALSE
[10:33:13.085]    - call: plan(strategy)
[10:33:13.090] plan(): nbrOfWorkers() = 2
[10:33:13.092] result() for MulticoreFuture ...
[10:33:13.092] result() for MulticoreFuture ... done
[10:33:13.092] signalConditions() ...
[10:33:13.092]  - include = ‘immediateCondition’
[10:33:13.093]  - exclude = 
[10:33:13.093]  - resignal = FALSE
[10:33:13.093]  - Number of conditions: 4
[10:33:13.093] signalConditions() ... done
[10:33:13.094] result() for MulticoreFuture ... done
[10:33:13.094] result() for MulticoreFuture ...
[10:33:13.094] result() for MulticoreFuture ... done
[10:33:13.094] signalConditions() ...
[10:33:13.094]  - include = ‘immediateCondition’
[10:33:13.094]  - exclude = 
[10:33:13.095]  - resignal = FALSE
[10:33:13.095]  - Number of conditions: 4
[10:33:13.095] signalConditions() ... done
[10:33:13.095] Future state: ‘finished’
[10:33:13.095] result() for MulticoreFuture ...
[10:33:13.095] result() for MulticoreFuture ... done
[10:33:13.095] signalConditions() ...
[10:33:13.096]  - include = ‘condition’
[10:33:13.096]  - exclude = ‘immediateCondition’
[10:33:13.096]  - resignal = TRUE
[10:33:13.096]  - Number of conditions: 4
[10:33:13.096]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.082] result() for MulticoreFuture ...
[10:33:13.096]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.082] result() for MulticoreFuture ... done
[10:33:13.096]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.083] result() for MulticoreFuture ...
[10:33:13.097]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.083] result() for MulticoreFuture ... done
[10:33:13.097] signalConditions() ... done
value(b) = 2
[10:33:13.097] result() for MulticoreFuture ...
[10:33:13.097] result() for MulticoreFuture ... done
[10:33:13.097] result() for MulticoreFuture ...
[10:33:13.098] result() for MulticoreFuture ... done
[10:33:13.098] signalConditions() ...
[10:33:13.098]  - include = ‘immediateCondition’
[10:33:13.098]  - exclude = 
[10:33:13.098]  - resignal = FALSE
[10:33:13.098]  - Number of conditions: 4
[10:33:13.098] signalConditions() ... done
[10:33:13.098] Future state: ‘finished’
[10:33:13.098] result() for MulticoreFuture ...
[10:33:13.098] result() for MulticoreFuture ... done
[10:33:13.099] signalConditions() ...
[10:33:13.099]  - include = ‘condition’
[10:33:13.099]  - exclude = ‘immediateCondition’
[10:33:13.099]  - resignal = TRUE
[10:33:13.099]  - Number of conditions: 4
[10:33:13.099]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.082] result() for MulticoreFuture ...
[10:33:13.099]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.082] result() for MulticoreFuture ... done
[10:33:13.099]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.083] result() for MulticoreFuture ...
[10:33:13.100]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.083] result() for MulticoreFuture ... done
[10:33:13.100] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.100] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.100] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:13.101] - globals found: [2] ‘{’, ‘pkg’
[10:33:13.102] Searching for globals ... DONE
[10:33:13.102] Resolving globals: TRUE
[10:33:13.102] Resolving any globals that are futures ...
[10:33:13.102] - globals: [2] ‘{’, ‘pkg’
[10:33:13.102] Resolving any globals that are futures ... DONE
[10:33:13.102] Resolving futures part of globals (recursively) ...
[10:33:13.103] resolve() on list ...
[10:33:13.103]  recursive: 99
[10:33:13.103]  length: 1
[10:33:13.103]  elements: ‘pkg’
[10:33:13.103]  length: 0 (resolved future 1)
[10:33:13.103] resolve() on list ... DONE
[10:33:13.103] - globals: [1] ‘pkg’
[10:33:13.103] Resolving futures part of globals (recursively) ... DONE
[10:33:13.104] The total size of the 1 globals is 112 bytes (112 bytes)
[10:33:13.104] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[10:33:13.104] - globals: [1] ‘pkg’
[10:33:13.104] 
[10:33:13.104] getGlobalsAndPackages() ... DONE
[10:33:13.105] Packages needed by the future expression (n = 0): <none>
[10:33:13.105] Packages needed by future strategies (n = 0): <none>
[10:33:13.105] {
[10:33:13.105]     {
[10:33:13.105]         {
[10:33:13.105]             ...future.startTime <- base::Sys.time()
[10:33:13.105]             {
[10:33:13.105]                 {
[10:33:13.105]                   {
[10:33:13.105]                     base::local({
[10:33:13.105]                       has_future <- base::requireNamespace("future", 
[10:33:13.105]                         quietly = TRUE)
[10:33:13.105]                       if (has_future) {
[10:33:13.105]                         ns <- base::getNamespace("future")
[10:33:13.105]                         version <- ns[[".package"]][["version"]]
[10:33:13.105]                         if (is.null(version)) 
[10:33:13.105]                           version <- utils::packageVersion("future")
[10:33:13.105]                       }
[10:33:13.105]                       else {
[10:33:13.105]                         version <- NULL
[10:33:13.105]                       }
[10:33:13.105]                       if (!has_future || version < "1.8.0") {
[10:33:13.105]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:13.105]                           "", base::R.version$version.string), 
[10:33:13.105]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:13.105]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:13.105]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:13.105]                             "release", "version")], collapse = " "), 
[10:33:13.105]                           hostname = base::Sys.info()[["nodename"]])
[10:33:13.105]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:13.105]                           info)
[10:33:13.105]                         info <- base::paste(info, collapse = "; ")
[10:33:13.105]                         if (!has_future) {
[10:33:13.105]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:13.105]                             info)
[10:33:13.105]                         }
[10:33:13.105]                         else {
[10:33:13.105]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:13.105]                             info, version)
[10:33:13.105]                         }
[10:33:13.105]                         base::stop(msg)
[10:33:13.105]                       }
[10:33:13.105]                     })
[10:33:13.105]                   }
[10:33:13.105]                   ...future.strategy.old <- future::plan("list")
[10:33:13.105]                   options(future.plan = NULL)
[10:33:13.105]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.105]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:13.105]                 }
[10:33:13.105]                 ...future.workdir <- getwd()
[10:33:13.105]             }
[10:33:13.105]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:13.105]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:13.105]         }
[10:33:13.105]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:13.105]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:13.105]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:13.105]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:13.105]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:13.105]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:13.105]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:13.105]             base::names(...future.oldOptions))
[10:33:13.105]     }
[10:33:13.105]     if (FALSE) {
[10:33:13.105]     }
[10:33:13.105]     else {
[10:33:13.105]         if (TRUE) {
[10:33:13.105]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:13.105]                 open = "w")
[10:33:13.105]         }
[10:33:13.105]         else {
[10:33:13.105]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:13.105]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:13.105]         }
[10:33:13.105]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:13.105]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:13.105]             base::sink(type = "output", split = FALSE)
[10:33:13.105]             base::close(...future.stdout)
[10:33:13.105]         }, add = TRUE)
[10:33:13.105]     }
[10:33:13.105]     ...future.frame <- base::sys.nframe()
[10:33:13.105]     ...future.conditions <- base::list()
[10:33:13.105]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:13.105]     if (FALSE) {
[10:33:13.105]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:13.105]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:13.105]     }
[10:33:13.105]     ...future.result <- base::tryCatch({
[10:33:13.105]         base::withCallingHandlers({
[10:33:13.105]             ...future.value <- base::withVisible(base::local({
[10:33:13.105]                 pkg
[10:33:13.105]             }))
[10:33:13.105]             future::FutureResult(value = ...future.value$value, 
[10:33:13.105]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.105]                   ...future.rng), globalenv = if (FALSE) 
[10:33:13.105]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:13.105]                     ...future.globalenv.names))
[10:33:13.105]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:13.105]         }, condition = base::local({
[10:33:13.105]             c <- base::c
[10:33:13.105]             inherits <- base::inherits
[10:33:13.105]             invokeRestart <- base::invokeRestart
[10:33:13.105]             length <- base::length
[10:33:13.105]             list <- base::list
[10:33:13.105]             seq.int <- base::seq.int
[10:33:13.105]             signalCondition <- base::signalCondition
[10:33:13.105]             sys.calls <- base::sys.calls
[10:33:13.105]             `[[` <- base::`[[`
[10:33:13.105]             `+` <- base::`+`
[10:33:13.105]             `<<-` <- base::`<<-`
[10:33:13.105]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:13.105]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:13.105]                   3L)]
[10:33:13.105]             }
[10:33:13.105]             function(cond) {
[10:33:13.105]                 is_error <- inherits(cond, "error")
[10:33:13.105]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:13.105]                   NULL)
[10:33:13.105]                 if (is_error) {
[10:33:13.105]                   sessionInformation <- function() {
[10:33:13.105]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:13.105]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:13.105]                       search = base::search(), system = base::Sys.info())
[10:33:13.105]                   }
[10:33:13.105]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.105]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:13.105]                     cond$call), session = sessionInformation(), 
[10:33:13.105]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:13.105]                   signalCondition(cond)
[10:33:13.105]                 }
[10:33:13.105]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:13.105]                 "immediateCondition"))) {
[10:33:13.105]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:13.105]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.105]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:13.105]                   if (TRUE && !signal) {
[10:33:13.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.105]                     {
[10:33:13.105]                       inherits <- base::inherits
[10:33:13.105]                       invokeRestart <- base::invokeRestart
[10:33:13.105]                       is.null <- base::is.null
[10:33:13.105]                       muffled <- FALSE
[10:33:13.105]                       if (inherits(cond, "message")) {
[10:33:13.105]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.105]                         if (muffled) 
[10:33:13.105]                           invokeRestart("muffleMessage")
[10:33:13.105]                       }
[10:33:13.105]                       else if (inherits(cond, "warning")) {
[10:33:13.105]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.105]                         if (muffled) 
[10:33:13.105]                           invokeRestart("muffleWarning")
[10:33:13.105]                       }
[10:33:13.105]                       else if (inherits(cond, "condition")) {
[10:33:13.105]                         if (!is.null(pattern)) {
[10:33:13.105]                           computeRestarts <- base::computeRestarts
[10:33:13.105]                           grepl <- base::grepl
[10:33:13.105]                           restarts <- computeRestarts(cond)
[10:33:13.105]                           for (restart in restarts) {
[10:33:13.105]                             name <- restart$name
[10:33:13.105]                             if (is.null(name)) 
[10:33:13.105]                               next
[10:33:13.105]                             if (!grepl(pattern, name)) 
[10:33:13.105]                               next
[10:33:13.105]                             invokeRestart(restart)
[10:33:13.105]                             muffled <- TRUE
[10:33:13.105]                             break
[10:33:13.105]                           }
[10:33:13.105]                         }
[10:33:13.105]                       }
[10:33:13.105]                       invisible(muffled)
[10:33:13.105]                     }
[10:33:13.105]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.105]                   }
[10:33:13.105]                 }
[10:33:13.105]                 else {
[10:33:13.105]                   if (TRUE) {
[10:33:13.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.105]                     {
[10:33:13.105]                       inherits <- base::inherits
[10:33:13.105]                       invokeRestart <- base::invokeRestart
[10:33:13.105]                       is.null <- base::is.null
[10:33:13.105]                       muffled <- FALSE
[10:33:13.105]                       if (inherits(cond, "message")) {
[10:33:13.105]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.105]                         if (muffled) 
[10:33:13.105]                           invokeRestart("muffleMessage")
[10:33:13.105]                       }
[10:33:13.105]                       else if (inherits(cond, "warning")) {
[10:33:13.105]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.105]                         if (muffled) 
[10:33:13.105]                           invokeRestart("muffleWarning")
[10:33:13.105]                       }
[10:33:13.105]                       else if (inherits(cond, "condition")) {
[10:33:13.105]                         if (!is.null(pattern)) {
[10:33:13.105]                           computeRestarts <- base::computeRestarts
[10:33:13.105]                           grepl <- base::grepl
[10:33:13.105]                           restarts <- computeRestarts(cond)
[10:33:13.105]                           for (restart in restarts) {
[10:33:13.105]                             name <- restart$name
[10:33:13.105]                             if (is.null(name)) 
[10:33:13.105]                               next
[10:33:13.105]                             if (!grepl(pattern, name)) 
[10:33:13.105]                               next
[10:33:13.105]                             invokeRestart(restart)
[10:33:13.105]                             muffled <- TRUE
[10:33:13.105]                             break
[10:33:13.105]                           }
[10:33:13.105]                         }
[10:33:13.105]                       }
[10:33:13.105]                       invisible(muffled)
[10:33:13.105]                     }
[10:33:13.105]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.105]                   }
[10:33:13.105]                 }
[10:33:13.105]             }
[10:33:13.105]         }))
[10:33:13.105]     }, error = function(ex) {
[10:33:13.105]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:13.105]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.105]                 ...future.rng), started = ...future.startTime, 
[10:33:13.105]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:13.105]             version = "1.8"), class = "FutureResult")
[10:33:13.105]     }, finally = {
[10:33:13.105]         if (!identical(...future.workdir, getwd())) 
[10:33:13.105]             setwd(...future.workdir)
[10:33:13.105]         {
[10:33:13.105]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:13.105]                 ...future.oldOptions$nwarnings <- NULL
[10:33:13.105]             }
[10:33:13.105]             base::options(...future.oldOptions)
[10:33:13.105]             if (.Platform$OS.type == "windows") {
[10:33:13.105]                 old_names <- names(...future.oldEnvVars)
[10:33:13.105]                 envs <- base::Sys.getenv()
[10:33:13.105]                 names <- names(envs)
[10:33:13.105]                 common <- intersect(names, old_names)
[10:33:13.105]                 added <- setdiff(names, old_names)
[10:33:13.105]                 removed <- setdiff(old_names, names)
[10:33:13.105]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:13.105]                   envs[common]]
[10:33:13.105]                 NAMES <- toupper(changed)
[10:33:13.105]                 args <- list()
[10:33:13.105]                 for (kk in seq_along(NAMES)) {
[10:33:13.105]                   name <- changed[[kk]]
[10:33:13.105]                   NAME <- NAMES[[kk]]
[10:33:13.105]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.105]                     next
[10:33:13.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.105]                 }
[10:33:13.105]                 NAMES <- toupper(added)
[10:33:13.105]                 for (kk in seq_along(NAMES)) {
[10:33:13.105]                   name <- added[[kk]]
[10:33:13.105]                   NAME <- NAMES[[kk]]
[10:33:13.105]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.105]                     next
[10:33:13.105]                   args[[name]] <- ""
[10:33:13.105]                 }
[10:33:13.105]                 NAMES <- toupper(removed)
[10:33:13.105]                 for (kk in seq_along(NAMES)) {
[10:33:13.105]                   name <- removed[[kk]]
[10:33:13.105]                   NAME <- NAMES[[kk]]
[10:33:13.105]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.105]                     next
[10:33:13.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.105]                 }
[10:33:13.105]                 if (length(args) > 0) 
[10:33:13.105]                   base::do.call(base::Sys.setenv, args = args)
[10:33:13.105]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:13.105]             }
[10:33:13.105]             else {
[10:33:13.105]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:13.105]             }
[10:33:13.105]             {
[10:33:13.105]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:13.105]                   0L) {
[10:33:13.105]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:13.105]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:13.105]                   base::options(opts)
[10:33:13.105]                 }
[10:33:13.105]                 {
[10:33:13.105]                   {
[10:33:13.105]                     NULL
[10:33:13.105]                     RNGkind("Mersenne-Twister")
[10:33:13.105]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:13.105]                       inherits = FALSE)
[10:33:13.105]                   }
[10:33:13.105]                   options(future.plan = NULL)
[10:33:13.105]                   if (is.na(NA_character_)) 
[10:33:13.105]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.105]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:13.105]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:13.105]                     .init = FALSE)
[10:33:13.105]                 }
[10:33:13.105]             }
[10:33:13.105]         }
[10:33:13.105]     })
[10:33:13.105]     if (TRUE) {
[10:33:13.105]         base::sink(type = "output", split = FALSE)
[10:33:13.105]         if (TRUE) {
[10:33:13.105]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:13.105]         }
[10:33:13.105]         else {
[10:33:13.105]             ...future.result["stdout"] <- base::list(NULL)
[10:33:13.105]         }
[10:33:13.105]         base::close(...future.stdout)
[10:33:13.105]         ...future.stdout <- NULL
[10:33:13.105]     }
[10:33:13.105]     ...future.result$conditions <- ...future.conditions
[10:33:13.105]     ...future.result$finished <- base::Sys.time()
[10:33:13.105]     ...future.result
[10:33:13.105] }
[10:33:13.108] assign_globals() ...
[10:33:13.108] List of 1
[10:33:13.108]  $ pkg: chr "foo"
[10:33:13.108]  - attr(*, "where")=List of 1
[10:33:13.108]   ..$ pkg:<environment: R_EmptyEnv> 
[10:33:13.108]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:13.108]  - attr(*, "resolved")= logi TRUE
[10:33:13.108]  - attr(*, "total_size")= num 112
[10:33:13.110] - copied ‘pkg’ to environment
[10:33:13.110] assign_globals() ... done
[10:33:13.111] plan(): Setting new future strategy stack:
[10:33:13.111] List of future strategies:
[10:33:13.111] 1. sequential:
[10:33:13.111]    - args: function (..., envir = parent.frame())
[10:33:13.111]    - tweaked: FALSE
[10:33:13.111]    - call: NULL
[10:33:13.111] plan(): nbrOfWorkers() = 1
[10:33:13.112] plan(): Setting new future strategy stack:
[10:33:13.112] List of future strategies:
[10:33:13.112] 1. multicore:
[10:33:13.112]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.112]    - tweaked: FALSE
[10:33:13.112]    - call: plan(strategy)
[10:33:13.116] plan(): nbrOfWorkers() = 2
[10:33:13.116] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.117] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.124] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:13.126] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:33:13.126] Searching for globals ... DONE
[10:33:13.126] Resolving globals: TRUE
[10:33:13.126] Resolving any globals that are futures ...
[10:33:13.126] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:33:13.126] Resolving any globals that are futures ... DONE
[10:33:13.127] Resolving futures part of globals (recursively) ...
[10:33:13.127] resolve() on list ...
[10:33:13.127]  recursive: 99
[10:33:13.127]  length: 1
[10:33:13.127]  elements: ‘a’
[10:33:13.127]  length: 0 (resolved future 1)
[10:33:13.128] resolve() on list ... DONE
[10:33:13.128] - globals: [1] ‘a’
[10:33:13.128] Resolving futures part of globals (recursively) ... DONE
[10:33:13.128] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:13.128] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:33:13.128] - globals: [1] ‘a’
[10:33:13.128] 
[10:33:13.129] getGlobalsAndPackages() ... DONE
[10:33:13.129] run() for ‘Future’ ...
[10:33:13.129] - state: ‘created’
[10:33:13.129] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:13.132] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:13.133] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:13.133]   - Field: ‘label’
[10:33:13.133]   - Field: ‘local’
[10:33:13.133]   - Field: ‘owner’
[10:33:13.133]   - Field: ‘envir’
[10:33:13.133]   - Field: ‘workers’
[10:33:13.133]   - Field: ‘packages’
[10:33:13.133]   - Field: ‘gc’
[10:33:13.133]   - Field: ‘job’
[10:33:13.134]   - Field: ‘conditions’
[10:33:13.134]   - Field: ‘expr’
[10:33:13.134]   - Field: ‘uuid’
[10:33:13.134]   - Field: ‘seed’
[10:33:13.134]   - Field: ‘version’
[10:33:13.134]   - Field: ‘result’
[10:33:13.134]   - Field: ‘asynchronous’
[10:33:13.134]   - Field: ‘calls’
[10:33:13.134]   - Field: ‘globals’
[10:33:13.134]   - Field: ‘stdout’
[10:33:13.134]   - Field: ‘earlySignal’
[10:33:13.135]   - Field: ‘lazy’
[10:33:13.135]   - Field: ‘state’
[10:33:13.135] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:13.135] - Launch lazy future ...
[10:33:13.135] Packages needed by the future expression (n = 0): <none>
[10:33:13.135] Packages needed by future strategies (n = 0): <none>
[10:33:13.136] {
[10:33:13.136]     {
[10:33:13.136]         {
[10:33:13.136]             ...future.startTime <- base::Sys.time()
[10:33:13.136]             {
[10:33:13.136]                 {
[10:33:13.136]                   {
[10:33:13.136]                     {
[10:33:13.136]                       base::local({
[10:33:13.136]                         has_future <- base::requireNamespace("future", 
[10:33:13.136]                           quietly = TRUE)
[10:33:13.136]                         if (has_future) {
[10:33:13.136]                           ns <- base::getNamespace("future")
[10:33:13.136]                           version <- ns[[".package"]][["version"]]
[10:33:13.136]                           if (is.null(version)) 
[10:33:13.136]                             version <- utils::packageVersion("future")
[10:33:13.136]                         }
[10:33:13.136]                         else {
[10:33:13.136]                           version <- NULL
[10:33:13.136]                         }
[10:33:13.136]                         if (!has_future || version < "1.8.0") {
[10:33:13.136]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:13.136]                             "", base::R.version$version.string), 
[10:33:13.136]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:13.136]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:13.136]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:13.136]                               "release", "version")], collapse = " "), 
[10:33:13.136]                             hostname = base::Sys.info()[["nodename"]])
[10:33:13.136]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:13.136]                             info)
[10:33:13.136]                           info <- base::paste(info, collapse = "; ")
[10:33:13.136]                           if (!has_future) {
[10:33:13.136]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:13.136]                               info)
[10:33:13.136]                           }
[10:33:13.136]                           else {
[10:33:13.136]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:13.136]                               info, version)
[10:33:13.136]                           }
[10:33:13.136]                           base::stop(msg)
[10:33:13.136]                         }
[10:33:13.136]                       })
[10:33:13.136]                     }
[10:33:13.136]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:13.136]                     base::options(mc.cores = 1L)
[10:33:13.136]                   }
[10:33:13.136]                   ...future.strategy.old <- future::plan("list")
[10:33:13.136]                   options(future.plan = NULL)
[10:33:13.136]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.136]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:13.136]                 }
[10:33:13.136]                 ...future.workdir <- getwd()
[10:33:13.136]             }
[10:33:13.136]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:13.136]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:13.136]         }
[10:33:13.136]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:13.136]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:13.136]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:13.136]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:13.136]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:13.136]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:13.136]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:13.136]             base::names(...future.oldOptions))
[10:33:13.136]     }
[10:33:13.136]     if (FALSE) {
[10:33:13.136]     }
[10:33:13.136]     else {
[10:33:13.136]         if (TRUE) {
[10:33:13.136]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:13.136]                 open = "w")
[10:33:13.136]         }
[10:33:13.136]         else {
[10:33:13.136]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:13.136]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:13.136]         }
[10:33:13.136]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:13.136]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:13.136]             base::sink(type = "output", split = FALSE)
[10:33:13.136]             base::close(...future.stdout)
[10:33:13.136]         }, add = TRUE)
[10:33:13.136]     }
[10:33:13.136]     ...future.frame <- base::sys.nframe()
[10:33:13.136]     ...future.conditions <- base::list()
[10:33:13.136]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:13.136]     if (FALSE) {
[10:33:13.136]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:13.136]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:13.136]     }
[10:33:13.136]     ...future.result <- base::tryCatch({
[10:33:13.136]         base::withCallingHandlers({
[10:33:13.136]             ...future.value <- base::withVisible(base::local({
[10:33:13.136]                 withCallingHandlers({
[10:33:13.136]                   {
[10:33:13.136]                     b <- a
[10:33:13.136]                     a <- 2
[10:33:13.136]                     a * b
[10:33:13.136]                   }
[10:33:13.136]                 }, immediateCondition = function(cond) {
[10:33:13.136]                   save_rds <- function (object, pathname, ...) 
[10:33:13.136]                   {
[10:33:13.136]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:13.136]                     if (file_test("-f", pathname_tmp)) {
[10:33:13.136]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.136]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:13.136]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.136]                         fi_tmp[["mtime"]])
[10:33:13.136]                     }
[10:33:13.136]                     tryCatch({
[10:33:13.136]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:13.136]                     }, error = function(ex) {
[10:33:13.136]                       msg <- conditionMessage(ex)
[10:33:13.136]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.136]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:13.136]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.136]                         fi_tmp[["mtime"]], msg)
[10:33:13.136]                       ex$message <- msg
[10:33:13.136]                       stop(ex)
[10:33:13.136]                     })
[10:33:13.136]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:13.136]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:13.136]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:13.136]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.136]                       fi <- file.info(pathname)
[10:33:13.136]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:13.136]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.136]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:13.136]                         fi[["size"]], fi[["mtime"]])
[10:33:13.136]                       stop(msg)
[10:33:13.136]                     }
[10:33:13.136]                     invisible(pathname)
[10:33:13.136]                   }
[10:33:13.136]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:13.136]                     rootPath = tempdir()) 
[10:33:13.136]                   {
[10:33:13.136]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:13.136]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:13.136]                       tmpdir = path, fileext = ".rds")
[10:33:13.136]                     save_rds(obj, file)
[10:33:13.136]                   }
[10:33:13.136]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:13.136]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.136]                   {
[10:33:13.136]                     inherits <- base::inherits
[10:33:13.136]                     invokeRestart <- base::invokeRestart
[10:33:13.136]                     is.null <- base::is.null
[10:33:13.136]                     muffled <- FALSE
[10:33:13.136]                     if (inherits(cond, "message")) {
[10:33:13.136]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:13.136]                       if (muffled) 
[10:33:13.136]                         invokeRestart("muffleMessage")
[10:33:13.136]                     }
[10:33:13.136]                     else if (inherits(cond, "warning")) {
[10:33:13.136]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:13.136]                       if (muffled) 
[10:33:13.136]                         invokeRestart("muffleWarning")
[10:33:13.136]                     }
[10:33:13.136]                     else if (inherits(cond, "condition")) {
[10:33:13.136]                       if (!is.null(pattern)) {
[10:33:13.136]                         computeRestarts <- base::computeRestarts
[10:33:13.136]                         grepl <- base::grepl
[10:33:13.136]                         restarts <- computeRestarts(cond)
[10:33:13.136]                         for (restart in restarts) {
[10:33:13.136]                           name <- restart$name
[10:33:13.136]                           if (is.null(name)) 
[10:33:13.136]                             next
[10:33:13.136]                           if (!grepl(pattern, name)) 
[10:33:13.136]                             next
[10:33:13.136]                           invokeRestart(restart)
[10:33:13.136]                           muffled <- TRUE
[10:33:13.136]                           break
[10:33:13.136]                         }
[10:33:13.136]                       }
[10:33:13.136]                     }
[10:33:13.136]                     invisible(muffled)
[10:33:13.136]                   }
[10:33:13.136]                   muffleCondition(cond)
[10:33:13.136]                 })
[10:33:13.136]             }))
[10:33:13.136]             future::FutureResult(value = ...future.value$value, 
[10:33:13.136]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.136]                   ...future.rng), globalenv = if (FALSE) 
[10:33:13.136]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:13.136]                     ...future.globalenv.names))
[10:33:13.136]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:13.136]         }, condition = base::local({
[10:33:13.136]             c <- base::c
[10:33:13.136]             inherits <- base::inherits
[10:33:13.136]             invokeRestart <- base::invokeRestart
[10:33:13.136]             length <- base::length
[10:33:13.136]             list <- base::list
[10:33:13.136]             seq.int <- base::seq.int
[10:33:13.136]             signalCondition <- base::signalCondition
[10:33:13.136]             sys.calls <- base::sys.calls
[10:33:13.136]             `[[` <- base::`[[`
[10:33:13.136]             `+` <- base::`+`
[10:33:13.136]             `<<-` <- base::`<<-`
[10:33:13.136]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:13.136]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:13.136]                   3L)]
[10:33:13.136]             }
[10:33:13.136]             function(cond) {
[10:33:13.136]                 is_error <- inherits(cond, "error")
[10:33:13.136]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:13.136]                   NULL)
[10:33:13.136]                 if (is_error) {
[10:33:13.136]                   sessionInformation <- function() {
[10:33:13.136]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:13.136]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:13.136]                       search = base::search(), system = base::Sys.info())
[10:33:13.136]                   }
[10:33:13.136]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.136]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:13.136]                     cond$call), session = sessionInformation(), 
[10:33:13.136]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:13.136]                   signalCondition(cond)
[10:33:13.136]                 }
[10:33:13.136]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:13.136]                 "immediateCondition"))) {
[10:33:13.136]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:13.136]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.136]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:13.136]                   if (TRUE && !signal) {
[10:33:13.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.136]                     {
[10:33:13.136]                       inherits <- base::inherits
[10:33:13.136]                       invokeRestart <- base::invokeRestart
[10:33:13.136]                       is.null <- base::is.null
[10:33:13.136]                       muffled <- FALSE
[10:33:13.136]                       if (inherits(cond, "message")) {
[10:33:13.136]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.136]                         if (muffled) 
[10:33:13.136]                           invokeRestart("muffleMessage")
[10:33:13.136]                       }
[10:33:13.136]                       else if (inherits(cond, "warning")) {
[10:33:13.136]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.136]                         if (muffled) 
[10:33:13.136]                           invokeRestart("muffleWarning")
[10:33:13.136]                       }
[10:33:13.136]                       else if (inherits(cond, "condition")) {
[10:33:13.136]                         if (!is.null(pattern)) {
[10:33:13.136]                           computeRestarts <- base::computeRestarts
[10:33:13.136]                           grepl <- base::grepl
[10:33:13.136]                           restarts <- computeRestarts(cond)
[10:33:13.136]                           for (restart in restarts) {
[10:33:13.136]                             name <- restart$name
[10:33:13.136]                             if (is.null(name)) 
[10:33:13.136]                               next
[10:33:13.136]                             if (!grepl(pattern, name)) 
[10:33:13.136]                               next
[10:33:13.136]                             invokeRestart(restart)
[10:33:13.136]                             muffled <- TRUE
[10:33:13.136]                             break
[10:33:13.136]                           }
[10:33:13.136]                         }
[10:33:13.136]                       }
[10:33:13.136]                       invisible(muffled)
[10:33:13.136]                     }
[10:33:13.136]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.136]                   }
[10:33:13.136]                 }
[10:33:13.136]                 else {
[10:33:13.136]                   if (TRUE) {
[10:33:13.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.136]                     {
[10:33:13.136]                       inherits <- base::inherits
[10:33:13.136]                       invokeRestart <- base::invokeRestart
[10:33:13.136]                       is.null <- base::is.null
[10:33:13.136]                       muffled <- FALSE
[10:33:13.136]                       if (inherits(cond, "message")) {
[10:33:13.136]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.136]                         if (muffled) 
[10:33:13.136]                           invokeRestart("muffleMessage")
[10:33:13.136]                       }
[10:33:13.136]                       else if (inherits(cond, "warning")) {
[10:33:13.136]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.136]                         if (muffled) 
[10:33:13.136]                           invokeRestart("muffleWarning")
[10:33:13.136]                       }
[10:33:13.136]                       else if (inherits(cond, "condition")) {
[10:33:13.136]                         if (!is.null(pattern)) {
[10:33:13.136]                           computeRestarts <- base::computeRestarts
[10:33:13.136]                           grepl <- base::grepl
[10:33:13.136]                           restarts <- computeRestarts(cond)
[10:33:13.136]                           for (restart in restarts) {
[10:33:13.136]                             name <- restart$name
[10:33:13.136]                             if (is.null(name)) 
[10:33:13.136]                               next
[10:33:13.136]                             if (!grepl(pattern, name)) 
[10:33:13.136]                               next
[10:33:13.136]                             invokeRestart(restart)
[10:33:13.136]                             muffled <- TRUE
[10:33:13.136]                             break
[10:33:13.136]                           }
[10:33:13.136]                         }
[10:33:13.136]                       }
[10:33:13.136]                       invisible(muffled)
[10:33:13.136]                     }
[10:33:13.136]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.136]                   }
[10:33:13.136]                 }
[10:33:13.136]             }
[10:33:13.136]         }))
[10:33:13.136]     }, error = function(ex) {
[10:33:13.136]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:13.136]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.136]                 ...future.rng), started = ...future.startTime, 
[10:33:13.136]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:13.136]             version = "1.8"), class = "FutureResult")
[10:33:13.136]     }, finally = {
[10:33:13.136]         if (!identical(...future.workdir, getwd())) 
[10:33:13.136]             setwd(...future.workdir)
[10:33:13.136]         {
[10:33:13.136]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:13.136]                 ...future.oldOptions$nwarnings <- NULL
[10:33:13.136]             }
[10:33:13.136]             base::options(...future.oldOptions)
[10:33:13.136]             if (.Platform$OS.type == "windows") {
[10:33:13.136]                 old_names <- names(...future.oldEnvVars)
[10:33:13.136]                 envs <- base::Sys.getenv()
[10:33:13.136]                 names <- names(envs)
[10:33:13.136]                 common <- intersect(names, old_names)
[10:33:13.136]                 added <- setdiff(names, old_names)
[10:33:13.136]                 removed <- setdiff(old_names, names)
[10:33:13.136]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:13.136]                   envs[common]]
[10:33:13.136]                 NAMES <- toupper(changed)
[10:33:13.136]                 args <- list()
[10:33:13.136]                 for (kk in seq_along(NAMES)) {
[10:33:13.136]                   name <- changed[[kk]]
[10:33:13.136]                   NAME <- NAMES[[kk]]
[10:33:13.136]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.136]                     next
[10:33:13.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.136]                 }
[10:33:13.136]                 NAMES <- toupper(added)
[10:33:13.136]                 for (kk in seq_along(NAMES)) {
[10:33:13.136]                   name <- added[[kk]]
[10:33:13.136]                   NAME <- NAMES[[kk]]
[10:33:13.136]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.136]                     next
[10:33:13.136]                   args[[name]] <- ""
[10:33:13.136]                 }
[10:33:13.136]                 NAMES <- toupper(removed)
[10:33:13.136]                 for (kk in seq_along(NAMES)) {
[10:33:13.136]                   name <- removed[[kk]]
[10:33:13.136]                   NAME <- NAMES[[kk]]
[10:33:13.136]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.136]                     next
[10:33:13.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.136]                 }
[10:33:13.136]                 if (length(args) > 0) 
[10:33:13.136]                   base::do.call(base::Sys.setenv, args = args)
[10:33:13.136]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:13.136]             }
[10:33:13.136]             else {
[10:33:13.136]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:13.136]             }
[10:33:13.136]             {
[10:33:13.136]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:13.136]                   0L) {
[10:33:13.136]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:13.136]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:13.136]                   base::options(opts)
[10:33:13.136]                 }
[10:33:13.136]                 {
[10:33:13.136]                   {
[10:33:13.136]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:13.136]                     NULL
[10:33:13.136]                   }
[10:33:13.136]                   options(future.plan = NULL)
[10:33:13.136]                   if (is.na(NA_character_)) 
[10:33:13.136]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.136]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:13.136]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:13.136]                     .init = FALSE)
[10:33:13.136]                 }
[10:33:13.136]             }
[10:33:13.136]         }
[10:33:13.136]     })
[10:33:13.136]     if (TRUE) {
[10:33:13.136]         base::sink(type = "output", split = FALSE)
[10:33:13.136]         if (TRUE) {
[10:33:13.136]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:13.136]         }
[10:33:13.136]         else {
[10:33:13.136]             ...future.result["stdout"] <- base::list(NULL)
[10:33:13.136]         }
[10:33:13.136]         base::close(...future.stdout)
[10:33:13.136]         ...future.stdout <- NULL
[10:33:13.136]     }
[10:33:13.136]     ...future.result$conditions <- ...future.conditions
[10:33:13.136]     ...future.result$finished <- base::Sys.time()
[10:33:13.136]     ...future.result
[10:33:13.136] }
[10:33:13.138] assign_globals() ...
[10:33:13.138] List of 1
[10:33:13.138]  $ a: num 3
[10:33:13.138]  - attr(*, "where")=List of 1
[10:33:13.138]   ..$ a:<environment: R_EmptyEnv> 
[10:33:13.138]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:13.138]  - attr(*, "resolved")= logi TRUE
[10:33:13.138]  - attr(*, "total_size")= num 56
[10:33:13.138]  - attr(*, "already-done")= logi TRUE
[10:33:13.140] - copied ‘a’ to environment
[10:33:13.140] assign_globals() ... done
[10:33:13.140] requestCore(): workers = 2
[10:33:13.142] MulticoreFuture started
[10:33:13.143] - Launch lazy future ... done
[10:33:13.143] run() for ‘MulticoreFuture’ ... done
[10:33:13.143] result() for MulticoreFuture ...
[10:33:13.143] plan(): Setting new future strategy stack:
[10:33:13.144] List of future strategies:
[10:33:13.144] 1. sequential:
[10:33:13.144]    - args: function (..., envir = parent.frame())
[10:33:13.144]    - tweaked: FALSE
[10:33:13.144]    - call: NULL
[10:33:13.145] plan(): nbrOfWorkers() = 1
[10:33:13.147] plan(): Setting new future strategy stack:
[10:33:13.147] List of future strategies:
[10:33:13.147] 1. multicore:
[10:33:13.147]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.147]    - tweaked: FALSE
[10:33:13.147]    - call: plan(strategy)
[10:33:13.152] plan(): nbrOfWorkers() = 2
[10:33:13.153] result() for MulticoreFuture ...
[10:33:13.153] result() for MulticoreFuture ... done
[10:33:13.153] result() for MulticoreFuture ... done
[10:33:13.154] result() for MulticoreFuture ...
[10:33:13.154] result() for MulticoreFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.154] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.155] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:13.157] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:33:13.157] Searching for globals ... DONE
[10:33:13.157] Resolving globals: TRUE
[10:33:13.158] Resolving any globals that are futures ...
[10:33:13.158] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:33:13.158] Resolving any globals that are futures ... DONE
[10:33:13.158] Resolving futures part of globals (recursively) ...
[10:33:13.159] resolve() on list ...
[10:33:13.159]  recursive: 99
[10:33:13.159]  length: 1
[10:33:13.159]  elements: ‘a’
[10:33:13.159]  length: 0 (resolved future 1)
[10:33:13.159] resolve() on list ... DONE
[10:33:13.159] - globals: [1] ‘a’
[10:33:13.159] Resolving futures part of globals (recursively) ... DONE
[10:33:13.160] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:13.162] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:33:13.162] - globals: [1] ‘a’
[10:33:13.163] 
[10:33:13.163] getGlobalsAndPackages() ... DONE
[10:33:13.163] run() for ‘Future’ ...
[10:33:13.164] - state: ‘created’
[10:33:13.164] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:13.168] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:13.168] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:13.168]   - Field: ‘label’
[10:33:13.168]   - Field: ‘local’
[10:33:13.169]   - Field: ‘owner’
[10:33:13.169]   - Field: ‘envir’
[10:33:13.169]   - Field: ‘workers’
[10:33:13.169]   - Field: ‘packages’
[10:33:13.169]   - Field: ‘gc’
[10:33:13.169]   - Field: ‘job’
[10:33:13.170]   - Field: ‘conditions’
[10:33:13.170]   - Field: ‘expr’
[10:33:13.170]   - Field: ‘uuid’
[10:33:13.170]   - Field: ‘seed’
[10:33:13.170]   - Field: ‘version’
[10:33:13.170]   - Field: ‘result’
[10:33:13.170]   - Field: ‘asynchronous’
[10:33:13.170]   - Field: ‘calls’
[10:33:13.170]   - Field: ‘globals’
[10:33:13.171]   - Field: ‘stdout’
[10:33:13.171]   - Field: ‘earlySignal’
[10:33:13.171]   - Field: ‘lazy’
[10:33:13.171]   - Field: ‘state’
[10:33:13.171] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:13.171] - Launch lazy future ...
[10:33:13.172] Packages needed by the future expression (n = 0): <none>
[10:33:13.172] Packages needed by future strategies (n = 0): <none>
[10:33:13.172] {
[10:33:13.172]     {
[10:33:13.172]         {
[10:33:13.172]             ...future.startTime <- base::Sys.time()
[10:33:13.172]             {
[10:33:13.172]                 {
[10:33:13.172]                   {
[10:33:13.172]                     {
[10:33:13.172]                       base::local({
[10:33:13.172]                         has_future <- base::requireNamespace("future", 
[10:33:13.172]                           quietly = TRUE)
[10:33:13.172]                         if (has_future) {
[10:33:13.172]                           ns <- base::getNamespace("future")
[10:33:13.172]                           version <- ns[[".package"]][["version"]]
[10:33:13.172]                           if (is.null(version)) 
[10:33:13.172]                             version <- utils::packageVersion("future")
[10:33:13.172]                         }
[10:33:13.172]                         else {
[10:33:13.172]                           version <- NULL
[10:33:13.172]                         }
[10:33:13.172]                         if (!has_future || version < "1.8.0") {
[10:33:13.172]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:13.172]                             "", base::R.version$version.string), 
[10:33:13.172]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:13.172]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:13.172]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:13.172]                               "release", "version")], collapse = " "), 
[10:33:13.172]                             hostname = base::Sys.info()[["nodename"]])
[10:33:13.172]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:13.172]                             info)
[10:33:13.172]                           info <- base::paste(info, collapse = "; ")
[10:33:13.172]                           if (!has_future) {
[10:33:13.172]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:13.172]                               info)
[10:33:13.172]                           }
[10:33:13.172]                           else {
[10:33:13.172]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:13.172]                               info, version)
[10:33:13.172]                           }
[10:33:13.172]                           base::stop(msg)
[10:33:13.172]                         }
[10:33:13.172]                       })
[10:33:13.172]                     }
[10:33:13.172]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:13.172]                     base::options(mc.cores = 1L)
[10:33:13.172]                   }
[10:33:13.172]                   ...future.strategy.old <- future::plan("list")
[10:33:13.172]                   options(future.plan = NULL)
[10:33:13.172]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.172]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:13.172]                 }
[10:33:13.172]                 ...future.workdir <- getwd()
[10:33:13.172]             }
[10:33:13.172]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:13.172]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:13.172]         }
[10:33:13.172]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:13.172]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:13.172]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:13.172]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:13.172]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:13.172]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:13.172]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:13.172]             base::names(...future.oldOptions))
[10:33:13.172]     }
[10:33:13.172]     if (FALSE) {
[10:33:13.172]     }
[10:33:13.172]     else {
[10:33:13.172]         if (TRUE) {
[10:33:13.172]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:13.172]                 open = "w")
[10:33:13.172]         }
[10:33:13.172]         else {
[10:33:13.172]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:13.172]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:13.172]         }
[10:33:13.172]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:13.172]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:13.172]             base::sink(type = "output", split = FALSE)
[10:33:13.172]             base::close(...future.stdout)
[10:33:13.172]         }, add = TRUE)
[10:33:13.172]     }
[10:33:13.172]     ...future.frame <- base::sys.nframe()
[10:33:13.172]     ...future.conditions <- base::list()
[10:33:13.172]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:13.172]     if (FALSE) {
[10:33:13.172]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:13.172]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:13.172]     }
[10:33:13.172]     ...future.result <- base::tryCatch({
[10:33:13.172]         base::withCallingHandlers({
[10:33:13.172]             ...future.value <- base::withVisible(base::local({
[10:33:13.172]                 withCallingHandlers({
[10:33:13.172]                   {
[10:33:13.172]                     b <- a
[10:33:13.172]                     a <- 2
[10:33:13.172]                     a * b
[10:33:13.172]                   }
[10:33:13.172]                 }, immediateCondition = function(cond) {
[10:33:13.172]                   save_rds <- function (object, pathname, ...) 
[10:33:13.172]                   {
[10:33:13.172]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:13.172]                     if (file_test("-f", pathname_tmp)) {
[10:33:13.172]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.172]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:13.172]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.172]                         fi_tmp[["mtime"]])
[10:33:13.172]                     }
[10:33:13.172]                     tryCatch({
[10:33:13.172]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:13.172]                     }, error = function(ex) {
[10:33:13.172]                       msg <- conditionMessage(ex)
[10:33:13.172]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.172]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:13.172]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.172]                         fi_tmp[["mtime"]], msg)
[10:33:13.172]                       ex$message <- msg
[10:33:13.172]                       stop(ex)
[10:33:13.172]                     })
[10:33:13.172]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:13.172]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:13.172]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:13.172]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.172]                       fi <- file.info(pathname)
[10:33:13.172]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:13.172]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.172]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:13.172]                         fi[["size"]], fi[["mtime"]])
[10:33:13.172]                       stop(msg)
[10:33:13.172]                     }
[10:33:13.172]                     invisible(pathname)
[10:33:13.172]                   }
[10:33:13.172]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:13.172]                     rootPath = tempdir()) 
[10:33:13.172]                   {
[10:33:13.172]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:13.172]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:13.172]                       tmpdir = path, fileext = ".rds")
[10:33:13.172]                     save_rds(obj, file)
[10:33:13.172]                   }
[10:33:13.172]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:13.172]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.172]                   {
[10:33:13.172]                     inherits <- base::inherits
[10:33:13.172]                     invokeRestart <- base::invokeRestart
[10:33:13.172]                     is.null <- base::is.null
[10:33:13.172]                     muffled <- FALSE
[10:33:13.172]                     if (inherits(cond, "message")) {
[10:33:13.172]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:13.172]                       if (muffled) 
[10:33:13.172]                         invokeRestart("muffleMessage")
[10:33:13.172]                     }
[10:33:13.172]                     else if (inherits(cond, "warning")) {
[10:33:13.172]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:13.172]                       if (muffled) 
[10:33:13.172]                         invokeRestart("muffleWarning")
[10:33:13.172]                     }
[10:33:13.172]                     else if (inherits(cond, "condition")) {
[10:33:13.172]                       if (!is.null(pattern)) {
[10:33:13.172]                         computeRestarts <- base::computeRestarts
[10:33:13.172]                         grepl <- base::grepl
[10:33:13.172]                         restarts <- computeRestarts(cond)
[10:33:13.172]                         for (restart in restarts) {
[10:33:13.172]                           name <- restart$name
[10:33:13.172]                           if (is.null(name)) 
[10:33:13.172]                             next
[10:33:13.172]                           if (!grepl(pattern, name)) 
[10:33:13.172]                             next
[10:33:13.172]                           invokeRestart(restart)
[10:33:13.172]                           muffled <- TRUE
[10:33:13.172]                           break
[10:33:13.172]                         }
[10:33:13.172]                       }
[10:33:13.172]                     }
[10:33:13.172]                     invisible(muffled)
[10:33:13.172]                   }
[10:33:13.172]                   muffleCondition(cond)
[10:33:13.172]                 })
[10:33:13.172]             }))
[10:33:13.172]             future::FutureResult(value = ...future.value$value, 
[10:33:13.172]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.172]                   ...future.rng), globalenv = if (FALSE) 
[10:33:13.172]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:13.172]                     ...future.globalenv.names))
[10:33:13.172]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:13.172]         }, condition = base::local({
[10:33:13.172]             c <- base::c
[10:33:13.172]             inherits <- base::inherits
[10:33:13.172]             invokeRestart <- base::invokeRestart
[10:33:13.172]             length <- base::length
[10:33:13.172]             list <- base::list
[10:33:13.172]             seq.int <- base::seq.int
[10:33:13.172]             signalCondition <- base::signalCondition
[10:33:13.172]             sys.calls <- base::sys.calls
[10:33:13.172]             `[[` <- base::`[[`
[10:33:13.172]             `+` <- base::`+`
[10:33:13.172]             `<<-` <- base::`<<-`
[10:33:13.172]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:13.172]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:13.172]                   3L)]
[10:33:13.172]             }
[10:33:13.172]             function(cond) {
[10:33:13.172]                 is_error <- inherits(cond, "error")
[10:33:13.172]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:13.172]                   NULL)
[10:33:13.172]                 if (is_error) {
[10:33:13.172]                   sessionInformation <- function() {
[10:33:13.172]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:13.172]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:13.172]                       search = base::search(), system = base::Sys.info())
[10:33:13.172]                   }
[10:33:13.172]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.172]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:13.172]                     cond$call), session = sessionInformation(), 
[10:33:13.172]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:13.172]                   signalCondition(cond)
[10:33:13.172]                 }
[10:33:13.172]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:13.172]                 "immediateCondition"))) {
[10:33:13.172]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:13.172]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.172]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:13.172]                   if (TRUE && !signal) {
[10:33:13.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.172]                     {
[10:33:13.172]                       inherits <- base::inherits
[10:33:13.172]                       invokeRestart <- base::invokeRestart
[10:33:13.172]                       is.null <- base::is.null
[10:33:13.172]                       muffled <- FALSE
[10:33:13.172]                       if (inherits(cond, "message")) {
[10:33:13.172]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.172]                         if (muffled) 
[10:33:13.172]                           invokeRestart("muffleMessage")
[10:33:13.172]                       }
[10:33:13.172]                       else if (inherits(cond, "warning")) {
[10:33:13.172]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.172]                         if (muffled) 
[10:33:13.172]                           invokeRestart("muffleWarning")
[10:33:13.172]                       }
[10:33:13.172]                       else if (inherits(cond, "condition")) {
[10:33:13.172]                         if (!is.null(pattern)) {
[10:33:13.172]                           computeRestarts <- base::computeRestarts
[10:33:13.172]                           grepl <- base::grepl
[10:33:13.172]                           restarts <- computeRestarts(cond)
[10:33:13.172]                           for (restart in restarts) {
[10:33:13.172]                             name <- restart$name
[10:33:13.172]                             if (is.null(name)) 
[10:33:13.172]                               next
[10:33:13.172]                             if (!grepl(pattern, name)) 
[10:33:13.172]                               next
[10:33:13.172]                             invokeRestart(restart)
[10:33:13.172]                             muffled <- TRUE
[10:33:13.172]                             break
[10:33:13.172]                           }
[10:33:13.172]                         }
[10:33:13.172]                       }
[10:33:13.172]                       invisible(muffled)
[10:33:13.172]                     }
[10:33:13.172]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.172]                   }
[10:33:13.172]                 }
[10:33:13.172]                 else {
[10:33:13.172]                   if (TRUE) {
[10:33:13.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.172]                     {
[10:33:13.172]                       inherits <- base::inherits
[10:33:13.172]                       invokeRestart <- base::invokeRestart
[10:33:13.172]                       is.null <- base::is.null
[10:33:13.172]                       muffled <- FALSE
[10:33:13.172]                       if (inherits(cond, "message")) {
[10:33:13.172]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.172]                         if (muffled) 
[10:33:13.172]                           invokeRestart("muffleMessage")
[10:33:13.172]                       }
[10:33:13.172]                       else if (inherits(cond, "warning")) {
[10:33:13.172]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.172]                         if (muffled) 
[10:33:13.172]                           invokeRestart("muffleWarning")
[10:33:13.172]                       }
[10:33:13.172]                       else if (inherits(cond, "condition")) {
[10:33:13.172]                         if (!is.null(pattern)) {
[10:33:13.172]                           computeRestarts <- base::computeRestarts
[10:33:13.172]                           grepl <- base::grepl
[10:33:13.172]                           restarts <- computeRestarts(cond)
[10:33:13.172]                           for (restart in restarts) {
[10:33:13.172]                             name <- restart$name
[10:33:13.172]                             if (is.null(name)) 
[10:33:13.172]                               next
[10:33:13.172]                             if (!grepl(pattern, name)) 
[10:33:13.172]                               next
[10:33:13.172]                             invokeRestart(restart)
[10:33:13.172]                             muffled <- TRUE
[10:33:13.172]                             break
[10:33:13.172]                           }
[10:33:13.172]                         }
[10:33:13.172]                       }
[10:33:13.172]                       invisible(muffled)
[10:33:13.172]                     }
[10:33:13.172]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.172]                   }
[10:33:13.172]                 }
[10:33:13.172]             }
[10:33:13.172]         }))
[10:33:13.172]     }, error = function(ex) {
[10:33:13.172]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:13.172]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.172]                 ...future.rng), started = ...future.startTime, 
[10:33:13.172]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:13.172]             version = "1.8"), class = "FutureResult")
[10:33:13.172]     }, finally = {
[10:33:13.172]         if (!identical(...future.workdir, getwd())) 
[10:33:13.172]             setwd(...future.workdir)
[10:33:13.172]         {
[10:33:13.172]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:13.172]                 ...future.oldOptions$nwarnings <- NULL
[10:33:13.172]             }
[10:33:13.172]             base::options(...future.oldOptions)
[10:33:13.172]             if (.Platform$OS.type == "windows") {
[10:33:13.172]                 old_names <- names(...future.oldEnvVars)
[10:33:13.172]                 envs <- base::Sys.getenv()
[10:33:13.172]                 names <- names(envs)
[10:33:13.172]                 common <- intersect(names, old_names)
[10:33:13.172]                 added <- setdiff(names, old_names)
[10:33:13.172]                 removed <- setdiff(old_names, names)
[10:33:13.172]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:13.172]                   envs[common]]
[10:33:13.172]                 NAMES <- toupper(changed)
[10:33:13.172]                 args <- list()
[10:33:13.172]                 for (kk in seq_along(NAMES)) {
[10:33:13.172]                   name <- changed[[kk]]
[10:33:13.172]                   NAME <- NAMES[[kk]]
[10:33:13.172]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.172]                     next
[10:33:13.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.172]                 }
[10:33:13.172]                 NAMES <- toupper(added)
[10:33:13.172]                 for (kk in seq_along(NAMES)) {
[10:33:13.172]                   name <- added[[kk]]
[10:33:13.172]                   NAME <- NAMES[[kk]]
[10:33:13.172]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.172]                     next
[10:33:13.172]                   args[[name]] <- ""
[10:33:13.172]                 }
[10:33:13.172]                 NAMES <- toupper(removed)
[10:33:13.172]                 for (kk in seq_along(NAMES)) {
[10:33:13.172]                   name <- removed[[kk]]
[10:33:13.172]                   NAME <- NAMES[[kk]]
[10:33:13.172]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.172]                     next
[10:33:13.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.172]                 }
[10:33:13.172]                 if (length(args) > 0) 
[10:33:13.172]                   base::do.call(base::Sys.setenv, args = args)
[10:33:13.172]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:13.172]             }
[10:33:13.172]             else {
[10:33:13.172]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:13.172]             }
[10:33:13.172]             {
[10:33:13.172]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:13.172]                   0L) {
[10:33:13.172]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:13.172]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:13.172]                   base::options(opts)
[10:33:13.172]                 }
[10:33:13.172]                 {
[10:33:13.172]                   {
[10:33:13.172]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:13.172]                     NULL
[10:33:13.172]                   }
[10:33:13.172]                   options(future.plan = NULL)
[10:33:13.172]                   if (is.na(NA_character_)) 
[10:33:13.172]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.172]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:13.172]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:13.172]                     .init = FALSE)
[10:33:13.172]                 }
[10:33:13.172]             }
[10:33:13.172]         }
[10:33:13.172]     })
[10:33:13.172]     if (TRUE) {
[10:33:13.172]         base::sink(type = "output", split = FALSE)
[10:33:13.172]         if (TRUE) {
[10:33:13.172]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:13.172]         }
[10:33:13.172]         else {
[10:33:13.172]             ...future.result["stdout"] <- base::list(NULL)
[10:33:13.172]         }
[10:33:13.172]         base::close(...future.stdout)
[10:33:13.172]         ...future.stdout <- NULL
[10:33:13.172]     }
[10:33:13.172]     ...future.result$conditions <- ...future.conditions
[10:33:13.172]     ...future.result$finished <- base::Sys.time()
[10:33:13.172]     ...future.result
[10:33:13.172] }
[10:33:13.174] assign_globals() ...
[10:33:13.175] List of 1
[10:33:13.175]  $ a: num 3
[10:33:13.175]  - attr(*, "where")=List of 1
[10:33:13.175]   ..$ a:<environment: R_EmptyEnv> 
[10:33:13.175]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:13.175]  - attr(*, "resolved")= logi TRUE
[10:33:13.175]  - attr(*, "total_size")= num 56
[10:33:13.175]  - attr(*, "already-done")= logi TRUE
[10:33:13.178] - copied ‘a’ to environment
[10:33:13.178] assign_globals() ... done
[10:33:13.178] requestCore(): workers = 2
[10:33:13.180] MulticoreFuture started
[10:33:13.180] - Launch lazy future ... done
[10:33:13.180] run() for ‘MulticoreFuture’ ... done
[10:33:13.180] result() for MulticoreFuture ...
[10:33:13.181] plan(): Setting new future strategy stack:
[10:33:13.181] List of future strategies:
[10:33:13.181] 1. sequential:
[10:33:13.181]    - args: function (..., envir = parent.frame())
[10:33:13.181]    - tweaked: FALSE
[10:33:13.181]    - call: NULL
[10:33:13.182] plan(): nbrOfWorkers() = 1
[10:33:13.184] plan(): Setting new future strategy stack:
[10:33:13.184] List of future strategies:
[10:33:13.184] 1. multicore:
[10:33:13.184]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.184]    - tweaked: FALSE
[10:33:13.184]    - call: plan(strategy)
[10:33:13.190] plan(): nbrOfWorkers() = 2
[10:33:13.190] result() for MulticoreFuture ...
[10:33:13.191] result() for MulticoreFuture ... done
[10:33:13.191] result() for MulticoreFuture ... done
[10:33:13.191] result() for MulticoreFuture ...
[10:33:13.191] result() for MulticoreFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.193] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.193] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:13.195] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:13.195] Searching for globals ... DONE
[10:33:13.196] Resolving globals: TRUE
[10:33:13.196] Resolving any globals that are futures ...
[10:33:13.196] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:13.196] Resolving any globals that are futures ... DONE
[10:33:13.196] Resolving futures part of globals (recursively) ...
[10:33:13.197] resolve() on list ...
[10:33:13.197]  recursive: 99
[10:33:13.197]  length: 2
[10:33:13.197]  elements: ‘a’, ‘ii’
[10:33:13.197]  length: 1 (resolved future 1)
[10:33:13.197]  length: 0 (resolved future 2)
[10:33:13.198] resolve() on list ... DONE
[10:33:13.198] - globals: [2] ‘a’, ‘ii’
[10:33:13.198] Resolving futures part of globals (recursively) ... DONE
[10:33:13.198] The total size of the 2 globals is 112 bytes (112 bytes)
[10:33:13.199] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:33:13.199] - globals: [2] ‘a’, ‘ii’
[10:33:13.199] 
[10:33:13.199] getGlobalsAndPackages() ... DONE
[10:33:13.199] run() for ‘Future’ ...
[10:33:13.199] - state: ‘created’
[10:33:13.199] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:13.203] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:13.204] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:13.204]   - Field: ‘label’
[10:33:13.204]   - Field: ‘local’
[10:33:13.204]   - Field: ‘owner’
[10:33:13.204]   - Field: ‘envir’
[10:33:13.204]   - Field: ‘workers’
[10:33:13.204]   - Field: ‘packages’
[10:33:13.204]   - Field: ‘gc’
[10:33:13.204]   - Field: ‘job’
[10:33:13.205]   - Field: ‘conditions’
[10:33:13.205]   - Field: ‘expr’
[10:33:13.205]   - Field: ‘uuid’
[10:33:13.205]   - Field: ‘seed’
[10:33:13.205]   - Field: ‘version’
[10:33:13.205]   - Field: ‘result’
[10:33:13.205]   - Field: ‘asynchronous’
[10:33:13.205]   - Field: ‘calls’
[10:33:13.206]   - Field: ‘globals’
[10:33:13.206]   - Field: ‘stdout’
[10:33:13.208]   - Field: ‘earlySignal’
[10:33:13.208]   - Field: ‘lazy’
[10:33:13.208]   - Field: ‘state’
[10:33:13.208] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:13.209] - Launch lazy future ...
[10:33:13.209] Packages needed by the future expression (n = 0): <none>
[10:33:13.209] Packages needed by future strategies (n = 0): <none>
[10:33:13.210] {
[10:33:13.210]     {
[10:33:13.210]         {
[10:33:13.210]             ...future.startTime <- base::Sys.time()
[10:33:13.210]             {
[10:33:13.210]                 {
[10:33:13.210]                   {
[10:33:13.210]                     {
[10:33:13.210]                       base::local({
[10:33:13.210]                         has_future <- base::requireNamespace("future", 
[10:33:13.210]                           quietly = TRUE)
[10:33:13.210]                         if (has_future) {
[10:33:13.210]                           ns <- base::getNamespace("future")
[10:33:13.210]                           version <- ns[[".package"]][["version"]]
[10:33:13.210]                           if (is.null(version)) 
[10:33:13.210]                             version <- utils::packageVersion("future")
[10:33:13.210]                         }
[10:33:13.210]                         else {
[10:33:13.210]                           version <- NULL
[10:33:13.210]                         }
[10:33:13.210]                         if (!has_future || version < "1.8.0") {
[10:33:13.210]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:13.210]                             "", base::R.version$version.string), 
[10:33:13.210]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:13.210]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:13.210]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:13.210]                               "release", "version")], collapse = " "), 
[10:33:13.210]                             hostname = base::Sys.info()[["nodename"]])
[10:33:13.210]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:13.210]                             info)
[10:33:13.210]                           info <- base::paste(info, collapse = "; ")
[10:33:13.210]                           if (!has_future) {
[10:33:13.210]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:13.210]                               info)
[10:33:13.210]                           }
[10:33:13.210]                           else {
[10:33:13.210]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:13.210]                               info, version)
[10:33:13.210]                           }
[10:33:13.210]                           base::stop(msg)
[10:33:13.210]                         }
[10:33:13.210]                       })
[10:33:13.210]                     }
[10:33:13.210]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:13.210]                     base::options(mc.cores = 1L)
[10:33:13.210]                   }
[10:33:13.210]                   ...future.strategy.old <- future::plan("list")
[10:33:13.210]                   options(future.plan = NULL)
[10:33:13.210]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.210]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:13.210]                 }
[10:33:13.210]                 ...future.workdir <- getwd()
[10:33:13.210]             }
[10:33:13.210]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:13.210]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:13.210]         }
[10:33:13.210]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:13.210]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:13.210]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:13.210]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:13.210]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:13.210]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:13.210]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:13.210]             base::names(...future.oldOptions))
[10:33:13.210]     }
[10:33:13.210]     if (FALSE) {
[10:33:13.210]     }
[10:33:13.210]     else {
[10:33:13.210]         if (TRUE) {
[10:33:13.210]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:13.210]                 open = "w")
[10:33:13.210]         }
[10:33:13.210]         else {
[10:33:13.210]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:13.210]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:13.210]         }
[10:33:13.210]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:13.210]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:13.210]             base::sink(type = "output", split = FALSE)
[10:33:13.210]             base::close(...future.stdout)
[10:33:13.210]         }, add = TRUE)
[10:33:13.210]     }
[10:33:13.210]     ...future.frame <- base::sys.nframe()
[10:33:13.210]     ...future.conditions <- base::list()
[10:33:13.210]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:13.210]     if (FALSE) {
[10:33:13.210]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:13.210]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:13.210]     }
[10:33:13.210]     ...future.result <- base::tryCatch({
[10:33:13.210]         base::withCallingHandlers({
[10:33:13.210]             ...future.value <- base::withVisible(base::local({
[10:33:13.210]                 withCallingHandlers({
[10:33:13.210]                   {
[10:33:13.210]                     b <- a * ii
[10:33:13.210]                     a <- 0
[10:33:13.210]                     b
[10:33:13.210]                   }
[10:33:13.210]                 }, immediateCondition = function(cond) {
[10:33:13.210]                   save_rds <- function (object, pathname, ...) 
[10:33:13.210]                   {
[10:33:13.210]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:13.210]                     if (file_test("-f", pathname_tmp)) {
[10:33:13.210]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.210]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:13.210]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.210]                         fi_tmp[["mtime"]])
[10:33:13.210]                     }
[10:33:13.210]                     tryCatch({
[10:33:13.210]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:13.210]                     }, error = function(ex) {
[10:33:13.210]                       msg <- conditionMessage(ex)
[10:33:13.210]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.210]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:13.210]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.210]                         fi_tmp[["mtime"]], msg)
[10:33:13.210]                       ex$message <- msg
[10:33:13.210]                       stop(ex)
[10:33:13.210]                     })
[10:33:13.210]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:13.210]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:13.210]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:13.210]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.210]                       fi <- file.info(pathname)
[10:33:13.210]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:13.210]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.210]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:13.210]                         fi[["size"]], fi[["mtime"]])
[10:33:13.210]                       stop(msg)
[10:33:13.210]                     }
[10:33:13.210]                     invisible(pathname)
[10:33:13.210]                   }
[10:33:13.210]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:13.210]                     rootPath = tempdir()) 
[10:33:13.210]                   {
[10:33:13.210]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:13.210]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:13.210]                       tmpdir = path, fileext = ".rds")
[10:33:13.210]                     save_rds(obj, file)
[10:33:13.210]                   }
[10:33:13.210]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:13.210]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.210]                   {
[10:33:13.210]                     inherits <- base::inherits
[10:33:13.210]                     invokeRestart <- base::invokeRestart
[10:33:13.210]                     is.null <- base::is.null
[10:33:13.210]                     muffled <- FALSE
[10:33:13.210]                     if (inherits(cond, "message")) {
[10:33:13.210]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:13.210]                       if (muffled) 
[10:33:13.210]                         invokeRestart("muffleMessage")
[10:33:13.210]                     }
[10:33:13.210]                     else if (inherits(cond, "warning")) {
[10:33:13.210]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:13.210]                       if (muffled) 
[10:33:13.210]                         invokeRestart("muffleWarning")
[10:33:13.210]                     }
[10:33:13.210]                     else if (inherits(cond, "condition")) {
[10:33:13.210]                       if (!is.null(pattern)) {
[10:33:13.210]                         computeRestarts <- base::computeRestarts
[10:33:13.210]                         grepl <- base::grepl
[10:33:13.210]                         restarts <- computeRestarts(cond)
[10:33:13.210]                         for (restart in restarts) {
[10:33:13.210]                           name <- restart$name
[10:33:13.210]                           if (is.null(name)) 
[10:33:13.210]                             next
[10:33:13.210]                           if (!grepl(pattern, name)) 
[10:33:13.210]                             next
[10:33:13.210]                           invokeRestart(restart)
[10:33:13.210]                           muffled <- TRUE
[10:33:13.210]                           break
[10:33:13.210]                         }
[10:33:13.210]                       }
[10:33:13.210]                     }
[10:33:13.210]                     invisible(muffled)
[10:33:13.210]                   }
[10:33:13.210]                   muffleCondition(cond)
[10:33:13.210]                 })
[10:33:13.210]             }))
[10:33:13.210]             future::FutureResult(value = ...future.value$value, 
[10:33:13.210]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.210]                   ...future.rng), globalenv = if (FALSE) 
[10:33:13.210]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:13.210]                     ...future.globalenv.names))
[10:33:13.210]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:13.210]         }, condition = base::local({
[10:33:13.210]             c <- base::c
[10:33:13.210]             inherits <- base::inherits
[10:33:13.210]             invokeRestart <- base::invokeRestart
[10:33:13.210]             length <- base::length
[10:33:13.210]             list <- base::list
[10:33:13.210]             seq.int <- base::seq.int
[10:33:13.210]             signalCondition <- base::signalCondition
[10:33:13.210]             sys.calls <- base::sys.calls
[10:33:13.210]             `[[` <- base::`[[`
[10:33:13.210]             `+` <- base::`+`
[10:33:13.210]             `<<-` <- base::`<<-`
[10:33:13.210]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:13.210]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:13.210]                   3L)]
[10:33:13.210]             }
[10:33:13.210]             function(cond) {
[10:33:13.210]                 is_error <- inherits(cond, "error")
[10:33:13.210]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:13.210]                   NULL)
[10:33:13.210]                 if (is_error) {
[10:33:13.210]                   sessionInformation <- function() {
[10:33:13.210]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:13.210]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:13.210]                       search = base::search(), system = base::Sys.info())
[10:33:13.210]                   }
[10:33:13.210]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.210]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:13.210]                     cond$call), session = sessionInformation(), 
[10:33:13.210]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:13.210]                   signalCondition(cond)
[10:33:13.210]                 }
[10:33:13.210]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:13.210]                 "immediateCondition"))) {
[10:33:13.210]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:13.210]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.210]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:13.210]                   if (TRUE && !signal) {
[10:33:13.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.210]                     {
[10:33:13.210]                       inherits <- base::inherits
[10:33:13.210]                       invokeRestart <- base::invokeRestart
[10:33:13.210]                       is.null <- base::is.null
[10:33:13.210]                       muffled <- FALSE
[10:33:13.210]                       if (inherits(cond, "message")) {
[10:33:13.210]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.210]                         if (muffled) 
[10:33:13.210]                           invokeRestart("muffleMessage")
[10:33:13.210]                       }
[10:33:13.210]                       else if (inherits(cond, "warning")) {
[10:33:13.210]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.210]                         if (muffled) 
[10:33:13.210]                           invokeRestart("muffleWarning")
[10:33:13.210]                       }
[10:33:13.210]                       else if (inherits(cond, "condition")) {
[10:33:13.210]                         if (!is.null(pattern)) {
[10:33:13.210]                           computeRestarts <- base::computeRestarts
[10:33:13.210]                           grepl <- base::grepl
[10:33:13.210]                           restarts <- computeRestarts(cond)
[10:33:13.210]                           for (restart in restarts) {
[10:33:13.210]                             name <- restart$name
[10:33:13.210]                             if (is.null(name)) 
[10:33:13.210]                               next
[10:33:13.210]                             if (!grepl(pattern, name)) 
[10:33:13.210]                               next
[10:33:13.210]                             invokeRestart(restart)
[10:33:13.210]                             muffled <- TRUE
[10:33:13.210]                             break
[10:33:13.210]                           }
[10:33:13.210]                         }
[10:33:13.210]                       }
[10:33:13.210]                       invisible(muffled)
[10:33:13.210]                     }
[10:33:13.210]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.210]                   }
[10:33:13.210]                 }
[10:33:13.210]                 else {
[10:33:13.210]                   if (TRUE) {
[10:33:13.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.210]                     {
[10:33:13.210]                       inherits <- base::inherits
[10:33:13.210]                       invokeRestart <- base::invokeRestart
[10:33:13.210]                       is.null <- base::is.null
[10:33:13.210]                       muffled <- FALSE
[10:33:13.210]                       if (inherits(cond, "message")) {
[10:33:13.210]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.210]                         if (muffled) 
[10:33:13.210]                           invokeRestart("muffleMessage")
[10:33:13.210]                       }
[10:33:13.210]                       else if (inherits(cond, "warning")) {
[10:33:13.210]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.210]                         if (muffled) 
[10:33:13.210]                           invokeRestart("muffleWarning")
[10:33:13.210]                       }
[10:33:13.210]                       else if (inherits(cond, "condition")) {
[10:33:13.210]                         if (!is.null(pattern)) {
[10:33:13.210]                           computeRestarts <- base::computeRestarts
[10:33:13.210]                           grepl <- base::grepl
[10:33:13.210]                           restarts <- computeRestarts(cond)
[10:33:13.210]                           for (restart in restarts) {
[10:33:13.210]                             name <- restart$name
[10:33:13.210]                             if (is.null(name)) 
[10:33:13.210]                               next
[10:33:13.210]                             if (!grepl(pattern, name)) 
[10:33:13.210]                               next
[10:33:13.210]                             invokeRestart(restart)
[10:33:13.210]                             muffled <- TRUE
[10:33:13.210]                             break
[10:33:13.210]                           }
[10:33:13.210]                         }
[10:33:13.210]                       }
[10:33:13.210]                       invisible(muffled)
[10:33:13.210]                     }
[10:33:13.210]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.210]                   }
[10:33:13.210]                 }
[10:33:13.210]             }
[10:33:13.210]         }))
[10:33:13.210]     }, error = function(ex) {
[10:33:13.210]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:13.210]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.210]                 ...future.rng), started = ...future.startTime, 
[10:33:13.210]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:13.210]             version = "1.8"), class = "FutureResult")
[10:33:13.210]     }, finally = {
[10:33:13.210]         if (!identical(...future.workdir, getwd())) 
[10:33:13.210]             setwd(...future.workdir)
[10:33:13.210]         {
[10:33:13.210]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:13.210]                 ...future.oldOptions$nwarnings <- NULL
[10:33:13.210]             }
[10:33:13.210]             base::options(...future.oldOptions)
[10:33:13.210]             if (.Platform$OS.type == "windows") {
[10:33:13.210]                 old_names <- names(...future.oldEnvVars)
[10:33:13.210]                 envs <- base::Sys.getenv()
[10:33:13.210]                 names <- names(envs)
[10:33:13.210]                 common <- intersect(names, old_names)
[10:33:13.210]                 added <- setdiff(names, old_names)
[10:33:13.210]                 removed <- setdiff(old_names, names)
[10:33:13.210]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:13.210]                   envs[common]]
[10:33:13.210]                 NAMES <- toupper(changed)
[10:33:13.210]                 args <- list()
[10:33:13.210]                 for (kk in seq_along(NAMES)) {
[10:33:13.210]                   name <- changed[[kk]]
[10:33:13.210]                   NAME <- NAMES[[kk]]
[10:33:13.210]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.210]                     next
[10:33:13.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.210]                 }
[10:33:13.210]                 NAMES <- toupper(added)
[10:33:13.210]                 for (kk in seq_along(NAMES)) {
[10:33:13.210]                   name <- added[[kk]]
[10:33:13.210]                   NAME <- NAMES[[kk]]
[10:33:13.210]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.210]                     next
[10:33:13.210]                   args[[name]] <- ""
[10:33:13.210]                 }
[10:33:13.210]                 NAMES <- toupper(removed)
[10:33:13.210]                 for (kk in seq_along(NAMES)) {
[10:33:13.210]                   name <- removed[[kk]]
[10:33:13.210]                   NAME <- NAMES[[kk]]
[10:33:13.210]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.210]                     next
[10:33:13.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.210]                 }
[10:33:13.210]                 if (length(args) > 0) 
[10:33:13.210]                   base::do.call(base::Sys.setenv, args = args)
[10:33:13.210]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:13.210]             }
[10:33:13.210]             else {
[10:33:13.210]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:13.210]             }
[10:33:13.210]             {
[10:33:13.210]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:13.210]                   0L) {
[10:33:13.210]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:13.210]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:13.210]                   base::options(opts)
[10:33:13.210]                 }
[10:33:13.210]                 {
[10:33:13.210]                   {
[10:33:13.210]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:13.210]                     NULL
[10:33:13.210]                   }
[10:33:13.210]                   options(future.plan = NULL)
[10:33:13.210]                   if (is.na(NA_character_)) 
[10:33:13.210]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.210]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:13.210]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:13.210]                     .init = FALSE)
[10:33:13.210]                 }
[10:33:13.210]             }
[10:33:13.210]         }
[10:33:13.210]     })
[10:33:13.210]     if (TRUE) {
[10:33:13.210]         base::sink(type = "output", split = FALSE)
[10:33:13.210]         if (TRUE) {
[10:33:13.210]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:13.210]         }
[10:33:13.210]         else {
[10:33:13.210]             ...future.result["stdout"] <- base::list(NULL)
[10:33:13.210]         }
[10:33:13.210]         base::close(...future.stdout)
[10:33:13.210]         ...future.stdout <- NULL
[10:33:13.210]     }
[10:33:13.210]     ...future.result$conditions <- ...future.conditions
[10:33:13.210]     ...future.result$finished <- base::Sys.time()
[10:33:13.210]     ...future.result
[10:33:13.210] }
[10:33:13.212] assign_globals() ...
[10:33:13.212] List of 2
[10:33:13.212]  $ a : num 1
[10:33:13.212]  $ ii: int 1
[10:33:13.212]  - attr(*, "where")=List of 2
[10:33:13.212]   ..$ a :<environment: R_EmptyEnv> 
[10:33:13.212]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:13.212]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:13.212]  - attr(*, "resolved")= logi TRUE
[10:33:13.212]  - attr(*, "total_size")= num 112
[10:33:13.212]  - attr(*, "already-done")= logi TRUE
[10:33:13.216] - copied ‘a’ to environment
[10:33:13.216] - copied ‘ii’ to environment
[10:33:13.216] assign_globals() ... done
[10:33:13.217] requestCore(): workers = 2
[10:33:13.218] MulticoreFuture started
[10:33:13.219] - Launch lazy future ... done
[10:33:13.219] run() for ‘MulticoreFuture’ ... done
[10:33:13.220] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.220] List of future strategies:
[10:33:13.220] 1. sequential:
[10:33:13.220]    - args: function (..., envir = parent.frame())
[10:33:13.220]    - tweaked: FALSE
[10:33:13.220]    - call: NULL
[10:33:13.221] getGlobalsAndPackages() ...
[10:33:13.221] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.221] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:13.223] plan(): Setting new future strategy stack:
[10:33:13.223] List of future strategies:
[10:33:13.223] 1. multicore:
[10:33:13.223]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.223]    - tweaked: FALSE
[10:33:13.223]    - call: plan(strategy)
[10:33:13.226] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:13.226] Searching for globals ... DONE
[10:33:13.226] Resolving globals: TRUE
[10:33:13.226] Resolving any globals that are futures ...
[10:33:13.226] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:13.226] Resolving any globals that are futures ... DONE
[10:33:13.227] Resolving futures part of globals (recursively) ...
[10:33:13.228] resolve() on list ...
[10:33:13.228]  recursive: 99
[10:33:13.228]  length: 2
[10:33:13.228]  elements: ‘a’, ‘ii’
[10:33:13.228] plan(): nbrOfWorkers() = 2
[10:33:13.228]  length: 1 (resolved future 1)
[10:33:13.228]  length: 0 (resolved future 2)
[10:33:13.228] resolve() on list ... DONE
[10:33:13.229] - globals: [2] ‘a’, ‘ii’
[10:33:13.229] Resolving futures part of globals (recursively) ... DONE
[10:33:13.229] The total size of the 2 globals is 112 bytes (112 bytes)
[10:33:13.230] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:33:13.230] - globals: [2] ‘a’, ‘ii’
[10:33:13.230] 
[10:33:13.230] getGlobalsAndPackages() ... DONE
[10:33:13.231] run() for ‘Future’ ...
[10:33:13.231] - state: ‘created’
[10:33:13.231] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:13.235] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:13.236] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:13.236]   - Field: ‘label’
[10:33:13.236]   - Field: ‘local’
[10:33:13.236]   - Field: ‘owner’
[10:33:13.236]   - Field: ‘envir’
[10:33:13.236]   - Field: ‘workers’
[10:33:13.236]   - Field: ‘packages’
[10:33:13.237]   - Field: ‘gc’
[10:33:13.237]   - Field: ‘job’
[10:33:13.237]   - Field: ‘conditions’
[10:33:13.237]   - Field: ‘expr’
[10:33:13.237]   - Field: ‘uuid’
[10:33:13.237]   - Field: ‘seed’
[10:33:13.237]   - Field: ‘version’
[10:33:13.238]   - Field: ‘result’
[10:33:13.238]   - Field: ‘asynchronous’
[10:33:13.238]   - Field: ‘calls’
[10:33:13.238]   - Field: ‘globals’
[10:33:13.238]   - Field: ‘stdout’
[10:33:13.238]   - Field: ‘earlySignal’
[10:33:13.238]   - Field: ‘lazy’
[10:33:13.239]   - Field: ‘state’
[10:33:13.239] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:13.239] - Launch lazy future ...
[10:33:13.239] Packages needed by the future expression (n = 0): <none>
[10:33:13.239] Packages needed by future strategies (n = 0): <none>
[10:33:13.240] {
[10:33:13.240]     {
[10:33:13.240]         {
[10:33:13.240]             ...future.startTime <- base::Sys.time()
[10:33:13.240]             {
[10:33:13.240]                 {
[10:33:13.240]                   {
[10:33:13.240]                     {
[10:33:13.240]                       base::local({
[10:33:13.240]                         has_future <- base::requireNamespace("future", 
[10:33:13.240]                           quietly = TRUE)
[10:33:13.240]                         if (has_future) {
[10:33:13.240]                           ns <- base::getNamespace("future")
[10:33:13.240]                           version <- ns[[".package"]][["version"]]
[10:33:13.240]                           if (is.null(version)) 
[10:33:13.240]                             version <- utils::packageVersion("future")
[10:33:13.240]                         }
[10:33:13.240]                         else {
[10:33:13.240]                           version <- NULL
[10:33:13.240]                         }
[10:33:13.240]                         if (!has_future || version < "1.8.0") {
[10:33:13.240]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:13.240]                             "", base::R.version$version.string), 
[10:33:13.240]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:13.240]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:13.240]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:13.240]                               "release", "version")], collapse = " "), 
[10:33:13.240]                             hostname = base::Sys.info()[["nodename"]])
[10:33:13.240]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:13.240]                             info)
[10:33:13.240]                           info <- base::paste(info, collapse = "; ")
[10:33:13.240]                           if (!has_future) {
[10:33:13.240]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:13.240]                               info)
[10:33:13.240]                           }
[10:33:13.240]                           else {
[10:33:13.240]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:13.240]                               info, version)
[10:33:13.240]                           }
[10:33:13.240]                           base::stop(msg)
[10:33:13.240]                         }
[10:33:13.240]                       })
[10:33:13.240]                     }
[10:33:13.240]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:13.240]                     base::options(mc.cores = 1L)
[10:33:13.240]                   }
[10:33:13.240]                   ...future.strategy.old <- future::plan("list")
[10:33:13.240]                   options(future.plan = NULL)
[10:33:13.240]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.240]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:13.240]                 }
[10:33:13.240]                 ...future.workdir <- getwd()
[10:33:13.240]             }
[10:33:13.240]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:13.240]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:13.240]         }
[10:33:13.240]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:13.240]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:13.240]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:13.240]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:13.240]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:13.240]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:13.240]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:13.240]             base::names(...future.oldOptions))
[10:33:13.240]     }
[10:33:13.240]     if (FALSE) {
[10:33:13.240]     }
[10:33:13.240]     else {
[10:33:13.240]         if (TRUE) {
[10:33:13.240]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:13.240]                 open = "w")
[10:33:13.240]         }
[10:33:13.240]         else {
[10:33:13.240]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:13.240]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:13.240]         }
[10:33:13.240]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:13.240]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:13.240]             base::sink(type = "output", split = FALSE)
[10:33:13.240]             base::close(...future.stdout)
[10:33:13.240]         }, add = TRUE)
[10:33:13.240]     }
[10:33:13.240]     ...future.frame <- base::sys.nframe()
[10:33:13.240]     ...future.conditions <- base::list()
[10:33:13.240]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:13.240]     if (FALSE) {
[10:33:13.240]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:13.240]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:13.240]     }
[10:33:13.240]     ...future.result <- base::tryCatch({
[10:33:13.240]         base::withCallingHandlers({
[10:33:13.240]             ...future.value <- base::withVisible(base::local({
[10:33:13.240]                 withCallingHandlers({
[10:33:13.240]                   {
[10:33:13.240]                     b <- a * ii
[10:33:13.240]                     a <- 0
[10:33:13.240]                     b
[10:33:13.240]                   }
[10:33:13.240]                 }, immediateCondition = function(cond) {
[10:33:13.240]                   save_rds <- function (object, pathname, ...) 
[10:33:13.240]                   {
[10:33:13.240]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:13.240]                     if (file_test("-f", pathname_tmp)) {
[10:33:13.240]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.240]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:13.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.240]                         fi_tmp[["mtime"]])
[10:33:13.240]                     }
[10:33:13.240]                     tryCatch({
[10:33:13.240]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:13.240]                     }, error = function(ex) {
[10:33:13.240]                       msg <- conditionMessage(ex)
[10:33:13.240]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.240]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:13.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.240]                         fi_tmp[["mtime"]], msg)
[10:33:13.240]                       ex$message <- msg
[10:33:13.240]                       stop(ex)
[10:33:13.240]                     })
[10:33:13.240]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:13.240]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:13.240]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:13.240]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.240]                       fi <- file.info(pathname)
[10:33:13.240]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:13.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.240]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:13.240]                         fi[["size"]], fi[["mtime"]])
[10:33:13.240]                       stop(msg)
[10:33:13.240]                     }
[10:33:13.240]                     invisible(pathname)
[10:33:13.240]                   }
[10:33:13.240]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:13.240]                     rootPath = tempdir()) 
[10:33:13.240]                   {
[10:33:13.240]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:13.240]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:13.240]                       tmpdir = path, fileext = ".rds")
[10:33:13.240]                     save_rds(obj, file)
[10:33:13.240]                   }
[10:33:13.240]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:13.240]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.240]                   {
[10:33:13.240]                     inherits <- base::inherits
[10:33:13.240]                     invokeRestart <- base::invokeRestart
[10:33:13.240]                     is.null <- base::is.null
[10:33:13.240]                     muffled <- FALSE
[10:33:13.240]                     if (inherits(cond, "message")) {
[10:33:13.240]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:13.240]                       if (muffled) 
[10:33:13.240]                         invokeRestart("muffleMessage")
[10:33:13.240]                     }
[10:33:13.240]                     else if (inherits(cond, "warning")) {
[10:33:13.240]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:13.240]                       if (muffled) 
[10:33:13.240]                         invokeRestart("muffleWarning")
[10:33:13.240]                     }
[10:33:13.240]                     else if (inherits(cond, "condition")) {
[10:33:13.240]                       if (!is.null(pattern)) {
[10:33:13.240]                         computeRestarts <- base::computeRestarts
[10:33:13.240]                         grepl <- base::grepl
[10:33:13.240]                         restarts <- computeRestarts(cond)
[10:33:13.240]                         for (restart in restarts) {
[10:33:13.240]                           name <- restart$name
[10:33:13.240]                           if (is.null(name)) 
[10:33:13.240]                             next
[10:33:13.240]                           if (!grepl(pattern, name)) 
[10:33:13.240]                             next
[10:33:13.240]                           invokeRestart(restart)
[10:33:13.240]                           muffled <- TRUE
[10:33:13.240]                           break
[10:33:13.240]                         }
[10:33:13.240]                       }
[10:33:13.240]                     }
[10:33:13.240]                     invisible(muffled)
[10:33:13.240]                   }
[10:33:13.240]                   muffleCondition(cond)
[10:33:13.240]                 })
[10:33:13.240]             }))
[10:33:13.240]             future::FutureResult(value = ...future.value$value, 
[10:33:13.240]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.240]                   ...future.rng), globalenv = if (FALSE) 
[10:33:13.240]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:13.240]                     ...future.globalenv.names))
[10:33:13.240]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:13.240]         }, condition = base::local({
[10:33:13.240]             c <- base::c
[10:33:13.240]             inherits <- base::inherits
[10:33:13.240]             invokeRestart <- base::invokeRestart
[10:33:13.240]             length <- base::length
[10:33:13.240]             list <- base::list
[10:33:13.240]             seq.int <- base::seq.int
[10:33:13.240]             signalCondition <- base::signalCondition
[10:33:13.240]             sys.calls <- base::sys.calls
[10:33:13.240]             `[[` <- base::`[[`
[10:33:13.240]             `+` <- base::`+`
[10:33:13.240]             `<<-` <- base::`<<-`
[10:33:13.240]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:13.240]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:13.240]                   3L)]
[10:33:13.240]             }
[10:33:13.240]             function(cond) {
[10:33:13.240]                 is_error <- inherits(cond, "error")
[10:33:13.240]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:13.240]                   NULL)
[10:33:13.240]                 if (is_error) {
[10:33:13.240]                   sessionInformation <- function() {
[10:33:13.240]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:13.240]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:13.240]                       search = base::search(), system = base::Sys.info())
[10:33:13.240]                   }
[10:33:13.240]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.240]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:13.240]                     cond$call), session = sessionInformation(), 
[10:33:13.240]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:13.240]                   signalCondition(cond)
[10:33:13.240]                 }
[10:33:13.240]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:13.240]                 "immediateCondition"))) {
[10:33:13.240]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:13.240]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.240]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:13.240]                   if (TRUE && !signal) {
[10:33:13.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.240]                     {
[10:33:13.240]                       inherits <- base::inherits
[10:33:13.240]                       invokeRestart <- base::invokeRestart
[10:33:13.240]                       is.null <- base::is.null
[10:33:13.240]                       muffled <- FALSE
[10:33:13.240]                       if (inherits(cond, "message")) {
[10:33:13.240]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.240]                         if (muffled) 
[10:33:13.240]                           invokeRestart("muffleMessage")
[10:33:13.240]                       }
[10:33:13.240]                       else if (inherits(cond, "warning")) {
[10:33:13.240]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.240]                         if (muffled) 
[10:33:13.240]                           invokeRestart("muffleWarning")
[10:33:13.240]                       }
[10:33:13.240]                       else if (inherits(cond, "condition")) {
[10:33:13.240]                         if (!is.null(pattern)) {
[10:33:13.240]                           computeRestarts <- base::computeRestarts
[10:33:13.240]                           grepl <- base::grepl
[10:33:13.240]                           restarts <- computeRestarts(cond)
[10:33:13.240]                           for (restart in restarts) {
[10:33:13.240]                             name <- restart$name
[10:33:13.240]                             if (is.null(name)) 
[10:33:13.240]                               next
[10:33:13.240]                             if (!grepl(pattern, name)) 
[10:33:13.240]                               next
[10:33:13.240]                             invokeRestart(restart)
[10:33:13.240]                             muffled <- TRUE
[10:33:13.240]                             break
[10:33:13.240]                           }
[10:33:13.240]                         }
[10:33:13.240]                       }
[10:33:13.240]                       invisible(muffled)
[10:33:13.240]                     }
[10:33:13.240]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.240]                   }
[10:33:13.240]                 }
[10:33:13.240]                 else {
[10:33:13.240]                   if (TRUE) {
[10:33:13.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.240]                     {
[10:33:13.240]                       inherits <- base::inherits
[10:33:13.240]                       invokeRestart <- base::invokeRestart
[10:33:13.240]                       is.null <- base::is.null
[10:33:13.240]                       muffled <- FALSE
[10:33:13.240]                       if (inherits(cond, "message")) {
[10:33:13.240]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.240]                         if (muffled) 
[10:33:13.240]                           invokeRestart("muffleMessage")
[10:33:13.240]                       }
[10:33:13.240]                       else if (inherits(cond, "warning")) {
[10:33:13.240]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.240]                         if (muffled) 
[10:33:13.240]                           invokeRestart("muffleWarning")
[10:33:13.240]                       }
[10:33:13.240]                       else if (inherits(cond, "condition")) {
[10:33:13.240]                         if (!is.null(pattern)) {
[10:33:13.240]                           computeRestarts <- base::computeRestarts
[10:33:13.240]                           grepl <- base::grepl
[10:33:13.240]                           restarts <- computeRestarts(cond)
[10:33:13.240]                           for (restart in restarts) {
[10:33:13.240]                             name <- restart$name
[10:33:13.240]                             if (is.null(name)) 
[10:33:13.240]                               next
[10:33:13.240]                             if (!grepl(pattern, name)) 
[10:33:13.240]                               next
[10:33:13.240]                             invokeRestart(restart)
[10:33:13.240]                             muffled <- TRUE
[10:33:13.240]                             break
[10:33:13.240]                           }
[10:33:13.240]                         }
[10:33:13.240]                       }
[10:33:13.240]                       invisible(muffled)
[10:33:13.240]                     }
[10:33:13.240]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.240]                   }
[10:33:13.240]                 }
[10:33:13.240]             }
[10:33:13.240]         }))
[10:33:13.240]     }, error = function(ex) {
[10:33:13.240]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:13.240]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.240]                 ...future.rng), started = ...future.startTime, 
[10:33:13.240]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:13.240]             version = "1.8"), class = "FutureResult")
[10:33:13.240]     }, finally = {
[10:33:13.240]         if (!identical(...future.workdir, getwd())) 
[10:33:13.240]             setwd(...future.workdir)
[10:33:13.240]         {
[10:33:13.240]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:13.240]                 ...future.oldOptions$nwarnings <- NULL
[10:33:13.240]             }
[10:33:13.240]             base::options(...future.oldOptions)
[10:33:13.240]             if (.Platform$OS.type == "windows") {
[10:33:13.240]                 old_names <- names(...future.oldEnvVars)
[10:33:13.240]                 envs <- base::Sys.getenv()
[10:33:13.240]                 names <- names(envs)
[10:33:13.240]                 common <- intersect(names, old_names)
[10:33:13.240]                 added <- setdiff(names, old_names)
[10:33:13.240]                 removed <- setdiff(old_names, names)
[10:33:13.240]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:13.240]                   envs[common]]
[10:33:13.240]                 NAMES <- toupper(changed)
[10:33:13.240]                 args <- list()
[10:33:13.240]                 for (kk in seq_along(NAMES)) {
[10:33:13.240]                   name <- changed[[kk]]
[10:33:13.240]                   NAME <- NAMES[[kk]]
[10:33:13.240]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.240]                     next
[10:33:13.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.240]                 }
[10:33:13.240]                 NAMES <- toupper(added)
[10:33:13.240]                 for (kk in seq_along(NAMES)) {
[10:33:13.240]                   name <- added[[kk]]
[10:33:13.240]                   NAME <- NAMES[[kk]]
[10:33:13.240]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.240]                     next
[10:33:13.240]                   args[[name]] <- ""
[10:33:13.240]                 }
[10:33:13.240]                 NAMES <- toupper(removed)
[10:33:13.240]                 for (kk in seq_along(NAMES)) {
[10:33:13.240]                   name <- removed[[kk]]
[10:33:13.240]                   NAME <- NAMES[[kk]]
[10:33:13.240]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.240]                     next
[10:33:13.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.240]                 }
[10:33:13.240]                 if (length(args) > 0) 
[10:33:13.240]                   base::do.call(base::Sys.setenv, args = args)
[10:33:13.240]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:13.240]             }
[10:33:13.240]             else {
[10:33:13.240]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:13.240]             }
[10:33:13.240]             {
[10:33:13.240]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:13.240]                   0L) {
[10:33:13.240]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:13.240]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:13.240]                   base::options(opts)
[10:33:13.240]                 }
[10:33:13.240]                 {
[10:33:13.240]                   {
[10:33:13.240]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:13.240]                     NULL
[10:33:13.240]                   }
[10:33:13.240]                   options(future.plan = NULL)
[10:33:13.240]                   if (is.na(NA_character_)) 
[10:33:13.240]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.240]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:13.240]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:13.240]                     .init = FALSE)
[10:33:13.240]                 }
[10:33:13.240]             }
[10:33:13.240]         }
[10:33:13.240]     })
[10:33:13.240]     if (TRUE) {
[10:33:13.240]         base::sink(type = "output", split = FALSE)
[10:33:13.240]         if (TRUE) {
[10:33:13.240]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:13.240]         }
[10:33:13.240]         else {
[10:33:13.240]             ...future.result["stdout"] <- base::list(NULL)
[10:33:13.240]         }
[10:33:13.240]         base::close(...future.stdout)
[10:33:13.240]         ...future.stdout <- NULL
[10:33:13.240]     }
[10:33:13.240]     ...future.result$conditions <- ...future.conditions
[10:33:13.240]     ...future.result$finished <- base::Sys.time()
[10:33:13.240]     ...future.result
[10:33:13.240] }
[10:33:13.243] assign_globals() ...
[10:33:13.243] List of 2
[10:33:13.243]  $ a : num 1
[10:33:13.243]  $ ii: int 2
[10:33:13.243]  - attr(*, "where")=List of 2
[10:33:13.243]   ..$ a :<environment: R_EmptyEnv> 
[10:33:13.243]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:13.243]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:13.243]  - attr(*, "resolved")= logi TRUE
[10:33:13.243]  - attr(*, "total_size")= num 112
[10:33:13.243]  - attr(*, "already-done")= logi TRUE
[10:33:13.252] - copied ‘a’ to environment
[10:33:13.252] - copied ‘ii’ to environment
[10:33:13.252] assign_globals() ... done
[10:33:13.252] requestCore(): workers = 2
[10:33:13.255] MulticoreFuture started
[10:33:13.255] - Launch lazy future ... done
[10:33:13.256] run() for ‘MulticoreFuture’ ... done
[10:33:13.256] plan(): Setting new future strategy stack:
[10:33:13.256] List of future strategies:
[10:33:13.256] 1. sequential:
[10:33:13.256]    - args: function (..., envir = parent.frame())
[10:33:13.256]    - tweaked: FALSE
[10:33:13.256]    - call: NULL
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.258] plan(): nbrOfWorkers() = 1
[10:33:13.258] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.258] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:13.260] plan(): Setting new future strategy stack:
[10:33:13.260] List of future strategies:
[10:33:13.260] 1. multicore:
[10:33:13.260]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.260]    - tweaked: FALSE
[10:33:13.260]    - call: plan(strategy)
[10:33:13.265] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:13.266] Searching for globals ... DONE
[10:33:13.266] Resolving globals: TRUE
[10:33:13.266] Resolving any globals that are futures ...
[10:33:13.267] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:13.267] Resolving any globals that are futures ... DONE
[10:33:13.267] plan(): nbrOfWorkers() = 2
[10:33:13.268] Resolving futures part of globals (recursively) ...
[10:33:13.268] resolve() on list ...
[10:33:13.268]  recursive: 99
[10:33:13.269]  length: 2
[10:33:13.269]  elements: ‘a’, ‘ii’
[10:33:13.269]  length: 1 (resolved future 1)
[10:33:13.270]  length: 0 (resolved future 2)
[10:33:13.270] resolve() on list ... DONE
[10:33:13.270] - globals: [2] ‘a’, ‘ii’
[10:33:13.270] Resolving futures part of globals (recursively) ... DONE
[10:33:13.270] The total size of the 2 globals is 112 bytes (112 bytes)
[10:33:13.271] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:33:13.271] - globals: [2] ‘a’, ‘ii’
[10:33:13.271] 
[10:33:13.272] getGlobalsAndPackages() ... DONE
[10:33:13.272] run() for ‘Future’ ...
[10:33:13.272] - state: ‘created’
[10:33:13.272] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:13.277] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:13.277] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:13.277]   - Field: ‘label’
[10:33:13.277]   - Field: ‘local’
[10:33:13.277]   - Field: ‘owner’
[10:33:13.277]   - Field: ‘envir’
[10:33:13.277]   - Field: ‘workers’
[10:33:13.278]   - Field: ‘packages’
[10:33:13.278]   - Field: ‘gc’
[10:33:13.278]   - Field: ‘job’
[10:33:13.278]   - Field: ‘conditions’
[10:33:13.278]   - Field: ‘expr’
[10:33:13.278]   - Field: ‘uuid’
[10:33:13.278]   - Field: ‘seed’
[10:33:13.279]   - Field: ‘version’
[10:33:13.279]   - Field: ‘result’
[10:33:13.279]   - Field: ‘asynchronous’
[10:33:13.279]   - Field: ‘calls’
[10:33:13.279]   - Field: ‘globals’
[10:33:13.279]   - Field: ‘stdout’
[10:33:13.279]   - Field: ‘earlySignal’
[10:33:13.279]   - Field: ‘lazy’
[10:33:13.280]   - Field: ‘state’
[10:33:13.280] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:13.280] - Launch lazy future ...
[10:33:13.280] Packages needed by the future expression (n = 0): <none>
[10:33:13.280] Packages needed by future strategies (n = 0): <none>
[10:33:13.281] {
[10:33:13.281]     {
[10:33:13.281]         {
[10:33:13.281]             ...future.startTime <- base::Sys.time()
[10:33:13.281]             {
[10:33:13.281]                 {
[10:33:13.281]                   {
[10:33:13.281]                     {
[10:33:13.281]                       base::local({
[10:33:13.281]                         has_future <- base::requireNamespace("future", 
[10:33:13.281]                           quietly = TRUE)
[10:33:13.281]                         if (has_future) {
[10:33:13.281]                           ns <- base::getNamespace("future")
[10:33:13.281]                           version <- ns[[".package"]][["version"]]
[10:33:13.281]                           if (is.null(version)) 
[10:33:13.281]                             version <- utils::packageVersion("future")
[10:33:13.281]                         }
[10:33:13.281]                         else {
[10:33:13.281]                           version <- NULL
[10:33:13.281]                         }
[10:33:13.281]                         if (!has_future || version < "1.8.0") {
[10:33:13.281]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:13.281]                             "", base::R.version$version.string), 
[10:33:13.281]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:13.281]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:13.281]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:13.281]                               "release", "version")], collapse = " "), 
[10:33:13.281]                             hostname = base::Sys.info()[["nodename"]])
[10:33:13.281]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:13.281]                             info)
[10:33:13.281]                           info <- base::paste(info, collapse = "; ")
[10:33:13.281]                           if (!has_future) {
[10:33:13.281]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:13.281]                               info)
[10:33:13.281]                           }
[10:33:13.281]                           else {
[10:33:13.281]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:13.281]                               info, version)
[10:33:13.281]                           }
[10:33:13.281]                           base::stop(msg)
[10:33:13.281]                         }
[10:33:13.281]                       })
[10:33:13.281]                     }
[10:33:13.281]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:13.281]                     base::options(mc.cores = 1L)
[10:33:13.281]                   }
[10:33:13.281]                   ...future.strategy.old <- future::plan("list")
[10:33:13.281]                   options(future.plan = NULL)
[10:33:13.281]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.281]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:13.281]                 }
[10:33:13.281]                 ...future.workdir <- getwd()
[10:33:13.281]             }
[10:33:13.281]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:13.281]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:13.281]         }
[10:33:13.281]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:13.281]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:13.281]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:13.281]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:13.281]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:13.281]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:13.281]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:13.281]             base::names(...future.oldOptions))
[10:33:13.281]     }
[10:33:13.281]     if (FALSE) {
[10:33:13.281]     }
[10:33:13.281]     else {
[10:33:13.281]         if (TRUE) {
[10:33:13.281]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:13.281]                 open = "w")
[10:33:13.281]         }
[10:33:13.281]         else {
[10:33:13.281]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:13.281]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:13.281]         }
[10:33:13.281]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:13.281]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:13.281]             base::sink(type = "output", split = FALSE)
[10:33:13.281]             base::close(...future.stdout)
[10:33:13.281]         }, add = TRUE)
[10:33:13.281]     }
[10:33:13.281]     ...future.frame <- base::sys.nframe()
[10:33:13.281]     ...future.conditions <- base::list()
[10:33:13.281]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:13.281]     if (FALSE) {
[10:33:13.281]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:13.281]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:13.281]     }
[10:33:13.281]     ...future.result <- base::tryCatch({
[10:33:13.281]         base::withCallingHandlers({
[10:33:13.281]             ...future.value <- base::withVisible(base::local({
[10:33:13.281]                 withCallingHandlers({
[10:33:13.281]                   {
[10:33:13.281]                     b <- a * ii
[10:33:13.281]                     a <- 0
[10:33:13.281]                     b
[10:33:13.281]                   }
[10:33:13.281]                 }, immediateCondition = function(cond) {
[10:33:13.281]                   save_rds <- function (object, pathname, ...) 
[10:33:13.281]                   {
[10:33:13.281]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:13.281]                     if (file_test("-f", pathname_tmp)) {
[10:33:13.281]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.281]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:13.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.281]                         fi_tmp[["mtime"]])
[10:33:13.281]                     }
[10:33:13.281]                     tryCatch({
[10:33:13.281]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:13.281]                     }, error = function(ex) {
[10:33:13.281]                       msg <- conditionMessage(ex)
[10:33:13.281]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.281]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:13.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.281]                         fi_tmp[["mtime"]], msg)
[10:33:13.281]                       ex$message <- msg
[10:33:13.281]                       stop(ex)
[10:33:13.281]                     })
[10:33:13.281]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:13.281]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:13.281]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:13.281]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.281]                       fi <- file.info(pathname)
[10:33:13.281]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:13.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.281]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:13.281]                         fi[["size"]], fi[["mtime"]])
[10:33:13.281]                       stop(msg)
[10:33:13.281]                     }
[10:33:13.281]                     invisible(pathname)
[10:33:13.281]                   }
[10:33:13.281]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:13.281]                     rootPath = tempdir()) 
[10:33:13.281]                   {
[10:33:13.281]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:13.281]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:13.281]                       tmpdir = path, fileext = ".rds")
[10:33:13.281]                     save_rds(obj, file)
[10:33:13.281]                   }
[10:33:13.281]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:13.281]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.281]                   {
[10:33:13.281]                     inherits <- base::inherits
[10:33:13.281]                     invokeRestart <- base::invokeRestart
[10:33:13.281]                     is.null <- base::is.null
[10:33:13.281]                     muffled <- FALSE
[10:33:13.281]                     if (inherits(cond, "message")) {
[10:33:13.281]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:13.281]                       if (muffled) 
[10:33:13.281]                         invokeRestart("muffleMessage")
[10:33:13.281]                     }
[10:33:13.281]                     else if (inherits(cond, "warning")) {
[10:33:13.281]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:13.281]                       if (muffled) 
[10:33:13.281]                         invokeRestart("muffleWarning")
[10:33:13.281]                     }
[10:33:13.281]                     else if (inherits(cond, "condition")) {
[10:33:13.281]                       if (!is.null(pattern)) {
[10:33:13.281]                         computeRestarts <- base::computeRestarts
[10:33:13.281]                         grepl <- base::grepl
[10:33:13.281]                         restarts <- computeRestarts(cond)
[10:33:13.281]                         for (restart in restarts) {
[10:33:13.281]                           name <- restart$name
[10:33:13.281]                           if (is.null(name)) 
[10:33:13.281]                             next
[10:33:13.281]                           if (!grepl(pattern, name)) 
[10:33:13.281]                             next
[10:33:13.281]                           invokeRestart(restart)
[10:33:13.281]                           muffled <- TRUE
[10:33:13.281]                           break
[10:33:13.281]                         }
[10:33:13.281]                       }
[10:33:13.281]                     }
[10:33:13.281]                     invisible(muffled)
[10:33:13.281]                   }
[10:33:13.281]                   muffleCondition(cond)
[10:33:13.281]                 })
[10:33:13.281]             }))
[10:33:13.281]             future::FutureResult(value = ...future.value$value, 
[10:33:13.281]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.281]                   ...future.rng), globalenv = if (FALSE) 
[10:33:13.281]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:13.281]                     ...future.globalenv.names))
[10:33:13.281]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:13.281]         }, condition = base::local({
[10:33:13.281]             c <- base::c
[10:33:13.281]             inherits <- base::inherits
[10:33:13.281]             invokeRestart <- base::invokeRestart
[10:33:13.281]             length <- base::length
[10:33:13.281]             list <- base::list
[10:33:13.281]             seq.int <- base::seq.int
[10:33:13.281]             signalCondition <- base::signalCondition
[10:33:13.281]             sys.calls <- base::sys.calls
[10:33:13.281]             `[[` <- base::`[[`
[10:33:13.281]             `+` <- base::`+`
[10:33:13.281]             `<<-` <- base::`<<-`
[10:33:13.281]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:13.281]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:13.281]                   3L)]
[10:33:13.281]             }
[10:33:13.281]             function(cond) {
[10:33:13.281]                 is_error <- inherits(cond, "error")
[10:33:13.281]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:13.281]                   NULL)
[10:33:13.281]                 if (is_error) {
[10:33:13.281]                   sessionInformation <- function() {
[10:33:13.281]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:13.281]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:13.281]                       search = base::search(), system = base::Sys.info())
[10:33:13.281]                   }
[10:33:13.281]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.281]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:13.281]                     cond$call), session = sessionInformation(), 
[10:33:13.281]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:13.281]                   signalCondition(cond)
[10:33:13.281]                 }
[10:33:13.281]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:13.281]                 "immediateCondition"))) {
[10:33:13.281]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:13.281]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.281]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:13.281]                   if (TRUE && !signal) {
[10:33:13.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.281]                     {
[10:33:13.281]                       inherits <- base::inherits
[10:33:13.281]                       invokeRestart <- base::invokeRestart
[10:33:13.281]                       is.null <- base::is.null
[10:33:13.281]                       muffled <- FALSE
[10:33:13.281]                       if (inherits(cond, "message")) {
[10:33:13.281]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.281]                         if (muffled) 
[10:33:13.281]                           invokeRestart("muffleMessage")
[10:33:13.281]                       }
[10:33:13.281]                       else if (inherits(cond, "warning")) {
[10:33:13.281]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.281]                         if (muffled) 
[10:33:13.281]                           invokeRestart("muffleWarning")
[10:33:13.281]                       }
[10:33:13.281]                       else if (inherits(cond, "condition")) {
[10:33:13.281]                         if (!is.null(pattern)) {
[10:33:13.281]                           computeRestarts <- base::computeRestarts
[10:33:13.281]                           grepl <- base::grepl
[10:33:13.281]                           restarts <- computeRestarts(cond)
[10:33:13.281]                           for (restart in restarts) {
[10:33:13.281]                             name <- restart$name
[10:33:13.281]                             if (is.null(name)) 
[10:33:13.281]                               next
[10:33:13.281]                             if (!grepl(pattern, name)) 
[10:33:13.281]                               next
[10:33:13.281]                             invokeRestart(restart)
[10:33:13.281]                             muffled <- TRUE
[10:33:13.281]                             break
[10:33:13.281]                           }
[10:33:13.281]                         }
[10:33:13.281]                       }
[10:33:13.281]                       invisible(muffled)
[10:33:13.281]                     }
[10:33:13.281]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.281]                   }
[10:33:13.281]                 }
[10:33:13.281]                 else {
[10:33:13.281]                   if (TRUE) {
[10:33:13.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.281]                     {
[10:33:13.281]                       inherits <- base::inherits
[10:33:13.281]                       invokeRestart <- base::invokeRestart
[10:33:13.281]                       is.null <- base::is.null
[10:33:13.281]                       muffled <- FALSE
[10:33:13.281]                       if (inherits(cond, "message")) {
[10:33:13.281]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.281]                         if (muffled) 
[10:33:13.281]                           invokeRestart("muffleMessage")
[10:33:13.281]                       }
[10:33:13.281]                       else if (inherits(cond, "warning")) {
[10:33:13.281]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.281]                         if (muffled) 
[10:33:13.281]                           invokeRestart("muffleWarning")
[10:33:13.281]                       }
[10:33:13.281]                       else if (inherits(cond, "condition")) {
[10:33:13.281]                         if (!is.null(pattern)) {
[10:33:13.281]                           computeRestarts <- base::computeRestarts
[10:33:13.281]                           grepl <- base::grepl
[10:33:13.281]                           restarts <- computeRestarts(cond)
[10:33:13.281]                           for (restart in restarts) {
[10:33:13.281]                             name <- restart$name
[10:33:13.281]                             if (is.null(name)) 
[10:33:13.281]                               next
[10:33:13.281]                             if (!grepl(pattern, name)) 
[10:33:13.281]                               next
[10:33:13.281]                             invokeRestart(restart)
[10:33:13.281]                             muffled <- TRUE
[10:33:13.281]                             break
[10:33:13.281]                           }
[10:33:13.281]                         }
[10:33:13.281]                       }
[10:33:13.281]                       invisible(muffled)
[10:33:13.281]                     }
[10:33:13.281]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.281]                   }
[10:33:13.281]                 }
[10:33:13.281]             }
[10:33:13.281]         }))
[10:33:13.281]     }, error = function(ex) {
[10:33:13.281]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:13.281]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.281]                 ...future.rng), started = ...future.startTime, 
[10:33:13.281]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:13.281]             version = "1.8"), class = "FutureResult")
[10:33:13.281]     }, finally = {
[10:33:13.281]         if (!identical(...future.workdir, getwd())) 
[10:33:13.281]             setwd(...future.workdir)
[10:33:13.281]         {
[10:33:13.281]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:13.281]                 ...future.oldOptions$nwarnings <- NULL
[10:33:13.281]             }
[10:33:13.281]             base::options(...future.oldOptions)
[10:33:13.281]             if (.Platform$OS.type == "windows") {
[10:33:13.281]                 old_names <- names(...future.oldEnvVars)
[10:33:13.281]                 envs <- base::Sys.getenv()
[10:33:13.281]                 names <- names(envs)
[10:33:13.281]                 common <- intersect(names, old_names)
[10:33:13.281]                 added <- setdiff(names, old_names)
[10:33:13.281]                 removed <- setdiff(old_names, names)
[10:33:13.281]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:13.281]                   envs[common]]
[10:33:13.281]                 NAMES <- toupper(changed)
[10:33:13.281]                 args <- list()
[10:33:13.281]                 for (kk in seq_along(NAMES)) {
[10:33:13.281]                   name <- changed[[kk]]
[10:33:13.281]                   NAME <- NAMES[[kk]]
[10:33:13.281]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.281]                     next
[10:33:13.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.281]                 }
[10:33:13.281]                 NAMES <- toupper(added)
[10:33:13.281]                 for (kk in seq_along(NAMES)) {
[10:33:13.281]                   name <- added[[kk]]
[10:33:13.281]                   NAME <- NAMES[[kk]]
[10:33:13.281]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.281]                     next
[10:33:13.281]                   args[[name]] <- ""
[10:33:13.281]                 }
[10:33:13.281]                 NAMES <- toupper(removed)
[10:33:13.281]                 for (kk in seq_along(NAMES)) {
[10:33:13.281]                   name <- removed[[kk]]
[10:33:13.281]                   NAME <- NAMES[[kk]]
[10:33:13.281]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.281]                     next
[10:33:13.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.281]                 }
[10:33:13.281]                 if (length(args) > 0) 
[10:33:13.281]                   base::do.call(base::Sys.setenv, args = args)
[10:33:13.281]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:13.281]             }
[10:33:13.281]             else {
[10:33:13.281]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:13.281]             }
[10:33:13.281]             {
[10:33:13.281]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:13.281]                   0L) {
[10:33:13.281]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:13.281]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:13.281]                   base::options(opts)
[10:33:13.281]                 }
[10:33:13.281]                 {
[10:33:13.281]                   {
[10:33:13.281]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:13.281]                     NULL
[10:33:13.281]                   }
[10:33:13.281]                   options(future.plan = NULL)
[10:33:13.281]                   if (is.na(NA_character_)) 
[10:33:13.281]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.281]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:13.281]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:13.281]                     .init = FALSE)
[10:33:13.281]                 }
[10:33:13.281]             }
[10:33:13.281]         }
[10:33:13.281]     })
[10:33:13.281]     if (TRUE) {
[10:33:13.281]         base::sink(type = "output", split = FALSE)
[10:33:13.281]         if (TRUE) {
[10:33:13.281]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:13.281]         }
[10:33:13.281]         else {
[10:33:13.281]             ...future.result["stdout"] <- base::list(NULL)
[10:33:13.281]         }
[10:33:13.281]         base::close(...future.stdout)
[10:33:13.281]         ...future.stdout <- NULL
[10:33:13.281]     }
[10:33:13.281]     ...future.result$conditions <- ...future.conditions
[10:33:13.281]     ...future.result$finished <- base::Sys.time()
[10:33:13.281]     ...future.result
[10:33:13.281] }
[10:33:13.284] assign_globals() ...
[10:33:13.284] List of 2
[10:33:13.284]  $ a : num 1
[10:33:13.284]  $ ii: int 3
[10:33:13.284]  - attr(*, "where")=List of 2
[10:33:13.284]   ..$ a :<environment: R_EmptyEnv> 
[10:33:13.284]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:13.284]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:13.284]  - attr(*, "resolved")= logi TRUE
[10:33:13.284]  - attr(*, "total_size")= num 112
[10:33:13.284]  - attr(*, "already-done")= logi TRUE
[10:33:13.288] - copied ‘a’ to environment
[10:33:13.288] - copied ‘ii’ to environment
[10:33:13.288] assign_globals() ... done
[10:33:13.289] requestCore(): workers = 2
[10:33:13.289] Poll #1 (0): usedCores() = 2, workers = 2
[10:33:13.312] result() for MulticoreFuture ...
[10:33:13.312] result() for MulticoreFuture ...
[10:33:13.313] result() for MulticoreFuture ... done
[10:33:13.313] result() for MulticoreFuture ... done
[10:33:13.313] result() for MulticoreFuture ...
[10:33:13.313] result() for MulticoreFuture ... done
[10:33:13.315] MulticoreFuture started
[10:33:13.316] - Launch lazy future ... done
[10:33:13.316] run() for ‘MulticoreFuture’ ... done
[10:33:13.317] plan(): Setting new future strategy stack:
[10:33:13.317] result() for MulticoreFuture ...
[10:33:13.317] result() for MulticoreFuture ... done
[10:33:13.317] result() for MulticoreFuture ...
[10:33:13.317] result() for MulticoreFuture ... done
[10:33:13.317] List of future strategies:
[10:33:13.317] 1. sequential:
[10:33:13.317]    - args: function (..., envir = parent.frame())
[10:33:13.317]    - tweaked: FALSE
[10:33:13.317]    - call: NULL
[10:33:13.318] result() for MulticoreFuture ...
[10:33:13.318] plan(): nbrOfWorkers() = 1
[10:33:13.319] result() for MulticoreFuture ...
[10:33:13.319] result() for MulticoreFuture ... done
[10:33:13.319] result() for MulticoreFuture ... done
[10:33:13.319] result() for MulticoreFuture ...
[10:33:13.320] result() for MulticoreFuture ... done
[10:33:13.320] plan(): Setting new future strategy stack:
[10:33:13.320] result() for MulticoreFuture ...
[10:33:13.320] List of future strategies:
[10:33:13.320] 1. multicore:
[10:33:13.320]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.320]    - tweaked: FALSE
[10:33:13.320]    - call: plan(strategy)
[10:33:13.325] plan(): nbrOfWorkers() = 2
[10:33:13.326] result() for MulticoreFuture ...
[10:33:13.326] result() for MulticoreFuture ... done
[10:33:13.326] result() for MulticoreFuture ... done
[10:33:13.327] result() for MulticoreFuture ...
[10:33:13.327] result() for MulticoreFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.328] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.329] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:13.331] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:13.331] Searching for globals ... DONE
[10:33:13.331] Resolving globals: TRUE
[10:33:13.332] Resolving any globals that are futures ...
[10:33:13.332] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:13.332] Resolving any globals that are futures ... DONE
[10:33:13.332] Resolving futures part of globals (recursively) ...
[10:33:13.333] resolve() on list ...
[10:33:13.333]  recursive: 99
[10:33:13.333]  length: 2
[10:33:13.333]  elements: ‘a’, ‘ii’
[10:33:13.333]  length: 1 (resolved future 1)
[10:33:13.333]  length: 0 (resolved future 2)
[10:33:13.333] resolve() on list ... DONE
[10:33:13.334] - globals: [2] ‘a’, ‘ii’
[10:33:13.334] Resolving futures part of globals (recursively) ... DONE
[10:33:13.334] The total size of the 2 globals is 112 bytes (112 bytes)
[10:33:13.334] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:33:13.335] - globals: [2] ‘a’, ‘ii’
[10:33:13.335] 
[10:33:13.335] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.336] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.336] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:13.341] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:13.341] Searching for globals ... DONE
[10:33:13.341] Resolving globals: TRUE
[10:33:13.341] Resolving any globals that are futures ...
[10:33:13.341] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:13.342] Resolving any globals that are futures ... DONE
[10:33:13.342] Resolving futures part of globals (recursively) ...
[10:33:13.342] resolve() on list ...
[10:33:13.343]  recursive: 99
[10:33:13.343]  length: 2
[10:33:13.343]  elements: ‘a’, ‘ii’
[10:33:13.343]  length: 1 (resolved future 1)
[10:33:13.343]  length: 0 (resolved future 2)
[10:33:13.343] resolve() on list ... DONE
[10:33:13.343] - globals: [2] ‘a’, ‘ii’
[10:33:13.344] Resolving futures part of globals (recursively) ... DONE
[10:33:13.344] The total size of the 2 globals is 112 bytes (112 bytes)
[10:33:13.344] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:33:13.344] - globals: [2] ‘a’, ‘ii’
[10:33:13.345] 
[10:33:13.345] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.346] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.346] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:13.348] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:13.348] Searching for globals ... DONE
[10:33:13.348] Resolving globals: TRUE
[10:33:13.348] Resolving any globals that are futures ...
[10:33:13.349] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:13.349] Resolving any globals that are futures ... DONE
[10:33:13.349] Resolving futures part of globals (recursively) ...
[10:33:13.349] resolve() on list ...
[10:33:13.350]  recursive: 99
[10:33:13.350]  length: 2
[10:33:13.350]  elements: ‘a’, ‘ii’
[10:33:13.350]  length: 1 (resolved future 1)
[10:33:13.350]  length: 0 (resolved future 2)
[10:33:13.350] resolve() on list ... DONE
[10:33:13.350] - globals: [2] ‘a’, ‘ii’
[10:33:13.350] Resolving futures part of globals (recursively) ... DONE
[10:33:13.350] The total size of the 2 globals is 112 bytes (112 bytes)
[10:33:13.351] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:33:13.351] - globals: [2] ‘a’, ‘ii’
[10:33:13.351] 
[10:33:13.351] getGlobalsAndPackages() ... DONE
[10:33:13.351] run() for ‘Future’ ...
[10:33:13.351] - state: ‘created’
[10:33:13.352] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:13.355] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:13.356] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:13.356]   - Field: ‘label’
[10:33:13.356]   - Field: ‘local’
[10:33:13.356]   - Field: ‘owner’
[10:33:13.356]   - Field: ‘envir’
[10:33:13.356]   - Field: ‘workers’
[10:33:13.356]   - Field: ‘packages’
[10:33:13.356]   - Field: ‘gc’
[10:33:13.356]   - Field: ‘job’
[10:33:13.356]   - Field: ‘conditions’
[10:33:13.357]   - Field: ‘expr’
[10:33:13.357]   - Field: ‘uuid’
[10:33:13.357]   - Field: ‘seed’
[10:33:13.357]   - Field: ‘version’
[10:33:13.357]   - Field: ‘result’
[10:33:13.357]   - Field: ‘asynchronous’
[10:33:13.357]   - Field: ‘calls’
[10:33:13.357]   - Field: ‘globals’
[10:33:13.357]   - Field: ‘stdout’
[10:33:13.357]   - Field: ‘earlySignal’
[10:33:13.357]   - Field: ‘lazy’
[10:33:13.358]   - Field: ‘state’
[10:33:13.358] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:13.358] - Launch lazy future ...
[10:33:13.358] Packages needed by the future expression (n = 0): <none>
[10:33:13.358] Packages needed by future strategies (n = 0): <none>
[10:33:13.359] {
[10:33:13.359]     {
[10:33:13.359]         {
[10:33:13.359]             ...future.startTime <- base::Sys.time()
[10:33:13.359]             {
[10:33:13.359]                 {
[10:33:13.359]                   {
[10:33:13.359]                     {
[10:33:13.359]                       base::local({
[10:33:13.359]                         has_future <- base::requireNamespace("future", 
[10:33:13.359]                           quietly = TRUE)
[10:33:13.359]                         if (has_future) {
[10:33:13.359]                           ns <- base::getNamespace("future")
[10:33:13.359]                           version <- ns[[".package"]][["version"]]
[10:33:13.359]                           if (is.null(version)) 
[10:33:13.359]                             version <- utils::packageVersion("future")
[10:33:13.359]                         }
[10:33:13.359]                         else {
[10:33:13.359]                           version <- NULL
[10:33:13.359]                         }
[10:33:13.359]                         if (!has_future || version < "1.8.0") {
[10:33:13.359]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:13.359]                             "", base::R.version$version.string), 
[10:33:13.359]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:13.359]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:13.359]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:13.359]                               "release", "version")], collapse = " "), 
[10:33:13.359]                             hostname = base::Sys.info()[["nodename"]])
[10:33:13.359]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:13.359]                             info)
[10:33:13.359]                           info <- base::paste(info, collapse = "; ")
[10:33:13.359]                           if (!has_future) {
[10:33:13.359]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:13.359]                               info)
[10:33:13.359]                           }
[10:33:13.359]                           else {
[10:33:13.359]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:13.359]                               info, version)
[10:33:13.359]                           }
[10:33:13.359]                           base::stop(msg)
[10:33:13.359]                         }
[10:33:13.359]                       })
[10:33:13.359]                     }
[10:33:13.359]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:13.359]                     base::options(mc.cores = 1L)
[10:33:13.359]                   }
[10:33:13.359]                   ...future.strategy.old <- future::plan("list")
[10:33:13.359]                   options(future.plan = NULL)
[10:33:13.359]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.359]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:13.359]                 }
[10:33:13.359]                 ...future.workdir <- getwd()
[10:33:13.359]             }
[10:33:13.359]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:13.359]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:13.359]         }
[10:33:13.359]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:13.359]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:13.359]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:13.359]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:13.359]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:13.359]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:13.359]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:13.359]             base::names(...future.oldOptions))
[10:33:13.359]     }
[10:33:13.359]     if (FALSE) {
[10:33:13.359]     }
[10:33:13.359]     else {
[10:33:13.359]         if (TRUE) {
[10:33:13.359]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:13.359]                 open = "w")
[10:33:13.359]         }
[10:33:13.359]         else {
[10:33:13.359]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:13.359]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:13.359]         }
[10:33:13.359]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:13.359]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:13.359]             base::sink(type = "output", split = FALSE)
[10:33:13.359]             base::close(...future.stdout)
[10:33:13.359]         }, add = TRUE)
[10:33:13.359]     }
[10:33:13.359]     ...future.frame <- base::sys.nframe()
[10:33:13.359]     ...future.conditions <- base::list()
[10:33:13.359]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:13.359]     if (FALSE) {
[10:33:13.359]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:13.359]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:13.359]     }
[10:33:13.359]     ...future.result <- base::tryCatch({
[10:33:13.359]         base::withCallingHandlers({
[10:33:13.359]             ...future.value <- base::withVisible(base::local({
[10:33:13.359]                 withCallingHandlers({
[10:33:13.359]                   {
[10:33:13.359]                     b <- a * ii
[10:33:13.359]                     a <- 0
[10:33:13.359]                     b
[10:33:13.359]                   }
[10:33:13.359]                 }, immediateCondition = function(cond) {
[10:33:13.359]                   save_rds <- function (object, pathname, ...) 
[10:33:13.359]                   {
[10:33:13.359]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:13.359]                     if (file_test("-f", pathname_tmp)) {
[10:33:13.359]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.359]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:13.359]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.359]                         fi_tmp[["mtime"]])
[10:33:13.359]                     }
[10:33:13.359]                     tryCatch({
[10:33:13.359]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:13.359]                     }, error = function(ex) {
[10:33:13.359]                       msg <- conditionMessage(ex)
[10:33:13.359]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.359]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:13.359]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.359]                         fi_tmp[["mtime"]], msg)
[10:33:13.359]                       ex$message <- msg
[10:33:13.359]                       stop(ex)
[10:33:13.359]                     })
[10:33:13.359]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:13.359]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:13.359]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:13.359]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.359]                       fi <- file.info(pathname)
[10:33:13.359]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:13.359]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.359]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:13.359]                         fi[["size"]], fi[["mtime"]])
[10:33:13.359]                       stop(msg)
[10:33:13.359]                     }
[10:33:13.359]                     invisible(pathname)
[10:33:13.359]                   }
[10:33:13.359]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:13.359]                     rootPath = tempdir()) 
[10:33:13.359]                   {
[10:33:13.359]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:13.359]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:13.359]                       tmpdir = path, fileext = ".rds")
[10:33:13.359]                     save_rds(obj, file)
[10:33:13.359]                   }
[10:33:13.359]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:13.359]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.359]                   {
[10:33:13.359]                     inherits <- base::inherits
[10:33:13.359]                     invokeRestart <- base::invokeRestart
[10:33:13.359]                     is.null <- base::is.null
[10:33:13.359]                     muffled <- FALSE
[10:33:13.359]                     if (inherits(cond, "message")) {
[10:33:13.359]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:13.359]                       if (muffled) 
[10:33:13.359]                         invokeRestart("muffleMessage")
[10:33:13.359]                     }
[10:33:13.359]                     else if (inherits(cond, "warning")) {
[10:33:13.359]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:13.359]                       if (muffled) 
[10:33:13.359]                         invokeRestart("muffleWarning")
[10:33:13.359]                     }
[10:33:13.359]                     else if (inherits(cond, "condition")) {
[10:33:13.359]                       if (!is.null(pattern)) {
[10:33:13.359]                         computeRestarts <- base::computeRestarts
[10:33:13.359]                         grepl <- base::grepl
[10:33:13.359]                         restarts <- computeRestarts(cond)
[10:33:13.359]                         for (restart in restarts) {
[10:33:13.359]                           name <- restart$name
[10:33:13.359]                           if (is.null(name)) 
[10:33:13.359]                             next
[10:33:13.359]                           if (!grepl(pattern, name)) 
[10:33:13.359]                             next
[10:33:13.359]                           invokeRestart(restart)
[10:33:13.359]                           muffled <- TRUE
[10:33:13.359]                           break
[10:33:13.359]                         }
[10:33:13.359]                       }
[10:33:13.359]                     }
[10:33:13.359]                     invisible(muffled)
[10:33:13.359]                   }
[10:33:13.359]                   muffleCondition(cond)
[10:33:13.359]                 })
[10:33:13.359]             }))
[10:33:13.359]             future::FutureResult(value = ...future.value$value, 
[10:33:13.359]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.359]                   ...future.rng), globalenv = if (FALSE) 
[10:33:13.359]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:13.359]                     ...future.globalenv.names))
[10:33:13.359]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:13.359]         }, condition = base::local({
[10:33:13.359]             c <- base::c
[10:33:13.359]             inherits <- base::inherits
[10:33:13.359]             invokeRestart <- base::invokeRestart
[10:33:13.359]             length <- base::length
[10:33:13.359]             list <- base::list
[10:33:13.359]             seq.int <- base::seq.int
[10:33:13.359]             signalCondition <- base::signalCondition
[10:33:13.359]             sys.calls <- base::sys.calls
[10:33:13.359]             `[[` <- base::`[[`
[10:33:13.359]             `+` <- base::`+`
[10:33:13.359]             `<<-` <- base::`<<-`
[10:33:13.359]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:13.359]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:13.359]                   3L)]
[10:33:13.359]             }
[10:33:13.359]             function(cond) {
[10:33:13.359]                 is_error <- inherits(cond, "error")
[10:33:13.359]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:13.359]                   NULL)
[10:33:13.359]                 if (is_error) {
[10:33:13.359]                   sessionInformation <- function() {
[10:33:13.359]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:13.359]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:13.359]                       search = base::search(), system = base::Sys.info())
[10:33:13.359]                   }
[10:33:13.359]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.359]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:13.359]                     cond$call), session = sessionInformation(), 
[10:33:13.359]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:13.359]                   signalCondition(cond)
[10:33:13.359]                 }
[10:33:13.359]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:13.359]                 "immediateCondition"))) {
[10:33:13.359]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:13.359]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.359]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:13.359]                   if (TRUE && !signal) {
[10:33:13.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.359]                     {
[10:33:13.359]                       inherits <- base::inherits
[10:33:13.359]                       invokeRestart <- base::invokeRestart
[10:33:13.359]                       is.null <- base::is.null
[10:33:13.359]                       muffled <- FALSE
[10:33:13.359]                       if (inherits(cond, "message")) {
[10:33:13.359]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.359]                         if (muffled) 
[10:33:13.359]                           invokeRestart("muffleMessage")
[10:33:13.359]                       }
[10:33:13.359]                       else if (inherits(cond, "warning")) {
[10:33:13.359]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.359]                         if (muffled) 
[10:33:13.359]                           invokeRestart("muffleWarning")
[10:33:13.359]                       }
[10:33:13.359]                       else if (inherits(cond, "condition")) {
[10:33:13.359]                         if (!is.null(pattern)) {
[10:33:13.359]                           computeRestarts <- base::computeRestarts
[10:33:13.359]                           grepl <- base::grepl
[10:33:13.359]                           restarts <- computeRestarts(cond)
[10:33:13.359]                           for (restart in restarts) {
[10:33:13.359]                             name <- restart$name
[10:33:13.359]                             if (is.null(name)) 
[10:33:13.359]                               next
[10:33:13.359]                             if (!grepl(pattern, name)) 
[10:33:13.359]                               next
[10:33:13.359]                             invokeRestart(restart)
[10:33:13.359]                             muffled <- TRUE
[10:33:13.359]                             break
[10:33:13.359]                           }
[10:33:13.359]                         }
[10:33:13.359]                       }
[10:33:13.359]                       invisible(muffled)
[10:33:13.359]                     }
[10:33:13.359]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.359]                   }
[10:33:13.359]                 }
[10:33:13.359]                 else {
[10:33:13.359]                   if (TRUE) {
[10:33:13.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.359]                     {
[10:33:13.359]                       inherits <- base::inherits
[10:33:13.359]                       invokeRestart <- base::invokeRestart
[10:33:13.359]                       is.null <- base::is.null
[10:33:13.359]                       muffled <- FALSE
[10:33:13.359]                       if (inherits(cond, "message")) {
[10:33:13.359]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.359]                         if (muffled) 
[10:33:13.359]                           invokeRestart("muffleMessage")
[10:33:13.359]                       }
[10:33:13.359]                       else if (inherits(cond, "warning")) {
[10:33:13.359]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.359]                         if (muffled) 
[10:33:13.359]                           invokeRestart("muffleWarning")
[10:33:13.359]                       }
[10:33:13.359]                       else if (inherits(cond, "condition")) {
[10:33:13.359]                         if (!is.null(pattern)) {
[10:33:13.359]                           computeRestarts <- base::computeRestarts
[10:33:13.359]                           grepl <- base::grepl
[10:33:13.359]                           restarts <- computeRestarts(cond)
[10:33:13.359]                           for (restart in restarts) {
[10:33:13.359]                             name <- restart$name
[10:33:13.359]                             if (is.null(name)) 
[10:33:13.359]                               next
[10:33:13.359]                             if (!grepl(pattern, name)) 
[10:33:13.359]                               next
[10:33:13.359]                             invokeRestart(restart)
[10:33:13.359]                             muffled <- TRUE
[10:33:13.359]                             break
[10:33:13.359]                           }
[10:33:13.359]                         }
[10:33:13.359]                       }
[10:33:13.359]                       invisible(muffled)
[10:33:13.359]                     }
[10:33:13.359]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.359]                   }
[10:33:13.359]                 }
[10:33:13.359]             }
[10:33:13.359]         }))
[10:33:13.359]     }, error = function(ex) {
[10:33:13.359]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:13.359]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.359]                 ...future.rng), started = ...future.startTime, 
[10:33:13.359]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:13.359]             version = "1.8"), class = "FutureResult")
[10:33:13.359]     }, finally = {
[10:33:13.359]         if (!identical(...future.workdir, getwd())) 
[10:33:13.359]             setwd(...future.workdir)
[10:33:13.359]         {
[10:33:13.359]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:13.359]                 ...future.oldOptions$nwarnings <- NULL
[10:33:13.359]             }
[10:33:13.359]             base::options(...future.oldOptions)
[10:33:13.359]             if (.Platform$OS.type == "windows") {
[10:33:13.359]                 old_names <- names(...future.oldEnvVars)
[10:33:13.359]                 envs <- base::Sys.getenv()
[10:33:13.359]                 names <- names(envs)
[10:33:13.359]                 common <- intersect(names, old_names)
[10:33:13.359]                 added <- setdiff(names, old_names)
[10:33:13.359]                 removed <- setdiff(old_names, names)
[10:33:13.359]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:13.359]                   envs[common]]
[10:33:13.359]                 NAMES <- toupper(changed)
[10:33:13.359]                 args <- list()
[10:33:13.359]                 for (kk in seq_along(NAMES)) {
[10:33:13.359]                   name <- changed[[kk]]
[10:33:13.359]                   NAME <- NAMES[[kk]]
[10:33:13.359]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.359]                     next
[10:33:13.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.359]                 }
[10:33:13.359]                 NAMES <- toupper(added)
[10:33:13.359]                 for (kk in seq_along(NAMES)) {
[10:33:13.359]                   name <- added[[kk]]
[10:33:13.359]                   NAME <- NAMES[[kk]]
[10:33:13.359]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.359]                     next
[10:33:13.359]                   args[[name]] <- ""
[10:33:13.359]                 }
[10:33:13.359]                 NAMES <- toupper(removed)
[10:33:13.359]                 for (kk in seq_along(NAMES)) {
[10:33:13.359]                   name <- removed[[kk]]
[10:33:13.359]                   NAME <- NAMES[[kk]]
[10:33:13.359]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.359]                     next
[10:33:13.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.359]                 }
[10:33:13.359]                 if (length(args) > 0) 
[10:33:13.359]                   base::do.call(base::Sys.setenv, args = args)
[10:33:13.359]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:13.359]             }
[10:33:13.359]             else {
[10:33:13.359]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:13.359]             }
[10:33:13.359]             {
[10:33:13.359]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:13.359]                   0L) {
[10:33:13.359]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:13.359]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:13.359]                   base::options(opts)
[10:33:13.359]                 }
[10:33:13.359]                 {
[10:33:13.359]                   {
[10:33:13.359]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:13.359]                     NULL
[10:33:13.359]                   }
[10:33:13.359]                   options(future.plan = NULL)
[10:33:13.359]                   if (is.na(NA_character_)) 
[10:33:13.359]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.359]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:13.359]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:13.359]                     .init = FALSE)
[10:33:13.359]                 }
[10:33:13.359]             }
[10:33:13.359]         }
[10:33:13.359]     })
[10:33:13.359]     if (TRUE) {
[10:33:13.359]         base::sink(type = "output", split = FALSE)
[10:33:13.359]         if (TRUE) {
[10:33:13.359]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:13.359]         }
[10:33:13.359]         else {
[10:33:13.359]             ...future.result["stdout"] <- base::list(NULL)
[10:33:13.359]         }
[10:33:13.359]         base::close(...future.stdout)
[10:33:13.359]         ...future.stdout <- NULL
[10:33:13.359]     }
[10:33:13.359]     ...future.result$conditions <- ...future.conditions
[10:33:13.359]     ...future.result$finished <- base::Sys.time()
[10:33:13.359]     ...future.result
[10:33:13.359] }
[10:33:13.361] assign_globals() ...
[10:33:13.361] List of 2
[10:33:13.361]  $ a : num 1
[10:33:13.361]  $ ii: int 1
[10:33:13.361]  - attr(*, "where")=List of 2
[10:33:13.361]   ..$ a :<environment: R_EmptyEnv> 
[10:33:13.361]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:13.361]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:13.361]  - attr(*, "resolved")= logi TRUE
[10:33:13.361]  - attr(*, "total_size")= num 112
[10:33:13.361]  - attr(*, "already-done")= logi TRUE
[10:33:13.364] - copied ‘a’ to environment
[10:33:13.364] - copied ‘ii’ to environment
[10:33:13.365] assign_globals() ... done
[10:33:13.365] requestCore(): workers = 2
[10:33:13.369] MulticoreFuture started
[10:33:13.369] - Launch lazy future ... done
[10:33:13.370] plan(): Setting new future strategy stack:
[10:33:13.370] run() for ‘MulticoreFuture’ ... done
[10:33:13.371] result() for MulticoreFuture ...
[10:33:13.370] List of future strategies:
[10:33:13.370] 1. sequential:
[10:33:13.370]    - args: function (..., envir = parent.frame())
[10:33:13.370]    - tweaked: FALSE
[10:33:13.370]    - call: NULL
[10:33:13.372] plan(): nbrOfWorkers() = 1
[10:33:13.375] plan(): Setting new future strategy stack:
[10:33:13.375] List of future strategies:
[10:33:13.375] 1. multicore:
[10:33:13.375]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.375]    - tweaked: FALSE
[10:33:13.375]    - call: plan(strategy)
[10:33:13.382] plan(): nbrOfWorkers() = 2
[10:33:13.383] result() for MulticoreFuture ...
[10:33:13.383] result() for MulticoreFuture ... done
[10:33:13.383] result() for MulticoreFuture ... done
[10:33:13.384] result() for MulticoreFuture ...
[10:33:13.384] result() for MulticoreFuture ... done
[10:33:13.385] run() for ‘Future’ ...
[10:33:13.385] - state: ‘created’
[10:33:13.385] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:13.390] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:13.390] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:13.390]   - Field: ‘label’
[10:33:13.390]   - Field: ‘local’
[10:33:13.391]   - Field: ‘owner’
[10:33:13.391]   - Field: ‘envir’
[10:33:13.391]   - Field: ‘workers’
[10:33:13.391]   - Field: ‘packages’
[10:33:13.391]   - Field: ‘gc’
[10:33:13.391]   - Field: ‘job’
[10:33:13.392]   - Field: ‘conditions’
[10:33:13.392]   - Field: ‘expr’
[10:33:13.392]   - Field: ‘uuid’
[10:33:13.392]   - Field: ‘seed’
[10:33:13.392]   - Field: ‘version’
[10:33:13.392]   - Field: ‘result’
[10:33:13.392]   - Field: ‘asynchronous’
[10:33:13.392]   - Field: ‘calls’
[10:33:13.393]   - Field: ‘globals’
[10:33:13.393]   - Field: ‘stdout’
[10:33:13.393]   - Field: ‘earlySignal’
[10:33:13.393]   - Field: ‘lazy’
[10:33:13.393]   - Field: ‘state’
[10:33:13.393] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:13.393] - Launch lazy future ...
[10:33:13.394] Packages needed by the future expression (n = 0): <none>
[10:33:13.394] Packages needed by future strategies (n = 0): <none>
[10:33:13.395] {
[10:33:13.395]     {
[10:33:13.395]         {
[10:33:13.395]             ...future.startTime <- base::Sys.time()
[10:33:13.395]             {
[10:33:13.395]                 {
[10:33:13.395]                   {
[10:33:13.395]                     {
[10:33:13.395]                       base::local({
[10:33:13.395]                         has_future <- base::requireNamespace("future", 
[10:33:13.395]                           quietly = TRUE)
[10:33:13.395]                         if (has_future) {
[10:33:13.395]                           ns <- base::getNamespace("future")
[10:33:13.395]                           version <- ns[[".package"]][["version"]]
[10:33:13.395]                           if (is.null(version)) 
[10:33:13.395]                             version <- utils::packageVersion("future")
[10:33:13.395]                         }
[10:33:13.395]                         else {
[10:33:13.395]                           version <- NULL
[10:33:13.395]                         }
[10:33:13.395]                         if (!has_future || version < "1.8.0") {
[10:33:13.395]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:13.395]                             "", base::R.version$version.string), 
[10:33:13.395]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:13.395]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:13.395]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:13.395]                               "release", "version")], collapse = " "), 
[10:33:13.395]                             hostname = base::Sys.info()[["nodename"]])
[10:33:13.395]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:13.395]                             info)
[10:33:13.395]                           info <- base::paste(info, collapse = "; ")
[10:33:13.395]                           if (!has_future) {
[10:33:13.395]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:13.395]                               info)
[10:33:13.395]                           }
[10:33:13.395]                           else {
[10:33:13.395]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:13.395]                               info, version)
[10:33:13.395]                           }
[10:33:13.395]                           base::stop(msg)
[10:33:13.395]                         }
[10:33:13.395]                       })
[10:33:13.395]                     }
[10:33:13.395]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:13.395]                     base::options(mc.cores = 1L)
[10:33:13.395]                   }
[10:33:13.395]                   ...future.strategy.old <- future::plan("list")
[10:33:13.395]                   options(future.plan = NULL)
[10:33:13.395]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.395]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:13.395]                 }
[10:33:13.395]                 ...future.workdir <- getwd()
[10:33:13.395]             }
[10:33:13.395]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:13.395]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:13.395]         }
[10:33:13.395]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:13.395]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:13.395]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:13.395]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:13.395]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:13.395]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:13.395]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:13.395]             base::names(...future.oldOptions))
[10:33:13.395]     }
[10:33:13.395]     if (FALSE) {
[10:33:13.395]     }
[10:33:13.395]     else {
[10:33:13.395]         if (TRUE) {
[10:33:13.395]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:13.395]                 open = "w")
[10:33:13.395]         }
[10:33:13.395]         else {
[10:33:13.395]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:13.395]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:13.395]         }
[10:33:13.395]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:13.395]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:13.395]             base::sink(type = "output", split = FALSE)
[10:33:13.395]             base::close(...future.stdout)
[10:33:13.395]         }, add = TRUE)
[10:33:13.395]     }
[10:33:13.395]     ...future.frame <- base::sys.nframe()
[10:33:13.395]     ...future.conditions <- base::list()
[10:33:13.395]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:13.395]     if (FALSE) {
[10:33:13.395]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:13.395]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:13.395]     }
[10:33:13.395]     ...future.result <- base::tryCatch({
[10:33:13.395]         base::withCallingHandlers({
[10:33:13.395]             ...future.value <- base::withVisible(base::local({
[10:33:13.395]                 withCallingHandlers({
[10:33:13.395]                   {
[10:33:13.395]                     b <- a * ii
[10:33:13.395]                     a <- 0
[10:33:13.395]                     b
[10:33:13.395]                   }
[10:33:13.395]                 }, immediateCondition = function(cond) {
[10:33:13.395]                   save_rds <- function (object, pathname, ...) 
[10:33:13.395]                   {
[10:33:13.395]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:13.395]                     if (file_test("-f", pathname_tmp)) {
[10:33:13.395]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.395]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:13.395]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.395]                         fi_tmp[["mtime"]])
[10:33:13.395]                     }
[10:33:13.395]                     tryCatch({
[10:33:13.395]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:13.395]                     }, error = function(ex) {
[10:33:13.395]                       msg <- conditionMessage(ex)
[10:33:13.395]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.395]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:13.395]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.395]                         fi_tmp[["mtime"]], msg)
[10:33:13.395]                       ex$message <- msg
[10:33:13.395]                       stop(ex)
[10:33:13.395]                     })
[10:33:13.395]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:13.395]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:13.395]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:13.395]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.395]                       fi <- file.info(pathname)
[10:33:13.395]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:13.395]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.395]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:13.395]                         fi[["size"]], fi[["mtime"]])
[10:33:13.395]                       stop(msg)
[10:33:13.395]                     }
[10:33:13.395]                     invisible(pathname)
[10:33:13.395]                   }
[10:33:13.395]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:13.395]                     rootPath = tempdir()) 
[10:33:13.395]                   {
[10:33:13.395]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:13.395]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:13.395]                       tmpdir = path, fileext = ".rds")
[10:33:13.395]                     save_rds(obj, file)
[10:33:13.395]                   }
[10:33:13.395]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:13.395]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.395]                   {
[10:33:13.395]                     inherits <- base::inherits
[10:33:13.395]                     invokeRestart <- base::invokeRestart
[10:33:13.395]                     is.null <- base::is.null
[10:33:13.395]                     muffled <- FALSE
[10:33:13.395]                     if (inherits(cond, "message")) {
[10:33:13.395]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:13.395]                       if (muffled) 
[10:33:13.395]                         invokeRestart("muffleMessage")
[10:33:13.395]                     }
[10:33:13.395]                     else if (inherits(cond, "warning")) {
[10:33:13.395]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:13.395]                       if (muffled) 
[10:33:13.395]                         invokeRestart("muffleWarning")
[10:33:13.395]                     }
[10:33:13.395]                     else if (inherits(cond, "condition")) {
[10:33:13.395]                       if (!is.null(pattern)) {
[10:33:13.395]                         computeRestarts <- base::computeRestarts
[10:33:13.395]                         grepl <- base::grepl
[10:33:13.395]                         restarts <- computeRestarts(cond)
[10:33:13.395]                         for (restart in restarts) {
[10:33:13.395]                           name <- restart$name
[10:33:13.395]                           if (is.null(name)) 
[10:33:13.395]                             next
[10:33:13.395]                           if (!grepl(pattern, name)) 
[10:33:13.395]                             next
[10:33:13.395]                           invokeRestart(restart)
[10:33:13.395]                           muffled <- TRUE
[10:33:13.395]                           break
[10:33:13.395]                         }
[10:33:13.395]                       }
[10:33:13.395]                     }
[10:33:13.395]                     invisible(muffled)
[10:33:13.395]                   }
[10:33:13.395]                   muffleCondition(cond)
[10:33:13.395]                 })
[10:33:13.395]             }))
[10:33:13.395]             future::FutureResult(value = ...future.value$value, 
[10:33:13.395]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.395]                   ...future.rng), globalenv = if (FALSE) 
[10:33:13.395]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:13.395]                     ...future.globalenv.names))
[10:33:13.395]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:13.395]         }, condition = base::local({
[10:33:13.395]             c <- base::c
[10:33:13.395]             inherits <- base::inherits
[10:33:13.395]             invokeRestart <- base::invokeRestart
[10:33:13.395]             length <- base::length
[10:33:13.395]             list <- base::list
[10:33:13.395]             seq.int <- base::seq.int
[10:33:13.395]             signalCondition <- base::signalCondition
[10:33:13.395]             sys.calls <- base::sys.calls
[10:33:13.395]             `[[` <- base::`[[`
[10:33:13.395]             `+` <- base::`+`
[10:33:13.395]             `<<-` <- base::`<<-`
[10:33:13.395]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:13.395]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:13.395]                   3L)]
[10:33:13.395]             }
[10:33:13.395]             function(cond) {
[10:33:13.395]                 is_error <- inherits(cond, "error")
[10:33:13.395]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:13.395]                   NULL)
[10:33:13.395]                 if (is_error) {
[10:33:13.395]                   sessionInformation <- function() {
[10:33:13.395]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:13.395]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:13.395]                       search = base::search(), system = base::Sys.info())
[10:33:13.395]                   }
[10:33:13.395]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.395]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:13.395]                     cond$call), session = sessionInformation(), 
[10:33:13.395]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:13.395]                   signalCondition(cond)
[10:33:13.395]                 }
[10:33:13.395]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:13.395]                 "immediateCondition"))) {
[10:33:13.395]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:13.395]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.395]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:13.395]                   if (TRUE && !signal) {
[10:33:13.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.395]                     {
[10:33:13.395]                       inherits <- base::inherits
[10:33:13.395]                       invokeRestart <- base::invokeRestart
[10:33:13.395]                       is.null <- base::is.null
[10:33:13.395]                       muffled <- FALSE
[10:33:13.395]                       if (inherits(cond, "message")) {
[10:33:13.395]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.395]                         if (muffled) 
[10:33:13.395]                           invokeRestart("muffleMessage")
[10:33:13.395]                       }
[10:33:13.395]                       else if (inherits(cond, "warning")) {
[10:33:13.395]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.395]                         if (muffled) 
[10:33:13.395]                           invokeRestart("muffleWarning")
[10:33:13.395]                       }
[10:33:13.395]                       else if (inherits(cond, "condition")) {
[10:33:13.395]                         if (!is.null(pattern)) {
[10:33:13.395]                           computeRestarts <- base::computeRestarts
[10:33:13.395]                           grepl <- base::grepl
[10:33:13.395]                           restarts <- computeRestarts(cond)
[10:33:13.395]                           for (restart in restarts) {
[10:33:13.395]                             name <- restart$name
[10:33:13.395]                             if (is.null(name)) 
[10:33:13.395]                               next
[10:33:13.395]                             if (!grepl(pattern, name)) 
[10:33:13.395]                               next
[10:33:13.395]                             invokeRestart(restart)
[10:33:13.395]                             muffled <- TRUE
[10:33:13.395]                             break
[10:33:13.395]                           }
[10:33:13.395]                         }
[10:33:13.395]                       }
[10:33:13.395]                       invisible(muffled)
[10:33:13.395]                     }
[10:33:13.395]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.395]                   }
[10:33:13.395]                 }
[10:33:13.395]                 else {
[10:33:13.395]                   if (TRUE) {
[10:33:13.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.395]                     {
[10:33:13.395]                       inherits <- base::inherits
[10:33:13.395]                       invokeRestart <- base::invokeRestart
[10:33:13.395]                       is.null <- base::is.null
[10:33:13.395]                       muffled <- FALSE
[10:33:13.395]                       if (inherits(cond, "message")) {
[10:33:13.395]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.395]                         if (muffled) 
[10:33:13.395]                           invokeRestart("muffleMessage")
[10:33:13.395]                       }
[10:33:13.395]                       else if (inherits(cond, "warning")) {
[10:33:13.395]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.395]                         if (muffled) 
[10:33:13.395]                           invokeRestart("muffleWarning")
[10:33:13.395]                       }
[10:33:13.395]                       else if (inherits(cond, "condition")) {
[10:33:13.395]                         if (!is.null(pattern)) {
[10:33:13.395]                           computeRestarts <- base::computeRestarts
[10:33:13.395]                           grepl <- base::grepl
[10:33:13.395]                           restarts <- computeRestarts(cond)
[10:33:13.395]                           for (restart in restarts) {
[10:33:13.395]                             name <- restart$name
[10:33:13.395]                             if (is.null(name)) 
[10:33:13.395]                               next
[10:33:13.395]                             if (!grepl(pattern, name)) 
[10:33:13.395]                               next
[10:33:13.395]                             invokeRestart(restart)
[10:33:13.395]                             muffled <- TRUE
[10:33:13.395]                             break
[10:33:13.395]                           }
[10:33:13.395]                         }
[10:33:13.395]                       }
[10:33:13.395]                       invisible(muffled)
[10:33:13.395]                     }
[10:33:13.395]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.395]                   }
[10:33:13.395]                 }
[10:33:13.395]             }
[10:33:13.395]         }))
[10:33:13.395]     }, error = function(ex) {
[10:33:13.395]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:13.395]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.395]                 ...future.rng), started = ...future.startTime, 
[10:33:13.395]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:13.395]             version = "1.8"), class = "FutureResult")
[10:33:13.395]     }, finally = {
[10:33:13.395]         if (!identical(...future.workdir, getwd())) 
[10:33:13.395]             setwd(...future.workdir)
[10:33:13.395]         {
[10:33:13.395]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:13.395]                 ...future.oldOptions$nwarnings <- NULL
[10:33:13.395]             }
[10:33:13.395]             base::options(...future.oldOptions)
[10:33:13.395]             if (.Platform$OS.type == "windows") {
[10:33:13.395]                 old_names <- names(...future.oldEnvVars)
[10:33:13.395]                 envs <- base::Sys.getenv()
[10:33:13.395]                 names <- names(envs)
[10:33:13.395]                 common <- intersect(names, old_names)
[10:33:13.395]                 added <- setdiff(names, old_names)
[10:33:13.395]                 removed <- setdiff(old_names, names)
[10:33:13.395]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:13.395]                   envs[common]]
[10:33:13.395]                 NAMES <- toupper(changed)
[10:33:13.395]                 args <- list()
[10:33:13.395]                 for (kk in seq_along(NAMES)) {
[10:33:13.395]                   name <- changed[[kk]]
[10:33:13.395]                   NAME <- NAMES[[kk]]
[10:33:13.395]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.395]                     next
[10:33:13.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.395]                 }
[10:33:13.395]                 NAMES <- toupper(added)
[10:33:13.395]                 for (kk in seq_along(NAMES)) {
[10:33:13.395]                   name <- added[[kk]]
[10:33:13.395]                   NAME <- NAMES[[kk]]
[10:33:13.395]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.395]                     next
[10:33:13.395]                   args[[name]] <- ""
[10:33:13.395]                 }
[10:33:13.395]                 NAMES <- toupper(removed)
[10:33:13.395]                 for (kk in seq_along(NAMES)) {
[10:33:13.395]                   name <- removed[[kk]]
[10:33:13.395]                   NAME <- NAMES[[kk]]
[10:33:13.395]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.395]                     next
[10:33:13.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.395]                 }
[10:33:13.395]                 if (length(args) > 0) 
[10:33:13.395]                   base::do.call(base::Sys.setenv, args = args)
[10:33:13.395]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:13.395]             }
[10:33:13.395]             else {
[10:33:13.395]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:13.395]             }
[10:33:13.395]             {
[10:33:13.395]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:13.395]                   0L) {
[10:33:13.395]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:13.395]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:13.395]                   base::options(opts)
[10:33:13.395]                 }
[10:33:13.395]                 {
[10:33:13.395]                   {
[10:33:13.395]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:13.395]                     NULL
[10:33:13.395]                   }
[10:33:13.395]                   options(future.plan = NULL)
[10:33:13.395]                   if (is.na(NA_character_)) 
[10:33:13.395]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.395]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:13.395]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:13.395]                     .init = FALSE)
[10:33:13.395]                 }
[10:33:13.395]             }
[10:33:13.395]         }
[10:33:13.395]     })
[10:33:13.395]     if (TRUE) {
[10:33:13.395]         base::sink(type = "output", split = FALSE)
[10:33:13.395]         if (TRUE) {
[10:33:13.395]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:13.395]         }
[10:33:13.395]         else {
[10:33:13.395]             ...future.result["stdout"] <- base::list(NULL)
[10:33:13.395]         }
[10:33:13.395]         base::close(...future.stdout)
[10:33:13.395]         ...future.stdout <- NULL
[10:33:13.395]     }
[10:33:13.395]     ...future.result$conditions <- ...future.conditions
[10:33:13.395]     ...future.result$finished <- base::Sys.time()
[10:33:13.395]     ...future.result
[10:33:13.395] }
[10:33:13.397] assign_globals() ...
[10:33:13.397] List of 2
[10:33:13.397]  $ a : num 1
[10:33:13.397]  $ ii: int 2
[10:33:13.397]  - attr(*, "where")=List of 2
[10:33:13.397]   ..$ a :<environment: R_EmptyEnv> 
[10:33:13.397]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:13.397]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:13.397]  - attr(*, "resolved")= logi TRUE
[10:33:13.397]  - attr(*, "total_size")= num 112
[10:33:13.397]  - attr(*, "already-done")= logi TRUE
[10:33:13.401] - copied ‘a’ to environment
[10:33:13.401] - copied ‘ii’ to environment
[10:33:13.402] assign_globals() ... done
[10:33:13.402] requestCore(): workers = 2
[10:33:13.404] MulticoreFuture started
[10:33:13.404] - Launch lazy future ... done
[10:33:13.404] run() for ‘MulticoreFuture’ ... done
[10:33:13.405] result() for MulticoreFuture ...
[10:33:13.405] plan(): Setting new future strategy stack:
[10:33:13.405] List of future strategies:
[10:33:13.405] 1. sequential:
[10:33:13.405]    - args: function (..., envir = parent.frame())
[10:33:13.405]    - tweaked: FALSE
[10:33:13.405]    - call: NULL
[10:33:13.406] plan(): nbrOfWorkers() = 1
[10:33:13.408] plan(): Setting new future strategy stack:
[10:33:13.409] List of future strategies:
[10:33:13.409] 1. multicore:
[10:33:13.409]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.409]    - tweaked: FALSE
[10:33:13.409]    - call: plan(strategy)
[10:33:13.414] plan(): nbrOfWorkers() = 2
[10:33:13.415] result() for MulticoreFuture ...
[10:33:13.415] result() for MulticoreFuture ... done
[10:33:13.415] result() for MulticoreFuture ... done
[10:33:13.415] result() for MulticoreFuture ...
[10:33:13.415] result() for MulticoreFuture ... done
[10:33:13.416] run() for ‘Future’ ...
[10:33:13.416] - state: ‘created’
[10:33:13.416] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:13.421] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:13.421] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:13.421]   - Field: ‘label’
[10:33:13.421]   - Field: ‘local’
[10:33:13.421]   - Field: ‘owner’
[10:33:13.421]   - Field: ‘envir’
[10:33:13.421]   - Field: ‘workers’
[10:33:13.422]   - Field: ‘packages’
[10:33:13.422]   - Field: ‘gc’
[10:33:13.422]   - Field: ‘job’
[10:33:13.422]   - Field: ‘conditions’
[10:33:13.422]   - Field: ‘expr’
[10:33:13.422]   - Field: ‘uuid’
[10:33:13.422]   - Field: ‘seed’
[10:33:13.422]   - Field: ‘version’
[10:33:13.422]   - Field: ‘result’
[10:33:13.423]   - Field: ‘asynchronous’
[10:33:13.423]   - Field: ‘calls’
[10:33:13.423]   - Field: ‘globals’
[10:33:13.423]   - Field: ‘stdout’
[10:33:13.423]   - Field: ‘earlySignal’
[10:33:13.423]   - Field: ‘lazy’
[10:33:13.423]   - Field: ‘state’
[10:33:13.423] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:13.424] - Launch lazy future ...
[10:33:13.424] Packages needed by the future expression (n = 0): <none>
[10:33:13.424] Packages needed by future strategies (n = 0): <none>
[10:33:13.425] {
[10:33:13.425]     {
[10:33:13.425]         {
[10:33:13.425]             ...future.startTime <- base::Sys.time()
[10:33:13.425]             {
[10:33:13.425]                 {
[10:33:13.425]                   {
[10:33:13.425]                     {
[10:33:13.425]                       base::local({
[10:33:13.425]                         has_future <- base::requireNamespace("future", 
[10:33:13.425]                           quietly = TRUE)
[10:33:13.425]                         if (has_future) {
[10:33:13.425]                           ns <- base::getNamespace("future")
[10:33:13.425]                           version <- ns[[".package"]][["version"]]
[10:33:13.425]                           if (is.null(version)) 
[10:33:13.425]                             version <- utils::packageVersion("future")
[10:33:13.425]                         }
[10:33:13.425]                         else {
[10:33:13.425]                           version <- NULL
[10:33:13.425]                         }
[10:33:13.425]                         if (!has_future || version < "1.8.0") {
[10:33:13.425]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:13.425]                             "", base::R.version$version.string), 
[10:33:13.425]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:13.425]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:13.425]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:13.425]                               "release", "version")], collapse = " "), 
[10:33:13.425]                             hostname = base::Sys.info()[["nodename"]])
[10:33:13.425]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:13.425]                             info)
[10:33:13.425]                           info <- base::paste(info, collapse = "; ")
[10:33:13.425]                           if (!has_future) {
[10:33:13.425]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:13.425]                               info)
[10:33:13.425]                           }
[10:33:13.425]                           else {
[10:33:13.425]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:13.425]                               info, version)
[10:33:13.425]                           }
[10:33:13.425]                           base::stop(msg)
[10:33:13.425]                         }
[10:33:13.425]                       })
[10:33:13.425]                     }
[10:33:13.425]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:13.425]                     base::options(mc.cores = 1L)
[10:33:13.425]                   }
[10:33:13.425]                   ...future.strategy.old <- future::plan("list")
[10:33:13.425]                   options(future.plan = NULL)
[10:33:13.425]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.425]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:13.425]                 }
[10:33:13.425]                 ...future.workdir <- getwd()
[10:33:13.425]             }
[10:33:13.425]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:13.425]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:13.425]         }
[10:33:13.425]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:13.425]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:13.425]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:13.425]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:13.425]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:13.425]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:13.425]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:13.425]             base::names(...future.oldOptions))
[10:33:13.425]     }
[10:33:13.425]     if (FALSE) {
[10:33:13.425]     }
[10:33:13.425]     else {
[10:33:13.425]         if (TRUE) {
[10:33:13.425]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:13.425]                 open = "w")
[10:33:13.425]         }
[10:33:13.425]         else {
[10:33:13.425]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:13.425]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:13.425]         }
[10:33:13.425]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:13.425]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:13.425]             base::sink(type = "output", split = FALSE)
[10:33:13.425]             base::close(...future.stdout)
[10:33:13.425]         }, add = TRUE)
[10:33:13.425]     }
[10:33:13.425]     ...future.frame <- base::sys.nframe()
[10:33:13.425]     ...future.conditions <- base::list()
[10:33:13.425]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:13.425]     if (FALSE) {
[10:33:13.425]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:13.425]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:13.425]     }
[10:33:13.425]     ...future.result <- base::tryCatch({
[10:33:13.425]         base::withCallingHandlers({
[10:33:13.425]             ...future.value <- base::withVisible(base::local({
[10:33:13.425]                 withCallingHandlers({
[10:33:13.425]                   {
[10:33:13.425]                     b <- a * ii
[10:33:13.425]                     a <- 0
[10:33:13.425]                     b
[10:33:13.425]                   }
[10:33:13.425]                 }, immediateCondition = function(cond) {
[10:33:13.425]                   save_rds <- function (object, pathname, ...) 
[10:33:13.425]                   {
[10:33:13.425]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:13.425]                     if (file_test("-f", pathname_tmp)) {
[10:33:13.425]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.425]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:13.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.425]                         fi_tmp[["mtime"]])
[10:33:13.425]                     }
[10:33:13.425]                     tryCatch({
[10:33:13.425]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:13.425]                     }, error = function(ex) {
[10:33:13.425]                       msg <- conditionMessage(ex)
[10:33:13.425]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.425]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:13.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.425]                         fi_tmp[["mtime"]], msg)
[10:33:13.425]                       ex$message <- msg
[10:33:13.425]                       stop(ex)
[10:33:13.425]                     })
[10:33:13.425]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:13.425]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:13.425]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:13.425]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.425]                       fi <- file.info(pathname)
[10:33:13.425]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:13.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.425]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:13.425]                         fi[["size"]], fi[["mtime"]])
[10:33:13.425]                       stop(msg)
[10:33:13.425]                     }
[10:33:13.425]                     invisible(pathname)
[10:33:13.425]                   }
[10:33:13.425]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:13.425]                     rootPath = tempdir()) 
[10:33:13.425]                   {
[10:33:13.425]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:13.425]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:13.425]                       tmpdir = path, fileext = ".rds")
[10:33:13.425]                     save_rds(obj, file)
[10:33:13.425]                   }
[10:33:13.425]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:13.425]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.425]                   {
[10:33:13.425]                     inherits <- base::inherits
[10:33:13.425]                     invokeRestart <- base::invokeRestart
[10:33:13.425]                     is.null <- base::is.null
[10:33:13.425]                     muffled <- FALSE
[10:33:13.425]                     if (inherits(cond, "message")) {
[10:33:13.425]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:13.425]                       if (muffled) 
[10:33:13.425]                         invokeRestart("muffleMessage")
[10:33:13.425]                     }
[10:33:13.425]                     else if (inherits(cond, "warning")) {
[10:33:13.425]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:13.425]                       if (muffled) 
[10:33:13.425]                         invokeRestart("muffleWarning")
[10:33:13.425]                     }
[10:33:13.425]                     else if (inherits(cond, "condition")) {
[10:33:13.425]                       if (!is.null(pattern)) {
[10:33:13.425]                         computeRestarts <- base::computeRestarts
[10:33:13.425]                         grepl <- base::grepl
[10:33:13.425]                         restarts <- computeRestarts(cond)
[10:33:13.425]                         for (restart in restarts) {
[10:33:13.425]                           name <- restart$name
[10:33:13.425]                           if (is.null(name)) 
[10:33:13.425]                             next
[10:33:13.425]                           if (!grepl(pattern, name)) 
[10:33:13.425]                             next
[10:33:13.425]                           invokeRestart(restart)
[10:33:13.425]                           muffled <- TRUE
[10:33:13.425]                           break
[10:33:13.425]                         }
[10:33:13.425]                       }
[10:33:13.425]                     }
[10:33:13.425]                     invisible(muffled)
[10:33:13.425]                   }
[10:33:13.425]                   muffleCondition(cond)
[10:33:13.425]                 })
[10:33:13.425]             }))
[10:33:13.425]             future::FutureResult(value = ...future.value$value, 
[10:33:13.425]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.425]                   ...future.rng), globalenv = if (FALSE) 
[10:33:13.425]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:13.425]                     ...future.globalenv.names))
[10:33:13.425]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:13.425]         }, condition = base::local({
[10:33:13.425]             c <- base::c
[10:33:13.425]             inherits <- base::inherits
[10:33:13.425]             invokeRestart <- base::invokeRestart
[10:33:13.425]             length <- base::length
[10:33:13.425]             list <- base::list
[10:33:13.425]             seq.int <- base::seq.int
[10:33:13.425]             signalCondition <- base::signalCondition
[10:33:13.425]             sys.calls <- base::sys.calls
[10:33:13.425]             `[[` <- base::`[[`
[10:33:13.425]             `+` <- base::`+`
[10:33:13.425]             `<<-` <- base::`<<-`
[10:33:13.425]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:13.425]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:13.425]                   3L)]
[10:33:13.425]             }
[10:33:13.425]             function(cond) {
[10:33:13.425]                 is_error <- inherits(cond, "error")
[10:33:13.425]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:13.425]                   NULL)
[10:33:13.425]                 if (is_error) {
[10:33:13.425]                   sessionInformation <- function() {
[10:33:13.425]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:13.425]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:13.425]                       search = base::search(), system = base::Sys.info())
[10:33:13.425]                   }
[10:33:13.425]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.425]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:13.425]                     cond$call), session = sessionInformation(), 
[10:33:13.425]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:13.425]                   signalCondition(cond)
[10:33:13.425]                 }
[10:33:13.425]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:13.425]                 "immediateCondition"))) {
[10:33:13.425]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:13.425]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.425]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:13.425]                   if (TRUE && !signal) {
[10:33:13.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.425]                     {
[10:33:13.425]                       inherits <- base::inherits
[10:33:13.425]                       invokeRestart <- base::invokeRestart
[10:33:13.425]                       is.null <- base::is.null
[10:33:13.425]                       muffled <- FALSE
[10:33:13.425]                       if (inherits(cond, "message")) {
[10:33:13.425]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.425]                         if (muffled) 
[10:33:13.425]                           invokeRestart("muffleMessage")
[10:33:13.425]                       }
[10:33:13.425]                       else if (inherits(cond, "warning")) {
[10:33:13.425]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.425]                         if (muffled) 
[10:33:13.425]                           invokeRestart("muffleWarning")
[10:33:13.425]                       }
[10:33:13.425]                       else if (inherits(cond, "condition")) {
[10:33:13.425]                         if (!is.null(pattern)) {
[10:33:13.425]                           computeRestarts <- base::computeRestarts
[10:33:13.425]                           grepl <- base::grepl
[10:33:13.425]                           restarts <- computeRestarts(cond)
[10:33:13.425]                           for (restart in restarts) {
[10:33:13.425]                             name <- restart$name
[10:33:13.425]                             if (is.null(name)) 
[10:33:13.425]                               next
[10:33:13.425]                             if (!grepl(pattern, name)) 
[10:33:13.425]                               next
[10:33:13.425]                             invokeRestart(restart)
[10:33:13.425]                             muffled <- TRUE
[10:33:13.425]                             break
[10:33:13.425]                           }
[10:33:13.425]                         }
[10:33:13.425]                       }
[10:33:13.425]                       invisible(muffled)
[10:33:13.425]                     }
[10:33:13.425]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.425]                   }
[10:33:13.425]                 }
[10:33:13.425]                 else {
[10:33:13.425]                   if (TRUE) {
[10:33:13.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.425]                     {
[10:33:13.425]                       inherits <- base::inherits
[10:33:13.425]                       invokeRestart <- base::invokeRestart
[10:33:13.425]                       is.null <- base::is.null
[10:33:13.425]                       muffled <- FALSE
[10:33:13.425]                       if (inherits(cond, "message")) {
[10:33:13.425]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.425]                         if (muffled) 
[10:33:13.425]                           invokeRestart("muffleMessage")
[10:33:13.425]                       }
[10:33:13.425]                       else if (inherits(cond, "warning")) {
[10:33:13.425]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.425]                         if (muffled) 
[10:33:13.425]                           invokeRestart("muffleWarning")
[10:33:13.425]                       }
[10:33:13.425]                       else if (inherits(cond, "condition")) {
[10:33:13.425]                         if (!is.null(pattern)) {
[10:33:13.425]                           computeRestarts <- base::computeRestarts
[10:33:13.425]                           grepl <- base::grepl
[10:33:13.425]                           restarts <- computeRestarts(cond)
[10:33:13.425]                           for (restart in restarts) {
[10:33:13.425]                             name <- restart$name
[10:33:13.425]                             if (is.null(name)) 
[10:33:13.425]                               next
[10:33:13.425]                             if (!grepl(pattern, name)) 
[10:33:13.425]                               next
[10:33:13.425]                             invokeRestart(restart)
[10:33:13.425]                             muffled <- TRUE
[10:33:13.425]                             break
[10:33:13.425]                           }
[10:33:13.425]                         }
[10:33:13.425]                       }
[10:33:13.425]                       invisible(muffled)
[10:33:13.425]                     }
[10:33:13.425]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.425]                   }
[10:33:13.425]                 }
[10:33:13.425]             }
[10:33:13.425]         }))
[10:33:13.425]     }, error = function(ex) {
[10:33:13.425]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:13.425]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.425]                 ...future.rng), started = ...future.startTime, 
[10:33:13.425]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:13.425]             version = "1.8"), class = "FutureResult")
[10:33:13.425]     }, finally = {
[10:33:13.425]         if (!identical(...future.workdir, getwd())) 
[10:33:13.425]             setwd(...future.workdir)
[10:33:13.425]         {
[10:33:13.425]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:13.425]                 ...future.oldOptions$nwarnings <- NULL
[10:33:13.425]             }
[10:33:13.425]             base::options(...future.oldOptions)
[10:33:13.425]             if (.Platform$OS.type == "windows") {
[10:33:13.425]                 old_names <- names(...future.oldEnvVars)
[10:33:13.425]                 envs <- base::Sys.getenv()
[10:33:13.425]                 names <- names(envs)
[10:33:13.425]                 common <- intersect(names, old_names)
[10:33:13.425]                 added <- setdiff(names, old_names)
[10:33:13.425]                 removed <- setdiff(old_names, names)
[10:33:13.425]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:13.425]                   envs[common]]
[10:33:13.425]                 NAMES <- toupper(changed)
[10:33:13.425]                 args <- list()
[10:33:13.425]                 for (kk in seq_along(NAMES)) {
[10:33:13.425]                   name <- changed[[kk]]
[10:33:13.425]                   NAME <- NAMES[[kk]]
[10:33:13.425]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.425]                     next
[10:33:13.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.425]                 }
[10:33:13.425]                 NAMES <- toupper(added)
[10:33:13.425]                 for (kk in seq_along(NAMES)) {
[10:33:13.425]                   name <- added[[kk]]
[10:33:13.425]                   NAME <- NAMES[[kk]]
[10:33:13.425]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.425]                     next
[10:33:13.425]                   args[[name]] <- ""
[10:33:13.425]                 }
[10:33:13.425]                 NAMES <- toupper(removed)
[10:33:13.425]                 for (kk in seq_along(NAMES)) {
[10:33:13.425]                   name <- removed[[kk]]
[10:33:13.425]                   NAME <- NAMES[[kk]]
[10:33:13.425]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.425]                     next
[10:33:13.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.425]                 }
[10:33:13.425]                 if (length(args) > 0) 
[10:33:13.425]                   base::do.call(base::Sys.setenv, args = args)
[10:33:13.425]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:13.425]             }
[10:33:13.425]             else {
[10:33:13.425]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:13.425]             }
[10:33:13.425]             {
[10:33:13.425]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:13.425]                   0L) {
[10:33:13.425]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:13.425]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:13.425]                   base::options(opts)
[10:33:13.425]                 }
[10:33:13.425]                 {
[10:33:13.425]                   {
[10:33:13.425]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:13.425]                     NULL
[10:33:13.425]                   }
[10:33:13.425]                   options(future.plan = NULL)
[10:33:13.425]                   if (is.na(NA_character_)) 
[10:33:13.425]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.425]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:13.425]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:13.425]                     .init = FALSE)
[10:33:13.425]                 }
[10:33:13.425]             }
[10:33:13.425]         }
[10:33:13.425]     })
[10:33:13.425]     if (TRUE) {
[10:33:13.425]         base::sink(type = "output", split = FALSE)
[10:33:13.425]         if (TRUE) {
[10:33:13.425]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:13.425]         }
[10:33:13.425]         else {
[10:33:13.425]             ...future.result["stdout"] <- base::list(NULL)
[10:33:13.425]         }
[10:33:13.425]         base::close(...future.stdout)
[10:33:13.425]         ...future.stdout <- NULL
[10:33:13.425]     }
[10:33:13.425]     ...future.result$conditions <- ...future.conditions
[10:33:13.425]     ...future.result$finished <- base::Sys.time()
[10:33:13.425]     ...future.result
[10:33:13.425] }
[10:33:13.427] assign_globals() ...
[10:33:13.428] List of 2
[10:33:13.428]  $ a : num 1
[10:33:13.428]  $ ii: int 3
[10:33:13.428]  - attr(*, "where")=List of 2
[10:33:13.428]   ..$ a :<environment: R_EmptyEnv> 
[10:33:13.428]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:13.428]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:13.428]  - attr(*, "resolved")= logi TRUE
[10:33:13.428]  - attr(*, "total_size")= num 112
[10:33:13.428]  - attr(*, "already-done")= logi TRUE
[10:33:13.435] - copied ‘a’ to environment
[10:33:13.435] - copied ‘ii’ to environment
[10:33:13.435] assign_globals() ... done
[10:33:13.436] requestCore(): workers = 2
[10:33:13.438] MulticoreFuture started
[10:33:13.438] - Launch lazy future ... done
[10:33:13.439] run() for ‘MulticoreFuture’ ... done
[10:33:13.439] result() for MulticoreFuture ...
[10:33:13.439] plan(): Setting new future strategy stack:
[10:33:13.439] List of future strategies:
[10:33:13.439] 1. sequential:
[10:33:13.439]    - args: function (..., envir = parent.frame())
[10:33:13.439]    - tweaked: FALSE
[10:33:13.439]    - call: NULL
[10:33:13.441] plan(): nbrOfWorkers() = 1
[10:33:13.444] plan(): Setting new future strategy stack:
[10:33:13.445] List of future strategies:
[10:33:13.445] 1. multicore:
[10:33:13.445]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.445]    - tweaked: FALSE
[10:33:13.445]    - call: plan(strategy)
[10:33:13.453] plan(): nbrOfWorkers() = 2
[10:33:13.454] result() for MulticoreFuture ...
[10:33:13.455] result() for MulticoreFuture ... done
[10:33:13.455] result() for MulticoreFuture ... done
[10:33:13.455] result() for MulticoreFuture ...
[10:33:13.455] result() for MulticoreFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.456] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.457] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:13.458] 
[10:33:13.458] Searching for globals ... DONE
[10:33:13.458] - globals: [0] <none>
[10:33:13.458] getGlobalsAndPackages() ... DONE
[10:33:13.459] run() for ‘Future’ ...
[10:33:13.459] - state: ‘created’
[10:33:13.459] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:13.464] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:13.464] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:13.464]   - Field: ‘label’
[10:33:13.464]   - Field: ‘local’
[10:33:13.464]   - Field: ‘owner’
[10:33:13.464]   - Field: ‘envir’
[10:33:13.464]   - Field: ‘workers’
[10:33:13.465]   - Field: ‘packages’
[10:33:13.465]   - Field: ‘gc’
[10:33:13.465]   - Field: ‘job’
[10:33:13.465]   - Field: ‘conditions’
[10:33:13.465]   - Field: ‘expr’
[10:33:13.465]   - Field: ‘uuid’
[10:33:13.465]   - Field: ‘seed’
[10:33:13.466]   - Field: ‘version’
[10:33:13.466]   - Field: ‘result’
[10:33:13.466]   - Field: ‘asynchronous’
[10:33:13.466]   - Field: ‘calls’
[10:33:13.466]   - Field: ‘globals’
[10:33:13.466]   - Field: ‘stdout’
[10:33:13.466]   - Field: ‘earlySignal’
[10:33:13.466]   - Field: ‘lazy’
[10:33:13.466]   - Field: ‘state’
[10:33:13.467] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:13.467] - Launch lazy future ...
[10:33:13.467] Packages needed by the future expression (n = 0): <none>
[10:33:13.467] Packages needed by future strategies (n = 0): <none>
[10:33:13.468] {
[10:33:13.468]     {
[10:33:13.468]         {
[10:33:13.468]             ...future.startTime <- base::Sys.time()
[10:33:13.468]             {
[10:33:13.468]                 {
[10:33:13.468]                   {
[10:33:13.468]                     {
[10:33:13.468]                       base::local({
[10:33:13.468]                         has_future <- base::requireNamespace("future", 
[10:33:13.468]                           quietly = TRUE)
[10:33:13.468]                         if (has_future) {
[10:33:13.468]                           ns <- base::getNamespace("future")
[10:33:13.468]                           version <- ns[[".package"]][["version"]]
[10:33:13.468]                           if (is.null(version)) 
[10:33:13.468]                             version <- utils::packageVersion("future")
[10:33:13.468]                         }
[10:33:13.468]                         else {
[10:33:13.468]                           version <- NULL
[10:33:13.468]                         }
[10:33:13.468]                         if (!has_future || version < "1.8.0") {
[10:33:13.468]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:13.468]                             "", base::R.version$version.string), 
[10:33:13.468]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:13.468]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:13.468]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:13.468]                               "release", "version")], collapse = " "), 
[10:33:13.468]                             hostname = base::Sys.info()[["nodename"]])
[10:33:13.468]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:13.468]                             info)
[10:33:13.468]                           info <- base::paste(info, collapse = "; ")
[10:33:13.468]                           if (!has_future) {
[10:33:13.468]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:13.468]                               info)
[10:33:13.468]                           }
[10:33:13.468]                           else {
[10:33:13.468]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:13.468]                               info, version)
[10:33:13.468]                           }
[10:33:13.468]                           base::stop(msg)
[10:33:13.468]                         }
[10:33:13.468]                       })
[10:33:13.468]                     }
[10:33:13.468]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:13.468]                     base::options(mc.cores = 1L)
[10:33:13.468]                   }
[10:33:13.468]                   ...future.strategy.old <- future::plan("list")
[10:33:13.468]                   options(future.plan = NULL)
[10:33:13.468]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.468]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:13.468]                 }
[10:33:13.468]                 ...future.workdir <- getwd()
[10:33:13.468]             }
[10:33:13.468]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:13.468]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:13.468]         }
[10:33:13.468]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:13.468]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:13.468]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:13.468]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:13.468]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:13.468]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:13.468]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:13.468]             base::names(...future.oldOptions))
[10:33:13.468]     }
[10:33:13.468]     if (FALSE) {
[10:33:13.468]     }
[10:33:13.468]     else {
[10:33:13.468]         if (TRUE) {
[10:33:13.468]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:13.468]                 open = "w")
[10:33:13.468]         }
[10:33:13.468]         else {
[10:33:13.468]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:13.468]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:13.468]         }
[10:33:13.468]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:13.468]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:13.468]             base::sink(type = "output", split = FALSE)
[10:33:13.468]             base::close(...future.stdout)
[10:33:13.468]         }, add = TRUE)
[10:33:13.468]     }
[10:33:13.468]     ...future.frame <- base::sys.nframe()
[10:33:13.468]     ...future.conditions <- base::list()
[10:33:13.468]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:13.468]     if (FALSE) {
[10:33:13.468]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:13.468]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:13.468]     }
[10:33:13.468]     ...future.result <- base::tryCatch({
[10:33:13.468]         base::withCallingHandlers({
[10:33:13.468]             ...future.value <- base::withVisible(base::local({
[10:33:13.468]                 withCallingHandlers({
[10:33:13.468]                   1
[10:33:13.468]                 }, immediateCondition = function(cond) {
[10:33:13.468]                   save_rds <- function (object, pathname, ...) 
[10:33:13.468]                   {
[10:33:13.468]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:13.468]                     if (file_test("-f", pathname_tmp)) {
[10:33:13.468]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.468]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:13.468]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.468]                         fi_tmp[["mtime"]])
[10:33:13.468]                     }
[10:33:13.468]                     tryCatch({
[10:33:13.468]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:13.468]                     }, error = function(ex) {
[10:33:13.468]                       msg <- conditionMessage(ex)
[10:33:13.468]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.468]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:13.468]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.468]                         fi_tmp[["mtime"]], msg)
[10:33:13.468]                       ex$message <- msg
[10:33:13.468]                       stop(ex)
[10:33:13.468]                     })
[10:33:13.468]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:13.468]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:13.468]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:13.468]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.468]                       fi <- file.info(pathname)
[10:33:13.468]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:13.468]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.468]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:13.468]                         fi[["size"]], fi[["mtime"]])
[10:33:13.468]                       stop(msg)
[10:33:13.468]                     }
[10:33:13.468]                     invisible(pathname)
[10:33:13.468]                   }
[10:33:13.468]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:13.468]                     rootPath = tempdir()) 
[10:33:13.468]                   {
[10:33:13.468]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:13.468]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:13.468]                       tmpdir = path, fileext = ".rds")
[10:33:13.468]                     save_rds(obj, file)
[10:33:13.468]                   }
[10:33:13.468]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:13.468]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.468]                   {
[10:33:13.468]                     inherits <- base::inherits
[10:33:13.468]                     invokeRestart <- base::invokeRestart
[10:33:13.468]                     is.null <- base::is.null
[10:33:13.468]                     muffled <- FALSE
[10:33:13.468]                     if (inherits(cond, "message")) {
[10:33:13.468]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:13.468]                       if (muffled) 
[10:33:13.468]                         invokeRestart("muffleMessage")
[10:33:13.468]                     }
[10:33:13.468]                     else if (inherits(cond, "warning")) {
[10:33:13.468]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:13.468]                       if (muffled) 
[10:33:13.468]                         invokeRestart("muffleWarning")
[10:33:13.468]                     }
[10:33:13.468]                     else if (inherits(cond, "condition")) {
[10:33:13.468]                       if (!is.null(pattern)) {
[10:33:13.468]                         computeRestarts <- base::computeRestarts
[10:33:13.468]                         grepl <- base::grepl
[10:33:13.468]                         restarts <- computeRestarts(cond)
[10:33:13.468]                         for (restart in restarts) {
[10:33:13.468]                           name <- restart$name
[10:33:13.468]                           if (is.null(name)) 
[10:33:13.468]                             next
[10:33:13.468]                           if (!grepl(pattern, name)) 
[10:33:13.468]                             next
[10:33:13.468]                           invokeRestart(restart)
[10:33:13.468]                           muffled <- TRUE
[10:33:13.468]                           break
[10:33:13.468]                         }
[10:33:13.468]                       }
[10:33:13.468]                     }
[10:33:13.468]                     invisible(muffled)
[10:33:13.468]                   }
[10:33:13.468]                   muffleCondition(cond)
[10:33:13.468]                 })
[10:33:13.468]             }))
[10:33:13.468]             future::FutureResult(value = ...future.value$value, 
[10:33:13.468]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.468]                   ...future.rng), globalenv = if (FALSE) 
[10:33:13.468]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:13.468]                     ...future.globalenv.names))
[10:33:13.468]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:13.468]         }, condition = base::local({
[10:33:13.468]             c <- base::c
[10:33:13.468]             inherits <- base::inherits
[10:33:13.468]             invokeRestart <- base::invokeRestart
[10:33:13.468]             length <- base::length
[10:33:13.468]             list <- base::list
[10:33:13.468]             seq.int <- base::seq.int
[10:33:13.468]             signalCondition <- base::signalCondition
[10:33:13.468]             sys.calls <- base::sys.calls
[10:33:13.468]             `[[` <- base::`[[`
[10:33:13.468]             `+` <- base::`+`
[10:33:13.468]             `<<-` <- base::`<<-`
[10:33:13.468]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:13.468]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:13.468]                   3L)]
[10:33:13.468]             }
[10:33:13.468]             function(cond) {
[10:33:13.468]                 is_error <- inherits(cond, "error")
[10:33:13.468]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:13.468]                   NULL)
[10:33:13.468]                 if (is_error) {
[10:33:13.468]                   sessionInformation <- function() {
[10:33:13.468]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:13.468]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:13.468]                       search = base::search(), system = base::Sys.info())
[10:33:13.468]                   }
[10:33:13.468]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.468]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:13.468]                     cond$call), session = sessionInformation(), 
[10:33:13.468]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:13.468]                   signalCondition(cond)
[10:33:13.468]                 }
[10:33:13.468]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:13.468]                 "immediateCondition"))) {
[10:33:13.468]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:13.468]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.468]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:13.468]                   if (TRUE && !signal) {
[10:33:13.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.468]                     {
[10:33:13.468]                       inherits <- base::inherits
[10:33:13.468]                       invokeRestart <- base::invokeRestart
[10:33:13.468]                       is.null <- base::is.null
[10:33:13.468]                       muffled <- FALSE
[10:33:13.468]                       if (inherits(cond, "message")) {
[10:33:13.468]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.468]                         if (muffled) 
[10:33:13.468]                           invokeRestart("muffleMessage")
[10:33:13.468]                       }
[10:33:13.468]                       else if (inherits(cond, "warning")) {
[10:33:13.468]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.468]                         if (muffled) 
[10:33:13.468]                           invokeRestart("muffleWarning")
[10:33:13.468]                       }
[10:33:13.468]                       else if (inherits(cond, "condition")) {
[10:33:13.468]                         if (!is.null(pattern)) {
[10:33:13.468]                           computeRestarts <- base::computeRestarts
[10:33:13.468]                           grepl <- base::grepl
[10:33:13.468]                           restarts <- computeRestarts(cond)
[10:33:13.468]                           for (restart in restarts) {
[10:33:13.468]                             name <- restart$name
[10:33:13.468]                             if (is.null(name)) 
[10:33:13.468]                               next
[10:33:13.468]                             if (!grepl(pattern, name)) 
[10:33:13.468]                               next
[10:33:13.468]                             invokeRestart(restart)
[10:33:13.468]                             muffled <- TRUE
[10:33:13.468]                             break
[10:33:13.468]                           }
[10:33:13.468]                         }
[10:33:13.468]                       }
[10:33:13.468]                       invisible(muffled)
[10:33:13.468]                     }
[10:33:13.468]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.468]                   }
[10:33:13.468]                 }
[10:33:13.468]                 else {
[10:33:13.468]                   if (TRUE) {
[10:33:13.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.468]                     {
[10:33:13.468]                       inherits <- base::inherits
[10:33:13.468]                       invokeRestart <- base::invokeRestart
[10:33:13.468]                       is.null <- base::is.null
[10:33:13.468]                       muffled <- FALSE
[10:33:13.468]                       if (inherits(cond, "message")) {
[10:33:13.468]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.468]                         if (muffled) 
[10:33:13.468]                           invokeRestart("muffleMessage")
[10:33:13.468]                       }
[10:33:13.468]                       else if (inherits(cond, "warning")) {
[10:33:13.468]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.468]                         if (muffled) 
[10:33:13.468]                           invokeRestart("muffleWarning")
[10:33:13.468]                       }
[10:33:13.468]                       else if (inherits(cond, "condition")) {
[10:33:13.468]                         if (!is.null(pattern)) {
[10:33:13.468]                           computeRestarts <- base::computeRestarts
[10:33:13.468]                           grepl <- base::grepl
[10:33:13.468]                           restarts <- computeRestarts(cond)
[10:33:13.468]                           for (restart in restarts) {
[10:33:13.468]                             name <- restart$name
[10:33:13.468]                             if (is.null(name)) 
[10:33:13.468]                               next
[10:33:13.468]                             if (!grepl(pattern, name)) 
[10:33:13.468]                               next
[10:33:13.468]                             invokeRestart(restart)
[10:33:13.468]                             muffled <- TRUE
[10:33:13.468]                             break
[10:33:13.468]                           }
[10:33:13.468]                         }
[10:33:13.468]                       }
[10:33:13.468]                       invisible(muffled)
[10:33:13.468]                     }
[10:33:13.468]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.468]                   }
[10:33:13.468]                 }
[10:33:13.468]             }
[10:33:13.468]         }))
[10:33:13.468]     }, error = function(ex) {
[10:33:13.468]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:13.468]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.468]                 ...future.rng), started = ...future.startTime, 
[10:33:13.468]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:13.468]             version = "1.8"), class = "FutureResult")
[10:33:13.468]     }, finally = {
[10:33:13.468]         if (!identical(...future.workdir, getwd())) 
[10:33:13.468]             setwd(...future.workdir)
[10:33:13.468]         {
[10:33:13.468]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:13.468]                 ...future.oldOptions$nwarnings <- NULL
[10:33:13.468]             }
[10:33:13.468]             base::options(...future.oldOptions)
[10:33:13.468]             if (.Platform$OS.type == "windows") {
[10:33:13.468]                 old_names <- names(...future.oldEnvVars)
[10:33:13.468]                 envs <- base::Sys.getenv()
[10:33:13.468]                 names <- names(envs)
[10:33:13.468]                 common <- intersect(names, old_names)
[10:33:13.468]                 added <- setdiff(names, old_names)
[10:33:13.468]                 removed <- setdiff(old_names, names)
[10:33:13.468]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:13.468]                   envs[common]]
[10:33:13.468]                 NAMES <- toupper(changed)
[10:33:13.468]                 args <- list()
[10:33:13.468]                 for (kk in seq_along(NAMES)) {
[10:33:13.468]                   name <- changed[[kk]]
[10:33:13.468]                   NAME <- NAMES[[kk]]
[10:33:13.468]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.468]                     next
[10:33:13.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.468]                 }
[10:33:13.468]                 NAMES <- toupper(added)
[10:33:13.468]                 for (kk in seq_along(NAMES)) {
[10:33:13.468]                   name <- added[[kk]]
[10:33:13.468]                   NAME <- NAMES[[kk]]
[10:33:13.468]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.468]                     next
[10:33:13.468]                   args[[name]] <- ""
[10:33:13.468]                 }
[10:33:13.468]                 NAMES <- toupper(removed)
[10:33:13.468]                 for (kk in seq_along(NAMES)) {
[10:33:13.468]                   name <- removed[[kk]]
[10:33:13.468]                   NAME <- NAMES[[kk]]
[10:33:13.468]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.468]                     next
[10:33:13.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.468]                 }
[10:33:13.468]                 if (length(args) > 0) 
[10:33:13.468]                   base::do.call(base::Sys.setenv, args = args)
[10:33:13.468]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:13.468]             }
[10:33:13.468]             else {
[10:33:13.468]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:13.468]             }
[10:33:13.468]             {
[10:33:13.468]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:13.468]                   0L) {
[10:33:13.468]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:13.468]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:13.468]                   base::options(opts)
[10:33:13.468]                 }
[10:33:13.468]                 {
[10:33:13.468]                   {
[10:33:13.468]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:13.468]                     NULL
[10:33:13.468]                   }
[10:33:13.468]                   options(future.plan = NULL)
[10:33:13.468]                   if (is.na(NA_character_)) 
[10:33:13.468]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.468]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:13.468]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:13.468]                     .init = FALSE)
[10:33:13.468]                 }
[10:33:13.468]             }
[10:33:13.468]         }
[10:33:13.468]     })
[10:33:13.468]     if (TRUE) {
[10:33:13.468]         base::sink(type = "output", split = FALSE)
[10:33:13.468]         if (TRUE) {
[10:33:13.468]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:13.468]         }
[10:33:13.468]         else {
[10:33:13.468]             ...future.result["stdout"] <- base::list(NULL)
[10:33:13.468]         }
[10:33:13.468]         base::close(...future.stdout)
[10:33:13.468]         ...future.stdout <- NULL
[10:33:13.468]     }
[10:33:13.468]     ...future.result$conditions <- ...future.conditions
[10:33:13.468]     ...future.result$finished <- base::Sys.time()
[10:33:13.468]     ...future.result
[10:33:13.468] }
[10:33:13.470] requestCore(): workers = 2
[10:33:13.473] MulticoreFuture started
[10:33:13.473] - Launch lazy future ... done
[10:33:13.473] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.474] getGlobalsAndPackages() ...
[10:33:13.474] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.474] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:13.474] List of future strategies:
[10:33:13.474] 1. sequential:
[10:33:13.474]    - args: function (..., envir = parent.frame())
[10:33:13.474]    - tweaked: FALSE
[10:33:13.474]    - call: NULL
[10:33:13.475] plan(): nbrOfWorkers() = 1
[10:33:13.476] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:13.476] Searching for globals ... DONE
[10:33:13.476] Resolving globals: TRUE
[10:33:13.477] Resolving any globals that are futures ...
[10:33:13.477] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:13.477] Resolving any globals that are futures ... DONE
[10:33:13.477] plan(): Setting new future strategy stack:
[10:33:13.478] Resolving futures part of globals (recursively) ...
[10:33:13.477] List of future strategies:
[10:33:13.477] 1. multicore:
[10:33:13.477]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.477]    - tweaked: FALSE
[10:33:13.477]    - call: plan(strategy)
[10:33:13.478] resolve() on list ...
[10:33:13.478]  recursive: 99
[10:33:13.478]  length: 1
[10:33:13.479]  elements: ‘a’
[10:33:13.482] plan(): nbrOfWorkers() = 2
[10:33:13.483] Future #1
[10:33:13.483] result() for MulticoreFuture ...
[10:33:13.484] result() for MulticoreFuture ...
[10:33:13.484] result() for MulticoreFuture ... done
[10:33:13.484] result() for MulticoreFuture ... done
[10:33:13.485] result() for MulticoreFuture ...
[10:33:13.485] result() for MulticoreFuture ... done
[10:33:13.485] A MulticoreFuture was resolved
[10:33:13.485]  length: 0 (resolved future 1)
[10:33:13.486] resolve() on list ... DONE
[10:33:13.486] - globals: [1] ‘a’
[10:33:13.486] Resolving futures part of globals (recursively) ... DONE
[10:33:13.489] The total size of the 1 globals is 1.57 MiB (1647008 bytes)
[10:33:13.489] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[10:33:13.490] - globals: [1] ‘a’
[10:33:13.490] - packages: [1] ‘future’
[10:33:13.490] getGlobalsAndPackages() ... DONE
[10:33:13.490] run() for ‘Future’ ...
[10:33:13.490] - state: ‘created’
[10:33:13.491] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:13.498] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:13.498] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:13.498]   - Field: ‘label’
[10:33:13.498]   - Field: ‘local’
[10:33:13.498]   - Field: ‘owner’
[10:33:13.499]   - Field: ‘envir’
[10:33:13.499]   - Field: ‘workers’
[10:33:13.499]   - Field: ‘packages’
[10:33:13.499]   - Field: ‘gc’
[10:33:13.499]   - Field: ‘job’
[10:33:13.500]   - Field: ‘conditions’
[10:33:13.500]   - Field: ‘expr’
[10:33:13.500]   - Field: ‘uuid’
[10:33:13.500]   - Field: ‘seed’
[10:33:13.500]   - Field: ‘version’
[10:33:13.500]   - Field: ‘result’
[10:33:13.500]   - Field: ‘asynchronous’
[10:33:13.500]   - Field: ‘calls’
[10:33:13.501]   - Field: ‘globals’
[10:33:13.501]   - Field: ‘stdout’
[10:33:13.501]   - Field: ‘earlySignal’
[10:33:13.501]   - Field: ‘lazy’
[10:33:13.501]   - Field: ‘state’
[10:33:13.501] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:13.502] - Launch lazy future ...
[10:33:13.502] Packages needed by the future expression (n = 1): ‘future’
[10:33:13.502] Packages needed by future strategies (n = 0): <none>
[10:33:13.503] {
[10:33:13.503]     {
[10:33:13.503]         {
[10:33:13.503]             ...future.startTime <- base::Sys.time()
[10:33:13.503]             {
[10:33:13.503]                 {
[10:33:13.503]                   {
[10:33:13.503]                     {
[10:33:13.503]                       {
[10:33:13.503]                         base::local({
[10:33:13.503]                           has_future <- base::requireNamespace("future", 
[10:33:13.503]                             quietly = TRUE)
[10:33:13.503]                           if (has_future) {
[10:33:13.503]                             ns <- base::getNamespace("future")
[10:33:13.503]                             version <- ns[[".package"]][["version"]]
[10:33:13.503]                             if (is.null(version)) 
[10:33:13.503]                               version <- utils::packageVersion("future")
[10:33:13.503]                           }
[10:33:13.503]                           else {
[10:33:13.503]                             version <- NULL
[10:33:13.503]                           }
[10:33:13.503]                           if (!has_future || version < "1.8.0") {
[10:33:13.503]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:13.503]                               "", base::R.version$version.string), 
[10:33:13.503]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:13.503]                                 base::R.version$platform, 8 * 
[10:33:13.503]                                   base::.Machine$sizeof.pointer), 
[10:33:13.503]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:13.503]                                 "release", "version")], collapse = " "), 
[10:33:13.503]                               hostname = base::Sys.info()[["nodename"]])
[10:33:13.503]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:13.503]                               info)
[10:33:13.503]                             info <- base::paste(info, collapse = "; ")
[10:33:13.503]                             if (!has_future) {
[10:33:13.503]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:13.503]                                 info)
[10:33:13.503]                             }
[10:33:13.503]                             else {
[10:33:13.503]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:13.503]                                 info, version)
[10:33:13.503]                             }
[10:33:13.503]                             base::stop(msg)
[10:33:13.503]                           }
[10:33:13.503]                         })
[10:33:13.503]                       }
[10:33:13.503]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:13.503]                       base::options(mc.cores = 1L)
[10:33:13.503]                     }
[10:33:13.503]                     base::local({
[10:33:13.503]                       for (pkg in "future") {
[10:33:13.503]                         base::loadNamespace(pkg)
[10:33:13.503]                         base::library(pkg, character.only = TRUE)
[10:33:13.503]                       }
[10:33:13.503]                     })
[10:33:13.503]                   }
[10:33:13.503]                   ...future.strategy.old <- future::plan("list")
[10:33:13.503]                   options(future.plan = NULL)
[10:33:13.503]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.503]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:13.503]                 }
[10:33:13.503]                 ...future.workdir <- getwd()
[10:33:13.503]             }
[10:33:13.503]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:13.503]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:13.503]         }
[10:33:13.503]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:13.503]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:13.503]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:13.503]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:13.503]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:13.503]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:13.503]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:13.503]             base::names(...future.oldOptions))
[10:33:13.503]     }
[10:33:13.503]     if (FALSE) {
[10:33:13.503]     }
[10:33:13.503]     else {
[10:33:13.503]         if (TRUE) {
[10:33:13.503]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:13.503]                 open = "w")
[10:33:13.503]         }
[10:33:13.503]         else {
[10:33:13.503]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:13.503]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:13.503]         }
[10:33:13.503]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:13.503]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:13.503]             base::sink(type = "output", split = FALSE)
[10:33:13.503]             base::close(...future.stdout)
[10:33:13.503]         }, add = TRUE)
[10:33:13.503]     }
[10:33:13.503]     ...future.frame <- base::sys.nframe()
[10:33:13.503]     ...future.conditions <- base::list()
[10:33:13.503]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:13.503]     if (FALSE) {
[10:33:13.503]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:13.503]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:13.503]     }
[10:33:13.503]     ...future.result <- base::tryCatch({
[10:33:13.503]         base::withCallingHandlers({
[10:33:13.503]             ...future.value <- base::withVisible(base::local({
[10:33:13.503]                 withCallingHandlers({
[10:33:13.503]                   value(a) + 1
[10:33:13.503]                 }, immediateCondition = function(cond) {
[10:33:13.503]                   save_rds <- function (object, pathname, ...) 
[10:33:13.503]                   {
[10:33:13.503]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:13.503]                     if (file_test("-f", pathname_tmp)) {
[10:33:13.503]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.503]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:13.503]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.503]                         fi_tmp[["mtime"]])
[10:33:13.503]                     }
[10:33:13.503]                     tryCatch({
[10:33:13.503]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:13.503]                     }, error = function(ex) {
[10:33:13.503]                       msg <- conditionMessage(ex)
[10:33:13.503]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.503]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:13.503]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.503]                         fi_tmp[["mtime"]], msg)
[10:33:13.503]                       ex$message <- msg
[10:33:13.503]                       stop(ex)
[10:33:13.503]                     })
[10:33:13.503]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:13.503]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:13.503]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:13.503]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.503]                       fi <- file.info(pathname)
[10:33:13.503]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:13.503]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.503]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:13.503]                         fi[["size"]], fi[["mtime"]])
[10:33:13.503]                       stop(msg)
[10:33:13.503]                     }
[10:33:13.503]                     invisible(pathname)
[10:33:13.503]                   }
[10:33:13.503]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:13.503]                     rootPath = tempdir()) 
[10:33:13.503]                   {
[10:33:13.503]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:13.503]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:13.503]                       tmpdir = path, fileext = ".rds")
[10:33:13.503]                     save_rds(obj, file)
[10:33:13.503]                   }
[10:33:13.503]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:13.503]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.503]                   {
[10:33:13.503]                     inherits <- base::inherits
[10:33:13.503]                     invokeRestart <- base::invokeRestart
[10:33:13.503]                     is.null <- base::is.null
[10:33:13.503]                     muffled <- FALSE
[10:33:13.503]                     if (inherits(cond, "message")) {
[10:33:13.503]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:13.503]                       if (muffled) 
[10:33:13.503]                         invokeRestart("muffleMessage")
[10:33:13.503]                     }
[10:33:13.503]                     else if (inherits(cond, "warning")) {
[10:33:13.503]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:13.503]                       if (muffled) 
[10:33:13.503]                         invokeRestart("muffleWarning")
[10:33:13.503]                     }
[10:33:13.503]                     else if (inherits(cond, "condition")) {
[10:33:13.503]                       if (!is.null(pattern)) {
[10:33:13.503]                         computeRestarts <- base::computeRestarts
[10:33:13.503]                         grepl <- base::grepl
[10:33:13.503]                         restarts <- computeRestarts(cond)
[10:33:13.503]                         for (restart in restarts) {
[10:33:13.503]                           name <- restart$name
[10:33:13.503]                           if (is.null(name)) 
[10:33:13.503]                             next
[10:33:13.503]                           if (!grepl(pattern, name)) 
[10:33:13.503]                             next
[10:33:13.503]                           invokeRestart(restart)
[10:33:13.503]                           muffled <- TRUE
[10:33:13.503]                           break
[10:33:13.503]                         }
[10:33:13.503]                       }
[10:33:13.503]                     }
[10:33:13.503]                     invisible(muffled)
[10:33:13.503]                   }
[10:33:13.503]                   muffleCondition(cond)
[10:33:13.503]                 })
[10:33:13.503]             }))
[10:33:13.503]             future::FutureResult(value = ...future.value$value, 
[10:33:13.503]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.503]                   ...future.rng), globalenv = if (FALSE) 
[10:33:13.503]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:13.503]                     ...future.globalenv.names))
[10:33:13.503]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:13.503]         }, condition = base::local({
[10:33:13.503]             c <- base::c
[10:33:13.503]             inherits <- base::inherits
[10:33:13.503]             invokeRestart <- base::invokeRestart
[10:33:13.503]             length <- base::length
[10:33:13.503]             list <- base::list
[10:33:13.503]             seq.int <- base::seq.int
[10:33:13.503]             signalCondition <- base::signalCondition
[10:33:13.503]             sys.calls <- base::sys.calls
[10:33:13.503]             `[[` <- base::`[[`
[10:33:13.503]             `+` <- base::`+`
[10:33:13.503]             `<<-` <- base::`<<-`
[10:33:13.503]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:13.503]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:13.503]                   3L)]
[10:33:13.503]             }
[10:33:13.503]             function(cond) {
[10:33:13.503]                 is_error <- inherits(cond, "error")
[10:33:13.503]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:13.503]                   NULL)
[10:33:13.503]                 if (is_error) {
[10:33:13.503]                   sessionInformation <- function() {
[10:33:13.503]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:13.503]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:13.503]                       search = base::search(), system = base::Sys.info())
[10:33:13.503]                   }
[10:33:13.503]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.503]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:13.503]                     cond$call), session = sessionInformation(), 
[10:33:13.503]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:13.503]                   signalCondition(cond)
[10:33:13.503]                 }
[10:33:13.503]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:13.503]                 "immediateCondition"))) {
[10:33:13.503]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:13.503]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.503]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:13.503]                   if (TRUE && !signal) {
[10:33:13.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.503]                     {
[10:33:13.503]                       inherits <- base::inherits
[10:33:13.503]                       invokeRestart <- base::invokeRestart
[10:33:13.503]                       is.null <- base::is.null
[10:33:13.503]                       muffled <- FALSE
[10:33:13.503]                       if (inherits(cond, "message")) {
[10:33:13.503]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.503]                         if (muffled) 
[10:33:13.503]                           invokeRestart("muffleMessage")
[10:33:13.503]                       }
[10:33:13.503]                       else if (inherits(cond, "warning")) {
[10:33:13.503]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.503]                         if (muffled) 
[10:33:13.503]                           invokeRestart("muffleWarning")
[10:33:13.503]                       }
[10:33:13.503]                       else if (inherits(cond, "condition")) {
[10:33:13.503]                         if (!is.null(pattern)) {
[10:33:13.503]                           computeRestarts <- base::computeRestarts
[10:33:13.503]                           grepl <- base::grepl
[10:33:13.503]                           restarts <- computeRestarts(cond)
[10:33:13.503]                           for (restart in restarts) {
[10:33:13.503]                             name <- restart$name
[10:33:13.503]                             if (is.null(name)) 
[10:33:13.503]                               next
[10:33:13.503]                             if (!grepl(pattern, name)) 
[10:33:13.503]                               next
[10:33:13.503]                             invokeRestart(restart)
[10:33:13.503]                             muffled <- TRUE
[10:33:13.503]                             break
[10:33:13.503]                           }
[10:33:13.503]                         }
[10:33:13.503]                       }
[10:33:13.503]                       invisible(muffled)
[10:33:13.503]                     }
[10:33:13.503]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.503]                   }
[10:33:13.503]                 }
[10:33:13.503]                 else {
[10:33:13.503]                   if (TRUE) {
[10:33:13.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.503]                     {
[10:33:13.503]                       inherits <- base::inherits
[10:33:13.503]                       invokeRestart <- base::invokeRestart
[10:33:13.503]                       is.null <- base::is.null
[10:33:13.503]                       muffled <- FALSE
[10:33:13.503]                       if (inherits(cond, "message")) {
[10:33:13.503]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.503]                         if (muffled) 
[10:33:13.503]                           invokeRestart("muffleMessage")
[10:33:13.503]                       }
[10:33:13.503]                       else if (inherits(cond, "warning")) {
[10:33:13.503]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.503]                         if (muffled) 
[10:33:13.503]                           invokeRestart("muffleWarning")
[10:33:13.503]                       }
[10:33:13.503]                       else if (inherits(cond, "condition")) {
[10:33:13.503]                         if (!is.null(pattern)) {
[10:33:13.503]                           computeRestarts <- base::computeRestarts
[10:33:13.503]                           grepl <- base::grepl
[10:33:13.503]                           restarts <- computeRestarts(cond)
[10:33:13.503]                           for (restart in restarts) {
[10:33:13.503]                             name <- restart$name
[10:33:13.503]                             if (is.null(name)) 
[10:33:13.503]                               next
[10:33:13.503]                             if (!grepl(pattern, name)) 
[10:33:13.503]                               next
[10:33:13.503]                             invokeRestart(restart)
[10:33:13.503]                             muffled <- TRUE
[10:33:13.503]                             break
[10:33:13.503]                           }
[10:33:13.503]                         }
[10:33:13.503]                       }
[10:33:13.503]                       invisible(muffled)
[10:33:13.503]                     }
[10:33:13.503]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.503]                   }
[10:33:13.503]                 }
[10:33:13.503]             }
[10:33:13.503]         }))
[10:33:13.503]     }, error = function(ex) {
[10:33:13.503]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:13.503]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.503]                 ...future.rng), started = ...future.startTime, 
[10:33:13.503]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:13.503]             version = "1.8"), class = "FutureResult")
[10:33:13.503]     }, finally = {
[10:33:13.503]         if (!identical(...future.workdir, getwd())) 
[10:33:13.503]             setwd(...future.workdir)
[10:33:13.503]         {
[10:33:13.503]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:13.503]                 ...future.oldOptions$nwarnings <- NULL
[10:33:13.503]             }
[10:33:13.503]             base::options(...future.oldOptions)
[10:33:13.503]             if (.Platform$OS.type == "windows") {
[10:33:13.503]                 old_names <- names(...future.oldEnvVars)
[10:33:13.503]                 envs <- base::Sys.getenv()
[10:33:13.503]                 names <- names(envs)
[10:33:13.503]                 common <- intersect(names, old_names)
[10:33:13.503]                 added <- setdiff(names, old_names)
[10:33:13.503]                 removed <- setdiff(old_names, names)
[10:33:13.503]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:13.503]                   envs[common]]
[10:33:13.503]                 NAMES <- toupper(changed)
[10:33:13.503]                 args <- list()
[10:33:13.503]                 for (kk in seq_along(NAMES)) {
[10:33:13.503]                   name <- changed[[kk]]
[10:33:13.503]                   NAME <- NAMES[[kk]]
[10:33:13.503]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.503]                     next
[10:33:13.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.503]                 }
[10:33:13.503]                 NAMES <- toupper(added)
[10:33:13.503]                 for (kk in seq_along(NAMES)) {
[10:33:13.503]                   name <- added[[kk]]
[10:33:13.503]                   NAME <- NAMES[[kk]]
[10:33:13.503]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.503]                     next
[10:33:13.503]                   args[[name]] <- ""
[10:33:13.503]                 }
[10:33:13.503]                 NAMES <- toupper(removed)
[10:33:13.503]                 for (kk in seq_along(NAMES)) {
[10:33:13.503]                   name <- removed[[kk]]
[10:33:13.503]                   NAME <- NAMES[[kk]]
[10:33:13.503]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.503]                     next
[10:33:13.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.503]                 }
[10:33:13.503]                 if (length(args) > 0) 
[10:33:13.503]                   base::do.call(base::Sys.setenv, args = args)
[10:33:13.503]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:13.503]             }
[10:33:13.503]             else {
[10:33:13.503]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:13.503]             }
[10:33:13.503]             {
[10:33:13.503]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:13.503]                   0L) {
[10:33:13.503]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:13.503]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:13.503]                   base::options(opts)
[10:33:13.503]                 }
[10:33:13.503]                 {
[10:33:13.503]                   {
[10:33:13.503]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:13.503]                     NULL
[10:33:13.503]                   }
[10:33:13.503]                   options(future.plan = NULL)
[10:33:13.503]                   if (is.na(NA_character_)) 
[10:33:13.503]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.503]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:13.503]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:13.503]                     .init = FALSE)
[10:33:13.503]                 }
[10:33:13.503]             }
[10:33:13.503]         }
[10:33:13.503]     })
[10:33:13.503]     if (TRUE) {
[10:33:13.503]         base::sink(type = "output", split = FALSE)
[10:33:13.503]         if (TRUE) {
[10:33:13.503]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:13.503]         }
[10:33:13.503]         else {
[10:33:13.503]             ...future.result["stdout"] <- base::list(NULL)
[10:33:13.503]         }
[10:33:13.503]         base::close(...future.stdout)
[10:33:13.503]         ...future.stdout <- NULL
[10:33:13.503]     }
[10:33:13.503]     ...future.result$conditions <- ...future.conditions
[10:33:13.503]     ...future.result$finished <- base::Sys.time()
[10:33:13.503]     ...future.result
[10:33:13.503] }
[10:33:13.505] assign_globals() ...
[10:33:13.505] List of 1
[10:33:13.505]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55aa53258de0> 
[10:33:13.505]  - attr(*, "where")=List of 1
[10:33:13.505]   ..$ a:<environment: R_EmptyEnv> 
[10:33:13.505]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:13.505]  - attr(*, "resolved")= logi TRUE
[10:33:13.505]  - attr(*, "total_size")= num 1647008
[10:33:13.505]  - attr(*, "already-done")= logi TRUE
[10:33:13.509] - copied ‘a’ to environment
[10:33:13.509] assign_globals() ... done
[10:33:13.509] requestCore(): workers = 2
[10:33:13.511] MulticoreFuture started
[10:33:13.511] - Launch lazy future ... done
[10:33:13.512] run() for ‘MulticoreFuture’ ... done
[10:33:13.512] result() for MulticoreFuture ...
[10:33:13.512] plan(): Setting new future strategy stack:
[10:33:13.513] List of future strategies:
[10:33:13.513] 1. sequential:
[10:33:13.513]    - args: function (..., envir = parent.frame())
[10:33:13.513]    - tweaked: FALSE
[10:33:13.513]    - call: NULL
[10:33:13.514] plan(): nbrOfWorkers() = 1
[10:33:13.517] plan(): Setting new future strategy stack:
[10:33:13.517] List of future strategies:
[10:33:13.517] 1. multicore:
[10:33:13.517]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.517]    - tweaked: FALSE
[10:33:13.517]    - call: plan(strategy)
[10:33:13.522] plan(): nbrOfWorkers() = 2
[10:33:13.523] result() for MulticoreFuture ...
[10:33:13.523] result() for MulticoreFuture ... done
[10:33:13.523] signalConditions() ...
[10:33:13.523]  - include = ‘immediateCondition’
[10:33:13.524]  - exclude = 
[10:33:13.524]  - resignal = FALSE
[10:33:13.524]  - Number of conditions: 4
[10:33:13.524] signalConditions() ... done
[10:33:13.524] result() for MulticoreFuture ... done
[10:33:13.524] result() for MulticoreFuture ...
[10:33:13.524] result() for MulticoreFuture ... done
[10:33:13.525] signalConditions() ...
[10:33:13.525]  - include = ‘immediateCondition’
[10:33:13.525]  - exclude = 
[10:33:13.525]  - resignal = FALSE
[10:33:13.525]  - Number of conditions: 4
[10:33:13.525] signalConditions() ... done
[10:33:13.525] Future state: ‘finished’
[10:33:13.525] result() for MulticoreFuture ...
[10:33:13.526] result() for MulticoreFuture ... done
[10:33:13.526] signalConditions() ...
[10:33:13.526]  - include = ‘condition’
[10:33:13.526]  - exclude = ‘immediateCondition’
[10:33:13.526]  - resignal = TRUE
[10:33:13.526]  - Number of conditions: 4
[10:33:13.526]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.515] result() for MulticoreFuture ...
[10:33:13.526]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.515] result() for MulticoreFuture ... done
[10:33:13.527]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.515] result() for MulticoreFuture ...
[10:33:13.527]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.516] result() for MulticoreFuture ... done
[10:33:13.527] signalConditions() ... done
value(b) = 2
[10:33:13.527] result() for MulticoreFuture ...
[10:33:13.527] result() for MulticoreFuture ... done
[10:33:13.527] result() for MulticoreFuture ...
[10:33:13.527] result() for MulticoreFuture ... done
[10:33:13.528] signalConditions() ...
[10:33:13.528]  - include = ‘immediateCondition’
[10:33:13.528]  - exclude = 
[10:33:13.528]  - resignal = FALSE
[10:33:13.528]  - Number of conditions: 4
[10:33:13.528] signalConditions() ... done
[10:33:13.528] Future state: ‘finished’
[10:33:13.528] result() for MulticoreFuture ...
[10:33:13.529] result() for MulticoreFuture ... done
[10:33:13.529] signalConditions() ...
[10:33:13.529]  - include = ‘condition’
[10:33:13.529]  - exclude = ‘immediateCondition’
[10:33:13.529]  - resignal = TRUE
[10:33:13.529]  - Number of conditions: 4
[10:33:13.529]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.515] result() for MulticoreFuture ...
[10:33:13.529]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.515] result() for MulticoreFuture ... done
[10:33:13.530]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.515] result() for MulticoreFuture ...
[10:33:13.530]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.516] result() for MulticoreFuture ... done
[10:33:13.530] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.530] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.530] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:13.531] 
[10:33:13.531] Searching for globals ... DONE
[10:33:13.531] - globals: [0] <none>
[10:33:13.531] getGlobalsAndPackages() ... DONE
[10:33:13.532] run() for ‘Future’ ...
[10:33:13.532] - state: ‘created’
[10:33:13.532] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:13.536] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:13.536] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:13.536]   - Field: ‘label’
[10:33:13.537]   - Field: ‘local’
[10:33:13.537]   - Field: ‘owner’
[10:33:13.537]   - Field: ‘envir’
[10:33:13.537]   - Field: ‘workers’
[10:33:13.537]   - Field: ‘packages’
[10:33:13.537]   - Field: ‘gc’
[10:33:13.537]   - Field: ‘job’
[10:33:13.537]   - Field: ‘conditions’
[10:33:13.538]   - Field: ‘expr’
[10:33:13.538]   - Field: ‘uuid’
[10:33:13.538]   - Field: ‘seed’
[10:33:13.538]   - Field: ‘version’
[10:33:13.538]   - Field: ‘result’
[10:33:13.538]   - Field: ‘asynchronous’
[10:33:13.538]   - Field: ‘calls’
[10:33:13.538]   - Field: ‘globals’
[10:33:13.538]   - Field: ‘stdout’
[10:33:13.539]   - Field: ‘earlySignal’
[10:33:13.539]   - Field: ‘lazy’
[10:33:13.539]   - Field: ‘state’
[10:33:13.541] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:13.541] - Launch lazy future ...
[10:33:13.542] Packages needed by the future expression (n = 0): <none>
[10:33:13.542] Packages needed by future strategies (n = 0): <none>
[10:33:13.543] {
[10:33:13.543]     {
[10:33:13.543]         {
[10:33:13.543]             ...future.startTime <- base::Sys.time()
[10:33:13.543]             {
[10:33:13.543]                 {
[10:33:13.543]                   {
[10:33:13.543]                     {
[10:33:13.543]                       base::local({
[10:33:13.543]                         has_future <- base::requireNamespace("future", 
[10:33:13.543]                           quietly = TRUE)
[10:33:13.543]                         if (has_future) {
[10:33:13.543]                           ns <- base::getNamespace("future")
[10:33:13.543]                           version <- ns[[".package"]][["version"]]
[10:33:13.543]                           if (is.null(version)) 
[10:33:13.543]                             version <- utils::packageVersion("future")
[10:33:13.543]                         }
[10:33:13.543]                         else {
[10:33:13.543]                           version <- NULL
[10:33:13.543]                         }
[10:33:13.543]                         if (!has_future || version < "1.8.0") {
[10:33:13.543]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:13.543]                             "", base::R.version$version.string), 
[10:33:13.543]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:13.543]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:13.543]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:13.543]                               "release", "version")], collapse = " "), 
[10:33:13.543]                             hostname = base::Sys.info()[["nodename"]])
[10:33:13.543]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:13.543]                             info)
[10:33:13.543]                           info <- base::paste(info, collapse = "; ")
[10:33:13.543]                           if (!has_future) {
[10:33:13.543]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:13.543]                               info)
[10:33:13.543]                           }
[10:33:13.543]                           else {
[10:33:13.543]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:13.543]                               info, version)
[10:33:13.543]                           }
[10:33:13.543]                           base::stop(msg)
[10:33:13.543]                         }
[10:33:13.543]                       })
[10:33:13.543]                     }
[10:33:13.543]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:13.543]                     base::options(mc.cores = 1L)
[10:33:13.543]                   }
[10:33:13.543]                   ...future.strategy.old <- future::plan("list")
[10:33:13.543]                   options(future.plan = NULL)
[10:33:13.543]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.543]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:13.543]                 }
[10:33:13.543]                 ...future.workdir <- getwd()
[10:33:13.543]             }
[10:33:13.543]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:13.543]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:13.543]         }
[10:33:13.543]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:13.543]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:13.543]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:13.543]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:13.543]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:13.543]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:13.543]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:13.543]             base::names(...future.oldOptions))
[10:33:13.543]     }
[10:33:13.543]     if (FALSE) {
[10:33:13.543]     }
[10:33:13.543]     else {
[10:33:13.543]         if (TRUE) {
[10:33:13.543]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:13.543]                 open = "w")
[10:33:13.543]         }
[10:33:13.543]         else {
[10:33:13.543]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:13.543]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:13.543]         }
[10:33:13.543]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:13.543]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:13.543]             base::sink(type = "output", split = FALSE)
[10:33:13.543]             base::close(...future.stdout)
[10:33:13.543]         }, add = TRUE)
[10:33:13.543]     }
[10:33:13.543]     ...future.frame <- base::sys.nframe()
[10:33:13.543]     ...future.conditions <- base::list()
[10:33:13.543]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:13.543]     if (FALSE) {
[10:33:13.543]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:13.543]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:13.543]     }
[10:33:13.543]     ...future.result <- base::tryCatch({
[10:33:13.543]         base::withCallingHandlers({
[10:33:13.543]             ...future.value <- base::withVisible(base::local({
[10:33:13.543]                 withCallingHandlers({
[10:33:13.543]                   1
[10:33:13.543]                 }, immediateCondition = function(cond) {
[10:33:13.543]                   save_rds <- function (object, pathname, ...) 
[10:33:13.543]                   {
[10:33:13.543]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:13.543]                     if (file_test("-f", pathname_tmp)) {
[10:33:13.543]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.543]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:13.543]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.543]                         fi_tmp[["mtime"]])
[10:33:13.543]                     }
[10:33:13.543]                     tryCatch({
[10:33:13.543]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:13.543]                     }, error = function(ex) {
[10:33:13.543]                       msg <- conditionMessage(ex)
[10:33:13.543]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.543]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:13.543]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.543]                         fi_tmp[["mtime"]], msg)
[10:33:13.543]                       ex$message <- msg
[10:33:13.543]                       stop(ex)
[10:33:13.543]                     })
[10:33:13.543]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:13.543]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:13.543]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:13.543]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.543]                       fi <- file.info(pathname)
[10:33:13.543]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:13.543]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.543]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:13.543]                         fi[["size"]], fi[["mtime"]])
[10:33:13.543]                       stop(msg)
[10:33:13.543]                     }
[10:33:13.543]                     invisible(pathname)
[10:33:13.543]                   }
[10:33:13.543]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:13.543]                     rootPath = tempdir()) 
[10:33:13.543]                   {
[10:33:13.543]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:13.543]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:13.543]                       tmpdir = path, fileext = ".rds")
[10:33:13.543]                     save_rds(obj, file)
[10:33:13.543]                   }
[10:33:13.543]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:13.543]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.543]                   {
[10:33:13.543]                     inherits <- base::inherits
[10:33:13.543]                     invokeRestart <- base::invokeRestart
[10:33:13.543]                     is.null <- base::is.null
[10:33:13.543]                     muffled <- FALSE
[10:33:13.543]                     if (inherits(cond, "message")) {
[10:33:13.543]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:13.543]                       if (muffled) 
[10:33:13.543]                         invokeRestart("muffleMessage")
[10:33:13.543]                     }
[10:33:13.543]                     else if (inherits(cond, "warning")) {
[10:33:13.543]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:13.543]                       if (muffled) 
[10:33:13.543]                         invokeRestart("muffleWarning")
[10:33:13.543]                     }
[10:33:13.543]                     else if (inherits(cond, "condition")) {
[10:33:13.543]                       if (!is.null(pattern)) {
[10:33:13.543]                         computeRestarts <- base::computeRestarts
[10:33:13.543]                         grepl <- base::grepl
[10:33:13.543]                         restarts <- computeRestarts(cond)
[10:33:13.543]                         for (restart in restarts) {
[10:33:13.543]                           name <- restart$name
[10:33:13.543]                           if (is.null(name)) 
[10:33:13.543]                             next
[10:33:13.543]                           if (!grepl(pattern, name)) 
[10:33:13.543]                             next
[10:33:13.543]                           invokeRestart(restart)
[10:33:13.543]                           muffled <- TRUE
[10:33:13.543]                           break
[10:33:13.543]                         }
[10:33:13.543]                       }
[10:33:13.543]                     }
[10:33:13.543]                     invisible(muffled)
[10:33:13.543]                   }
[10:33:13.543]                   muffleCondition(cond)
[10:33:13.543]                 })
[10:33:13.543]             }))
[10:33:13.543]             future::FutureResult(value = ...future.value$value, 
[10:33:13.543]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.543]                   ...future.rng), globalenv = if (FALSE) 
[10:33:13.543]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:13.543]                     ...future.globalenv.names))
[10:33:13.543]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:13.543]         }, condition = base::local({
[10:33:13.543]             c <- base::c
[10:33:13.543]             inherits <- base::inherits
[10:33:13.543]             invokeRestart <- base::invokeRestart
[10:33:13.543]             length <- base::length
[10:33:13.543]             list <- base::list
[10:33:13.543]             seq.int <- base::seq.int
[10:33:13.543]             signalCondition <- base::signalCondition
[10:33:13.543]             sys.calls <- base::sys.calls
[10:33:13.543]             `[[` <- base::`[[`
[10:33:13.543]             `+` <- base::`+`
[10:33:13.543]             `<<-` <- base::`<<-`
[10:33:13.543]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:13.543]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:13.543]                   3L)]
[10:33:13.543]             }
[10:33:13.543]             function(cond) {
[10:33:13.543]                 is_error <- inherits(cond, "error")
[10:33:13.543]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:13.543]                   NULL)
[10:33:13.543]                 if (is_error) {
[10:33:13.543]                   sessionInformation <- function() {
[10:33:13.543]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:13.543]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:13.543]                       search = base::search(), system = base::Sys.info())
[10:33:13.543]                   }
[10:33:13.543]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.543]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:13.543]                     cond$call), session = sessionInformation(), 
[10:33:13.543]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:13.543]                   signalCondition(cond)
[10:33:13.543]                 }
[10:33:13.543]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:13.543]                 "immediateCondition"))) {
[10:33:13.543]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:13.543]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.543]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:13.543]                   if (TRUE && !signal) {
[10:33:13.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.543]                     {
[10:33:13.543]                       inherits <- base::inherits
[10:33:13.543]                       invokeRestart <- base::invokeRestart
[10:33:13.543]                       is.null <- base::is.null
[10:33:13.543]                       muffled <- FALSE
[10:33:13.543]                       if (inherits(cond, "message")) {
[10:33:13.543]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.543]                         if (muffled) 
[10:33:13.543]                           invokeRestart("muffleMessage")
[10:33:13.543]                       }
[10:33:13.543]                       else if (inherits(cond, "warning")) {
[10:33:13.543]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.543]                         if (muffled) 
[10:33:13.543]                           invokeRestart("muffleWarning")
[10:33:13.543]                       }
[10:33:13.543]                       else if (inherits(cond, "condition")) {
[10:33:13.543]                         if (!is.null(pattern)) {
[10:33:13.543]                           computeRestarts <- base::computeRestarts
[10:33:13.543]                           grepl <- base::grepl
[10:33:13.543]                           restarts <- computeRestarts(cond)
[10:33:13.543]                           for (restart in restarts) {
[10:33:13.543]                             name <- restart$name
[10:33:13.543]                             if (is.null(name)) 
[10:33:13.543]                               next
[10:33:13.543]                             if (!grepl(pattern, name)) 
[10:33:13.543]                               next
[10:33:13.543]                             invokeRestart(restart)
[10:33:13.543]                             muffled <- TRUE
[10:33:13.543]                             break
[10:33:13.543]                           }
[10:33:13.543]                         }
[10:33:13.543]                       }
[10:33:13.543]                       invisible(muffled)
[10:33:13.543]                     }
[10:33:13.543]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.543]                   }
[10:33:13.543]                 }
[10:33:13.543]                 else {
[10:33:13.543]                   if (TRUE) {
[10:33:13.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.543]                     {
[10:33:13.543]                       inherits <- base::inherits
[10:33:13.543]                       invokeRestart <- base::invokeRestart
[10:33:13.543]                       is.null <- base::is.null
[10:33:13.543]                       muffled <- FALSE
[10:33:13.543]                       if (inherits(cond, "message")) {
[10:33:13.543]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.543]                         if (muffled) 
[10:33:13.543]                           invokeRestart("muffleMessage")
[10:33:13.543]                       }
[10:33:13.543]                       else if (inherits(cond, "warning")) {
[10:33:13.543]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.543]                         if (muffled) 
[10:33:13.543]                           invokeRestart("muffleWarning")
[10:33:13.543]                       }
[10:33:13.543]                       else if (inherits(cond, "condition")) {
[10:33:13.543]                         if (!is.null(pattern)) {
[10:33:13.543]                           computeRestarts <- base::computeRestarts
[10:33:13.543]                           grepl <- base::grepl
[10:33:13.543]                           restarts <- computeRestarts(cond)
[10:33:13.543]                           for (restart in restarts) {
[10:33:13.543]                             name <- restart$name
[10:33:13.543]                             if (is.null(name)) 
[10:33:13.543]                               next
[10:33:13.543]                             if (!grepl(pattern, name)) 
[10:33:13.543]                               next
[10:33:13.543]                             invokeRestart(restart)
[10:33:13.543]                             muffled <- TRUE
[10:33:13.543]                             break
[10:33:13.543]                           }
[10:33:13.543]                         }
[10:33:13.543]                       }
[10:33:13.543]                       invisible(muffled)
[10:33:13.543]                     }
[10:33:13.543]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.543]                   }
[10:33:13.543]                 }
[10:33:13.543]             }
[10:33:13.543]         }))
[10:33:13.543]     }, error = function(ex) {
[10:33:13.543]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:13.543]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.543]                 ...future.rng), started = ...future.startTime, 
[10:33:13.543]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:13.543]             version = "1.8"), class = "FutureResult")
[10:33:13.543]     }, finally = {
[10:33:13.543]         if (!identical(...future.workdir, getwd())) 
[10:33:13.543]             setwd(...future.workdir)
[10:33:13.543]         {
[10:33:13.543]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:13.543]                 ...future.oldOptions$nwarnings <- NULL
[10:33:13.543]             }
[10:33:13.543]             base::options(...future.oldOptions)
[10:33:13.543]             if (.Platform$OS.type == "windows") {
[10:33:13.543]                 old_names <- names(...future.oldEnvVars)
[10:33:13.543]                 envs <- base::Sys.getenv()
[10:33:13.543]                 names <- names(envs)
[10:33:13.543]                 common <- intersect(names, old_names)
[10:33:13.543]                 added <- setdiff(names, old_names)
[10:33:13.543]                 removed <- setdiff(old_names, names)
[10:33:13.543]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:13.543]                   envs[common]]
[10:33:13.543]                 NAMES <- toupper(changed)
[10:33:13.543]                 args <- list()
[10:33:13.543]                 for (kk in seq_along(NAMES)) {
[10:33:13.543]                   name <- changed[[kk]]
[10:33:13.543]                   NAME <- NAMES[[kk]]
[10:33:13.543]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.543]                     next
[10:33:13.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.543]                 }
[10:33:13.543]                 NAMES <- toupper(added)
[10:33:13.543]                 for (kk in seq_along(NAMES)) {
[10:33:13.543]                   name <- added[[kk]]
[10:33:13.543]                   NAME <- NAMES[[kk]]
[10:33:13.543]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.543]                     next
[10:33:13.543]                   args[[name]] <- ""
[10:33:13.543]                 }
[10:33:13.543]                 NAMES <- toupper(removed)
[10:33:13.543]                 for (kk in seq_along(NAMES)) {
[10:33:13.543]                   name <- removed[[kk]]
[10:33:13.543]                   NAME <- NAMES[[kk]]
[10:33:13.543]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.543]                     next
[10:33:13.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.543]                 }
[10:33:13.543]                 if (length(args) > 0) 
[10:33:13.543]                   base::do.call(base::Sys.setenv, args = args)
[10:33:13.543]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:13.543]             }
[10:33:13.543]             else {
[10:33:13.543]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:13.543]             }
[10:33:13.543]             {
[10:33:13.543]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:13.543]                   0L) {
[10:33:13.543]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:13.543]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:13.543]                   base::options(opts)
[10:33:13.543]                 }
[10:33:13.543]                 {
[10:33:13.543]                   {
[10:33:13.543]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:13.543]                     NULL
[10:33:13.543]                   }
[10:33:13.543]                   options(future.plan = NULL)
[10:33:13.543]                   if (is.na(NA_character_)) 
[10:33:13.543]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.543]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:13.543]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:13.543]                     .init = FALSE)
[10:33:13.543]                 }
[10:33:13.543]             }
[10:33:13.543]         }
[10:33:13.543]     })
[10:33:13.543]     if (TRUE) {
[10:33:13.543]         base::sink(type = "output", split = FALSE)
[10:33:13.543]         if (TRUE) {
[10:33:13.543]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:13.543]         }
[10:33:13.543]         else {
[10:33:13.543]             ...future.result["stdout"] <- base::list(NULL)
[10:33:13.543]         }
[10:33:13.543]         base::close(...future.stdout)
[10:33:13.543]         ...future.stdout <- NULL
[10:33:13.543]     }
[10:33:13.543]     ...future.result$conditions <- ...future.conditions
[10:33:13.543]     ...future.result$finished <- base::Sys.time()
[10:33:13.543]     ...future.result
[10:33:13.543] }
[10:33:13.545] requestCore(): workers = 2
[10:33:13.548] MulticoreFuture started
[10:33:13.548] - Launch lazy future ... done
[10:33:13.548] run() for ‘MulticoreFuture’ ... done
[10:33:13.549] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.549] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.549] List of future strategies:
[10:33:13.549] 1. sequential:
[10:33:13.549]    - args: function (..., envir = parent.frame())
[10:33:13.549]    - tweaked: FALSE
[10:33:13.549]    - call: NULL
[10:33:13.550] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:13.550] plan(): nbrOfWorkers() = 1
[10:33:13.552] plan(): Setting new future strategy stack:
[10:33:13.553] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:13.553] List of future strategies:
[10:33:13.553] 1. multicore:
[10:33:13.553]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.553]    - tweaked: FALSE
[10:33:13.553]    - call: plan(strategy)
[10:33:13.553] Searching for globals ... DONE
[10:33:13.554] Resolving globals: TRUE
[10:33:13.554] Resolving any globals that are futures ...
[10:33:13.554] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:13.554] Resolving any globals that are futures ... DONE
[10:33:13.555] Resolving futures part of globals (recursively) ...
[10:33:13.556] resolve() on list ...
[10:33:13.556]  recursive: 99
[10:33:13.557]  length: 1
[10:33:13.557]  elements: ‘a’
[10:33:13.558] plan(): nbrOfWorkers() = 2
[10:33:13.559] Future #1
[10:33:13.559] result() for MulticoreFuture ...
[10:33:13.560] result() for MulticoreFuture ...
[10:33:13.560] result() for MulticoreFuture ... done
[10:33:13.560] result() for MulticoreFuture ... done
[10:33:13.560] result() for MulticoreFuture ...
[10:33:13.561] result() for MulticoreFuture ... done
[10:33:13.561] A MulticoreFuture was resolved
[10:33:13.561]  length: 0 (resolved future 1)
[10:33:13.561] resolve() on list ... DONE
[10:33:13.561] - globals: [1] ‘a’
[10:33:13.561] Resolving futures part of globals (recursively) ... DONE
[10:33:13.564] The total size of the 1 globals is 1.57 MiB (1647008 bytes)
[10:33:13.564] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[10:33:13.565] - globals: [1] ‘a’
[10:33:13.565] - packages: [1] ‘future’
[10:33:13.565] getGlobalsAndPackages() ... DONE
[10:33:13.565] run() for ‘Future’ ...
[10:33:13.565] - state: ‘created’
[10:33:13.566] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:13.570] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:13.570] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:13.570]   - Field: ‘label’
[10:33:13.570]   - Field: ‘local’
[10:33:13.570]   - Field: ‘owner’
[10:33:13.571]   - Field: ‘envir’
[10:33:13.571]   - Field: ‘workers’
[10:33:13.571]   - Field: ‘packages’
[10:33:13.571]   - Field: ‘gc’
[10:33:13.571]   - Field: ‘job’
[10:33:13.571]   - Field: ‘conditions’
[10:33:13.571]   - Field: ‘expr’
[10:33:13.571]   - Field: ‘uuid’
[10:33:13.572]   - Field: ‘seed’
[10:33:13.572]   - Field: ‘version’
[10:33:13.572]   - Field: ‘result’
[10:33:13.572]   - Field: ‘asynchronous’
[10:33:13.572]   - Field: ‘calls’
[10:33:13.572]   - Field: ‘globals’
[10:33:13.572]   - Field: ‘stdout’
[10:33:13.572]   - Field: ‘earlySignal’
[10:33:13.572]   - Field: ‘lazy’
[10:33:13.573]   - Field: ‘state’
[10:33:13.573] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:13.573] - Launch lazy future ...
[10:33:13.573] Packages needed by the future expression (n = 1): ‘future’
[10:33:13.573] Packages needed by future strategies (n = 0): <none>
[10:33:13.574] {
[10:33:13.574]     {
[10:33:13.574]         {
[10:33:13.574]             ...future.startTime <- base::Sys.time()
[10:33:13.574]             {
[10:33:13.574]                 {
[10:33:13.574]                   {
[10:33:13.574]                     {
[10:33:13.574]                       {
[10:33:13.574]                         base::local({
[10:33:13.574]                           has_future <- base::requireNamespace("future", 
[10:33:13.574]                             quietly = TRUE)
[10:33:13.574]                           if (has_future) {
[10:33:13.574]                             ns <- base::getNamespace("future")
[10:33:13.574]                             version <- ns[[".package"]][["version"]]
[10:33:13.574]                             if (is.null(version)) 
[10:33:13.574]                               version <- utils::packageVersion("future")
[10:33:13.574]                           }
[10:33:13.574]                           else {
[10:33:13.574]                             version <- NULL
[10:33:13.574]                           }
[10:33:13.574]                           if (!has_future || version < "1.8.0") {
[10:33:13.574]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:13.574]                               "", base::R.version$version.string), 
[10:33:13.574]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:13.574]                                 base::R.version$platform, 8 * 
[10:33:13.574]                                   base::.Machine$sizeof.pointer), 
[10:33:13.574]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:13.574]                                 "release", "version")], collapse = " "), 
[10:33:13.574]                               hostname = base::Sys.info()[["nodename"]])
[10:33:13.574]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:13.574]                               info)
[10:33:13.574]                             info <- base::paste(info, collapse = "; ")
[10:33:13.574]                             if (!has_future) {
[10:33:13.574]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:13.574]                                 info)
[10:33:13.574]                             }
[10:33:13.574]                             else {
[10:33:13.574]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:13.574]                                 info, version)
[10:33:13.574]                             }
[10:33:13.574]                             base::stop(msg)
[10:33:13.574]                           }
[10:33:13.574]                         })
[10:33:13.574]                       }
[10:33:13.574]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:13.574]                       base::options(mc.cores = 1L)
[10:33:13.574]                     }
[10:33:13.574]                     base::local({
[10:33:13.574]                       for (pkg in "future") {
[10:33:13.574]                         base::loadNamespace(pkg)
[10:33:13.574]                         base::library(pkg, character.only = TRUE)
[10:33:13.574]                       }
[10:33:13.574]                     })
[10:33:13.574]                   }
[10:33:13.574]                   ...future.strategy.old <- future::plan("list")
[10:33:13.574]                   options(future.plan = NULL)
[10:33:13.574]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.574]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:13.574]                 }
[10:33:13.574]                 ...future.workdir <- getwd()
[10:33:13.574]             }
[10:33:13.574]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:13.574]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:13.574]         }
[10:33:13.574]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:13.574]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:13.574]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:13.574]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:13.574]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:13.574]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:13.574]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:13.574]             base::names(...future.oldOptions))
[10:33:13.574]     }
[10:33:13.574]     if (FALSE) {
[10:33:13.574]     }
[10:33:13.574]     else {
[10:33:13.574]         if (TRUE) {
[10:33:13.574]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:13.574]                 open = "w")
[10:33:13.574]         }
[10:33:13.574]         else {
[10:33:13.574]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:13.574]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:13.574]         }
[10:33:13.574]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:13.574]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:13.574]             base::sink(type = "output", split = FALSE)
[10:33:13.574]             base::close(...future.stdout)
[10:33:13.574]         }, add = TRUE)
[10:33:13.574]     }
[10:33:13.574]     ...future.frame <- base::sys.nframe()
[10:33:13.574]     ...future.conditions <- base::list()
[10:33:13.574]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:13.574]     if (FALSE) {
[10:33:13.574]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:13.574]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:13.574]     }
[10:33:13.574]     ...future.result <- base::tryCatch({
[10:33:13.574]         base::withCallingHandlers({
[10:33:13.574]             ...future.value <- base::withVisible(base::local({
[10:33:13.574]                 withCallingHandlers({
[10:33:13.574]                   value(a) + 1
[10:33:13.574]                 }, immediateCondition = function(cond) {
[10:33:13.574]                   save_rds <- function (object, pathname, ...) 
[10:33:13.574]                   {
[10:33:13.574]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:13.574]                     if (file_test("-f", pathname_tmp)) {
[10:33:13.574]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.574]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:13.574]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.574]                         fi_tmp[["mtime"]])
[10:33:13.574]                     }
[10:33:13.574]                     tryCatch({
[10:33:13.574]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:13.574]                     }, error = function(ex) {
[10:33:13.574]                       msg <- conditionMessage(ex)
[10:33:13.574]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.574]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:13.574]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.574]                         fi_tmp[["mtime"]], msg)
[10:33:13.574]                       ex$message <- msg
[10:33:13.574]                       stop(ex)
[10:33:13.574]                     })
[10:33:13.574]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:13.574]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:13.574]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:13.574]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.574]                       fi <- file.info(pathname)
[10:33:13.574]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:13.574]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.574]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:13.574]                         fi[["size"]], fi[["mtime"]])
[10:33:13.574]                       stop(msg)
[10:33:13.574]                     }
[10:33:13.574]                     invisible(pathname)
[10:33:13.574]                   }
[10:33:13.574]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:13.574]                     rootPath = tempdir()) 
[10:33:13.574]                   {
[10:33:13.574]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:13.574]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:13.574]                       tmpdir = path, fileext = ".rds")
[10:33:13.574]                     save_rds(obj, file)
[10:33:13.574]                   }
[10:33:13.574]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:13.574]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.574]                   {
[10:33:13.574]                     inherits <- base::inherits
[10:33:13.574]                     invokeRestart <- base::invokeRestart
[10:33:13.574]                     is.null <- base::is.null
[10:33:13.574]                     muffled <- FALSE
[10:33:13.574]                     if (inherits(cond, "message")) {
[10:33:13.574]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:13.574]                       if (muffled) 
[10:33:13.574]                         invokeRestart("muffleMessage")
[10:33:13.574]                     }
[10:33:13.574]                     else if (inherits(cond, "warning")) {
[10:33:13.574]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:13.574]                       if (muffled) 
[10:33:13.574]                         invokeRestart("muffleWarning")
[10:33:13.574]                     }
[10:33:13.574]                     else if (inherits(cond, "condition")) {
[10:33:13.574]                       if (!is.null(pattern)) {
[10:33:13.574]                         computeRestarts <- base::computeRestarts
[10:33:13.574]                         grepl <- base::grepl
[10:33:13.574]                         restarts <- computeRestarts(cond)
[10:33:13.574]                         for (restart in restarts) {
[10:33:13.574]                           name <- restart$name
[10:33:13.574]                           if (is.null(name)) 
[10:33:13.574]                             next
[10:33:13.574]                           if (!grepl(pattern, name)) 
[10:33:13.574]                             next
[10:33:13.574]                           invokeRestart(restart)
[10:33:13.574]                           muffled <- TRUE
[10:33:13.574]                           break
[10:33:13.574]                         }
[10:33:13.574]                       }
[10:33:13.574]                     }
[10:33:13.574]                     invisible(muffled)
[10:33:13.574]                   }
[10:33:13.574]                   muffleCondition(cond)
[10:33:13.574]                 })
[10:33:13.574]             }))
[10:33:13.574]             future::FutureResult(value = ...future.value$value, 
[10:33:13.574]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.574]                   ...future.rng), globalenv = if (FALSE) 
[10:33:13.574]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:13.574]                     ...future.globalenv.names))
[10:33:13.574]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:13.574]         }, condition = base::local({
[10:33:13.574]             c <- base::c
[10:33:13.574]             inherits <- base::inherits
[10:33:13.574]             invokeRestart <- base::invokeRestart
[10:33:13.574]             length <- base::length
[10:33:13.574]             list <- base::list
[10:33:13.574]             seq.int <- base::seq.int
[10:33:13.574]             signalCondition <- base::signalCondition
[10:33:13.574]             sys.calls <- base::sys.calls
[10:33:13.574]             `[[` <- base::`[[`
[10:33:13.574]             `+` <- base::`+`
[10:33:13.574]             `<<-` <- base::`<<-`
[10:33:13.574]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:13.574]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:13.574]                   3L)]
[10:33:13.574]             }
[10:33:13.574]             function(cond) {
[10:33:13.574]                 is_error <- inherits(cond, "error")
[10:33:13.574]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:13.574]                   NULL)
[10:33:13.574]                 if (is_error) {
[10:33:13.574]                   sessionInformation <- function() {
[10:33:13.574]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:13.574]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:13.574]                       search = base::search(), system = base::Sys.info())
[10:33:13.574]                   }
[10:33:13.574]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.574]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:13.574]                     cond$call), session = sessionInformation(), 
[10:33:13.574]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:13.574]                   signalCondition(cond)
[10:33:13.574]                 }
[10:33:13.574]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:13.574]                 "immediateCondition"))) {
[10:33:13.574]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:13.574]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.574]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:13.574]                   if (TRUE && !signal) {
[10:33:13.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.574]                     {
[10:33:13.574]                       inherits <- base::inherits
[10:33:13.574]                       invokeRestart <- base::invokeRestart
[10:33:13.574]                       is.null <- base::is.null
[10:33:13.574]                       muffled <- FALSE
[10:33:13.574]                       if (inherits(cond, "message")) {
[10:33:13.574]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.574]                         if (muffled) 
[10:33:13.574]                           invokeRestart("muffleMessage")
[10:33:13.574]                       }
[10:33:13.574]                       else if (inherits(cond, "warning")) {
[10:33:13.574]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.574]                         if (muffled) 
[10:33:13.574]                           invokeRestart("muffleWarning")
[10:33:13.574]                       }
[10:33:13.574]                       else if (inherits(cond, "condition")) {
[10:33:13.574]                         if (!is.null(pattern)) {
[10:33:13.574]                           computeRestarts <- base::computeRestarts
[10:33:13.574]                           grepl <- base::grepl
[10:33:13.574]                           restarts <- computeRestarts(cond)
[10:33:13.574]                           for (restart in restarts) {
[10:33:13.574]                             name <- restart$name
[10:33:13.574]                             if (is.null(name)) 
[10:33:13.574]                               next
[10:33:13.574]                             if (!grepl(pattern, name)) 
[10:33:13.574]                               next
[10:33:13.574]                             invokeRestart(restart)
[10:33:13.574]                             muffled <- TRUE
[10:33:13.574]                             break
[10:33:13.574]                           }
[10:33:13.574]                         }
[10:33:13.574]                       }
[10:33:13.574]                       invisible(muffled)
[10:33:13.574]                     }
[10:33:13.574]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.574]                   }
[10:33:13.574]                 }
[10:33:13.574]                 else {
[10:33:13.574]                   if (TRUE) {
[10:33:13.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.574]                     {
[10:33:13.574]                       inherits <- base::inherits
[10:33:13.574]                       invokeRestart <- base::invokeRestart
[10:33:13.574]                       is.null <- base::is.null
[10:33:13.574]                       muffled <- FALSE
[10:33:13.574]                       if (inherits(cond, "message")) {
[10:33:13.574]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.574]                         if (muffled) 
[10:33:13.574]                           invokeRestart("muffleMessage")
[10:33:13.574]                       }
[10:33:13.574]                       else if (inherits(cond, "warning")) {
[10:33:13.574]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.574]                         if (muffled) 
[10:33:13.574]                           invokeRestart("muffleWarning")
[10:33:13.574]                       }
[10:33:13.574]                       else if (inherits(cond, "condition")) {
[10:33:13.574]                         if (!is.null(pattern)) {
[10:33:13.574]                           computeRestarts <- base::computeRestarts
[10:33:13.574]                           grepl <- base::grepl
[10:33:13.574]                           restarts <- computeRestarts(cond)
[10:33:13.574]                           for (restart in restarts) {
[10:33:13.574]                             name <- restart$name
[10:33:13.574]                             if (is.null(name)) 
[10:33:13.574]                               next
[10:33:13.574]                             if (!grepl(pattern, name)) 
[10:33:13.574]                               next
[10:33:13.574]                             invokeRestart(restart)
[10:33:13.574]                             muffled <- TRUE
[10:33:13.574]                             break
[10:33:13.574]                           }
[10:33:13.574]                         }
[10:33:13.574]                       }
[10:33:13.574]                       invisible(muffled)
[10:33:13.574]                     }
[10:33:13.574]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.574]                   }
[10:33:13.574]                 }
[10:33:13.574]             }
[10:33:13.574]         }))
[10:33:13.574]     }, error = function(ex) {
[10:33:13.574]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:13.574]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.574]                 ...future.rng), started = ...future.startTime, 
[10:33:13.574]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:13.574]             version = "1.8"), class = "FutureResult")
[10:33:13.574]     }, finally = {
[10:33:13.574]         if (!identical(...future.workdir, getwd())) 
[10:33:13.574]             setwd(...future.workdir)
[10:33:13.574]         {
[10:33:13.574]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:13.574]                 ...future.oldOptions$nwarnings <- NULL
[10:33:13.574]             }
[10:33:13.574]             base::options(...future.oldOptions)
[10:33:13.574]             if (.Platform$OS.type == "windows") {
[10:33:13.574]                 old_names <- names(...future.oldEnvVars)
[10:33:13.574]                 envs <- base::Sys.getenv()
[10:33:13.574]                 names <- names(envs)
[10:33:13.574]                 common <- intersect(names, old_names)
[10:33:13.574]                 added <- setdiff(names, old_names)
[10:33:13.574]                 removed <- setdiff(old_names, names)
[10:33:13.574]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:13.574]                   envs[common]]
[10:33:13.574]                 NAMES <- toupper(changed)
[10:33:13.574]                 args <- list()
[10:33:13.574]                 for (kk in seq_along(NAMES)) {
[10:33:13.574]                   name <- changed[[kk]]
[10:33:13.574]                   NAME <- NAMES[[kk]]
[10:33:13.574]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.574]                     next
[10:33:13.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.574]                 }
[10:33:13.574]                 NAMES <- toupper(added)
[10:33:13.574]                 for (kk in seq_along(NAMES)) {
[10:33:13.574]                   name <- added[[kk]]
[10:33:13.574]                   NAME <- NAMES[[kk]]
[10:33:13.574]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.574]                     next
[10:33:13.574]                   args[[name]] <- ""
[10:33:13.574]                 }
[10:33:13.574]                 NAMES <- toupper(removed)
[10:33:13.574]                 for (kk in seq_along(NAMES)) {
[10:33:13.574]                   name <- removed[[kk]]
[10:33:13.574]                   NAME <- NAMES[[kk]]
[10:33:13.574]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.574]                     next
[10:33:13.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.574]                 }
[10:33:13.574]                 if (length(args) > 0) 
[10:33:13.574]                   base::do.call(base::Sys.setenv, args = args)
[10:33:13.574]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:13.574]             }
[10:33:13.574]             else {
[10:33:13.574]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:13.574]             }
[10:33:13.574]             {
[10:33:13.574]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:13.574]                   0L) {
[10:33:13.574]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:13.574]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:13.574]                   base::options(opts)
[10:33:13.574]                 }
[10:33:13.574]                 {
[10:33:13.574]                   {
[10:33:13.574]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:13.574]                     NULL
[10:33:13.574]                   }
[10:33:13.574]                   options(future.plan = NULL)
[10:33:13.574]                   if (is.na(NA_character_)) 
[10:33:13.574]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.574]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:13.574]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:13.574]                     .init = FALSE)
[10:33:13.574]                 }
[10:33:13.574]             }
[10:33:13.574]         }
[10:33:13.574]     })
[10:33:13.574]     if (TRUE) {
[10:33:13.574]         base::sink(type = "output", split = FALSE)
[10:33:13.574]         if (TRUE) {
[10:33:13.574]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:13.574]         }
[10:33:13.574]         else {
[10:33:13.574]             ...future.result["stdout"] <- base::list(NULL)
[10:33:13.574]         }
[10:33:13.574]         base::close(...future.stdout)
[10:33:13.574]         ...future.stdout <- NULL
[10:33:13.574]     }
[10:33:13.574]     ...future.result$conditions <- ...future.conditions
[10:33:13.574]     ...future.result$finished <- base::Sys.time()
[10:33:13.574]     ...future.result
[10:33:13.574] }
[10:33:13.576] assign_globals() ...
[10:33:13.577] List of 1
[10:33:13.577]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55aa5323ae78> 
[10:33:13.577]  - attr(*, "where")=List of 1
[10:33:13.577]   ..$ a:<environment: R_EmptyEnv> 
[10:33:13.577]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:13.577]  - attr(*, "resolved")= logi TRUE
[10:33:13.577]  - attr(*, "total_size")= num 1647008
[10:33:13.577]  - attr(*, "already-done")= logi TRUE
[10:33:13.579] - copied ‘a’ to environment
[10:33:13.579] assign_globals() ... done
[10:33:13.580] requestCore(): workers = 2
[10:33:13.582] MulticoreFuture started
[10:33:13.582] - Launch lazy future ... done
[10:33:13.582] run() for ‘MulticoreFuture’ ... done
[10:33:13.583] result() for MulticoreFuture ...
[10:33:13.583] plan(): Setting new future strategy stack:
[10:33:13.583] List of future strategies:
[10:33:13.583] 1. sequential:
[10:33:13.583]    - args: function (..., envir = parent.frame())
[10:33:13.583]    - tweaked: FALSE
[10:33:13.583]    - call: NULL
[10:33:13.584] plan(): nbrOfWorkers() = 1
[10:33:13.595] plan(): Setting new future strategy stack:
[10:33:13.595] List of future strategies:
[10:33:13.595] 1. multicore:
[10:33:13.595]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.595]    - tweaked: FALSE
[10:33:13.595]    - call: plan(strategy)
[10:33:13.600] plan(): nbrOfWorkers() = 2
[10:33:13.601] result() for MulticoreFuture ...
[10:33:13.604] result() for MulticoreFuture ... done
[10:33:13.604] signalConditions() ...
[10:33:13.605]  - include = ‘immediateCondition’
[10:33:13.605]  - exclude = 
[10:33:13.605]  - resignal = FALSE
[10:33:13.605]  - Number of conditions: 4
[10:33:13.606] signalConditions() ... done
[10:33:13.606] result() for MulticoreFuture ... done
[10:33:13.606] result() for MulticoreFuture ...
[10:33:13.606] result() for MulticoreFuture ... done
[10:33:13.606] signalConditions() ...
[10:33:13.607]  - include = ‘immediateCondition’
[10:33:13.607]  - exclude = 
[10:33:13.607]  - resignal = FALSE
[10:33:13.607]  - Number of conditions: 4
[10:33:13.607] signalConditions() ... done
[10:33:13.607] Future state: ‘finished’
[10:33:13.608] result() for MulticoreFuture ...
[10:33:13.608] result() for MulticoreFuture ... done
[10:33:13.608] signalConditions() ...
[10:33:13.608]  - include = ‘condition’
[10:33:13.608]  - exclude = ‘immediateCondition’
[10:33:13.608]  - resignal = TRUE
[10:33:13.608]  - Number of conditions: 4
[10:33:13.608]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.591] result() for MulticoreFuture ...
[10:33:13.609]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.592] result() for MulticoreFuture ... done
[10:33:13.609]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.592] result() for MulticoreFuture ...
[10:33:13.609]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.593] result() for MulticoreFuture ... done
[10:33:13.610] signalConditions() ... done
value(b) = 2
[10:33:13.610] result() for MulticoreFuture ...
[10:33:13.610] result() for MulticoreFuture ... done
[10:33:13.610] result() for MulticoreFuture ...
[10:33:13.610] result() for MulticoreFuture ... done
[10:33:13.610] signalConditions() ...
[10:33:13.611]  - include = ‘immediateCondition’
[10:33:13.611]  - exclude = 
[10:33:13.611]  - resignal = FALSE
[10:33:13.611]  - Number of conditions: 4
[10:33:13.611] signalConditions() ... done
[10:33:13.611] Future state: ‘finished’
[10:33:13.611] result() for MulticoreFuture ...
[10:33:13.611] result() for MulticoreFuture ... done
[10:33:13.612] signalConditions() ...
[10:33:13.612]  - include = ‘condition’
[10:33:13.612]  - exclude = ‘immediateCondition’
[10:33:13.612]  - resignal = TRUE
[10:33:13.612]  - Number of conditions: 4
[10:33:13.612]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.591] result() for MulticoreFuture ...
[10:33:13.612]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.592] result() for MulticoreFuture ... done
[10:33:13.612]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.592] result() for MulticoreFuture ...
[10:33:13.613]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.593] result() for MulticoreFuture ... done
[10:33:13.613] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.613] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.613] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:13.614] 
[10:33:13.614] Searching for globals ... DONE
[10:33:13.614] - globals: [0] <none>
[10:33:13.614] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.615] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.615] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:13.616] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:13.616] Searching for globals ... DONE
[10:33:13.616] Resolving globals: TRUE
[10:33:13.616] Resolving any globals that are futures ...
[10:33:13.616] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:13.616] Resolving any globals that are futures ... DONE
[10:33:13.617] Resolving futures part of globals (recursively) ...
[10:33:13.617] resolve() on list ...
[10:33:13.617]  recursive: 99
[10:33:13.617]  length: 1
[10:33:13.617]  elements: ‘a’
[10:33:13.618] run() for ‘Future’ ...
[10:33:13.618] - state: ‘created’
[10:33:13.618] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:13.622] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:13.622] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:13.622]   - Field: ‘label’
[10:33:13.622]   - Field: ‘local’
[10:33:13.622]   - Field: ‘owner’
[10:33:13.623]   - Field: ‘envir’
[10:33:13.623]   - Field: ‘workers’
[10:33:13.623]   - Field: ‘packages’
[10:33:13.623]   - Field: ‘gc’
[10:33:13.623]   - Field: ‘job’
[10:33:13.623]   - Field: ‘conditions’
[10:33:13.623]   - Field: ‘expr’
[10:33:13.623]   - Field: ‘uuid’
[10:33:13.624]   - Field: ‘seed’
[10:33:13.624]   - Field: ‘version’
[10:33:13.624]   - Field: ‘result’
[10:33:13.624]   - Field: ‘asynchronous’
[10:33:13.624]   - Field: ‘calls’
[10:33:13.624]   - Field: ‘globals’
[10:33:13.624]   - Field: ‘stdout’
[10:33:13.624]   - Field: ‘earlySignal’
[10:33:13.624]   - Field: ‘lazy’
[10:33:13.625]   - Field: ‘state’
[10:33:13.625] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:13.625] - Launch lazy future ...
[10:33:13.625] Packages needed by the future expression (n = 0): <none>
[10:33:13.625] Packages needed by future strategies (n = 0): <none>
[10:33:13.626] {
[10:33:13.626]     {
[10:33:13.626]         {
[10:33:13.626]             ...future.startTime <- base::Sys.time()
[10:33:13.626]             {
[10:33:13.626]                 {
[10:33:13.626]                   {
[10:33:13.626]                     {
[10:33:13.626]                       base::local({
[10:33:13.626]                         has_future <- base::requireNamespace("future", 
[10:33:13.626]                           quietly = TRUE)
[10:33:13.626]                         if (has_future) {
[10:33:13.626]                           ns <- base::getNamespace("future")
[10:33:13.626]                           version <- ns[[".package"]][["version"]]
[10:33:13.626]                           if (is.null(version)) 
[10:33:13.626]                             version <- utils::packageVersion("future")
[10:33:13.626]                         }
[10:33:13.626]                         else {
[10:33:13.626]                           version <- NULL
[10:33:13.626]                         }
[10:33:13.626]                         if (!has_future || version < "1.8.0") {
[10:33:13.626]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:13.626]                             "", base::R.version$version.string), 
[10:33:13.626]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:13.626]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:13.626]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:13.626]                               "release", "version")], collapse = " "), 
[10:33:13.626]                             hostname = base::Sys.info()[["nodename"]])
[10:33:13.626]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:13.626]                             info)
[10:33:13.626]                           info <- base::paste(info, collapse = "; ")
[10:33:13.626]                           if (!has_future) {
[10:33:13.626]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:13.626]                               info)
[10:33:13.626]                           }
[10:33:13.626]                           else {
[10:33:13.626]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:13.626]                               info, version)
[10:33:13.626]                           }
[10:33:13.626]                           base::stop(msg)
[10:33:13.626]                         }
[10:33:13.626]                       })
[10:33:13.626]                     }
[10:33:13.626]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:13.626]                     base::options(mc.cores = 1L)
[10:33:13.626]                   }
[10:33:13.626]                   ...future.strategy.old <- future::plan("list")
[10:33:13.626]                   options(future.plan = NULL)
[10:33:13.626]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.626]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:13.626]                 }
[10:33:13.626]                 ...future.workdir <- getwd()
[10:33:13.626]             }
[10:33:13.626]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:13.626]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:13.626]         }
[10:33:13.626]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:13.626]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:13.626]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:13.626]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:13.626]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:13.626]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:13.626]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:13.626]             base::names(...future.oldOptions))
[10:33:13.626]     }
[10:33:13.626]     if (FALSE) {
[10:33:13.626]     }
[10:33:13.626]     else {
[10:33:13.626]         if (TRUE) {
[10:33:13.626]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:13.626]                 open = "w")
[10:33:13.626]         }
[10:33:13.626]         else {
[10:33:13.626]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:13.626]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:13.626]         }
[10:33:13.626]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:13.626]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:13.626]             base::sink(type = "output", split = FALSE)
[10:33:13.626]             base::close(...future.stdout)
[10:33:13.626]         }, add = TRUE)
[10:33:13.626]     }
[10:33:13.626]     ...future.frame <- base::sys.nframe()
[10:33:13.626]     ...future.conditions <- base::list()
[10:33:13.626]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:13.626]     if (FALSE) {
[10:33:13.626]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:13.626]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:13.626]     }
[10:33:13.626]     ...future.result <- base::tryCatch({
[10:33:13.626]         base::withCallingHandlers({
[10:33:13.626]             ...future.value <- base::withVisible(base::local({
[10:33:13.626]                 withCallingHandlers({
[10:33:13.626]                   1
[10:33:13.626]                 }, immediateCondition = function(cond) {
[10:33:13.626]                   save_rds <- function (object, pathname, ...) 
[10:33:13.626]                   {
[10:33:13.626]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:13.626]                     if (file_test("-f", pathname_tmp)) {
[10:33:13.626]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.626]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:13.626]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.626]                         fi_tmp[["mtime"]])
[10:33:13.626]                     }
[10:33:13.626]                     tryCatch({
[10:33:13.626]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:13.626]                     }, error = function(ex) {
[10:33:13.626]                       msg <- conditionMessage(ex)
[10:33:13.626]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.626]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:13.626]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.626]                         fi_tmp[["mtime"]], msg)
[10:33:13.626]                       ex$message <- msg
[10:33:13.626]                       stop(ex)
[10:33:13.626]                     })
[10:33:13.626]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:13.626]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:13.626]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:13.626]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.626]                       fi <- file.info(pathname)
[10:33:13.626]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:13.626]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.626]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:13.626]                         fi[["size"]], fi[["mtime"]])
[10:33:13.626]                       stop(msg)
[10:33:13.626]                     }
[10:33:13.626]                     invisible(pathname)
[10:33:13.626]                   }
[10:33:13.626]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:13.626]                     rootPath = tempdir()) 
[10:33:13.626]                   {
[10:33:13.626]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:13.626]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:13.626]                       tmpdir = path, fileext = ".rds")
[10:33:13.626]                     save_rds(obj, file)
[10:33:13.626]                   }
[10:33:13.626]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:13.626]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.626]                   {
[10:33:13.626]                     inherits <- base::inherits
[10:33:13.626]                     invokeRestart <- base::invokeRestart
[10:33:13.626]                     is.null <- base::is.null
[10:33:13.626]                     muffled <- FALSE
[10:33:13.626]                     if (inherits(cond, "message")) {
[10:33:13.626]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:13.626]                       if (muffled) 
[10:33:13.626]                         invokeRestart("muffleMessage")
[10:33:13.626]                     }
[10:33:13.626]                     else if (inherits(cond, "warning")) {
[10:33:13.626]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:13.626]                       if (muffled) 
[10:33:13.626]                         invokeRestart("muffleWarning")
[10:33:13.626]                     }
[10:33:13.626]                     else if (inherits(cond, "condition")) {
[10:33:13.626]                       if (!is.null(pattern)) {
[10:33:13.626]                         computeRestarts <- base::computeRestarts
[10:33:13.626]                         grepl <- base::grepl
[10:33:13.626]                         restarts <- computeRestarts(cond)
[10:33:13.626]                         for (restart in restarts) {
[10:33:13.626]                           name <- restart$name
[10:33:13.626]                           if (is.null(name)) 
[10:33:13.626]                             next
[10:33:13.626]                           if (!grepl(pattern, name)) 
[10:33:13.626]                             next
[10:33:13.626]                           invokeRestart(restart)
[10:33:13.626]                           muffled <- TRUE
[10:33:13.626]                           break
[10:33:13.626]                         }
[10:33:13.626]                       }
[10:33:13.626]                     }
[10:33:13.626]                     invisible(muffled)
[10:33:13.626]                   }
[10:33:13.626]                   muffleCondition(cond)
[10:33:13.626]                 })
[10:33:13.626]             }))
[10:33:13.626]             future::FutureResult(value = ...future.value$value, 
[10:33:13.626]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.626]                   ...future.rng), globalenv = if (FALSE) 
[10:33:13.626]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:13.626]                     ...future.globalenv.names))
[10:33:13.626]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:13.626]         }, condition = base::local({
[10:33:13.626]             c <- base::c
[10:33:13.626]             inherits <- base::inherits
[10:33:13.626]             invokeRestart <- base::invokeRestart
[10:33:13.626]             length <- base::length
[10:33:13.626]             list <- base::list
[10:33:13.626]             seq.int <- base::seq.int
[10:33:13.626]             signalCondition <- base::signalCondition
[10:33:13.626]             sys.calls <- base::sys.calls
[10:33:13.626]             `[[` <- base::`[[`
[10:33:13.626]             `+` <- base::`+`
[10:33:13.626]             `<<-` <- base::`<<-`
[10:33:13.626]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:13.626]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:13.626]                   3L)]
[10:33:13.626]             }
[10:33:13.626]             function(cond) {
[10:33:13.626]                 is_error <- inherits(cond, "error")
[10:33:13.626]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:13.626]                   NULL)
[10:33:13.626]                 if (is_error) {
[10:33:13.626]                   sessionInformation <- function() {
[10:33:13.626]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:13.626]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:13.626]                       search = base::search(), system = base::Sys.info())
[10:33:13.626]                   }
[10:33:13.626]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.626]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:13.626]                     cond$call), session = sessionInformation(), 
[10:33:13.626]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:13.626]                   signalCondition(cond)
[10:33:13.626]                 }
[10:33:13.626]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:13.626]                 "immediateCondition"))) {
[10:33:13.626]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:13.626]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.626]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:13.626]                   if (TRUE && !signal) {
[10:33:13.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.626]                     {
[10:33:13.626]                       inherits <- base::inherits
[10:33:13.626]                       invokeRestart <- base::invokeRestart
[10:33:13.626]                       is.null <- base::is.null
[10:33:13.626]                       muffled <- FALSE
[10:33:13.626]                       if (inherits(cond, "message")) {
[10:33:13.626]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.626]                         if (muffled) 
[10:33:13.626]                           invokeRestart("muffleMessage")
[10:33:13.626]                       }
[10:33:13.626]                       else if (inherits(cond, "warning")) {
[10:33:13.626]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.626]                         if (muffled) 
[10:33:13.626]                           invokeRestart("muffleWarning")
[10:33:13.626]                       }
[10:33:13.626]                       else if (inherits(cond, "condition")) {
[10:33:13.626]                         if (!is.null(pattern)) {
[10:33:13.626]                           computeRestarts <- base::computeRestarts
[10:33:13.626]                           grepl <- base::grepl
[10:33:13.626]                           restarts <- computeRestarts(cond)
[10:33:13.626]                           for (restart in restarts) {
[10:33:13.626]                             name <- restart$name
[10:33:13.626]                             if (is.null(name)) 
[10:33:13.626]                               next
[10:33:13.626]                             if (!grepl(pattern, name)) 
[10:33:13.626]                               next
[10:33:13.626]                             invokeRestart(restart)
[10:33:13.626]                             muffled <- TRUE
[10:33:13.626]                             break
[10:33:13.626]                           }
[10:33:13.626]                         }
[10:33:13.626]                       }
[10:33:13.626]                       invisible(muffled)
[10:33:13.626]                     }
[10:33:13.626]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.626]                   }
[10:33:13.626]                 }
[10:33:13.626]                 else {
[10:33:13.626]                   if (TRUE) {
[10:33:13.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.626]                     {
[10:33:13.626]                       inherits <- base::inherits
[10:33:13.626]                       invokeRestart <- base::invokeRestart
[10:33:13.626]                       is.null <- base::is.null
[10:33:13.626]                       muffled <- FALSE
[10:33:13.626]                       if (inherits(cond, "message")) {
[10:33:13.626]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.626]                         if (muffled) 
[10:33:13.626]                           invokeRestart("muffleMessage")
[10:33:13.626]                       }
[10:33:13.626]                       else if (inherits(cond, "warning")) {
[10:33:13.626]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.626]                         if (muffled) 
[10:33:13.626]                           invokeRestart("muffleWarning")
[10:33:13.626]                       }
[10:33:13.626]                       else if (inherits(cond, "condition")) {
[10:33:13.626]                         if (!is.null(pattern)) {
[10:33:13.626]                           computeRestarts <- base::computeRestarts
[10:33:13.626]                           grepl <- base::grepl
[10:33:13.626]                           restarts <- computeRestarts(cond)
[10:33:13.626]                           for (restart in restarts) {
[10:33:13.626]                             name <- restart$name
[10:33:13.626]                             if (is.null(name)) 
[10:33:13.626]                               next
[10:33:13.626]                             if (!grepl(pattern, name)) 
[10:33:13.626]                               next
[10:33:13.626]                             invokeRestart(restart)
[10:33:13.626]                             muffled <- TRUE
[10:33:13.626]                             break
[10:33:13.626]                           }
[10:33:13.626]                         }
[10:33:13.626]                       }
[10:33:13.626]                       invisible(muffled)
[10:33:13.626]                     }
[10:33:13.626]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.626]                   }
[10:33:13.626]                 }
[10:33:13.626]             }
[10:33:13.626]         }))
[10:33:13.626]     }, error = function(ex) {
[10:33:13.626]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:13.626]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.626]                 ...future.rng), started = ...future.startTime, 
[10:33:13.626]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:13.626]             version = "1.8"), class = "FutureResult")
[10:33:13.626]     }, finally = {
[10:33:13.626]         if (!identical(...future.workdir, getwd())) 
[10:33:13.626]             setwd(...future.workdir)
[10:33:13.626]         {
[10:33:13.626]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:13.626]                 ...future.oldOptions$nwarnings <- NULL
[10:33:13.626]             }
[10:33:13.626]             base::options(...future.oldOptions)
[10:33:13.626]             if (.Platform$OS.type == "windows") {
[10:33:13.626]                 old_names <- names(...future.oldEnvVars)
[10:33:13.626]                 envs <- base::Sys.getenv()
[10:33:13.626]                 names <- names(envs)
[10:33:13.626]                 common <- intersect(names, old_names)
[10:33:13.626]                 added <- setdiff(names, old_names)
[10:33:13.626]                 removed <- setdiff(old_names, names)
[10:33:13.626]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:13.626]                   envs[common]]
[10:33:13.626]                 NAMES <- toupper(changed)
[10:33:13.626]                 args <- list()
[10:33:13.626]                 for (kk in seq_along(NAMES)) {
[10:33:13.626]                   name <- changed[[kk]]
[10:33:13.626]                   NAME <- NAMES[[kk]]
[10:33:13.626]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.626]                     next
[10:33:13.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.626]                 }
[10:33:13.626]                 NAMES <- toupper(added)
[10:33:13.626]                 for (kk in seq_along(NAMES)) {
[10:33:13.626]                   name <- added[[kk]]
[10:33:13.626]                   NAME <- NAMES[[kk]]
[10:33:13.626]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.626]                     next
[10:33:13.626]                   args[[name]] <- ""
[10:33:13.626]                 }
[10:33:13.626]                 NAMES <- toupper(removed)
[10:33:13.626]                 for (kk in seq_along(NAMES)) {
[10:33:13.626]                   name <- removed[[kk]]
[10:33:13.626]                   NAME <- NAMES[[kk]]
[10:33:13.626]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.626]                     next
[10:33:13.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.626]                 }
[10:33:13.626]                 if (length(args) > 0) 
[10:33:13.626]                   base::do.call(base::Sys.setenv, args = args)
[10:33:13.626]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:13.626]             }
[10:33:13.626]             else {
[10:33:13.626]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:13.626]             }
[10:33:13.626]             {
[10:33:13.626]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:13.626]                   0L) {
[10:33:13.626]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:13.626]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:13.626]                   base::options(opts)
[10:33:13.626]                 }
[10:33:13.626]                 {
[10:33:13.626]                   {
[10:33:13.626]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:13.626]                     NULL
[10:33:13.626]                   }
[10:33:13.626]                   options(future.plan = NULL)
[10:33:13.626]                   if (is.na(NA_character_)) 
[10:33:13.626]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.626]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:13.626]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:13.626]                     .init = FALSE)
[10:33:13.626]                 }
[10:33:13.626]             }
[10:33:13.626]         }
[10:33:13.626]     })
[10:33:13.626]     if (TRUE) {
[10:33:13.626]         base::sink(type = "output", split = FALSE)
[10:33:13.626]         if (TRUE) {
[10:33:13.626]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:13.626]         }
[10:33:13.626]         else {
[10:33:13.626]             ...future.result["stdout"] <- base::list(NULL)
[10:33:13.626]         }
[10:33:13.626]         base::close(...future.stdout)
[10:33:13.626]         ...future.stdout <- NULL
[10:33:13.626]     }
[10:33:13.626]     ...future.result$conditions <- ...future.conditions
[10:33:13.626]     ...future.result$finished <- base::Sys.time()
[10:33:13.626]     ...future.result
[10:33:13.626] }
[10:33:13.628] requestCore(): workers = 2
[10:33:13.630] MulticoreFuture started
[10:33:13.630] - Launch lazy future ... done
[10:33:13.630] run() for ‘MulticoreFuture’ ... done
[10:33:13.631] plan(): Setting new future strategy stack:
[10:33:13.631] List of future strategies:
[10:33:13.631] 1. sequential:
[10:33:13.631]    - args: function (..., envir = parent.frame())
[10:33:13.631]    - tweaked: FALSE
[10:33:13.631]    - call: NULL
[10:33:13.632] plan(): nbrOfWorkers() = 1
[10:33:13.634] plan(): Setting new future strategy stack:
[10:33:13.634] List of future strategies:
[10:33:13.634] 1. multicore:
[10:33:13.634]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.634]    - tweaked: FALSE
[10:33:13.634]    - call: plan(strategy)
[10:33:13.639] plan(): nbrOfWorkers() = 2
[10:33:13.640] Future #1
[10:33:13.640] result() for MulticoreFuture ...
[10:33:13.641] result() for MulticoreFuture ...
[10:33:13.641] result() for MulticoreFuture ... done
[10:33:13.641] result() for MulticoreFuture ... done
[10:33:13.641] result() for MulticoreFuture ...
[10:33:13.642] result() for MulticoreFuture ... done
[10:33:13.642] A MulticoreFuture was resolved
[10:33:13.642]  length: 0 (resolved future 1)
[10:33:13.642] resolve() on list ... DONE
[10:33:13.642] - globals: [1] ‘a’
[10:33:13.643] Resolving futures part of globals (recursively) ... DONE
[10:33:13.648] The total size of the 1 globals is 1.57 MiB (1647176 bytes)
[10:33:13.649] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[10:33:13.649] - globals: [1] ‘a’
[10:33:13.649] - packages: [1] ‘future’
[10:33:13.650] getGlobalsAndPackages() ... DONE
[10:33:13.650] run() for ‘Future’ ...
[10:33:13.650] - state: ‘created’
[10:33:13.650] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:13.655] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:13.655] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:13.655]   - Field: ‘label’
[10:33:13.655]   - Field: ‘local’
[10:33:13.655]   - Field: ‘owner’
[10:33:13.655]   - Field: ‘envir’
[10:33:13.655]   - Field: ‘workers’
[10:33:13.656]   - Field: ‘packages’
[10:33:13.656]   - Field: ‘gc’
[10:33:13.656]   - Field: ‘job’
[10:33:13.656]   - Field: ‘conditions’
[10:33:13.656]   - Field: ‘expr’
[10:33:13.656]   - Field: ‘uuid’
[10:33:13.656]   - Field: ‘seed’
[10:33:13.656]   - Field: ‘version’
[10:33:13.657]   - Field: ‘result’
[10:33:13.657]   - Field: ‘asynchronous’
[10:33:13.657]   - Field: ‘calls’
[10:33:13.657]   - Field: ‘globals’
[10:33:13.657]   - Field: ‘stdout’
[10:33:13.657]   - Field: ‘earlySignal’
[10:33:13.657]   - Field: ‘lazy’
[10:33:13.658]   - Field: ‘state’
[10:33:13.658] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:13.658] - Launch lazy future ...
[10:33:13.658] Packages needed by the future expression (n = 1): ‘future’
[10:33:13.658] Packages needed by future strategies (n = 0): <none>
[10:33:13.659] {
[10:33:13.659]     {
[10:33:13.659]         {
[10:33:13.659]             ...future.startTime <- base::Sys.time()
[10:33:13.659]             {
[10:33:13.659]                 {
[10:33:13.659]                   {
[10:33:13.659]                     {
[10:33:13.659]                       {
[10:33:13.659]                         base::local({
[10:33:13.659]                           has_future <- base::requireNamespace("future", 
[10:33:13.659]                             quietly = TRUE)
[10:33:13.659]                           if (has_future) {
[10:33:13.659]                             ns <- base::getNamespace("future")
[10:33:13.659]                             version <- ns[[".package"]][["version"]]
[10:33:13.659]                             if (is.null(version)) 
[10:33:13.659]                               version <- utils::packageVersion("future")
[10:33:13.659]                           }
[10:33:13.659]                           else {
[10:33:13.659]                             version <- NULL
[10:33:13.659]                           }
[10:33:13.659]                           if (!has_future || version < "1.8.0") {
[10:33:13.659]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:13.659]                               "", base::R.version$version.string), 
[10:33:13.659]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:13.659]                                 base::R.version$platform, 8 * 
[10:33:13.659]                                   base::.Machine$sizeof.pointer), 
[10:33:13.659]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:13.659]                                 "release", "version")], collapse = " "), 
[10:33:13.659]                               hostname = base::Sys.info()[["nodename"]])
[10:33:13.659]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:13.659]                               info)
[10:33:13.659]                             info <- base::paste(info, collapse = "; ")
[10:33:13.659]                             if (!has_future) {
[10:33:13.659]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:13.659]                                 info)
[10:33:13.659]                             }
[10:33:13.659]                             else {
[10:33:13.659]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:13.659]                                 info, version)
[10:33:13.659]                             }
[10:33:13.659]                             base::stop(msg)
[10:33:13.659]                           }
[10:33:13.659]                         })
[10:33:13.659]                       }
[10:33:13.659]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:13.659]                       base::options(mc.cores = 1L)
[10:33:13.659]                     }
[10:33:13.659]                     base::local({
[10:33:13.659]                       for (pkg in "future") {
[10:33:13.659]                         base::loadNamespace(pkg)
[10:33:13.659]                         base::library(pkg, character.only = TRUE)
[10:33:13.659]                       }
[10:33:13.659]                     })
[10:33:13.659]                   }
[10:33:13.659]                   ...future.strategy.old <- future::plan("list")
[10:33:13.659]                   options(future.plan = NULL)
[10:33:13.659]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.659]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:13.659]                 }
[10:33:13.659]                 ...future.workdir <- getwd()
[10:33:13.659]             }
[10:33:13.659]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:13.659]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:13.659]         }
[10:33:13.659]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:13.659]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:13.659]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:13.659]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:13.659]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:13.659]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:13.659]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:13.659]             base::names(...future.oldOptions))
[10:33:13.659]     }
[10:33:13.659]     if (FALSE) {
[10:33:13.659]     }
[10:33:13.659]     else {
[10:33:13.659]         if (TRUE) {
[10:33:13.659]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:13.659]                 open = "w")
[10:33:13.659]         }
[10:33:13.659]         else {
[10:33:13.659]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:13.659]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:13.659]         }
[10:33:13.659]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:13.659]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:13.659]             base::sink(type = "output", split = FALSE)
[10:33:13.659]             base::close(...future.stdout)
[10:33:13.659]         }, add = TRUE)
[10:33:13.659]     }
[10:33:13.659]     ...future.frame <- base::sys.nframe()
[10:33:13.659]     ...future.conditions <- base::list()
[10:33:13.659]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:13.659]     if (FALSE) {
[10:33:13.659]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:13.659]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:13.659]     }
[10:33:13.659]     ...future.result <- base::tryCatch({
[10:33:13.659]         base::withCallingHandlers({
[10:33:13.659]             ...future.value <- base::withVisible(base::local({
[10:33:13.659]                 withCallingHandlers({
[10:33:13.659]                   value(a) + 1
[10:33:13.659]                 }, immediateCondition = function(cond) {
[10:33:13.659]                   save_rds <- function (object, pathname, ...) 
[10:33:13.659]                   {
[10:33:13.659]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:13.659]                     if (file_test("-f", pathname_tmp)) {
[10:33:13.659]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.659]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:13.659]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.659]                         fi_tmp[["mtime"]])
[10:33:13.659]                     }
[10:33:13.659]                     tryCatch({
[10:33:13.659]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:13.659]                     }, error = function(ex) {
[10:33:13.659]                       msg <- conditionMessage(ex)
[10:33:13.659]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.659]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:13.659]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.659]                         fi_tmp[["mtime"]], msg)
[10:33:13.659]                       ex$message <- msg
[10:33:13.659]                       stop(ex)
[10:33:13.659]                     })
[10:33:13.659]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:13.659]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:13.659]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:13.659]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.659]                       fi <- file.info(pathname)
[10:33:13.659]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:13.659]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.659]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:13.659]                         fi[["size"]], fi[["mtime"]])
[10:33:13.659]                       stop(msg)
[10:33:13.659]                     }
[10:33:13.659]                     invisible(pathname)
[10:33:13.659]                   }
[10:33:13.659]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:13.659]                     rootPath = tempdir()) 
[10:33:13.659]                   {
[10:33:13.659]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:13.659]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:13.659]                       tmpdir = path, fileext = ".rds")
[10:33:13.659]                     save_rds(obj, file)
[10:33:13.659]                   }
[10:33:13.659]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:13.659]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.659]                   {
[10:33:13.659]                     inherits <- base::inherits
[10:33:13.659]                     invokeRestart <- base::invokeRestart
[10:33:13.659]                     is.null <- base::is.null
[10:33:13.659]                     muffled <- FALSE
[10:33:13.659]                     if (inherits(cond, "message")) {
[10:33:13.659]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:13.659]                       if (muffled) 
[10:33:13.659]                         invokeRestart("muffleMessage")
[10:33:13.659]                     }
[10:33:13.659]                     else if (inherits(cond, "warning")) {
[10:33:13.659]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:13.659]                       if (muffled) 
[10:33:13.659]                         invokeRestart("muffleWarning")
[10:33:13.659]                     }
[10:33:13.659]                     else if (inherits(cond, "condition")) {
[10:33:13.659]                       if (!is.null(pattern)) {
[10:33:13.659]                         computeRestarts <- base::computeRestarts
[10:33:13.659]                         grepl <- base::grepl
[10:33:13.659]                         restarts <- computeRestarts(cond)
[10:33:13.659]                         for (restart in restarts) {
[10:33:13.659]                           name <- restart$name
[10:33:13.659]                           if (is.null(name)) 
[10:33:13.659]                             next
[10:33:13.659]                           if (!grepl(pattern, name)) 
[10:33:13.659]                             next
[10:33:13.659]                           invokeRestart(restart)
[10:33:13.659]                           muffled <- TRUE
[10:33:13.659]                           break
[10:33:13.659]                         }
[10:33:13.659]                       }
[10:33:13.659]                     }
[10:33:13.659]                     invisible(muffled)
[10:33:13.659]                   }
[10:33:13.659]                   muffleCondition(cond)
[10:33:13.659]                 })
[10:33:13.659]             }))
[10:33:13.659]             future::FutureResult(value = ...future.value$value, 
[10:33:13.659]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.659]                   ...future.rng), globalenv = if (FALSE) 
[10:33:13.659]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:13.659]                     ...future.globalenv.names))
[10:33:13.659]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:13.659]         }, condition = base::local({
[10:33:13.659]             c <- base::c
[10:33:13.659]             inherits <- base::inherits
[10:33:13.659]             invokeRestart <- base::invokeRestart
[10:33:13.659]             length <- base::length
[10:33:13.659]             list <- base::list
[10:33:13.659]             seq.int <- base::seq.int
[10:33:13.659]             signalCondition <- base::signalCondition
[10:33:13.659]             sys.calls <- base::sys.calls
[10:33:13.659]             `[[` <- base::`[[`
[10:33:13.659]             `+` <- base::`+`
[10:33:13.659]             `<<-` <- base::`<<-`
[10:33:13.659]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:13.659]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:13.659]                   3L)]
[10:33:13.659]             }
[10:33:13.659]             function(cond) {
[10:33:13.659]                 is_error <- inherits(cond, "error")
[10:33:13.659]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:13.659]                   NULL)
[10:33:13.659]                 if (is_error) {
[10:33:13.659]                   sessionInformation <- function() {
[10:33:13.659]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:13.659]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:13.659]                       search = base::search(), system = base::Sys.info())
[10:33:13.659]                   }
[10:33:13.659]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.659]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:13.659]                     cond$call), session = sessionInformation(), 
[10:33:13.659]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:13.659]                   signalCondition(cond)
[10:33:13.659]                 }
[10:33:13.659]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:13.659]                 "immediateCondition"))) {
[10:33:13.659]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:13.659]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.659]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:13.659]                   if (TRUE && !signal) {
[10:33:13.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.659]                     {
[10:33:13.659]                       inherits <- base::inherits
[10:33:13.659]                       invokeRestart <- base::invokeRestart
[10:33:13.659]                       is.null <- base::is.null
[10:33:13.659]                       muffled <- FALSE
[10:33:13.659]                       if (inherits(cond, "message")) {
[10:33:13.659]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.659]                         if (muffled) 
[10:33:13.659]                           invokeRestart("muffleMessage")
[10:33:13.659]                       }
[10:33:13.659]                       else if (inherits(cond, "warning")) {
[10:33:13.659]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.659]                         if (muffled) 
[10:33:13.659]                           invokeRestart("muffleWarning")
[10:33:13.659]                       }
[10:33:13.659]                       else if (inherits(cond, "condition")) {
[10:33:13.659]                         if (!is.null(pattern)) {
[10:33:13.659]                           computeRestarts <- base::computeRestarts
[10:33:13.659]                           grepl <- base::grepl
[10:33:13.659]                           restarts <- computeRestarts(cond)
[10:33:13.659]                           for (restart in restarts) {
[10:33:13.659]                             name <- restart$name
[10:33:13.659]                             if (is.null(name)) 
[10:33:13.659]                               next
[10:33:13.659]                             if (!grepl(pattern, name)) 
[10:33:13.659]                               next
[10:33:13.659]                             invokeRestart(restart)
[10:33:13.659]                             muffled <- TRUE
[10:33:13.659]                             break
[10:33:13.659]                           }
[10:33:13.659]                         }
[10:33:13.659]                       }
[10:33:13.659]                       invisible(muffled)
[10:33:13.659]                     }
[10:33:13.659]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.659]                   }
[10:33:13.659]                 }
[10:33:13.659]                 else {
[10:33:13.659]                   if (TRUE) {
[10:33:13.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.659]                     {
[10:33:13.659]                       inherits <- base::inherits
[10:33:13.659]                       invokeRestart <- base::invokeRestart
[10:33:13.659]                       is.null <- base::is.null
[10:33:13.659]                       muffled <- FALSE
[10:33:13.659]                       if (inherits(cond, "message")) {
[10:33:13.659]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.659]                         if (muffled) 
[10:33:13.659]                           invokeRestart("muffleMessage")
[10:33:13.659]                       }
[10:33:13.659]                       else if (inherits(cond, "warning")) {
[10:33:13.659]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.659]                         if (muffled) 
[10:33:13.659]                           invokeRestart("muffleWarning")
[10:33:13.659]                       }
[10:33:13.659]                       else if (inherits(cond, "condition")) {
[10:33:13.659]                         if (!is.null(pattern)) {
[10:33:13.659]                           computeRestarts <- base::computeRestarts
[10:33:13.659]                           grepl <- base::grepl
[10:33:13.659]                           restarts <- computeRestarts(cond)
[10:33:13.659]                           for (restart in restarts) {
[10:33:13.659]                             name <- restart$name
[10:33:13.659]                             if (is.null(name)) 
[10:33:13.659]                               next
[10:33:13.659]                             if (!grepl(pattern, name)) 
[10:33:13.659]                               next
[10:33:13.659]                             invokeRestart(restart)
[10:33:13.659]                             muffled <- TRUE
[10:33:13.659]                             break
[10:33:13.659]                           }
[10:33:13.659]                         }
[10:33:13.659]                       }
[10:33:13.659]                       invisible(muffled)
[10:33:13.659]                     }
[10:33:13.659]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.659]                   }
[10:33:13.659]                 }
[10:33:13.659]             }
[10:33:13.659]         }))
[10:33:13.659]     }, error = function(ex) {
[10:33:13.659]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:13.659]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.659]                 ...future.rng), started = ...future.startTime, 
[10:33:13.659]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:13.659]             version = "1.8"), class = "FutureResult")
[10:33:13.659]     }, finally = {
[10:33:13.659]         if (!identical(...future.workdir, getwd())) 
[10:33:13.659]             setwd(...future.workdir)
[10:33:13.659]         {
[10:33:13.659]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:13.659]                 ...future.oldOptions$nwarnings <- NULL
[10:33:13.659]             }
[10:33:13.659]             base::options(...future.oldOptions)
[10:33:13.659]             if (.Platform$OS.type == "windows") {
[10:33:13.659]                 old_names <- names(...future.oldEnvVars)
[10:33:13.659]                 envs <- base::Sys.getenv()
[10:33:13.659]                 names <- names(envs)
[10:33:13.659]                 common <- intersect(names, old_names)
[10:33:13.659]                 added <- setdiff(names, old_names)
[10:33:13.659]                 removed <- setdiff(old_names, names)
[10:33:13.659]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:13.659]                   envs[common]]
[10:33:13.659]                 NAMES <- toupper(changed)
[10:33:13.659]                 args <- list()
[10:33:13.659]                 for (kk in seq_along(NAMES)) {
[10:33:13.659]                   name <- changed[[kk]]
[10:33:13.659]                   NAME <- NAMES[[kk]]
[10:33:13.659]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.659]                     next
[10:33:13.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.659]                 }
[10:33:13.659]                 NAMES <- toupper(added)
[10:33:13.659]                 for (kk in seq_along(NAMES)) {
[10:33:13.659]                   name <- added[[kk]]
[10:33:13.659]                   NAME <- NAMES[[kk]]
[10:33:13.659]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.659]                     next
[10:33:13.659]                   args[[name]] <- ""
[10:33:13.659]                 }
[10:33:13.659]                 NAMES <- toupper(removed)
[10:33:13.659]                 for (kk in seq_along(NAMES)) {
[10:33:13.659]                   name <- removed[[kk]]
[10:33:13.659]                   NAME <- NAMES[[kk]]
[10:33:13.659]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.659]                     next
[10:33:13.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.659]                 }
[10:33:13.659]                 if (length(args) > 0) 
[10:33:13.659]                   base::do.call(base::Sys.setenv, args = args)
[10:33:13.659]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:13.659]             }
[10:33:13.659]             else {
[10:33:13.659]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:13.659]             }
[10:33:13.659]             {
[10:33:13.659]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:13.659]                   0L) {
[10:33:13.659]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:13.659]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:13.659]                   base::options(opts)
[10:33:13.659]                 }
[10:33:13.659]                 {
[10:33:13.659]                   {
[10:33:13.659]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:13.659]                     NULL
[10:33:13.659]                   }
[10:33:13.659]                   options(future.plan = NULL)
[10:33:13.659]                   if (is.na(NA_character_)) 
[10:33:13.659]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.659]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:13.659]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:13.659]                     .init = FALSE)
[10:33:13.659]                 }
[10:33:13.659]             }
[10:33:13.659]         }
[10:33:13.659]     })
[10:33:13.659]     if (TRUE) {
[10:33:13.659]         base::sink(type = "output", split = FALSE)
[10:33:13.659]         if (TRUE) {
[10:33:13.659]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:13.659]         }
[10:33:13.659]         else {
[10:33:13.659]             ...future.result["stdout"] <- base::list(NULL)
[10:33:13.659]         }
[10:33:13.659]         base::close(...future.stdout)
[10:33:13.659]         ...future.stdout <- NULL
[10:33:13.659]     }
[10:33:13.659]     ...future.result$conditions <- ...future.conditions
[10:33:13.659]     ...future.result$finished <- base::Sys.time()
[10:33:13.659]     ...future.result
[10:33:13.659] }
[10:33:13.661] assign_globals() ...
[10:33:13.661] List of 1
[10:33:13.661]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55aa516aca38> 
[10:33:13.661]  - attr(*, "where")=List of 1
[10:33:13.661]   ..$ a:<environment: R_EmptyEnv> 
[10:33:13.661]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:13.661]  - attr(*, "resolved")= logi TRUE
[10:33:13.661]  - attr(*, "total_size")= num 1647176
[10:33:13.661]  - attr(*, "already-done")= logi TRUE
[10:33:13.664] - copied ‘a’ to environment
[10:33:13.664] assign_globals() ... done
[10:33:13.664] requestCore(): workers = 2
[10:33:13.666] MulticoreFuture started
[10:33:13.667] - Launch lazy future ... done
[10:33:13.667] run() for ‘MulticoreFuture’ ... done
[10:33:13.667] result() for MulticoreFuture ...
[10:33:13.668] plan(): Setting new future strategy stack:
[10:33:13.668] List of future strategies:
[10:33:13.668] 1. sequential:
[10:33:13.668]    - args: function (..., envir = parent.frame())
[10:33:13.668]    - tweaked: FALSE
[10:33:13.668]    - call: NULL
[10:33:13.669] plan(): nbrOfWorkers() = 1
[10:33:13.672] plan(): Setting new future strategy stack:
[10:33:13.672] List of future strategies:
[10:33:13.672] 1. multicore:
[10:33:13.672]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.672]    - tweaked: FALSE
[10:33:13.672]    - call: plan(strategy)
[10:33:13.677] plan(): nbrOfWorkers() = 2
[10:33:13.678] result() for MulticoreFuture ...
[10:33:13.678] result() for MulticoreFuture ... done
[10:33:13.679] signalConditions() ...
[10:33:13.679]  - include = ‘immediateCondition’
[10:33:13.679]  - exclude = 
[10:33:13.679]  - resignal = FALSE
[10:33:13.679]  - Number of conditions: 4
[10:33:13.679] signalConditions() ... done
[10:33:13.679] result() for MulticoreFuture ... done
[10:33:13.679] result() for MulticoreFuture ...
[10:33:13.680] result() for MulticoreFuture ... done
[10:33:13.680] signalConditions() ...
[10:33:13.680]  - include = ‘immediateCondition’
[10:33:13.680]  - exclude = 
[10:33:13.680]  - resignal = FALSE
[10:33:13.680]  - Number of conditions: 4
[10:33:13.680] signalConditions() ... done
[10:33:13.680] Future state: ‘finished’
[10:33:13.681] result() for MulticoreFuture ...
[10:33:13.681] result() for MulticoreFuture ... done
[10:33:13.681] signalConditions() ...
[10:33:13.681]  - include = ‘condition’
[10:33:13.681]  - exclude = ‘immediateCondition’
[10:33:13.681]  - resignal = TRUE
[10:33:13.681]  - Number of conditions: 4
[10:33:13.681]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.670] result() for MulticoreFuture ...
[10:33:13.682]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.670] result() for MulticoreFuture ... done
[10:33:13.682]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.671] result() for MulticoreFuture ...
[10:33:13.682]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.671] result() for MulticoreFuture ... done
[10:33:13.682] signalConditions() ... done
value(b) = 2
[10:33:13.682] result() for MulticoreFuture ...
[10:33:13.682] result() for MulticoreFuture ... done
[10:33:13.683] result() for MulticoreFuture ...
[10:33:13.683] result() for MulticoreFuture ... done
[10:33:13.683] signalConditions() ...
[10:33:13.683]  - include = ‘immediateCondition’
[10:33:13.683]  - exclude = 
[10:33:13.683]  - resignal = FALSE
[10:33:13.683]  - Number of conditions: 4
[10:33:13.683] signalConditions() ... done
[10:33:13.684] Future state: ‘finished’
[10:33:13.684] result() for MulticoreFuture ...
[10:33:13.684] result() for MulticoreFuture ... done
[10:33:13.684] signalConditions() ...
[10:33:13.684]  - include = ‘condition’
[10:33:13.684]  - exclude = ‘immediateCondition’
[10:33:13.684]  - resignal = TRUE
[10:33:13.684]  - Number of conditions: 4
[10:33:13.684]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.670] result() for MulticoreFuture ...
[10:33:13.685]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.670] result() for MulticoreFuture ... done
[10:33:13.685]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.671] result() for MulticoreFuture ...
[10:33:13.685]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.671] result() for MulticoreFuture ... done
[10:33:13.685] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.685] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.686] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:13.686] 
[10:33:13.686] Searching for globals ... DONE
[10:33:13.686] - globals: [0] <none>
[10:33:13.687] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.687] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.687] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:13.691] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:13.691] Searching for globals ... DONE
[10:33:13.692] Resolving globals: TRUE
[10:33:13.692] Resolving any globals that are futures ...
[10:33:13.692] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:13.692] Resolving any globals that are futures ... DONE
[10:33:13.692] Resolving futures part of globals (recursively) ...
[10:33:13.693] resolve() on list ...
[10:33:13.693]  recursive: 99
[10:33:13.693]  length: 1
[10:33:13.693]  elements: ‘a’
[10:33:13.693] run() for ‘Future’ ...
[10:33:13.694] - state: ‘created’
[10:33:13.694] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:13.698] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:13.698] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:13.698]   - Field: ‘label’
[10:33:13.698]   - Field: ‘local’
[10:33:13.699]   - Field: ‘owner’
[10:33:13.699]   - Field: ‘envir’
[10:33:13.699]   - Field: ‘workers’
[10:33:13.699]   - Field: ‘packages’
[10:33:13.699]   - Field: ‘gc’
[10:33:13.699]   - Field: ‘job’
[10:33:13.699]   - Field: ‘conditions’
[10:33:13.699]   - Field: ‘expr’
[10:33:13.699]   - Field: ‘uuid’
[10:33:13.700]   - Field: ‘seed’
[10:33:13.700]   - Field: ‘version’
[10:33:13.700]   - Field: ‘result’
[10:33:13.700]   - Field: ‘asynchronous’
[10:33:13.700]   - Field: ‘calls’
[10:33:13.700]   - Field: ‘globals’
[10:33:13.700]   - Field: ‘stdout’
[10:33:13.701]   - Field: ‘earlySignal’
[10:33:13.701]   - Field: ‘lazy’
[10:33:13.701]   - Field: ‘state’
[10:33:13.701] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:13.701] - Launch lazy future ...
[10:33:13.701] Packages needed by the future expression (n = 0): <none>
[10:33:13.701] Packages needed by future strategies (n = 0): <none>
[10:33:13.702] {
[10:33:13.702]     {
[10:33:13.702]         {
[10:33:13.702]             ...future.startTime <- base::Sys.time()
[10:33:13.702]             {
[10:33:13.702]                 {
[10:33:13.702]                   {
[10:33:13.702]                     {
[10:33:13.702]                       base::local({
[10:33:13.702]                         has_future <- base::requireNamespace("future", 
[10:33:13.702]                           quietly = TRUE)
[10:33:13.702]                         if (has_future) {
[10:33:13.702]                           ns <- base::getNamespace("future")
[10:33:13.702]                           version <- ns[[".package"]][["version"]]
[10:33:13.702]                           if (is.null(version)) 
[10:33:13.702]                             version <- utils::packageVersion("future")
[10:33:13.702]                         }
[10:33:13.702]                         else {
[10:33:13.702]                           version <- NULL
[10:33:13.702]                         }
[10:33:13.702]                         if (!has_future || version < "1.8.0") {
[10:33:13.702]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:13.702]                             "", base::R.version$version.string), 
[10:33:13.702]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:13.702]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:13.702]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:13.702]                               "release", "version")], collapse = " "), 
[10:33:13.702]                             hostname = base::Sys.info()[["nodename"]])
[10:33:13.702]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:13.702]                             info)
[10:33:13.702]                           info <- base::paste(info, collapse = "; ")
[10:33:13.702]                           if (!has_future) {
[10:33:13.702]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:13.702]                               info)
[10:33:13.702]                           }
[10:33:13.702]                           else {
[10:33:13.702]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:13.702]                               info, version)
[10:33:13.702]                           }
[10:33:13.702]                           base::stop(msg)
[10:33:13.702]                         }
[10:33:13.702]                       })
[10:33:13.702]                     }
[10:33:13.702]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:13.702]                     base::options(mc.cores = 1L)
[10:33:13.702]                   }
[10:33:13.702]                   ...future.strategy.old <- future::plan("list")
[10:33:13.702]                   options(future.plan = NULL)
[10:33:13.702]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.702]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:13.702]                 }
[10:33:13.702]                 ...future.workdir <- getwd()
[10:33:13.702]             }
[10:33:13.702]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:13.702]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:13.702]         }
[10:33:13.702]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:13.702]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:13.702]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:13.702]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:13.702]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:13.702]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:13.702]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:13.702]             base::names(...future.oldOptions))
[10:33:13.702]     }
[10:33:13.702]     if (FALSE) {
[10:33:13.702]     }
[10:33:13.702]     else {
[10:33:13.702]         if (TRUE) {
[10:33:13.702]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:13.702]                 open = "w")
[10:33:13.702]         }
[10:33:13.702]         else {
[10:33:13.702]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:13.702]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:13.702]         }
[10:33:13.702]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:13.702]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:13.702]             base::sink(type = "output", split = FALSE)
[10:33:13.702]             base::close(...future.stdout)
[10:33:13.702]         }, add = TRUE)
[10:33:13.702]     }
[10:33:13.702]     ...future.frame <- base::sys.nframe()
[10:33:13.702]     ...future.conditions <- base::list()
[10:33:13.702]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:13.702]     if (FALSE) {
[10:33:13.702]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:13.702]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:13.702]     }
[10:33:13.702]     ...future.result <- base::tryCatch({
[10:33:13.702]         base::withCallingHandlers({
[10:33:13.702]             ...future.value <- base::withVisible(base::local({
[10:33:13.702]                 withCallingHandlers({
[10:33:13.702]                   1
[10:33:13.702]                 }, immediateCondition = function(cond) {
[10:33:13.702]                   save_rds <- function (object, pathname, ...) 
[10:33:13.702]                   {
[10:33:13.702]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:13.702]                     if (file_test("-f", pathname_tmp)) {
[10:33:13.702]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.702]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:13.702]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.702]                         fi_tmp[["mtime"]])
[10:33:13.702]                     }
[10:33:13.702]                     tryCatch({
[10:33:13.702]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:13.702]                     }, error = function(ex) {
[10:33:13.702]                       msg <- conditionMessage(ex)
[10:33:13.702]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.702]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:13.702]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.702]                         fi_tmp[["mtime"]], msg)
[10:33:13.702]                       ex$message <- msg
[10:33:13.702]                       stop(ex)
[10:33:13.702]                     })
[10:33:13.702]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:13.702]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:13.702]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:13.702]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.702]                       fi <- file.info(pathname)
[10:33:13.702]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:13.702]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.702]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:13.702]                         fi[["size"]], fi[["mtime"]])
[10:33:13.702]                       stop(msg)
[10:33:13.702]                     }
[10:33:13.702]                     invisible(pathname)
[10:33:13.702]                   }
[10:33:13.702]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:13.702]                     rootPath = tempdir()) 
[10:33:13.702]                   {
[10:33:13.702]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:13.702]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:13.702]                       tmpdir = path, fileext = ".rds")
[10:33:13.702]                     save_rds(obj, file)
[10:33:13.702]                   }
[10:33:13.702]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:13.702]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.702]                   {
[10:33:13.702]                     inherits <- base::inherits
[10:33:13.702]                     invokeRestart <- base::invokeRestart
[10:33:13.702]                     is.null <- base::is.null
[10:33:13.702]                     muffled <- FALSE
[10:33:13.702]                     if (inherits(cond, "message")) {
[10:33:13.702]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:13.702]                       if (muffled) 
[10:33:13.702]                         invokeRestart("muffleMessage")
[10:33:13.702]                     }
[10:33:13.702]                     else if (inherits(cond, "warning")) {
[10:33:13.702]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:13.702]                       if (muffled) 
[10:33:13.702]                         invokeRestart("muffleWarning")
[10:33:13.702]                     }
[10:33:13.702]                     else if (inherits(cond, "condition")) {
[10:33:13.702]                       if (!is.null(pattern)) {
[10:33:13.702]                         computeRestarts <- base::computeRestarts
[10:33:13.702]                         grepl <- base::grepl
[10:33:13.702]                         restarts <- computeRestarts(cond)
[10:33:13.702]                         for (restart in restarts) {
[10:33:13.702]                           name <- restart$name
[10:33:13.702]                           if (is.null(name)) 
[10:33:13.702]                             next
[10:33:13.702]                           if (!grepl(pattern, name)) 
[10:33:13.702]                             next
[10:33:13.702]                           invokeRestart(restart)
[10:33:13.702]                           muffled <- TRUE
[10:33:13.702]                           break
[10:33:13.702]                         }
[10:33:13.702]                       }
[10:33:13.702]                     }
[10:33:13.702]                     invisible(muffled)
[10:33:13.702]                   }
[10:33:13.702]                   muffleCondition(cond)
[10:33:13.702]                 })
[10:33:13.702]             }))
[10:33:13.702]             future::FutureResult(value = ...future.value$value, 
[10:33:13.702]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.702]                   ...future.rng), globalenv = if (FALSE) 
[10:33:13.702]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:13.702]                     ...future.globalenv.names))
[10:33:13.702]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:13.702]         }, condition = base::local({
[10:33:13.702]             c <- base::c
[10:33:13.702]             inherits <- base::inherits
[10:33:13.702]             invokeRestart <- base::invokeRestart
[10:33:13.702]             length <- base::length
[10:33:13.702]             list <- base::list
[10:33:13.702]             seq.int <- base::seq.int
[10:33:13.702]             signalCondition <- base::signalCondition
[10:33:13.702]             sys.calls <- base::sys.calls
[10:33:13.702]             `[[` <- base::`[[`
[10:33:13.702]             `+` <- base::`+`
[10:33:13.702]             `<<-` <- base::`<<-`
[10:33:13.702]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:13.702]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:13.702]                   3L)]
[10:33:13.702]             }
[10:33:13.702]             function(cond) {
[10:33:13.702]                 is_error <- inherits(cond, "error")
[10:33:13.702]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:13.702]                   NULL)
[10:33:13.702]                 if (is_error) {
[10:33:13.702]                   sessionInformation <- function() {
[10:33:13.702]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:13.702]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:13.702]                       search = base::search(), system = base::Sys.info())
[10:33:13.702]                   }
[10:33:13.702]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.702]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:13.702]                     cond$call), session = sessionInformation(), 
[10:33:13.702]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:13.702]                   signalCondition(cond)
[10:33:13.702]                 }
[10:33:13.702]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:13.702]                 "immediateCondition"))) {
[10:33:13.702]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:13.702]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.702]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:13.702]                   if (TRUE && !signal) {
[10:33:13.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.702]                     {
[10:33:13.702]                       inherits <- base::inherits
[10:33:13.702]                       invokeRestart <- base::invokeRestart
[10:33:13.702]                       is.null <- base::is.null
[10:33:13.702]                       muffled <- FALSE
[10:33:13.702]                       if (inherits(cond, "message")) {
[10:33:13.702]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.702]                         if (muffled) 
[10:33:13.702]                           invokeRestart("muffleMessage")
[10:33:13.702]                       }
[10:33:13.702]                       else if (inherits(cond, "warning")) {
[10:33:13.702]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.702]                         if (muffled) 
[10:33:13.702]                           invokeRestart("muffleWarning")
[10:33:13.702]                       }
[10:33:13.702]                       else if (inherits(cond, "condition")) {
[10:33:13.702]                         if (!is.null(pattern)) {
[10:33:13.702]                           computeRestarts <- base::computeRestarts
[10:33:13.702]                           grepl <- base::grepl
[10:33:13.702]                           restarts <- computeRestarts(cond)
[10:33:13.702]                           for (restart in restarts) {
[10:33:13.702]                             name <- restart$name
[10:33:13.702]                             if (is.null(name)) 
[10:33:13.702]                               next
[10:33:13.702]                             if (!grepl(pattern, name)) 
[10:33:13.702]                               next
[10:33:13.702]                             invokeRestart(restart)
[10:33:13.702]                             muffled <- TRUE
[10:33:13.702]                             break
[10:33:13.702]                           }
[10:33:13.702]                         }
[10:33:13.702]                       }
[10:33:13.702]                       invisible(muffled)
[10:33:13.702]                     }
[10:33:13.702]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.702]                   }
[10:33:13.702]                 }
[10:33:13.702]                 else {
[10:33:13.702]                   if (TRUE) {
[10:33:13.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.702]                     {
[10:33:13.702]                       inherits <- base::inherits
[10:33:13.702]                       invokeRestart <- base::invokeRestart
[10:33:13.702]                       is.null <- base::is.null
[10:33:13.702]                       muffled <- FALSE
[10:33:13.702]                       if (inherits(cond, "message")) {
[10:33:13.702]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.702]                         if (muffled) 
[10:33:13.702]                           invokeRestart("muffleMessage")
[10:33:13.702]                       }
[10:33:13.702]                       else if (inherits(cond, "warning")) {
[10:33:13.702]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.702]                         if (muffled) 
[10:33:13.702]                           invokeRestart("muffleWarning")
[10:33:13.702]                       }
[10:33:13.702]                       else if (inherits(cond, "condition")) {
[10:33:13.702]                         if (!is.null(pattern)) {
[10:33:13.702]                           computeRestarts <- base::computeRestarts
[10:33:13.702]                           grepl <- base::grepl
[10:33:13.702]                           restarts <- computeRestarts(cond)
[10:33:13.702]                           for (restart in restarts) {
[10:33:13.702]                             name <- restart$name
[10:33:13.702]                             if (is.null(name)) 
[10:33:13.702]                               next
[10:33:13.702]                             if (!grepl(pattern, name)) 
[10:33:13.702]                               next
[10:33:13.702]                             invokeRestart(restart)
[10:33:13.702]                             muffled <- TRUE
[10:33:13.702]                             break
[10:33:13.702]                           }
[10:33:13.702]                         }
[10:33:13.702]                       }
[10:33:13.702]                       invisible(muffled)
[10:33:13.702]                     }
[10:33:13.702]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.702]                   }
[10:33:13.702]                 }
[10:33:13.702]             }
[10:33:13.702]         }))
[10:33:13.702]     }, error = function(ex) {
[10:33:13.702]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:13.702]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.702]                 ...future.rng), started = ...future.startTime, 
[10:33:13.702]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:13.702]             version = "1.8"), class = "FutureResult")
[10:33:13.702]     }, finally = {
[10:33:13.702]         if (!identical(...future.workdir, getwd())) 
[10:33:13.702]             setwd(...future.workdir)
[10:33:13.702]         {
[10:33:13.702]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:13.702]                 ...future.oldOptions$nwarnings <- NULL
[10:33:13.702]             }
[10:33:13.702]             base::options(...future.oldOptions)
[10:33:13.702]             if (.Platform$OS.type == "windows") {
[10:33:13.702]                 old_names <- names(...future.oldEnvVars)
[10:33:13.702]                 envs <- base::Sys.getenv()
[10:33:13.702]                 names <- names(envs)
[10:33:13.702]                 common <- intersect(names, old_names)
[10:33:13.702]                 added <- setdiff(names, old_names)
[10:33:13.702]                 removed <- setdiff(old_names, names)
[10:33:13.702]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:13.702]                   envs[common]]
[10:33:13.702]                 NAMES <- toupper(changed)
[10:33:13.702]                 args <- list()
[10:33:13.702]                 for (kk in seq_along(NAMES)) {
[10:33:13.702]                   name <- changed[[kk]]
[10:33:13.702]                   NAME <- NAMES[[kk]]
[10:33:13.702]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.702]                     next
[10:33:13.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.702]                 }
[10:33:13.702]                 NAMES <- toupper(added)
[10:33:13.702]                 for (kk in seq_along(NAMES)) {
[10:33:13.702]                   name <- added[[kk]]
[10:33:13.702]                   NAME <- NAMES[[kk]]
[10:33:13.702]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.702]                     next
[10:33:13.702]                   args[[name]] <- ""
[10:33:13.702]                 }
[10:33:13.702]                 NAMES <- toupper(removed)
[10:33:13.702]                 for (kk in seq_along(NAMES)) {
[10:33:13.702]                   name <- removed[[kk]]
[10:33:13.702]                   NAME <- NAMES[[kk]]
[10:33:13.702]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.702]                     next
[10:33:13.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.702]                 }
[10:33:13.702]                 if (length(args) > 0) 
[10:33:13.702]                   base::do.call(base::Sys.setenv, args = args)
[10:33:13.702]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:13.702]             }
[10:33:13.702]             else {
[10:33:13.702]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:13.702]             }
[10:33:13.702]             {
[10:33:13.702]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:13.702]                   0L) {
[10:33:13.702]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:13.702]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:13.702]                   base::options(opts)
[10:33:13.702]                 }
[10:33:13.702]                 {
[10:33:13.702]                   {
[10:33:13.702]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:13.702]                     NULL
[10:33:13.702]                   }
[10:33:13.702]                   options(future.plan = NULL)
[10:33:13.702]                   if (is.na(NA_character_)) 
[10:33:13.702]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.702]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:13.702]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:13.702]                     .init = FALSE)
[10:33:13.702]                 }
[10:33:13.702]             }
[10:33:13.702]         }
[10:33:13.702]     })
[10:33:13.702]     if (TRUE) {
[10:33:13.702]         base::sink(type = "output", split = FALSE)
[10:33:13.702]         if (TRUE) {
[10:33:13.702]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:13.702]         }
[10:33:13.702]         else {
[10:33:13.702]             ...future.result["stdout"] <- base::list(NULL)
[10:33:13.702]         }
[10:33:13.702]         base::close(...future.stdout)
[10:33:13.702]         ...future.stdout <- NULL
[10:33:13.702]     }
[10:33:13.702]     ...future.result$conditions <- ...future.conditions
[10:33:13.702]     ...future.result$finished <- base::Sys.time()
[10:33:13.702]     ...future.result
[10:33:13.702] }
[10:33:13.704] requestCore(): workers = 2
[10:33:13.706] MulticoreFuture started
[10:33:13.706] - Launch lazy future ... done
[10:33:13.707] run() for ‘MulticoreFuture’ ... done
[10:33:13.707] plan(): Setting new future strategy stack:
[10:33:13.707] List of future strategies:
[10:33:13.707] 1. sequential:
[10:33:13.707]    - args: function (..., envir = parent.frame())
[10:33:13.707]    - tweaked: FALSE
[10:33:13.707]    - call: NULL
[10:33:13.708] plan(): nbrOfWorkers() = 1
[10:33:13.710] plan(): Setting new future strategy stack:
[10:33:13.711] List of future strategies:
[10:33:13.711] 1. multicore:
[10:33:13.711]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.711]    - tweaked: FALSE
[10:33:13.711]    - call: plan(strategy)
[10:33:13.716] plan(): nbrOfWorkers() = 2
[10:33:13.716] Future #1
[10:33:13.717] result() for MulticoreFuture ...
[10:33:13.717] result() for MulticoreFuture ...
[10:33:13.718] result() for MulticoreFuture ... done
[10:33:13.718] result() for MulticoreFuture ... done
[10:33:13.718] result() for MulticoreFuture ...
[10:33:13.718] result() for MulticoreFuture ... done
[10:33:13.718] A MulticoreFuture was resolved
[10:33:13.718]  length: 0 (resolved future 1)
[10:33:13.719] resolve() on list ... DONE
[10:33:13.719] - globals: [1] ‘a’
[10:33:13.719] Resolving futures part of globals (recursively) ... DONE
[10:33:13.722] The total size of the 1 globals is 1.57 MiB (1647176 bytes)
[10:33:13.722] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[10:33:13.722] - globals: [1] ‘a’
[10:33:13.723] - packages: [1] ‘future’
[10:33:13.723] getGlobalsAndPackages() ... DONE
[10:33:13.723] run() for ‘Future’ ...
[10:33:13.723] - state: ‘created’
[10:33:13.723] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:13.727] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:13.728] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:13.728]   - Field: ‘label’
[10:33:13.728]   - Field: ‘local’
[10:33:13.728]   - Field: ‘owner’
[10:33:13.728]   - Field: ‘envir’
[10:33:13.728]   - Field: ‘workers’
[10:33:13.728]   - Field: ‘packages’
[10:33:13.728]   - Field: ‘gc’
[10:33:13.728]   - Field: ‘job’
[10:33:13.729]   - Field: ‘conditions’
[10:33:13.729]   - Field: ‘expr’
[10:33:13.729]   - Field: ‘uuid’
[10:33:13.729]   - Field: ‘seed’
[10:33:13.729]   - Field: ‘version’
[10:33:13.729]   - Field: ‘result’
[10:33:13.729]   - Field: ‘asynchronous’
[10:33:13.729]   - Field: ‘calls’
[10:33:13.730]   - Field: ‘globals’
[10:33:13.730]   - Field: ‘stdout’
[10:33:13.730]   - Field: ‘earlySignal’
[10:33:13.730]   - Field: ‘lazy’
[10:33:13.730]   - Field: ‘state’
[10:33:13.730] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:13.730] - Launch lazy future ...
[10:33:13.731] Packages needed by the future expression (n = 1): ‘future’
[10:33:13.731] Packages needed by future strategies (n = 0): <none>
[10:33:13.731] {
[10:33:13.731]     {
[10:33:13.731]         {
[10:33:13.731]             ...future.startTime <- base::Sys.time()
[10:33:13.731]             {
[10:33:13.731]                 {
[10:33:13.731]                   {
[10:33:13.731]                     {
[10:33:13.731]                       {
[10:33:13.731]                         base::local({
[10:33:13.731]                           has_future <- base::requireNamespace("future", 
[10:33:13.731]                             quietly = TRUE)
[10:33:13.731]                           if (has_future) {
[10:33:13.731]                             ns <- base::getNamespace("future")
[10:33:13.731]                             version <- ns[[".package"]][["version"]]
[10:33:13.731]                             if (is.null(version)) 
[10:33:13.731]                               version <- utils::packageVersion("future")
[10:33:13.731]                           }
[10:33:13.731]                           else {
[10:33:13.731]                             version <- NULL
[10:33:13.731]                           }
[10:33:13.731]                           if (!has_future || version < "1.8.0") {
[10:33:13.731]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:13.731]                               "", base::R.version$version.string), 
[10:33:13.731]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:13.731]                                 base::R.version$platform, 8 * 
[10:33:13.731]                                   base::.Machine$sizeof.pointer), 
[10:33:13.731]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:13.731]                                 "release", "version")], collapse = " "), 
[10:33:13.731]                               hostname = base::Sys.info()[["nodename"]])
[10:33:13.731]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:13.731]                               info)
[10:33:13.731]                             info <- base::paste(info, collapse = "; ")
[10:33:13.731]                             if (!has_future) {
[10:33:13.731]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:13.731]                                 info)
[10:33:13.731]                             }
[10:33:13.731]                             else {
[10:33:13.731]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:13.731]                                 info, version)
[10:33:13.731]                             }
[10:33:13.731]                             base::stop(msg)
[10:33:13.731]                           }
[10:33:13.731]                         })
[10:33:13.731]                       }
[10:33:13.731]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:13.731]                       base::options(mc.cores = 1L)
[10:33:13.731]                     }
[10:33:13.731]                     base::local({
[10:33:13.731]                       for (pkg in "future") {
[10:33:13.731]                         base::loadNamespace(pkg)
[10:33:13.731]                         base::library(pkg, character.only = TRUE)
[10:33:13.731]                       }
[10:33:13.731]                     })
[10:33:13.731]                   }
[10:33:13.731]                   ...future.strategy.old <- future::plan("list")
[10:33:13.731]                   options(future.plan = NULL)
[10:33:13.731]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.731]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:13.731]                 }
[10:33:13.731]                 ...future.workdir <- getwd()
[10:33:13.731]             }
[10:33:13.731]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:13.731]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:13.731]         }
[10:33:13.731]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:13.731]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:13.731]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:13.731]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:13.731]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:13.731]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:13.731]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:13.731]             base::names(...future.oldOptions))
[10:33:13.731]     }
[10:33:13.731]     if (FALSE) {
[10:33:13.731]     }
[10:33:13.731]     else {
[10:33:13.731]         if (TRUE) {
[10:33:13.731]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:13.731]                 open = "w")
[10:33:13.731]         }
[10:33:13.731]         else {
[10:33:13.731]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:13.731]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:13.731]         }
[10:33:13.731]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:13.731]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:13.731]             base::sink(type = "output", split = FALSE)
[10:33:13.731]             base::close(...future.stdout)
[10:33:13.731]         }, add = TRUE)
[10:33:13.731]     }
[10:33:13.731]     ...future.frame <- base::sys.nframe()
[10:33:13.731]     ...future.conditions <- base::list()
[10:33:13.731]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:13.731]     if (FALSE) {
[10:33:13.731]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:13.731]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:13.731]     }
[10:33:13.731]     ...future.result <- base::tryCatch({
[10:33:13.731]         base::withCallingHandlers({
[10:33:13.731]             ...future.value <- base::withVisible(base::local({
[10:33:13.731]                 withCallingHandlers({
[10:33:13.731]                   value(a) + 1
[10:33:13.731]                 }, immediateCondition = function(cond) {
[10:33:13.731]                   save_rds <- function (object, pathname, ...) 
[10:33:13.731]                   {
[10:33:13.731]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:13.731]                     if (file_test("-f", pathname_tmp)) {
[10:33:13.731]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.731]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:13.731]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.731]                         fi_tmp[["mtime"]])
[10:33:13.731]                     }
[10:33:13.731]                     tryCatch({
[10:33:13.731]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:13.731]                     }, error = function(ex) {
[10:33:13.731]                       msg <- conditionMessage(ex)
[10:33:13.731]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.731]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:13.731]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.731]                         fi_tmp[["mtime"]], msg)
[10:33:13.731]                       ex$message <- msg
[10:33:13.731]                       stop(ex)
[10:33:13.731]                     })
[10:33:13.731]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:13.731]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:13.731]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:13.731]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.731]                       fi <- file.info(pathname)
[10:33:13.731]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:13.731]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.731]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:13.731]                         fi[["size"]], fi[["mtime"]])
[10:33:13.731]                       stop(msg)
[10:33:13.731]                     }
[10:33:13.731]                     invisible(pathname)
[10:33:13.731]                   }
[10:33:13.731]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:13.731]                     rootPath = tempdir()) 
[10:33:13.731]                   {
[10:33:13.731]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:13.731]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:13.731]                       tmpdir = path, fileext = ".rds")
[10:33:13.731]                     save_rds(obj, file)
[10:33:13.731]                   }
[10:33:13.731]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:13.731]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.731]                   {
[10:33:13.731]                     inherits <- base::inherits
[10:33:13.731]                     invokeRestart <- base::invokeRestart
[10:33:13.731]                     is.null <- base::is.null
[10:33:13.731]                     muffled <- FALSE
[10:33:13.731]                     if (inherits(cond, "message")) {
[10:33:13.731]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:13.731]                       if (muffled) 
[10:33:13.731]                         invokeRestart("muffleMessage")
[10:33:13.731]                     }
[10:33:13.731]                     else if (inherits(cond, "warning")) {
[10:33:13.731]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:13.731]                       if (muffled) 
[10:33:13.731]                         invokeRestart("muffleWarning")
[10:33:13.731]                     }
[10:33:13.731]                     else if (inherits(cond, "condition")) {
[10:33:13.731]                       if (!is.null(pattern)) {
[10:33:13.731]                         computeRestarts <- base::computeRestarts
[10:33:13.731]                         grepl <- base::grepl
[10:33:13.731]                         restarts <- computeRestarts(cond)
[10:33:13.731]                         for (restart in restarts) {
[10:33:13.731]                           name <- restart$name
[10:33:13.731]                           if (is.null(name)) 
[10:33:13.731]                             next
[10:33:13.731]                           if (!grepl(pattern, name)) 
[10:33:13.731]                             next
[10:33:13.731]                           invokeRestart(restart)
[10:33:13.731]                           muffled <- TRUE
[10:33:13.731]                           break
[10:33:13.731]                         }
[10:33:13.731]                       }
[10:33:13.731]                     }
[10:33:13.731]                     invisible(muffled)
[10:33:13.731]                   }
[10:33:13.731]                   muffleCondition(cond)
[10:33:13.731]                 })
[10:33:13.731]             }))
[10:33:13.731]             future::FutureResult(value = ...future.value$value, 
[10:33:13.731]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.731]                   ...future.rng), globalenv = if (FALSE) 
[10:33:13.731]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:13.731]                     ...future.globalenv.names))
[10:33:13.731]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:13.731]         }, condition = base::local({
[10:33:13.731]             c <- base::c
[10:33:13.731]             inherits <- base::inherits
[10:33:13.731]             invokeRestart <- base::invokeRestart
[10:33:13.731]             length <- base::length
[10:33:13.731]             list <- base::list
[10:33:13.731]             seq.int <- base::seq.int
[10:33:13.731]             signalCondition <- base::signalCondition
[10:33:13.731]             sys.calls <- base::sys.calls
[10:33:13.731]             `[[` <- base::`[[`
[10:33:13.731]             `+` <- base::`+`
[10:33:13.731]             `<<-` <- base::`<<-`
[10:33:13.731]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:13.731]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:13.731]                   3L)]
[10:33:13.731]             }
[10:33:13.731]             function(cond) {
[10:33:13.731]                 is_error <- inherits(cond, "error")
[10:33:13.731]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:13.731]                   NULL)
[10:33:13.731]                 if (is_error) {
[10:33:13.731]                   sessionInformation <- function() {
[10:33:13.731]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:13.731]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:13.731]                       search = base::search(), system = base::Sys.info())
[10:33:13.731]                   }
[10:33:13.731]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.731]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:13.731]                     cond$call), session = sessionInformation(), 
[10:33:13.731]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:13.731]                   signalCondition(cond)
[10:33:13.731]                 }
[10:33:13.731]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:13.731]                 "immediateCondition"))) {
[10:33:13.731]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:13.731]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.731]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:13.731]                   if (TRUE && !signal) {
[10:33:13.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.731]                     {
[10:33:13.731]                       inherits <- base::inherits
[10:33:13.731]                       invokeRestart <- base::invokeRestart
[10:33:13.731]                       is.null <- base::is.null
[10:33:13.731]                       muffled <- FALSE
[10:33:13.731]                       if (inherits(cond, "message")) {
[10:33:13.731]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.731]                         if (muffled) 
[10:33:13.731]                           invokeRestart("muffleMessage")
[10:33:13.731]                       }
[10:33:13.731]                       else if (inherits(cond, "warning")) {
[10:33:13.731]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.731]                         if (muffled) 
[10:33:13.731]                           invokeRestart("muffleWarning")
[10:33:13.731]                       }
[10:33:13.731]                       else if (inherits(cond, "condition")) {
[10:33:13.731]                         if (!is.null(pattern)) {
[10:33:13.731]                           computeRestarts <- base::computeRestarts
[10:33:13.731]                           grepl <- base::grepl
[10:33:13.731]                           restarts <- computeRestarts(cond)
[10:33:13.731]                           for (restart in restarts) {
[10:33:13.731]                             name <- restart$name
[10:33:13.731]                             if (is.null(name)) 
[10:33:13.731]                               next
[10:33:13.731]                             if (!grepl(pattern, name)) 
[10:33:13.731]                               next
[10:33:13.731]                             invokeRestart(restart)
[10:33:13.731]                             muffled <- TRUE
[10:33:13.731]                             break
[10:33:13.731]                           }
[10:33:13.731]                         }
[10:33:13.731]                       }
[10:33:13.731]                       invisible(muffled)
[10:33:13.731]                     }
[10:33:13.731]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.731]                   }
[10:33:13.731]                 }
[10:33:13.731]                 else {
[10:33:13.731]                   if (TRUE) {
[10:33:13.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.731]                     {
[10:33:13.731]                       inherits <- base::inherits
[10:33:13.731]                       invokeRestart <- base::invokeRestart
[10:33:13.731]                       is.null <- base::is.null
[10:33:13.731]                       muffled <- FALSE
[10:33:13.731]                       if (inherits(cond, "message")) {
[10:33:13.731]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.731]                         if (muffled) 
[10:33:13.731]                           invokeRestart("muffleMessage")
[10:33:13.731]                       }
[10:33:13.731]                       else if (inherits(cond, "warning")) {
[10:33:13.731]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.731]                         if (muffled) 
[10:33:13.731]                           invokeRestart("muffleWarning")
[10:33:13.731]                       }
[10:33:13.731]                       else if (inherits(cond, "condition")) {
[10:33:13.731]                         if (!is.null(pattern)) {
[10:33:13.731]                           computeRestarts <- base::computeRestarts
[10:33:13.731]                           grepl <- base::grepl
[10:33:13.731]                           restarts <- computeRestarts(cond)
[10:33:13.731]                           for (restart in restarts) {
[10:33:13.731]                             name <- restart$name
[10:33:13.731]                             if (is.null(name)) 
[10:33:13.731]                               next
[10:33:13.731]                             if (!grepl(pattern, name)) 
[10:33:13.731]                               next
[10:33:13.731]                             invokeRestart(restart)
[10:33:13.731]                             muffled <- TRUE
[10:33:13.731]                             break
[10:33:13.731]                           }
[10:33:13.731]                         }
[10:33:13.731]                       }
[10:33:13.731]                       invisible(muffled)
[10:33:13.731]                     }
[10:33:13.731]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.731]                   }
[10:33:13.731]                 }
[10:33:13.731]             }
[10:33:13.731]         }))
[10:33:13.731]     }, error = function(ex) {
[10:33:13.731]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:13.731]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.731]                 ...future.rng), started = ...future.startTime, 
[10:33:13.731]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:13.731]             version = "1.8"), class = "FutureResult")
[10:33:13.731]     }, finally = {
[10:33:13.731]         if (!identical(...future.workdir, getwd())) 
[10:33:13.731]             setwd(...future.workdir)
[10:33:13.731]         {
[10:33:13.731]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:13.731]                 ...future.oldOptions$nwarnings <- NULL
[10:33:13.731]             }
[10:33:13.731]             base::options(...future.oldOptions)
[10:33:13.731]             if (.Platform$OS.type == "windows") {
[10:33:13.731]                 old_names <- names(...future.oldEnvVars)
[10:33:13.731]                 envs <- base::Sys.getenv()
[10:33:13.731]                 names <- names(envs)
[10:33:13.731]                 common <- intersect(names, old_names)
[10:33:13.731]                 added <- setdiff(names, old_names)
[10:33:13.731]                 removed <- setdiff(old_names, names)
[10:33:13.731]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:13.731]                   envs[common]]
[10:33:13.731]                 NAMES <- toupper(changed)
[10:33:13.731]                 args <- list()
[10:33:13.731]                 for (kk in seq_along(NAMES)) {
[10:33:13.731]                   name <- changed[[kk]]
[10:33:13.731]                   NAME <- NAMES[[kk]]
[10:33:13.731]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.731]                     next
[10:33:13.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.731]                 }
[10:33:13.731]                 NAMES <- toupper(added)
[10:33:13.731]                 for (kk in seq_along(NAMES)) {
[10:33:13.731]                   name <- added[[kk]]
[10:33:13.731]                   NAME <- NAMES[[kk]]
[10:33:13.731]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.731]                     next
[10:33:13.731]                   args[[name]] <- ""
[10:33:13.731]                 }
[10:33:13.731]                 NAMES <- toupper(removed)
[10:33:13.731]                 for (kk in seq_along(NAMES)) {
[10:33:13.731]                   name <- removed[[kk]]
[10:33:13.731]                   NAME <- NAMES[[kk]]
[10:33:13.731]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.731]                     next
[10:33:13.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.731]                 }
[10:33:13.731]                 if (length(args) > 0) 
[10:33:13.731]                   base::do.call(base::Sys.setenv, args = args)
[10:33:13.731]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:13.731]             }
[10:33:13.731]             else {
[10:33:13.731]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:13.731]             }
[10:33:13.731]             {
[10:33:13.731]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:13.731]                   0L) {
[10:33:13.731]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:13.731]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:13.731]                   base::options(opts)
[10:33:13.731]                 }
[10:33:13.731]                 {
[10:33:13.731]                   {
[10:33:13.731]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:13.731]                     NULL
[10:33:13.731]                   }
[10:33:13.731]                   options(future.plan = NULL)
[10:33:13.731]                   if (is.na(NA_character_)) 
[10:33:13.731]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.731]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:13.731]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:13.731]                     .init = FALSE)
[10:33:13.731]                 }
[10:33:13.731]             }
[10:33:13.731]         }
[10:33:13.731]     })
[10:33:13.731]     if (TRUE) {
[10:33:13.731]         base::sink(type = "output", split = FALSE)
[10:33:13.731]         if (TRUE) {
[10:33:13.731]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:13.731]         }
[10:33:13.731]         else {
[10:33:13.731]             ...future.result["stdout"] <- base::list(NULL)
[10:33:13.731]         }
[10:33:13.731]         base::close(...future.stdout)
[10:33:13.731]         ...future.stdout <- NULL
[10:33:13.731]     }
[10:33:13.731]     ...future.result$conditions <- ...future.conditions
[10:33:13.731]     ...future.result$finished <- base::Sys.time()
[10:33:13.731]     ...future.result
[10:33:13.731] }
[10:33:13.736] assign_globals() ...
[10:33:13.736] List of 1
[10:33:13.736]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55aa535476b8> 
[10:33:13.736]  - attr(*, "where")=List of 1
[10:33:13.736]   ..$ a:<environment: R_EmptyEnv> 
[10:33:13.736]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:13.736]  - attr(*, "resolved")= logi TRUE
[10:33:13.736]  - attr(*, "total_size")= num 1647176
[10:33:13.736]  - attr(*, "already-done")= logi TRUE
[10:33:13.740] - copied ‘a’ to environment
[10:33:13.740] assign_globals() ... done
[10:33:13.740] requestCore(): workers = 2
[10:33:13.742] MulticoreFuture started
[10:33:13.743] - Launch lazy future ... done
[10:33:13.743] run() for ‘MulticoreFuture’ ... done
[10:33:13.744] result() for MulticoreFuture ...
[10:33:13.744] plan(): Setting new future strategy stack:
[10:33:13.744] List of future strategies:
[10:33:13.744] 1. sequential:
[10:33:13.744]    - args: function (..., envir = parent.frame())
[10:33:13.744]    - tweaked: FALSE
[10:33:13.744]    - call: NULL
[10:33:13.746] plan(): nbrOfWorkers() = 1
[10:33:13.750] plan(): Setting new future strategy stack:
[10:33:13.750] List of future strategies:
[10:33:13.750] 1. multicore:
[10:33:13.750]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.750]    - tweaked: FALSE
[10:33:13.750]    - call: plan(strategy)
[10:33:13.756] plan(): nbrOfWorkers() = 2
[10:33:13.757] result() for MulticoreFuture ...
[10:33:13.758] result() for MulticoreFuture ... done
[10:33:13.758] signalConditions() ...
[10:33:13.758]  - include = ‘immediateCondition’
[10:33:13.758]  - exclude = 
[10:33:13.758]  - resignal = FALSE
[10:33:13.758]  - Number of conditions: 4
[10:33:13.759] signalConditions() ... done
[10:33:13.759] result() for MulticoreFuture ... done
[10:33:13.759] result() for MulticoreFuture ...
[10:33:13.759] result() for MulticoreFuture ... done
[10:33:13.759] signalConditions() ...
[10:33:13.759]  - include = ‘immediateCondition’
[10:33:13.760]  - exclude = 
[10:33:13.760]  - resignal = FALSE
[10:33:13.760]  - Number of conditions: 4
[10:33:13.760] signalConditions() ... done
[10:33:13.760] Future state: ‘finished’
[10:33:13.760] result() for MulticoreFuture ...
[10:33:13.760] result() for MulticoreFuture ... done
[10:33:13.761] signalConditions() ...
[10:33:13.761]  - include = ‘condition’
[10:33:13.761]  - exclude = ‘immediateCondition’
[10:33:13.761]  - resignal = TRUE
[10:33:13.761]  - Number of conditions: 4
[10:33:13.761]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.748] result() for MulticoreFuture ...
[10:33:13.762]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.748] result() for MulticoreFuture ... done
[10:33:13.762]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.748] result() for MulticoreFuture ...
[10:33:13.762]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.749] result() for MulticoreFuture ... done
[10:33:13.762] signalConditions() ... done
value(b) = 2
[10:33:13.762] result() for MulticoreFuture ...
[10:33:13.762] result() for MulticoreFuture ... done
[10:33:13.763] result() for MulticoreFuture ...
[10:33:13.763] result() for MulticoreFuture ... done
[10:33:13.763] signalConditions() ...
[10:33:13.763]  - include = ‘immediateCondition’
[10:33:13.763]  - exclude = 
[10:33:13.763]  - resignal = FALSE
[10:33:13.763]  - Number of conditions: 4
[10:33:13.763] signalConditions() ... done
[10:33:13.764] Future state: ‘finished’
[10:33:13.764] result() for MulticoreFuture ...
[10:33:13.764] result() for MulticoreFuture ... done
[10:33:13.764] signalConditions() ...
[10:33:13.764]  - include = ‘condition’
[10:33:13.764]  - exclude = ‘immediateCondition’
[10:33:13.764]  - resignal = TRUE
[10:33:13.764]  - Number of conditions: 4
[10:33:13.764]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.748] result() for MulticoreFuture ...
[10:33:13.765]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.748] result() for MulticoreFuture ... done
[10:33:13.765]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.748] result() for MulticoreFuture ...
[10:33:13.765]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:13.749] result() for MulticoreFuture ... done
[10:33:13.765] signalConditions() ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.766] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.766] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:13.767] - globals found: [2] ‘{’, ‘pkg’
[10:33:13.767] Searching for globals ... DONE
[10:33:13.767] Resolving globals: TRUE
[10:33:13.767] Resolving any globals that are futures ...
[10:33:13.767] - globals: [2] ‘{’, ‘pkg’
[10:33:13.767] Resolving any globals that are futures ... DONE
[10:33:13.768] Resolving futures part of globals (recursively) ...
[10:33:13.768] resolve() on list ...
[10:33:13.768]  recursive: 99
[10:33:13.768]  length: 1
[10:33:13.769]  elements: ‘pkg’
[10:33:13.769]  length: 0 (resolved future 1)
[10:33:13.769] resolve() on list ... DONE
[10:33:13.769] - globals: [1] ‘pkg’
[10:33:13.769] Resolving futures part of globals (recursively) ... DONE
[10:33:13.769] The total size of the 1 globals is 112 bytes (112 bytes)
[10:33:13.770] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[10:33:13.770] - globals: [1] ‘pkg’
[10:33:13.770] 
[10:33:13.770] getGlobalsAndPackages() ... DONE
[10:33:13.771] Packages needed by the future expression (n = 0): <none>
[10:33:13.771] Packages needed by future strategies (n = 0): <none>
[10:33:13.771] {
[10:33:13.771]     {
[10:33:13.771]         {
[10:33:13.771]             ...future.startTime <- base::Sys.time()
[10:33:13.771]             {
[10:33:13.771]                 {
[10:33:13.771]                   {
[10:33:13.771]                     base::local({
[10:33:13.771]                       has_future <- base::requireNamespace("future", 
[10:33:13.771]                         quietly = TRUE)
[10:33:13.771]                       if (has_future) {
[10:33:13.771]                         ns <- base::getNamespace("future")
[10:33:13.771]                         version <- ns[[".package"]][["version"]]
[10:33:13.771]                         if (is.null(version)) 
[10:33:13.771]                           version <- utils::packageVersion("future")
[10:33:13.771]                       }
[10:33:13.771]                       else {
[10:33:13.771]                         version <- NULL
[10:33:13.771]                       }
[10:33:13.771]                       if (!has_future || version < "1.8.0") {
[10:33:13.771]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:13.771]                           "", base::R.version$version.string), 
[10:33:13.771]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:13.771]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:13.771]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:13.771]                             "release", "version")], collapse = " "), 
[10:33:13.771]                           hostname = base::Sys.info()[["nodename"]])
[10:33:13.771]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:13.771]                           info)
[10:33:13.771]                         info <- base::paste(info, collapse = "; ")
[10:33:13.771]                         if (!has_future) {
[10:33:13.771]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:13.771]                             info)
[10:33:13.771]                         }
[10:33:13.771]                         else {
[10:33:13.771]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:13.771]                             info, version)
[10:33:13.771]                         }
[10:33:13.771]                         base::stop(msg)
[10:33:13.771]                       }
[10:33:13.771]                     })
[10:33:13.771]                   }
[10:33:13.771]                   ...future.strategy.old <- future::plan("list")
[10:33:13.771]                   options(future.plan = NULL)
[10:33:13.771]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.771]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:13.771]                 }
[10:33:13.771]                 ...future.workdir <- getwd()
[10:33:13.771]             }
[10:33:13.771]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:13.771]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:13.771]         }
[10:33:13.771]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:13.771]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:13.771]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:13.771]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:13.771]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:13.771]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:13.771]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:13.771]             base::names(...future.oldOptions))
[10:33:13.771]     }
[10:33:13.771]     if (FALSE) {
[10:33:13.771]     }
[10:33:13.771]     else {
[10:33:13.771]         if (TRUE) {
[10:33:13.771]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:13.771]                 open = "w")
[10:33:13.771]         }
[10:33:13.771]         else {
[10:33:13.771]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:13.771]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:13.771]         }
[10:33:13.771]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:13.771]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:13.771]             base::sink(type = "output", split = FALSE)
[10:33:13.771]             base::close(...future.stdout)
[10:33:13.771]         }, add = TRUE)
[10:33:13.771]     }
[10:33:13.771]     ...future.frame <- base::sys.nframe()
[10:33:13.771]     ...future.conditions <- base::list()
[10:33:13.771]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:13.771]     if (FALSE) {
[10:33:13.771]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:13.771]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:13.771]     }
[10:33:13.771]     ...future.result <- base::tryCatch({
[10:33:13.771]         base::withCallingHandlers({
[10:33:13.771]             ...future.value <- base::withVisible(base::local({
[10:33:13.771]                 pkg
[10:33:13.771]             }))
[10:33:13.771]             future::FutureResult(value = ...future.value$value, 
[10:33:13.771]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.771]                   ...future.rng), globalenv = if (FALSE) 
[10:33:13.771]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:13.771]                     ...future.globalenv.names))
[10:33:13.771]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:13.771]         }, condition = base::local({
[10:33:13.771]             c <- base::c
[10:33:13.771]             inherits <- base::inherits
[10:33:13.771]             invokeRestart <- base::invokeRestart
[10:33:13.771]             length <- base::length
[10:33:13.771]             list <- base::list
[10:33:13.771]             seq.int <- base::seq.int
[10:33:13.771]             signalCondition <- base::signalCondition
[10:33:13.771]             sys.calls <- base::sys.calls
[10:33:13.771]             `[[` <- base::`[[`
[10:33:13.771]             `+` <- base::`+`
[10:33:13.771]             `<<-` <- base::`<<-`
[10:33:13.771]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:13.771]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:13.771]                   3L)]
[10:33:13.771]             }
[10:33:13.771]             function(cond) {
[10:33:13.771]                 is_error <- inherits(cond, "error")
[10:33:13.771]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:13.771]                   NULL)
[10:33:13.771]                 if (is_error) {
[10:33:13.771]                   sessionInformation <- function() {
[10:33:13.771]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:13.771]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:13.771]                       search = base::search(), system = base::Sys.info())
[10:33:13.771]                   }
[10:33:13.771]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.771]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:13.771]                     cond$call), session = sessionInformation(), 
[10:33:13.771]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:13.771]                   signalCondition(cond)
[10:33:13.771]                 }
[10:33:13.771]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:13.771]                 "immediateCondition"))) {
[10:33:13.771]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:13.771]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.771]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:13.771]                   if (TRUE && !signal) {
[10:33:13.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.771]                     {
[10:33:13.771]                       inherits <- base::inherits
[10:33:13.771]                       invokeRestart <- base::invokeRestart
[10:33:13.771]                       is.null <- base::is.null
[10:33:13.771]                       muffled <- FALSE
[10:33:13.771]                       if (inherits(cond, "message")) {
[10:33:13.771]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.771]                         if (muffled) 
[10:33:13.771]                           invokeRestart("muffleMessage")
[10:33:13.771]                       }
[10:33:13.771]                       else if (inherits(cond, "warning")) {
[10:33:13.771]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.771]                         if (muffled) 
[10:33:13.771]                           invokeRestart("muffleWarning")
[10:33:13.771]                       }
[10:33:13.771]                       else if (inherits(cond, "condition")) {
[10:33:13.771]                         if (!is.null(pattern)) {
[10:33:13.771]                           computeRestarts <- base::computeRestarts
[10:33:13.771]                           grepl <- base::grepl
[10:33:13.771]                           restarts <- computeRestarts(cond)
[10:33:13.771]                           for (restart in restarts) {
[10:33:13.771]                             name <- restart$name
[10:33:13.771]                             if (is.null(name)) 
[10:33:13.771]                               next
[10:33:13.771]                             if (!grepl(pattern, name)) 
[10:33:13.771]                               next
[10:33:13.771]                             invokeRestart(restart)
[10:33:13.771]                             muffled <- TRUE
[10:33:13.771]                             break
[10:33:13.771]                           }
[10:33:13.771]                         }
[10:33:13.771]                       }
[10:33:13.771]                       invisible(muffled)
[10:33:13.771]                     }
[10:33:13.771]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.771]                   }
[10:33:13.771]                 }
[10:33:13.771]                 else {
[10:33:13.771]                   if (TRUE) {
[10:33:13.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.771]                     {
[10:33:13.771]                       inherits <- base::inherits
[10:33:13.771]                       invokeRestart <- base::invokeRestart
[10:33:13.771]                       is.null <- base::is.null
[10:33:13.771]                       muffled <- FALSE
[10:33:13.771]                       if (inherits(cond, "message")) {
[10:33:13.771]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.771]                         if (muffled) 
[10:33:13.771]                           invokeRestart("muffleMessage")
[10:33:13.771]                       }
[10:33:13.771]                       else if (inherits(cond, "warning")) {
[10:33:13.771]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.771]                         if (muffled) 
[10:33:13.771]                           invokeRestart("muffleWarning")
[10:33:13.771]                       }
[10:33:13.771]                       else if (inherits(cond, "condition")) {
[10:33:13.771]                         if (!is.null(pattern)) {
[10:33:13.771]                           computeRestarts <- base::computeRestarts
[10:33:13.771]                           grepl <- base::grepl
[10:33:13.771]                           restarts <- computeRestarts(cond)
[10:33:13.771]                           for (restart in restarts) {
[10:33:13.771]                             name <- restart$name
[10:33:13.771]                             if (is.null(name)) 
[10:33:13.771]                               next
[10:33:13.771]                             if (!grepl(pattern, name)) 
[10:33:13.771]                               next
[10:33:13.771]                             invokeRestart(restart)
[10:33:13.771]                             muffled <- TRUE
[10:33:13.771]                             break
[10:33:13.771]                           }
[10:33:13.771]                         }
[10:33:13.771]                       }
[10:33:13.771]                       invisible(muffled)
[10:33:13.771]                     }
[10:33:13.771]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.771]                   }
[10:33:13.771]                 }
[10:33:13.771]             }
[10:33:13.771]         }))
[10:33:13.771]     }, error = function(ex) {
[10:33:13.771]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:13.771]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.771]                 ...future.rng), started = ...future.startTime, 
[10:33:13.771]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:13.771]             version = "1.8"), class = "FutureResult")
[10:33:13.771]     }, finally = {
[10:33:13.771]         if (!identical(...future.workdir, getwd())) 
[10:33:13.771]             setwd(...future.workdir)
[10:33:13.771]         {
[10:33:13.771]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:13.771]                 ...future.oldOptions$nwarnings <- NULL
[10:33:13.771]             }
[10:33:13.771]             base::options(...future.oldOptions)
[10:33:13.771]             if (.Platform$OS.type == "windows") {
[10:33:13.771]                 old_names <- names(...future.oldEnvVars)
[10:33:13.771]                 envs <- base::Sys.getenv()
[10:33:13.771]                 names <- names(envs)
[10:33:13.771]                 common <- intersect(names, old_names)
[10:33:13.771]                 added <- setdiff(names, old_names)
[10:33:13.771]                 removed <- setdiff(old_names, names)
[10:33:13.771]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:13.771]                   envs[common]]
[10:33:13.771]                 NAMES <- toupper(changed)
[10:33:13.771]                 args <- list()
[10:33:13.771]                 for (kk in seq_along(NAMES)) {
[10:33:13.771]                   name <- changed[[kk]]
[10:33:13.771]                   NAME <- NAMES[[kk]]
[10:33:13.771]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.771]                     next
[10:33:13.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.771]                 }
[10:33:13.771]                 NAMES <- toupper(added)
[10:33:13.771]                 for (kk in seq_along(NAMES)) {
[10:33:13.771]                   name <- added[[kk]]
[10:33:13.771]                   NAME <- NAMES[[kk]]
[10:33:13.771]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.771]                     next
[10:33:13.771]                   args[[name]] <- ""
[10:33:13.771]                 }
[10:33:13.771]                 NAMES <- toupper(removed)
[10:33:13.771]                 for (kk in seq_along(NAMES)) {
[10:33:13.771]                   name <- removed[[kk]]
[10:33:13.771]                   NAME <- NAMES[[kk]]
[10:33:13.771]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.771]                     next
[10:33:13.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.771]                 }
[10:33:13.771]                 if (length(args) > 0) 
[10:33:13.771]                   base::do.call(base::Sys.setenv, args = args)
[10:33:13.771]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:13.771]             }
[10:33:13.771]             else {
[10:33:13.771]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:13.771]             }
[10:33:13.771]             {
[10:33:13.771]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:13.771]                   0L) {
[10:33:13.771]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:13.771]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:13.771]                   base::options(opts)
[10:33:13.771]                 }
[10:33:13.771]                 {
[10:33:13.771]                   {
[10:33:13.771]                     NULL
[10:33:13.771]                     RNGkind("Mersenne-Twister")
[10:33:13.771]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:13.771]                       inherits = FALSE)
[10:33:13.771]                   }
[10:33:13.771]                   options(future.plan = NULL)
[10:33:13.771]                   if (is.na(NA_character_)) 
[10:33:13.771]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.771]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:13.771]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:13.771]                     .init = FALSE)
[10:33:13.771]                 }
[10:33:13.771]             }
[10:33:13.771]         }
[10:33:13.771]     })
[10:33:13.771]     if (TRUE) {
[10:33:13.771]         base::sink(type = "output", split = FALSE)
[10:33:13.771]         if (TRUE) {
[10:33:13.771]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:13.771]         }
[10:33:13.771]         else {
[10:33:13.771]             ...future.result["stdout"] <- base::list(NULL)
[10:33:13.771]         }
[10:33:13.771]         base::close(...future.stdout)
[10:33:13.771]         ...future.stdout <- NULL
[10:33:13.771]     }
[10:33:13.771]     ...future.result$conditions <- ...future.conditions
[10:33:13.771]     ...future.result$finished <- base::Sys.time()
[10:33:13.771]     ...future.result
[10:33:13.771] }
[10:33:13.773] assign_globals() ...
[10:33:13.774] List of 1
[10:33:13.774]  $ pkg: chr "foo"
[10:33:13.774]  - attr(*, "where")=List of 1
[10:33:13.774]   ..$ pkg:<environment: R_EmptyEnv> 
[10:33:13.774]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:13.774]  - attr(*, "resolved")= logi TRUE
[10:33:13.774]  - attr(*, "total_size")= num 112
[10:33:13.776] - copied ‘pkg’ to environment
[10:33:13.776] assign_globals() ... done
[10:33:13.777] plan(): Setting new future strategy stack:
[10:33:13.777] List of future strategies:
[10:33:13.777] 1. sequential:
[10:33:13.777]    - args: function (..., envir = parent.frame())
[10:33:13.777]    - tweaked: FALSE
[10:33:13.777]    - call: NULL
[10:33:13.777] plan(): nbrOfWorkers() = 1
[10:33:13.780] plan(): Setting new future strategy stack:
[10:33:13.781] List of future strategies:
[10:33:13.781] 1. multicore:
[10:33:13.781]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.781]    - tweaked: FALSE
[10:33:13.781]    - call: plan(strategy)
[10:33:13.785] plan(): nbrOfWorkers() = 2
[10:33:13.785] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.786] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.786] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:13.789] - globals found: [3] ‘{’, ‘<-’, ‘+’
[10:33:13.789] Searching for globals ... DONE
[10:33:13.789] Resolving globals: TRUE
[10:33:13.789] Resolving any globals that are futures ...
[10:33:13.789] - globals: [3] ‘{’, ‘<-’, ‘+’
[10:33:13.789] Resolving any globals that are futures ... DONE
[10:33:13.790] 
[10:33:13.790] 
[10:33:13.790] getGlobalsAndPackages() ... DONE
[10:33:13.790] run() for ‘Future’ ...
[10:33:13.790] - state: ‘created’
[10:33:13.790] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:13.794] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:13.794] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:13.794]   - Field: ‘label’
[10:33:13.794]   - Field: ‘local’
[10:33:13.794]   - Field: ‘owner’
[10:33:13.794]   - Field: ‘envir’
[10:33:13.795]   - Field: ‘workers’
[10:33:13.795]   - Field: ‘packages’
[10:33:13.795]   - Field: ‘gc’
[10:33:13.795]   - Field: ‘job’
[10:33:13.795]   - Field: ‘conditions’
[10:33:13.795]   - Field: ‘expr’
[10:33:13.795]   - Field: ‘uuid’
[10:33:13.795]   - Field: ‘seed’
[10:33:13.795]   - Field: ‘version’
[10:33:13.795]   - Field: ‘result’
[10:33:13.795]   - Field: ‘asynchronous’
[10:33:13.796]   - Field: ‘calls’
[10:33:13.796]   - Field: ‘globals’
[10:33:13.796]   - Field: ‘stdout’
[10:33:13.796]   - Field: ‘earlySignal’
[10:33:13.796]   - Field: ‘lazy’
[10:33:13.796]   - Field: ‘state’
[10:33:13.796] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:13.796] - Launch lazy future ...
[10:33:13.797] Packages needed by the future expression (n = 0): <none>
[10:33:13.797] Packages needed by future strategies (n = 0): <none>
[10:33:13.797] {
[10:33:13.797]     {
[10:33:13.797]         {
[10:33:13.797]             ...future.startTime <- base::Sys.time()
[10:33:13.797]             {
[10:33:13.797]                 {
[10:33:13.797]                   {
[10:33:13.797]                     {
[10:33:13.797]                       base::local({
[10:33:13.797]                         has_future <- base::requireNamespace("future", 
[10:33:13.797]                           quietly = TRUE)
[10:33:13.797]                         if (has_future) {
[10:33:13.797]                           ns <- base::getNamespace("future")
[10:33:13.797]                           version <- ns[[".package"]][["version"]]
[10:33:13.797]                           if (is.null(version)) 
[10:33:13.797]                             version <- utils::packageVersion("future")
[10:33:13.797]                         }
[10:33:13.797]                         else {
[10:33:13.797]                           version <- NULL
[10:33:13.797]                         }
[10:33:13.797]                         if (!has_future || version < "1.8.0") {
[10:33:13.797]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:13.797]                             "", base::R.version$version.string), 
[10:33:13.797]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:13.797]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:13.797]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:13.797]                               "release", "version")], collapse = " "), 
[10:33:13.797]                             hostname = base::Sys.info()[["nodename"]])
[10:33:13.797]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:13.797]                             info)
[10:33:13.797]                           info <- base::paste(info, collapse = "; ")
[10:33:13.797]                           if (!has_future) {
[10:33:13.797]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:13.797]                               info)
[10:33:13.797]                           }
[10:33:13.797]                           else {
[10:33:13.797]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:13.797]                               info, version)
[10:33:13.797]                           }
[10:33:13.797]                           base::stop(msg)
[10:33:13.797]                         }
[10:33:13.797]                       })
[10:33:13.797]                     }
[10:33:13.797]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:13.797]                     base::options(mc.cores = 1L)
[10:33:13.797]                   }
[10:33:13.797]                   ...future.strategy.old <- future::plan("list")
[10:33:13.797]                   options(future.plan = NULL)
[10:33:13.797]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.797]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:13.797]                 }
[10:33:13.797]                 ...future.workdir <- getwd()
[10:33:13.797]             }
[10:33:13.797]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:13.797]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:13.797]         }
[10:33:13.797]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:13.797]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:13.797]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:13.797]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:13.797]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:13.797]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:13.797]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:13.797]             base::names(...future.oldOptions))
[10:33:13.797]     }
[10:33:13.797]     if (FALSE) {
[10:33:13.797]     }
[10:33:13.797]     else {
[10:33:13.797]         if (TRUE) {
[10:33:13.797]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:13.797]                 open = "w")
[10:33:13.797]         }
[10:33:13.797]         else {
[10:33:13.797]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:13.797]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:13.797]         }
[10:33:13.797]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:13.797]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:13.797]             base::sink(type = "output", split = FALSE)
[10:33:13.797]             base::close(...future.stdout)
[10:33:13.797]         }, add = TRUE)
[10:33:13.797]     }
[10:33:13.797]     ...future.frame <- base::sys.nframe()
[10:33:13.797]     ...future.conditions <- base::list()
[10:33:13.797]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:13.797]     if (FALSE) {
[10:33:13.797]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:13.797]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:13.797]     }
[10:33:13.797]     ...future.result <- base::tryCatch({
[10:33:13.797]         base::withCallingHandlers({
[10:33:13.797]             ...future.value <- base::withVisible(base::local({
[10:33:13.797]                 withCallingHandlers({
[10:33:13.797]                   {
[10:33:13.797]                     x <- 0
[10:33:13.797]                     x <- x + 1
[10:33:13.797]                     x
[10:33:13.797]                   }
[10:33:13.797]                 }, immediateCondition = function(cond) {
[10:33:13.797]                   save_rds <- function (object, pathname, ...) 
[10:33:13.797]                   {
[10:33:13.797]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:13.797]                     if (file_test("-f", pathname_tmp)) {
[10:33:13.797]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.797]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:13.797]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.797]                         fi_tmp[["mtime"]])
[10:33:13.797]                     }
[10:33:13.797]                     tryCatch({
[10:33:13.797]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:13.797]                     }, error = function(ex) {
[10:33:13.797]                       msg <- conditionMessage(ex)
[10:33:13.797]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.797]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:13.797]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.797]                         fi_tmp[["mtime"]], msg)
[10:33:13.797]                       ex$message <- msg
[10:33:13.797]                       stop(ex)
[10:33:13.797]                     })
[10:33:13.797]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:13.797]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:13.797]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:13.797]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.797]                       fi <- file.info(pathname)
[10:33:13.797]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:13.797]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.797]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:13.797]                         fi[["size"]], fi[["mtime"]])
[10:33:13.797]                       stop(msg)
[10:33:13.797]                     }
[10:33:13.797]                     invisible(pathname)
[10:33:13.797]                   }
[10:33:13.797]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:13.797]                     rootPath = tempdir()) 
[10:33:13.797]                   {
[10:33:13.797]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:13.797]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:13.797]                       tmpdir = path, fileext = ".rds")
[10:33:13.797]                     save_rds(obj, file)
[10:33:13.797]                   }
[10:33:13.797]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:13.797]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.797]                   {
[10:33:13.797]                     inherits <- base::inherits
[10:33:13.797]                     invokeRestart <- base::invokeRestart
[10:33:13.797]                     is.null <- base::is.null
[10:33:13.797]                     muffled <- FALSE
[10:33:13.797]                     if (inherits(cond, "message")) {
[10:33:13.797]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:13.797]                       if (muffled) 
[10:33:13.797]                         invokeRestart("muffleMessage")
[10:33:13.797]                     }
[10:33:13.797]                     else if (inherits(cond, "warning")) {
[10:33:13.797]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:13.797]                       if (muffled) 
[10:33:13.797]                         invokeRestart("muffleWarning")
[10:33:13.797]                     }
[10:33:13.797]                     else if (inherits(cond, "condition")) {
[10:33:13.797]                       if (!is.null(pattern)) {
[10:33:13.797]                         computeRestarts <- base::computeRestarts
[10:33:13.797]                         grepl <- base::grepl
[10:33:13.797]                         restarts <- computeRestarts(cond)
[10:33:13.797]                         for (restart in restarts) {
[10:33:13.797]                           name <- restart$name
[10:33:13.797]                           if (is.null(name)) 
[10:33:13.797]                             next
[10:33:13.797]                           if (!grepl(pattern, name)) 
[10:33:13.797]                             next
[10:33:13.797]                           invokeRestart(restart)
[10:33:13.797]                           muffled <- TRUE
[10:33:13.797]                           break
[10:33:13.797]                         }
[10:33:13.797]                       }
[10:33:13.797]                     }
[10:33:13.797]                     invisible(muffled)
[10:33:13.797]                   }
[10:33:13.797]                   muffleCondition(cond)
[10:33:13.797]                 })
[10:33:13.797]             }))
[10:33:13.797]             future::FutureResult(value = ...future.value$value, 
[10:33:13.797]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.797]                   ...future.rng), globalenv = if (FALSE) 
[10:33:13.797]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:13.797]                     ...future.globalenv.names))
[10:33:13.797]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:13.797]         }, condition = base::local({
[10:33:13.797]             c <- base::c
[10:33:13.797]             inherits <- base::inherits
[10:33:13.797]             invokeRestart <- base::invokeRestart
[10:33:13.797]             length <- base::length
[10:33:13.797]             list <- base::list
[10:33:13.797]             seq.int <- base::seq.int
[10:33:13.797]             signalCondition <- base::signalCondition
[10:33:13.797]             sys.calls <- base::sys.calls
[10:33:13.797]             `[[` <- base::`[[`
[10:33:13.797]             `+` <- base::`+`
[10:33:13.797]             `<<-` <- base::`<<-`
[10:33:13.797]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:13.797]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:13.797]                   3L)]
[10:33:13.797]             }
[10:33:13.797]             function(cond) {
[10:33:13.797]                 is_error <- inherits(cond, "error")
[10:33:13.797]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:13.797]                   NULL)
[10:33:13.797]                 if (is_error) {
[10:33:13.797]                   sessionInformation <- function() {
[10:33:13.797]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:13.797]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:13.797]                       search = base::search(), system = base::Sys.info())
[10:33:13.797]                   }
[10:33:13.797]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.797]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:13.797]                     cond$call), session = sessionInformation(), 
[10:33:13.797]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:13.797]                   signalCondition(cond)
[10:33:13.797]                 }
[10:33:13.797]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:13.797]                 "immediateCondition"))) {
[10:33:13.797]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:13.797]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.797]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:13.797]                   if (TRUE && !signal) {
[10:33:13.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.797]                     {
[10:33:13.797]                       inherits <- base::inherits
[10:33:13.797]                       invokeRestart <- base::invokeRestart
[10:33:13.797]                       is.null <- base::is.null
[10:33:13.797]                       muffled <- FALSE
[10:33:13.797]                       if (inherits(cond, "message")) {
[10:33:13.797]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.797]                         if (muffled) 
[10:33:13.797]                           invokeRestart("muffleMessage")
[10:33:13.797]                       }
[10:33:13.797]                       else if (inherits(cond, "warning")) {
[10:33:13.797]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.797]                         if (muffled) 
[10:33:13.797]                           invokeRestart("muffleWarning")
[10:33:13.797]                       }
[10:33:13.797]                       else if (inherits(cond, "condition")) {
[10:33:13.797]                         if (!is.null(pattern)) {
[10:33:13.797]                           computeRestarts <- base::computeRestarts
[10:33:13.797]                           grepl <- base::grepl
[10:33:13.797]                           restarts <- computeRestarts(cond)
[10:33:13.797]                           for (restart in restarts) {
[10:33:13.797]                             name <- restart$name
[10:33:13.797]                             if (is.null(name)) 
[10:33:13.797]                               next
[10:33:13.797]                             if (!grepl(pattern, name)) 
[10:33:13.797]                               next
[10:33:13.797]                             invokeRestart(restart)
[10:33:13.797]                             muffled <- TRUE
[10:33:13.797]                             break
[10:33:13.797]                           }
[10:33:13.797]                         }
[10:33:13.797]                       }
[10:33:13.797]                       invisible(muffled)
[10:33:13.797]                     }
[10:33:13.797]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.797]                   }
[10:33:13.797]                 }
[10:33:13.797]                 else {
[10:33:13.797]                   if (TRUE) {
[10:33:13.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.797]                     {
[10:33:13.797]                       inherits <- base::inherits
[10:33:13.797]                       invokeRestart <- base::invokeRestart
[10:33:13.797]                       is.null <- base::is.null
[10:33:13.797]                       muffled <- FALSE
[10:33:13.797]                       if (inherits(cond, "message")) {
[10:33:13.797]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.797]                         if (muffled) 
[10:33:13.797]                           invokeRestart("muffleMessage")
[10:33:13.797]                       }
[10:33:13.797]                       else if (inherits(cond, "warning")) {
[10:33:13.797]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.797]                         if (muffled) 
[10:33:13.797]                           invokeRestart("muffleWarning")
[10:33:13.797]                       }
[10:33:13.797]                       else if (inherits(cond, "condition")) {
[10:33:13.797]                         if (!is.null(pattern)) {
[10:33:13.797]                           computeRestarts <- base::computeRestarts
[10:33:13.797]                           grepl <- base::grepl
[10:33:13.797]                           restarts <- computeRestarts(cond)
[10:33:13.797]                           for (restart in restarts) {
[10:33:13.797]                             name <- restart$name
[10:33:13.797]                             if (is.null(name)) 
[10:33:13.797]                               next
[10:33:13.797]                             if (!grepl(pattern, name)) 
[10:33:13.797]                               next
[10:33:13.797]                             invokeRestart(restart)
[10:33:13.797]                             muffled <- TRUE
[10:33:13.797]                             break
[10:33:13.797]                           }
[10:33:13.797]                         }
[10:33:13.797]                       }
[10:33:13.797]                       invisible(muffled)
[10:33:13.797]                     }
[10:33:13.797]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.797]                   }
[10:33:13.797]                 }
[10:33:13.797]             }
[10:33:13.797]         }))
[10:33:13.797]     }, error = function(ex) {
[10:33:13.797]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:13.797]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.797]                 ...future.rng), started = ...future.startTime, 
[10:33:13.797]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:13.797]             version = "1.8"), class = "FutureResult")
[10:33:13.797]     }, finally = {
[10:33:13.797]         if (!identical(...future.workdir, getwd())) 
[10:33:13.797]             setwd(...future.workdir)
[10:33:13.797]         {
[10:33:13.797]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:13.797]                 ...future.oldOptions$nwarnings <- NULL
[10:33:13.797]             }
[10:33:13.797]             base::options(...future.oldOptions)
[10:33:13.797]             if (.Platform$OS.type == "windows") {
[10:33:13.797]                 old_names <- names(...future.oldEnvVars)
[10:33:13.797]                 envs <- base::Sys.getenv()
[10:33:13.797]                 names <- names(envs)
[10:33:13.797]                 common <- intersect(names, old_names)
[10:33:13.797]                 added <- setdiff(names, old_names)
[10:33:13.797]                 removed <- setdiff(old_names, names)
[10:33:13.797]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:13.797]                   envs[common]]
[10:33:13.797]                 NAMES <- toupper(changed)
[10:33:13.797]                 args <- list()
[10:33:13.797]                 for (kk in seq_along(NAMES)) {
[10:33:13.797]                   name <- changed[[kk]]
[10:33:13.797]                   NAME <- NAMES[[kk]]
[10:33:13.797]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.797]                     next
[10:33:13.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.797]                 }
[10:33:13.797]                 NAMES <- toupper(added)
[10:33:13.797]                 for (kk in seq_along(NAMES)) {
[10:33:13.797]                   name <- added[[kk]]
[10:33:13.797]                   NAME <- NAMES[[kk]]
[10:33:13.797]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.797]                     next
[10:33:13.797]                   args[[name]] <- ""
[10:33:13.797]                 }
[10:33:13.797]                 NAMES <- toupper(removed)
[10:33:13.797]                 for (kk in seq_along(NAMES)) {
[10:33:13.797]                   name <- removed[[kk]]
[10:33:13.797]                   NAME <- NAMES[[kk]]
[10:33:13.797]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.797]                     next
[10:33:13.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.797]                 }
[10:33:13.797]                 if (length(args) > 0) 
[10:33:13.797]                   base::do.call(base::Sys.setenv, args = args)
[10:33:13.797]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:13.797]             }
[10:33:13.797]             else {
[10:33:13.797]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:13.797]             }
[10:33:13.797]             {
[10:33:13.797]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:13.797]                   0L) {
[10:33:13.797]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:13.797]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:13.797]                   base::options(opts)
[10:33:13.797]                 }
[10:33:13.797]                 {
[10:33:13.797]                   {
[10:33:13.797]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:13.797]                     NULL
[10:33:13.797]                   }
[10:33:13.797]                   options(future.plan = NULL)
[10:33:13.797]                   if (is.na(NA_character_)) 
[10:33:13.797]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.797]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:13.797]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:13.797]                     .init = FALSE)
[10:33:13.797]                 }
[10:33:13.797]             }
[10:33:13.797]         }
[10:33:13.797]     })
[10:33:13.797]     if (TRUE) {
[10:33:13.797]         base::sink(type = "output", split = FALSE)
[10:33:13.797]         if (TRUE) {
[10:33:13.797]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:13.797]         }
[10:33:13.797]         else {
[10:33:13.797]             ...future.result["stdout"] <- base::list(NULL)
[10:33:13.797]         }
[10:33:13.797]         base::close(...future.stdout)
[10:33:13.797]         ...future.stdout <- NULL
[10:33:13.797]     }
[10:33:13.797]     ...future.result$conditions <- ...future.conditions
[10:33:13.797]     ...future.result$finished <- base::Sys.time()
[10:33:13.797]     ...future.result
[10:33:13.797] }
[10:33:13.799] requestCore(): workers = 2
[10:33:13.802] MulticoreFuture started
[10:33:13.802] - Launch lazy future ... done
[10:33:13.802] run() for ‘MulticoreFuture’ ... done
[10:33:13.802] result() for MulticoreFuture ...
[10:33:13.803] plan(): Setting new future strategy stack:
[10:33:13.803] List of future strategies:
[10:33:13.803] 1. sequential:
[10:33:13.803]    - args: function (..., envir = parent.frame())
[10:33:13.803]    - tweaked: FALSE
[10:33:13.803]    - call: NULL
[10:33:13.804] plan(): nbrOfWorkers() = 1
[10:33:13.806] plan(): Setting new future strategy stack:
[10:33:13.806] List of future strategies:
[10:33:13.806] 1. multicore:
[10:33:13.806]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.806]    - tweaked: FALSE
[10:33:13.806]    - call: plan(strategy)
[10:33:13.812] plan(): nbrOfWorkers() = 2
[10:33:13.812] result() for MulticoreFuture ...
[10:33:13.813] result() for MulticoreFuture ... done
[10:33:13.813] result() for MulticoreFuture ... done
[10:33:13.813] result() for MulticoreFuture ...
[10:33:13.813] result() for MulticoreFuture ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.814] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.814] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:13.816] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[10:33:13.816] Searching for globals ... DONE
[10:33:13.816] Resolving globals: TRUE
[10:33:13.816] Resolving any globals that are futures ...
[10:33:13.817] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[10:33:13.817] Resolving any globals that are futures ... DONE
[10:33:13.817] Resolving futures part of globals (recursively) ...
[10:33:13.818] resolve() on list ...
[10:33:13.818]  recursive: 99
[10:33:13.818]  length: 1
[10:33:13.818]  elements: ‘x’
[10:33:13.818]  length: 0 (resolved future 1)
[10:33:13.818] resolve() on list ... DONE
[10:33:13.818] - globals: [1] ‘x’
[10:33:13.818] Resolving futures part of globals (recursively) ... DONE
[10:33:13.819] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:13.819] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[10:33:13.819] - globals: [1] ‘x’
[10:33:13.819] 
[10:33:13.819] getGlobalsAndPackages() ... DONE
[10:33:13.820] run() for ‘Future’ ...
[10:33:13.820] - state: ‘created’
[10:33:13.820] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:13.827] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:13.828] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:13.828]   - Field: ‘label’
[10:33:13.828]   - Field: ‘local’
[10:33:13.828]   - Field: ‘owner’
[10:33:13.828]   - Field: ‘envir’
[10:33:13.828]   - Field: ‘workers’
[10:33:13.828]   - Field: ‘packages’
[10:33:13.829]   - Field: ‘gc’
[10:33:13.829]   - Field: ‘job’
[10:33:13.829]   - Field: ‘conditions’
[10:33:13.829]   - Field: ‘expr’
[10:33:13.829]   - Field: ‘uuid’
[10:33:13.829]   - Field: ‘seed’
[10:33:13.829]   - Field: ‘version’
[10:33:13.830]   - Field: ‘result’
[10:33:13.830]   - Field: ‘asynchronous’
[10:33:13.830]   - Field: ‘calls’
[10:33:13.830]   - Field: ‘globals’
[10:33:13.830]   - Field: ‘stdout’
[10:33:13.830]   - Field: ‘earlySignal’
[10:33:13.830]   - Field: ‘lazy’
[10:33:13.831]   - Field: ‘state’
[10:33:13.831] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:13.831] - Launch lazy future ...
[10:33:13.831] Packages needed by the future expression (n = 0): <none>
[10:33:13.831] Packages needed by future strategies (n = 0): <none>
[10:33:13.832] {
[10:33:13.832]     {
[10:33:13.832]         {
[10:33:13.832]             ...future.startTime <- base::Sys.time()
[10:33:13.832]             {
[10:33:13.832]                 {
[10:33:13.832]                   {
[10:33:13.832]                     {
[10:33:13.832]                       base::local({
[10:33:13.832]                         has_future <- base::requireNamespace("future", 
[10:33:13.832]                           quietly = TRUE)
[10:33:13.832]                         if (has_future) {
[10:33:13.832]                           ns <- base::getNamespace("future")
[10:33:13.832]                           version <- ns[[".package"]][["version"]]
[10:33:13.832]                           if (is.null(version)) 
[10:33:13.832]                             version <- utils::packageVersion("future")
[10:33:13.832]                         }
[10:33:13.832]                         else {
[10:33:13.832]                           version <- NULL
[10:33:13.832]                         }
[10:33:13.832]                         if (!has_future || version < "1.8.0") {
[10:33:13.832]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:13.832]                             "", base::R.version$version.string), 
[10:33:13.832]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:13.832]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:13.832]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:13.832]                               "release", "version")], collapse = " "), 
[10:33:13.832]                             hostname = base::Sys.info()[["nodename"]])
[10:33:13.832]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:13.832]                             info)
[10:33:13.832]                           info <- base::paste(info, collapse = "; ")
[10:33:13.832]                           if (!has_future) {
[10:33:13.832]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:13.832]                               info)
[10:33:13.832]                           }
[10:33:13.832]                           else {
[10:33:13.832]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:13.832]                               info, version)
[10:33:13.832]                           }
[10:33:13.832]                           base::stop(msg)
[10:33:13.832]                         }
[10:33:13.832]                       })
[10:33:13.832]                     }
[10:33:13.832]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:13.832]                     base::options(mc.cores = 1L)
[10:33:13.832]                   }
[10:33:13.832]                   ...future.strategy.old <- future::plan("list")
[10:33:13.832]                   options(future.plan = NULL)
[10:33:13.832]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.832]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:13.832]                 }
[10:33:13.832]                 ...future.workdir <- getwd()
[10:33:13.832]             }
[10:33:13.832]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:13.832]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:13.832]         }
[10:33:13.832]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:13.832]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:13.832]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:13.832]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:13.832]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:13.832]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:13.832]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:13.832]             base::names(...future.oldOptions))
[10:33:13.832]     }
[10:33:13.832]     if (FALSE) {
[10:33:13.832]     }
[10:33:13.832]     else {
[10:33:13.832]         if (TRUE) {
[10:33:13.832]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:13.832]                 open = "w")
[10:33:13.832]         }
[10:33:13.832]         else {
[10:33:13.832]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:13.832]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:13.832]         }
[10:33:13.832]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:13.832]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:13.832]             base::sink(type = "output", split = FALSE)
[10:33:13.832]             base::close(...future.stdout)
[10:33:13.832]         }, add = TRUE)
[10:33:13.832]     }
[10:33:13.832]     ...future.frame <- base::sys.nframe()
[10:33:13.832]     ...future.conditions <- base::list()
[10:33:13.832]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:13.832]     if (FALSE) {
[10:33:13.832]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:13.832]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:13.832]     }
[10:33:13.832]     ...future.result <- base::tryCatch({
[10:33:13.832]         base::withCallingHandlers({
[10:33:13.832]             ...future.value <- base::withVisible(base::local({
[10:33:13.832]                 withCallingHandlers({
[10:33:13.832]                   {
[10:33:13.832]                     x <- x + 1
[10:33:13.832]                     x
[10:33:13.832]                   }
[10:33:13.832]                 }, immediateCondition = function(cond) {
[10:33:13.832]                   save_rds <- function (object, pathname, ...) 
[10:33:13.832]                   {
[10:33:13.832]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:13.832]                     if (file_test("-f", pathname_tmp)) {
[10:33:13.832]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.832]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:13.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.832]                         fi_tmp[["mtime"]])
[10:33:13.832]                     }
[10:33:13.832]                     tryCatch({
[10:33:13.832]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:13.832]                     }, error = function(ex) {
[10:33:13.832]                       msg <- conditionMessage(ex)
[10:33:13.832]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.832]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:13.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.832]                         fi_tmp[["mtime"]], msg)
[10:33:13.832]                       ex$message <- msg
[10:33:13.832]                       stop(ex)
[10:33:13.832]                     })
[10:33:13.832]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:13.832]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:13.832]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:13.832]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.832]                       fi <- file.info(pathname)
[10:33:13.832]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:13.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.832]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:13.832]                         fi[["size"]], fi[["mtime"]])
[10:33:13.832]                       stop(msg)
[10:33:13.832]                     }
[10:33:13.832]                     invisible(pathname)
[10:33:13.832]                   }
[10:33:13.832]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:13.832]                     rootPath = tempdir()) 
[10:33:13.832]                   {
[10:33:13.832]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:13.832]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:13.832]                       tmpdir = path, fileext = ".rds")
[10:33:13.832]                     save_rds(obj, file)
[10:33:13.832]                   }
[10:33:13.832]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:13.832]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.832]                   {
[10:33:13.832]                     inherits <- base::inherits
[10:33:13.832]                     invokeRestart <- base::invokeRestart
[10:33:13.832]                     is.null <- base::is.null
[10:33:13.832]                     muffled <- FALSE
[10:33:13.832]                     if (inherits(cond, "message")) {
[10:33:13.832]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:13.832]                       if (muffled) 
[10:33:13.832]                         invokeRestart("muffleMessage")
[10:33:13.832]                     }
[10:33:13.832]                     else if (inherits(cond, "warning")) {
[10:33:13.832]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:13.832]                       if (muffled) 
[10:33:13.832]                         invokeRestart("muffleWarning")
[10:33:13.832]                     }
[10:33:13.832]                     else if (inherits(cond, "condition")) {
[10:33:13.832]                       if (!is.null(pattern)) {
[10:33:13.832]                         computeRestarts <- base::computeRestarts
[10:33:13.832]                         grepl <- base::grepl
[10:33:13.832]                         restarts <- computeRestarts(cond)
[10:33:13.832]                         for (restart in restarts) {
[10:33:13.832]                           name <- restart$name
[10:33:13.832]                           if (is.null(name)) 
[10:33:13.832]                             next
[10:33:13.832]                           if (!grepl(pattern, name)) 
[10:33:13.832]                             next
[10:33:13.832]                           invokeRestart(restart)
[10:33:13.832]                           muffled <- TRUE
[10:33:13.832]                           break
[10:33:13.832]                         }
[10:33:13.832]                       }
[10:33:13.832]                     }
[10:33:13.832]                     invisible(muffled)
[10:33:13.832]                   }
[10:33:13.832]                   muffleCondition(cond)
[10:33:13.832]                 })
[10:33:13.832]             }))
[10:33:13.832]             future::FutureResult(value = ...future.value$value, 
[10:33:13.832]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.832]                   ...future.rng), globalenv = if (FALSE) 
[10:33:13.832]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:13.832]                     ...future.globalenv.names))
[10:33:13.832]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:13.832]         }, condition = base::local({
[10:33:13.832]             c <- base::c
[10:33:13.832]             inherits <- base::inherits
[10:33:13.832]             invokeRestart <- base::invokeRestart
[10:33:13.832]             length <- base::length
[10:33:13.832]             list <- base::list
[10:33:13.832]             seq.int <- base::seq.int
[10:33:13.832]             signalCondition <- base::signalCondition
[10:33:13.832]             sys.calls <- base::sys.calls
[10:33:13.832]             `[[` <- base::`[[`
[10:33:13.832]             `+` <- base::`+`
[10:33:13.832]             `<<-` <- base::`<<-`
[10:33:13.832]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:13.832]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:13.832]                   3L)]
[10:33:13.832]             }
[10:33:13.832]             function(cond) {
[10:33:13.832]                 is_error <- inherits(cond, "error")
[10:33:13.832]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:13.832]                   NULL)
[10:33:13.832]                 if (is_error) {
[10:33:13.832]                   sessionInformation <- function() {
[10:33:13.832]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:13.832]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:13.832]                       search = base::search(), system = base::Sys.info())
[10:33:13.832]                   }
[10:33:13.832]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.832]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:13.832]                     cond$call), session = sessionInformation(), 
[10:33:13.832]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:13.832]                   signalCondition(cond)
[10:33:13.832]                 }
[10:33:13.832]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:13.832]                 "immediateCondition"))) {
[10:33:13.832]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:13.832]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.832]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:13.832]                   if (TRUE && !signal) {
[10:33:13.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.832]                     {
[10:33:13.832]                       inherits <- base::inherits
[10:33:13.832]                       invokeRestart <- base::invokeRestart
[10:33:13.832]                       is.null <- base::is.null
[10:33:13.832]                       muffled <- FALSE
[10:33:13.832]                       if (inherits(cond, "message")) {
[10:33:13.832]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.832]                         if (muffled) 
[10:33:13.832]                           invokeRestart("muffleMessage")
[10:33:13.832]                       }
[10:33:13.832]                       else if (inherits(cond, "warning")) {
[10:33:13.832]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.832]                         if (muffled) 
[10:33:13.832]                           invokeRestart("muffleWarning")
[10:33:13.832]                       }
[10:33:13.832]                       else if (inherits(cond, "condition")) {
[10:33:13.832]                         if (!is.null(pattern)) {
[10:33:13.832]                           computeRestarts <- base::computeRestarts
[10:33:13.832]                           grepl <- base::grepl
[10:33:13.832]                           restarts <- computeRestarts(cond)
[10:33:13.832]                           for (restart in restarts) {
[10:33:13.832]                             name <- restart$name
[10:33:13.832]                             if (is.null(name)) 
[10:33:13.832]                               next
[10:33:13.832]                             if (!grepl(pattern, name)) 
[10:33:13.832]                               next
[10:33:13.832]                             invokeRestart(restart)
[10:33:13.832]                             muffled <- TRUE
[10:33:13.832]                             break
[10:33:13.832]                           }
[10:33:13.832]                         }
[10:33:13.832]                       }
[10:33:13.832]                       invisible(muffled)
[10:33:13.832]                     }
[10:33:13.832]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.832]                   }
[10:33:13.832]                 }
[10:33:13.832]                 else {
[10:33:13.832]                   if (TRUE) {
[10:33:13.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.832]                     {
[10:33:13.832]                       inherits <- base::inherits
[10:33:13.832]                       invokeRestart <- base::invokeRestart
[10:33:13.832]                       is.null <- base::is.null
[10:33:13.832]                       muffled <- FALSE
[10:33:13.832]                       if (inherits(cond, "message")) {
[10:33:13.832]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.832]                         if (muffled) 
[10:33:13.832]                           invokeRestart("muffleMessage")
[10:33:13.832]                       }
[10:33:13.832]                       else if (inherits(cond, "warning")) {
[10:33:13.832]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.832]                         if (muffled) 
[10:33:13.832]                           invokeRestart("muffleWarning")
[10:33:13.832]                       }
[10:33:13.832]                       else if (inherits(cond, "condition")) {
[10:33:13.832]                         if (!is.null(pattern)) {
[10:33:13.832]                           computeRestarts <- base::computeRestarts
[10:33:13.832]                           grepl <- base::grepl
[10:33:13.832]                           restarts <- computeRestarts(cond)
[10:33:13.832]                           for (restart in restarts) {
[10:33:13.832]                             name <- restart$name
[10:33:13.832]                             if (is.null(name)) 
[10:33:13.832]                               next
[10:33:13.832]                             if (!grepl(pattern, name)) 
[10:33:13.832]                               next
[10:33:13.832]                             invokeRestart(restart)
[10:33:13.832]                             muffled <- TRUE
[10:33:13.832]                             break
[10:33:13.832]                           }
[10:33:13.832]                         }
[10:33:13.832]                       }
[10:33:13.832]                       invisible(muffled)
[10:33:13.832]                     }
[10:33:13.832]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.832]                   }
[10:33:13.832]                 }
[10:33:13.832]             }
[10:33:13.832]         }))
[10:33:13.832]     }, error = function(ex) {
[10:33:13.832]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:13.832]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.832]                 ...future.rng), started = ...future.startTime, 
[10:33:13.832]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:13.832]             version = "1.8"), class = "FutureResult")
[10:33:13.832]     }, finally = {
[10:33:13.832]         if (!identical(...future.workdir, getwd())) 
[10:33:13.832]             setwd(...future.workdir)
[10:33:13.832]         {
[10:33:13.832]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:13.832]                 ...future.oldOptions$nwarnings <- NULL
[10:33:13.832]             }
[10:33:13.832]             base::options(...future.oldOptions)
[10:33:13.832]             if (.Platform$OS.type == "windows") {
[10:33:13.832]                 old_names <- names(...future.oldEnvVars)
[10:33:13.832]                 envs <- base::Sys.getenv()
[10:33:13.832]                 names <- names(envs)
[10:33:13.832]                 common <- intersect(names, old_names)
[10:33:13.832]                 added <- setdiff(names, old_names)
[10:33:13.832]                 removed <- setdiff(old_names, names)
[10:33:13.832]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:13.832]                   envs[common]]
[10:33:13.832]                 NAMES <- toupper(changed)
[10:33:13.832]                 args <- list()
[10:33:13.832]                 for (kk in seq_along(NAMES)) {
[10:33:13.832]                   name <- changed[[kk]]
[10:33:13.832]                   NAME <- NAMES[[kk]]
[10:33:13.832]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.832]                     next
[10:33:13.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.832]                 }
[10:33:13.832]                 NAMES <- toupper(added)
[10:33:13.832]                 for (kk in seq_along(NAMES)) {
[10:33:13.832]                   name <- added[[kk]]
[10:33:13.832]                   NAME <- NAMES[[kk]]
[10:33:13.832]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.832]                     next
[10:33:13.832]                   args[[name]] <- ""
[10:33:13.832]                 }
[10:33:13.832]                 NAMES <- toupper(removed)
[10:33:13.832]                 for (kk in seq_along(NAMES)) {
[10:33:13.832]                   name <- removed[[kk]]
[10:33:13.832]                   NAME <- NAMES[[kk]]
[10:33:13.832]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.832]                     next
[10:33:13.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.832]                 }
[10:33:13.832]                 if (length(args) > 0) 
[10:33:13.832]                   base::do.call(base::Sys.setenv, args = args)
[10:33:13.832]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:13.832]             }
[10:33:13.832]             else {
[10:33:13.832]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:13.832]             }
[10:33:13.832]             {
[10:33:13.832]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:13.832]                   0L) {
[10:33:13.832]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:13.832]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:13.832]                   base::options(opts)
[10:33:13.832]                 }
[10:33:13.832]                 {
[10:33:13.832]                   {
[10:33:13.832]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:13.832]                     NULL
[10:33:13.832]                   }
[10:33:13.832]                   options(future.plan = NULL)
[10:33:13.832]                   if (is.na(NA_character_)) 
[10:33:13.832]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.832]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:13.832]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:13.832]                     .init = FALSE)
[10:33:13.832]                 }
[10:33:13.832]             }
[10:33:13.832]         }
[10:33:13.832]     })
[10:33:13.832]     if (TRUE) {
[10:33:13.832]         base::sink(type = "output", split = FALSE)
[10:33:13.832]         if (TRUE) {
[10:33:13.832]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:13.832]         }
[10:33:13.832]         else {
[10:33:13.832]             ...future.result["stdout"] <- base::list(NULL)
[10:33:13.832]         }
[10:33:13.832]         base::close(...future.stdout)
[10:33:13.832]         ...future.stdout <- NULL
[10:33:13.832]     }
[10:33:13.832]     ...future.result$conditions <- ...future.conditions
[10:33:13.832]     ...future.result$finished <- base::Sys.time()
[10:33:13.832]     ...future.result
[10:33:13.832] }
[10:33:13.834] assign_globals() ...
[10:33:13.834] List of 1
[10:33:13.834]  $ x: num 1
[10:33:13.834]  - attr(*, "where")=List of 1
[10:33:13.834]   ..$ x:<environment: R_EmptyEnv> 
[10:33:13.834]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:13.834]  - attr(*, "resolved")= logi TRUE
[10:33:13.834]  - attr(*, "total_size")= num 56
[10:33:13.834]  - attr(*, "already-done")= logi TRUE
[10:33:13.838] - copied ‘x’ to environment
[10:33:13.838] assign_globals() ... done
[10:33:13.838] requestCore(): workers = 2
[10:33:13.840] MulticoreFuture started
[10:33:13.840] - Launch lazy future ... done
[10:33:13.841] run() for ‘MulticoreFuture’ ... done
[10:33:13.841] plan(): Setting new future strategy stack:
[10:33:13.841] result() for MulticoreFuture ...
[10:33:13.841] List of future strategies:
[10:33:13.841] 1. sequential:
[10:33:13.841]    - args: function (..., envir = parent.frame())
[10:33:13.841]    - tweaked: FALSE
[10:33:13.841]    - call: NULL
[10:33:13.842] plan(): nbrOfWorkers() = 1
[10:33:13.844] plan(): Setting new future strategy stack:
[10:33:13.844] List of future strategies:
[10:33:13.844] 1. multicore:
[10:33:13.844]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.844]    - tweaked: FALSE
[10:33:13.844]    - call: plan(strategy)
[10:33:13.849] plan(): nbrOfWorkers() = 2
[10:33:13.850] result() for MulticoreFuture ...
[10:33:13.850] result() for MulticoreFuture ... done
[10:33:13.851] result() for MulticoreFuture ... done
[10:33:13.851] result() for MulticoreFuture ...
[10:33:13.851] result() for MulticoreFuture ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.851] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.852] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:13.854] - globals found: [3] ‘{’, ‘<-’, ‘x’
[10:33:13.854] Searching for globals ... DONE
[10:33:13.854] Resolving globals: TRUE
[10:33:13.854] Resolving any globals that are futures ...
[10:33:13.855] - globals: [3] ‘{’, ‘<-’, ‘x’
[10:33:13.855] Resolving any globals that are futures ... DONE
[10:33:13.855] Resolving futures part of globals (recursively) ...
[10:33:13.855] resolve() on list ...
[10:33:13.856]  recursive: 99
[10:33:13.856]  length: 1
[10:33:13.856]  elements: ‘x’
[10:33:13.856]  length: 0 (resolved future 1)
[10:33:13.856] resolve() on list ... DONE
[10:33:13.856] - globals: [1] ‘x’
[10:33:13.856] Resolving futures part of globals (recursively) ... DONE
[10:33:13.857] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[10:33:13.857] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[10:33:13.857] - globals: [1] ‘x’
[10:33:13.857] 
[10:33:13.857] getGlobalsAndPackages() ... DONE
[10:33:13.858] run() for ‘Future’ ...
[10:33:13.858] - state: ‘created’
[10:33:13.858] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:13.862] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:13.862] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:13.862]   - Field: ‘label’
[10:33:13.862]   - Field: ‘local’
[10:33:13.863]   - Field: ‘owner’
[10:33:13.863]   - Field: ‘envir’
[10:33:13.863]   - Field: ‘workers’
[10:33:13.863]   - Field: ‘packages’
[10:33:13.863]   - Field: ‘gc’
[10:33:13.863]   - Field: ‘job’
[10:33:13.863]   - Field: ‘conditions’
[10:33:13.863]   - Field: ‘expr’
[10:33:13.864]   - Field: ‘uuid’
[10:33:13.864]   - Field: ‘seed’
[10:33:13.864]   - Field: ‘version’
[10:33:13.864]   - Field: ‘result’
[10:33:13.866]   - Field: ‘asynchronous’
[10:33:13.866]   - Field: ‘calls’
[10:33:13.867]   - Field: ‘globals’
[10:33:13.867]   - Field: ‘stdout’
[10:33:13.867]   - Field: ‘earlySignal’
[10:33:13.867]   - Field: ‘lazy’
[10:33:13.867]   - Field: ‘state’
[10:33:13.867] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:13.868] - Launch lazy future ...
[10:33:13.868] Packages needed by the future expression (n = 0): <none>
[10:33:13.868] Packages needed by future strategies (n = 0): <none>
[10:33:13.869] {
[10:33:13.869]     {
[10:33:13.869]         {
[10:33:13.869]             ...future.startTime <- base::Sys.time()
[10:33:13.869]             {
[10:33:13.869]                 {
[10:33:13.869]                   {
[10:33:13.869]                     {
[10:33:13.869]                       base::local({
[10:33:13.869]                         has_future <- base::requireNamespace("future", 
[10:33:13.869]                           quietly = TRUE)
[10:33:13.869]                         if (has_future) {
[10:33:13.869]                           ns <- base::getNamespace("future")
[10:33:13.869]                           version <- ns[[".package"]][["version"]]
[10:33:13.869]                           if (is.null(version)) 
[10:33:13.869]                             version <- utils::packageVersion("future")
[10:33:13.869]                         }
[10:33:13.869]                         else {
[10:33:13.869]                           version <- NULL
[10:33:13.869]                         }
[10:33:13.869]                         if (!has_future || version < "1.8.0") {
[10:33:13.869]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:13.869]                             "", base::R.version$version.string), 
[10:33:13.869]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:13.869]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:13.869]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:13.869]                               "release", "version")], collapse = " "), 
[10:33:13.869]                             hostname = base::Sys.info()[["nodename"]])
[10:33:13.869]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:13.869]                             info)
[10:33:13.869]                           info <- base::paste(info, collapse = "; ")
[10:33:13.869]                           if (!has_future) {
[10:33:13.869]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:13.869]                               info)
[10:33:13.869]                           }
[10:33:13.869]                           else {
[10:33:13.869]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:13.869]                               info, version)
[10:33:13.869]                           }
[10:33:13.869]                           base::stop(msg)
[10:33:13.869]                         }
[10:33:13.869]                       })
[10:33:13.869]                     }
[10:33:13.869]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:13.869]                     base::options(mc.cores = 1L)
[10:33:13.869]                   }
[10:33:13.869]                   ...future.strategy.old <- future::plan("list")
[10:33:13.869]                   options(future.plan = NULL)
[10:33:13.869]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.869]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:13.869]                 }
[10:33:13.869]                 ...future.workdir <- getwd()
[10:33:13.869]             }
[10:33:13.869]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:13.869]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:13.869]         }
[10:33:13.869]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:13.869]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:13.869]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:13.869]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:13.869]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:13.869]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:13.869]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:13.869]             base::names(...future.oldOptions))
[10:33:13.869]     }
[10:33:13.869]     if (FALSE) {
[10:33:13.869]     }
[10:33:13.869]     else {
[10:33:13.869]         if (TRUE) {
[10:33:13.869]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:13.869]                 open = "w")
[10:33:13.869]         }
[10:33:13.869]         else {
[10:33:13.869]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:13.869]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:13.869]         }
[10:33:13.869]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:13.869]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:13.869]             base::sink(type = "output", split = FALSE)
[10:33:13.869]             base::close(...future.stdout)
[10:33:13.869]         }, add = TRUE)
[10:33:13.869]     }
[10:33:13.869]     ...future.frame <- base::sys.nframe()
[10:33:13.869]     ...future.conditions <- base::list()
[10:33:13.869]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:13.869]     if (FALSE) {
[10:33:13.869]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:13.869]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:13.869]     }
[10:33:13.869]     ...future.result <- base::tryCatch({
[10:33:13.869]         base::withCallingHandlers({
[10:33:13.869]             ...future.value <- base::withVisible(base::local({
[10:33:13.869]                 withCallingHandlers({
[10:33:13.869]                   {
[10:33:13.869]                     x <- x()
[10:33:13.869]                     x
[10:33:13.869]                   }
[10:33:13.869]                 }, immediateCondition = function(cond) {
[10:33:13.869]                   save_rds <- function (object, pathname, ...) 
[10:33:13.869]                   {
[10:33:13.869]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:13.869]                     if (file_test("-f", pathname_tmp)) {
[10:33:13.869]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.869]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:13.869]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.869]                         fi_tmp[["mtime"]])
[10:33:13.869]                     }
[10:33:13.869]                     tryCatch({
[10:33:13.869]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:13.869]                     }, error = function(ex) {
[10:33:13.869]                       msg <- conditionMessage(ex)
[10:33:13.869]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.869]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:13.869]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.869]                         fi_tmp[["mtime"]], msg)
[10:33:13.869]                       ex$message <- msg
[10:33:13.869]                       stop(ex)
[10:33:13.869]                     })
[10:33:13.869]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:13.869]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:13.869]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:13.869]                       fi_tmp <- file.info(pathname_tmp)
[10:33:13.869]                       fi <- file.info(pathname)
[10:33:13.869]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:13.869]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:13.869]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:13.869]                         fi[["size"]], fi[["mtime"]])
[10:33:13.869]                       stop(msg)
[10:33:13.869]                     }
[10:33:13.869]                     invisible(pathname)
[10:33:13.869]                   }
[10:33:13.869]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:13.869]                     rootPath = tempdir()) 
[10:33:13.869]                   {
[10:33:13.869]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:13.869]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:13.869]                       tmpdir = path, fileext = ".rds")
[10:33:13.869]                     save_rds(obj, file)
[10:33:13.869]                   }
[10:33:13.869]                   saveImmediateCondition(cond, path = "/tmp/Rtmp01mK3z/.future/immediateConditions")
[10:33:13.869]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.869]                   {
[10:33:13.869]                     inherits <- base::inherits
[10:33:13.869]                     invokeRestart <- base::invokeRestart
[10:33:13.869]                     is.null <- base::is.null
[10:33:13.869]                     muffled <- FALSE
[10:33:13.869]                     if (inherits(cond, "message")) {
[10:33:13.869]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:13.869]                       if (muffled) 
[10:33:13.869]                         invokeRestart("muffleMessage")
[10:33:13.869]                     }
[10:33:13.869]                     else if (inherits(cond, "warning")) {
[10:33:13.869]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:13.869]                       if (muffled) 
[10:33:13.869]                         invokeRestart("muffleWarning")
[10:33:13.869]                     }
[10:33:13.869]                     else if (inherits(cond, "condition")) {
[10:33:13.869]                       if (!is.null(pattern)) {
[10:33:13.869]                         computeRestarts <- base::computeRestarts
[10:33:13.869]                         grepl <- base::grepl
[10:33:13.869]                         restarts <- computeRestarts(cond)
[10:33:13.869]                         for (restart in restarts) {
[10:33:13.869]                           name <- restart$name
[10:33:13.869]                           if (is.null(name)) 
[10:33:13.869]                             next
[10:33:13.869]                           if (!grepl(pattern, name)) 
[10:33:13.869]                             next
[10:33:13.869]                           invokeRestart(restart)
[10:33:13.869]                           muffled <- TRUE
[10:33:13.869]                           break
[10:33:13.869]                         }
[10:33:13.869]                       }
[10:33:13.869]                     }
[10:33:13.869]                     invisible(muffled)
[10:33:13.869]                   }
[10:33:13.869]                   muffleCondition(cond)
[10:33:13.869]                 })
[10:33:13.869]             }))
[10:33:13.869]             future::FutureResult(value = ...future.value$value, 
[10:33:13.869]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.869]                   ...future.rng), globalenv = if (FALSE) 
[10:33:13.869]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:13.869]                     ...future.globalenv.names))
[10:33:13.869]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:13.869]         }, condition = base::local({
[10:33:13.869]             c <- base::c
[10:33:13.869]             inherits <- base::inherits
[10:33:13.869]             invokeRestart <- base::invokeRestart
[10:33:13.869]             length <- base::length
[10:33:13.869]             list <- base::list
[10:33:13.869]             seq.int <- base::seq.int
[10:33:13.869]             signalCondition <- base::signalCondition
[10:33:13.869]             sys.calls <- base::sys.calls
[10:33:13.869]             `[[` <- base::`[[`
[10:33:13.869]             `+` <- base::`+`
[10:33:13.869]             `<<-` <- base::`<<-`
[10:33:13.869]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:13.869]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:13.869]                   3L)]
[10:33:13.869]             }
[10:33:13.869]             function(cond) {
[10:33:13.869]                 is_error <- inherits(cond, "error")
[10:33:13.869]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:13.869]                   NULL)
[10:33:13.869]                 if (is_error) {
[10:33:13.869]                   sessionInformation <- function() {
[10:33:13.869]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:13.869]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:13.869]                       search = base::search(), system = base::Sys.info())
[10:33:13.869]                   }
[10:33:13.869]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.869]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:13.869]                     cond$call), session = sessionInformation(), 
[10:33:13.869]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:13.869]                   signalCondition(cond)
[10:33:13.869]                 }
[10:33:13.869]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:13.869]                 "immediateCondition"))) {
[10:33:13.869]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:13.869]                   ...future.conditions[[length(...future.conditions) + 
[10:33:13.869]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:13.869]                   if (TRUE && !signal) {
[10:33:13.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.869]                     {
[10:33:13.869]                       inherits <- base::inherits
[10:33:13.869]                       invokeRestart <- base::invokeRestart
[10:33:13.869]                       is.null <- base::is.null
[10:33:13.869]                       muffled <- FALSE
[10:33:13.869]                       if (inherits(cond, "message")) {
[10:33:13.869]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.869]                         if (muffled) 
[10:33:13.869]                           invokeRestart("muffleMessage")
[10:33:13.869]                       }
[10:33:13.869]                       else if (inherits(cond, "warning")) {
[10:33:13.869]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.869]                         if (muffled) 
[10:33:13.869]                           invokeRestart("muffleWarning")
[10:33:13.869]                       }
[10:33:13.869]                       else if (inherits(cond, "condition")) {
[10:33:13.869]                         if (!is.null(pattern)) {
[10:33:13.869]                           computeRestarts <- base::computeRestarts
[10:33:13.869]                           grepl <- base::grepl
[10:33:13.869]                           restarts <- computeRestarts(cond)
[10:33:13.869]                           for (restart in restarts) {
[10:33:13.869]                             name <- restart$name
[10:33:13.869]                             if (is.null(name)) 
[10:33:13.869]                               next
[10:33:13.869]                             if (!grepl(pattern, name)) 
[10:33:13.869]                               next
[10:33:13.869]                             invokeRestart(restart)
[10:33:13.869]                             muffled <- TRUE
[10:33:13.869]                             break
[10:33:13.869]                           }
[10:33:13.869]                         }
[10:33:13.869]                       }
[10:33:13.869]                       invisible(muffled)
[10:33:13.869]                     }
[10:33:13.869]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.869]                   }
[10:33:13.869]                 }
[10:33:13.869]                 else {
[10:33:13.869]                   if (TRUE) {
[10:33:13.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:13.869]                     {
[10:33:13.869]                       inherits <- base::inherits
[10:33:13.869]                       invokeRestart <- base::invokeRestart
[10:33:13.869]                       is.null <- base::is.null
[10:33:13.869]                       muffled <- FALSE
[10:33:13.869]                       if (inherits(cond, "message")) {
[10:33:13.869]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:13.869]                         if (muffled) 
[10:33:13.869]                           invokeRestart("muffleMessage")
[10:33:13.869]                       }
[10:33:13.869]                       else if (inherits(cond, "warning")) {
[10:33:13.869]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:13.869]                         if (muffled) 
[10:33:13.869]                           invokeRestart("muffleWarning")
[10:33:13.869]                       }
[10:33:13.869]                       else if (inherits(cond, "condition")) {
[10:33:13.869]                         if (!is.null(pattern)) {
[10:33:13.869]                           computeRestarts <- base::computeRestarts
[10:33:13.869]                           grepl <- base::grepl
[10:33:13.869]                           restarts <- computeRestarts(cond)
[10:33:13.869]                           for (restart in restarts) {
[10:33:13.869]                             name <- restart$name
[10:33:13.869]                             if (is.null(name)) 
[10:33:13.869]                               next
[10:33:13.869]                             if (!grepl(pattern, name)) 
[10:33:13.869]                               next
[10:33:13.869]                             invokeRestart(restart)
[10:33:13.869]                             muffled <- TRUE
[10:33:13.869]                             break
[10:33:13.869]                           }
[10:33:13.869]                         }
[10:33:13.869]                       }
[10:33:13.869]                       invisible(muffled)
[10:33:13.869]                     }
[10:33:13.869]                     muffleCondition(cond, pattern = "^muffle")
[10:33:13.869]                   }
[10:33:13.869]                 }
[10:33:13.869]             }
[10:33:13.869]         }))
[10:33:13.869]     }, error = function(ex) {
[10:33:13.869]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:13.869]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:13.869]                 ...future.rng), started = ...future.startTime, 
[10:33:13.869]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:13.869]             version = "1.8"), class = "FutureResult")
[10:33:13.869]     }, finally = {
[10:33:13.869]         if (!identical(...future.workdir, getwd())) 
[10:33:13.869]             setwd(...future.workdir)
[10:33:13.869]         {
[10:33:13.869]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:13.869]                 ...future.oldOptions$nwarnings <- NULL
[10:33:13.869]             }
[10:33:13.869]             base::options(...future.oldOptions)
[10:33:13.869]             if (.Platform$OS.type == "windows") {
[10:33:13.869]                 old_names <- names(...future.oldEnvVars)
[10:33:13.869]                 envs <- base::Sys.getenv()
[10:33:13.869]                 names <- names(envs)
[10:33:13.869]                 common <- intersect(names, old_names)
[10:33:13.869]                 added <- setdiff(names, old_names)
[10:33:13.869]                 removed <- setdiff(old_names, names)
[10:33:13.869]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:13.869]                   envs[common]]
[10:33:13.869]                 NAMES <- toupper(changed)
[10:33:13.869]                 args <- list()
[10:33:13.869]                 for (kk in seq_along(NAMES)) {
[10:33:13.869]                   name <- changed[[kk]]
[10:33:13.869]                   NAME <- NAMES[[kk]]
[10:33:13.869]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.869]                     next
[10:33:13.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.869]                 }
[10:33:13.869]                 NAMES <- toupper(added)
[10:33:13.869]                 for (kk in seq_along(NAMES)) {
[10:33:13.869]                   name <- added[[kk]]
[10:33:13.869]                   NAME <- NAMES[[kk]]
[10:33:13.869]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.869]                     next
[10:33:13.869]                   args[[name]] <- ""
[10:33:13.869]                 }
[10:33:13.869]                 NAMES <- toupper(removed)
[10:33:13.869]                 for (kk in seq_along(NAMES)) {
[10:33:13.869]                   name <- removed[[kk]]
[10:33:13.869]                   NAME <- NAMES[[kk]]
[10:33:13.869]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:13.869]                     next
[10:33:13.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:13.869]                 }
[10:33:13.869]                 if (length(args) > 0) 
[10:33:13.869]                   base::do.call(base::Sys.setenv, args = args)
[10:33:13.869]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:13.869]             }
[10:33:13.869]             else {
[10:33:13.869]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:13.869]             }
[10:33:13.869]             {
[10:33:13.869]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:13.869]                   0L) {
[10:33:13.869]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:13.869]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:13.869]                   base::options(opts)
[10:33:13.869]                 }
[10:33:13.869]                 {
[10:33:13.869]                   {
[10:33:13.869]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:13.869]                     NULL
[10:33:13.869]                   }
[10:33:13.869]                   options(future.plan = NULL)
[10:33:13.869]                   if (is.na(NA_character_)) 
[10:33:13.869]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:13.869]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:13.869]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:13.869]                     .init = FALSE)
[10:33:13.869]                 }
[10:33:13.869]             }
[10:33:13.869]         }
[10:33:13.869]     })
[10:33:13.869]     if (TRUE) {
[10:33:13.869]         base::sink(type = "output", split = FALSE)
[10:33:13.869]         if (TRUE) {
[10:33:13.869]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:13.869]         }
[10:33:13.869]         else {
[10:33:13.869]             ...future.result["stdout"] <- base::list(NULL)
[10:33:13.869]         }
[10:33:13.869]         base::close(...future.stdout)
[10:33:13.869]         ...future.stdout <- NULL
[10:33:13.869]     }
[10:33:13.869]     ...future.result$conditions <- ...future.conditions
[10:33:13.869]     ...future.result$finished <- base::Sys.time()
[10:33:13.869]     ...future.result
[10:33:13.869] }
[10:33:13.871] assign_globals() ...
[10:33:13.871] List of 1
[10:33:13.871]  $ x:function ()  
[10:33:13.871]  - attr(*, "where")=List of 1
[10:33:13.871]   ..$ x:<environment: R_EmptyEnv> 
[10:33:13.871]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:13.871]  - attr(*, "resolved")= logi TRUE
[10:33:13.871]  - attr(*, "total_size")= num 1032
[10:33:13.871]  - attr(*, "already-done")= logi TRUE
[10:33:13.875] - reassign environment for ‘x’
[10:33:13.875] - copied ‘x’ to environment
[10:33:13.875] assign_globals() ... done
[10:33:13.875] requestCore(): workers = 2
[10:33:13.877] MulticoreFuture started
[10:33:13.877] - Launch lazy future ... done
[10:33:13.878] run() for ‘MulticoreFuture’ ... done
[10:33:13.878] plan(): Setting new future strategy stack:
[10:33:13.878] result() for MulticoreFuture ...
[10:33:13.878] List of future strategies:
[10:33:13.878] 1. sequential:
[10:33:13.878]    - args: function (..., envir = parent.frame())
[10:33:13.878]    - tweaked: FALSE
[10:33:13.878]    - call: NULL
[10:33:13.879] plan(): nbrOfWorkers() = 1
[10:33:13.882] plan(): Setting new future strategy stack:
[10:33:13.882] List of future strategies:
[10:33:13.882] 1. multicore:
[10:33:13.882]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:13.882]    - tweaked: FALSE
[10:33:13.882]    - call: plan(strategy)
[10:33:13.887] plan(): nbrOfWorkers() = 2
[10:33:13.888] result() for MulticoreFuture ...
[10:33:13.888] result() for MulticoreFuture ... done
[10:33:13.889] result() for MulticoreFuture ... done
[10:33:13.889] result() for MulticoreFuture ...
[10:33:13.889] result() for MulticoreFuture ... done
value(f) = ‘TRUE’
- plan('multisession') ...
[10:33:13.890] plan(): Setting new future strategy stack:
[10:33:13.890] List of future strategies:
[10:33:13.890] 1. multisession:
[10:33:13.890]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:13.890]    - tweaked: FALSE
[10:33:13.890]    - call: plan(strategy)
[10:33:13.891] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:33:13.891] multisession:
[10:33:13.891] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:13.891] - tweaked: FALSE
[10:33:13.891] - call: plan(strategy)
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:13.898] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:13.898] Not searching for globals
[10:33:13.898] - globals: [0] <none>
[10:33:13.898] getGlobalsAndPackages() ... DONE
[10:33:13.899] [local output] makeClusterPSOCK() ...
[10:33:13.945] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:33:13.946] [local output] Base port: 11086
[10:33:13.946] [local output] Getting setup options for 2 cluster nodes ...
[10:33:13.946] [local output]  - Node 1 of 2 ...
[10:33:13.947] [local output] localMachine=TRUE => revtunnel=FALSE

[10:33:13.948] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp01mK3z/worker.rank=1.parallelly.parent=84413.149bd54adb27.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp01mK3z/worker.rank=1.parallelly.parent=84413.149bd54adb27.pid")'’
[10:33:14.136] - Possible to infer worker's PID: TRUE
[10:33:14.136] [local output] Rscript port: 11086

[10:33:14.136] [local output]  - Node 2 of 2 ...
[10:33:14.137] [local output] localMachine=TRUE => revtunnel=FALSE

[10:33:14.137] [local output] Rscript port: 11086

[10:33:14.137] [local output] Getting setup options for 2 cluster nodes ... done
[10:33:14.138] [local output]  - Parallel setup requested for some PSOCK nodes
[10:33:14.138] [local output] Setting up PSOCK nodes in parallel
[10:33:14.138] List of 36
[10:33:14.138]  $ worker          : chr "localhost"
[10:33:14.138]   ..- attr(*, "localhost")= logi TRUE
[10:33:14.138]  $ master          : chr "localhost"
[10:33:14.138]  $ port            : int 11086
[10:33:14.138]  $ connectTimeout  : num 120
[10:33:14.138]  $ timeout         : num 2592000
[10:33:14.138]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:33:14.138]  $ homogeneous     : logi TRUE
[10:33:14.138]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:33:14.138]  $ rscript_envs    : NULL
[10:33:14.138]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:33:14.138]  $ rscript_startup : NULL
[10:33:14.138]  $ rscript_sh      : chr "sh"
[10:33:14.138]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:33:14.138]  $ methods         : logi TRUE
[10:33:14.138]  $ socketOptions   : chr "no-delay"
[10:33:14.138]  $ useXDR          : logi FALSE
[10:33:14.138]  $ outfile         : chr "/dev/null"
[10:33:14.138]  $ renice          : int NA
[10:33:14.138]  $ rshcmd          : NULL
[10:33:14.138]  $ user            : chr(0) 
[10:33:14.138]  $ revtunnel       : logi FALSE
[10:33:14.138]  $ rshlogfile      : NULL
[10:33:14.138]  $ rshopts         : chr(0) 
[10:33:14.138]  $ rank            : int 1
[10:33:14.138]  $ manual          : logi FALSE
[10:33:14.138]  $ dryrun          : logi FALSE
[10:33:14.138]  $ quiet           : logi FALSE
[10:33:14.138]  $ setup_strategy  : chr "parallel"
[10:33:14.138]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:33:14.138]  $ pidfile         : chr "/tmp/Rtmp01mK3z/worker.rank=1.parallelly.parent=84413.149bd54adb27.pid"
[10:33:14.138]  $ rshcmd_label    : NULL
[10:33:14.138]  $ rsh_call        : NULL
[10:33:14.138]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:33:14.138]  $ localMachine    : logi TRUE
[10:33:14.138]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:33:14.138]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:33:14.138]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:33:14.138]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:33:14.138]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:33:14.138]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:33:14.138]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:33:14.138]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:33:14.138]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:33:14.138]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:33:14.138]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:33:14.138]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:33:14.138]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:33:14.138]  $ arguments       :List of 28
[10:33:14.138]   ..$ worker          : chr "localhost"
[10:33:14.138]   ..$ master          : NULL
[10:33:14.138]   ..$ port            : int 11086
[10:33:14.138]   ..$ connectTimeout  : num 120
[10:33:14.138]   ..$ timeout         : num 2592000
[10:33:14.138]   ..$ rscript         : NULL
[10:33:14.138]   ..$ homogeneous     : NULL
[10:33:14.138]   ..$ rscript_args    : NULL
[10:33:14.138]   ..$ rscript_envs    : NULL
[10:33:14.138]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:33:14.138]   ..$ rscript_startup : NULL
[10:33:14.138]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:33:14.138]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:33:14.138]   ..$ methods         : logi TRUE
[10:33:14.138]   ..$ socketOptions   : chr "no-delay"
[10:33:14.138]   ..$ useXDR          : logi FALSE
[10:33:14.138]   ..$ outfile         : chr "/dev/null"
[10:33:14.138]   ..$ renice          : int NA
[10:33:14.138]   ..$ rshcmd          : NULL
[10:33:14.138]   ..$ user            : NULL
[10:33:14.138]   ..$ revtunnel       : logi NA
[10:33:14.138]   ..$ rshlogfile      : NULL
[10:33:14.138]   ..$ rshopts         : NULL
[10:33:14.138]   ..$ rank            : int 1
[10:33:14.138]   ..$ manual          : logi FALSE
[10:33:14.138]   ..$ dryrun          : logi FALSE
[10:33:14.138]   ..$ quiet           : logi FALSE
[10:33:14.138]   ..$ setup_strategy  : chr "parallel"
[10:33:14.138]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:33:14.155] [local output] System call to launch all workers:
[10:33:14.155] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp01mK3z/worker.rank=1.parallelly.parent=84413.149bd54adb27.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11086 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:33:14.155] [local output] Starting PSOCK main server
[10:33:14.161] [local output] Workers launched
[10:33:14.161] [local output] Waiting for workers to connect back
[10:33:14.161]  - [local output] 0 workers out of 2 ready
[10:33:14.402]  - [local output] 0 workers out of 2 ready
[10:33:14.402]  - [local output] 1 workers out of 2 ready
[10:33:14.403]  - [local output] 1 workers out of 2 ready
[10:33:14.403]  - [local output] 2 workers out of 2 ready
[10:33:14.403] [local output] Launching of workers completed
[10:33:14.404] [local output] Collecting session information from workers
[10:33:14.404] [local output]  - Worker #1 of 2
[10:33:14.405] [local output]  - Worker #2 of 2
[10:33:14.405] [local output] makeClusterPSOCK() ... done
[10:33:14.416] Packages needed by the future expression (n = 0): <none>
[10:33:14.416] Packages needed by future strategies (n = 0): <none>
[10:33:14.417] {
[10:33:14.417]     {
[10:33:14.417]         {
[10:33:14.417]             ...future.startTime <- base::Sys.time()
[10:33:14.417]             {
[10:33:14.417]                 {
[10:33:14.417]                   {
[10:33:14.417]                     {
[10:33:14.417]                       base::local({
[10:33:14.417]                         has_future <- base::requireNamespace("future", 
[10:33:14.417]                           quietly = TRUE)
[10:33:14.417]                         if (has_future) {
[10:33:14.417]                           ns <- base::getNamespace("future")
[10:33:14.417]                           version <- ns[[".package"]][["version"]]
[10:33:14.417]                           if (is.null(version)) 
[10:33:14.417]                             version <- utils::packageVersion("future")
[10:33:14.417]                         }
[10:33:14.417]                         else {
[10:33:14.417]                           version <- NULL
[10:33:14.417]                         }
[10:33:14.417]                         if (!has_future || version < "1.8.0") {
[10:33:14.417]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:14.417]                             "", base::R.version$version.string), 
[10:33:14.417]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:14.417]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:14.417]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:14.417]                               "release", "version")], collapse = " "), 
[10:33:14.417]                             hostname = base::Sys.info()[["nodename"]])
[10:33:14.417]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:14.417]                             info)
[10:33:14.417]                           info <- base::paste(info, collapse = "; ")
[10:33:14.417]                           if (!has_future) {
[10:33:14.417]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:14.417]                               info)
[10:33:14.417]                           }
[10:33:14.417]                           else {
[10:33:14.417]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:14.417]                               info, version)
[10:33:14.417]                           }
[10:33:14.417]                           base::stop(msg)
[10:33:14.417]                         }
[10:33:14.417]                       })
[10:33:14.417]                     }
[10:33:14.417]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:14.417]                     base::options(mc.cores = 1L)
[10:33:14.417]                   }
[10:33:14.417]                   ...future.strategy.old <- future::plan("list")
[10:33:14.417]                   options(future.plan = NULL)
[10:33:14.417]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:14.417]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:14.417]                 }
[10:33:14.417]                 ...future.workdir <- getwd()
[10:33:14.417]             }
[10:33:14.417]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:14.417]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:14.417]         }
[10:33:14.417]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:14.417]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:14.417]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:14.417]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:14.417]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:14.417]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:14.417]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:14.417]             base::names(...future.oldOptions))
[10:33:14.417]     }
[10:33:14.417]     if (FALSE) {
[10:33:14.417]     }
[10:33:14.417]     else {
[10:33:14.417]         if (TRUE) {
[10:33:14.417]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:14.417]                 open = "w")
[10:33:14.417]         }
[10:33:14.417]         else {
[10:33:14.417]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:14.417]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:14.417]         }
[10:33:14.417]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:14.417]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:14.417]             base::sink(type = "output", split = FALSE)
[10:33:14.417]             base::close(...future.stdout)
[10:33:14.417]         }, add = TRUE)
[10:33:14.417]     }
[10:33:14.417]     ...future.frame <- base::sys.nframe()
[10:33:14.417]     ...future.conditions <- base::list()
[10:33:14.417]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:14.417]     if (FALSE) {
[10:33:14.417]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:14.417]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:14.417]     }
[10:33:14.417]     ...future.result <- base::tryCatch({
[10:33:14.417]         base::withCallingHandlers({
[10:33:14.417]             ...future.value <- base::withVisible(base::local({
[10:33:14.417]                 ...future.makeSendCondition <- base::local({
[10:33:14.417]                   sendCondition <- NULL
[10:33:14.417]                   function(frame = 1L) {
[10:33:14.417]                     if (is.function(sendCondition)) 
[10:33:14.417]                       return(sendCondition)
[10:33:14.417]                     ns <- getNamespace("parallel")
[10:33:14.417]                     if (exists("sendData", mode = "function", 
[10:33:14.417]                       envir = ns)) {
[10:33:14.417]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:14.417]                         envir = ns)
[10:33:14.417]                       envir <- sys.frame(frame)
[10:33:14.417]                       master <- NULL
[10:33:14.417]                       while (!identical(envir, .GlobalEnv) && 
[10:33:14.417]                         !identical(envir, emptyenv())) {
[10:33:14.417]                         if (exists("master", mode = "list", envir = envir, 
[10:33:14.417]                           inherits = FALSE)) {
[10:33:14.417]                           master <- get("master", mode = "list", 
[10:33:14.417]                             envir = envir, inherits = FALSE)
[10:33:14.417]                           if (inherits(master, c("SOCKnode", 
[10:33:14.417]                             "SOCK0node"))) {
[10:33:14.417]                             sendCondition <<- function(cond) {
[10:33:14.417]                               data <- list(type = "VALUE", value = cond, 
[10:33:14.417]                                 success = TRUE)
[10:33:14.417]                               parallel_sendData(master, data)
[10:33:14.417]                             }
[10:33:14.417]                             return(sendCondition)
[10:33:14.417]                           }
[10:33:14.417]                         }
[10:33:14.417]                         frame <- frame + 1L
[10:33:14.417]                         envir <- sys.frame(frame)
[10:33:14.417]                       }
[10:33:14.417]                     }
[10:33:14.417]                     sendCondition <<- function(cond) NULL
[10:33:14.417]                   }
[10:33:14.417]                 })
[10:33:14.417]                 withCallingHandlers({
[10:33:14.417]                   NA
[10:33:14.417]                 }, immediateCondition = function(cond) {
[10:33:14.417]                   sendCondition <- ...future.makeSendCondition()
[10:33:14.417]                   sendCondition(cond)
[10:33:14.417]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.417]                   {
[10:33:14.417]                     inherits <- base::inherits
[10:33:14.417]                     invokeRestart <- base::invokeRestart
[10:33:14.417]                     is.null <- base::is.null
[10:33:14.417]                     muffled <- FALSE
[10:33:14.417]                     if (inherits(cond, "message")) {
[10:33:14.417]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:14.417]                       if (muffled) 
[10:33:14.417]                         invokeRestart("muffleMessage")
[10:33:14.417]                     }
[10:33:14.417]                     else if (inherits(cond, "warning")) {
[10:33:14.417]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:14.417]                       if (muffled) 
[10:33:14.417]                         invokeRestart("muffleWarning")
[10:33:14.417]                     }
[10:33:14.417]                     else if (inherits(cond, "condition")) {
[10:33:14.417]                       if (!is.null(pattern)) {
[10:33:14.417]                         computeRestarts <- base::computeRestarts
[10:33:14.417]                         grepl <- base::grepl
[10:33:14.417]                         restarts <- computeRestarts(cond)
[10:33:14.417]                         for (restart in restarts) {
[10:33:14.417]                           name <- restart$name
[10:33:14.417]                           if (is.null(name)) 
[10:33:14.417]                             next
[10:33:14.417]                           if (!grepl(pattern, name)) 
[10:33:14.417]                             next
[10:33:14.417]                           invokeRestart(restart)
[10:33:14.417]                           muffled <- TRUE
[10:33:14.417]                           break
[10:33:14.417]                         }
[10:33:14.417]                       }
[10:33:14.417]                     }
[10:33:14.417]                     invisible(muffled)
[10:33:14.417]                   }
[10:33:14.417]                   muffleCondition(cond)
[10:33:14.417]                 })
[10:33:14.417]             }))
[10:33:14.417]             future::FutureResult(value = ...future.value$value, 
[10:33:14.417]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:14.417]                   ...future.rng), globalenv = if (FALSE) 
[10:33:14.417]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:14.417]                     ...future.globalenv.names))
[10:33:14.417]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:14.417]         }, condition = base::local({
[10:33:14.417]             c <- base::c
[10:33:14.417]             inherits <- base::inherits
[10:33:14.417]             invokeRestart <- base::invokeRestart
[10:33:14.417]             length <- base::length
[10:33:14.417]             list <- base::list
[10:33:14.417]             seq.int <- base::seq.int
[10:33:14.417]             signalCondition <- base::signalCondition
[10:33:14.417]             sys.calls <- base::sys.calls
[10:33:14.417]             `[[` <- base::`[[`
[10:33:14.417]             `+` <- base::`+`
[10:33:14.417]             `<<-` <- base::`<<-`
[10:33:14.417]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:14.417]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:14.417]                   3L)]
[10:33:14.417]             }
[10:33:14.417]             function(cond) {
[10:33:14.417]                 is_error <- inherits(cond, "error")
[10:33:14.417]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:14.417]                   NULL)
[10:33:14.417]                 if (is_error) {
[10:33:14.417]                   sessionInformation <- function() {
[10:33:14.417]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:14.417]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:14.417]                       search = base::search(), system = base::Sys.info())
[10:33:14.417]                   }
[10:33:14.417]                   ...future.conditions[[length(...future.conditions) + 
[10:33:14.417]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:14.417]                     cond$call), session = sessionInformation(), 
[10:33:14.417]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:14.417]                   signalCondition(cond)
[10:33:14.417]                 }
[10:33:14.417]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:14.417]                 "immediateCondition"))) {
[10:33:14.417]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:14.417]                   ...future.conditions[[length(...future.conditions) + 
[10:33:14.417]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:14.417]                   if (TRUE && !signal) {
[10:33:14.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.417]                     {
[10:33:14.417]                       inherits <- base::inherits
[10:33:14.417]                       invokeRestart <- base::invokeRestart
[10:33:14.417]                       is.null <- base::is.null
[10:33:14.417]                       muffled <- FALSE
[10:33:14.417]                       if (inherits(cond, "message")) {
[10:33:14.417]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:14.417]                         if (muffled) 
[10:33:14.417]                           invokeRestart("muffleMessage")
[10:33:14.417]                       }
[10:33:14.417]                       else if (inherits(cond, "warning")) {
[10:33:14.417]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:14.417]                         if (muffled) 
[10:33:14.417]                           invokeRestart("muffleWarning")
[10:33:14.417]                       }
[10:33:14.417]                       else if (inherits(cond, "condition")) {
[10:33:14.417]                         if (!is.null(pattern)) {
[10:33:14.417]                           computeRestarts <- base::computeRestarts
[10:33:14.417]                           grepl <- base::grepl
[10:33:14.417]                           restarts <- computeRestarts(cond)
[10:33:14.417]                           for (restart in restarts) {
[10:33:14.417]                             name <- restart$name
[10:33:14.417]                             if (is.null(name)) 
[10:33:14.417]                               next
[10:33:14.417]                             if (!grepl(pattern, name)) 
[10:33:14.417]                               next
[10:33:14.417]                             invokeRestart(restart)
[10:33:14.417]                             muffled <- TRUE
[10:33:14.417]                             break
[10:33:14.417]                           }
[10:33:14.417]                         }
[10:33:14.417]                       }
[10:33:14.417]                       invisible(muffled)
[10:33:14.417]                     }
[10:33:14.417]                     muffleCondition(cond, pattern = "^muffle")
[10:33:14.417]                   }
[10:33:14.417]                 }
[10:33:14.417]                 else {
[10:33:14.417]                   if (TRUE) {
[10:33:14.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.417]                     {
[10:33:14.417]                       inherits <- base::inherits
[10:33:14.417]                       invokeRestart <- base::invokeRestart
[10:33:14.417]                       is.null <- base::is.null
[10:33:14.417]                       muffled <- FALSE
[10:33:14.417]                       if (inherits(cond, "message")) {
[10:33:14.417]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:14.417]                         if (muffled) 
[10:33:14.417]                           invokeRestart("muffleMessage")
[10:33:14.417]                       }
[10:33:14.417]                       else if (inherits(cond, "warning")) {
[10:33:14.417]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:14.417]                         if (muffled) 
[10:33:14.417]                           invokeRestart("muffleWarning")
[10:33:14.417]                       }
[10:33:14.417]                       else if (inherits(cond, "condition")) {
[10:33:14.417]                         if (!is.null(pattern)) {
[10:33:14.417]                           computeRestarts <- base::computeRestarts
[10:33:14.417]                           grepl <- base::grepl
[10:33:14.417]                           restarts <- computeRestarts(cond)
[10:33:14.417]                           for (restart in restarts) {
[10:33:14.417]                             name <- restart$name
[10:33:14.417]                             if (is.null(name)) 
[10:33:14.417]                               next
[10:33:14.417]                             if (!grepl(pattern, name)) 
[10:33:14.417]                               next
[10:33:14.417]                             invokeRestart(restart)
[10:33:14.417]                             muffled <- TRUE
[10:33:14.417]                             break
[10:33:14.417]                           }
[10:33:14.417]                         }
[10:33:14.417]                       }
[10:33:14.417]                       invisible(muffled)
[10:33:14.417]                     }
[10:33:14.417]                     muffleCondition(cond, pattern = "^muffle")
[10:33:14.417]                   }
[10:33:14.417]                 }
[10:33:14.417]             }
[10:33:14.417]         }))
[10:33:14.417]     }, error = function(ex) {
[10:33:14.417]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:14.417]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:14.417]                 ...future.rng), started = ...future.startTime, 
[10:33:14.417]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:14.417]             version = "1.8"), class = "FutureResult")
[10:33:14.417]     }, finally = {
[10:33:14.417]         if (!identical(...future.workdir, getwd())) 
[10:33:14.417]             setwd(...future.workdir)
[10:33:14.417]         {
[10:33:14.417]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:14.417]                 ...future.oldOptions$nwarnings <- NULL
[10:33:14.417]             }
[10:33:14.417]             base::options(...future.oldOptions)
[10:33:14.417]             if (.Platform$OS.type == "windows") {
[10:33:14.417]                 old_names <- names(...future.oldEnvVars)
[10:33:14.417]                 envs <- base::Sys.getenv()
[10:33:14.417]                 names <- names(envs)
[10:33:14.417]                 common <- intersect(names, old_names)
[10:33:14.417]                 added <- setdiff(names, old_names)
[10:33:14.417]                 removed <- setdiff(old_names, names)
[10:33:14.417]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:14.417]                   envs[common]]
[10:33:14.417]                 NAMES <- toupper(changed)
[10:33:14.417]                 args <- list()
[10:33:14.417]                 for (kk in seq_along(NAMES)) {
[10:33:14.417]                   name <- changed[[kk]]
[10:33:14.417]                   NAME <- NAMES[[kk]]
[10:33:14.417]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.417]                     next
[10:33:14.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:14.417]                 }
[10:33:14.417]                 NAMES <- toupper(added)
[10:33:14.417]                 for (kk in seq_along(NAMES)) {
[10:33:14.417]                   name <- added[[kk]]
[10:33:14.417]                   NAME <- NAMES[[kk]]
[10:33:14.417]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.417]                     next
[10:33:14.417]                   args[[name]] <- ""
[10:33:14.417]                 }
[10:33:14.417]                 NAMES <- toupper(removed)
[10:33:14.417]                 for (kk in seq_along(NAMES)) {
[10:33:14.417]                   name <- removed[[kk]]
[10:33:14.417]                   NAME <- NAMES[[kk]]
[10:33:14.417]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.417]                     next
[10:33:14.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:14.417]                 }
[10:33:14.417]                 if (length(args) > 0) 
[10:33:14.417]                   base::do.call(base::Sys.setenv, args = args)
[10:33:14.417]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:14.417]             }
[10:33:14.417]             else {
[10:33:14.417]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:14.417]             }
[10:33:14.417]             {
[10:33:14.417]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:14.417]                   0L) {
[10:33:14.417]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:14.417]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:14.417]                   base::options(opts)
[10:33:14.417]                 }
[10:33:14.417]                 {
[10:33:14.417]                   {
[10:33:14.417]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:14.417]                     NULL
[10:33:14.417]                   }
[10:33:14.417]                   options(future.plan = NULL)
[10:33:14.417]                   if (is.na(NA_character_)) 
[10:33:14.417]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:14.417]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:14.417]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:14.417]                     .init = FALSE)
[10:33:14.417]                 }
[10:33:14.417]             }
[10:33:14.417]         }
[10:33:14.417]     })
[10:33:14.417]     if (TRUE) {
[10:33:14.417]         base::sink(type = "output", split = FALSE)
[10:33:14.417]         if (TRUE) {
[10:33:14.417]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:14.417]         }
[10:33:14.417]         else {
[10:33:14.417]             ...future.result["stdout"] <- base::list(NULL)
[10:33:14.417]         }
[10:33:14.417]         base::close(...future.stdout)
[10:33:14.417]         ...future.stdout <- NULL
[10:33:14.417]     }
[10:33:14.417]     ...future.result$conditions <- ...future.conditions
[10:33:14.417]     ...future.result$finished <- base::Sys.time()
[10:33:14.417]     ...future.result
[10:33:14.417] }
[10:33:14.469] MultisessionFuture started
[10:33:14.470] result() for ClusterFuture ...
[10:33:14.470] receiveMessageFromWorker() for ClusterFuture ...
[10:33:14.471] - Validating connection of MultisessionFuture
[10:33:14.503] - received message: FutureResult
[10:33:14.503] - Received FutureResult
[10:33:14.503] - Erased future from FutureRegistry
[10:33:14.504] result() for ClusterFuture ...
[10:33:14.504] - result already collected: FutureResult
[10:33:14.504] result() for ClusterFuture ... done
[10:33:14.504] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:14.504] result() for ClusterFuture ... done
[10:33:14.504] result() for ClusterFuture ...
[10:33:14.504] - result already collected: FutureResult
[10:33:14.504] result() for ClusterFuture ... done
[10:33:14.504] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:33:14.508] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:14.509] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:14.509] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:14.510] - globals found: [3] ‘{’, ‘<-’, ‘*’
[10:33:14.510] Searching for globals ... DONE
[10:33:14.511] Resolving globals: TRUE
[10:33:14.511] Resolving any globals that are futures ...
[10:33:14.511] - globals: [3] ‘{’, ‘<-’, ‘*’
[10:33:14.511] Resolving any globals that are futures ... DONE
[10:33:14.511] 
[10:33:14.511] 
[10:33:14.512] getGlobalsAndPackages() ... DONE
[10:33:14.512] run() for ‘Future’ ...
[10:33:14.512] - state: ‘created’
[10:33:14.512] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:14.526] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:14.526] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:14.527]   - Field: ‘node’
[10:33:14.527]   - Field: ‘label’
[10:33:14.527]   - Field: ‘local’
[10:33:14.527]   - Field: ‘owner’
[10:33:14.527]   - Field: ‘envir’
[10:33:14.527]   - Field: ‘workers’
[10:33:14.527]   - Field: ‘packages’
[10:33:14.527]   - Field: ‘gc’
[10:33:14.527]   - Field: ‘conditions’
[10:33:14.527]   - Field: ‘persistent’
[10:33:14.528]   - Field: ‘expr’
[10:33:14.528]   - Field: ‘uuid’
[10:33:14.528]   - Field: ‘seed’
[10:33:14.528]   - Field: ‘version’
[10:33:14.528]   - Field: ‘result’
[10:33:14.528]   - Field: ‘asynchronous’
[10:33:14.528]   - Field: ‘calls’
[10:33:14.528]   - Field: ‘globals’
[10:33:14.529]   - Field: ‘stdout’
[10:33:14.529]   - Field: ‘earlySignal’
[10:33:14.529]   - Field: ‘lazy’
[10:33:14.529]   - Field: ‘state’
[10:33:14.529] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:14.529] - Launch lazy future ...
[10:33:14.529] Packages needed by the future expression (n = 0): <none>
[10:33:14.530] Packages needed by future strategies (n = 0): <none>
[10:33:14.530] {
[10:33:14.530]     {
[10:33:14.530]         {
[10:33:14.530]             ...future.startTime <- base::Sys.time()
[10:33:14.530]             {
[10:33:14.530]                 {
[10:33:14.530]                   {
[10:33:14.530]                     {
[10:33:14.530]                       base::local({
[10:33:14.530]                         has_future <- base::requireNamespace("future", 
[10:33:14.530]                           quietly = TRUE)
[10:33:14.530]                         if (has_future) {
[10:33:14.530]                           ns <- base::getNamespace("future")
[10:33:14.530]                           version <- ns[[".package"]][["version"]]
[10:33:14.530]                           if (is.null(version)) 
[10:33:14.530]                             version <- utils::packageVersion("future")
[10:33:14.530]                         }
[10:33:14.530]                         else {
[10:33:14.530]                           version <- NULL
[10:33:14.530]                         }
[10:33:14.530]                         if (!has_future || version < "1.8.0") {
[10:33:14.530]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:14.530]                             "", base::R.version$version.string), 
[10:33:14.530]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:14.530]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:14.530]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:14.530]                               "release", "version")], collapse = " "), 
[10:33:14.530]                             hostname = base::Sys.info()[["nodename"]])
[10:33:14.530]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:14.530]                             info)
[10:33:14.530]                           info <- base::paste(info, collapse = "; ")
[10:33:14.530]                           if (!has_future) {
[10:33:14.530]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:14.530]                               info)
[10:33:14.530]                           }
[10:33:14.530]                           else {
[10:33:14.530]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:14.530]                               info, version)
[10:33:14.530]                           }
[10:33:14.530]                           base::stop(msg)
[10:33:14.530]                         }
[10:33:14.530]                       })
[10:33:14.530]                     }
[10:33:14.530]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:14.530]                     base::options(mc.cores = 1L)
[10:33:14.530]                   }
[10:33:14.530]                   ...future.strategy.old <- future::plan("list")
[10:33:14.530]                   options(future.plan = NULL)
[10:33:14.530]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:14.530]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:14.530]                 }
[10:33:14.530]                 ...future.workdir <- getwd()
[10:33:14.530]             }
[10:33:14.530]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:14.530]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:14.530]         }
[10:33:14.530]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:14.530]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:14.530]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:14.530]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:14.530]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:14.530]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:14.530]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:14.530]             base::names(...future.oldOptions))
[10:33:14.530]     }
[10:33:14.530]     if (FALSE) {
[10:33:14.530]     }
[10:33:14.530]     else {
[10:33:14.530]         if (TRUE) {
[10:33:14.530]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:14.530]                 open = "w")
[10:33:14.530]         }
[10:33:14.530]         else {
[10:33:14.530]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:14.530]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:14.530]         }
[10:33:14.530]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:14.530]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:14.530]             base::sink(type = "output", split = FALSE)
[10:33:14.530]             base::close(...future.stdout)
[10:33:14.530]         }, add = TRUE)
[10:33:14.530]     }
[10:33:14.530]     ...future.frame <- base::sys.nframe()
[10:33:14.530]     ...future.conditions <- base::list()
[10:33:14.530]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:14.530]     if (FALSE) {
[10:33:14.530]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:14.530]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:14.530]     }
[10:33:14.530]     ...future.result <- base::tryCatch({
[10:33:14.530]         base::withCallingHandlers({
[10:33:14.530]             ...future.value <- base::withVisible(base::local({
[10:33:14.530]                 ...future.makeSendCondition <- base::local({
[10:33:14.530]                   sendCondition <- NULL
[10:33:14.530]                   function(frame = 1L) {
[10:33:14.530]                     if (is.function(sendCondition)) 
[10:33:14.530]                       return(sendCondition)
[10:33:14.530]                     ns <- getNamespace("parallel")
[10:33:14.530]                     if (exists("sendData", mode = "function", 
[10:33:14.530]                       envir = ns)) {
[10:33:14.530]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:14.530]                         envir = ns)
[10:33:14.530]                       envir <- sys.frame(frame)
[10:33:14.530]                       master <- NULL
[10:33:14.530]                       while (!identical(envir, .GlobalEnv) && 
[10:33:14.530]                         !identical(envir, emptyenv())) {
[10:33:14.530]                         if (exists("master", mode = "list", envir = envir, 
[10:33:14.530]                           inherits = FALSE)) {
[10:33:14.530]                           master <- get("master", mode = "list", 
[10:33:14.530]                             envir = envir, inherits = FALSE)
[10:33:14.530]                           if (inherits(master, c("SOCKnode", 
[10:33:14.530]                             "SOCK0node"))) {
[10:33:14.530]                             sendCondition <<- function(cond) {
[10:33:14.530]                               data <- list(type = "VALUE", value = cond, 
[10:33:14.530]                                 success = TRUE)
[10:33:14.530]                               parallel_sendData(master, data)
[10:33:14.530]                             }
[10:33:14.530]                             return(sendCondition)
[10:33:14.530]                           }
[10:33:14.530]                         }
[10:33:14.530]                         frame <- frame + 1L
[10:33:14.530]                         envir <- sys.frame(frame)
[10:33:14.530]                       }
[10:33:14.530]                     }
[10:33:14.530]                     sendCondition <<- function(cond) NULL
[10:33:14.530]                   }
[10:33:14.530]                 })
[10:33:14.530]                 withCallingHandlers({
[10:33:14.530]                   {
[10:33:14.530]                     b <- a
[10:33:14.530]                     a <- 2
[10:33:14.530]                     a * b
[10:33:14.530]                   }
[10:33:14.530]                 }, immediateCondition = function(cond) {
[10:33:14.530]                   sendCondition <- ...future.makeSendCondition()
[10:33:14.530]                   sendCondition(cond)
[10:33:14.530]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.530]                   {
[10:33:14.530]                     inherits <- base::inherits
[10:33:14.530]                     invokeRestart <- base::invokeRestart
[10:33:14.530]                     is.null <- base::is.null
[10:33:14.530]                     muffled <- FALSE
[10:33:14.530]                     if (inherits(cond, "message")) {
[10:33:14.530]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:14.530]                       if (muffled) 
[10:33:14.530]                         invokeRestart("muffleMessage")
[10:33:14.530]                     }
[10:33:14.530]                     else if (inherits(cond, "warning")) {
[10:33:14.530]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:14.530]                       if (muffled) 
[10:33:14.530]                         invokeRestart("muffleWarning")
[10:33:14.530]                     }
[10:33:14.530]                     else if (inherits(cond, "condition")) {
[10:33:14.530]                       if (!is.null(pattern)) {
[10:33:14.530]                         computeRestarts <- base::computeRestarts
[10:33:14.530]                         grepl <- base::grepl
[10:33:14.530]                         restarts <- computeRestarts(cond)
[10:33:14.530]                         for (restart in restarts) {
[10:33:14.530]                           name <- restart$name
[10:33:14.530]                           if (is.null(name)) 
[10:33:14.530]                             next
[10:33:14.530]                           if (!grepl(pattern, name)) 
[10:33:14.530]                             next
[10:33:14.530]                           invokeRestart(restart)
[10:33:14.530]                           muffled <- TRUE
[10:33:14.530]                           break
[10:33:14.530]                         }
[10:33:14.530]                       }
[10:33:14.530]                     }
[10:33:14.530]                     invisible(muffled)
[10:33:14.530]                   }
[10:33:14.530]                   muffleCondition(cond)
[10:33:14.530]                 })
[10:33:14.530]             }))
[10:33:14.530]             future::FutureResult(value = ...future.value$value, 
[10:33:14.530]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:14.530]                   ...future.rng), globalenv = if (FALSE) 
[10:33:14.530]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:14.530]                     ...future.globalenv.names))
[10:33:14.530]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:14.530]         }, condition = base::local({
[10:33:14.530]             c <- base::c
[10:33:14.530]             inherits <- base::inherits
[10:33:14.530]             invokeRestart <- base::invokeRestart
[10:33:14.530]             length <- base::length
[10:33:14.530]             list <- base::list
[10:33:14.530]             seq.int <- base::seq.int
[10:33:14.530]             signalCondition <- base::signalCondition
[10:33:14.530]             sys.calls <- base::sys.calls
[10:33:14.530]             `[[` <- base::`[[`
[10:33:14.530]             `+` <- base::`+`
[10:33:14.530]             `<<-` <- base::`<<-`
[10:33:14.530]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:14.530]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:14.530]                   3L)]
[10:33:14.530]             }
[10:33:14.530]             function(cond) {
[10:33:14.530]                 is_error <- inherits(cond, "error")
[10:33:14.530]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:14.530]                   NULL)
[10:33:14.530]                 if (is_error) {
[10:33:14.530]                   sessionInformation <- function() {
[10:33:14.530]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:14.530]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:14.530]                       search = base::search(), system = base::Sys.info())
[10:33:14.530]                   }
[10:33:14.530]                   ...future.conditions[[length(...future.conditions) + 
[10:33:14.530]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:14.530]                     cond$call), session = sessionInformation(), 
[10:33:14.530]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:14.530]                   signalCondition(cond)
[10:33:14.530]                 }
[10:33:14.530]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:14.530]                 "immediateCondition"))) {
[10:33:14.530]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:14.530]                   ...future.conditions[[length(...future.conditions) + 
[10:33:14.530]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:14.530]                   if (TRUE && !signal) {
[10:33:14.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.530]                     {
[10:33:14.530]                       inherits <- base::inherits
[10:33:14.530]                       invokeRestart <- base::invokeRestart
[10:33:14.530]                       is.null <- base::is.null
[10:33:14.530]                       muffled <- FALSE
[10:33:14.530]                       if (inherits(cond, "message")) {
[10:33:14.530]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:14.530]                         if (muffled) 
[10:33:14.530]                           invokeRestart("muffleMessage")
[10:33:14.530]                       }
[10:33:14.530]                       else if (inherits(cond, "warning")) {
[10:33:14.530]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:14.530]                         if (muffled) 
[10:33:14.530]                           invokeRestart("muffleWarning")
[10:33:14.530]                       }
[10:33:14.530]                       else if (inherits(cond, "condition")) {
[10:33:14.530]                         if (!is.null(pattern)) {
[10:33:14.530]                           computeRestarts <- base::computeRestarts
[10:33:14.530]                           grepl <- base::grepl
[10:33:14.530]                           restarts <- computeRestarts(cond)
[10:33:14.530]                           for (restart in restarts) {
[10:33:14.530]                             name <- restart$name
[10:33:14.530]                             if (is.null(name)) 
[10:33:14.530]                               next
[10:33:14.530]                             if (!grepl(pattern, name)) 
[10:33:14.530]                               next
[10:33:14.530]                             invokeRestart(restart)
[10:33:14.530]                             muffled <- TRUE
[10:33:14.530]                             break
[10:33:14.530]                           }
[10:33:14.530]                         }
[10:33:14.530]                       }
[10:33:14.530]                       invisible(muffled)
[10:33:14.530]                     }
[10:33:14.530]                     muffleCondition(cond, pattern = "^muffle")
[10:33:14.530]                   }
[10:33:14.530]                 }
[10:33:14.530]                 else {
[10:33:14.530]                   if (TRUE) {
[10:33:14.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.530]                     {
[10:33:14.530]                       inherits <- base::inherits
[10:33:14.530]                       invokeRestart <- base::invokeRestart
[10:33:14.530]                       is.null <- base::is.null
[10:33:14.530]                       muffled <- FALSE
[10:33:14.530]                       if (inherits(cond, "message")) {
[10:33:14.530]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:14.530]                         if (muffled) 
[10:33:14.530]                           invokeRestart("muffleMessage")
[10:33:14.530]                       }
[10:33:14.530]                       else if (inherits(cond, "warning")) {
[10:33:14.530]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:14.530]                         if (muffled) 
[10:33:14.530]                           invokeRestart("muffleWarning")
[10:33:14.530]                       }
[10:33:14.530]                       else if (inherits(cond, "condition")) {
[10:33:14.530]                         if (!is.null(pattern)) {
[10:33:14.530]                           computeRestarts <- base::computeRestarts
[10:33:14.530]                           grepl <- base::grepl
[10:33:14.530]                           restarts <- computeRestarts(cond)
[10:33:14.530]                           for (restart in restarts) {
[10:33:14.530]                             name <- restart$name
[10:33:14.530]                             if (is.null(name)) 
[10:33:14.530]                               next
[10:33:14.530]                             if (!grepl(pattern, name)) 
[10:33:14.530]                               next
[10:33:14.530]                             invokeRestart(restart)
[10:33:14.530]                             muffled <- TRUE
[10:33:14.530]                             break
[10:33:14.530]                           }
[10:33:14.530]                         }
[10:33:14.530]                       }
[10:33:14.530]                       invisible(muffled)
[10:33:14.530]                     }
[10:33:14.530]                     muffleCondition(cond, pattern = "^muffle")
[10:33:14.530]                   }
[10:33:14.530]                 }
[10:33:14.530]             }
[10:33:14.530]         }))
[10:33:14.530]     }, error = function(ex) {
[10:33:14.530]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:14.530]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:14.530]                 ...future.rng), started = ...future.startTime, 
[10:33:14.530]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:14.530]             version = "1.8"), class = "FutureResult")
[10:33:14.530]     }, finally = {
[10:33:14.530]         if (!identical(...future.workdir, getwd())) 
[10:33:14.530]             setwd(...future.workdir)
[10:33:14.530]         {
[10:33:14.530]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:14.530]                 ...future.oldOptions$nwarnings <- NULL
[10:33:14.530]             }
[10:33:14.530]             base::options(...future.oldOptions)
[10:33:14.530]             if (.Platform$OS.type == "windows") {
[10:33:14.530]                 old_names <- names(...future.oldEnvVars)
[10:33:14.530]                 envs <- base::Sys.getenv()
[10:33:14.530]                 names <- names(envs)
[10:33:14.530]                 common <- intersect(names, old_names)
[10:33:14.530]                 added <- setdiff(names, old_names)
[10:33:14.530]                 removed <- setdiff(old_names, names)
[10:33:14.530]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:14.530]                   envs[common]]
[10:33:14.530]                 NAMES <- toupper(changed)
[10:33:14.530]                 args <- list()
[10:33:14.530]                 for (kk in seq_along(NAMES)) {
[10:33:14.530]                   name <- changed[[kk]]
[10:33:14.530]                   NAME <- NAMES[[kk]]
[10:33:14.530]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.530]                     next
[10:33:14.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:14.530]                 }
[10:33:14.530]                 NAMES <- toupper(added)
[10:33:14.530]                 for (kk in seq_along(NAMES)) {
[10:33:14.530]                   name <- added[[kk]]
[10:33:14.530]                   NAME <- NAMES[[kk]]
[10:33:14.530]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.530]                     next
[10:33:14.530]                   args[[name]] <- ""
[10:33:14.530]                 }
[10:33:14.530]                 NAMES <- toupper(removed)
[10:33:14.530]                 for (kk in seq_along(NAMES)) {
[10:33:14.530]                   name <- removed[[kk]]
[10:33:14.530]                   NAME <- NAMES[[kk]]
[10:33:14.530]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.530]                     next
[10:33:14.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:14.530]                 }
[10:33:14.530]                 if (length(args) > 0) 
[10:33:14.530]                   base::do.call(base::Sys.setenv, args = args)
[10:33:14.530]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:14.530]             }
[10:33:14.530]             else {
[10:33:14.530]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:14.530]             }
[10:33:14.530]             {
[10:33:14.530]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:14.530]                   0L) {
[10:33:14.530]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:14.530]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:14.530]                   base::options(opts)
[10:33:14.530]                 }
[10:33:14.530]                 {
[10:33:14.530]                   {
[10:33:14.530]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:14.530]                     NULL
[10:33:14.530]                   }
[10:33:14.530]                   options(future.plan = NULL)
[10:33:14.530]                   if (is.na(NA_character_)) 
[10:33:14.530]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:14.530]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:14.530]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:14.530]                     .init = FALSE)
[10:33:14.530]                 }
[10:33:14.530]             }
[10:33:14.530]         }
[10:33:14.530]     })
[10:33:14.530]     if (TRUE) {
[10:33:14.530]         base::sink(type = "output", split = FALSE)
[10:33:14.530]         if (TRUE) {
[10:33:14.530]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:14.530]         }
[10:33:14.530]         else {
[10:33:14.530]             ...future.result["stdout"] <- base::list(NULL)
[10:33:14.530]         }
[10:33:14.530]         base::close(...future.stdout)
[10:33:14.530]         ...future.stdout <- NULL
[10:33:14.530]     }
[10:33:14.530]     ...future.result$conditions <- ...future.conditions
[10:33:14.530]     ...future.result$finished <- base::Sys.time()
[10:33:14.530]     ...future.result
[10:33:14.530] }
[10:33:14.533] MultisessionFuture started
[10:33:14.534] - Launch lazy future ... done
[10:33:14.534] run() for ‘MultisessionFuture’ ... done
[10:33:14.534] result() for ClusterFuture ...
[10:33:14.534] receiveMessageFromWorker() for ClusterFuture ...
[10:33:14.534] - Validating connection of MultisessionFuture
[10:33:14.539] - received message: FutureResult
[10:33:14.539] - Received FutureResult
[10:33:14.539] - Erased future from FutureRegistry
[10:33:14.540] result() for ClusterFuture ...
[10:33:14.540] - result already collected: FutureResult
[10:33:14.540] result() for ClusterFuture ... done
[10:33:14.540] signalConditions() ...
[10:33:14.540]  - include = ‘immediateCondition’
[10:33:14.540]  - exclude = 
[10:33:14.540]  - resignal = FALSE
[10:33:14.540]  - Number of conditions: 1
[10:33:14.540] signalConditions() ... done
[10:33:14.541] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:14.541] result() for ClusterFuture ... done
[10:33:14.541] result() for ClusterFuture ...
[10:33:14.541] - result already collected: FutureResult
[10:33:14.541] result() for ClusterFuture ... done
[10:33:14.541] signalConditions() ...
[10:33:14.541]  - include = ‘immediateCondition’
[10:33:14.541]  - exclude = 
[10:33:14.541]  - resignal = FALSE
[10:33:14.542]  - Number of conditions: 1
[10:33:14.542] signalConditions() ... done
[10:33:14.542] Future state: ‘finished’
[10:33:14.542] result() for ClusterFuture ...
[10:33:14.542] - result already collected: FutureResult
[10:33:14.542] result() for ClusterFuture ... done
[10:33:14.542] signalConditions() ...
[10:33:14.542]  - include = ‘condition’
[10:33:14.542]  - exclude = ‘immediateCondition’
[10:33:14.543]  - resignal = TRUE
[10:33:14.543]  - Number of conditions: 1
[10:33:14.543]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:33:14.543] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "c3bfbccbe859" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 10:33:14"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:14.559] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:14.560] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:14.561] - globals found: [3] ‘{’, ‘<-’, ‘*’
[10:33:14.561] Searching for globals ... DONE
[10:33:14.562] Resolving globals: TRUE
[10:33:14.562] Resolving any globals that are futures ...
[10:33:14.562] - globals: [3] ‘{’, ‘<-’, ‘*’
[10:33:14.562] Resolving any globals that are futures ... DONE
[10:33:14.562] 
[10:33:14.562] 
[10:33:14.563] getGlobalsAndPackages() ... DONE
[10:33:14.563] run() for ‘Future’ ...
[10:33:14.563] - state: ‘created’
[10:33:14.563] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:14.578] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:14.578] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:14.578]   - Field: ‘node’
[10:33:14.578]   - Field: ‘label’
[10:33:14.578]   - Field: ‘local’
[10:33:14.578]   - Field: ‘owner’
[10:33:14.578]   - Field: ‘envir’
[10:33:14.578]   - Field: ‘workers’
[10:33:14.578]   - Field: ‘packages’
[10:33:14.579]   - Field: ‘gc’
[10:33:14.579]   - Field: ‘conditions’
[10:33:14.579]   - Field: ‘persistent’
[10:33:14.579]   - Field: ‘expr’
[10:33:14.579]   - Field: ‘uuid’
[10:33:14.579]   - Field: ‘seed’
[10:33:14.579]   - Field: ‘version’
[10:33:14.579]   - Field: ‘result’
[10:33:14.579]   - Field: ‘asynchronous’
[10:33:14.580]   - Field: ‘calls’
[10:33:14.580]   - Field: ‘globals’
[10:33:14.580]   - Field: ‘stdout’
[10:33:14.580]   - Field: ‘earlySignal’
[10:33:14.580]   - Field: ‘lazy’
[10:33:14.580]   - Field: ‘state’
[10:33:14.580] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:14.580] - Launch lazy future ...
[10:33:14.581] Packages needed by the future expression (n = 0): <none>
[10:33:14.581] Packages needed by future strategies (n = 0): <none>
[10:33:14.581] {
[10:33:14.581]     {
[10:33:14.581]         {
[10:33:14.581]             ...future.startTime <- base::Sys.time()
[10:33:14.581]             {
[10:33:14.581]                 {
[10:33:14.581]                   {
[10:33:14.581]                     {
[10:33:14.581]                       base::local({
[10:33:14.581]                         has_future <- base::requireNamespace("future", 
[10:33:14.581]                           quietly = TRUE)
[10:33:14.581]                         if (has_future) {
[10:33:14.581]                           ns <- base::getNamespace("future")
[10:33:14.581]                           version <- ns[[".package"]][["version"]]
[10:33:14.581]                           if (is.null(version)) 
[10:33:14.581]                             version <- utils::packageVersion("future")
[10:33:14.581]                         }
[10:33:14.581]                         else {
[10:33:14.581]                           version <- NULL
[10:33:14.581]                         }
[10:33:14.581]                         if (!has_future || version < "1.8.0") {
[10:33:14.581]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:14.581]                             "", base::R.version$version.string), 
[10:33:14.581]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:14.581]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:14.581]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:14.581]                               "release", "version")], collapse = " "), 
[10:33:14.581]                             hostname = base::Sys.info()[["nodename"]])
[10:33:14.581]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:14.581]                             info)
[10:33:14.581]                           info <- base::paste(info, collapse = "; ")
[10:33:14.581]                           if (!has_future) {
[10:33:14.581]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:14.581]                               info)
[10:33:14.581]                           }
[10:33:14.581]                           else {
[10:33:14.581]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:14.581]                               info, version)
[10:33:14.581]                           }
[10:33:14.581]                           base::stop(msg)
[10:33:14.581]                         }
[10:33:14.581]                       })
[10:33:14.581]                     }
[10:33:14.581]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:14.581]                     base::options(mc.cores = 1L)
[10:33:14.581]                   }
[10:33:14.581]                   ...future.strategy.old <- future::plan("list")
[10:33:14.581]                   options(future.plan = NULL)
[10:33:14.581]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:14.581]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:14.581]                 }
[10:33:14.581]                 ...future.workdir <- getwd()
[10:33:14.581]             }
[10:33:14.581]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:14.581]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:14.581]         }
[10:33:14.581]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:14.581]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:14.581]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:14.581]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:14.581]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:14.581]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:14.581]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:14.581]             base::names(...future.oldOptions))
[10:33:14.581]     }
[10:33:14.581]     if (FALSE) {
[10:33:14.581]     }
[10:33:14.581]     else {
[10:33:14.581]         if (TRUE) {
[10:33:14.581]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:14.581]                 open = "w")
[10:33:14.581]         }
[10:33:14.581]         else {
[10:33:14.581]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:14.581]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:14.581]         }
[10:33:14.581]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:14.581]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:14.581]             base::sink(type = "output", split = FALSE)
[10:33:14.581]             base::close(...future.stdout)
[10:33:14.581]         }, add = TRUE)
[10:33:14.581]     }
[10:33:14.581]     ...future.frame <- base::sys.nframe()
[10:33:14.581]     ...future.conditions <- base::list()
[10:33:14.581]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:14.581]     if (FALSE) {
[10:33:14.581]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:14.581]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:14.581]     }
[10:33:14.581]     ...future.result <- base::tryCatch({
[10:33:14.581]         base::withCallingHandlers({
[10:33:14.581]             ...future.value <- base::withVisible(base::local({
[10:33:14.581]                 ...future.makeSendCondition <- base::local({
[10:33:14.581]                   sendCondition <- NULL
[10:33:14.581]                   function(frame = 1L) {
[10:33:14.581]                     if (is.function(sendCondition)) 
[10:33:14.581]                       return(sendCondition)
[10:33:14.581]                     ns <- getNamespace("parallel")
[10:33:14.581]                     if (exists("sendData", mode = "function", 
[10:33:14.581]                       envir = ns)) {
[10:33:14.581]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:14.581]                         envir = ns)
[10:33:14.581]                       envir <- sys.frame(frame)
[10:33:14.581]                       master <- NULL
[10:33:14.581]                       while (!identical(envir, .GlobalEnv) && 
[10:33:14.581]                         !identical(envir, emptyenv())) {
[10:33:14.581]                         if (exists("master", mode = "list", envir = envir, 
[10:33:14.581]                           inherits = FALSE)) {
[10:33:14.581]                           master <- get("master", mode = "list", 
[10:33:14.581]                             envir = envir, inherits = FALSE)
[10:33:14.581]                           if (inherits(master, c("SOCKnode", 
[10:33:14.581]                             "SOCK0node"))) {
[10:33:14.581]                             sendCondition <<- function(cond) {
[10:33:14.581]                               data <- list(type = "VALUE", value = cond, 
[10:33:14.581]                                 success = TRUE)
[10:33:14.581]                               parallel_sendData(master, data)
[10:33:14.581]                             }
[10:33:14.581]                             return(sendCondition)
[10:33:14.581]                           }
[10:33:14.581]                         }
[10:33:14.581]                         frame <- frame + 1L
[10:33:14.581]                         envir <- sys.frame(frame)
[10:33:14.581]                       }
[10:33:14.581]                     }
[10:33:14.581]                     sendCondition <<- function(cond) NULL
[10:33:14.581]                   }
[10:33:14.581]                 })
[10:33:14.581]                 withCallingHandlers({
[10:33:14.581]                   {
[10:33:14.581]                     b <- a
[10:33:14.581]                     a <- 2
[10:33:14.581]                     a * b
[10:33:14.581]                   }
[10:33:14.581]                 }, immediateCondition = function(cond) {
[10:33:14.581]                   sendCondition <- ...future.makeSendCondition()
[10:33:14.581]                   sendCondition(cond)
[10:33:14.581]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.581]                   {
[10:33:14.581]                     inherits <- base::inherits
[10:33:14.581]                     invokeRestart <- base::invokeRestart
[10:33:14.581]                     is.null <- base::is.null
[10:33:14.581]                     muffled <- FALSE
[10:33:14.581]                     if (inherits(cond, "message")) {
[10:33:14.581]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:14.581]                       if (muffled) 
[10:33:14.581]                         invokeRestart("muffleMessage")
[10:33:14.581]                     }
[10:33:14.581]                     else if (inherits(cond, "warning")) {
[10:33:14.581]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:14.581]                       if (muffled) 
[10:33:14.581]                         invokeRestart("muffleWarning")
[10:33:14.581]                     }
[10:33:14.581]                     else if (inherits(cond, "condition")) {
[10:33:14.581]                       if (!is.null(pattern)) {
[10:33:14.581]                         computeRestarts <- base::computeRestarts
[10:33:14.581]                         grepl <- base::grepl
[10:33:14.581]                         restarts <- computeRestarts(cond)
[10:33:14.581]                         for (restart in restarts) {
[10:33:14.581]                           name <- restart$name
[10:33:14.581]                           if (is.null(name)) 
[10:33:14.581]                             next
[10:33:14.581]                           if (!grepl(pattern, name)) 
[10:33:14.581]                             next
[10:33:14.581]                           invokeRestart(restart)
[10:33:14.581]                           muffled <- TRUE
[10:33:14.581]                           break
[10:33:14.581]                         }
[10:33:14.581]                       }
[10:33:14.581]                     }
[10:33:14.581]                     invisible(muffled)
[10:33:14.581]                   }
[10:33:14.581]                   muffleCondition(cond)
[10:33:14.581]                 })
[10:33:14.581]             }))
[10:33:14.581]             future::FutureResult(value = ...future.value$value, 
[10:33:14.581]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:14.581]                   ...future.rng), globalenv = if (FALSE) 
[10:33:14.581]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:14.581]                     ...future.globalenv.names))
[10:33:14.581]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:14.581]         }, condition = base::local({
[10:33:14.581]             c <- base::c
[10:33:14.581]             inherits <- base::inherits
[10:33:14.581]             invokeRestart <- base::invokeRestart
[10:33:14.581]             length <- base::length
[10:33:14.581]             list <- base::list
[10:33:14.581]             seq.int <- base::seq.int
[10:33:14.581]             signalCondition <- base::signalCondition
[10:33:14.581]             sys.calls <- base::sys.calls
[10:33:14.581]             `[[` <- base::`[[`
[10:33:14.581]             `+` <- base::`+`
[10:33:14.581]             `<<-` <- base::`<<-`
[10:33:14.581]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:14.581]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:14.581]                   3L)]
[10:33:14.581]             }
[10:33:14.581]             function(cond) {
[10:33:14.581]                 is_error <- inherits(cond, "error")
[10:33:14.581]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:14.581]                   NULL)
[10:33:14.581]                 if (is_error) {
[10:33:14.581]                   sessionInformation <- function() {
[10:33:14.581]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:14.581]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:14.581]                       search = base::search(), system = base::Sys.info())
[10:33:14.581]                   }
[10:33:14.581]                   ...future.conditions[[length(...future.conditions) + 
[10:33:14.581]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:14.581]                     cond$call), session = sessionInformation(), 
[10:33:14.581]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:14.581]                   signalCondition(cond)
[10:33:14.581]                 }
[10:33:14.581]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:14.581]                 "immediateCondition"))) {
[10:33:14.581]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:14.581]                   ...future.conditions[[length(...future.conditions) + 
[10:33:14.581]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:14.581]                   if (TRUE && !signal) {
[10:33:14.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.581]                     {
[10:33:14.581]                       inherits <- base::inherits
[10:33:14.581]                       invokeRestart <- base::invokeRestart
[10:33:14.581]                       is.null <- base::is.null
[10:33:14.581]                       muffled <- FALSE
[10:33:14.581]                       if (inherits(cond, "message")) {
[10:33:14.581]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:14.581]                         if (muffled) 
[10:33:14.581]                           invokeRestart("muffleMessage")
[10:33:14.581]                       }
[10:33:14.581]                       else if (inherits(cond, "warning")) {
[10:33:14.581]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:14.581]                         if (muffled) 
[10:33:14.581]                           invokeRestart("muffleWarning")
[10:33:14.581]                       }
[10:33:14.581]                       else if (inherits(cond, "condition")) {
[10:33:14.581]                         if (!is.null(pattern)) {
[10:33:14.581]                           computeRestarts <- base::computeRestarts
[10:33:14.581]                           grepl <- base::grepl
[10:33:14.581]                           restarts <- computeRestarts(cond)
[10:33:14.581]                           for (restart in restarts) {
[10:33:14.581]                             name <- restart$name
[10:33:14.581]                             if (is.null(name)) 
[10:33:14.581]                               next
[10:33:14.581]                             if (!grepl(pattern, name)) 
[10:33:14.581]                               next
[10:33:14.581]                             invokeRestart(restart)
[10:33:14.581]                             muffled <- TRUE
[10:33:14.581]                             break
[10:33:14.581]                           }
[10:33:14.581]                         }
[10:33:14.581]                       }
[10:33:14.581]                       invisible(muffled)
[10:33:14.581]                     }
[10:33:14.581]                     muffleCondition(cond, pattern = "^muffle")
[10:33:14.581]                   }
[10:33:14.581]                 }
[10:33:14.581]                 else {
[10:33:14.581]                   if (TRUE) {
[10:33:14.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.581]                     {
[10:33:14.581]                       inherits <- base::inherits
[10:33:14.581]                       invokeRestart <- base::invokeRestart
[10:33:14.581]                       is.null <- base::is.null
[10:33:14.581]                       muffled <- FALSE
[10:33:14.581]                       if (inherits(cond, "message")) {
[10:33:14.581]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:14.581]                         if (muffled) 
[10:33:14.581]                           invokeRestart("muffleMessage")
[10:33:14.581]                       }
[10:33:14.581]                       else if (inherits(cond, "warning")) {
[10:33:14.581]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:14.581]                         if (muffled) 
[10:33:14.581]                           invokeRestart("muffleWarning")
[10:33:14.581]                       }
[10:33:14.581]                       else if (inherits(cond, "condition")) {
[10:33:14.581]                         if (!is.null(pattern)) {
[10:33:14.581]                           computeRestarts <- base::computeRestarts
[10:33:14.581]                           grepl <- base::grepl
[10:33:14.581]                           restarts <- computeRestarts(cond)
[10:33:14.581]                           for (restart in restarts) {
[10:33:14.581]                             name <- restart$name
[10:33:14.581]                             if (is.null(name)) 
[10:33:14.581]                               next
[10:33:14.581]                             if (!grepl(pattern, name)) 
[10:33:14.581]                               next
[10:33:14.581]                             invokeRestart(restart)
[10:33:14.581]                             muffled <- TRUE
[10:33:14.581]                             break
[10:33:14.581]                           }
[10:33:14.581]                         }
[10:33:14.581]                       }
[10:33:14.581]                       invisible(muffled)
[10:33:14.581]                     }
[10:33:14.581]                     muffleCondition(cond, pattern = "^muffle")
[10:33:14.581]                   }
[10:33:14.581]                 }
[10:33:14.581]             }
[10:33:14.581]         }))
[10:33:14.581]     }, error = function(ex) {
[10:33:14.581]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:14.581]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:14.581]                 ...future.rng), started = ...future.startTime, 
[10:33:14.581]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:14.581]             version = "1.8"), class = "FutureResult")
[10:33:14.581]     }, finally = {
[10:33:14.581]         if (!identical(...future.workdir, getwd())) 
[10:33:14.581]             setwd(...future.workdir)
[10:33:14.581]         {
[10:33:14.581]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:14.581]                 ...future.oldOptions$nwarnings <- NULL
[10:33:14.581]             }
[10:33:14.581]             base::options(...future.oldOptions)
[10:33:14.581]             if (.Platform$OS.type == "windows") {
[10:33:14.581]                 old_names <- names(...future.oldEnvVars)
[10:33:14.581]                 envs <- base::Sys.getenv()
[10:33:14.581]                 names <- names(envs)
[10:33:14.581]                 common <- intersect(names, old_names)
[10:33:14.581]                 added <- setdiff(names, old_names)
[10:33:14.581]                 removed <- setdiff(old_names, names)
[10:33:14.581]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:14.581]                   envs[common]]
[10:33:14.581]                 NAMES <- toupper(changed)
[10:33:14.581]                 args <- list()
[10:33:14.581]                 for (kk in seq_along(NAMES)) {
[10:33:14.581]                   name <- changed[[kk]]
[10:33:14.581]                   NAME <- NAMES[[kk]]
[10:33:14.581]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.581]                     next
[10:33:14.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:14.581]                 }
[10:33:14.581]                 NAMES <- toupper(added)
[10:33:14.581]                 for (kk in seq_along(NAMES)) {
[10:33:14.581]                   name <- added[[kk]]
[10:33:14.581]                   NAME <- NAMES[[kk]]
[10:33:14.581]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.581]                     next
[10:33:14.581]                   args[[name]] <- ""
[10:33:14.581]                 }
[10:33:14.581]                 NAMES <- toupper(removed)
[10:33:14.581]                 for (kk in seq_along(NAMES)) {
[10:33:14.581]                   name <- removed[[kk]]
[10:33:14.581]                   NAME <- NAMES[[kk]]
[10:33:14.581]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.581]                     next
[10:33:14.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:14.581]                 }
[10:33:14.581]                 if (length(args) > 0) 
[10:33:14.581]                   base::do.call(base::Sys.setenv, args = args)
[10:33:14.581]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:14.581]             }
[10:33:14.581]             else {
[10:33:14.581]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:14.581]             }
[10:33:14.581]             {
[10:33:14.581]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:14.581]                   0L) {
[10:33:14.581]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:14.581]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:14.581]                   base::options(opts)
[10:33:14.581]                 }
[10:33:14.581]                 {
[10:33:14.581]                   {
[10:33:14.581]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:14.581]                     NULL
[10:33:14.581]                   }
[10:33:14.581]                   options(future.plan = NULL)
[10:33:14.581]                   if (is.na(NA_character_)) 
[10:33:14.581]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:14.581]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:14.581]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:14.581]                     .init = FALSE)
[10:33:14.581]                 }
[10:33:14.581]             }
[10:33:14.581]         }
[10:33:14.581]     })
[10:33:14.581]     if (TRUE) {
[10:33:14.581]         base::sink(type = "output", split = FALSE)
[10:33:14.581]         if (TRUE) {
[10:33:14.581]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:14.581]         }
[10:33:14.581]         else {
[10:33:14.581]             ...future.result["stdout"] <- base::list(NULL)
[10:33:14.581]         }
[10:33:14.581]         base::close(...future.stdout)
[10:33:14.581]         ...future.stdout <- NULL
[10:33:14.581]     }
[10:33:14.581]     ...future.result$conditions <- ...future.conditions
[10:33:14.581]     ...future.result$finished <- base::Sys.time()
[10:33:14.581]     ...future.result
[10:33:14.581] }
[10:33:14.585] MultisessionFuture started
[10:33:14.588] - Launch lazy future ... done
[10:33:14.588] run() for ‘MultisessionFuture’ ... done
[10:33:14.588] result() for ClusterFuture ...
[10:33:14.588] receiveMessageFromWorker() for ClusterFuture ...
[10:33:14.588] - Validating connection of MultisessionFuture
[10:33:14.588] - received message: FutureResult
[10:33:14.588] - Received FutureResult
[10:33:14.589] - Erased future from FutureRegistry
[10:33:14.589] result() for ClusterFuture ...
[10:33:14.589] - result already collected: FutureResult
[10:33:14.589] result() for ClusterFuture ... done
[10:33:14.589] signalConditions() ...
[10:33:14.589]  - include = ‘immediateCondition’
[10:33:14.589]  - exclude = 
[10:33:14.589]  - resignal = FALSE
[10:33:14.589]  - Number of conditions: 1
[10:33:14.589] signalConditions() ... done
[10:33:14.589] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:14.590] result() for ClusterFuture ... done
[10:33:14.590] result() for ClusterFuture ...
[10:33:14.590] - result already collected: FutureResult
[10:33:14.590] result() for ClusterFuture ... done
[10:33:14.590] signalConditions() ...
[10:33:14.590]  - include = ‘immediateCondition’
[10:33:14.590]  - exclude = 
[10:33:14.590]  - resignal = FALSE
[10:33:14.590]  - Number of conditions: 1
[10:33:14.590] signalConditions() ... done
[10:33:14.590] Future state: ‘finished’
[10:33:14.591] result() for ClusterFuture ...
[10:33:14.591] - result already collected: FutureResult
[10:33:14.591] result() for ClusterFuture ... done
[10:33:14.591] signalConditions() ...
[10:33:14.591]  - include = ‘condition’
[10:33:14.591]  - exclude = ‘immediateCondition’
[10:33:14.591]  - resignal = TRUE
[10:33:14.591]  - Number of conditions: 1
[10:33:14.591]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:33:14.591] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "c3bfbccbe859" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 10:33:14"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:14.605] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:14.605] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:14.606] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:14.607] Searching for globals ... DONE
[10:33:14.607] Resolving globals: TRUE
[10:33:14.607] Resolving any globals that are futures ...
[10:33:14.607] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:14.607] Resolving any globals that are futures ... DONE
[10:33:14.607] Resolving futures part of globals (recursively) ...
[10:33:14.608] resolve() on list ...
[10:33:14.608]  recursive: 99
[10:33:14.608]  length: 1
[10:33:14.608]  elements: ‘ii’
[10:33:14.608]  length: 0 (resolved future 1)
[10:33:14.608] resolve() on list ... DONE
[10:33:14.608] - globals: [1] ‘ii’
[10:33:14.608] Resolving futures part of globals (recursively) ... DONE
[10:33:14.608] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:14.609] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:14.609] - globals: [1] ‘ii’
[10:33:14.609] 
[10:33:14.609] getGlobalsAndPackages() ... DONE
[10:33:14.609] run() for ‘Future’ ...
[10:33:14.609] - state: ‘created’
[10:33:14.610] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:14.623] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:14.623] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:14.623]   - Field: ‘node’
[10:33:14.624]   - Field: ‘label’
[10:33:14.624]   - Field: ‘local’
[10:33:14.624]   - Field: ‘owner’
[10:33:14.624]   - Field: ‘envir’
[10:33:14.624]   - Field: ‘workers’
[10:33:14.624]   - Field: ‘packages’
[10:33:14.624]   - Field: ‘gc’
[10:33:14.624]   - Field: ‘conditions’
[10:33:14.624]   - Field: ‘persistent’
[10:33:14.624]   - Field: ‘expr’
[10:33:14.624]   - Field: ‘uuid’
[10:33:14.625]   - Field: ‘seed’
[10:33:14.625]   - Field: ‘version’
[10:33:14.625]   - Field: ‘result’
[10:33:14.625]   - Field: ‘asynchronous’
[10:33:14.625]   - Field: ‘calls’
[10:33:14.625]   - Field: ‘globals’
[10:33:14.625]   - Field: ‘stdout’
[10:33:14.625]   - Field: ‘earlySignal’
[10:33:14.625]   - Field: ‘lazy’
[10:33:14.625]   - Field: ‘state’
[10:33:14.626] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:14.626] - Launch lazy future ...
[10:33:14.626] Packages needed by the future expression (n = 0): <none>
[10:33:14.626] Packages needed by future strategies (n = 0): <none>
[10:33:14.626] {
[10:33:14.626]     {
[10:33:14.626]         {
[10:33:14.626]             ...future.startTime <- base::Sys.time()
[10:33:14.626]             {
[10:33:14.626]                 {
[10:33:14.626]                   {
[10:33:14.626]                     {
[10:33:14.626]                       base::local({
[10:33:14.626]                         has_future <- base::requireNamespace("future", 
[10:33:14.626]                           quietly = TRUE)
[10:33:14.626]                         if (has_future) {
[10:33:14.626]                           ns <- base::getNamespace("future")
[10:33:14.626]                           version <- ns[[".package"]][["version"]]
[10:33:14.626]                           if (is.null(version)) 
[10:33:14.626]                             version <- utils::packageVersion("future")
[10:33:14.626]                         }
[10:33:14.626]                         else {
[10:33:14.626]                           version <- NULL
[10:33:14.626]                         }
[10:33:14.626]                         if (!has_future || version < "1.8.0") {
[10:33:14.626]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:14.626]                             "", base::R.version$version.string), 
[10:33:14.626]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:14.626]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:14.626]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:14.626]                               "release", "version")], collapse = " "), 
[10:33:14.626]                             hostname = base::Sys.info()[["nodename"]])
[10:33:14.626]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:14.626]                             info)
[10:33:14.626]                           info <- base::paste(info, collapse = "; ")
[10:33:14.626]                           if (!has_future) {
[10:33:14.626]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:14.626]                               info)
[10:33:14.626]                           }
[10:33:14.626]                           else {
[10:33:14.626]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:14.626]                               info, version)
[10:33:14.626]                           }
[10:33:14.626]                           base::stop(msg)
[10:33:14.626]                         }
[10:33:14.626]                       })
[10:33:14.626]                     }
[10:33:14.626]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:14.626]                     base::options(mc.cores = 1L)
[10:33:14.626]                   }
[10:33:14.626]                   ...future.strategy.old <- future::plan("list")
[10:33:14.626]                   options(future.plan = NULL)
[10:33:14.626]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:14.626]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:14.626]                 }
[10:33:14.626]                 ...future.workdir <- getwd()
[10:33:14.626]             }
[10:33:14.626]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:14.626]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:14.626]         }
[10:33:14.626]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:14.626]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:14.626]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:14.626]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:14.626]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:14.626]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:14.626]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:14.626]             base::names(...future.oldOptions))
[10:33:14.626]     }
[10:33:14.626]     if (FALSE) {
[10:33:14.626]     }
[10:33:14.626]     else {
[10:33:14.626]         if (TRUE) {
[10:33:14.626]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:14.626]                 open = "w")
[10:33:14.626]         }
[10:33:14.626]         else {
[10:33:14.626]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:14.626]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:14.626]         }
[10:33:14.626]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:14.626]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:14.626]             base::sink(type = "output", split = FALSE)
[10:33:14.626]             base::close(...future.stdout)
[10:33:14.626]         }, add = TRUE)
[10:33:14.626]     }
[10:33:14.626]     ...future.frame <- base::sys.nframe()
[10:33:14.626]     ...future.conditions <- base::list()
[10:33:14.626]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:14.626]     if (FALSE) {
[10:33:14.626]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:14.626]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:14.626]     }
[10:33:14.626]     ...future.result <- base::tryCatch({
[10:33:14.626]         base::withCallingHandlers({
[10:33:14.626]             ...future.value <- base::withVisible(base::local({
[10:33:14.626]                 ...future.makeSendCondition <- base::local({
[10:33:14.626]                   sendCondition <- NULL
[10:33:14.626]                   function(frame = 1L) {
[10:33:14.626]                     if (is.function(sendCondition)) 
[10:33:14.626]                       return(sendCondition)
[10:33:14.626]                     ns <- getNamespace("parallel")
[10:33:14.626]                     if (exists("sendData", mode = "function", 
[10:33:14.626]                       envir = ns)) {
[10:33:14.626]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:14.626]                         envir = ns)
[10:33:14.626]                       envir <- sys.frame(frame)
[10:33:14.626]                       master <- NULL
[10:33:14.626]                       while (!identical(envir, .GlobalEnv) && 
[10:33:14.626]                         !identical(envir, emptyenv())) {
[10:33:14.626]                         if (exists("master", mode = "list", envir = envir, 
[10:33:14.626]                           inherits = FALSE)) {
[10:33:14.626]                           master <- get("master", mode = "list", 
[10:33:14.626]                             envir = envir, inherits = FALSE)
[10:33:14.626]                           if (inherits(master, c("SOCKnode", 
[10:33:14.626]                             "SOCK0node"))) {
[10:33:14.626]                             sendCondition <<- function(cond) {
[10:33:14.626]                               data <- list(type = "VALUE", value = cond, 
[10:33:14.626]                                 success = TRUE)
[10:33:14.626]                               parallel_sendData(master, data)
[10:33:14.626]                             }
[10:33:14.626]                             return(sendCondition)
[10:33:14.626]                           }
[10:33:14.626]                         }
[10:33:14.626]                         frame <- frame + 1L
[10:33:14.626]                         envir <- sys.frame(frame)
[10:33:14.626]                       }
[10:33:14.626]                     }
[10:33:14.626]                     sendCondition <<- function(cond) NULL
[10:33:14.626]                   }
[10:33:14.626]                 })
[10:33:14.626]                 withCallingHandlers({
[10:33:14.626]                   {
[10:33:14.626]                     b <- a * ii
[10:33:14.626]                     a <- 0
[10:33:14.626]                     b
[10:33:14.626]                   }
[10:33:14.626]                 }, immediateCondition = function(cond) {
[10:33:14.626]                   sendCondition <- ...future.makeSendCondition()
[10:33:14.626]                   sendCondition(cond)
[10:33:14.626]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.626]                   {
[10:33:14.626]                     inherits <- base::inherits
[10:33:14.626]                     invokeRestart <- base::invokeRestart
[10:33:14.626]                     is.null <- base::is.null
[10:33:14.626]                     muffled <- FALSE
[10:33:14.626]                     if (inherits(cond, "message")) {
[10:33:14.626]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:14.626]                       if (muffled) 
[10:33:14.626]                         invokeRestart("muffleMessage")
[10:33:14.626]                     }
[10:33:14.626]                     else if (inherits(cond, "warning")) {
[10:33:14.626]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:14.626]                       if (muffled) 
[10:33:14.626]                         invokeRestart("muffleWarning")
[10:33:14.626]                     }
[10:33:14.626]                     else if (inherits(cond, "condition")) {
[10:33:14.626]                       if (!is.null(pattern)) {
[10:33:14.626]                         computeRestarts <- base::computeRestarts
[10:33:14.626]                         grepl <- base::grepl
[10:33:14.626]                         restarts <- computeRestarts(cond)
[10:33:14.626]                         for (restart in restarts) {
[10:33:14.626]                           name <- restart$name
[10:33:14.626]                           if (is.null(name)) 
[10:33:14.626]                             next
[10:33:14.626]                           if (!grepl(pattern, name)) 
[10:33:14.626]                             next
[10:33:14.626]                           invokeRestart(restart)
[10:33:14.626]                           muffled <- TRUE
[10:33:14.626]                           break
[10:33:14.626]                         }
[10:33:14.626]                       }
[10:33:14.626]                     }
[10:33:14.626]                     invisible(muffled)
[10:33:14.626]                   }
[10:33:14.626]                   muffleCondition(cond)
[10:33:14.626]                 })
[10:33:14.626]             }))
[10:33:14.626]             future::FutureResult(value = ...future.value$value, 
[10:33:14.626]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:14.626]                   ...future.rng), globalenv = if (FALSE) 
[10:33:14.626]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:14.626]                     ...future.globalenv.names))
[10:33:14.626]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:14.626]         }, condition = base::local({
[10:33:14.626]             c <- base::c
[10:33:14.626]             inherits <- base::inherits
[10:33:14.626]             invokeRestart <- base::invokeRestart
[10:33:14.626]             length <- base::length
[10:33:14.626]             list <- base::list
[10:33:14.626]             seq.int <- base::seq.int
[10:33:14.626]             signalCondition <- base::signalCondition
[10:33:14.626]             sys.calls <- base::sys.calls
[10:33:14.626]             `[[` <- base::`[[`
[10:33:14.626]             `+` <- base::`+`
[10:33:14.626]             `<<-` <- base::`<<-`
[10:33:14.626]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:14.626]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:14.626]                   3L)]
[10:33:14.626]             }
[10:33:14.626]             function(cond) {
[10:33:14.626]                 is_error <- inherits(cond, "error")
[10:33:14.626]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:14.626]                   NULL)
[10:33:14.626]                 if (is_error) {
[10:33:14.626]                   sessionInformation <- function() {
[10:33:14.626]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:14.626]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:14.626]                       search = base::search(), system = base::Sys.info())
[10:33:14.626]                   }
[10:33:14.626]                   ...future.conditions[[length(...future.conditions) + 
[10:33:14.626]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:14.626]                     cond$call), session = sessionInformation(), 
[10:33:14.626]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:14.626]                   signalCondition(cond)
[10:33:14.626]                 }
[10:33:14.626]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:14.626]                 "immediateCondition"))) {
[10:33:14.626]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:14.626]                   ...future.conditions[[length(...future.conditions) + 
[10:33:14.626]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:14.626]                   if (TRUE && !signal) {
[10:33:14.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.626]                     {
[10:33:14.626]                       inherits <- base::inherits
[10:33:14.626]                       invokeRestart <- base::invokeRestart
[10:33:14.626]                       is.null <- base::is.null
[10:33:14.626]                       muffled <- FALSE
[10:33:14.626]                       if (inherits(cond, "message")) {
[10:33:14.626]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:14.626]                         if (muffled) 
[10:33:14.626]                           invokeRestart("muffleMessage")
[10:33:14.626]                       }
[10:33:14.626]                       else if (inherits(cond, "warning")) {
[10:33:14.626]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:14.626]                         if (muffled) 
[10:33:14.626]                           invokeRestart("muffleWarning")
[10:33:14.626]                       }
[10:33:14.626]                       else if (inherits(cond, "condition")) {
[10:33:14.626]                         if (!is.null(pattern)) {
[10:33:14.626]                           computeRestarts <- base::computeRestarts
[10:33:14.626]                           grepl <- base::grepl
[10:33:14.626]                           restarts <- computeRestarts(cond)
[10:33:14.626]                           for (restart in restarts) {
[10:33:14.626]                             name <- restart$name
[10:33:14.626]                             if (is.null(name)) 
[10:33:14.626]                               next
[10:33:14.626]                             if (!grepl(pattern, name)) 
[10:33:14.626]                               next
[10:33:14.626]                             invokeRestart(restart)
[10:33:14.626]                             muffled <- TRUE
[10:33:14.626]                             break
[10:33:14.626]                           }
[10:33:14.626]                         }
[10:33:14.626]                       }
[10:33:14.626]                       invisible(muffled)
[10:33:14.626]                     }
[10:33:14.626]                     muffleCondition(cond, pattern = "^muffle")
[10:33:14.626]                   }
[10:33:14.626]                 }
[10:33:14.626]                 else {
[10:33:14.626]                   if (TRUE) {
[10:33:14.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.626]                     {
[10:33:14.626]                       inherits <- base::inherits
[10:33:14.626]                       invokeRestart <- base::invokeRestart
[10:33:14.626]                       is.null <- base::is.null
[10:33:14.626]                       muffled <- FALSE
[10:33:14.626]                       if (inherits(cond, "message")) {
[10:33:14.626]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:14.626]                         if (muffled) 
[10:33:14.626]                           invokeRestart("muffleMessage")
[10:33:14.626]                       }
[10:33:14.626]                       else if (inherits(cond, "warning")) {
[10:33:14.626]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:14.626]                         if (muffled) 
[10:33:14.626]                           invokeRestart("muffleWarning")
[10:33:14.626]                       }
[10:33:14.626]                       else if (inherits(cond, "condition")) {
[10:33:14.626]                         if (!is.null(pattern)) {
[10:33:14.626]                           computeRestarts <- base::computeRestarts
[10:33:14.626]                           grepl <- base::grepl
[10:33:14.626]                           restarts <- computeRestarts(cond)
[10:33:14.626]                           for (restart in restarts) {
[10:33:14.626]                             name <- restart$name
[10:33:14.626]                             if (is.null(name)) 
[10:33:14.626]                               next
[10:33:14.626]                             if (!grepl(pattern, name)) 
[10:33:14.626]                               next
[10:33:14.626]                             invokeRestart(restart)
[10:33:14.626]                             muffled <- TRUE
[10:33:14.626]                             break
[10:33:14.626]                           }
[10:33:14.626]                         }
[10:33:14.626]                       }
[10:33:14.626]                       invisible(muffled)
[10:33:14.626]                     }
[10:33:14.626]                     muffleCondition(cond, pattern = "^muffle")
[10:33:14.626]                   }
[10:33:14.626]                 }
[10:33:14.626]             }
[10:33:14.626]         }))
[10:33:14.626]     }, error = function(ex) {
[10:33:14.626]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:14.626]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:14.626]                 ...future.rng), started = ...future.startTime, 
[10:33:14.626]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:14.626]             version = "1.8"), class = "FutureResult")
[10:33:14.626]     }, finally = {
[10:33:14.626]         if (!identical(...future.workdir, getwd())) 
[10:33:14.626]             setwd(...future.workdir)
[10:33:14.626]         {
[10:33:14.626]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:14.626]                 ...future.oldOptions$nwarnings <- NULL
[10:33:14.626]             }
[10:33:14.626]             base::options(...future.oldOptions)
[10:33:14.626]             if (.Platform$OS.type == "windows") {
[10:33:14.626]                 old_names <- names(...future.oldEnvVars)
[10:33:14.626]                 envs <- base::Sys.getenv()
[10:33:14.626]                 names <- names(envs)
[10:33:14.626]                 common <- intersect(names, old_names)
[10:33:14.626]                 added <- setdiff(names, old_names)
[10:33:14.626]                 removed <- setdiff(old_names, names)
[10:33:14.626]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:14.626]                   envs[common]]
[10:33:14.626]                 NAMES <- toupper(changed)
[10:33:14.626]                 args <- list()
[10:33:14.626]                 for (kk in seq_along(NAMES)) {
[10:33:14.626]                   name <- changed[[kk]]
[10:33:14.626]                   NAME <- NAMES[[kk]]
[10:33:14.626]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.626]                     next
[10:33:14.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:14.626]                 }
[10:33:14.626]                 NAMES <- toupper(added)
[10:33:14.626]                 for (kk in seq_along(NAMES)) {
[10:33:14.626]                   name <- added[[kk]]
[10:33:14.626]                   NAME <- NAMES[[kk]]
[10:33:14.626]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.626]                     next
[10:33:14.626]                   args[[name]] <- ""
[10:33:14.626]                 }
[10:33:14.626]                 NAMES <- toupper(removed)
[10:33:14.626]                 for (kk in seq_along(NAMES)) {
[10:33:14.626]                   name <- removed[[kk]]
[10:33:14.626]                   NAME <- NAMES[[kk]]
[10:33:14.626]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.626]                     next
[10:33:14.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:14.626]                 }
[10:33:14.626]                 if (length(args) > 0) 
[10:33:14.626]                   base::do.call(base::Sys.setenv, args = args)
[10:33:14.626]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:14.626]             }
[10:33:14.626]             else {
[10:33:14.626]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:14.626]             }
[10:33:14.626]             {
[10:33:14.626]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:14.626]                   0L) {
[10:33:14.626]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:14.626]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:14.626]                   base::options(opts)
[10:33:14.626]                 }
[10:33:14.626]                 {
[10:33:14.626]                   {
[10:33:14.626]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:14.626]                     NULL
[10:33:14.626]                   }
[10:33:14.626]                   options(future.plan = NULL)
[10:33:14.626]                   if (is.na(NA_character_)) 
[10:33:14.626]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:14.626]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:14.626]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:14.626]                     .init = FALSE)
[10:33:14.626]                 }
[10:33:14.626]             }
[10:33:14.626]         }
[10:33:14.626]     })
[10:33:14.626]     if (TRUE) {
[10:33:14.626]         base::sink(type = "output", split = FALSE)
[10:33:14.626]         if (TRUE) {
[10:33:14.626]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:14.626]         }
[10:33:14.626]         else {
[10:33:14.626]             ...future.result["stdout"] <- base::list(NULL)
[10:33:14.626]         }
[10:33:14.626]         base::close(...future.stdout)
[10:33:14.626]         ...future.stdout <- NULL
[10:33:14.626]     }
[10:33:14.626]     ...future.result$conditions <- ...future.conditions
[10:33:14.626]     ...future.result$finished <- base::Sys.time()
[10:33:14.626]     ...future.result
[10:33:14.626] }
[10:33:14.629] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[10:33:14.629] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[10:33:14.629] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[10:33:14.630] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[10:33:14.630] MultisessionFuture started
[10:33:14.630] - Launch lazy future ... done
[10:33:14.630] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:14.631] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:14.631] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:14.633] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:14.633] Searching for globals ... DONE
[10:33:14.634] Resolving globals: TRUE
[10:33:14.634] Resolving any globals that are futures ...
[10:33:14.634] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:14.634] Resolving any globals that are futures ... DONE
[10:33:14.634] Resolving futures part of globals (recursively) ...
[10:33:14.634] resolve() on list ...
[10:33:14.635]  recursive: 99
[10:33:14.635]  length: 1
[10:33:14.635]  elements: ‘ii’
[10:33:14.635]  length: 0 (resolved future 1)
[10:33:14.635] resolve() on list ... DONE
[10:33:14.635] - globals: [1] ‘ii’
[10:33:14.635] Resolving futures part of globals (recursively) ... DONE
[10:33:14.635] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:14.636] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:14.636] - globals: [1] ‘ii’
[10:33:14.636] 
[10:33:14.636] getGlobalsAndPackages() ... DONE
[10:33:14.636] run() for ‘Future’ ...
[10:33:14.636] - state: ‘created’
[10:33:14.636] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:14.650] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:14.650] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:14.650]   - Field: ‘node’
[10:33:14.650]   - Field: ‘label’
[10:33:14.650]   - Field: ‘local’
[10:33:14.650]   - Field: ‘owner’
[10:33:14.650]   - Field: ‘envir’
[10:33:14.651]   - Field: ‘workers’
[10:33:14.651]   - Field: ‘packages’
[10:33:14.651]   - Field: ‘gc’
[10:33:14.651]   - Field: ‘conditions’
[10:33:14.651]   - Field: ‘persistent’
[10:33:14.651]   - Field: ‘expr’
[10:33:14.651]   - Field: ‘uuid’
[10:33:14.651]   - Field: ‘seed’
[10:33:14.651]   - Field: ‘version’
[10:33:14.651]   - Field: ‘result’
[10:33:14.651]   - Field: ‘asynchronous’
[10:33:14.652]   - Field: ‘calls’
[10:33:14.652]   - Field: ‘globals’
[10:33:14.652]   - Field: ‘stdout’
[10:33:14.652]   - Field: ‘earlySignal’
[10:33:14.652]   - Field: ‘lazy’
[10:33:14.652]   - Field: ‘state’
[10:33:14.652] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:14.652] - Launch lazy future ...
[10:33:14.652] Packages needed by the future expression (n = 0): <none>
[10:33:14.653] Packages needed by future strategies (n = 0): <none>
[10:33:14.653] {
[10:33:14.653]     {
[10:33:14.653]         {
[10:33:14.653]             ...future.startTime <- base::Sys.time()
[10:33:14.653]             {
[10:33:14.653]                 {
[10:33:14.653]                   {
[10:33:14.653]                     {
[10:33:14.653]                       base::local({
[10:33:14.653]                         has_future <- base::requireNamespace("future", 
[10:33:14.653]                           quietly = TRUE)
[10:33:14.653]                         if (has_future) {
[10:33:14.653]                           ns <- base::getNamespace("future")
[10:33:14.653]                           version <- ns[[".package"]][["version"]]
[10:33:14.653]                           if (is.null(version)) 
[10:33:14.653]                             version <- utils::packageVersion("future")
[10:33:14.653]                         }
[10:33:14.653]                         else {
[10:33:14.653]                           version <- NULL
[10:33:14.653]                         }
[10:33:14.653]                         if (!has_future || version < "1.8.0") {
[10:33:14.653]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:14.653]                             "", base::R.version$version.string), 
[10:33:14.653]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:14.653]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:14.653]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:14.653]                               "release", "version")], collapse = " "), 
[10:33:14.653]                             hostname = base::Sys.info()[["nodename"]])
[10:33:14.653]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:14.653]                             info)
[10:33:14.653]                           info <- base::paste(info, collapse = "; ")
[10:33:14.653]                           if (!has_future) {
[10:33:14.653]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:14.653]                               info)
[10:33:14.653]                           }
[10:33:14.653]                           else {
[10:33:14.653]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:14.653]                               info, version)
[10:33:14.653]                           }
[10:33:14.653]                           base::stop(msg)
[10:33:14.653]                         }
[10:33:14.653]                       })
[10:33:14.653]                     }
[10:33:14.653]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:14.653]                     base::options(mc.cores = 1L)
[10:33:14.653]                   }
[10:33:14.653]                   ...future.strategy.old <- future::plan("list")
[10:33:14.653]                   options(future.plan = NULL)
[10:33:14.653]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:14.653]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:14.653]                 }
[10:33:14.653]                 ...future.workdir <- getwd()
[10:33:14.653]             }
[10:33:14.653]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:14.653]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:14.653]         }
[10:33:14.653]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:14.653]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:14.653]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:14.653]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:14.653]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:14.653]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:14.653]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:14.653]             base::names(...future.oldOptions))
[10:33:14.653]     }
[10:33:14.653]     if (FALSE) {
[10:33:14.653]     }
[10:33:14.653]     else {
[10:33:14.653]         if (TRUE) {
[10:33:14.653]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:14.653]                 open = "w")
[10:33:14.653]         }
[10:33:14.653]         else {
[10:33:14.653]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:14.653]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:14.653]         }
[10:33:14.653]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:14.653]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:14.653]             base::sink(type = "output", split = FALSE)
[10:33:14.653]             base::close(...future.stdout)
[10:33:14.653]         }, add = TRUE)
[10:33:14.653]     }
[10:33:14.653]     ...future.frame <- base::sys.nframe()
[10:33:14.653]     ...future.conditions <- base::list()
[10:33:14.653]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:14.653]     if (FALSE) {
[10:33:14.653]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:14.653]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:14.653]     }
[10:33:14.653]     ...future.result <- base::tryCatch({
[10:33:14.653]         base::withCallingHandlers({
[10:33:14.653]             ...future.value <- base::withVisible(base::local({
[10:33:14.653]                 ...future.makeSendCondition <- base::local({
[10:33:14.653]                   sendCondition <- NULL
[10:33:14.653]                   function(frame = 1L) {
[10:33:14.653]                     if (is.function(sendCondition)) 
[10:33:14.653]                       return(sendCondition)
[10:33:14.653]                     ns <- getNamespace("parallel")
[10:33:14.653]                     if (exists("sendData", mode = "function", 
[10:33:14.653]                       envir = ns)) {
[10:33:14.653]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:14.653]                         envir = ns)
[10:33:14.653]                       envir <- sys.frame(frame)
[10:33:14.653]                       master <- NULL
[10:33:14.653]                       while (!identical(envir, .GlobalEnv) && 
[10:33:14.653]                         !identical(envir, emptyenv())) {
[10:33:14.653]                         if (exists("master", mode = "list", envir = envir, 
[10:33:14.653]                           inherits = FALSE)) {
[10:33:14.653]                           master <- get("master", mode = "list", 
[10:33:14.653]                             envir = envir, inherits = FALSE)
[10:33:14.653]                           if (inherits(master, c("SOCKnode", 
[10:33:14.653]                             "SOCK0node"))) {
[10:33:14.653]                             sendCondition <<- function(cond) {
[10:33:14.653]                               data <- list(type = "VALUE", value = cond, 
[10:33:14.653]                                 success = TRUE)
[10:33:14.653]                               parallel_sendData(master, data)
[10:33:14.653]                             }
[10:33:14.653]                             return(sendCondition)
[10:33:14.653]                           }
[10:33:14.653]                         }
[10:33:14.653]                         frame <- frame + 1L
[10:33:14.653]                         envir <- sys.frame(frame)
[10:33:14.653]                       }
[10:33:14.653]                     }
[10:33:14.653]                     sendCondition <<- function(cond) NULL
[10:33:14.653]                   }
[10:33:14.653]                 })
[10:33:14.653]                 withCallingHandlers({
[10:33:14.653]                   {
[10:33:14.653]                     b <- a * ii
[10:33:14.653]                     a <- 0
[10:33:14.653]                     b
[10:33:14.653]                   }
[10:33:14.653]                 }, immediateCondition = function(cond) {
[10:33:14.653]                   sendCondition <- ...future.makeSendCondition()
[10:33:14.653]                   sendCondition(cond)
[10:33:14.653]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.653]                   {
[10:33:14.653]                     inherits <- base::inherits
[10:33:14.653]                     invokeRestart <- base::invokeRestart
[10:33:14.653]                     is.null <- base::is.null
[10:33:14.653]                     muffled <- FALSE
[10:33:14.653]                     if (inherits(cond, "message")) {
[10:33:14.653]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:14.653]                       if (muffled) 
[10:33:14.653]                         invokeRestart("muffleMessage")
[10:33:14.653]                     }
[10:33:14.653]                     else if (inherits(cond, "warning")) {
[10:33:14.653]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:14.653]                       if (muffled) 
[10:33:14.653]                         invokeRestart("muffleWarning")
[10:33:14.653]                     }
[10:33:14.653]                     else if (inherits(cond, "condition")) {
[10:33:14.653]                       if (!is.null(pattern)) {
[10:33:14.653]                         computeRestarts <- base::computeRestarts
[10:33:14.653]                         grepl <- base::grepl
[10:33:14.653]                         restarts <- computeRestarts(cond)
[10:33:14.653]                         for (restart in restarts) {
[10:33:14.653]                           name <- restart$name
[10:33:14.653]                           if (is.null(name)) 
[10:33:14.653]                             next
[10:33:14.653]                           if (!grepl(pattern, name)) 
[10:33:14.653]                             next
[10:33:14.653]                           invokeRestart(restart)
[10:33:14.653]                           muffled <- TRUE
[10:33:14.653]                           break
[10:33:14.653]                         }
[10:33:14.653]                       }
[10:33:14.653]                     }
[10:33:14.653]                     invisible(muffled)
[10:33:14.653]                   }
[10:33:14.653]                   muffleCondition(cond)
[10:33:14.653]                 })
[10:33:14.653]             }))
[10:33:14.653]             future::FutureResult(value = ...future.value$value, 
[10:33:14.653]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:14.653]                   ...future.rng), globalenv = if (FALSE) 
[10:33:14.653]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:14.653]                     ...future.globalenv.names))
[10:33:14.653]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:14.653]         }, condition = base::local({
[10:33:14.653]             c <- base::c
[10:33:14.653]             inherits <- base::inherits
[10:33:14.653]             invokeRestart <- base::invokeRestart
[10:33:14.653]             length <- base::length
[10:33:14.653]             list <- base::list
[10:33:14.653]             seq.int <- base::seq.int
[10:33:14.653]             signalCondition <- base::signalCondition
[10:33:14.653]             sys.calls <- base::sys.calls
[10:33:14.653]             `[[` <- base::`[[`
[10:33:14.653]             `+` <- base::`+`
[10:33:14.653]             `<<-` <- base::`<<-`
[10:33:14.653]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:14.653]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:14.653]                   3L)]
[10:33:14.653]             }
[10:33:14.653]             function(cond) {
[10:33:14.653]                 is_error <- inherits(cond, "error")
[10:33:14.653]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:14.653]                   NULL)
[10:33:14.653]                 if (is_error) {
[10:33:14.653]                   sessionInformation <- function() {
[10:33:14.653]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:14.653]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:14.653]                       search = base::search(), system = base::Sys.info())
[10:33:14.653]                   }
[10:33:14.653]                   ...future.conditions[[length(...future.conditions) + 
[10:33:14.653]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:14.653]                     cond$call), session = sessionInformation(), 
[10:33:14.653]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:14.653]                   signalCondition(cond)
[10:33:14.653]                 }
[10:33:14.653]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:14.653]                 "immediateCondition"))) {
[10:33:14.653]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:14.653]                   ...future.conditions[[length(...future.conditions) + 
[10:33:14.653]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:14.653]                   if (TRUE && !signal) {
[10:33:14.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.653]                     {
[10:33:14.653]                       inherits <- base::inherits
[10:33:14.653]                       invokeRestart <- base::invokeRestart
[10:33:14.653]                       is.null <- base::is.null
[10:33:14.653]                       muffled <- FALSE
[10:33:14.653]                       if (inherits(cond, "message")) {
[10:33:14.653]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:14.653]                         if (muffled) 
[10:33:14.653]                           invokeRestart("muffleMessage")
[10:33:14.653]                       }
[10:33:14.653]                       else if (inherits(cond, "warning")) {
[10:33:14.653]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:14.653]                         if (muffled) 
[10:33:14.653]                           invokeRestart("muffleWarning")
[10:33:14.653]                       }
[10:33:14.653]                       else if (inherits(cond, "condition")) {
[10:33:14.653]                         if (!is.null(pattern)) {
[10:33:14.653]                           computeRestarts <- base::computeRestarts
[10:33:14.653]                           grepl <- base::grepl
[10:33:14.653]                           restarts <- computeRestarts(cond)
[10:33:14.653]                           for (restart in restarts) {
[10:33:14.653]                             name <- restart$name
[10:33:14.653]                             if (is.null(name)) 
[10:33:14.653]                               next
[10:33:14.653]                             if (!grepl(pattern, name)) 
[10:33:14.653]                               next
[10:33:14.653]                             invokeRestart(restart)
[10:33:14.653]                             muffled <- TRUE
[10:33:14.653]                             break
[10:33:14.653]                           }
[10:33:14.653]                         }
[10:33:14.653]                       }
[10:33:14.653]                       invisible(muffled)
[10:33:14.653]                     }
[10:33:14.653]                     muffleCondition(cond, pattern = "^muffle")
[10:33:14.653]                   }
[10:33:14.653]                 }
[10:33:14.653]                 else {
[10:33:14.653]                   if (TRUE) {
[10:33:14.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.653]                     {
[10:33:14.653]                       inherits <- base::inherits
[10:33:14.653]                       invokeRestart <- base::invokeRestart
[10:33:14.653]                       is.null <- base::is.null
[10:33:14.653]                       muffled <- FALSE
[10:33:14.653]                       if (inherits(cond, "message")) {
[10:33:14.653]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:14.653]                         if (muffled) 
[10:33:14.653]                           invokeRestart("muffleMessage")
[10:33:14.653]                       }
[10:33:14.653]                       else if (inherits(cond, "warning")) {
[10:33:14.653]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:14.653]                         if (muffled) 
[10:33:14.653]                           invokeRestart("muffleWarning")
[10:33:14.653]                       }
[10:33:14.653]                       else if (inherits(cond, "condition")) {
[10:33:14.653]                         if (!is.null(pattern)) {
[10:33:14.653]                           computeRestarts <- base::computeRestarts
[10:33:14.653]                           grepl <- base::grepl
[10:33:14.653]                           restarts <- computeRestarts(cond)
[10:33:14.653]                           for (restart in restarts) {
[10:33:14.653]                             name <- restart$name
[10:33:14.653]                             if (is.null(name)) 
[10:33:14.653]                               next
[10:33:14.653]                             if (!grepl(pattern, name)) 
[10:33:14.653]                               next
[10:33:14.653]                             invokeRestart(restart)
[10:33:14.653]                             muffled <- TRUE
[10:33:14.653]                             break
[10:33:14.653]                           }
[10:33:14.653]                         }
[10:33:14.653]                       }
[10:33:14.653]                       invisible(muffled)
[10:33:14.653]                     }
[10:33:14.653]                     muffleCondition(cond, pattern = "^muffle")
[10:33:14.653]                   }
[10:33:14.653]                 }
[10:33:14.653]             }
[10:33:14.653]         }))
[10:33:14.653]     }, error = function(ex) {
[10:33:14.653]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:14.653]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:14.653]                 ...future.rng), started = ...future.startTime, 
[10:33:14.653]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:14.653]             version = "1.8"), class = "FutureResult")
[10:33:14.653]     }, finally = {
[10:33:14.653]         if (!identical(...future.workdir, getwd())) 
[10:33:14.653]             setwd(...future.workdir)
[10:33:14.653]         {
[10:33:14.653]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:14.653]                 ...future.oldOptions$nwarnings <- NULL
[10:33:14.653]             }
[10:33:14.653]             base::options(...future.oldOptions)
[10:33:14.653]             if (.Platform$OS.type == "windows") {
[10:33:14.653]                 old_names <- names(...future.oldEnvVars)
[10:33:14.653]                 envs <- base::Sys.getenv()
[10:33:14.653]                 names <- names(envs)
[10:33:14.653]                 common <- intersect(names, old_names)
[10:33:14.653]                 added <- setdiff(names, old_names)
[10:33:14.653]                 removed <- setdiff(old_names, names)
[10:33:14.653]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:14.653]                   envs[common]]
[10:33:14.653]                 NAMES <- toupper(changed)
[10:33:14.653]                 args <- list()
[10:33:14.653]                 for (kk in seq_along(NAMES)) {
[10:33:14.653]                   name <- changed[[kk]]
[10:33:14.653]                   NAME <- NAMES[[kk]]
[10:33:14.653]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.653]                     next
[10:33:14.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:14.653]                 }
[10:33:14.653]                 NAMES <- toupper(added)
[10:33:14.653]                 for (kk in seq_along(NAMES)) {
[10:33:14.653]                   name <- added[[kk]]
[10:33:14.653]                   NAME <- NAMES[[kk]]
[10:33:14.653]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.653]                     next
[10:33:14.653]                   args[[name]] <- ""
[10:33:14.653]                 }
[10:33:14.653]                 NAMES <- toupper(removed)
[10:33:14.653]                 for (kk in seq_along(NAMES)) {
[10:33:14.653]                   name <- removed[[kk]]
[10:33:14.653]                   NAME <- NAMES[[kk]]
[10:33:14.653]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.653]                     next
[10:33:14.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:14.653]                 }
[10:33:14.653]                 if (length(args) > 0) 
[10:33:14.653]                   base::do.call(base::Sys.setenv, args = args)
[10:33:14.653]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:14.653]             }
[10:33:14.653]             else {
[10:33:14.653]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:14.653]             }
[10:33:14.653]             {
[10:33:14.653]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:14.653]                   0L) {
[10:33:14.653]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:14.653]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:14.653]                   base::options(opts)
[10:33:14.653]                 }
[10:33:14.653]                 {
[10:33:14.653]                   {
[10:33:14.653]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:14.653]                     NULL
[10:33:14.653]                   }
[10:33:14.653]                   options(future.plan = NULL)
[10:33:14.653]                   if (is.na(NA_character_)) 
[10:33:14.653]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:14.653]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:14.653]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:14.653]                     .init = FALSE)
[10:33:14.653]                 }
[10:33:14.653]             }
[10:33:14.653]         }
[10:33:14.653]     })
[10:33:14.653]     if (TRUE) {
[10:33:14.653]         base::sink(type = "output", split = FALSE)
[10:33:14.653]         if (TRUE) {
[10:33:14.653]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:14.653]         }
[10:33:14.653]         else {
[10:33:14.653]             ...future.result["stdout"] <- base::list(NULL)
[10:33:14.653]         }
[10:33:14.653]         base::close(...future.stdout)
[10:33:14.653]         ...future.stdout <- NULL
[10:33:14.653]     }
[10:33:14.653]     ...future.result$conditions <- ...future.conditions
[10:33:14.653]     ...future.result$finished <- base::Sys.time()
[10:33:14.653]     ...future.result
[10:33:14.653] }
[10:33:14.705] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[10:33:14.705] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[10:33:14.706] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[10:33:14.706] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[10:33:14.707] MultisessionFuture started
[10:33:14.707] - Launch lazy future ... done
[10:33:14.707] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:14.708] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:14.708] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:14.710] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:14.710] Searching for globals ... DONE
[10:33:14.711] Resolving globals: TRUE
[10:33:14.711] Resolving any globals that are futures ...
[10:33:14.711] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:14.711] Resolving any globals that are futures ... DONE
[10:33:14.712] Resolving futures part of globals (recursively) ...
[10:33:14.712] resolve() on list ...
[10:33:14.712]  recursive: 99
[10:33:14.712]  length: 1
[10:33:14.713]  elements: ‘ii’
[10:33:14.713]  length: 0 (resolved future 1)
[10:33:14.713] resolve() on list ... DONE
[10:33:14.713] - globals: [1] ‘ii’
[10:33:14.713] Resolving futures part of globals (recursively) ... DONE
[10:33:14.713] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:14.714] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:14.714] - globals: [1] ‘ii’
[10:33:14.714] 
[10:33:14.714] getGlobalsAndPackages() ... DONE
[10:33:14.715] run() for ‘Future’ ...
[10:33:14.715] - state: ‘created’
[10:33:14.715] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:14.732] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:14.732] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:14.733]   - Field: ‘node’
[10:33:14.733]   - Field: ‘label’
[10:33:14.733]   - Field: ‘local’
[10:33:14.733]   - Field: ‘owner’
[10:33:14.733]   - Field: ‘envir’
[10:33:14.733]   - Field: ‘workers’
[10:33:14.734]   - Field: ‘packages’
[10:33:14.734]   - Field: ‘gc’
[10:33:14.734]   - Field: ‘conditions’
[10:33:14.734]   - Field: ‘persistent’
[10:33:14.734]   - Field: ‘expr’
[10:33:14.734]   - Field: ‘uuid’
[10:33:14.735]   - Field: ‘seed’
[10:33:14.735]   - Field: ‘version’
[10:33:14.735]   - Field: ‘result’
[10:33:14.735]   - Field: ‘asynchronous’
[10:33:14.735]   - Field: ‘calls’
[10:33:14.735]   - Field: ‘globals’
[10:33:14.736]   - Field: ‘stdout’
[10:33:14.736]   - Field: ‘earlySignal’
[10:33:14.736]   - Field: ‘lazy’
[10:33:14.736]   - Field: ‘state’
[10:33:14.736] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:14.736] - Launch lazy future ...
[10:33:14.737] Packages needed by the future expression (n = 0): <none>
[10:33:14.737] Packages needed by future strategies (n = 0): <none>
[10:33:14.738] {
[10:33:14.738]     {
[10:33:14.738]         {
[10:33:14.738]             ...future.startTime <- base::Sys.time()
[10:33:14.738]             {
[10:33:14.738]                 {
[10:33:14.738]                   {
[10:33:14.738]                     {
[10:33:14.738]                       base::local({
[10:33:14.738]                         has_future <- base::requireNamespace("future", 
[10:33:14.738]                           quietly = TRUE)
[10:33:14.738]                         if (has_future) {
[10:33:14.738]                           ns <- base::getNamespace("future")
[10:33:14.738]                           version <- ns[[".package"]][["version"]]
[10:33:14.738]                           if (is.null(version)) 
[10:33:14.738]                             version <- utils::packageVersion("future")
[10:33:14.738]                         }
[10:33:14.738]                         else {
[10:33:14.738]                           version <- NULL
[10:33:14.738]                         }
[10:33:14.738]                         if (!has_future || version < "1.8.0") {
[10:33:14.738]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:14.738]                             "", base::R.version$version.string), 
[10:33:14.738]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:14.738]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:14.738]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:14.738]                               "release", "version")], collapse = " "), 
[10:33:14.738]                             hostname = base::Sys.info()[["nodename"]])
[10:33:14.738]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:14.738]                             info)
[10:33:14.738]                           info <- base::paste(info, collapse = "; ")
[10:33:14.738]                           if (!has_future) {
[10:33:14.738]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:14.738]                               info)
[10:33:14.738]                           }
[10:33:14.738]                           else {
[10:33:14.738]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:14.738]                               info, version)
[10:33:14.738]                           }
[10:33:14.738]                           base::stop(msg)
[10:33:14.738]                         }
[10:33:14.738]                       })
[10:33:14.738]                     }
[10:33:14.738]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:14.738]                     base::options(mc.cores = 1L)
[10:33:14.738]                   }
[10:33:14.738]                   ...future.strategy.old <- future::plan("list")
[10:33:14.738]                   options(future.plan = NULL)
[10:33:14.738]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:14.738]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:14.738]                 }
[10:33:14.738]                 ...future.workdir <- getwd()
[10:33:14.738]             }
[10:33:14.738]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:14.738]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:14.738]         }
[10:33:14.738]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:14.738]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:14.738]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:14.738]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:14.738]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:14.738]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:14.738]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:14.738]             base::names(...future.oldOptions))
[10:33:14.738]     }
[10:33:14.738]     if (FALSE) {
[10:33:14.738]     }
[10:33:14.738]     else {
[10:33:14.738]         if (TRUE) {
[10:33:14.738]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:14.738]                 open = "w")
[10:33:14.738]         }
[10:33:14.738]         else {
[10:33:14.738]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:14.738]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:14.738]         }
[10:33:14.738]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:14.738]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:14.738]             base::sink(type = "output", split = FALSE)
[10:33:14.738]             base::close(...future.stdout)
[10:33:14.738]         }, add = TRUE)
[10:33:14.738]     }
[10:33:14.738]     ...future.frame <- base::sys.nframe()
[10:33:14.738]     ...future.conditions <- base::list()
[10:33:14.738]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:14.738]     if (FALSE) {
[10:33:14.738]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:14.738]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:14.738]     }
[10:33:14.738]     ...future.result <- base::tryCatch({
[10:33:14.738]         base::withCallingHandlers({
[10:33:14.738]             ...future.value <- base::withVisible(base::local({
[10:33:14.738]                 ...future.makeSendCondition <- base::local({
[10:33:14.738]                   sendCondition <- NULL
[10:33:14.738]                   function(frame = 1L) {
[10:33:14.738]                     if (is.function(sendCondition)) 
[10:33:14.738]                       return(sendCondition)
[10:33:14.738]                     ns <- getNamespace("parallel")
[10:33:14.738]                     if (exists("sendData", mode = "function", 
[10:33:14.738]                       envir = ns)) {
[10:33:14.738]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:14.738]                         envir = ns)
[10:33:14.738]                       envir <- sys.frame(frame)
[10:33:14.738]                       master <- NULL
[10:33:14.738]                       while (!identical(envir, .GlobalEnv) && 
[10:33:14.738]                         !identical(envir, emptyenv())) {
[10:33:14.738]                         if (exists("master", mode = "list", envir = envir, 
[10:33:14.738]                           inherits = FALSE)) {
[10:33:14.738]                           master <- get("master", mode = "list", 
[10:33:14.738]                             envir = envir, inherits = FALSE)
[10:33:14.738]                           if (inherits(master, c("SOCKnode", 
[10:33:14.738]                             "SOCK0node"))) {
[10:33:14.738]                             sendCondition <<- function(cond) {
[10:33:14.738]                               data <- list(type = "VALUE", value = cond, 
[10:33:14.738]                                 success = TRUE)
[10:33:14.738]                               parallel_sendData(master, data)
[10:33:14.738]                             }
[10:33:14.738]                             return(sendCondition)
[10:33:14.738]                           }
[10:33:14.738]                         }
[10:33:14.738]                         frame <- frame + 1L
[10:33:14.738]                         envir <- sys.frame(frame)
[10:33:14.738]                       }
[10:33:14.738]                     }
[10:33:14.738]                     sendCondition <<- function(cond) NULL
[10:33:14.738]                   }
[10:33:14.738]                 })
[10:33:14.738]                 withCallingHandlers({
[10:33:14.738]                   {
[10:33:14.738]                     b <- a * ii
[10:33:14.738]                     a <- 0
[10:33:14.738]                     b
[10:33:14.738]                   }
[10:33:14.738]                 }, immediateCondition = function(cond) {
[10:33:14.738]                   sendCondition <- ...future.makeSendCondition()
[10:33:14.738]                   sendCondition(cond)
[10:33:14.738]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.738]                   {
[10:33:14.738]                     inherits <- base::inherits
[10:33:14.738]                     invokeRestart <- base::invokeRestart
[10:33:14.738]                     is.null <- base::is.null
[10:33:14.738]                     muffled <- FALSE
[10:33:14.738]                     if (inherits(cond, "message")) {
[10:33:14.738]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:14.738]                       if (muffled) 
[10:33:14.738]                         invokeRestart("muffleMessage")
[10:33:14.738]                     }
[10:33:14.738]                     else if (inherits(cond, "warning")) {
[10:33:14.738]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:14.738]                       if (muffled) 
[10:33:14.738]                         invokeRestart("muffleWarning")
[10:33:14.738]                     }
[10:33:14.738]                     else if (inherits(cond, "condition")) {
[10:33:14.738]                       if (!is.null(pattern)) {
[10:33:14.738]                         computeRestarts <- base::computeRestarts
[10:33:14.738]                         grepl <- base::grepl
[10:33:14.738]                         restarts <- computeRestarts(cond)
[10:33:14.738]                         for (restart in restarts) {
[10:33:14.738]                           name <- restart$name
[10:33:14.738]                           if (is.null(name)) 
[10:33:14.738]                             next
[10:33:14.738]                           if (!grepl(pattern, name)) 
[10:33:14.738]                             next
[10:33:14.738]                           invokeRestart(restart)
[10:33:14.738]                           muffled <- TRUE
[10:33:14.738]                           break
[10:33:14.738]                         }
[10:33:14.738]                       }
[10:33:14.738]                     }
[10:33:14.738]                     invisible(muffled)
[10:33:14.738]                   }
[10:33:14.738]                   muffleCondition(cond)
[10:33:14.738]                 })
[10:33:14.738]             }))
[10:33:14.738]             future::FutureResult(value = ...future.value$value, 
[10:33:14.738]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:14.738]                   ...future.rng), globalenv = if (FALSE) 
[10:33:14.738]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:14.738]                     ...future.globalenv.names))
[10:33:14.738]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:14.738]         }, condition = base::local({
[10:33:14.738]             c <- base::c
[10:33:14.738]             inherits <- base::inherits
[10:33:14.738]             invokeRestart <- base::invokeRestart
[10:33:14.738]             length <- base::length
[10:33:14.738]             list <- base::list
[10:33:14.738]             seq.int <- base::seq.int
[10:33:14.738]             signalCondition <- base::signalCondition
[10:33:14.738]             sys.calls <- base::sys.calls
[10:33:14.738]             `[[` <- base::`[[`
[10:33:14.738]             `+` <- base::`+`
[10:33:14.738]             `<<-` <- base::`<<-`
[10:33:14.738]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:14.738]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:14.738]                   3L)]
[10:33:14.738]             }
[10:33:14.738]             function(cond) {
[10:33:14.738]                 is_error <- inherits(cond, "error")
[10:33:14.738]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:14.738]                   NULL)
[10:33:14.738]                 if (is_error) {
[10:33:14.738]                   sessionInformation <- function() {
[10:33:14.738]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:14.738]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:14.738]                       search = base::search(), system = base::Sys.info())
[10:33:14.738]                   }
[10:33:14.738]                   ...future.conditions[[length(...future.conditions) + 
[10:33:14.738]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:14.738]                     cond$call), session = sessionInformation(), 
[10:33:14.738]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:14.738]                   signalCondition(cond)
[10:33:14.738]                 }
[10:33:14.738]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:14.738]                 "immediateCondition"))) {
[10:33:14.738]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:14.738]                   ...future.conditions[[length(...future.conditions) + 
[10:33:14.738]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:14.738]                   if (TRUE && !signal) {
[10:33:14.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.738]                     {
[10:33:14.738]                       inherits <- base::inherits
[10:33:14.738]                       invokeRestart <- base::invokeRestart
[10:33:14.738]                       is.null <- base::is.null
[10:33:14.738]                       muffled <- FALSE
[10:33:14.738]                       if (inherits(cond, "message")) {
[10:33:14.738]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:14.738]                         if (muffled) 
[10:33:14.738]                           invokeRestart("muffleMessage")
[10:33:14.738]                       }
[10:33:14.738]                       else if (inherits(cond, "warning")) {
[10:33:14.738]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:14.738]                         if (muffled) 
[10:33:14.738]                           invokeRestart("muffleWarning")
[10:33:14.738]                       }
[10:33:14.738]                       else if (inherits(cond, "condition")) {
[10:33:14.738]                         if (!is.null(pattern)) {
[10:33:14.738]                           computeRestarts <- base::computeRestarts
[10:33:14.738]                           grepl <- base::grepl
[10:33:14.738]                           restarts <- computeRestarts(cond)
[10:33:14.738]                           for (restart in restarts) {
[10:33:14.738]                             name <- restart$name
[10:33:14.738]                             if (is.null(name)) 
[10:33:14.738]                               next
[10:33:14.738]                             if (!grepl(pattern, name)) 
[10:33:14.738]                               next
[10:33:14.738]                             invokeRestart(restart)
[10:33:14.738]                             muffled <- TRUE
[10:33:14.738]                             break
[10:33:14.738]                           }
[10:33:14.738]                         }
[10:33:14.738]                       }
[10:33:14.738]                       invisible(muffled)
[10:33:14.738]                     }
[10:33:14.738]                     muffleCondition(cond, pattern = "^muffle")
[10:33:14.738]                   }
[10:33:14.738]                 }
[10:33:14.738]                 else {
[10:33:14.738]                   if (TRUE) {
[10:33:14.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.738]                     {
[10:33:14.738]                       inherits <- base::inherits
[10:33:14.738]                       invokeRestart <- base::invokeRestart
[10:33:14.738]                       is.null <- base::is.null
[10:33:14.738]                       muffled <- FALSE
[10:33:14.738]                       if (inherits(cond, "message")) {
[10:33:14.738]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:14.738]                         if (muffled) 
[10:33:14.738]                           invokeRestart("muffleMessage")
[10:33:14.738]                       }
[10:33:14.738]                       else if (inherits(cond, "warning")) {
[10:33:14.738]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:14.738]                         if (muffled) 
[10:33:14.738]                           invokeRestart("muffleWarning")
[10:33:14.738]                       }
[10:33:14.738]                       else if (inherits(cond, "condition")) {
[10:33:14.738]                         if (!is.null(pattern)) {
[10:33:14.738]                           computeRestarts <- base::computeRestarts
[10:33:14.738]                           grepl <- base::grepl
[10:33:14.738]                           restarts <- computeRestarts(cond)
[10:33:14.738]                           for (restart in restarts) {
[10:33:14.738]                             name <- restart$name
[10:33:14.738]                             if (is.null(name)) 
[10:33:14.738]                               next
[10:33:14.738]                             if (!grepl(pattern, name)) 
[10:33:14.738]                               next
[10:33:14.738]                             invokeRestart(restart)
[10:33:14.738]                             muffled <- TRUE
[10:33:14.738]                             break
[10:33:14.738]                           }
[10:33:14.738]                         }
[10:33:14.738]                       }
[10:33:14.738]                       invisible(muffled)
[10:33:14.738]                     }
[10:33:14.738]                     muffleCondition(cond, pattern = "^muffle")
[10:33:14.738]                   }
[10:33:14.738]                 }
[10:33:14.738]             }
[10:33:14.738]         }))
[10:33:14.738]     }, error = function(ex) {
[10:33:14.738]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:14.738]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:14.738]                 ...future.rng), started = ...future.startTime, 
[10:33:14.738]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:14.738]             version = "1.8"), class = "FutureResult")
[10:33:14.738]     }, finally = {
[10:33:14.738]         if (!identical(...future.workdir, getwd())) 
[10:33:14.738]             setwd(...future.workdir)
[10:33:14.738]         {
[10:33:14.738]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:14.738]                 ...future.oldOptions$nwarnings <- NULL
[10:33:14.738]             }
[10:33:14.738]             base::options(...future.oldOptions)
[10:33:14.738]             if (.Platform$OS.type == "windows") {
[10:33:14.738]                 old_names <- names(...future.oldEnvVars)
[10:33:14.738]                 envs <- base::Sys.getenv()
[10:33:14.738]                 names <- names(envs)
[10:33:14.738]                 common <- intersect(names, old_names)
[10:33:14.738]                 added <- setdiff(names, old_names)
[10:33:14.738]                 removed <- setdiff(old_names, names)
[10:33:14.738]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:14.738]                   envs[common]]
[10:33:14.738]                 NAMES <- toupper(changed)
[10:33:14.738]                 args <- list()
[10:33:14.738]                 for (kk in seq_along(NAMES)) {
[10:33:14.738]                   name <- changed[[kk]]
[10:33:14.738]                   NAME <- NAMES[[kk]]
[10:33:14.738]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.738]                     next
[10:33:14.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:14.738]                 }
[10:33:14.738]                 NAMES <- toupper(added)
[10:33:14.738]                 for (kk in seq_along(NAMES)) {
[10:33:14.738]                   name <- added[[kk]]
[10:33:14.738]                   NAME <- NAMES[[kk]]
[10:33:14.738]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.738]                     next
[10:33:14.738]                   args[[name]] <- ""
[10:33:14.738]                 }
[10:33:14.738]                 NAMES <- toupper(removed)
[10:33:14.738]                 for (kk in seq_along(NAMES)) {
[10:33:14.738]                   name <- removed[[kk]]
[10:33:14.738]                   NAME <- NAMES[[kk]]
[10:33:14.738]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.738]                     next
[10:33:14.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:14.738]                 }
[10:33:14.738]                 if (length(args) > 0) 
[10:33:14.738]                   base::do.call(base::Sys.setenv, args = args)
[10:33:14.738]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:14.738]             }
[10:33:14.738]             else {
[10:33:14.738]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:14.738]             }
[10:33:14.738]             {
[10:33:14.738]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:14.738]                   0L) {
[10:33:14.738]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:14.738]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:14.738]                   base::options(opts)
[10:33:14.738]                 }
[10:33:14.738]                 {
[10:33:14.738]                   {
[10:33:14.738]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:14.738]                     NULL
[10:33:14.738]                   }
[10:33:14.738]                   options(future.plan = NULL)
[10:33:14.738]                   if (is.na(NA_character_)) 
[10:33:14.738]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:14.738]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:14.738]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:14.738]                     .init = FALSE)
[10:33:14.738]                 }
[10:33:14.738]             }
[10:33:14.738]         }
[10:33:14.738]     })
[10:33:14.738]     if (TRUE) {
[10:33:14.738]         base::sink(type = "output", split = FALSE)
[10:33:14.738]         if (TRUE) {
[10:33:14.738]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:14.738]         }
[10:33:14.738]         else {
[10:33:14.738]             ...future.result["stdout"] <- base::list(NULL)
[10:33:14.738]         }
[10:33:14.738]         base::close(...future.stdout)
[10:33:14.738]         ...future.stdout <- NULL
[10:33:14.738]     }
[10:33:14.738]     ...future.result$conditions <- ...future.conditions
[10:33:14.738]     ...future.result$finished <- base::Sys.time()
[10:33:14.738]     ...future.result
[10:33:14.738] }
[10:33:14.741] Poll #1 (0): usedNodes() = 2, workers = 2
[10:33:14.753] receiveMessageFromWorker() for ClusterFuture ...
[10:33:14.753] - Validating connection of MultisessionFuture
[10:33:14.754] - received message: FutureResult
[10:33:14.754] - Received FutureResult
[10:33:14.754] - Erased future from FutureRegistry
[10:33:14.754] result() for ClusterFuture ...
[10:33:14.754] - result already collected: FutureResult
[10:33:14.754] result() for ClusterFuture ... done
[10:33:14.755] signalConditions() ...
[10:33:14.755]  - include = ‘immediateCondition’
[10:33:14.755]  - exclude = 
[10:33:14.755]  - resignal = FALSE
[10:33:14.755]  - Number of conditions: 1
[10:33:14.755] signalConditions() ... done
[10:33:14.755] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:14.756] result() for ClusterFuture ...
[10:33:14.756] - result already collected: FutureResult
[10:33:14.756] result() for ClusterFuture ... done
[10:33:14.756] result() for ClusterFuture ...
[10:33:14.756] - result already collected: FutureResult
[10:33:14.756] result() for ClusterFuture ... done
[10:33:14.756] signalConditions() ...
[10:33:14.756]  - include = ‘immediateCondition’
[10:33:14.756]  - exclude = 
[10:33:14.756]  - resignal = FALSE
[10:33:14.756]  - Number of conditions: 1
[10:33:14.757] signalConditions() ... done
[10:33:14.757] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[10:33:14.757] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[10:33:14.758] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[10:33:14.758] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[10:33:14.758] MultisessionFuture started
[10:33:14.758] - Launch lazy future ... done
[10:33:14.759] run() for ‘MultisessionFuture’ ... done
[10:33:14.759] result() for ClusterFuture ...
[10:33:14.759] - result already collected: FutureResult
[10:33:14.759] result() for ClusterFuture ... done
[10:33:14.759] result() for ClusterFuture ...
[10:33:14.759] - result already collected: FutureResult
[10:33:14.759] result() for ClusterFuture ... done
[10:33:14.759] signalConditions() ...
[10:33:14.759]  - include = ‘immediateCondition’
[10:33:14.759]  - exclude = 
[10:33:14.760]  - resignal = FALSE
[10:33:14.760]  - Number of conditions: 1
[10:33:14.760] signalConditions() ... done
[10:33:14.760] Future state: ‘finished’
[10:33:14.760] result() for ClusterFuture ...
[10:33:14.760] - result already collected: FutureResult
[10:33:14.760] result() for ClusterFuture ... done
[10:33:14.760] signalConditions() ...
[10:33:14.760]  - include = ‘condition’
[10:33:14.760]  - exclude = ‘immediateCondition’
[10:33:14.760]  - resignal = TRUE
[10:33:14.760]  - Number of conditions: 1
[10:33:14.761]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:33:14.761] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "c3bfbccbe859" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 10:33:14"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:14.776] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:14.776] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:14.777] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:14.777] Searching for globals ... DONE
[10:33:14.777] Resolving globals: TRUE
[10:33:14.777] Resolving any globals that are futures ...
[10:33:14.778] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:14.778] Resolving any globals that are futures ... DONE
[10:33:14.778] Resolving futures part of globals (recursively) ...
[10:33:14.778] resolve() on list ...
[10:33:14.778]  recursive: 99
[10:33:14.778]  length: 1
[10:33:14.778]  elements: ‘ii’
[10:33:14.779]  length: 0 (resolved future 1)
[10:33:14.779] resolve() on list ... DONE
[10:33:14.779] - globals: [1] ‘ii’
[10:33:14.779] Resolving futures part of globals (recursively) ... DONE
[10:33:14.779] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:14.779] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:14.779] - globals: [1] ‘ii’
[10:33:14.780] 
[10:33:14.780] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:14.780] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:14.780] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:14.782] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:14.782] Searching for globals ... DONE
[10:33:14.782] Resolving globals: TRUE
[10:33:14.782] Resolving any globals that are futures ...
[10:33:14.782] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:14.782] Resolving any globals that are futures ... DONE
[10:33:14.782] Resolving futures part of globals (recursively) ...
[10:33:14.783] resolve() on list ...
[10:33:14.783]  recursive: 99
[10:33:14.783]  length: 1
[10:33:14.783]  elements: ‘ii’
[10:33:14.783]  length: 0 (resolved future 1)
[10:33:14.783] resolve() on list ... DONE
[10:33:14.783] - globals: [1] ‘ii’
[10:33:14.783] Resolving futures part of globals (recursively) ... DONE
[10:33:14.783] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:14.784] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:14.784] - globals: [1] ‘ii’
[10:33:14.784] 
[10:33:14.784] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:14.784] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:14.785] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:14.786] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:14.786] Searching for globals ... DONE
[10:33:14.786] Resolving globals: TRUE
[10:33:14.786] Resolving any globals that are futures ...
[10:33:14.786] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:33:14.786] Resolving any globals that are futures ... DONE
[10:33:14.787] Resolving futures part of globals (recursively) ...
[10:33:14.787] resolve() on list ...
[10:33:14.787]  recursive: 99
[10:33:14.787]  length: 1
[10:33:14.787]  elements: ‘ii’
[10:33:14.787]  length: 0 (resolved future 1)
[10:33:14.787] resolve() on list ... DONE
[10:33:14.787] - globals: [1] ‘ii’
[10:33:14.787] Resolving futures part of globals (recursively) ... DONE
[10:33:14.788] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:14.788] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:14.788] - globals: [1] ‘ii’
[10:33:14.788] 
[10:33:14.788] getGlobalsAndPackages() ... DONE
[10:33:14.788] run() for ‘Future’ ...
[10:33:14.789] - state: ‘created’
[10:33:14.789] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:14.805] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:14.805] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:14.805]   - Field: ‘node’
[10:33:14.805]   - Field: ‘label’
[10:33:14.805]   - Field: ‘local’
[10:33:14.805]   - Field: ‘owner’
[10:33:14.805]   - Field: ‘envir’
[10:33:14.805]   - Field: ‘workers’
[10:33:14.806]   - Field: ‘packages’
[10:33:14.806]   - Field: ‘gc’
[10:33:14.806]   - Field: ‘conditions’
[10:33:14.806]   - Field: ‘persistent’
[10:33:14.806]   - Field: ‘expr’
[10:33:14.806]   - Field: ‘uuid’
[10:33:14.806]   - Field: ‘seed’
[10:33:14.806]   - Field: ‘version’
[10:33:14.806]   - Field: ‘result’
[10:33:14.806]   - Field: ‘asynchronous’
[10:33:14.807]   - Field: ‘calls’
[10:33:14.807]   - Field: ‘globals’
[10:33:14.807]   - Field: ‘stdout’
[10:33:14.807]   - Field: ‘earlySignal’
[10:33:14.807]   - Field: ‘lazy’
[10:33:14.807]   - Field: ‘state’
[10:33:14.807] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:14.807] - Launch lazy future ...
[10:33:14.807] Packages needed by the future expression (n = 0): <none>
[10:33:14.808] Packages needed by future strategies (n = 0): <none>
[10:33:14.808] {
[10:33:14.808]     {
[10:33:14.808]         {
[10:33:14.808]             ...future.startTime <- base::Sys.time()
[10:33:14.808]             {
[10:33:14.808]                 {
[10:33:14.808]                   {
[10:33:14.808]                     {
[10:33:14.808]                       base::local({
[10:33:14.808]                         has_future <- base::requireNamespace("future", 
[10:33:14.808]                           quietly = TRUE)
[10:33:14.808]                         if (has_future) {
[10:33:14.808]                           ns <- base::getNamespace("future")
[10:33:14.808]                           version <- ns[[".package"]][["version"]]
[10:33:14.808]                           if (is.null(version)) 
[10:33:14.808]                             version <- utils::packageVersion("future")
[10:33:14.808]                         }
[10:33:14.808]                         else {
[10:33:14.808]                           version <- NULL
[10:33:14.808]                         }
[10:33:14.808]                         if (!has_future || version < "1.8.0") {
[10:33:14.808]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:14.808]                             "", base::R.version$version.string), 
[10:33:14.808]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:14.808]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:14.808]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:14.808]                               "release", "version")], collapse = " "), 
[10:33:14.808]                             hostname = base::Sys.info()[["nodename"]])
[10:33:14.808]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:14.808]                             info)
[10:33:14.808]                           info <- base::paste(info, collapse = "; ")
[10:33:14.808]                           if (!has_future) {
[10:33:14.808]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:14.808]                               info)
[10:33:14.808]                           }
[10:33:14.808]                           else {
[10:33:14.808]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:14.808]                               info, version)
[10:33:14.808]                           }
[10:33:14.808]                           base::stop(msg)
[10:33:14.808]                         }
[10:33:14.808]                       })
[10:33:14.808]                     }
[10:33:14.808]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:14.808]                     base::options(mc.cores = 1L)
[10:33:14.808]                   }
[10:33:14.808]                   ...future.strategy.old <- future::plan("list")
[10:33:14.808]                   options(future.plan = NULL)
[10:33:14.808]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:14.808]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:14.808]                 }
[10:33:14.808]                 ...future.workdir <- getwd()
[10:33:14.808]             }
[10:33:14.808]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:14.808]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:14.808]         }
[10:33:14.808]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:14.808]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:14.808]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:14.808]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:14.808]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:14.808]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:14.808]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:14.808]             base::names(...future.oldOptions))
[10:33:14.808]     }
[10:33:14.808]     if (FALSE) {
[10:33:14.808]     }
[10:33:14.808]     else {
[10:33:14.808]         if (TRUE) {
[10:33:14.808]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:14.808]                 open = "w")
[10:33:14.808]         }
[10:33:14.808]         else {
[10:33:14.808]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:14.808]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:14.808]         }
[10:33:14.808]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:14.808]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:14.808]             base::sink(type = "output", split = FALSE)
[10:33:14.808]             base::close(...future.stdout)
[10:33:14.808]         }, add = TRUE)
[10:33:14.808]     }
[10:33:14.808]     ...future.frame <- base::sys.nframe()
[10:33:14.808]     ...future.conditions <- base::list()
[10:33:14.808]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:14.808]     if (FALSE) {
[10:33:14.808]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:14.808]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:14.808]     }
[10:33:14.808]     ...future.result <- base::tryCatch({
[10:33:14.808]         base::withCallingHandlers({
[10:33:14.808]             ...future.value <- base::withVisible(base::local({
[10:33:14.808]                 ...future.makeSendCondition <- base::local({
[10:33:14.808]                   sendCondition <- NULL
[10:33:14.808]                   function(frame = 1L) {
[10:33:14.808]                     if (is.function(sendCondition)) 
[10:33:14.808]                       return(sendCondition)
[10:33:14.808]                     ns <- getNamespace("parallel")
[10:33:14.808]                     if (exists("sendData", mode = "function", 
[10:33:14.808]                       envir = ns)) {
[10:33:14.808]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:14.808]                         envir = ns)
[10:33:14.808]                       envir <- sys.frame(frame)
[10:33:14.808]                       master <- NULL
[10:33:14.808]                       while (!identical(envir, .GlobalEnv) && 
[10:33:14.808]                         !identical(envir, emptyenv())) {
[10:33:14.808]                         if (exists("master", mode = "list", envir = envir, 
[10:33:14.808]                           inherits = FALSE)) {
[10:33:14.808]                           master <- get("master", mode = "list", 
[10:33:14.808]                             envir = envir, inherits = FALSE)
[10:33:14.808]                           if (inherits(master, c("SOCKnode", 
[10:33:14.808]                             "SOCK0node"))) {
[10:33:14.808]                             sendCondition <<- function(cond) {
[10:33:14.808]                               data <- list(type = "VALUE", value = cond, 
[10:33:14.808]                                 success = TRUE)
[10:33:14.808]                               parallel_sendData(master, data)
[10:33:14.808]                             }
[10:33:14.808]                             return(sendCondition)
[10:33:14.808]                           }
[10:33:14.808]                         }
[10:33:14.808]                         frame <- frame + 1L
[10:33:14.808]                         envir <- sys.frame(frame)
[10:33:14.808]                       }
[10:33:14.808]                     }
[10:33:14.808]                     sendCondition <<- function(cond) NULL
[10:33:14.808]                   }
[10:33:14.808]                 })
[10:33:14.808]                 withCallingHandlers({
[10:33:14.808]                   {
[10:33:14.808]                     b <- a * ii
[10:33:14.808]                     a <- 0
[10:33:14.808]                     b
[10:33:14.808]                   }
[10:33:14.808]                 }, immediateCondition = function(cond) {
[10:33:14.808]                   sendCondition <- ...future.makeSendCondition()
[10:33:14.808]                   sendCondition(cond)
[10:33:14.808]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.808]                   {
[10:33:14.808]                     inherits <- base::inherits
[10:33:14.808]                     invokeRestart <- base::invokeRestart
[10:33:14.808]                     is.null <- base::is.null
[10:33:14.808]                     muffled <- FALSE
[10:33:14.808]                     if (inherits(cond, "message")) {
[10:33:14.808]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:14.808]                       if (muffled) 
[10:33:14.808]                         invokeRestart("muffleMessage")
[10:33:14.808]                     }
[10:33:14.808]                     else if (inherits(cond, "warning")) {
[10:33:14.808]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:14.808]                       if (muffled) 
[10:33:14.808]                         invokeRestart("muffleWarning")
[10:33:14.808]                     }
[10:33:14.808]                     else if (inherits(cond, "condition")) {
[10:33:14.808]                       if (!is.null(pattern)) {
[10:33:14.808]                         computeRestarts <- base::computeRestarts
[10:33:14.808]                         grepl <- base::grepl
[10:33:14.808]                         restarts <- computeRestarts(cond)
[10:33:14.808]                         for (restart in restarts) {
[10:33:14.808]                           name <- restart$name
[10:33:14.808]                           if (is.null(name)) 
[10:33:14.808]                             next
[10:33:14.808]                           if (!grepl(pattern, name)) 
[10:33:14.808]                             next
[10:33:14.808]                           invokeRestart(restart)
[10:33:14.808]                           muffled <- TRUE
[10:33:14.808]                           break
[10:33:14.808]                         }
[10:33:14.808]                       }
[10:33:14.808]                     }
[10:33:14.808]                     invisible(muffled)
[10:33:14.808]                   }
[10:33:14.808]                   muffleCondition(cond)
[10:33:14.808]                 })
[10:33:14.808]             }))
[10:33:14.808]             future::FutureResult(value = ...future.value$value, 
[10:33:14.808]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:14.808]                   ...future.rng), globalenv = if (FALSE) 
[10:33:14.808]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:14.808]                     ...future.globalenv.names))
[10:33:14.808]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:14.808]         }, condition = base::local({
[10:33:14.808]             c <- base::c
[10:33:14.808]             inherits <- base::inherits
[10:33:14.808]             invokeRestart <- base::invokeRestart
[10:33:14.808]             length <- base::length
[10:33:14.808]             list <- base::list
[10:33:14.808]             seq.int <- base::seq.int
[10:33:14.808]             signalCondition <- base::signalCondition
[10:33:14.808]             sys.calls <- base::sys.calls
[10:33:14.808]             `[[` <- base::`[[`
[10:33:14.808]             `+` <- base::`+`
[10:33:14.808]             `<<-` <- base::`<<-`
[10:33:14.808]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:14.808]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:14.808]                   3L)]
[10:33:14.808]             }
[10:33:14.808]             function(cond) {
[10:33:14.808]                 is_error <- inherits(cond, "error")
[10:33:14.808]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:14.808]                   NULL)
[10:33:14.808]                 if (is_error) {
[10:33:14.808]                   sessionInformation <- function() {
[10:33:14.808]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:14.808]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:14.808]                       search = base::search(), system = base::Sys.info())
[10:33:14.808]                   }
[10:33:14.808]                   ...future.conditions[[length(...future.conditions) + 
[10:33:14.808]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:14.808]                     cond$call), session = sessionInformation(), 
[10:33:14.808]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:14.808]                   signalCondition(cond)
[10:33:14.808]                 }
[10:33:14.808]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:14.808]                 "immediateCondition"))) {
[10:33:14.808]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:14.808]                   ...future.conditions[[length(...future.conditions) + 
[10:33:14.808]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:14.808]                   if (TRUE && !signal) {
[10:33:14.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.808]                     {
[10:33:14.808]                       inherits <- base::inherits
[10:33:14.808]                       invokeRestart <- base::invokeRestart
[10:33:14.808]                       is.null <- base::is.null
[10:33:14.808]                       muffled <- FALSE
[10:33:14.808]                       if (inherits(cond, "message")) {
[10:33:14.808]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:14.808]                         if (muffled) 
[10:33:14.808]                           invokeRestart("muffleMessage")
[10:33:14.808]                       }
[10:33:14.808]                       else if (inherits(cond, "warning")) {
[10:33:14.808]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:14.808]                         if (muffled) 
[10:33:14.808]                           invokeRestart("muffleWarning")
[10:33:14.808]                       }
[10:33:14.808]                       else if (inherits(cond, "condition")) {
[10:33:14.808]                         if (!is.null(pattern)) {
[10:33:14.808]                           computeRestarts <- base::computeRestarts
[10:33:14.808]                           grepl <- base::grepl
[10:33:14.808]                           restarts <- computeRestarts(cond)
[10:33:14.808]                           for (restart in restarts) {
[10:33:14.808]                             name <- restart$name
[10:33:14.808]                             if (is.null(name)) 
[10:33:14.808]                               next
[10:33:14.808]                             if (!grepl(pattern, name)) 
[10:33:14.808]                               next
[10:33:14.808]                             invokeRestart(restart)
[10:33:14.808]                             muffled <- TRUE
[10:33:14.808]                             break
[10:33:14.808]                           }
[10:33:14.808]                         }
[10:33:14.808]                       }
[10:33:14.808]                       invisible(muffled)
[10:33:14.808]                     }
[10:33:14.808]                     muffleCondition(cond, pattern = "^muffle")
[10:33:14.808]                   }
[10:33:14.808]                 }
[10:33:14.808]                 else {
[10:33:14.808]                   if (TRUE) {
[10:33:14.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.808]                     {
[10:33:14.808]                       inherits <- base::inherits
[10:33:14.808]                       invokeRestart <- base::invokeRestart
[10:33:14.808]                       is.null <- base::is.null
[10:33:14.808]                       muffled <- FALSE
[10:33:14.808]                       if (inherits(cond, "message")) {
[10:33:14.808]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:14.808]                         if (muffled) 
[10:33:14.808]                           invokeRestart("muffleMessage")
[10:33:14.808]                       }
[10:33:14.808]                       else if (inherits(cond, "warning")) {
[10:33:14.808]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:14.808]                         if (muffled) 
[10:33:14.808]                           invokeRestart("muffleWarning")
[10:33:14.808]                       }
[10:33:14.808]                       else if (inherits(cond, "condition")) {
[10:33:14.808]                         if (!is.null(pattern)) {
[10:33:14.808]                           computeRestarts <- base::computeRestarts
[10:33:14.808]                           grepl <- base::grepl
[10:33:14.808]                           restarts <- computeRestarts(cond)
[10:33:14.808]                           for (restart in restarts) {
[10:33:14.808]                             name <- restart$name
[10:33:14.808]                             if (is.null(name)) 
[10:33:14.808]                               next
[10:33:14.808]                             if (!grepl(pattern, name)) 
[10:33:14.808]                               next
[10:33:14.808]                             invokeRestart(restart)
[10:33:14.808]                             muffled <- TRUE
[10:33:14.808]                             break
[10:33:14.808]                           }
[10:33:14.808]                         }
[10:33:14.808]                       }
[10:33:14.808]                       invisible(muffled)
[10:33:14.808]                     }
[10:33:14.808]                     muffleCondition(cond, pattern = "^muffle")
[10:33:14.808]                   }
[10:33:14.808]                 }
[10:33:14.808]             }
[10:33:14.808]         }))
[10:33:14.808]     }, error = function(ex) {
[10:33:14.808]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:14.808]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:14.808]                 ...future.rng), started = ...future.startTime, 
[10:33:14.808]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:14.808]             version = "1.8"), class = "FutureResult")
[10:33:14.808]     }, finally = {
[10:33:14.808]         if (!identical(...future.workdir, getwd())) 
[10:33:14.808]             setwd(...future.workdir)
[10:33:14.808]         {
[10:33:14.808]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:14.808]                 ...future.oldOptions$nwarnings <- NULL
[10:33:14.808]             }
[10:33:14.808]             base::options(...future.oldOptions)
[10:33:14.808]             if (.Platform$OS.type == "windows") {
[10:33:14.808]                 old_names <- names(...future.oldEnvVars)
[10:33:14.808]                 envs <- base::Sys.getenv()
[10:33:14.808]                 names <- names(envs)
[10:33:14.808]                 common <- intersect(names, old_names)
[10:33:14.808]                 added <- setdiff(names, old_names)
[10:33:14.808]                 removed <- setdiff(old_names, names)
[10:33:14.808]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:14.808]                   envs[common]]
[10:33:14.808]                 NAMES <- toupper(changed)
[10:33:14.808]                 args <- list()
[10:33:14.808]                 for (kk in seq_along(NAMES)) {
[10:33:14.808]                   name <- changed[[kk]]
[10:33:14.808]                   NAME <- NAMES[[kk]]
[10:33:14.808]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.808]                     next
[10:33:14.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:14.808]                 }
[10:33:14.808]                 NAMES <- toupper(added)
[10:33:14.808]                 for (kk in seq_along(NAMES)) {
[10:33:14.808]                   name <- added[[kk]]
[10:33:14.808]                   NAME <- NAMES[[kk]]
[10:33:14.808]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.808]                     next
[10:33:14.808]                   args[[name]] <- ""
[10:33:14.808]                 }
[10:33:14.808]                 NAMES <- toupper(removed)
[10:33:14.808]                 for (kk in seq_along(NAMES)) {
[10:33:14.808]                   name <- removed[[kk]]
[10:33:14.808]                   NAME <- NAMES[[kk]]
[10:33:14.808]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.808]                     next
[10:33:14.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:14.808]                 }
[10:33:14.808]                 if (length(args) > 0) 
[10:33:14.808]                   base::do.call(base::Sys.setenv, args = args)
[10:33:14.808]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:14.808]             }
[10:33:14.808]             else {
[10:33:14.808]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:14.808]             }
[10:33:14.808]             {
[10:33:14.808]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:14.808]                   0L) {
[10:33:14.808]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:14.808]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:14.808]                   base::options(opts)
[10:33:14.808]                 }
[10:33:14.808]                 {
[10:33:14.808]                   {
[10:33:14.808]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:14.808]                     NULL
[10:33:14.808]                   }
[10:33:14.808]                   options(future.plan = NULL)
[10:33:14.808]                   if (is.na(NA_character_)) 
[10:33:14.808]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:14.808]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:14.808]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:14.808]                     .init = FALSE)
[10:33:14.808]                 }
[10:33:14.808]             }
[10:33:14.808]         }
[10:33:14.808]     })
[10:33:14.808]     if (TRUE) {
[10:33:14.808]         base::sink(type = "output", split = FALSE)
[10:33:14.808]         if (TRUE) {
[10:33:14.808]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:14.808]         }
[10:33:14.808]         else {
[10:33:14.808]             ...future.result["stdout"] <- base::list(NULL)
[10:33:14.808]         }
[10:33:14.808]         base::close(...future.stdout)
[10:33:14.808]         ...future.stdout <- NULL
[10:33:14.808]     }
[10:33:14.808]     ...future.result$conditions <- ...future.conditions
[10:33:14.808]     ...future.result$finished <- base::Sys.time()
[10:33:14.808]     ...future.result
[10:33:14.808] }
[10:33:14.810] Poll #1 (0): usedNodes() = 2, workers = 2
[10:33:14.821] receiveMessageFromWorker() for ClusterFuture ...
[10:33:14.821] - Validating connection of MultisessionFuture
[10:33:14.821] - received message: FutureResult
[10:33:14.822] - Received FutureResult
[10:33:14.822] - Erased future from FutureRegistry
[10:33:14.822] result() for ClusterFuture ...
[10:33:14.822] - result already collected: FutureResult
[10:33:14.822] result() for ClusterFuture ... done
[10:33:14.822] signalConditions() ...
[10:33:14.822]  - include = ‘immediateCondition’
[10:33:14.822]  - exclude = 
[10:33:14.822]  - resignal = FALSE
[10:33:14.822]  - Number of conditions: 1
[10:33:14.822] signalConditions() ... done
[10:33:14.823] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:14.823] result() for ClusterFuture ...
[10:33:14.823] - result already collected: FutureResult
[10:33:14.823] result() for ClusterFuture ... done
[10:33:14.823] result() for ClusterFuture ...
[10:33:14.823] - result already collected: FutureResult
[10:33:14.823] result() for ClusterFuture ... done
[10:33:14.823] signalConditions() ...
[10:33:14.823]  - include = ‘immediateCondition’
[10:33:14.823]  - exclude = 
[10:33:14.823]  - resignal = FALSE
[10:33:14.824]  - Number of conditions: 1
[10:33:14.824] signalConditions() ... done
[10:33:14.824] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[10:33:14.825] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[10:33:14.825] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[10:33:14.825] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[10:33:14.825] MultisessionFuture started
[10:33:14.826] - Launch lazy future ... done
[10:33:14.826] run() for ‘MultisessionFuture’ ... done
[10:33:14.826] result() for ClusterFuture ...
[10:33:14.826] receiveMessageFromWorker() for ClusterFuture ...
[10:33:14.826] - Validating connection of MultisessionFuture
[10:33:14.831] - received message: FutureResult
[10:33:14.831] - Received FutureResult
[10:33:14.831] - Erased future from FutureRegistry
[10:33:14.831] result() for ClusterFuture ...
[10:33:14.831] - result already collected: FutureResult
[10:33:14.831] result() for ClusterFuture ... done
[10:33:14.832] signalConditions() ...
[10:33:14.832]  - include = ‘immediateCondition’
[10:33:14.832]  - exclude = 
[10:33:14.832]  - resignal = FALSE
[10:33:14.832]  - Number of conditions: 1
[10:33:14.832] signalConditions() ... done
[10:33:14.832] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:14.832] result() for ClusterFuture ... done
[10:33:14.832] result() for ClusterFuture ...
[10:33:14.832] - result already collected: FutureResult
[10:33:14.832] result() for ClusterFuture ... done
[10:33:14.832] signalConditions() ...
[10:33:14.833]  - include = ‘immediateCondition’
[10:33:14.833]  - exclude = 
[10:33:14.833]  - resignal = FALSE
[10:33:14.833]  - Number of conditions: 1
[10:33:14.833] signalConditions() ... done
[10:33:14.833] Future state: ‘finished’
[10:33:14.833] result() for ClusterFuture ...
[10:33:14.833] - result already collected: FutureResult
[10:33:14.833] result() for ClusterFuture ... done
[10:33:14.833] signalConditions() ...
[10:33:14.833]  - include = ‘condition’
[10:33:14.834]  - exclude = ‘immediateCondition’
[10:33:14.834]  - resignal = TRUE
[10:33:14.834]  - Number of conditions: 1
[10:33:14.834]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:33:14.834] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.3"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "29"
  .. .. .. .. ..$ svn rev       : chr "86002"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.3 (2024-02-29)"
  .. .. .. .. ..$ nickname      : chr "Angel Food Cake"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "c3bfbccbe859" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 10:33:14"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:14.848] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:14.848] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:14.848] 
[10:33:14.848] Searching for globals ... DONE
[10:33:14.849] - globals: [0] <none>
[10:33:14.849] getGlobalsAndPackages() ... DONE
[10:33:14.849] run() for ‘Future’ ...
[10:33:14.849] - state: ‘created’
[10:33:14.849] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:14.863] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:14.863] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:14.863]   - Field: ‘node’
[10:33:14.863]   - Field: ‘label’
[10:33:14.863]   - Field: ‘local’
[10:33:14.864]   - Field: ‘owner’
[10:33:14.864]   - Field: ‘envir’
[10:33:14.864]   - Field: ‘workers’
[10:33:14.864]   - Field: ‘packages’
[10:33:14.864]   - Field: ‘gc’
[10:33:14.864]   - Field: ‘conditions’
[10:33:14.864]   - Field: ‘persistent’
[10:33:14.864]   - Field: ‘expr’
[10:33:14.864]   - Field: ‘uuid’
[10:33:14.864]   - Field: ‘seed’
[10:33:14.864]   - Field: ‘version’
[10:33:14.865]   - Field: ‘result’
[10:33:14.865]   - Field: ‘asynchronous’
[10:33:14.865]   - Field: ‘calls’
[10:33:14.865]   - Field: ‘globals’
[10:33:14.865]   - Field: ‘stdout’
[10:33:14.865]   - Field: ‘earlySignal’
[10:33:14.865]   - Field: ‘lazy’
[10:33:14.865]   - Field: ‘state’
[10:33:14.865] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:14.865] - Launch lazy future ...
[10:33:14.866] Packages needed by the future expression (n = 0): <none>
[10:33:14.866] Packages needed by future strategies (n = 0): <none>
[10:33:14.866] {
[10:33:14.866]     {
[10:33:14.866]         {
[10:33:14.866]             ...future.startTime <- base::Sys.time()
[10:33:14.866]             {
[10:33:14.866]                 {
[10:33:14.866]                   {
[10:33:14.866]                     {
[10:33:14.866]                       base::local({
[10:33:14.866]                         has_future <- base::requireNamespace("future", 
[10:33:14.866]                           quietly = TRUE)
[10:33:14.866]                         if (has_future) {
[10:33:14.866]                           ns <- base::getNamespace("future")
[10:33:14.866]                           version <- ns[[".package"]][["version"]]
[10:33:14.866]                           if (is.null(version)) 
[10:33:14.866]                             version <- utils::packageVersion("future")
[10:33:14.866]                         }
[10:33:14.866]                         else {
[10:33:14.866]                           version <- NULL
[10:33:14.866]                         }
[10:33:14.866]                         if (!has_future || version < "1.8.0") {
[10:33:14.866]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:14.866]                             "", base::R.version$version.string), 
[10:33:14.866]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:14.866]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:14.866]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:14.866]                               "release", "version")], collapse = " "), 
[10:33:14.866]                             hostname = base::Sys.info()[["nodename"]])
[10:33:14.866]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:14.866]                             info)
[10:33:14.866]                           info <- base::paste(info, collapse = "; ")
[10:33:14.866]                           if (!has_future) {
[10:33:14.866]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:14.866]                               info)
[10:33:14.866]                           }
[10:33:14.866]                           else {
[10:33:14.866]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:14.866]                               info, version)
[10:33:14.866]                           }
[10:33:14.866]                           base::stop(msg)
[10:33:14.866]                         }
[10:33:14.866]                       })
[10:33:14.866]                     }
[10:33:14.866]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:14.866]                     base::options(mc.cores = 1L)
[10:33:14.866]                   }
[10:33:14.866]                   ...future.strategy.old <- future::plan("list")
[10:33:14.866]                   options(future.plan = NULL)
[10:33:14.866]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:14.866]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:14.866]                 }
[10:33:14.866]                 ...future.workdir <- getwd()
[10:33:14.866]             }
[10:33:14.866]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:14.866]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:14.866]         }
[10:33:14.866]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:14.866]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:14.866]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:14.866]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:14.866]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:14.866]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:14.866]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:14.866]             base::names(...future.oldOptions))
[10:33:14.866]     }
[10:33:14.866]     if (FALSE) {
[10:33:14.866]     }
[10:33:14.866]     else {
[10:33:14.866]         if (TRUE) {
[10:33:14.866]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:14.866]                 open = "w")
[10:33:14.866]         }
[10:33:14.866]         else {
[10:33:14.866]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:14.866]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:14.866]         }
[10:33:14.866]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:14.866]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:14.866]             base::sink(type = "output", split = FALSE)
[10:33:14.866]             base::close(...future.stdout)
[10:33:14.866]         }, add = TRUE)
[10:33:14.866]     }
[10:33:14.866]     ...future.frame <- base::sys.nframe()
[10:33:14.866]     ...future.conditions <- base::list()
[10:33:14.866]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:14.866]     if (FALSE) {
[10:33:14.866]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:14.866]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:14.866]     }
[10:33:14.866]     ...future.result <- base::tryCatch({
[10:33:14.866]         base::withCallingHandlers({
[10:33:14.866]             ...future.value <- base::withVisible(base::local({
[10:33:14.866]                 ...future.makeSendCondition <- base::local({
[10:33:14.866]                   sendCondition <- NULL
[10:33:14.866]                   function(frame = 1L) {
[10:33:14.866]                     if (is.function(sendCondition)) 
[10:33:14.866]                       return(sendCondition)
[10:33:14.866]                     ns <- getNamespace("parallel")
[10:33:14.866]                     if (exists("sendData", mode = "function", 
[10:33:14.866]                       envir = ns)) {
[10:33:14.866]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:14.866]                         envir = ns)
[10:33:14.866]                       envir <- sys.frame(frame)
[10:33:14.866]                       master <- NULL
[10:33:14.866]                       while (!identical(envir, .GlobalEnv) && 
[10:33:14.866]                         !identical(envir, emptyenv())) {
[10:33:14.866]                         if (exists("master", mode = "list", envir = envir, 
[10:33:14.866]                           inherits = FALSE)) {
[10:33:14.866]                           master <- get("master", mode = "list", 
[10:33:14.866]                             envir = envir, inherits = FALSE)
[10:33:14.866]                           if (inherits(master, c("SOCKnode", 
[10:33:14.866]                             "SOCK0node"))) {
[10:33:14.866]                             sendCondition <<- function(cond) {
[10:33:14.866]                               data <- list(type = "VALUE", value = cond, 
[10:33:14.866]                                 success = TRUE)
[10:33:14.866]                               parallel_sendData(master, data)
[10:33:14.866]                             }
[10:33:14.866]                             return(sendCondition)
[10:33:14.866]                           }
[10:33:14.866]                         }
[10:33:14.866]                         frame <- frame + 1L
[10:33:14.866]                         envir <- sys.frame(frame)
[10:33:14.866]                       }
[10:33:14.866]                     }
[10:33:14.866]                     sendCondition <<- function(cond) NULL
[10:33:14.866]                   }
[10:33:14.866]                 })
[10:33:14.866]                 withCallingHandlers({
[10:33:14.866]                   1
[10:33:14.866]                 }, immediateCondition = function(cond) {
[10:33:14.866]                   sendCondition <- ...future.makeSendCondition()
[10:33:14.866]                   sendCondition(cond)
[10:33:14.866]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.866]                   {
[10:33:14.866]                     inherits <- base::inherits
[10:33:14.866]                     invokeRestart <- base::invokeRestart
[10:33:14.866]                     is.null <- base::is.null
[10:33:14.866]                     muffled <- FALSE
[10:33:14.866]                     if (inherits(cond, "message")) {
[10:33:14.866]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:14.866]                       if (muffled) 
[10:33:14.866]                         invokeRestart("muffleMessage")
[10:33:14.866]                     }
[10:33:14.866]                     else if (inherits(cond, "warning")) {
[10:33:14.866]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:14.866]                       if (muffled) 
[10:33:14.866]                         invokeRestart("muffleWarning")
[10:33:14.866]                     }
[10:33:14.866]                     else if (inherits(cond, "condition")) {
[10:33:14.866]                       if (!is.null(pattern)) {
[10:33:14.866]                         computeRestarts <- base::computeRestarts
[10:33:14.866]                         grepl <- base::grepl
[10:33:14.866]                         restarts <- computeRestarts(cond)
[10:33:14.866]                         for (restart in restarts) {
[10:33:14.866]                           name <- restart$name
[10:33:14.866]                           if (is.null(name)) 
[10:33:14.866]                             next
[10:33:14.866]                           if (!grepl(pattern, name)) 
[10:33:14.866]                             next
[10:33:14.866]                           invokeRestart(restart)
[10:33:14.866]                           muffled <- TRUE
[10:33:14.866]                           break
[10:33:14.866]                         }
[10:33:14.866]                       }
[10:33:14.866]                     }
[10:33:14.866]                     invisible(muffled)
[10:33:14.866]                   }
[10:33:14.866]                   muffleCondition(cond)
[10:33:14.866]                 })
[10:33:14.866]             }))
[10:33:14.866]             future::FutureResult(value = ...future.value$value, 
[10:33:14.866]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:14.866]                   ...future.rng), globalenv = if (FALSE) 
[10:33:14.866]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:14.866]                     ...future.globalenv.names))
[10:33:14.866]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:14.866]         }, condition = base::local({
[10:33:14.866]             c <- base::c
[10:33:14.866]             inherits <- base::inherits
[10:33:14.866]             invokeRestart <- base::invokeRestart
[10:33:14.866]             length <- base::length
[10:33:14.866]             list <- base::list
[10:33:14.866]             seq.int <- base::seq.int
[10:33:14.866]             signalCondition <- base::signalCondition
[10:33:14.866]             sys.calls <- base::sys.calls
[10:33:14.866]             `[[` <- base::`[[`
[10:33:14.866]             `+` <- base::`+`
[10:33:14.866]             `<<-` <- base::`<<-`
[10:33:14.866]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:14.866]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:14.866]                   3L)]
[10:33:14.866]             }
[10:33:14.866]             function(cond) {
[10:33:14.866]                 is_error <- inherits(cond, "error")
[10:33:14.866]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:14.866]                   NULL)
[10:33:14.866]                 if (is_error) {
[10:33:14.866]                   sessionInformation <- function() {
[10:33:14.866]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:14.866]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:14.866]                       search = base::search(), system = base::Sys.info())
[10:33:14.866]                   }
[10:33:14.866]                   ...future.conditions[[length(...future.conditions) + 
[10:33:14.866]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:14.866]                     cond$call), session = sessionInformation(), 
[10:33:14.866]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:14.866]                   signalCondition(cond)
[10:33:14.866]                 }
[10:33:14.866]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:14.866]                 "immediateCondition"))) {
[10:33:14.866]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:14.866]                   ...future.conditions[[length(...future.conditions) + 
[10:33:14.866]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:14.866]                   if (TRUE && !signal) {
[10:33:14.866]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.866]                     {
[10:33:14.866]                       inherits <- base::inherits
[10:33:14.866]                       invokeRestart <- base::invokeRestart
[10:33:14.866]                       is.null <- base::is.null
[10:33:14.866]                       muffled <- FALSE
[10:33:14.866]                       if (inherits(cond, "message")) {
[10:33:14.866]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:14.866]                         if (muffled) 
[10:33:14.866]                           invokeRestart("muffleMessage")
[10:33:14.866]                       }
[10:33:14.866]                       else if (inherits(cond, "warning")) {
[10:33:14.866]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:14.866]                         if (muffled) 
[10:33:14.866]                           invokeRestart("muffleWarning")
[10:33:14.866]                       }
[10:33:14.866]                       else if (inherits(cond, "condition")) {
[10:33:14.866]                         if (!is.null(pattern)) {
[10:33:14.866]                           computeRestarts <- base::computeRestarts
[10:33:14.866]                           grepl <- base::grepl
[10:33:14.866]                           restarts <- computeRestarts(cond)
[10:33:14.866]                           for (restart in restarts) {
[10:33:14.866]                             name <- restart$name
[10:33:14.866]                             if (is.null(name)) 
[10:33:14.866]                               next
[10:33:14.866]                             if (!grepl(pattern, name)) 
[10:33:14.866]                               next
[10:33:14.866]                             invokeRestart(restart)
[10:33:14.866]                             muffled <- TRUE
[10:33:14.866]                             break
[10:33:14.866]                           }
[10:33:14.866]                         }
[10:33:14.866]                       }
[10:33:14.866]                       invisible(muffled)
[10:33:14.866]                     }
[10:33:14.866]                     muffleCondition(cond, pattern = "^muffle")
[10:33:14.866]                   }
[10:33:14.866]                 }
[10:33:14.866]                 else {
[10:33:14.866]                   if (TRUE) {
[10:33:14.866]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.866]                     {
[10:33:14.866]                       inherits <- base::inherits
[10:33:14.866]                       invokeRestart <- base::invokeRestart
[10:33:14.866]                       is.null <- base::is.null
[10:33:14.866]                       muffled <- FALSE
[10:33:14.866]                       if (inherits(cond, "message")) {
[10:33:14.866]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:14.866]                         if (muffled) 
[10:33:14.866]                           invokeRestart("muffleMessage")
[10:33:14.866]                       }
[10:33:14.866]                       else if (inherits(cond, "warning")) {
[10:33:14.866]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:14.866]                         if (muffled) 
[10:33:14.866]                           invokeRestart("muffleWarning")
[10:33:14.866]                       }
[10:33:14.866]                       else if (inherits(cond, "condition")) {
[10:33:14.866]                         if (!is.null(pattern)) {
[10:33:14.866]                           computeRestarts <- base::computeRestarts
[10:33:14.866]                           grepl <- base::grepl
[10:33:14.866]                           restarts <- computeRestarts(cond)
[10:33:14.866]                           for (restart in restarts) {
[10:33:14.866]                             name <- restart$name
[10:33:14.866]                             if (is.null(name)) 
[10:33:14.866]                               next
[10:33:14.866]                             if (!grepl(pattern, name)) 
[10:33:14.866]                               next
[10:33:14.866]                             invokeRestart(restart)
[10:33:14.866]                             muffled <- TRUE
[10:33:14.866]                             break
[10:33:14.866]                           }
[10:33:14.866]                         }
[10:33:14.866]                       }
[10:33:14.866]                       invisible(muffled)
[10:33:14.866]                     }
[10:33:14.866]                     muffleCondition(cond, pattern = "^muffle")
[10:33:14.866]                   }
[10:33:14.866]                 }
[10:33:14.866]             }
[10:33:14.866]         }))
[10:33:14.866]     }, error = function(ex) {
[10:33:14.866]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:14.866]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:14.866]                 ...future.rng), started = ...future.startTime, 
[10:33:14.866]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:14.866]             version = "1.8"), class = "FutureResult")
[10:33:14.866]     }, finally = {
[10:33:14.866]         if (!identical(...future.workdir, getwd())) 
[10:33:14.866]             setwd(...future.workdir)
[10:33:14.866]         {
[10:33:14.866]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:14.866]                 ...future.oldOptions$nwarnings <- NULL
[10:33:14.866]             }
[10:33:14.866]             base::options(...future.oldOptions)
[10:33:14.866]             if (.Platform$OS.type == "windows") {
[10:33:14.866]                 old_names <- names(...future.oldEnvVars)
[10:33:14.866]                 envs <- base::Sys.getenv()
[10:33:14.866]                 names <- names(envs)
[10:33:14.866]                 common <- intersect(names, old_names)
[10:33:14.866]                 added <- setdiff(names, old_names)
[10:33:14.866]                 removed <- setdiff(old_names, names)
[10:33:14.866]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:14.866]                   envs[common]]
[10:33:14.866]                 NAMES <- toupper(changed)
[10:33:14.866]                 args <- list()
[10:33:14.866]                 for (kk in seq_along(NAMES)) {
[10:33:14.866]                   name <- changed[[kk]]
[10:33:14.866]                   NAME <- NAMES[[kk]]
[10:33:14.866]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.866]                     next
[10:33:14.866]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:14.866]                 }
[10:33:14.866]                 NAMES <- toupper(added)
[10:33:14.866]                 for (kk in seq_along(NAMES)) {
[10:33:14.866]                   name <- added[[kk]]
[10:33:14.866]                   NAME <- NAMES[[kk]]
[10:33:14.866]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.866]                     next
[10:33:14.866]                   args[[name]] <- ""
[10:33:14.866]                 }
[10:33:14.866]                 NAMES <- toupper(removed)
[10:33:14.866]                 for (kk in seq_along(NAMES)) {
[10:33:14.866]                   name <- removed[[kk]]
[10:33:14.866]                   NAME <- NAMES[[kk]]
[10:33:14.866]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.866]                     next
[10:33:14.866]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:14.866]                 }
[10:33:14.866]                 if (length(args) > 0) 
[10:33:14.866]                   base::do.call(base::Sys.setenv, args = args)
[10:33:14.866]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:14.866]             }
[10:33:14.866]             else {
[10:33:14.866]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:14.866]             }
[10:33:14.866]             {
[10:33:14.866]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:14.866]                   0L) {
[10:33:14.866]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:14.866]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:14.866]                   base::options(opts)
[10:33:14.866]                 }
[10:33:14.866]                 {
[10:33:14.866]                   {
[10:33:14.866]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:14.866]                     NULL
[10:33:14.866]                   }
[10:33:14.866]                   options(future.plan = NULL)
[10:33:14.866]                   if (is.na(NA_character_)) 
[10:33:14.866]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:14.866]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:14.866]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:14.866]                     .init = FALSE)
[10:33:14.866]                 }
[10:33:14.866]             }
[10:33:14.866]         }
[10:33:14.866]     })
[10:33:14.866]     if (TRUE) {
[10:33:14.866]         base::sink(type = "output", split = FALSE)
[10:33:14.866]         if (TRUE) {
[10:33:14.866]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:14.866]         }
[10:33:14.866]         else {
[10:33:14.866]             ...future.result["stdout"] <- base::list(NULL)
[10:33:14.866]         }
[10:33:14.866]         base::close(...future.stdout)
[10:33:14.866]         ...future.stdout <- NULL
[10:33:14.866]     }
[10:33:14.866]     ...future.result$conditions <- ...future.conditions
[10:33:14.866]     ...future.result$finished <- base::Sys.time()
[10:33:14.866]     ...future.result
[10:33:14.866] }
[10:33:14.869] MultisessionFuture started
[10:33:14.869] - Launch lazy future ... done
[10:33:14.869] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:14.870] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:14.870] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:14.871] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:14.871] Searching for globals ... DONE
[10:33:14.871] Resolving globals: TRUE
[10:33:14.871] Resolving any globals that are futures ...
[10:33:14.871] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:14.871] Resolving any globals that are futures ... DONE
[10:33:14.872] Resolving futures part of globals (recursively) ...
[10:33:14.872] resolve() on list ...
[10:33:14.872]  recursive: 99
[10:33:14.872]  length: 1
[10:33:14.872]  elements: ‘a’
[10:33:14.873] receiveMessageFromWorker() for ClusterFuture ...
[10:33:14.873] - Validating connection of MultisessionFuture
[10:33:14.873] - received message: FutureResult
[10:33:14.873] - Received FutureResult
[10:33:14.873] - Erased future from FutureRegistry
[10:33:14.873] result() for ClusterFuture ...
[10:33:14.873] - result already collected: FutureResult
[10:33:14.873] result() for ClusterFuture ... done
[10:33:14.873] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:14.874] Future #1
[10:33:14.874] result() for ClusterFuture ...
[10:33:14.874] - result already collected: FutureResult
[10:33:14.874] result() for ClusterFuture ... done
[10:33:14.874] result() for ClusterFuture ...
[10:33:14.874] - result already collected: FutureResult
[10:33:14.874] result() for ClusterFuture ... done
[10:33:14.874] A MultisessionFuture was resolved
[10:33:14.874]  length: 0 (resolved future 1)
[10:33:14.874] resolve() on list ... DONE
[10:33:14.874] - globals: [1] ‘a’
[10:33:14.875] Resolving futures part of globals (recursively) ... DONE
[10:33:14.875] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[10:33:14.876] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[10:33:14.876] - globals: [1] ‘a’
[10:33:14.876] - packages: [1] ‘future’
[10:33:14.876] getGlobalsAndPackages() ... DONE
[10:33:14.876] run() for ‘Future’ ...
[10:33:14.877] - state: ‘created’
[10:33:14.877] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:14.890] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:14.890] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:14.890]   - Field: ‘node’
[10:33:14.891]   - Field: ‘label’
[10:33:14.891]   - Field: ‘local’
[10:33:14.891]   - Field: ‘owner’
[10:33:14.891]   - Field: ‘envir’
[10:33:14.891]   - Field: ‘workers’
[10:33:14.891]   - Field: ‘packages’
[10:33:14.891]   - Field: ‘gc’
[10:33:14.891]   - Field: ‘conditions’
[10:33:14.891]   - Field: ‘persistent’
[10:33:14.891]   - Field: ‘expr’
[10:33:14.891]   - Field: ‘uuid’
[10:33:14.892]   - Field: ‘seed’
[10:33:14.892]   - Field: ‘version’
[10:33:14.893]   - Field: ‘result’
[10:33:14.894]   - Field: ‘asynchronous’
[10:33:14.894]   - Field: ‘calls’
[10:33:14.894]   - Field: ‘globals’
[10:33:14.894]   - Field: ‘stdout’
[10:33:14.894]   - Field: ‘earlySignal’
[10:33:14.894]   - Field: ‘lazy’
[10:33:14.894]   - Field: ‘state’
[10:33:14.894] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:14.894] - Launch lazy future ...
[10:33:14.895] Packages needed by the future expression (n = 1): ‘future’
[10:33:14.895] Packages needed by future strategies (n = 0): <none>
[10:33:14.895] {
[10:33:14.895]     {
[10:33:14.895]         {
[10:33:14.895]             ...future.startTime <- base::Sys.time()
[10:33:14.895]             {
[10:33:14.895]                 {
[10:33:14.895]                   {
[10:33:14.895]                     {
[10:33:14.895]                       {
[10:33:14.895]                         base::local({
[10:33:14.895]                           has_future <- base::requireNamespace("future", 
[10:33:14.895]                             quietly = TRUE)
[10:33:14.895]                           if (has_future) {
[10:33:14.895]                             ns <- base::getNamespace("future")
[10:33:14.895]                             version <- ns[[".package"]][["version"]]
[10:33:14.895]                             if (is.null(version)) 
[10:33:14.895]                               version <- utils::packageVersion("future")
[10:33:14.895]                           }
[10:33:14.895]                           else {
[10:33:14.895]                             version <- NULL
[10:33:14.895]                           }
[10:33:14.895]                           if (!has_future || version < "1.8.0") {
[10:33:14.895]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:14.895]                               "", base::R.version$version.string), 
[10:33:14.895]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:14.895]                                 base::R.version$platform, 8 * 
[10:33:14.895]                                   base::.Machine$sizeof.pointer), 
[10:33:14.895]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:14.895]                                 "release", "version")], collapse = " "), 
[10:33:14.895]                               hostname = base::Sys.info()[["nodename"]])
[10:33:14.895]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:14.895]                               info)
[10:33:14.895]                             info <- base::paste(info, collapse = "; ")
[10:33:14.895]                             if (!has_future) {
[10:33:14.895]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:14.895]                                 info)
[10:33:14.895]                             }
[10:33:14.895]                             else {
[10:33:14.895]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:14.895]                                 info, version)
[10:33:14.895]                             }
[10:33:14.895]                             base::stop(msg)
[10:33:14.895]                           }
[10:33:14.895]                         })
[10:33:14.895]                       }
[10:33:14.895]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:14.895]                       base::options(mc.cores = 1L)
[10:33:14.895]                     }
[10:33:14.895]                     base::local({
[10:33:14.895]                       for (pkg in "future") {
[10:33:14.895]                         base::loadNamespace(pkg)
[10:33:14.895]                         base::library(pkg, character.only = TRUE)
[10:33:14.895]                       }
[10:33:14.895]                     })
[10:33:14.895]                   }
[10:33:14.895]                   ...future.strategy.old <- future::plan("list")
[10:33:14.895]                   options(future.plan = NULL)
[10:33:14.895]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:14.895]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:14.895]                 }
[10:33:14.895]                 ...future.workdir <- getwd()
[10:33:14.895]             }
[10:33:14.895]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:14.895]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:14.895]         }
[10:33:14.895]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:14.895]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:14.895]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:14.895]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:14.895]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:14.895]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:14.895]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:14.895]             base::names(...future.oldOptions))
[10:33:14.895]     }
[10:33:14.895]     if (FALSE) {
[10:33:14.895]     }
[10:33:14.895]     else {
[10:33:14.895]         if (TRUE) {
[10:33:14.895]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:14.895]                 open = "w")
[10:33:14.895]         }
[10:33:14.895]         else {
[10:33:14.895]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:14.895]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:14.895]         }
[10:33:14.895]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:14.895]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:14.895]             base::sink(type = "output", split = FALSE)
[10:33:14.895]             base::close(...future.stdout)
[10:33:14.895]         }, add = TRUE)
[10:33:14.895]     }
[10:33:14.895]     ...future.frame <- base::sys.nframe()
[10:33:14.895]     ...future.conditions <- base::list()
[10:33:14.895]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:14.895]     if (FALSE) {
[10:33:14.895]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:14.895]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:14.895]     }
[10:33:14.895]     ...future.result <- base::tryCatch({
[10:33:14.895]         base::withCallingHandlers({
[10:33:14.895]             ...future.value <- base::withVisible(base::local({
[10:33:14.895]                 ...future.makeSendCondition <- base::local({
[10:33:14.895]                   sendCondition <- NULL
[10:33:14.895]                   function(frame = 1L) {
[10:33:14.895]                     if (is.function(sendCondition)) 
[10:33:14.895]                       return(sendCondition)
[10:33:14.895]                     ns <- getNamespace("parallel")
[10:33:14.895]                     if (exists("sendData", mode = "function", 
[10:33:14.895]                       envir = ns)) {
[10:33:14.895]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:14.895]                         envir = ns)
[10:33:14.895]                       envir <- sys.frame(frame)
[10:33:14.895]                       master <- NULL
[10:33:14.895]                       while (!identical(envir, .GlobalEnv) && 
[10:33:14.895]                         !identical(envir, emptyenv())) {
[10:33:14.895]                         if (exists("master", mode = "list", envir = envir, 
[10:33:14.895]                           inherits = FALSE)) {
[10:33:14.895]                           master <- get("master", mode = "list", 
[10:33:14.895]                             envir = envir, inherits = FALSE)
[10:33:14.895]                           if (inherits(master, c("SOCKnode", 
[10:33:14.895]                             "SOCK0node"))) {
[10:33:14.895]                             sendCondition <<- function(cond) {
[10:33:14.895]                               data <- list(type = "VALUE", value = cond, 
[10:33:14.895]                                 success = TRUE)
[10:33:14.895]                               parallel_sendData(master, data)
[10:33:14.895]                             }
[10:33:14.895]                             return(sendCondition)
[10:33:14.895]                           }
[10:33:14.895]                         }
[10:33:14.895]                         frame <- frame + 1L
[10:33:14.895]                         envir <- sys.frame(frame)
[10:33:14.895]                       }
[10:33:14.895]                     }
[10:33:14.895]                     sendCondition <<- function(cond) NULL
[10:33:14.895]                   }
[10:33:14.895]                 })
[10:33:14.895]                 withCallingHandlers({
[10:33:14.895]                   value(a) + 1
[10:33:14.895]                 }, immediateCondition = function(cond) {
[10:33:14.895]                   sendCondition <- ...future.makeSendCondition()
[10:33:14.895]                   sendCondition(cond)
[10:33:14.895]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.895]                   {
[10:33:14.895]                     inherits <- base::inherits
[10:33:14.895]                     invokeRestart <- base::invokeRestart
[10:33:14.895]                     is.null <- base::is.null
[10:33:14.895]                     muffled <- FALSE
[10:33:14.895]                     if (inherits(cond, "message")) {
[10:33:14.895]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:14.895]                       if (muffled) 
[10:33:14.895]                         invokeRestart("muffleMessage")
[10:33:14.895]                     }
[10:33:14.895]                     else if (inherits(cond, "warning")) {
[10:33:14.895]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:14.895]                       if (muffled) 
[10:33:14.895]                         invokeRestart("muffleWarning")
[10:33:14.895]                     }
[10:33:14.895]                     else if (inherits(cond, "condition")) {
[10:33:14.895]                       if (!is.null(pattern)) {
[10:33:14.895]                         computeRestarts <- base::computeRestarts
[10:33:14.895]                         grepl <- base::grepl
[10:33:14.895]                         restarts <- computeRestarts(cond)
[10:33:14.895]                         for (restart in restarts) {
[10:33:14.895]                           name <- restart$name
[10:33:14.895]                           if (is.null(name)) 
[10:33:14.895]                             next
[10:33:14.895]                           if (!grepl(pattern, name)) 
[10:33:14.895]                             next
[10:33:14.895]                           invokeRestart(restart)
[10:33:14.895]                           muffled <- TRUE
[10:33:14.895]                           break
[10:33:14.895]                         }
[10:33:14.895]                       }
[10:33:14.895]                     }
[10:33:14.895]                     invisible(muffled)
[10:33:14.895]                   }
[10:33:14.895]                   muffleCondition(cond)
[10:33:14.895]                 })
[10:33:14.895]             }))
[10:33:14.895]             future::FutureResult(value = ...future.value$value, 
[10:33:14.895]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:14.895]                   ...future.rng), globalenv = if (FALSE) 
[10:33:14.895]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:14.895]                     ...future.globalenv.names))
[10:33:14.895]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:14.895]         }, condition = base::local({
[10:33:14.895]             c <- base::c
[10:33:14.895]             inherits <- base::inherits
[10:33:14.895]             invokeRestart <- base::invokeRestart
[10:33:14.895]             length <- base::length
[10:33:14.895]             list <- base::list
[10:33:14.895]             seq.int <- base::seq.int
[10:33:14.895]             signalCondition <- base::signalCondition
[10:33:14.895]             sys.calls <- base::sys.calls
[10:33:14.895]             `[[` <- base::`[[`
[10:33:14.895]             `+` <- base::`+`
[10:33:14.895]             `<<-` <- base::`<<-`
[10:33:14.895]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:14.895]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:14.895]                   3L)]
[10:33:14.895]             }
[10:33:14.895]             function(cond) {
[10:33:14.895]                 is_error <- inherits(cond, "error")
[10:33:14.895]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:14.895]                   NULL)
[10:33:14.895]                 if (is_error) {
[10:33:14.895]                   sessionInformation <- function() {
[10:33:14.895]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:14.895]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:14.895]                       search = base::search(), system = base::Sys.info())
[10:33:14.895]                   }
[10:33:14.895]                   ...future.conditions[[length(...future.conditions) + 
[10:33:14.895]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:14.895]                     cond$call), session = sessionInformation(), 
[10:33:14.895]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:14.895]                   signalCondition(cond)
[10:33:14.895]                 }
[10:33:14.895]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:14.895]                 "immediateCondition"))) {
[10:33:14.895]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:14.895]                   ...future.conditions[[length(...future.conditions) + 
[10:33:14.895]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:14.895]                   if (TRUE && !signal) {
[10:33:14.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.895]                     {
[10:33:14.895]                       inherits <- base::inherits
[10:33:14.895]                       invokeRestart <- base::invokeRestart
[10:33:14.895]                       is.null <- base::is.null
[10:33:14.895]                       muffled <- FALSE
[10:33:14.895]                       if (inherits(cond, "message")) {
[10:33:14.895]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:14.895]                         if (muffled) 
[10:33:14.895]                           invokeRestart("muffleMessage")
[10:33:14.895]                       }
[10:33:14.895]                       else if (inherits(cond, "warning")) {
[10:33:14.895]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:14.895]                         if (muffled) 
[10:33:14.895]                           invokeRestart("muffleWarning")
[10:33:14.895]                       }
[10:33:14.895]                       else if (inherits(cond, "condition")) {
[10:33:14.895]                         if (!is.null(pattern)) {
[10:33:14.895]                           computeRestarts <- base::computeRestarts
[10:33:14.895]                           grepl <- base::grepl
[10:33:14.895]                           restarts <- computeRestarts(cond)
[10:33:14.895]                           for (restart in restarts) {
[10:33:14.895]                             name <- restart$name
[10:33:14.895]                             if (is.null(name)) 
[10:33:14.895]                               next
[10:33:14.895]                             if (!grepl(pattern, name)) 
[10:33:14.895]                               next
[10:33:14.895]                             invokeRestart(restart)
[10:33:14.895]                             muffled <- TRUE
[10:33:14.895]                             break
[10:33:14.895]                           }
[10:33:14.895]                         }
[10:33:14.895]                       }
[10:33:14.895]                       invisible(muffled)
[10:33:14.895]                     }
[10:33:14.895]                     muffleCondition(cond, pattern = "^muffle")
[10:33:14.895]                   }
[10:33:14.895]                 }
[10:33:14.895]                 else {
[10:33:14.895]                   if (TRUE) {
[10:33:14.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:14.895]                     {
[10:33:14.895]                       inherits <- base::inherits
[10:33:14.895]                       invokeRestart <- base::invokeRestart
[10:33:14.895]                       is.null <- base::is.null
[10:33:14.895]                       muffled <- FALSE
[10:33:14.895]                       if (inherits(cond, "message")) {
[10:33:14.895]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:14.895]                         if (muffled) 
[10:33:14.895]                           invokeRestart("muffleMessage")
[10:33:14.895]                       }
[10:33:14.895]                       else if (inherits(cond, "warning")) {
[10:33:14.895]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:14.895]                         if (muffled) 
[10:33:14.895]                           invokeRestart("muffleWarning")
[10:33:14.895]                       }
[10:33:14.895]                       else if (inherits(cond, "condition")) {
[10:33:14.895]                         if (!is.null(pattern)) {
[10:33:14.895]                           computeRestarts <- base::computeRestarts
[10:33:14.895]                           grepl <- base::grepl
[10:33:14.895]                           restarts <- computeRestarts(cond)
[10:33:14.895]                           for (restart in restarts) {
[10:33:14.895]                             name <- restart$name
[10:33:14.895]                             if (is.null(name)) 
[10:33:14.895]                               next
[10:33:14.895]                             if (!grepl(pattern, name)) 
[10:33:14.895]                               next
[10:33:14.895]                             invokeRestart(restart)
[10:33:14.895]                             muffled <- TRUE
[10:33:14.895]                             break
[10:33:14.895]                           }
[10:33:14.895]                         }
[10:33:14.895]                       }
[10:33:14.895]                       invisible(muffled)
[10:33:14.895]                     }
[10:33:14.895]                     muffleCondition(cond, pattern = "^muffle")
[10:33:14.895]                   }
[10:33:14.895]                 }
[10:33:14.895]             }
[10:33:14.895]         }))
[10:33:14.895]     }, error = function(ex) {
[10:33:14.895]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:14.895]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:14.895]                 ...future.rng), started = ...future.startTime, 
[10:33:14.895]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:14.895]             version = "1.8"), class = "FutureResult")
[10:33:14.895]     }, finally = {
[10:33:14.895]         if (!identical(...future.workdir, getwd())) 
[10:33:14.895]             setwd(...future.workdir)
[10:33:14.895]         {
[10:33:14.895]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:14.895]                 ...future.oldOptions$nwarnings <- NULL
[10:33:14.895]             }
[10:33:14.895]             base::options(...future.oldOptions)
[10:33:14.895]             if (.Platform$OS.type == "windows") {
[10:33:14.895]                 old_names <- names(...future.oldEnvVars)
[10:33:14.895]                 envs <- base::Sys.getenv()
[10:33:14.895]                 names <- names(envs)
[10:33:14.895]                 common <- intersect(names, old_names)
[10:33:14.895]                 added <- setdiff(names, old_names)
[10:33:14.895]                 removed <- setdiff(old_names, names)
[10:33:14.895]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:14.895]                   envs[common]]
[10:33:14.895]                 NAMES <- toupper(changed)
[10:33:14.895]                 args <- list()
[10:33:14.895]                 for (kk in seq_along(NAMES)) {
[10:33:14.895]                   name <- changed[[kk]]
[10:33:14.895]                   NAME <- NAMES[[kk]]
[10:33:14.895]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.895]                     next
[10:33:14.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:14.895]                 }
[10:33:14.895]                 NAMES <- toupper(added)
[10:33:14.895]                 for (kk in seq_along(NAMES)) {
[10:33:14.895]                   name <- added[[kk]]
[10:33:14.895]                   NAME <- NAMES[[kk]]
[10:33:14.895]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.895]                     next
[10:33:14.895]                   args[[name]] <- ""
[10:33:14.895]                 }
[10:33:14.895]                 NAMES <- toupper(removed)
[10:33:14.895]                 for (kk in seq_along(NAMES)) {
[10:33:14.895]                   name <- removed[[kk]]
[10:33:14.895]                   NAME <- NAMES[[kk]]
[10:33:14.895]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:14.895]                     next
[10:33:14.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:14.895]                 }
[10:33:14.895]                 if (length(args) > 0) 
[10:33:14.895]                   base::do.call(base::Sys.setenv, args = args)
[10:33:14.895]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:14.895]             }
[10:33:14.895]             else {
[10:33:14.895]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:14.895]             }
[10:33:14.895]             {
[10:33:14.895]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:14.895]                   0L) {
[10:33:14.895]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:14.895]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:14.895]                   base::options(opts)
[10:33:14.895]                 }
[10:33:14.895]                 {
[10:33:14.895]                   {
[10:33:14.895]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:14.895]                     NULL
[10:33:14.895]                   }
[10:33:14.895]                   options(future.plan = NULL)
[10:33:14.895]                   if (is.na(NA_character_)) 
[10:33:14.895]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:14.895]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:14.895]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:14.895]                     .init = FALSE)
[10:33:14.895]                 }
[10:33:14.895]             }
[10:33:14.895]         }
[10:33:14.895]     })
[10:33:14.895]     if (TRUE) {
[10:33:14.895]         base::sink(type = "output", split = FALSE)
[10:33:14.895]         if (TRUE) {
[10:33:14.895]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:14.895]         }
[10:33:14.895]         else {
[10:33:14.895]             ...future.result["stdout"] <- base::list(NULL)
[10:33:14.895]         }
[10:33:14.895]         base::close(...future.stdout)
[10:33:14.895]         ...future.stdout <- NULL
[10:33:14.895]     }
[10:33:14.895]     ...future.result$conditions <- ...future.conditions
[10:33:14.895]     ...future.result$finished <- base::Sys.time()
[10:33:14.895]     ...future.result
[10:33:14.895] }
[10:33:14.898] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[10:33:14.898] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[10:33:14.949] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[10:33:14.949] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[10:33:14.950] MultisessionFuture started
[10:33:14.950] - Launch lazy future ... done
[10:33:14.950] run() for ‘MultisessionFuture’ ... done
[10:33:14.950] result() for ClusterFuture ...
[10:33:14.950] receiveMessageFromWorker() for ClusterFuture ...
[10:33:14.950] - Validating connection of MultisessionFuture
[10:33:14.998] - received message: FutureResult
[10:33:14.999] - Received FutureResult
[10:33:14.999] - Erased future from FutureRegistry
[10:33:14.999] result() for ClusterFuture ...
[10:33:14.999] - result already collected: FutureResult
[10:33:14.999] result() for ClusterFuture ... done
[10:33:14.999] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:14.999] result() for ClusterFuture ... done
[10:33:14.999] result() for ClusterFuture ...
[10:33:14.999] - result already collected: FutureResult
[10:33:14.999] result() for ClusterFuture ... done
value(b) = 2
[10:33:15.000] result() for ClusterFuture ...
[10:33:15.000] - result already collected: FutureResult
[10:33:15.000] result() for ClusterFuture ... done
[10:33:15.000] result() for ClusterFuture ...
[10:33:15.000] - result already collected: FutureResult
[10:33:15.000] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:15.000] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:15.000] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:15.001] 
[10:33:15.001] Searching for globals ... DONE
[10:33:15.001] - globals: [0] <none>
[10:33:15.001] getGlobalsAndPackages() ... DONE
[10:33:15.002] run() for ‘Future’ ...
[10:33:15.002] - state: ‘created’
[10:33:15.002] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:15.017] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:15.017] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:15.017]   - Field: ‘node’
[10:33:15.017]   - Field: ‘label’
[10:33:15.017]   - Field: ‘local’
[10:33:15.017]   - Field: ‘owner’
[10:33:15.017]   - Field: ‘envir’
[10:33:15.018]   - Field: ‘workers’
[10:33:15.018]   - Field: ‘packages’
[10:33:15.018]   - Field: ‘gc’
[10:33:15.018]   - Field: ‘conditions’
[10:33:15.018]   - Field: ‘persistent’
[10:33:15.018]   - Field: ‘expr’
[10:33:15.018]   - Field: ‘uuid’
[10:33:15.018]   - Field: ‘seed’
[10:33:15.018]   - Field: ‘version’
[10:33:15.018]   - Field: ‘result’
[10:33:15.018]   - Field: ‘asynchronous’
[10:33:15.019]   - Field: ‘calls’
[10:33:15.019]   - Field: ‘globals’
[10:33:15.019]   - Field: ‘stdout’
[10:33:15.019]   - Field: ‘earlySignal’
[10:33:15.019]   - Field: ‘lazy’
[10:33:15.019]   - Field: ‘state’
[10:33:15.019] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:15.019] - Launch lazy future ...
[10:33:15.019] Packages needed by the future expression (n = 0): <none>
[10:33:15.020] Packages needed by future strategies (n = 0): <none>
[10:33:15.020] {
[10:33:15.020]     {
[10:33:15.020]         {
[10:33:15.020]             ...future.startTime <- base::Sys.time()
[10:33:15.020]             {
[10:33:15.020]                 {
[10:33:15.020]                   {
[10:33:15.020]                     {
[10:33:15.020]                       base::local({
[10:33:15.020]                         has_future <- base::requireNamespace("future", 
[10:33:15.020]                           quietly = TRUE)
[10:33:15.020]                         if (has_future) {
[10:33:15.020]                           ns <- base::getNamespace("future")
[10:33:15.020]                           version <- ns[[".package"]][["version"]]
[10:33:15.020]                           if (is.null(version)) 
[10:33:15.020]                             version <- utils::packageVersion("future")
[10:33:15.020]                         }
[10:33:15.020]                         else {
[10:33:15.020]                           version <- NULL
[10:33:15.020]                         }
[10:33:15.020]                         if (!has_future || version < "1.8.0") {
[10:33:15.020]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:15.020]                             "", base::R.version$version.string), 
[10:33:15.020]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:15.020]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:15.020]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:15.020]                               "release", "version")], collapse = " "), 
[10:33:15.020]                             hostname = base::Sys.info()[["nodename"]])
[10:33:15.020]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:15.020]                             info)
[10:33:15.020]                           info <- base::paste(info, collapse = "; ")
[10:33:15.020]                           if (!has_future) {
[10:33:15.020]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:15.020]                               info)
[10:33:15.020]                           }
[10:33:15.020]                           else {
[10:33:15.020]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:15.020]                               info, version)
[10:33:15.020]                           }
[10:33:15.020]                           base::stop(msg)
[10:33:15.020]                         }
[10:33:15.020]                       })
[10:33:15.020]                     }
[10:33:15.020]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:15.020]                     base::options(mc.cores = 1L)
[10:33:15.020]                   }
[10:33:15.020]                   ...future.strategy.old <- future::plan("list")
[10:33:15.020]                   options(future.plan = NULL)
[10:33:15.020]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.020]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:15.020]                 }
[10:33:15.020]                 ...future.workdir <- getwd()
[10:33:15.020]             }
[10:33:15.020]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:15.020]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:15.020]         }
[10:33:15.020]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:15.020]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:15.020]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:15.020]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:15.020]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:15.020]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:15.020]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:15.020]             base::names(...future.oldOptions))
[10:33:15.020]     }
[10:33:15.020]     if (FALSE) {
[10:33:15.020]     }
[10:33:15.020]     else {
[10:33:15.020]         if (TRUE) {
[10:33:15.020]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:15.020]                 open = "w")
[10:33:15.020]         }
[10:33:15.020]         else {
[10:33:15.020]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:15.020]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:15.020]         }
[10:33:15.020]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:15.020]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:15.020]             base::sink(type = "output", split = FALSE)
[10:33:15.020]             base::close(...future.stdout)
[10:33:15.020]         }, add = TRUE)
[10:33:15.020]     }
[10:33:15.020]     ...future.frame <- base::sys.nframe()
[10:33:15.020]     ...future.conditions <- base::list()
[10:33:15.020]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:15.020]     if (FALSE) {
[10:33:15.020]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:15.020]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:15.020]     }
[10:33:15.020]     ...future.result <- base::tryCatch({
[10:33:15.020]         base::withCallingHandlers({
[10:33:15.020]             ...future.value <- base::withVisible(base::local({
[10:33:15.020]                 ...future.makeSendCondition <- base::local({
[10:33:15.020]                   sendCondition <- NULL
[10:33:15.020]                   function(frame = 1L) {
[10:33:15.020]                     if (is.function(sendCondition)) 
[10:33:15.020]                       return(sendCondition)
[10:33:15.020]                     ns <- getNamespace("parallel")
[10:33:15.020]                     if (exists("sendData", mode = "function", 
[10:33:15.020]                       envir = ns)) {
[10:33:15.020]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:15.020]                         envir = ns)
[10:33:15.020]                       envir <- sys.frame(frame)
[10:33:15.020]                       master <- NULL
[10:33:15.020]                       while (!identical(envir, .GlobalEnv) && 
[10:33:15.020]                         !identical(envir, emptyenv())) {
[10:33:15.020]                         if (exists("master", mode = "list", envir = envir, 
[10:33:15.020]                           inherits = FALSE)) {
[10:33:15.020]                           master <- get("master", mode = "list", 
[10:33:15.020]                             envir = envir, inherits = FALSE)
[10:33:15.020]                           if (inherits(master, c("SOCKnode", 
[10:33:15.020]                             "SOCK0node"))) {
[10:33:15.020]                             sendCondition <<- function(cond) {
[10:33:15.020]                               data <- list(type = "VALUE", value = cond, 
[10:33:15.020]                                 success = TRUE)
[10:33:15.020]                               parallel_sendData(master, data)
[10:33:15.020]                             }
[10:33:15.020]                             return(sendCondition)
[10:33:15.020]                           }
[10:33:15.020]                         }
[10:33:15.020]                         frame <- frame + 1L
[10:33:15.020]                         envir <- sys.frame(frame)
[10:33:15.020]                       }
[10:33:15.020]                     }
[10:33:15.020]                     sendCondition <<- function(cond) NULL
[10:33:15.020]                   }
[10:33:15.020]                 })
[10:33:15.020]                 withCallingHandlers({
[10:33:15.020]                   1
[10:33:15.020]                 }, immediateCondition = function(cond) {
[10:33:15.020]                   sendCondition <- ...future.makeSendCondition()
[10:33:15.020]                   sendCondition(cond)
[10:33:15.020]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.020]                   {
[10:33:15.020]                     inherits <- base::inherits
[10:33:15.020]                     invokeRestart <- base::invokeRestart
[10:33:15.020]                     is.null <- base::is.null
[10:33:15.020]                     muffled <- FALSE
[10:33:15.020]                     if (inherits(cond, "message")) {
[10:33:15.020]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:15.020]                       if (muffled) 
[10:33:15.020]                         invokeRestart("muffleMessage")
[10:33:15.020]                     }
[10:33:15.020]                     else if (inherits(cond, "warning")) {
[10:33:15.020]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:15.020]                       if (muffled) 
[10:33:15.020]                         invokeRestart("muffleWarning")
[10:33:15.020]                     }
[10:33:15.020]                     else if (inherits(cond, "condition")) {
[10:33:15.020]                       if (!is.null(pattern)) {
[10:33:15.020]                         computeRestarts <- base::computeRestarts
[10:33:15.020]                         grepl <- base::grepl
[10:33:15.020]                         restarts <- computeRestarts(cond)
[10:33:15.020]                         for (restart in restarts) {
[10:33:15.020]                           name <- restart$name
[10:33:15.020]                           if (is.null(name)) 
[10:33:15.020]                             next
[10:33:15.020]                           if (!grepl(pattern, name)) 
[10:33:15.020]                             next
[10:33:15.020]                           invokeRestart(restart)
[10:33:15.020]                           muffled <- TRUE
[10:33:15.020]                           break
[10:33:15.020]                         }
[10:33:15.020]                       }
[10:33:15.020]                     }
[10:33:15.020]                     invisible(muffled)
[10:33:15.020]                   }
[10:33:15.020]                   muffleCondition(cond)
[10:33:15.020]                 })
[10:33:15.020]             }))
[10:33:15.020]             future::FutureResult(value = ...future.value$value, 
[10:33:15.020]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.020]                   ...future.rng), globalenv = if (FALSE) 
[10:33:15.020]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:15.020]                     ...future.globalenv.names))
[10:33:15.020]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:15.020]         }, condition = base::local({
[10:33:15.020]             c <- base::c
[10:33:15.020]             inherits <- base::inherits
[10:33:15.020]             invokeRestart <- base::invokeRestart
[10:33:15.020]             length <- base::length
[10:33:15.020]             list <- base::list
[10:33:15.020]             seq.int <- base::seq.int
[10:33:15.020]             signalCondition <- base::signalCondition
[10:33:15.020]             sys.calls <- base::sys.calls
[10:33:15.020]             `[[` <- base::`[[`
[10:33:15.020]             `+` <- base::`+`
[10:33:15.020]             `<<-` <- base::`<<-`
[10:33:15.020]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:15.020]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:15.020]                   3L)]
[10:33:15.020]             }
[10:33:15.020]             function(cond) {
[10:33:15.020]                 is_error <- inherits(cond, "error")
[10:33:15.020]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:15.020]                   NULL)
[10:33:15.020]                 if (is_error) {
[10:33:15.020]                   sessionInformation <- function() {
[10:33:15.020]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:15.020]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:15.020]                       search = base::search(), system = base::Sys.info())
[10:33:15.020]                   }
[10:33:15.020]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.020]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:15.020]                     cond$call), session = sessionInformation(), 
[10:33:15.020]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:15.020]                   signalCondition(cond)
[10:33:15.020]                 }
[10:33:15.020]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:15.020]                 "immediateCondition"))) {
[10:33:15.020]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:15.020]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.020]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:15.020]                   if (TRUE && !signal) {
[10:33:15.020]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.020]                     {
[10:33:15.020]                       inherits <- base::inherits
[10:33:15.020]                       invokeRestart <- base::invokeRestart
[10:33:15.020]                       is.null <- base::is.null
[10:33:15.020]                       muffled <- FALSE
[10:33:15.020]                       if (inherits(cond, "message")) {
[10:33:15.020]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.020]                         if (muffled) 
[10:33:15.020]                           invokeRestart("muffleMessage")
[10:33:15.020]                       }
[10:33:15.020]                       else if (inherits(cond, "warning")) {
[10:33:15.020]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.020]                         if (muffled) 
[10:33:15.020]                           invokeRestart("muffleWarning")
[10:33:15.020]                       }
[10:33:15.020]                       else if (inherits(cond, "condition")) {
[10:33:15.020]                         if (!is.null(pattern)) {
[10:33:15.020]                           computeRestarts <- base::computeRestarts
[10:33:15.020]                           grepl <- base::grepl
[10:33:15.020]                           restarts <- computeRestarts(cond)
[10:33:15.020]                           for (restart in restarts) {
[10:33:15.020]                             name <- restart$name
[10:33:15.020]                             if (is.null(name)) 
[10:33:15.020]                               next
[10:33:15.020]                             if (!grepl(pattern, name)) 
[10:33:15.020]                               next
[10:33:15.020]                             invokeRestart(restart)
[10:33:15.020]                             muffled <- TRUE
[10:33:15.020]                             break
[10:33:15.020]                           }
[10:33:15.020]                         }
[10:33:15.020]                       }
[10:33:15.020]                       invisible(muffled)
[10:33:15.020]                     }
[10:33:15.020]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.020]                   }
[10:33:15.020]                 }
[10:33:15.020]                 else {
[10:33:15.020]                   if (TRUE) {
[10:33:15.020]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.020]                     {
[10:33:15.020]                       inherits <- base::inherits
[10:33:15.020]                       invokeRestart <- base::invokeRestart
[10:33:15.020]                       is.null <- base::is.null
[10:33:15.020]                       muffled <- FALSE
[10:33:15.020]                       if (inherits(cond, "message")) {
[10:33:15.020]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.020]                         if (muffled) 
[10:33:15.020]                           invokeRestart("muffleMessage")
[10:33:15.020]                       }
[10:33:15.020]                       else if (inherits(cond, "warning")) {
[10:33:15.020]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.020]                         if (muffled) 
[10:33:15.020]                           invokeRestart("muffleWarning")
[10:33:15.020]                       }
[10:33:15.020]                       else if (inherits(cond, "condition")) {
[10:33:15.020]                         if (!is.null(pattern)) {
[10:33:15.020]                           computeRestarts <- base::computeRestarts
[10:33:15.020]                           grepl <- base::grepl
[10:33:15.020]                           restarts <- computeRestarts(cond)
[10:33:15.020]                           for (restart in restarts) {
[10:33:15.020]                             name <- restart$name
[10:33:15.020]                             if (is.null(name)) 
[10:33:15.020]                               next
[10:33:15.020]                             if (!grepl(pattern, name)) 
[10:33:15.020]                               next
[10:33:15.020]                             invokeRestart(restart)
[10:33:15.020]                             muffled <- TRUE
[10:33:15.020]                             break
[10:33:15.020]                           }
[10:33:15.020]                         }
[10:33:15.020]                       }
[10:33:15.020]                       invisible(muffled)
[10:33:15.020]                     }
[10:33:15.020]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.020]                   }
[10:33:15.020]                 }
[10:33:15.020]             }
[10:33:15.020]         }))
[10:33:15.020]     }, error = function(ex) {
[10:33:15.020]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:15.020]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.020]                 ...future.rng), started = ...future.startTime, 
[10:33:15.020]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:15.020]             version = "1.8"), class = "FutureResult")
[10:33:15.020]     }, finally = {
[10:33:15.020]         if (!identical(...future.workdir, getwd())) 
[10:33:15.020]             setwd(...future.workdir)
[10:33:15.020]         {
[10:33:15.020]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:15.020]                 ...future.oldOptions$nwarnings <- NULL
[10:33:15.020]             }
[10:33:15.020]             base::options(...future.oldOptions)
[10:33:15.020]             if (.Platform$OS.type == "windows") {
[10:33:15.020]                 old_names <- names(...future.oldEnvVars)
[10:33:15.020]                 envs <- base::Sys.getenv()
[10:33:15.020]                 names <- names(envs)
[10:33:15.020]                 common <- intersect(names, old_names)
[10:33:15.020]                 added <- setdiff(names, old_names)
[10:33:15.020]                 removed <- setdiff(old_names, names)
[10:33:15.020]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:15.020]                   envs[common]]
[10:33:15.020]                 NAMES <- toupper(changed)
[10:33:15.020]                 args <- list()
[10:33:15.020]                 for (kk in seq_along(NAMES)) {
[10:33:15.020]                   name <- changed[[kk]]
[10:33:15.020]                   NAME <- NAMES[[kk]]
[10:33:15.020]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.020]                     next
[10:33:15.020]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.020]                 }
[10:33:15.020]                 NAMES <- toupper(added)
[10:33:15.020]                 for (kk in seq_along(NAMES)) {
[10:33:15.020]                   name <- added[[kk]]
[10:33:15.020]                   NAME <- NAMES[[kk]]
[10:33:15.020]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.020]                     next
[10:33:15.020]                   args[[name]] <- ""
[10:33:15.020]                 }
[10:33:15.020]                 NAMES <- toupper(removed)
[10:33:15.020]                 for (kk in seq_along(NAMES)) {
[10:33:15.020]                   name <- removed[[kk]]
[10:33:15.020]                   NAME <- NAMES[[kk]]
[10:33:15.020]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.020]                     next
[10:33:15.020]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.020]                 }
[10:33:15.020]                 if (length(args) > 0) 
[10:33:15.020]                   base::do.call(base::Sys.setenv, args = args)
[10:33:15.020]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:15.020]             }
[10:33:15.020]             else {
[10:33:15.020]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:15.020]             }
[10:33:15.020]             {
[10:33:15.020]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:15.020]                   0L) {
[10:33:15.020]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:15.020]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:15.020]                   base::options(opts)
[10:33:15.020]                 }
[10:33:15.020]                 {
[10:33:15.020]                   {
[10:33:15.020]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:15.020]                     NULL
[10:33:15.020]                   }
[10:33:15.020]                   options(future.plan = NULL)
[10:33:15.020]                   if (is.na(NA_character_)) 
[10:33:15.020]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.020]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:15.020]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:15.020]                     .init = FALSE)
[10:33:15.020]                 }
[10:33:15.020]             }
[10:33:15.020]         }
[10:33:15.020]     })
[10:33:15.020]     if (TRUE) {
[10:33:15.020]         base::sink(type = "output", split = FALSE)
[10:33:15.020]         if (TRUE) {
[10:33:15.020]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:15.020]         }
[10:33:15.020]         else {
[10:33:15.020]             ...future.result["stdout"] <- base::list(NULL)
[10:33:15.020]         }
[10:33:15.020]         base::close(...future.stdout)
[10:33:15.020]         ...future.stdout <- NULL
[10:33:15.020]     }
[10:33:15.020]     ...future.result$conditions <- ...future.conditions
[10:33:15.020]     ...future.result$finished <- base::Sys.time()
[10:33:15.020]     ...future.result
[10:33:15.020] }
[10:33:15.023] MultisessionFuture started
[10:33:15.023] - Launch lazy future ... done
[10:33:15.023] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:15.023] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:15.023] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:15.024] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:15.024] Searching for globals ... DONE
[10:33:15.024] Resolving globals: TRUE
[10:33:15.025] Resolving any globals that are futures ...
[10:33:15.025] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:15.025] Resolving any globals that are futures ... DONE
[10:33:15.025] Resolving futures part of globals (recursively) ...
[10:33:15.025] resolve() on list ...
[10:33:15.025]  recursive: 99
[10:33:15.026]  length: 1
[10:33:15.026]  elements: ‘a’
[10:33:15.067] receiveMessageFromWorker() for ClusterFuture ...
[10:33:15.067] - Validating connection of MultisessionFuture
[10:33:15.067] - received message: FutureResult
[10:33:15.068] - Received FutureResult
[10:33:15.068] - Erased future from FutureRegistry
[10:33:15.068] result() for ClusterFuture ...
[10:33:15.068] - result already collected: FutureResult
[10:33:15.068] result() for ClusterFuture ... done
[10:33:15.068] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:15.068] Future #1
[10:33:15.068] result() for ClusterFuture ...
[10:33:15.068] - result already collected: FutureResult
[10:33:15.069] result() for ClusterFuture ... done
[10:33:15.069] result() for ClusterFuture ...
[10:33:15.069] - result already collected: FutureResult
[10:33:15.069] result() for ClusterFuture ... done
[10:33:15.069] A MultisessionFuture was resolved
[10:33:15.069]  length: 0 (resolved future 1)
[10:33:15.069] resolve() on list ... DONE
[10:33:15.069] - globals: [1] ‘a’
[10:33:15.069] Resolving futures part of globals (recursively) ... DONE
[10:33:15.070] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[10:33:15.071] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[10:33:15.071] - globals: [1] ‘a’
[10:33:15.071] - packages: [1] ‘future’
[10:33:15.071] getGlobalsAndPackages() ... DONE
[10:33:15.071] run() for ‘Future’ ...
[10:33:15.071] - state: ‘created’
[10:33:15.072] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:15.086] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:15.086] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:15.086]   - Field: ‘node’
[10:33:15.086]   - Field: ‘label’
[10:33:15.086]   - Field: ‘local’
[10:33:15.086]   - Field: ‘owner’
[10:33:15.087]   - Field: ‘envir’
[10:33:15.087]   - Field: ‘workers’
[10:33:15.087]   - Field: ‘packages’
[10:33:15.087]   - Field: ‘gc’
[10:33:15.087]   - Field: ‘conditions’
[10:33:15.087]   - Field: ‘persistent’
[10:33:15.087]   - Field: ‘expr’
[10:33:15.087]   - Field: ‘uuid’
[10:33:15.087]   - Field: ‘seed’
[10:33:15.087]   - Field: ‘version’
[10:33:15.087]   - Field: ‘result’
[10:33:15.088]   - Field: ‘asynchronous’
[10:33:15.088]   - Field: ‘calls’
[10:33:15.088]   - Field: ‘globals’
[10:33:15.088]   - Field: ‘stdout’
[10:33:15.088]   - Field: ‘earlySignal’
[10:33:15.088]   - Field: ‘lazy’
[10:33:15.088]   - Field: ‘state’
[10:33:15.088] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:15.088] - Launch lazy future ...
[10:33:15.089] Packages needed by the future expression (n = 1): ‘future’
[10:33:15.089] Packages needed by future strategies (n = 0): <none>
[10:33:15.089] {
[10:33:15.089]     {
[10:33:15.089]         {
[10:33:15.089]             ...future.startTime <- base::Sys.time()
[10:33:15.089]             {
[10:33:15.089]                 {
[10:33:15.089]                   {
[10:33:15.089]                     {
[10:33:15.089]                       {
[10:33:15.089]                         base::local({
[10:33:15.089]                           has_future <- base::requireNamespace("future", 
[10:33:15.089]                             quietly = TRUE)
[10:33:15.089]                           if (has_future) {
[10:33:15.089]                             ns <- base::getNamespace("future")
[10:33:15.089]                             version <- ns[[".package"]][["version"]]
[10:33:15.089]                             if (is.null(version)) 
[10:33:15.089]                               version <- utils::packageVersion("future")
[10:33:15.089]                           }
[10:33:15.089]                           else {
[10:33:15.089]                             version <- NULL
[10:33:15.089]                           }
[10:33:15.089]                           if (!has_future || version < "1.8.0") {
[10:33:15.089]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:15.089]                               "", base::R.version$version.string), 
[10:33:15.089]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:15.089]                                 base::R.version$platform, 8 * 
[10:33:15.089]                                   base::.Machine$sizeof.pointer), 
[10:33:15.089]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:15.089]                                 "release", "version")], collapse = " "), 
[10:33:15.089]                               hostname = base::Sys.info()[["nodename"]])
[10:33:15.089]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:15.089]                               info)
[10:33:15.089]                             info <- base::paste(info, collapse = "; ")
[10:33:15.089]                             if (!has_future) {
[10:33:15.089]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:15.089]                                 info)
[10:33:15.089]                             }
[10:33:15.089]                             else {
[10:33:15.089]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:15.089]                                 info, version)
[10:33:15.089]                             }
[10:33:15.089]                             base::stop(msg)
[10:33:15.089]                           }
[10:33:15.089]                         })
[10:33:15.089]                       }
[10:33:15.089]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:15.089]                       base::options(mc.cores = 1L)
[10:33:15.089]                     }
[10:33:15.089]                     base::local({
[10:33:15.089]                       for (pkg in "future") {
[10:33:15.089]                         base::loadNamespace(pkg)
[10:33:15.089]                         base::library(pkg, character.only = TRUE)
[10:33:15.089]                       }
[10:33:15.089]                     })
[10:33:15.089]                   }
[10:33:15.089]                   ...future.strategy.old <- future::plan("list")
[10:33:15.089]                   options(future.plan = NULL)
[10:33:15.089]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.089]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:15.089]                 }
[10:33:15.089]                 ...future.workdir <- getwd()
[10:33:15.089]             }
[10:33:15.089]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:15.089]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:15.089]         }
[10:33:15.089]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:15.089]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:15.089]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:15.089]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:15.089]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:15.089]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:15.089]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:15.089]             base::names(...future.oldOptions))
[10:33:15.089]     }
[10:33:15.089]     if (FALSE) {
[10:33:15.089]     }
[10:33:15.089]     else {
[10:33:15.089]         if (TRUE) {
[10:33:15.089]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:15.089]                 open = "w")
[10:33:15.089]         }
[10:33:15.089]         else {
[10:33:15.089]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:15.089]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:15.089]         }
[10:33:15.089]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:15.089]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:15.089]             base::sink(type = "output", split = FALSE)
[10:33:15.089]             base::close(...future.stdout)
[10:33:15.089]         }, add = TRUE)
[10:33:15.089]     }
[10:33:15.089]     ...future.frame <- base::sys.nframe()
[10:33:15.089]     ...future.conditions <- base::list()
[10:33:15.089]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:15.089]     if (FALSE) {
[10:33:15.089]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:15.089]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:15.089]     }
[10:33:15.089]     ...future.result <- base::tryCatch({
[10:33:15.089]         base::withCallingHandlers({
[10:33:15.089]             ...future.value <- base::withVisible(base::local({
[10:33:15.089]                 ...future.makeSendCondition <- base::local({
[10:33:15.089]                   sendCondition <- NULL
[10:33:15.089]                   function(frame = 1L) {
[10:33:15.089]                     if (is.function(sendCondition)) 
[10:33:15.089]                       return(sendCondition)
[10:33:15.089]                     ns <- getNamespace("parallel")
[10:33:15.089]                     if (exists("sendData", mode = "function", 
[10:33:15.089]                       envir = ns)) {
[10:33:15.089]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:15.089]                         envir = ns)
[10:33:15.089]                       envir <- sys.frame(frame)
[10:33:15.089]                       master <- NULL
[10:33:15.089]                       while (!identical(envir, .GlobalEnv) && 
[10:33:15.089]                         !identical(envir, emptyenv())) {
[10:33:15.089]                         if (exists("master", mode = "list", envir = envir, 
[10:33:15.089]                           inherits = FALSE)) {
[10:33:15.089]                           master <- get("master", mode = "list", 
[10:33:15.089]                             envir = envir, inherits = FALSE)
[10:33:15.089]                           if (inherits(master, c("SOCKnode", 
[10:33:15.089]                             "SOCK0node"))) {
[10:33:15.089]                             sendCondition <<- function(cond) {
[10:33:15.089]                               data <- list(type = "VALUE", value = cond, 
[10:33:15.089]                                 success = TRUE)
[10:33:15.089]                               parallel_sendData(master, data)
[10:33:15.089]                             }
[10:33:15.089]                             return(sendCondition)
[10:33:15.089]                           }
[10:33:15.089]                         }
[10:33:15.089]                         frame <- frame + 1L
[10:33:15.089]                         envir <- sys.frame(frame)
[10:33:15.089]                       }
[10:33:15.089]                     }
[10:33:15.089]                     sendCondition <<- function(cond) NULL
[10:33:15.089]                   }
[10:33:15.089]                 })
[10:33:15.089]                 withCallingHandlers({
[10:33:15.089]                   value(a) + 1
[10:33:15.089]                 }, immediateCondition = function(cond) {
[10:33:15.089]                   sendCondition <- ...future.makeSendCondition()
[10:33:15.089]                   sendCondition(cond)
[10:33:15.089]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.089]                   {
[10:33:15.089]                     inherits <- base::inherits
[10:33:15.089]                     invokeRestart <- base::invokeRestart
[10:33:15.089]                     is.null <- base::is.null
[10:33:15.089]                     muffled <- FALSE
[10:33:15.089]                     if (inherits(cond, "message")) {
[10:33:15.089]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:15.089]                       if (muffled) 
[10:33:15.089]                         invokeRestart("muffleMessage")
[10:33:15.089]                     }
[10:33:15.089]                     else if (inherits(cond, "warning")) {
[10:33:15.089]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:15.089]                       if (muffled) 
[10:33:15.089]                         invokeRestart("muffleWarning")
[10:33:15.089]                     }
[10:33:15.089]                     else if (inherits(cond, "condition")) {
[10:33:15.089]                       if (!is.null(pattern)) {
[10:33:15.089]                         computeRestarts <- base::computeRestarts
[10:33:15.089]                         grepl <- base::grepl
[10:33:15.089]                         restarts <- computeRestarts(cond)
[10:33:15.089]                         for (restart in restarts) {
[10:33:15.089]                           name <- restart$name
[10:33:15.089]                           if (is.null(name)) 
[10:33:15.089]                             next
[10:33:15.089]                           if (!grepl(pattern, name)) 
[10:33:15.089]                             next
[10:33:15.089]                           invokeRestart(restart)
[10:33:15.089]                           muffled <- TRUE
[10:33:15.089]                           break
[10:33:15.089]                         }
[10:33:15.089]                       }
[10:33:15.089]                     }
[10:33:15.089]                     invisible(muffled)
[10:33:15.089]                   }
[10:33:15.089]                   muffleCondition(cond)
[10:33:15.089]                 })
[10:33:15.089]             }))
[10:33:15.089]             future::FutureResult(value = ...future.value$value, 
[10:33:15.089]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.089]                   ...future.rng), globalenv = if (FALSE) 
[10:33:15.089]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:15.089]                     ...future.globalenv.names))
[10:33:15.089]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:15.089]         }, condition = base::local({
[10:33:15.089]             c <- base::c
[10:33:15.089]             inherits <- base::inherits
[10:33:15.089]             invokeRestart <- base::invokeRestart
[10:33:15.089]             length <- base::length
[10:33:15.089]             list <- base::list
[10:33:15.089]             seq.int <- base::seq.int
[10:33:15.089]             signalCondition <- base::signalCondition
[10:33:15.089]             sys.calls <- base::sys.calls
[10:33:15.089]             `[[` <- base::`[[`
[10:33:15.089]             `+` <- base::`+`
[10:33:15.089]             `<<-` <- base::`<<-`
[10:33:15.089]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:15.089]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:15.089]                   3L)]
[10:33:15.089]             }
[10:33:15.089]             function(cond) {
[10:33:15.089]                 is_error <- inherits(cond, "error")
[10:33:15.089]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:15.089]                   NULL)
[10:33:15.089]                 if (is_error) {
[10:33:15.089]                   sessionInformation <- function() {
[10:33:15.089]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:15.089]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:15.089]                       search = base::search(), system = base::Sys.info())
[10:33:15.089]                   }
[10:33:15.089]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.089]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:15.089]                     cond$call), session = sessionInformation(), 
[10:33:15.089]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:15.089]                   signalCondition(cond)
[10:33:15.089]                 }
[10:33:15.089]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:15.089]                 "immediateCondition"))) {
[10:33:15.089]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:15.089]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.089]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:15.089]                   if (TRUE && !signal) {
[10:33:15.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.089]                     {
[10:33:15.089]                       inherits <- base::inherits
[10:33:15.089]                       invokeRestart <- base::invokeRestart
[10:33:15.089]                       is.null <- base::is.null
[10:33:15.089]                       muffled <- FALSE
[10:33:15.089]                       if (inherits(cond, "message")) {
[10:33:15.089]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.089]                         if (muffled) 
[10:33:15.089]                           invokeRestart("muffleMessage")
[10:33:15.089]                       }
[10:33:15.089]                       else if (inherits(cond, "warning")) {
[10:33:15.089]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.089]                         if (muffled) 
[10:33:15.089]                           invokeRestart("muffleWarning")
[10:33:15.089]                       }
[10:33:15.089]                       else if (inherits(cond, "condition")) {
[10:33:15.089]                         if (!is.null(pattern)) {
[10:33:15.089]                           computeRestarts <- base::computeRestarts
[10:33:15.089]                           grepl <- base::grepl
[10:33:15.089]                           restarts <- computeRestarts(cond)
[10:33:15.089]                           for (restart in restarts) {
[10:33:15.089]                             name <- restart$name
[10:33:15.089]                             if (is.null(name)) 
[10:33:15.089]                               next
[10:33:15.089]                             if (!grepl(pattern, name)) 
[10:33:15.089]                               next
[10:33:15.089]                             invokeRestart(restart)
[10:33:15.089]                             muffled <- TRUE
[10:33:15.089]                             break
[10:33:15.089]                           }
[10:33:15.089]                         }
[10:33:15.089]                       }
[10:33:15.089]                       invisible(muffled)
[10:33:15.089]                     }
[10:33:15.089]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.089]                   }
[10:33:15.089]                 }
[10:33:15.089]                 else {
[10:33:15.089]                   if (TRUE) {
[10:33:15.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.089]                     {
[10:33:15.089]                       inherits <- base::inherits
[10:33:15.089]                       invokeRestart <- base::invokeRestart
[10:33:15.089]                       is.null <- base::is.null
[10:33:15.089]                       muffled <- FALSE
[10:33:15.089]                       if (inherits(cond, "message")) {
[10:33:15.089]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.089]                         if (muffled) 
[10:33:15.089]                           invokeRestart("muffleMessage")
[10:33:15.089]                       }
[10:33:15.089]                       else if (inherits(cond, "warning")) {
[10:33:15.089]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.089]                         if (muffled) 
[10:33:15.089]                           invokeRestart("muffleWarning")
[10:33:15.089]                       }
[10:33:15.089]                       else if (inherits(cond, "condition")) {
[10:33:15.089]                         if (!is.null(pattern)) {
[10:33:15.089]                           computeRestarts <- base::computeRestarts
[10:33:15.089]                           grepl <- base::grepl
[10:33:15.089]                           restarts <- computeRestarts(cond)
[10:33:15.089]                           for (restart in restarts) {
[10:33:15.089]                             name <- restart$name
[10:33:15.089]                             if (is.null(name)) 
[10:33:15.089]                               next
[10:33:15.089]                             if (!grepl(pattern, name)) 
[10:33:15.089]                               next
[10:33:15.089]                             invokeRestart(restart)
[10:33:15.089]                             muffled <- TRUE
[10:33:15.089]                             break
[10:33:15.089]                           }
[10:33:15.089]                         }
[10:33:15.089]                       }
[10:33:15.089]                       invisible(muffled)
[10:33:15.089]                     }
[10:33:15.089]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.089]                   }
[10:33:15.089]                 }
[10:33:15.089]             }
[10:33:15.089]         }))
[10:33:15.089]     }, error = function(ex) {
[10:33:15.089]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:15.089]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.089]                 ...future.rng), started = ...future.startTime, 
[10:33:15.089]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:15.089]             version = "1.8"), class = "FutureResult")
[10:33:15.089]     }, finally = {
[10:33:15.089]         if (!identical(...future.workdir, getwd())) 
[10:33:15.089]             setwd(...future.workdir)
[10:33:15.089]         {
[10:33:15.089]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:15.089]                 ...future.oldOptions$nwarnings <- NULL
[10:33:15.089]             }
[10:33:15.089]             base::options(...future.oldOptions)
[10:33:15.089]             if (.Platform$OS.type == "windows") {
[10:33:15.089]                 old_names <- names(...future.oldEnvVars)
[10:33:15.089]                 envs <- base::Sys.getenv()
[10:33:15.089]                 names <- names(envs)
[10:33:15.089]                 common <- intersect(names, old_names)
[10:33:15.089]                 added <- setdiff(names, old_names)
[10:33:15.089]                 removed <- setdiff(old_names, names)
[10:33:15.089]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:15.089]                   envs[common]]
[10:33:15.089]                 NAMES <- toupper(changed)
[10:33:15.089]                 args <- list()
[10:33:15.089]                 for (kk in seq_along(NAMES)) {
[10:33:15.089]                   name <- changed[[kk]]
[10:33:15.089]                   NAME <- NAMES[[kk]]
[10:33:15.089]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.089]                     next
[10:33:15.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.089]                 }
[10:33:15.089]                 NAMES <- toupper(added)
[10:33:15.089]                 for (kk in seq_along(NAMES)) {
[10:33:15.089]                   name <- added[[kk]]
[10:33:15.089]                   NAME <- NAMES[[kk]]
[10:33:15.089]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.089]                     next
[10:33:15.089]                   args[[name]] <- ""
[10:33:15.089]                 }
[10:33:15.089]                 NAMES <- toupper(removed)
[10:33:15.089]                 for (kk in seq_along(NAMES)) {
[10:33:15.089]                   name <- removed[[kk]]
[10:33:15.089]                   NAME <- NAMES[[kk]]
[10:33:15.089]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.089]                     next
[10:33:15.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.089]                 }
[10:33:15.089]                 if (length(args) > 0) 
[10:33:15.089]                   base::do.call(base::Sys.setenv, args = args)
[10:33:15.089]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:15.089]             }
[10:33:15.089]             else {
[10:33:15.089]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:15.089]             }
[10:33:15.089]             {
[10:33:15.089]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:15.089]                   0L) {
[10:33:15.089]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:15.089]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:15.089]                   base::options(opts)
[10:33:15.089]                 }
[10:33:15.089]                 {
[10:33:15.089]                   {
[10:33:15.089]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:15.089]                     NULL
[10:33:15.089]                   }
[10:33:15.089]                   options(future.plan = NULL)
[10:33:15.089]                   if (is.na(NA_character_)) 
[10:33:15.089]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.089]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:15.089]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:15.089]                     .init = FALSE)
[10:33:15.089]                 }
[10:33:15.089]             }
[10:33:15.089]         }
[10:33:15.089]     })
[10:33:15.089]     if (TRUE) {
[10:33:15.089]         base::sink(type = "output", split = FALSE)
[10:33:15.089]         if (TRUE) {
[10:33:15.089]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:15.089]         }
[10:33:15.089]         else {
[10:33:15.089]             ...future.result["stdout"] <- base::list(NULL)
[10:33:15.089]         }
[10:33:15.089]         base::close(...future.stdout)
[10:33:15.089]         ...future.stdout <- NULL
[10:33:15.089]     }
[10:33:15.089]     ...future.result$conditions <- ...future.conditions
[10:33:15.089]     ...future.result$finished <- base::Sys.time()
[10:33:15.089]     ...future.result
[10:33:15.089] }
[10:33:15.092] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[10:33:15.093] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[10:33:15.145] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[10:33:15.145] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[10:33:15.146] MultisessionFuture started
[10:33:15.146] - Launch lazy future ... done
[10:33:15.146] run() for ‘MultisessionFuture’ ... done
[10:33:15.146] result() for ClusterFuture ...
[10:33:15.146] receiveMessageFromWorker() for ClusterFuture ...
[10:33:15.146] - Validating connection of MultisessionFuture
[10:33:15.191] - received message: FutureResult
[10:33:15.191] - Received FutureResult
[10:33:15.191] - Erased future from FutureRegistry
[10:33:15.191] result() for ClusterFuture ...
[10:33:15.191] - result already collected: FutureResult
[10:33:15.191] result() for ClusterFuture ... done
[10:33:15.191] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:15.191] result() for ClusterFuture ... done
[10:33:15.191] result() for ClusterFuture ...
[10:33:15.192] - result already collected: FutureResult
[10:33:15.192] result() for ClusterFuture ... done
value(b) = 2
[10:33:15.192] result() for ClusterFuture ...
[10:33:15.192] - result already collected: FutureResult
[10:33:15.192] result() for ClusterFuture ... done
[10:33:15.192] result() for ClusterFuture ...
[10:33:15.192] - result already collected: FutureResult
[10:33:15.192] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:15.192] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:15.193] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:15.193] 
[10:33:15.193] Searching for globals ... DONE
[10:33:15.193] - globals: [0] <none>
[10:33:15.194] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:15.194] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:15.194] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:15.195] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:15.195] Searching for globals ... DONE
[10:33:15.195] Resolving globals: TRUE
[10:33:15.195] Resolving any globals that are futures ...
[10:33:15.195] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:15.195] Resolving any globals that are futures ... DONE
[10:33:15.196] Resolving futures part of globals (recursively) ...
[10:33:15.196] resolve() on list ...
[10:33:15.196]  recursive: 99
[10:33:15.196]  length: 1
[10:33:15.196]  elements: ‘a’
[10:33:15.196] run() for ‘Future’ ...
[10:33:15.196] - state: ‘created’
[10:33:15.197] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:15.210] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:15.210] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:15.210]   - Field: ‘node’
[10:33:15.210]   - Field: ‘label’
[10:33:15.211]   - Field: ‘local’
[10:33:15.211]   - Field: ‘owner’
[10:33:15.211]   - Field: ‘envir’
[10:33:15.211]   - Field: ‘workers’
[10:33:15.211]   - Field: ‘packages’
[10:33:15.211]   - Field: ‘gc’
[10:33:15.211]   - Field: ‘conditions’
[10:33:15.211]   - Field: ‘persistent’
[10:33:15.211]   - Field: ‘expr’
[10:33:15.211]   - Field: ‘uuid’
[10:33:15.211]   - Field: ‘seed’
[10:33:15.212]   - Field: ‘version’
[10:33:15.212]   - Field: ‘result’
[10:33:15.212]   - Field: ‘asynchronous’
[10:33:15.212]   - Field: ‘calls’
[10:33:15.212]   - Field: ‘globals’
[10:33:15.212]   - Field: ‘stdout’
[10:33:15.212]   - Field: ‘earlySignal’
[10:33:15.212]   - Field: ‘lazy’
[10:33:15.212]   - Field: ‘state’
[10:33:15.212] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:15.213] - Launch lazy future ...
[10:33:15.213] Packages needed by the future expression (n = 0): <none>
[10:33:15.213] Packages needed by future strategies (n = 0): <none>
[10:33:15.213] {
[10:33:15.213]     {
[10:33:15.213]         {
[10:33:15.213]             ...future.startTime <- base::Sys.time()
[10:33:15.213]             {
[10:33:15.213]                 {
[10:33:15.213]                   {
[10:33:15.213]                     {
[10:33:15.213]                       base::local({
[10:33:15.213]                         has_future <- base::requireNamespace("future", 
[10:33:15.213]                           quietly = TRUE)
[10:33:15.213]                         if (has_future) {
[10:33:15.213]                           ns <- base::getNamespace("future")
[10:33:15.213]                           version <- ns[[".package"]][["version"]]
[10:33:15.213]                           if (is.null(version)) 
[10:33:15.213]                             version <- utils::packageVersion("future")
[10:33:15.213]                         }
[10:33:15.213]                         else {
[10:33:15.213]                           version <- NULL
[10:33:15.213]                         }
[10:33:15.213]                         if (!has_future || version < "1.8.0") {
[10:33:15.213]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:15.213]                             "", base::R.version$version.string), 
[10:33:15.213]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:15.213]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:15.213]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:15.213]                               "release", "version")], collapse = " "), 
[10:33:15.213]                             hostname = base::Sys.info()[["nodename"]])
[10:33:15.213]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:15.213]                             info)
[10:33:15.213]                           info <- base::paste(info, collapse = "; ")
[10:33:15.213]                           if (!has_future) {
[10:33:15.213]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:15.213]                               info)
[10:33:15.213]                           }
[10:33:15.213]                           else {
[10:33:15.213]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:15.213]                               info, version)
[10:33:15.213]                           }
[10:33:15.213]                           base::stop(msg)
[10:33:15.213]                         }
[10:33:15.213]                       })
[10:33:15.213]                     }
[10:33:15.213]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:15.213]                     base::options(mc.cores = 1L)
[10:33:15.213]                   }
[10:33:15.213]                   ...future.strategy.old <- future::plan("list")
[10:33:15.213]                   options(future.plan = NULL)
[10:33:15.213]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.213]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:15.213]                 }
[10:33:15.213]                 ...future.workdir <- getwd()
[10:33:15.213]             }
[10:33:15.213]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:15.213]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:15.213]         }
[10:33:15.213]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:15.213]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:15.213]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:15.213]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:15.213]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:15.213]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:15.213]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:15.213]             base::names(...future.oldOptions))
[10:33:15.213]     }
[10:33:15.213]     if (FALSE) {
[10:33:15.213]     }
[10:33:15.213]     else {
[10:33:15.213]         if (TRUE) {
[10:33:15.213]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:15.213]                 open = "w")
[10:33:15.213]         }
[10:33:15.213]         else {
[10:33:15.213]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:15.213]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:15.213]         }
[10:33:15.213]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:15.213]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:15.213]             base::sink(type = "output", split = FALSE)
[10:33:15.213]             base::close(...future.stdout)
[10:33:15.213]         }, add = TRUE)
[10:33:15.213]     }
[10:33:15.213]     ...future.frame <- base::sys.nframe()
[10:33:15.213]     ...future.conditions <- base::list()
[10:33:15.213]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:15.213]     if (FALSE) {
[10:33:15.213]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:15.213]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:15.213]     }
[10:33:15.213]     ...future.result <- base::tryCatch({
[10:33:15.213]         base::withCallingHandlers({
[10:33:15.213]             ...future.value <- base::withVisible(base::local({
[10:33:15.213]                 ...future.makeSendCondition <- base::local({
[10:33:15.213]                   sendCondition <- NULL
[10:33:15.213]                   function(frame = 1L) {
[10:33:15.213]                     if (is.function(sendCondition)) 
[10:33:15.213]                       return(sendCondition)
[10:33:15.213]                     ns <- getNamespace("parallel")
[10:33:15.213]                     if (exists("sendData", mode = "function", 
[10:33:15.213]                       envir = ns)) {
[10:33:15.213]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:15.213]                         envir = ns)
[10:33:15.213]                       envir <- sys.frame(frame)
[10:33:15.213]                       master <- NULL
[10:33:15.213]                       while (!identical(envir, .GlobalEnv) && 
[10:33:15.213]                         !identical(envir, emptyenv())) {
[10:33:15.213]                         if (exists("master", mode = "list", envir = envir, 
[10:33:15.213]                           inherits = FALSE)) {
[10:33:15.213]                           master <- get("master", mode = "list", 
[10:33:15.213]                             envir = envir, inherits = FALSE)
[10:33:15.213]                           if (inherits(master, c("SOCKnode", 
[10:33:15.213]                             "SOCK0node"))) {
[10:33:15.213]                             sendCondition <<- function(cond) {
[10:33:15.213]                               data <- list(type = "VALUE", value = cond, 
[10:33:15.213]                                 success = TRUE)
[10:33:15.213]                               parallel_sendData(master, data)
[10:33:15.213]                             }
[10:33:15.213]                             return(sendCondition)
[10:33:15.213]                           }
[10:33:15.213]                         }
[10:33:15.213]                         frame <- frame + 1L
[10:33:15.213]                         envir <- sys.frame(frame)
[10:33:15.213]                       }
[10:33:15.213]                     }
[10:33:15.213]                     sendCondition <<- function(cond) NULL
[10:33:15.213]                   }
[10:33:15.213]                 })
[10:33:15.213]                 withCallingHandlers({
[10:33:15.213]                   1
[10:33:15.213]                 }, immediateCondition = function(cond) {
[10:33:15.213]                   sendCondition <- ...future.makeSendCondition()
[10:33:15.213]                   sendCondition(cond)
[10:33:15.213]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.213]                   {
[10:33:15.213]                     inherits <- base::inherits
[10:33:15.213]                     invokeRestart <- base::invokeRestart
[10:33:15.213]                     is.null <- base::is.null
[10:33:15.213]                     muffled <- FALSE
[10:33:15.213]                     if (inherits(cond, "message")) {
[10:33:15.213]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:15.213]                       if (muffled) 
[10:33:15.213]                         invokeRestart("muffleMessage")
[10:33:15.213]                     }
[10:33:15.213]                     else if (inherits(cond, "warning")) {
[10:33:15.213]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:15.213]                       if (muffled) 
[10:33:15.213]                         invokeRestart("muffleWarning")
[10:33:15.213]                     }
[10:33:15.213]                     else if (inherits(cond, "condition")) {
[10:33:15.213]                       if (!is.null(pattern)) {
[10:33:15.213]                         computeRestarts <- base::computeRestarts
[10:33:15.213]                         grepl <- base::grepl
[10:33:15.213]                         restarts <- computeRestarts(cond)
[10:33:15.213]                         for (restart in restarts) {
[10:33:15.213]                           name <- restart$name
[10:33:15.213]                           if (is.null(name)) 
[10:33:15.213]                             next
[10:33:15.213]                           if (!grepl(pattern, name)) 
[10:33:15.213]                             next
[10:33:15.213]                           invokeRestart(restart)
[10:33:15.213]                           muffled <- TRUE
[10:33:15.213]                           break
[10:33:15.213]                         }
[10:33:15.213]                       }
[10:33:15.213]                     }
[10:33:15.213]                     invisible(muffled)
[10:33:15.213]                   }
[10:33:15.213]                   muffleCondition(cond)
[10:33:15.213]                 })
[10:33:15.213]             }))
[10:33:15.213]             future::FutureResult(value = ...future.value$value, 
[10:33:15.213]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.213]                   ...future.rng), globalenv = if (FALSE) 
[10:33:15.213]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:15.213]                     ...future.globalenv.names))
[10:33:15.213]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:15.213]         }, condition = base::local({
[10:33:15.213]             c <- base::c
[10:33:15.213]             inherits <- base::inherits
[10:33:15.213]             invokeRestart <- base::invokeRestart
[10:33:15.213]             length <- base::length
[10:33:15.213]             list <- base::list
[10:33:15.213]             seq.int <- base::seq.int
[10:33:15.213]             signalCondition <- base::signalCondition
[10:33:15.213]             sys.calls <- base::sys.calls
[10:33:15.213]             `[[` <- base::`[[`
[10:33:15.213]             `+` <- base::`+`
[10:33:15.213]             `<<-` <- base::`<<-`
[10:33:15.213]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:15.213]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:15.213]                   3L)]
[10:33:15.213]             }
[10:33:15.213]             function(cond) {
[10:33:15.213]                 is_error <- inherits(cond, "error")
[10:33:15.213]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:15.213]                   NULL)
[10:33:15.213]                 if (is_error) {
[10:33:15.213]                   sessionInformation <- function() {
[10:33:15.213]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:15.213]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:15.213]                       search = base::search(), system = base::Sys.info())
[10:33:15.213]                   }
[10:33:15.213]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.213]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:15.213]                     cond$call), session = sessionInformation(), 
[10:33:15.213]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:15.213]                   signalCondition(cond)
[10:33:15.213]                 }
[10:33:15.213]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:15.213]                 "immediateCondition"))) {
[10:33:15.213]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:15.213]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.213]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:15.213]                   if (TRUE && !signal) {
[10:33:15.213]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.213]                     {
[10:33:15.213]                       inherits <- base::inherits
[10:33:15.213]                       invokeRestart <- base::invokeRestart
[10:33:15.213]                       is.null <- base::is.null
[10:33:15.213]                       muffled <- FALSE
[10:33:15.213]                       if (inherits(cond, "message")) {
[10:33:15.213]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.213]                         if (muffled) 
[10:33:15.213]                           invokeRestart("muffleMessage")
[10:33:15.213]                       }
[10:33:15.213]                       else if (inherits(cond, "warning")) {
[10:33:15.213]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.213]                         if (muffled) 
[10:33:15.213]                           invokeRestart("muffleWarning")
[10:33:15.213]                       }
[10:33:15.213]                       else if (inherits(cond, "condition")) {
[10:33:15.213]                         if (!is.null(pattern)) {
[10:33:15.213]                           computeRestarts <- base::computeRestarts
[10:33:15.213]                           grepl <- base::grepl
[10:33:15.213]                           restarts <- computeRestarts(cond)
[10:33:15.213]                           for (restart in restarts) {
[10:33:15.213]                             name <- restart$name
[10:33:15.213]                             if (is.null(name)) 
[10:33:15.213]                               next
[10:33:15.213]                             if (!grepl(pattern, name)) 
[10:33:15.213]                               next
[10:33:15.213]                             invokeRestart(restart)
[10:33:15.213]                             muffled <- TRUE
[10:33:15.213]                             break
[10:33:15.213]                           }
[10:33:15.213]                         }
[10:33:15.213]                       }
[10:33:15.213]                       invisible(muffled)
[10:33:15.213]                     }
[10:33:15.213]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.213]                   }
[10:33:15.213]                 }
[10:33:15.213]                 else {
[10:33:15.213]                   if (TRUE) {
[10:33:15.213]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.213]                     {
[10:33:15.213]                       inherits <- base::inherits
[10:33:15.213]                       invokeRestart <- base::invokeRestart
[10:33:15.213]                       is.null <- base::is.null
[10:33:15.213]                       muffled <- FALSE
[10:33:15.213]                       if (inherits(cond, "message")) {
[10:33:15.213]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.213]                         if (muffled) 
[10:33:15.213]                           invokeRestart("muffleMessage")
[10:33:15.213]                       }
[10:33:15.213]                       else if (inherits(cond, "warning")) {
[10:33:15.213]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.213]                         if (muffled) 
[10:33:15.213]                           invokeRestart("muffleWarning")
[10:33:15.213]                       }
[10:33:15.213]                       else if (inherits(cond, "condition")) {
[10:33:15.213]                         if (!is.null(pattern)) {
[10:33:15.213]                           computeRestarts <- base::computeRestarts
[10:33:15.213]                           grepl <- base::grepl
[10:33:15.213]                           restarts <- computeRestarts(cond)
[10:33:15.213]                           for (restart in restarts) {
[10:33:15.213]                             name <- restart$name
[10:33:15.213]                             if (is.null(name)) 
[10:33:15.213]                               next
[10:33:15.213]                             if (!grepl(pattern, name)) 
[10:33:15.213]                               next
[10:33:15.213]                             invokeRestart(restart)
[10:33:15.213]                             muffled <- TRUE
[10:33:15.213]                             break
[10:33:15.213]                           }
[10:33:15.213]                         }
[10:33:15.213]                       }
[10:33:15.213]                       invisible(muffled)
[10:33:15.213]                     }
[10:33:15.213]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.213]                   }
[10:33:15.213]                 }
[10:33:15.213]             }
[10:33:15.213]         }))
[10:33:15.213]     }, error = function(ex) {
[10:33:15.213]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:15.213]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.213]                 ...future.rng), started = ...future.startTime, 
[10:33:15.213]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:15.213]             version = "1.8"), class = "FutureResult")
[10:33:15.213]     }, finally = {
[10:33:15.213]         if (!identical(...future.workdir, getwd())) 
[10:33:15.213]             setwd(...future.workdir)
[10:33:15.213]         {
[10:33:15.213]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:15.213]                 ...future.oldOptions$nwarnings <- NULL
[10:33:15.213]             }
[10:33:15.213]             base::options(...future.oldOptions)
[10:33:15.213]             if (.Platform$OS.type == "windows") {
[10:33:15.213]                 old_names <- names(...future.oldEnvVars)
[10:33:15.213]                 envs <- base::Sys.getenv()
[10:33:15.213]                 names <- names(envs)
[10:33:15.213]                 common <- intersect(names, old_names)
[10:33:15.213]                 added <- setdiff(names, old_names)
[10:33:15.213]                 removed <- setdiff(old_names, names)
[10:33:15.213]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:15.213]                   envs[common]]
[10:33:15.213]                 NAMES <- toupper(changed)
[10:33:15.213]                 args <- list()
[10:33:15.213]                 for (kk in seq_along(NAMES)) {
[10:33:15.213]                   name <- changed[[kk]]
[10:33:15.213]                   NAME <- NAMES[[kk]]
[10:33:15.213]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.213]                     next
[10:33:15.213]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.213]                 }
[10:33:15.213]                 NAMES <- toupper(added)
[10:33:15.213]                 for (kk in seq_along(NAMES)) {
[10:33:15.213]                   name <- added[[kk]]
[10:33:15.213]                   NAME <- NAMES[[kk]]
[10:33:15.213]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.213]                     next
[10:33:15.213]                   args[[name]] <- ""
[10:33:15.213]                 }
[10:33:15.213]                 NAMES <- toupper(removed)
[10:33:15.213]                 for (kk in seq_along(NAMES)) {
[10:33:15.213]                   name <- removed[[kk]]
[10:33:15.213]                   NAME <- NAMES[[kk]]
[10:33:15.213]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.213]                     next
[10:33:15.213]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.213]                 }
[10:33:15.213]                 if (length(args) > 0) 
[10:33:15.213]                   base::do.call(base::Sys.setenv, args = args)
[10:33:15.213]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:15.213]             }
[10:33:15.213]             else {
[10:33:15.213]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:15.213]             }
[10:33:15.213]             {
[10:33:15.213]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:15.213]                   0L) {
[10:33:15.213]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:15.213]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:15.213]                   base::options(opts)
[10:33:15.213]                 }
[10:33:15.213]                 {
[10:33:15.213]                   {
[10:33:15.213]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:15.213]                     NULL
[10:33:15.213]                   }
[10:33:15.213]                   options(future.plan = NULL)
[10:33:15.213]                   if (is.na(NA_character_)) 
[10:33:15.213]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.213]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:15.213]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:15.213]                     .init = FALSE)
[10:33:15.213]                 }
[10:33:15.213]             }
[10:33:15.213]         }
[10:33:15.213]     })
[10:33:15.213]     if (TRUE) {
[10:33:15.213]         base::sink(type = "output", split = FALSE)
[10:33:15.213]         if (TRUE) {
[10:33:15.213]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:15.213]         }
[10:33:15.213]         else {
[10:33:15.213]             ...future.result["stdout"] <- base::list(NULL)
[10:33:15.213]         }
[10:33:15.213]         base::close(...future.stdout)
[10:33:15.213]         ...future.stdout <- NULL
[10:33:15.213]     }
[10:33:15.213]     ...future.result$conditions <- ...future.conditions
[10:33:15.213]     ...future.result$finished <- base::Sys.time()
[10:33:15.213]     ...future.result
[10:33:15.213] }
[10:33:15.216] MultisessionFuture started
[10:33:15.216] - Launch lazy future ... done
[10:33:15.216] run() for ‘MultisessionFuture’ ... done
[10:33:15.259] receiveMessageFromWorker() for ClusterFuture ...
[10:33:15.259] - Validating connection of MultisessionFuture
[10:33:15.259] - received message: FutureResult
[10:33:15.259] - Received FutureResult
[10:33:15.259] - Erased future from FutureRegistry
[10:33:15.259] result() for ClusterFuture ...
[10:33:15.259] - result already collected: FutureResult
[10:33:15.259] result() for ClusterFuture ... done
[10:33:15.259] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:15.260] Future #1
[10:33:15.260] result() for ClusterFuture ...
[10:33:15.260] - result already collected: FutureResult
[10:33:15.260] result() for ClusterFuture ... done
[10:33:15.260] result() for ClusterFuture ...
[10:33:15.260] - result already collected: FutureResult
[10:33:15.260] result() for ClusterFuture ... done
[10:33:15.260] A MultisessionFuture was resolved
[10:33:15.260]  length: 0 (resolved future 1)
[10:33:15.260] resolve() on list ... DONE
[10:33:15.261] - globals: [1] ‘a’
[10:33:15.261] Resolving futures part of globals (recursively) ... DONE
[10:33:15.262] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[10:33:15.262] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[10:33:15.262] - globals: [1] ‘a’
[10:33:15.262] - packages: [1] ‘future’
[10:33:15.262] getGlobalsAndPackages() ... DONE
[10:33:15.262] run() for ‘Future’ ...
[10:33:15.263] - state: ‘created’
[10:33:15.263] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:15.277] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:15.277] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:15.277]   - Field: ‘node’
[10:33:15.277]   - Field: ‘label’
[10:33:15.277]   - Field: ‘local’
[10:33:15.277]   - Field: ‘owner’
[10:33:15.277]   - Field: ‘envir’
[10:33:15.277]   - Field: ‘workers’
[10:33:15.277]   - Field: ‘packages’
[10:33:15.278]   - Field: ‘gc’
[10:33:15.278]   - Field: ‘conditions’
[10:33:15.278]   - Field: ‘persistent’
[10:33:15.278]   - Field: ‘expr’
[10:33:15.278]   - Field: ‘uuid’
[10:33:15.278]   - Field: ‘seed’
[10:33:15.278]   - Field: ‘version’
[10:33:15.278]   - Field: ‘result’
[10:33:15.278]   - Field: ‘asynchronous’
[10:33:15.278]   - Field: ‘calls’
[10:33:15.278]   - Field: ‘globals’
[10:33:15.278]   - Field: ‘stdout’
[10:33:15.279]   - Field: ‘earlySignal’
[10:33:15.279]   - Field: ‘lazy’
[10:33:15.279]   - Field: ‘state’
[10:33:15.279] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:15.279] - Launch lazy future ...
[10:33:15.279] Packages needed by the future expression (n = 1): ‘future’
[10:33:15.279] Packages needed by future strategies (n = 0): <none>
[10:33:15.280] {
[10:33:15.280]     {
[10:33:15.280]         {
[10:33:15.280]             ...future.startTime <- base::Sys.time()
[10:33:15.280]             {
[10:33:15.280]                 {
[10:33:15.280]                   {
[10:33:15.280]                     {
[10:33:15.280]                       {
[10:33:15.280]                         base::local({
[10:33:15.280]                           has_future <- base::requireNamespace("future", 
[10:33:15.280]                             quietly = TRUE)
[10:33:15.280]                           if (has_future) {
[10:33:15.280]                             ns <- base::getNamespace("future")
[10:33:15.280]                             version <- ns[[".package"]][["version"]]
[10:33:15.280]                             if (is.null(version)) 
[10:33:15.280]                               version <- utils::packageVersion("future")
[10:33:15.280]                           }
[10:33:15.280]                           else {
[10:33:15.280]                             version <- NULL
[10:33:15.280]                           }
[10:33:15.280]                           if (!has_future || version < "1.8.0") {
[10:33:15.280]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:15.280]                               "", base::R.version$version.string), 
[10:33:15.280]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:15.280]                                 base::R.version$platform, 8 * 
[10:33:15.280]                                   base::.Machine$sizeof.pointer), 
[10:33:15.280]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:15.280]                                 "release", "version")], collapse = " "), 
[10:33:15.280]                               hostname = base::Sys.info()[["nodename"]])
[10:33:15.280]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:15.280]                               info)
[10:33:15.280]                             info <- base::paste(info, collapse = "; ")
[10:33:15.280]                             if (!has_future) {
[10:33:15.280]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:15.280]                                 info)
[10:33:15.280]                             }
[10:33:15.280]                             else {
[10:33:15.280]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:15.280]                                 info, version)
[10:33:15.280]                             }
[10:33:15.280]                             base::stop(msg)
[10:33:15.280]                           }
[10:33:15.280]                         })
[10:33:15.280]                       }
[10:33:15.280]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:15.280]                       base::options(mc.cores = 1L)
[10:33:15.280]                     }
[10:33:15.280]                     base::local({
[10:33:15.280]                       for (pkg in "future") {
[10:33:15.280]                         base::loadNamespace(pkg)
[10:33:15.280]                         base::library(pkg, character.only = TRUE)
[10:33:15.280]                       }
[10:33:15.280]                     })
[10:33:15.280]                   }
[10:33:15.280]                   ...future.strategy.old <- future::plan("list")
[10:33:15.280]                   options(future.plan = NULL)
[10:33:15.280]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.280]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:15.280]                 }
[10:33:15.280]                 ...future.workdir <- getwd()
[10:33:15.280]             }
[10:33:15.280]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:15.280]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:15.280]         }
[10:33:15.280]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:15.280]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:15.280]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:15.280]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:15.280]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:15.280]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:15.280]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:15.280]             base::names(...future.oldOptions))
[10:33:15.280]     }
[10:33:15.280]     if (FALSE) {
[10:33:15.280]     }
[10:33:15.280]     else {
[10:33:15.280]         if (TRUE) {
[10:33:15.280]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:15.280]                 open = "w")
[10:33:15.280]         }
[10:33:15.280]         else {
[10:33:15.280]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:15.280]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:15.280]         }
[10:33:15.280]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:15.280]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:15.280]             base::sink(type = "output", split = FALSE)
[10:33:15.280]             base::close(...future.stdout)
[10:33:15.280]         }, add = TRUE)
[10:33:15.280]     }
[10:33:15.280]     ...future.frame <- base::sys.nframe()
[10:33:15.280]     ...future.conditions <- base::list()
[10:33:15.280]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:15.280]     if (FALSE) {
[10:33:15.280]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:15.280]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:15.280]     }
[10:33:15.280]     ...future.result <- base::tryCatch({
[10:33:15.280]         base::withCallingHandlers({
[10:33:15.280]             ...future.value <- base::withVisible(base::local({
[10:33:15.280]                 ...future.makeSendCondition <- base::local({
[10:33:15.280]                   sendCondition <- NULL
[10:33:15.280]                   function(frame = 1L) {
[10:33:15.280]                     if (is.function(sendCondition)) 
[10:33:15.280]                       return(sendCondition)
[10:33:15.280]                     ns <- getNamespace("parallel")
[10:33:15.280]                     if (exists("sendData", mode = "function", 
[10:33:15.280]                       envir = ns)) {
[10:33:15.280]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:15.280]                         envir = ns)
[10:33:15.280]                       envir <- sys.frame(frame)
[10:33:15.280]                       master <- NULL
[10:33:15.280]                       while (!identical(envir, .GlobalEnv) && 
[10:33:15.280]                         !identical(envir, emptyenv())) {
[10:33:15.280]                         if (exists("master", mode = "list", envir = envir, 
[10:33:15.280]                           inherits = FALSE)) {
[10:33:15.280]                           master <- get("master", mode = "list", 
[10:33:15.280]                             envir = envir, inherits = FALSE)
[10:33:15.280]                           if (inherits(master, c("SOCKnode", 
[10:33:15.280]                             "SOCK0node"))) {
[10:33:15.280]                             sendCondition <<- function(cond) {
[10:33:15.280]                               data <- list(type = "VALUE", value = cond, 
[10:33:15.280]                                 success = TRUE)
[10:33:15.280]                               parallel_sendData(master, data)
[10:33:15.280]                             }
[10:33:15.280]                             return(sendCondition)
[10:33:15.280]                           }
[10:33:15.280]                         }
[10:33:15.280]                         frame <- frame + 1L
[10:33:15.280]                         envir <- sys.frame(frame)
[10:33:15.280]                       }
[10:33:15.280]                     }
[10:33:15.280]                     sendCondition <<- function(cond) NULL
[10:33:15.280]                   }
[10:33:15.280]                 })
[10:33:15.280]                 withCallingHandlers({
[10:33:15.280]                   value(a) + 1
[10:33:15.280]                 }, immediateCondition = function(cond) {
[10:33:15.280]                   sendCondition <- ...future.makeSendCondition()
[10:33:15.280]                   sendCondition(cond)
[10:33:15.280]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.280]                   {
[10:33:15.280]                     inherits <- base::inherits
[10:33:15.280]                     invokeRestart <- base::invokeRestart
[10:33:15.280]                     is.null <- base::is.null
[10:33:15.280]                     muffled <- FALSE
[10:33:15.280]                     if (inherits(cond, "message")) {
[10:33:15.280]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:15.280]                       if (muffled) 
[10:33:15.280]                         invokeRestart("muffleMessage")
[10:33:15.280]                     }
[10:33:15.280]                     else if (inherits(cond, "warning")) {
[10:33:15.280]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:15.280]                       if (muffled) 
[10:33:15.280]                         invokeRestart("muffleWarning")
[10:33:15.280]                     }
[10:33:15.280]                     else if (inherits(cond, "condition")) {
[10:33:15.280]                       if (!is.null(pattern)) {
[10:33:15.280]                         computeRestarts <- base::computeRestarts
[10:33:15.280]                         grepl <- base::grepl
[10:33:15.280]                         restarts <- computeRestarts(cond)
[10:33:15.280]                         for (restart in restarts) {
[10:33:15.280]                           name <- restart$name
[10:33:15.280]                           if (is.null(name)) 
[10:33:15.280]                             next
[10:33:15.280]                           if (!grepl(pattern, name)) 
[10:33:15.280]                             next
[10:33:15.280]                           invokeRestart(restart)
[10:33:15.280]                           muffled <- TRUE
[10:33:15.280]                           break
[10:33:15.280]                         }
[10:33:15.280]                       }
[10:33:15.280]                     }
[10:33:15.280]                     invisible(muffled)
[10:33:15.280]                   }
[10:33:15.280]                   muffleCondition(cond)
[10:33:15.280]                 })
[10:33:15.280]             }))
[10:33:15.280]             future::FutureResult(value = ...future.value$value, 
[10:33:15.280]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.280]                   ...future.rng), globalenv = if (FALSE) 
[10:33:15.280]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:15.280]                     ...future.globalenv.names))
[10:33:15.280]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:15.280]         }, condition = base::local({
[10:33:15.280]             c <- base::c
[10:33:15.280]             inherits <- base::inherits
[10:33:15.280]             invokeRestart <- base::invokeRestart
[10:33:15.280]             length <- base::length
[10:33:15.280]             list <- base::list
[10:33:15.280]             seq.int <- base::seq.int
[10:33:15.280]             signalCondition <- base::signalCondition
[10:33:15.280]             sys.calls <- base::sys.calls
[10:33:15.280]             `[[` <- base::`[[`
[10:33:15.280]             `+` <- base::`+`
[10:33:15.280]             `<<-` <- base::`<<-`
[10:33:15.280]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:15.280]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:15.280]                   3L)]
[10:33:15.280]             }
[10:33:15.280]             function(cond) {
[10:33:15.280]                 is_error <- inherits(cond, "error")
[10:33:15.280]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:15.280]                   NULL)
[10:33:15.280]                 if (is_error) {
[10:33:15.280]                   sessionInformation <- function() {
[10:33:15.280]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:15.280]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:15.280]                       search = base::search(), system = base::Sys.info())
[10:33:15.280]                   }
[10:33:15.280]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.280]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:15.280]                     cond$call), session = sessionInformation(), 
[10:33:15.280]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:15.280]                   signalCondition(cond)
[10:33:15.280]                 }
[10:33:15.280]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:15.280]                 "immediateCondition"))) {
[10:33:15.280]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:15.280]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.280]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:15.280]                   if (TRUE && !signal) {
[10:33:15.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.280]                     {
[10:33:15.280]                       inherits <- base::inherits
[10:33:15.280]                       invokeRestart <- base::invokeRestart
[10:33:15.280]                       is.null <- base::is.null
[10:33:15.280]                       muffled <- FALSE
[10:33:15.280]                       if (inherits(cond, "message")) {
[10:33:15.280]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.280]                         if (muffled) 
[10:33:15.280]                           invokeRestart("muffleMessage")
[10:33:15.280]                       }
[10:33:15.280]                       else if (inherits(cond, "warning")) {
[10:33:15.280]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.280]                         if (muffled) 
[10:33:15.280]                           invokeRestart("muffleWarning")
[10:33:15.280]                       }
[10:33:15.280]                       else if (inherits(cond, "condition")) {
[10:33:15.280]                         if (!is.null(pattern)) {
[10:33:15.280]                           computeRestarts <- base::computeRestarts
[10:33:15.280]                           grepl <- base::grepl
[10:33:15.280]                           restarts <- computeRestarts(cond)
[10:33:15.280]                           for (restart in restarts) {
[10:33:15.280]                             name <- restart$name
[10:33:15.280]                             if (is.null(name)) 
[10:33:15.280]                               next
[10:33:15.280]                             if (!grepl(pattern, name)) 
[10:33:15.280]                               next
[10:33:15.280]                             invokeRestart(restart)
[10:33:15.280]                             muffled <- TRUE
[10:33:15.280]                             break
[10:33:15.280]                           }
[10:33:15.280]                         }
[10:33:15.280]                       }
[10:33:15.280]                       invisible(muffled)
[10:33:15.280]                     }
[10:33:15.280]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.280]                   }
[10:33:15.280]                 }
[10:33:15.280]                 else {
[10:33:15.280]                   if (TRUE) {
[10:33:15.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.280]                     {
[10:33:15.280]                       inherits <- base::inherits
[10:33:15.280]                       invokeRestart <- base::invokeRestart
[10:33:15.280]                       is.null <- base::is.null
[10:33:15.280]                       muffled <- FALSE
[10:33:15.280]                       if (inherits(cond, "message")) {
[10:33:15.280]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.280]                         if (muffled) 
[10:33:15.280]                           invokeRestart("muffleMessage")
[10:33:15.280]                       }
[10:33:15.280]                       else if (inherits(cond, "warning")) {
[10:33:15.280]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.280]                         if (muffled) 
[10:33:15.280]                           invokeRestart("muffleWarning")
[10:33:15.280]                       }
[10:33:15.280]                       else if (inherits(cond, "condition")) {
[10:33:15.280]                         if (!is.null(pattern)) {
[10:33:15.280]                           computeRestarts <- base::computeRestarts
[10:33:15.280]                           grepl <- base::grepl
[10:33:15.280]                           restarts <- computeRestarts(cond)
[10:33:15.280]                           for (restart in restarts) {
[10:33:15.280]                             name <- restart$name
[10:33:15.280]                             if (is.null(name)) 
[10:33:15.280]                               next
[10:33:15.280]                             if (!grepl(pattern, name)) 
[10:33:15.280]                               next
[10:33:15.280]                             invokeRestart(restart)
[10:33:15.280]                             muffled <- TRUE
[10:33:15.280]                             break
[10:33:15.280]                           }
[10:33:15.280]                         }
[10:33:15.280]                       }
[10:33:15.280]                       invisible(muffled)
[10:33:15.280]                     }
[10:33:15.280]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.280]                   }
[10:33:15.280]                 }
[10:33:15.280]             }
[10:33:15.280]         }))
[10:33:15.280]     }, error = function(ex) {
[10:33:15.280]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:15.280]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.280]                 ...future.rng), started = ...future.startTime, 
[10:33:15.280]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:15.280]             version = "1.8"), class = "FutureResult")
[10:33:15.280]     }, finally = {
[10:33:15.280]         if (!identical(...future.workdir, getwd())) 
[10:33:15.280]             setwd(...future.workdir)
[10:33:15.280]         {
[10:33:15.280]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:15.280]                 ...future.oldOptions$nwarnings <- NULL
[10:33:15.280]             }
[10:33:15.280]             base::options(...future.oldOptions)
[10:33:15.280]             if (.Platform$OS.type == "windows") {
[10:33:15.280]                 old_names <- names(...future.oldEnvVars)
[10:33:15.280]                 envs <- base::Sys.getenv()
[10:33:15.280]                 names <- names(envs)
[10:33:15.280]                 common <- intersect(names, old_names)
[10:33:15.280]                 added <- setdiff(names, old_names)
[10:33:15.280]                 removed <- setdiff(old_names, names)
[10:33:15.280]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:15.280]                   envs[common]]
[10:33:15.280]                 NAMES <- toupper(changed)
[10:33:15.280]                 args <- list()
[10:33:15.280]                 for (kk in seq_along(NAMES)) {
[10:33:15.280]                   name <- changed[[kk]]
[10:33:15.280]                   NAME <- NAMES[[kk]]
[10:33:15.280]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.280]                     next
[10:33:15.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.280]                 }
[10:33:15.280]                 NAMES <- toupper(added)
[10:33:15.280]                 for (kk in seq_along(NAMES)) {
[10:33:15.280]                   name <- added[[kk]]
[10:33:15.280]                   NAME <- NAMES[[kk]]
[10:33:15.280]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.280]                     next
[10:33:15.280]                   args[[name]] <- ""
[10:33:15.280]                 }
[10:33:15.280]                 NAMES <- toupper(removed)
[10:33:15.280]                 for (kk in seq_along(NAMES)) {
[10:33:15.280]                   name <- removed[[kk]]
[10:33:15.280]                   NAME <- NAMES[[kk]]
[10:33:15.280]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.280]                     next
[10:33:15.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.280]                 }
[10:33:15.280]                 if (length(args) > 0) 
[10:33:15.280]                   base::do.call(base::Sys.setenv, args = args)
[10:33:15.280]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:15.280]             }
[10:33:15.280]             else {
[10:33:15.280]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:15.280]             }
[10:33:15.280]             {
[10:33:15.280]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:15.280]                   0L) {
[10:33:15.280]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:15.280]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:15.280]                   base::options(opts)
[10:33:15.280]                 }
[10:33:15.280]                 {
[10:33:15.280]                   {
[10:33:15.280]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:15.280]                     NULL
[10:33:15.280]                   }
[10:33:15.280]                   options(future.plan = NULL)
[10:33:15.280]                   if (is.na(NA_character_)) 
[10:33:15.280]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.280]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:15.280]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:15.280]                     .init = FALSE)
[10:33:15.280]                 }
[10:33:15.280]             }
[10:33:15.280]         }
[10:33:15.280]     })
[10:33:15.280]     if (TRUE) {
[10:33:15.280]         base::sink(type = "output", split = FALSE)
[10:33:15.280]         if (TRUE) {
[10:33:15.280]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:15.280]         }
[10:33:15.280]         else {
[10:33:15.280]             ...future.result["stdout"] <- base::list(NULL)
[10:33:15.280]         }
[10:33:15.280]         base::close(...future.stdout)
[10:33:15.280]         ...future.stdout <- NULL
[10:33:15.280]     }
[10:33:15.280]     ...future.result$conditions <- ...future.conditions
[10:33:15.280]     ...future.result$finished <- base::Sys.time()
[10:33:15.280]     ...future.result
[10:33:15.280] }
[10:33:15.282] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[10:33:15.283] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[10:33:15.337] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[10:33:15.337] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[10:33:15.338] MultisessionFuture started
[10:33:15.338] - Launch lazy future ... done
[10:33:15.338] run() for ‘MultisessionFuture’ ... done
[10:33:15.338] result() for ClusterFuture ...
[10:33:15.338] receiveMessageFromWorker() for ClusterFuture ...
[10:33:15.339] - Validating connection of MultisessionFuture
[10:33:15.383] - received message: FutureResult
[10:33:15.383] - Received FutureResult
[10:33:15.383] - Erased future from FutureRegistry
[10:33:15.383] result() for ClusterFuture ...
[10:33:15.383] - result already collected: FutureResult
[10:33:15.383] result() for ClusterFuture ... done
[10:33:15.383] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:15.384] result() for ClusterFuture ... done
[10:33:15.384] result() for ClusterFuture ...
[10:33:15.384] - result already collected: FutureResult
[10:33:15.384] result() for ClusterFuture ... done
value(b) = 2
[10:33:15.384] result() for ClusterFuture ...
[10:33:15.384] - result already collected: FutureResult
[10:33:15.384] result() for ClusterFuture ... done
[10:33:15.384] result() for ClusterFuture ...
[10:33:15.384] - result already collected: FutureResult
[10:33:15.385] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:15.385] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:15.385] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:15.386] 
[10:33:15.386] Searching for globals ... DONE
[10:33:15.386] - globals: [0] <none>
[10:33:15.386] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:15.386] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:15.386] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:15.387] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:15.387] Searching for globals ... DONE
[10:33:15.388] Resolving globals: TRUE
[10:33:15.388] Resolving any globals that are futures ...
[10:33:15.388] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:15.388] Resolving any globals that are futures ... DONE
[10:33:15.388] Resolving futures part of globals (recursively) ...
[10:33:15.388] resolve() on list ...
[10:33:15.389]  recursive: 99
[10:33:15.389]  length: 1
[10:33:15.389]  elements: ‘a’
[10:33:15.389] run() for ‘Future’ ...
[10:33:15.389] - state: ‘created’
[10:33:15.389] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:15.405] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:15.405] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:15.405]   - Field: ‘node’
[10:33:15.405]   - Field: ‘label’
[10:33:15.405]   - Field: ‘local’
[10:33:15.406]   - Field: ‘owner’
[10:33:15.406]   - Field: ‘envir’
[10:33:15.406]   - Field: ‘workers’
[10:33:15.406]   - Field: ‘packages’
[10:33:15.406]   - Field: ‘gc’
[10:33:15.406]   - Field: ‘conditions’
[10:33:15.406]   - Field: ‘persistent’
[10:33:15.406]   - Field: ‘expr’
[10:33:15.406]   - Field: ‘uuid’
[10:33:15.406]   - Field: ‘seed’
[10:33:15.406]   - Field: ‘version’
[10:33:15.407]   - Field: ‘result’
[10:33:15.407]   - Field: ‘asynchronous’
[10:33:15.407]   - Field: ‘calls’
[10:33:15.407]   - Field: ‘globals’
[10:33:15.407]   - Field: ‘stdout’
[10:33:15.407]   - Field: ‘earlySignal’
[10:33:15.407]   - Field: ‘lazy’
[10:33:15.407]   - Field: ‘state’
[10:33:15.407] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:15.407] - Launch lazy future ...
[10:33:15.408] Packages needed by the future expression (n = 0): <none>
[10:33:15.408] Packages needed by future strategies (n = 0): <none>
[10:33:15.408] {
[10:33:15.408]     {
[10:33:15.408]         {
[10:33:15.408]             ...future.startTime <- base::Sys.time()
[10:33:15.408]             {
[10:33:15.408]                 {
[10:33:15.408]                   {
[10:33:15.408]                     {
[10:33:15.408]                       base::local({
[10:33:15.408]                         has_future <- base::requireNamespace("future", 
[10:33:15.408]                           quietly = TRUE)
[10:33:15.408]                         if (has_future) {
[10:33:15.408]                           ns <- base::getNamespace("future")
[10:33:15.408]                           version <- ns[[".package"]][["version"]]
[10:33:15.408]                           if (is.null(version)) 
[10:33:15.408]                             version <- utils::packageVersion("future")
[10:33:15.408]                         }
[10:33:15.408]                         else {
[10:33:15.408]                           version <- NULL
[10:33:15.408]                         }
[10:33:15.408]                         if (!has_future || version < "1.8.0") {
[10:33:15.408]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:15.408]                             "", base::R.version$version.string), 
[10:33:15.408]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:15.408]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:15.408]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:15.408]                               "release", "version")], collapse = " "), 
[10:33:15.408]                             hostname = base::Sys.info()[["nodename"]])
[10:33:15.408]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:15.408]                             info)
[10:33:15.408]                           info <- base::paste(info, collapse = "; ")
[10:33:15.408]                           if (!has_future) {
[10:33:15.408]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:15.408]                               info)
[10:33:15.408]                           }
[10:33:15.408]                           else {
[10:33:15.408]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:15.408]                               info, version)
[10:33:15.408]                           }
[10:33:15.408]                           base::stop(msg)
[10:33:15.408]                         }
[10:33:15.408]                       })
[10:33:15.408]                     }
[10:33:15.408]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:15.408]                     base::options(mc.cores = 1L)
[10:33:15.408]                   }
[10:33:15.408]                   ...future.strategy.old <- future::plan("list")
[10:33:15.408]                   options(future.plan = NULL)
[10:33:15.408]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.408]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:15.408]                 }
[10:33:15.408]                 ...future.workdir <- getwd()
[10:33:15.408]             }
[10:33:15.408]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:15.408]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:15.408]         }
[10:33:15.408]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:15.408]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:15.408]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:15.408]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:15.408]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:15.408]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:15.408]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:15.408]             base::names(...future.oldOptions))
[10:33:15.408]     }
[10:33:15.408]     if (FALSE) {
[10:33:15.408]     }
[10:33:15.408]     else {
[10:33:15.408]         if (TRUE) {
[10:33:15.408]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:15.408]                 open = "w")
[10:33:15.408]         }
[10:33:15.408]         else {
[10:33:15.408]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:15.408]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:15.408]         }
[10:33:15.408]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:15.408]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:15.408]             base::sink(type = "output", split = FALSE)
[10:33:15.408]             base::close(...future.stdout)
[10:33:15.408]         }, add = TRUE)
[10:33:15.408]     }
[10:33:15.408]     ...future.frame <- base::sys.nframe()
[10:33:15.408]     ...future.conditions <- base::list()
[10:33:15.408]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:15.408]     if (FALSE) {
[10:33:15.408]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:15.408]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:15.408]     }
[10:33:15.408]     ...future.result <- base::tryCatch({
[10:33:15.408]         base::withCallingHandlers({
[10:33:15.408]             ...future.value <- base::withVisible(base::local({
[10:33:15.408]                 ...future.makeSendCondition <- base::local({
[10:33:15.408]                   sendCondition <- NULL
[10:33:15.408]                   function(frame = 1L) {
[10:33:15.408]                     if (is.function(sendCondition)) 
[10:33:15.408]                       return(sendCondition)
[10:33:15.408]                     ns <- getNamespace("parallel")
[10:33:15.408]                     if (exists("sendData", mode = "function", 
[10:33:15.408]                       envir = ns)) {
[10:33:15.408]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:15.408]                         envir = ns)
[10:33:15.408]                       envir <- sys.frame(frame)
[10:33:15.408]                       master <- NULL
[10:33:15.408]                       while (!identical(envir, .GlobalEnv) && 
[10:33:15.408]                         !identical(envir, emptyenv())) {
[10:33:15.408]                         if (exists("master", mode = "list", envir = envir, 
[10:33:15.408]                           inherits = FALSE)) {
[10:33:15.408]                           master <- get("master", mode = "list", 
[10:33:15.408]                             envir = envir, inherits = FALSE)
[10:33:15.408]                           if (inherits(master, c("SOCKnode", 
[10:33:15.408]                             "SOCK0node"))) {
[10:33:15.408]                             sendCondition <<- function(cond) {
[10:33:15.408]                               data <- list(type = "VALUE", value = cond, 
[10:33:15.408]                                 success = TRUE)
[10:33:15.408]                               parallel_sendData(master, data)
[10:33:15.408]                             }
[10:33:15.408]                             return(sendCondition)
[10:33:15.408]                           }
[10:33:15.408]                         }
[10:33:15.408]                         frame <- frame + 1L
[10:33:15.408]                         envir <- sys.frame(frame)
[10:33:15.408]                       }
[10:33:15.408]                     }
[10:33:15.408]                     sendCondition <<- function(cond) NULL
[10:33:15.408]                   }
[10:33:15.408]                 })
[10:33:15.408]                 withCallingHandlers({
[10:33:15.408]                   1
[10:33:15.408]                 }, immediateCondition = function(cond) {
[10:33:15.408]                   sendCondition <- ...future.makeSendCondition()
[10:33:15.408]                   sendCondition(cond)
[10:33:15.408]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.408]                   {
[10:33:15.408]                     inherits <- base::inherits
[10:33:15.408]                     invokeRestart <- base::invokeRestart
[10:33:15.408]                     is.null <- base::is.null
[10:33:15.408]                     muffled <- FALSE
[10:33:15.408]                     if (inherits(cond, "message")) {
[10:33:15.408]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:15.408]                       if (muffled) 
[10:33:15.408]                         invokeRestart("muffleMessage")
[10:33:15.408]                     }
[10:33:15.408]                     else if (inherits(cond, "warning")) {
[10:33:15.408]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:15.408]                       if (muffled) 
[10:33:15.408]                         invokeRestart("muffleWarning")
[10:33:15.408]                     }
[10:33:15.408]                     else if (inherits(cond, "condition")) {
[10:33:15.408]                       if (!is.null(pattern)) {
[10:33:15.408]                         computeRestarts <- base::computeRestarts
[10:33:15.408]                         grepl <- base::grepl
[10:33:15.408]                         restarts <- computeRestarts(cond)
[10:33:15.408]                         for (restart in restarts) {
[10:33:15.408]                           name <- restart$name
[10:33:15.408]                           if (is.null(name)) 
[10:33:15.408]                             next
[10:33:15.408]                           if (!grepl(pattern, name)) 
[10:33:15.408]                             next
[10:33:15.408]                           invokeRestart(restart)
[10:33:15.408]                           muffled <- TRUE
[10:33:15.408]                           break
[10:33:15.408]                         }
[10:33:15.408]                       }
[10:33:15.408]                     }
[10:33:15.408]                     invisible(muffled)
[10:33:15.408]                   }
[10:33:15.408]                   muffleCondition(cond)
[10:33:15.408]                 })
[10:33:15.408]             }))
[10:33:15.408]             future::FutureResult(value = ...future.value$value, 
[10:33:15.408]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.408]                   ...future.rng), globalenv = if (FALSE) 
[10:33:15.408]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:15.408]                     ...future.globalenv.names))
[10:33:15.408]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:15.408]         }, condition = base::local({
[10:33:15.408]             c <- base::c
[10:33:15.408]             inherits <- base::inherits
[10:33:15.408]             invokeRestart <- base::invokeRestart
[10:33:15.408]             length <- base::length
[10:33:15.408]             list <- base::list
[10:33:15.408]             seq.int <- base::seq.int
[10:33:15.408]             signalCondition <- base::signalCondition
[10:33:15.408]             sys.calls <- base::sys.calls
[10:33:15.408]             `[[` <- base::`[[`
[10:33:15.408]             `+` <- base::`+`
[10:33:15.408]             `<<-` <- base::`<<-`
[10:33:15.408]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:15.408]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:15.408]                   3L)]
[10:33:15.408]             }
[10:33:15.408]             function(cond) {
[10:33:15.408]                 is_error <- inherits(cond, "error")
[10:33:15.408]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:15.408]                   NULL)
[10:33:15.408]                 if (is_error) {
[10:33:15.408]                   sessionInformation <- function() {
[10:33:15.408]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:15.408]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:15.408]                       search = base::search(), system = base::Sys.info())
[10:33:15.408]                   }
[10:33:15.408]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.408]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:15.408]                     cond$call), session = sessionInformation(), 
[10:33:15.408]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:15.408]                   signalCondition(cond)
[10:33:15.408]                 }
[10:33:15.408]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:15.408]                 "immediateCondition"))) {
[10:33:15.408]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:15.408]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.408]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:15.408]                   if (TRUE && !signal) {
[10:33:15.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.408]                     {
[10:33:15.408]                       inherits <- base::inherits
[10:33:15.408]                       invokeRestart <- base::invokeRestart
[10:33:15.408]                       is.null <- base::is.null
[10:33:15.408]                       muffled <- FALSE
[10:33:15.408]                       if (inherits(cond, "message")) {
[10:33:15.408]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.408]                         if (muffled) 
[10:33:15.408]                           invokeRestart("muffleMessage")
[10:33:15.408]                       }
[10:33:15.408]                       else if (inherits(cond, "warning")) {
[10:33:15.408]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.408]                         if (muffled) 
[10:33:15.408]                           invokeRestart("muffleWarning")
[10:33:15.408]                       }
[10:33:15.408]                       else if (inherits(cond, "condition")) {
[10:33:15.408]                         if (!is.null(pattern)) {
[10:33:15.408]                           computeRestarts <- base::computeRestarts
[10:33:15.408]                           grepl <- base::grepl
[10:33:15.408]                           restarts <- computeRestarts(cond)
[10:33:15.408]                           for (restart in restarts) {
[10:33:15.408]                             name <- restart$name
[10:33:15.408]                             if (is.null(name)) 
[10:33:15.408]                               next
[10:33:15.408]                             if (!grepl(pattern, name)) 
[10:33:15.408]                               next
[10:33:15.408]                             invokeRestart(restart)
[10:33:15.408]                             muffled <- TRUE
[10:33:15.408]                             break
[10:33:15.408]                           }
[10:33:15.408]                         }
[10:33:15.408]                       }
[10:33:15.408]                       invisible(muffled)
[10:33:15.408]                     }
[10:33:15.408]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.408]                   }
[10:33:15.408]                 }
[10:33:15.408]                 else {
[10:33:15.408]                   if (TRUE) {
[10:33:15.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.408]                     {
[10:33:15.408]                       inherits <- base::inherits
[10:33:15.408]                       invokeRestart <- base::invokeRestart
[10:33:15.408]                       is.null <- base::is.null
[10:33:15.408]                       muffled <- FALSE
[10:33:15.408]                       if (inherits(cond, "message")) {
[10:33:15.408]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.408]                         if (muffled) 
[10:33:15.408]                           invokeRestart("muffleMessage")
[10:33:15.408]                       }
[10:33:15.408]                       else if (inherits(cond, "warning")) {
[10:33:15.408]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.408]                         if (muffled) 
[10:33:15.408]                           invokeRestart("muffleWarning")
[10:33:15.408]                       }
[10:33:15.408]                       else if (inherits(cond, "condition")) {
[10:33:15.408]                         if (!is.null(pattern)) {
[10:33:15.408]                           computeRestarts <- base::computeRestarts
[10:33:15.408]                           grepl <- base::grepl
[10:33:15.408]                           restarts <- computeRestarts(cond)
[10:33:15.408]                           for (restart in restarts) {
[10:33:15.408]                             name <- restart$name
[10:33:15.408]                             if (is.null(name)) 
[10:33:15.408]                               next
[10:33:15.408]                             if (!grepl(pattern, name)) 
[10:33:15.408]                               next
[10:33:15.408]                             invokeRestart(restart)
[10:33:15.408]                             muffled <- TRUE
[10:33:15.408]                             break
[10:33:15.408]                           }
[10:33:15.408]                         }
[10:33:15.408]                       }
[10:33:15.408]                       invisible(muffled)
[10:33:15.408]                     }
[10:33:15.408]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.408]                   }
[10:33:15.408]                 }
[10:33:15.408]             }
[10:33:15.408]         }))
[10:33:15.408]     }, error = function(ex) {
[10:33:15.408]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:15.408]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.408]                 ...future.rng), started = ...future.startTime, 
[10:33:15.408]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:15.408]             version = "1.8"), class = "FutureResult")
[10:33:15.408]     }, finally = {
[10:33:15.408]         if (!identical(...future.workdir, getwd())) 
[10:33:15.408]             setwd(...future.workdir)
[10:33:15.408]         {
[10:33:15.408]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:15.408]                 ...future.oldOptions$nwarnings <- NULL
[10:33:15.408]             }
[10:33:15.408]             base::options(...future.oldOptions)
[10:33:15.408]             if (.Platform$OS.type == "windows") {
[10:33:15.408]                 old_names <- names(...future.oldEnvVars)
[10:33:15.408]                 envs <- base::Sys.getenv()
[10:33:15.408]                 names <- names(envs)
[10:33:15.408]                 common <- intersect(names, old_names)
[10:33:15.408]                 added <- setdiff(names, old_names)
[10:33:15.408]                 removed <- setdiff(old_names, names)
[10:33:15.408]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:15.408]                   envs[common]]
[10:33:15.408]                 NAMES <- toupper(changed)
[10:33:15.408]                 args <- list()
[10:33:15.408]                 for (kk in seq_along(NAMES)) {
[10:33:15.408]                   name <- changed[[kk]]
[10:33:15.408]                   NAME <- NAMES[[kk]]
[10:33:15.408]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.408]                     next
[10:33:15.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.408]                 }
[10:33:15.408]                 NAMES <- toupper(added)
[10:33:15.408]                 for (kk in seq_along(NAMES)) {
[10:33:15.408]                   name <- added[[kk]]
[10:33:15.408]                   NAME <- NAMES[[kk]]
[10:33:15.408]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.408]                     next
[10:33:15.408]                   args[[name]] <- ""
[10:33:15.408]                 }
[10:33:15.408]                 NAMES <- toupper(removed)
[10:33:15.408]                 for (kk in seq_along(NAMES)) {
[10:33:15.408]                   name <- removed[[kk]]
[10:33:15.408]                   NAME <- NAMES[[kk]]
[10:33:15.408]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.408]                     next
[10:33:15.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.408]                 }
[10:33:15.408]                 if (length(args) > 0) 
[10:33:15.408]                   base::do.call(base::Sys.setenv, args = args)
[10:33:15.408]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:15.408]             }
[10:33:15.408]             else {
[10:33:15.408]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:15.408]             }
[10:33:15.408]             {
[10:33:15.408]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:15.408]                   0L) {
[10:33:15.408]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:15.408]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:15.408]                   base::options(opts)
[10:33:15.408]                 }
[10:33:15.408]                 {
[10:33:15.408]                   {
[10:33:15.408]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:15.408]                     NULL
[10:33:15.408]                   }
[10:33:15.408]                   options(future.plan = NULL)
[10:33:15.408]                   if (is.na(NA_character_)) 
[10:33:15.408]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.408]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:15.408]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:15.408]                     .init = FALSE)
[10:33:15.408]                 }
[10:33:15.408]             }
[10:33:15.408]         }
[10:33:15.408]     })
[10:33:15.408]     if (TRUE) {
[10:33:15.408]         base::sink(type = "output", split = FALSE)
[10:33:15.408]         if (TRUE) {
[10:33:15.408]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:15.408]         }
[10:33:15.408]         else {
[10:33:15.408]             ...future.result["stdout"] <- base::list(NULL)
[10:33:15.408]         }
[10:33:15.408]         base::close(...future.stdout)
[10:33:15.408]         ...future.stdout <- NULL
[10:33:15.408]     }
[10:33:15.408]     ...future.result$conditions <- ...future.conditions
[10:33:15.408]     ...future.result$finished <- base::Sys.time()
[10:33:15.408]     ...future.result
[10:33:15.408] }
[10:33:15.411] MultisessionFuture started
[10:33:15.411] - Launch lazy future ... done
[10:33:15.411] run() for ‘MultisessionFuture’ ... done
[10:33:15.455] receiveMessageFromWorker() for ClusterFuture ...
[10:33:15.455] - Validating connection of MultisessionFuture
[10:33:15.455] - received message: FutureResult
[10:33:15.455] - Received FutureResult
[10:33:15.455] - Erased future from FutureRegistry
[10:33:15.455] result() for ClusterFuture ...
[10:33:15.455] - result already collected: FutureResult
[10:33:15.455] result() for ClusterFuture ... done
[10:33:15.456] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:15.456] Future #1
[10:33:15.456] result() for ClusterFuture ...
[10:33:15.456] - result already collected: FutureResult
[10:33:15.456] result() for ClusterFuture ... done
[10:33:15.456] result() for ClusterFuture ...
[10:33:15.456] - result already collected: FutureResult
[10:33:15.456] result() for ClusterFuture ... done
[10:33:15.456] A MultisessionFuture was resolved
[10:33:15.457]  length: 0 (resolved future 1)
[10:33:15.457] resolve() on list ... DONE
[10:33:15.457] - globals: [1] ‘a’
[10:33:15.457] Resolving futures part of globals (recursively) ... DONE
[10:33:15.458] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[10:33:15.458] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[10:33:15.458] - globals: [1] ‘a’
[10:33:15.458] - packages: [1] ‘future’
[10:33:15.458] getGlobalsAndPackages() ... DONE
[10:33:15.459] run() for ‘Future’ ...
[10:33:15.459] - state: ‘created’
[10:33:15.459] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:15.473] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:15.474] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:15.474]   - Field: ‘node’
[10:33:15.474]   - Field: ‘label’
[10:33:15.474]   - Field: ‘local’
[10:33:15.474]   - Field: ‘owner’
[10:33:15.474]   - Field: ‘envir’
[10:33:15.474]   - Field: ‘workers’
[10:33:15.474]   - Field: ‘packages’
[10:33:15.474]   - Field: ‘gc’
[10:33:15.474]   - Field: ‘conditions’
[10:33:15.475]   - Field: ‘persistent’
[10:33:15.475]   - Field: ‘expr’
[10:33:15.475]   - Field: ‘uuid’
[10:33:15.475]   - Field: ‘seed’
[10:33:15.475]   - Field: ‘version’
[10:33:15.475]   - Field: ‘result’
[10:33:15.475]   - Field: ‘asynchronous’
[10:33:15.475]   - Field: ‘calls’
[10:33:15.475]   - Field: ‘globals’
[10:33:15.475]   - Field: ‘stdout’
[10:33:15.475]   - Field: ‘earlySignal’
[10:33:15.476]   - Field: ‘lazy’
[10:33:15.476]   - Field: ‘state’
[10:33:15.476] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:15.476] - Launch lazy future ...
[10:33:15.476] Packages needed by the future expression (n = 1): ‘future’
[10:33:15.476] Packages needed by future strategies (n = 0): <none>
[10:33:15.477] {
[10:33:15.477]     {
[10:33:15.477]         {
[10:33:15.477]             ...future.startTime <- base::Sys.time()
[10:33:15.477]             {
[10:33:15.477]                 {
[10:33:15.477]                   {
[10:33:15.477]                     {
[10:33:15.477]                       {
[10:33:15.477]                         base::local({
[10:33:15.477]                           has_future <- base::requireNamespace("future", 
[10:33:15.477]                             quietly = TRUE)
[10:33:15.477]                           if (has_future) {
[10:33:15.477]                             ns <- base::getNamespace("future")
[10:33:15.477]                             version <- ns[[".package"]][["version"]]
[10:33:15.477]                             if (is.null(version)) 
[10:33:15.477]                               version <- utils::packageVersion("future")
[10:33:15.477]                           }
[10:33:15.477]                           else {
[10:33:15.477]                             version <- NULL
[10:33:15.477]                           }
[10:33:15.477]                           if (!has_future || version < "1.8.0") {
[10:33:15.477]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:15.477]                               "", base::R.version$version.string), 
[10:33:15.477]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:15.477]                                 base::R.version$platform, 8 * 
[10:33:15.477]                                   base::.Machine$sizeof.pointer), 
[10:33:15.477]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:15.477]                                 "release", "version")], collapse = " "), 
[10:33:15.477]                               hostname = base::Sys.info()[["nodename"]])
[10:33:15.477]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:15.477]                               info)
[10:33:15.477]                             info <- base::paste(info, collapse = "; ")
[10:33:15.477]                             if (!has_future) {
[10:33:15.477]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:15.477]                                 info)
[10:33:15.477]                             }
[10:33:15.477]                             else {
[10:33:15.477]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:15.477]                                 info, version)
[10:33:15.477]                             }
[10:33:15.477]                             base::stop(msg)
[10:33:15.477]                           }
[10:33:15.477]                         })
[10:33:15.477]                       }
[10:33:15.477]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:15.477]                       base::options(mc.cores = 1L)
[10:33:15.477]                     }
[10:33:15.477]                     base::local({
[10:33:15.477]                       for (pkg in "future") {
[10:33:15.477]                         base::loadNamespace(pkg)
[10:33:15.477]                         base::library(pkg, character.only = TRUE)
[10:33:15.477]                       }
[10:33:15.477]                     })
[10:33:15.477]                   }
[10:33:15.477]                   ...future.strategy.old <- future::plan("list")
[10:33:15.477]                   options(future.plan = NULL)
[10:33:15.477]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.477]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:15.477]                 }
[10:33:15.477]                 ...future.workdir <- getwd()
[10:33:15.477]             }
[10:33:15.477]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:15.477]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:15.477]         }
[10:33:15.477]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:15.477]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:15.477]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:15.477]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:15.477]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:15.477]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:15.477]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:15.477]             base::names(...future.oldOptions))
[10:33:15.477]     }
[10:33:15.477]     if (FALSE) {
[10:33:15.477]     }
[10:33:15.477]     else {
[10:33:15.477]         if (TRUE) {
[10:33:15.477]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:15.477]                 open = "w")
[10:33:15.477]         }
[10:33:15.477]         else {
[10:33:15.477]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:15.477]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:15.477]         }
[10:33:15.477]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:15.477]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:15.477]             base::sink(type = "output", split = FALSE)
[10:33:15.477]             base::close(...future.stdout)
[10:33:15.477]         }, add = TRUE)
[10:33:15.477]     }
[10:33:15.477]     ...future.frame <- base::sys.nframe()
[10:33:15.477]     ...future.conditions <- base::list()
[10:33:15.477]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:15.477]     if (FALSE) {
[10:33:15.477]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:15.477]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:15.477]     }
[10:33:15.477]     ...future.result <- base::tryCatch({
[10:33:15.477]         base::withCallingHandlers({
[10:33:15.477]             ...future.value <- base::withVisible(base::local({
[10:33:15.477]                 ...future.makeSendCondition <- base::local({
[10:33:15.477]                   sendCondition <- NULL
[10:33:15.477]                   function(frame = 1L) {
[10:33:15.477]                     if (is.function(sendCondition)) 
[10:33:15.477]                       return(sendCondition)
[10:33:15.477]                     ns <- getNamespace("parallel")
[10:33:15.477]                     if (exists("sendData", mode = "function", 
[10:33:15.477]                       envir = ns)) {
[10:33:15.477]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:15.477]                         envir = ns)
[10:33:15.477]                       envir <- sys.frame(frame)
[10:33:15.477]                       master <- NULL
[10:33:15.477]                       while (!identical(envir, .GlobalEnv) && 
[10:33:15.477]                         !identical(envir, emptyenv())) {
[10:33:15.477]                         if (exists("master", mode = "list", envir = envir, 
[10:33:15.477]                           inherits = FALSE)) {
[10:33:15.477]                           master <- get("master", mode = "list", 
[10:33:15.477]                             envir = envir, inherits = FALSE)
[10:33:15.477]                           if (inherits(master, c("SOCKnode", 
[10:33:15.477]                             "SOCK0node"))) {
[10:33:15.477]                             sendCondition <<- function(cond) {
[10:33:15.477]                               data <- list(type = "VALUE", value = cond, 
[10:33:15.477]                                 success = TRUE)
[10:33:15.477]                               parallel_sendData(master, data)
[10:33:15.477]                             }
[10:33:15.477]                             return(sendCondition)
[10:33:15.477]                           }
[10:33:15.477]                         }
[10:33:15.477]                         frame <- frame + 1L
[10:33:15.477]                         envir <- sys.frame(frame)
[10:33:15.477]                       }
[10:33:15.477]                     }
[10:33:15.477]                     sendCondition <<- function(cond) NULL
[10:33:15.477]                   }
[10:33:15.477]                 })
[10:33:15.477]                 withCallingHandlers({
[10:33:15.477]                   value(a) + 1
[10:33:15.477]                 }, immediateCondition = function(cond) {
[10:33:15.477]                   sendCondition <- ...future.makeSendCondition()
[10:33:15.477]                   sendCondition(cond)
[10:33:15.477]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.477]                   {
[10:33:15.477]                     inherits <- base::inherits
[10:33:15.477]                     invokeRestart <- base::invokeRestart
[10:33:15.477]                     is.null <- base::is.null
[10:33:15.477]                     muffled <- FALSE
[10:33:15.477]                     if (inherits(cond, "message")) {
[10:33:15.477]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:15.477]                       if (muffled) 
[10:33:15.477]                         invokeRestart("muffleMessage")
[10:33:15.477]                     }
[10:33:15.477]                     else if (inherits(cond, "warning")) {
[10:33:15.477]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:15.477]                       if (muffled) 
[10:33:15.477]                         invokeRestart("muffleWarning")
[10:33:15.477]                     }
[10:33:15.477]                     else if (inherits(cond, "condition")) {
[10:33:15.477]                       if (!is.null(pattern)) {
[10:33:15.477]                         computeRestarts <- base::computeRestarts
[10:33:15.477]                         grepl <- base::grepl
[10:33:15.477]                         restarts <- computeRestarts(cond)
[10:33:15.477]                         for (restart in restarts) {
[10:33:15.477]                           name <- restart$name
[10:33:15.477]                           if (is.null(name)) 
[10:33:15.477]                             next
[10:33:15.477]                           if (!grepl(pattern, name)) 
[10:33:15.477]                             next
[10:33:15.477]                           invokeRestart(restart)
[10:33:15.477]                           muffled <- TRUE
[10:33:15.477]                           break
[10:33:15.477]                         }
[10:33:15.477]                       }
[10:33:15.477]                     }
[10:33:15.477]                     invisible(muffled)
[10:33:15.477]                   }
[10:33:15.477]                   muffleCondition(cond)
[10:33:15.477]                 })
[10:33:15.477]             }))
[10:33:15.477]             future::FutureResult(value = ...future.value$value, 
[10:33:15.477]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.477]                   ...future.rng), globalenv = if (FALSE) 
[10:33:15.477]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:15.477]                     ...future.globalenv.names))
[10:33:15.477]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:15.477]         }, condition = base::local({
[10:33:15.477]             c <- base::c
[10:33:15.477]             inherits <- base::inherits
[10:33:15.477]             invokeRestart <- base::invokeRestart
[10:33:15.477]             length <- base::length
[10:33:15.477]             list <- base::list
[10:33:15.477]             seq.int <- base::seq.int
[10:33:15.477]             signalCondition <- base::signalCondition
[10:33:15.477]             sys.calls <- base::sys.calls
[10:33:15.477]             `[[` <- base::`[[`
[10:33:15.477]             `+` <- base::`+`
[10:33:15.477]             `<<-` <- base::`<<-`
[10:33:15.477]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:15.477]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:15.477]                   3L)]
[10:33:15.477]             }
[10:33:15.477]             function(cond) {
[10:33:15.477]                 is_error <- inherits(cond, "error")
[10:33:15.477]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:15.477]                   NULL)
[10:33:15.477]                 if (is_error) {
[10:33:15.477]                   sessionInformation <- function() {
[10:33:15.477]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:15.477]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:15.477]                       search = base::search(), system = base::Sys.info())
[10:33:15.477]                   }
[10:33:15.477]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.477]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:15.477]                     cond$call), session = sessionInformation(), 
[10:33:15.477]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:15.477]                   signalCondition(cond)
[10:33:15.477]                 }
[10:33:15.477]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:15.477]                 "immediateCondition"))) {
[10:33:15.477]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:15.477]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.477]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:15.477]                   if (TRUE && !signal) {
[10:33:15.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.477]                     {
[10:33:15.477]                       inherits <- base::inherits
[10:33:15.477]                       invokeRestart <- base::invokeRestart
[10:33:15.477]                       is.null <- base::is.null
[10:33:15.477]                       muffled <- FALSE
[10:33:15.477]                       if (inherits(cond, "message")) {
[10:33:15.477]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.477]                         if (muffled) 
[10:33:15.477]                           invokeRestart("muffleMessage")
[10:33:15.477]                       }
[10:33:15.477]                       else if (inherits(cond, "warning")) {
[10:33:15.477]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.477]                         if (muffled) 
[10:33:15.477]                           invokeRestart("muffleWarning")
[10:33:15.477]                       }
[10:33:15.477]                       else if (inherits(cond, "condition")) {
[10:33:15.477]                         if (!is.null(pattern)) {
[10:33:15.477]                           computeRestarts <- base::computeRestarts
[10:33:15.477]                           grepl <- base::grepl
[10:33:15.477]                           restarts <- computeRestarts(cond)
[10:33:15.477]                           for (restart in restarts) {
[10:33:15.477]                             name <- restart$name
[10:33:15.477]                             if (is.null(name)) 
[10:33:15.477]                               next
[10:33:15.477]                             if (!grepl(pattern, name)) 
[10:33:15.477]                               next
[10:33:15.477]                             invokeRestart(restart)
[10:33:15.477]                             muffled <- TRUE
[10:33:15.477]                             break
[10:33:15.477]                           }
[10:33:15.477]                         }
[10:33:15.477]                       }
[10:33:15.477]                       invisible(muffled)
[10:33:15.477]                     }
[10:33:15.477]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.477]                   }
[10:33:15.477]                 }
[10:33:15.477]                 else {
[10:33:15.477]                   if (TRUE) {
[10:33:15.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.477]                     {
[10:33:15.477]                       inherits <- base::inherits
[10:33:15.477]                       invokeRestart <- base::invokeRestart
[10:33:15.477]                       is.null <- base::is.null
[10:33:15.477]                       muffled <- FALSE
[10:33:15.477]                       if (inherits(cond, "message")) {
[10:33:15.477]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.477]                         if (muffled) 
[10:33:15.477]                           invokeRestart("muffleMessage")
[10:33:15.477]                       }
[10:33:15.477]                       else if (inherits(cond, "warning")) {
[10:33:15.477]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.477]                         if (muffled) 
[10:33:15.477]                           invokeRestart("muffleWarning")
[10:33:15.477]                       }
[10:33:15.477]                       else if (inherits(cond, "condition")) {
[10:33:15.477]                         if (!is.null(pattern)) {
[10:33:15.477]                           computeRestarts <- base::computeRestarts
[10:33:15.477]                           grepl <- base::grepl
[10:33:15.477]                           restarts <- computeRestarts(cond)
[10:33:15.477]                           for (restart in restarts) {
[10:33:15.477]                             name <- restart$name
[10:33:15.477]                             if (is.null(name)) 
[10:33:15.477]                               next
[10:33:15.477]                             if (!grepl(pattern, name)) 
[10:33:15.477]                               next
[10:33:15.477]                             invokeRestart(restart)
[10:33:15.477]                             muffled <- TRUE
[10:33:15.477]                             break
[10:33:15.477]                           }
[10:33:15.477]                         }
[10:33:15.477]                       }
[10:33:15.477]                       invisible(muffled)
[10:33:15.477]                     }
[10:33:15.477]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.477]                   }
[10:33:15.477]                 }
[10:33:15.477]             }
[10:33:15.477]         }))
[10:33:15.477]     }, error = function(ex) {
[10:33:15.477]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:15.477]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.477]                 ...future.rng), started = ...future.startTime, 
[10:33:15.477]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:15.477]             version = "1.8"), class = "FutureResult")
[10:33:15.477]     }, finally = {
[10:33:15.477]         if (!identical(...future.workdir, getwd())) 
[10:33:15.477]             setwd(...future.workdir)
[10:33:15.477]         {
[10:33:15.477]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:15.477]                 ...future.oldOptions$nwarnings <- NULL
[10:33:15.477]             }
[10:33:15.477]             base::options(...future.oldOptions)
[10:33:15.477]             if (.Platform$OS.type == "windows") {
[10:33:15.477]                 old_names <- names(...future.oldEnvVars)
[10:33:15.477]                 envs <- base::Sys.getenv()
[10:33:15.477]                 names <- names(envs)
[10:33:15.477]                 common <- intersect(names, old_names)
[10:33:15.477]                 added <- setdiff(names, old_names)
[10:33:15.477]                 removed <- setdiff(old_names, names)
[10:33:15.477]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:15.477]                   envs[common]]
[10:33:15.477]                 NAMES <- toupper(changed)
[10:33:15.477]                 args <- list()
[10:33:15.477]                 for (kk in seq_along(NAMES)) {
[10:33:15.477]                   name <- changed[[kk]]
[10:33:15.477]                   NAME <- NAMES[[kk]]
[10:33:15.477]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.477]                     next
[10:33:15.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.477]                 }
[10:33:15.477]                 NAMES <- toupper(added)
[10:33:15.477]                 for (kk in seq_along(NAMES)) {
[10:33:15.477]                   name <- added[[kk]]
[10:33:15.477]                   NAME <- NAMES[[kk]]
[10:33:15.477]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.477]                     next
[10:33:15.477]                   args[[name]] <- ""
[10:33:15.477]                 }
[10:33:15.477]                 NAMES <- toupper(removed)
[10:33:15.477]                 for (kk in seq_along(NAMES)) {
[10:33:15.477]                   name <- removed[[kk]]
[10:33:15.477]                   NAME <- NAMES[[kk]]
[10:33:15.477]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.477]                     next
[10:33:15.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.477]                 }
[10:33:15.477]                 if (length(args) > 0) 
[10:33:15.477]                   base::do.call(base::Sys.setenv, args = args)
[10:33:15.477]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:15.477]             }
[10:33:15.477]             else {
[10:33:15.477]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:15.477]             }
[10:33:15.477]             {
[10:33:15.477]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:15.477]                   0L) {
[10:33:15.477]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:15.477]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:15.477]                   base::options(opts)
[10:33:15.477]                 }
[10:33:15.477]                 {
[10:33:15.477]                   {
[10:33:15.477]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:15.477]                     NULL
[10:33:15.477]                   }
[10:33:15.477]                   options(future.plan = NULL)
[10:33:15.477]                   if (is.na(NA_character_)) 
[10:33:15.477]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.477]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:15.477]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:15.477]                     .init = FALSE)
[10:33:15.477]                 }
[10:33:15.477]             }
[10:33:15.477]         }
[10:33:15.477]     })
[10:33:15.477]     if (TRUE) {
[10:33:15.477]         base::sink(type = "output", split = FALSE)
[10:33:15.477]         if (TRUE) {
[10:33:15.477]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:15.477]         }
[10:33:15.477]         else {
[10:33:15.477]             ...future.result["stdout"] <- base::list(NULL)
[10:33:15.477]         }
[10:33:15.477]         base::close(...future.stdout)
[10:33:15.477]         ...future.stdout <- NULL
[10:33:15.477]     }
[10:33:15.477]     ...future.result$conditions <- ...future.conditions
[10:33:15.477]     ...future.result$finished <- base::Sys.time()
[10:33:15.477]     ...future.result
[10:33:15.477] }
[10:33:15.479] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[10:33:15.480] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[10:33:15.533] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[10:33:15.533] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[10:33:15.534] MultisessionFuture started
[10:33:15.534] - Launch lazy future ... done
[10:33:15.534] run() for ‘MultisessionFuture’ ... done
[10:33:15.534] result() for ClusterFuture ...
[10:33:15.534] receiveMessageFromWorker() for ClusterFuture ...
[10:33:15.534] - Validating connection of MultisessionFuture
[10:33:15.579] - received message: FutureResult
[10:33:15.579] - Received FutureResult
[10:33:15.579] - Erased future from FutureRegistry
[10:33:15.579] result() for ClusterFuture ...
[10:33:15.579] - result already collected: FutureResult
[10:33:15.580] result() for ClusterFuture ... done
[10:33:15.580] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:15.580] result() for ClusterFuture ... done
[10:33:15.580] result() for ClusterFuture ...
[10:33:15.580] - result already collected: FutureResult
[10:33:15.580] result() for ClusterFuture ... done
value(b) = 2
[10:33:15.580] result() for ClusterFuture ...
[10:33:15.580] - result already collected: FutureResult
[10:33:15.580] result() for ClusterFuture ... done
[10:33:15.580] result() for ClusterFuture ...
[10:33:15.581] - result already collected: FutureResult
[10:33:15.581] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:15.581] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:15.581] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:33:15.582] - globals found: [2] ‘{’, ‘pkg’
[10:33:15.582] Searching for globals ... DONE
[10:33:15.582] Resolving globals: TRUE
[10:33:15.582] Resolving any globals that are futures ...
[10:33:15.582] - globals: [2] ‘{’, ‘pkg’
[10:33:15.583] Resolving any globals that are futures ... DONE
[10:33:15.583] Resolving futures part of globals (recursively) ...
[10:33:15.583] resolve() on list ...
[10:33:15.583]  recursive: 99
[10:33:15.583]  length: 1
[10:33:15.583]  elements: ‘pkg’
[10:33:15.583]  length: 0 (resolved future 1)
[10:33:15.584] resolve() on list ... DONE
[10:33:15.584] - globals: [1] ‘pkg’
[10:33:15.584] Resolving futures part of globals (recursively) ... DONE
[10:33:15.584] The total size of the 1 globals is 112 bytes (112 bytes)
[10:33:15.584] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[10:33:15.584] - globals: [1] ‘pkg’
[10:33:15.584] 
[10:33:15.585] getGlobalsAndPackages() ... DONE
[10:33:15.585] Packages needed by the future expression (n = 0): <none>
[10:33:15.585] Packages needed by future strategies (n = 0): <none>
[10:33:15.585] {
[10:33:15.585]     {
[10:33:15.585]         {
[10:33:15.585]             ...future.startTime <- base::Sys.time()
[10:33:15.585]             {
[10:33:15.585]                 {
[10:33:15.585]                   {
[10:33:15.585]                     base::local({
[10:33:15.585]                       has_future <- base::requireNamespace("future", 
[10:33:15.585]                         quietly = TRUE)
[10:33:15.585]                       if (has_future) {
[10:33:15.585]                         ns <- base::getNamespace("future")
[10:33:15.585]                         version <- ns[[".package"]][["version"]]
[10:33:15.585]                         if (is.null(version)) 
[10:33:15.585]                           version <- utils::packageVersion("future")
[10:33:15.585]                       }
[10:33:15.585]                       else {
[10:33:15.585]                         version <- NULL
[10:33:15.585]                       }
[10:33:15.585]                       if (!has_future || version < "1.8.0") {
[10:33:15.585]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:15.585]                           "", base::R.version$version.string), 
[10:33:15.585]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:15.585]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:15.585]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:15.585]                             "release", "version")], collapse = " "), 
[10:33:15.585]                           hostname = base::Sys.info()[["nodename"]])
[10:33:15.585]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:15.585]                           info)
[10:33:15.585]                         info <- base::paste(info, collapse = "; ")
[10:33:15.585]                         if (!has_future) {
[10:33:15.585]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:15.585]                             info)
[10:33:15.585]                         }
[10:33:15.585]                         else {
[10:33:15.585]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:15.585]                             info, version)
[10:33:15.585]                         }
[10:33:15.585]                         base::stop(msg)
[10:33:15.585]                       }
[10:33:15.585]                     })
[10:33:15.585]                   }
[10:33:15.585]                   ...future.strategy.old <- future::plan("list")
[10:33:15.585]                   options(future.plan = NULL)
[10:33:15.585]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.585]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:15.585]                 }
[10:33:15.585]                 ...future.workdir <- getwd()
[10:33:15.585]             }
[10:33:15.585]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:15.585]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:15.585]         }
[10:33:15.585]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:15.585]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:33:15.585]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:15.585]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:15.585]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:15.585]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:15.585]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:15.585]             base::names(...future.oldOptions))
[10:33:15.585]     }
[10:33:15.585]     if (FALSE) {
[10:33:15.585]     }
[10:33:15.585]     else {
[10:33:15.585]         if (TRUE) {
[10:33:15.585]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:15.585]                 open = "w")
[10:33:15.585]         }
[10:33:15.585]         else {
[10:33:15.585]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:15.585]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:15.585]         }
[10:33:15.585]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:15.585]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:15.585]             base::sink(type = "output", split = FALSE)
[10:33:15.585]             base::close(...future.stdout)
[10:33:15.585]         }, add = TRUE)
[10:33:15.585]     }
[10:33:15.585]     ...future.frame <- base::sys.nframe()
[10:33:15.585]     ...future.conditions <- base::list()
[10:33:15.585]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:15.585]     if (FALSE) {
[10:33:15.585]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:15.585]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:15.585]     }
[10:33:15.585]     ...future.result <- base::tryCatch({
[10:33:15.585]         base::withCallingHandlers({
[10:33:15.585]             ...future.value <- base::withVisible(base::local({
[10:33:15.585]                 pkg
[10:33:15.585]             }))
[10:33:15.585]             future::FutureResult(value = ...future.value$value, 
[10:33:15.585]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.585]                   ...future.rng), globalenv = if (FALSE) 
[10:33:15.585]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:15.585]                     ...future.globalenv.names))
[10:33:15.585]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:15.585]         }, condition = base::local({
[10:33:15.585]             c <- base::c
[10:33:15.585]             inherits <- base::inherits
[10:33:15.585]             invokeRestart <- base::invokeRestart
[10:33:15.585]             length <- base::length
[10:33:15.585]             list <- base::list
[10:33:15.585]             seq.int <- base::seq.int
[10:33:15.585]             signalCondition <- base::signalCondition
[10:33:15.585]             sys.calls <- base::sys.calls
[10:33:15.585]             `[[` <- base::`[[`
[10:33:15.585]             `+` <- base::`+`
[10:33:15.585]             `<<-` <- base::`<<-`
[10:33:15.585]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:15.585]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:15.585]                   3L)]
[10:33:15.585]             }
[10:33:15.585]             function(cond) {
[10:33:15.585]                 is_error <- inherits(cond, "error")
[10:33:15.585]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:15.585]                   NULL)
[10:33:15.585]                 if (is_error) {
[10:33:15.585]                   sessionInformation <- function() {
[10:33:15.585]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:15.585]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:15.585]                       search = base::search(), system = base::Sys.info())
[10:33:15.585]                   }
[10:33:15.585]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.585]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:15.585]                     cond$call), session = sessionInformation(), 
[10:33:15.585]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:15.585]                   signalCondition(cond)
[10:33:15.585]                 }
[10:33:15.585]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:15.585]                 "immediateCondition"))) {
[10:33:15.585]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:15.585]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.585]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:15.585]                   if (TRUE && !signal) {
[10:33:15.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.585]                     {
[10:33:15.585]                       inherits <- base::inherits
[10:33:15.585]                       invokeRestart <- base::invokeRestart
[10:33:15.585]                       is.null <- base::is.null
[10:33:15.585]                       muffled <- FALSE
[10:33:15.585]                       if (inherits(cond, "message")) {
[10:33:15.585]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.585]                         if (muffled) 
[10:33:15.585]                           invokeRestart("muffleMessage")
[10:33:15.585]                       }
[10:33:15.585]                       else if (inherits(cond, "warning")) {
[10:33:15.585]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.585]                         if (muffled) 
[10:33:15.585]                           invokeRestart("muffleWarning")
[10:33:15.585]                       }
[10:33:15.585]                       else if (inherits(cond, "condition")) {
[10:33:15.585]                         if (!is.null(pattern)) {
[10:33:15.585]                           computeRestarts <- base::computeRestarts
[10:33:15.585]                           grepl <- base::grepl
[10:33:15.585]                           restarts <- computeRestarts(cond)
[10:33:15.585]                           for (restart in restarts) {
[10:33:15.585]                             name <- restart$name
[10:33:15.585]                             if (is.null(name)) 
[10:33:15.585]                               next
[10:33:15.585]                             if (!grepl(pattern, name)) 
[10:33:15.585]                               next
[10:33:15.585]                             invokeRestart(restart)
[10:33:15.585]                             muffled <- TRUE
[10:33:15.585]                             break
[10:33:15.585]                           }
[10:33:15.585]                         }
[10:33:15.585]                       }
[10:33:15.585]                       invisible(muffled)
[10:33:15.585]                     }
[10:33:15.585]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.585]                   }
[10:33:15.585]                 }
[10:33:15.585]                 else {
[10:33:15.585]                   if (TRUE) {
[10:33:15.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.585]                     {
[10:33:15.585]                       inherits <- base::inherits
[10:33:15.585]                       invokeRestart <- base::invokeRestart
[10:33:15.585]                       is.null <- base::is.null
[10:33:15.585]                       muffled <- FALSE
[10:33:15.585]                       if (inherits(cond, "message")) {
[10:33:15.585]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.585]                         if (muffled) 
[10:33:15.585]                           invokeRestart("muffleMessage")
[10:33:15.585]                       }
[10:33:15.585]                       else if (inherits(cond, "warning")) {
[10:33:15.585]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.585]                         if (muffled) 
[10:33:15.585]                           invokeRestart("muffleWarning")
[10:33:15.585]                       }
[10:33:15.585]                       else if (inherits(cond, "condition")) {
[10:33:15.585]                         if (!is.null(pattern)) {
[10:33:15.585]                           computeRestarts <- base::computeRestarts
[10:33:15.585]                           grepl <- base::grepl
[10:33:15.585]                           restarts <- computeRestarts(cond)
[10:33:15.585]                           for (restart in restarts) {
[10:33:15.585]                             name <- restart$name
[10:33:15.585]                             if (is.null(name)) 
[10:33:15.585]                               next
[10:33:15.585]                             if (!grepl(pattern, name)) 
[10:33:15.585]                               next
[10:33:15.585]                             invokeRestart(restart)
[10:33:15.585]                             muffled <- TRUE
[10:33:15.585]                             break
[10:33:15.585]                           }
[10:33:15.585]                         }
[10:33:15.585]                       }
[10:33:15.585]                       invisible(muffled)
[10:33:15.585]                     }
[10:33:15.585]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.585]                   }
[10:33:15.585]                 }
[10:33:15.585]             }
[10:33:15.585]         }))
[10:33:15.585]     }, error = function(ex) {
[10:33:15.585]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:15.585]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.585]                 ...future.rng), started = ...future.startTime, 
[10:33:15.585]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:15.585]             version = "1.8"), class = "FutureResult")
[10:33:15.585]     }, finally = {
[10:33:15.585]         if (!identical(...future.workdir, getwd())) 
[10:33:15.585]             setwd(...future.workdir)
[10:33:15.585]         {
[10:33:15.585]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:15.585]                 ...future.oldOptions$nwarnings <- NULL
[10:33:15.585]             }
[10:33:15.585]             base::options(...future.oldOptions)
[10:33:15.585]             if (.Platform$OS.type == "windows") {
[10:33:15.585]                 old_names <- names(...future.oldEnvVars)
[10:33:15.585]                 envs <- base::Sys.getenv()
[10:33:15.585]                 names <- names(envs)
[10:33:15.585]                 common <- intersect(names, old_names)
[10:33:15.585]                 added <- setdiff(names, old_names)
[10:33:15.585]                 removed <- setdiff(old_names, names)
[10:33:15.585]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:15.585]                   envs[common]]
[10:33:15.585]                 NAMES <- toupper(changed)
[10:33:15.585]                 args <- list()
[10:33:15.585]                 for (kk in seq_along(NAMES)) {
[10:33:15.585]                   name <- changed[[kk]]
[10:33:15.585]                   NAME <- NAMES[[kk]]
[10:33:15.585]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.585]                     next
[10:33:15.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.585]                 }
[10:33:15.585]                 NAMES <- toupper(added)
[10:33:15.585]                 for (kk in seq_along(NAMES)) {
[10:33:15.585]                   name <- added[[kk]]
[10:33:15.585]                   NAME <- NAMES[[kk]]
[10:33:15.585]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.585]                     next
[10:33:15.585]                   args[[name]] <- ""
[10:33:15.585]                 }
[10:33:15.585]                 NAMES <- toupper(removed)
[10:33:15.585]                 for (kk in seq_along(NAMES)) {
[10:33:15.585]                   name <- removed[[kk]]
[10:33:15.585]                   NAME <- NAMES[[kk]]
[10:33:15.585]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.585]                     next
[10:33:15.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.585]                 }
[10:33:15.585]                 if (length(args) > 0) 
[10:33:15.585]                   base::do.call(base::Sys.setenv, args = args)
[10:33:15.585]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:15.585]             }
[10:33:15.585]             else {
[10:33:15.585]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:15.585]             }
[10:33:15.585]             {
[10:33:15.585]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:15.585]                   0L) {
[10:33:15.585]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:15.585]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:15.585]                   base::options(opts)
[10:33:15.585]                 }
[10:33:15.585]                 {
[10:33:15.585]                   {
[10:33:15.585]                     NULL
[10:33:15.585]                     RNGkind("Mersenne-Twister")
[10:33:15.585]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:15.585]                       inherits = FALSE)
[10:33:15.585]                   }
[10:33:15.585]                   options(future.plan = NULL)
[10:33:15.585]                   if (is.na(NA_character_)) 
[10:33:15.585]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.585]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:15.585]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:15.585]                     .init = FALSE)
[10:33:15.585]                 }
[10:33:15.585]             }
[10:33:15.585]         }
[10:33:15.585]     })
[10:33:15.585]     if (TRUE) {
[10:33:15.585]         base::sink(type = "output", split = FALSE)
[10:33:15.585]         if (TRUE) {
[10:33:15.585]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:15.585]         }
[10:33:15.585]         else {
[10:33:15.585]             ...future.result["stdout"] <- base::list(NULL)
[10:33:15.585]         }
[10:33:15.585]         base::close(...future.stdout)
[10:33:15.585]         ...future.stdout <- NULL
[10:33:15.585]     }
[10:33:15.585]     ...future.result$conditions <- ...future.conditions
[10:33:15.585]     ...future.result$finished <- base::Sys.time()
[10:33:15.585]     ...future.result
[10:33:15.585] }
[10:33:15.587] assign_globals() ...
[10:33:15.587] List of 1
[10:33:15.587]  $ pkg: chr "foo"
[10:33:15.587]  - attr(*, "where")=List of 1
[10:33:15.587]   ..$ pkg:<environment: R_EmptyEnv> 
[10:33:15.587]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:15.587]  - attr(*, "resolved")= logi TRUE
[10:33:15.587]  - attr(*, "total_size")= num 112
[10:33:15.589] - copied ‘pkg’ to environment
[10:33:15.589] assign_globals() ... done
[10:33:15.590] plan(): Setting new future strategy stack:
[10:33:15.590] List of future strategies:
[10:33:15.590] 1. sequential:
[10:33:15.590]    - args: function (..., envir = parent.frame())
[10:33:15.590]    - tweaked: FALSE
[10:33:15.590]    - call: NULL
[10:33:15.590] plan(): nbrOfWorkers() = 1
[10:33:15.591] plan(): Setting new future strategy stack:
[10:33:15.591] List of future strategies:
[10:33:15.591] 1. multisession:
[10:33:15.591]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:15.591]    - tweaked: FALSE
[10:33:15.591]    - call: plan(strategy)
[10:33:15.595] plan(): nbrOfWorkers() = 2
[10:33:15.595] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:15.595] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:15.596] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:15.597] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:33:15.598] Searching for globals ... DONE
[10:33:15.598] Resolving globals: TRUE
[10:33:15.598] Resolving any globals that are futures ...
[10:33:15.598] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:33:15.598] Resolving any globals that are futures ... DONE
[10:33:15.598] Resolving futures part of globals (recursively) ...
[10:33:15.598] resolve() on list ...
[10:33:15.599]  recursive: 99
[10:33:15.599]  length: 1
[10:33:15.599]  elements: ‘a’
[10:33:15.599]  length: 0 (resolved future 1)
[10:33:15.599] resolve() on list ... DONE
[10:33:15.599] - globals: [1] ‘a’
[10:33:15.599] Resolving futures part of globals (recursively) ... DONE
[10:33:15.599] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:15.600] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:33:15.600] - globals: [1] ‘a’
[10:33:15.600] 
[10:33:15.600] getGlobalsAndPackages() ... DONE
[10:33:15.600] run() for ‘Future’ ...
[10:33:15.600] - state: ‘created’
[10:33:15.600] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:15.614] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:15.614] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:15.614]   - Field: ‘node’
[10:33:15.614]   - Field: ‘label’
[10:33:15.614]   - Field: ‘local’
[10:33:15.614]   - Field: ‘owner’
[10:33:15.614]   - Field: ‘envir’
[10:33:15.615]   - Field: ‘workers’
[10:33:15.615]   - Field: ‘packages’
[10:33:15.615]   - Field: ‘gc’
[10:33:15.615]   - Field: ‘conditions’
[10:33:15.615]   - Field: ‘persistent’
[10:33:15.615]   - Field: ‘expr’
[10:33:15.615]   - Field: ‘uuid’
[10:33:15.615]   - Field: ‘seed’
[10:33:15.615]   - Field: ‘version’
[10:33:15.615]   - Field: ‘result’
[10:33:15.615]   - Field: ‘asynchronous’
[10:33:15.616]   - Field: ‘calls’
[10:33:15.616]   - Field: ‘globals’
[10:33:15.616]   - Field: ‘stdout’
[10:33:15.616]   - Field: ‘earlySignal’
[10:33:15.616]   - Field: ‘lazy’
[10:33:15.616]   - Field: ‘state’
[10:33:15.616] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:15.616] - Launch lazy future ...
[10:33:15.616] Packages needed by the future expression (n = 0): <none>
[10:33:15.617] Packages needed by future strategies (n = 0): <none>
[10:33:15.617] {
[10:33:15.617]     {
[10:33:15.617]         {
[10:33:15.617]             ...future.startTime <- base::Sys.time()
[10:33:15.617]             {
[10:33:15.617]                 {
[10:33:15.617]                   {
[10:33:15.617]                     {
[10:33:15.617]                       base::local({
[10:33:15.617]                         has_future <- base::requireNamespace("future", 
[10:33:15.617]                           quietly = TRUE)
[10:33:15.617]                         if (has_future) {
[10:33:15.617]                           ns <- base::getNamespace("future")
[10:33:15.617]                           version <- ns[[".package"]][["version"]]
[10:33:15.617]                           if (is.null(version)) 
[10:33:15.617]                             version <- utils::packageVersion("future")
[10:33:15.617]                         }
[10:33:15.617]                         else {
[10:33:15.617]                           version <- NULL
[10:33:15.617]                         }
[10:33:15.617]                         if (!has_future || version < "1.8.0") {
[10:33:15.617]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:15.617]                             "", base::R.version$version.string), 
[10:33:15.617]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:15.617]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:15.617]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:15.617]                               "release", "version")], collapse = " "), 
[10:33:15.617]                             hostname = base::Sys.info()[["nodename"]])
[10:33:15.617]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:15.617]                             info)
[10:33:15.617]                           info <- base::paste(info, collapse = "; ")
[10:33:15.617]                           if (!has_future) {
[10:33:15.617]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:15.617]                               info)
[10:33:15.617]                           }
[10:33:15.617]                           else {
[10:33:15.617]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:15.617]                               info, version)
[10:33:15.617]                           }
[10:33:15.617]                           base::stop(msg)
[10:33:15.617]                         }
[10:33:15.617]                       })
[10:33:15.617]                     }
[10:33:15.617]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:15.617]                     base::options(mc.cores = 1L)
[10:33:15.617]                   }
[10:33:15.617]                   ...future.strategy.old <- future::plan("list")
[10:33:15.617]                   options(future.plan = NULL)
[10:33:15.617]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.617]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:15.617]                 }
[10:33:15.617]                 ...future.workdir <- getwd()
[10:33:15.617]             }
[10:33:15.617]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:15.617]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:15.617]         }
[10:33:15.617]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:15.617]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:15.617]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:15.617]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:15.617]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:15.617]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:15.617]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:15.617]             base::names(...future.oldOptions))
[10:33:15.617]     }
[10:33:15.617]     if (FALSE) {
[10:33:15.617]     }
[10:33:15.617]     else {
[10:33:15.617]         if (TRUE) {
[10:33:15.617]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:15.617]                 open = "w")
[10:33:15.617]         }
[10:33:15.617]         else {
[10:33:15.617]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:15.617]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:15.617]         }
[10:33:15.617]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:15.617]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:15.617]             base::sink(type = "output", split = FALSE)
[10:33:15.617]             base::close(...future.stdout)
[10:33:15.617]         }, add = TRUE)
[10:33:15.617]     }
[10:33:15.617]     ...future.frame <- base::sys.nframe()
[10:33:15.617]     ...future.conditions <- base::list()
[10:33:15.617]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:15.617]     if (FALSE) {
[10:33:15.617]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:15.617]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:15.617]     }
[10:33:15.617]     ...future.result <- base::tryCatch({
[10:33:15.617]         base::withCallingHandlers({
[10:33:15.617]             ...future.value <- base::withVisible(base::local({
[10:33:15.617]                 ...future.makeSendCondition <- base::local({
[10:33:15.617]                   sendCondition <- NULL
[10:33:15.617]                   function(frame = 1L) {
[10:33:15.617]                     if (is.function(sendCondition)) 
[10:33:15.617]                       return(sendCondition)
[10:33:15.617]                     ns <- getNamespace("parallel")
[10:33:15.617]                     if (exists("sendData", mode = "function", 
[10:33:15.617]                       envir = ns)) {
[10:33:15.617]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:15.617]                         envir = ns)
[10:33:15.617]                       envir <- sys.frame(frame)
[10:33:15.617]                       master <- NULL
[10:33:15.617]                       while (!identical(envir, .GlobalEnv) && 
[10:33:15.617]                         !identical(envir, emptyenv())) {
[10:33:15.617]                         if (exists("master", mode = "list", envir = envir, 
[10:33:15.617]                           inherits = FALSE)) {
[10:33:15.617]                           master <- get("master", mode = "list", 
[10:33:15.617]                             envir = envir, inherits = FALSE)
[10:33:15.617]                           if (inherits(master, c("SOCKnode", 
[10:33:15.617]                             "SOCK0node"))) {
[10:33:15.617]                             sendCondition <<- function(cond) {
[10:33:15.617]                               data <- list(type = "VALUE", value = cond, 
[10:33:15.617]                                 success = TRUE)
[10:33:15.617]                               parallel_sendData(master, data)
[10:33:15.617]                             }
[10:33:15.617]                             return(sendCondition)
[10:33:15.617]                           }
[10:33:15.617]                         }
[10:33:15.617]                         frame <- frame + 1L
[10:33:15.617]                         envir <- sys.frame(frame)
[10:33:15.617]                       }
[10:33:15.617]                     }
[10:33:15.617]                     sendCondition <<- function(cond) NULL
[10:33:15.617]                   }
[10:33:15.617]                 })
[10:33:15.617]                 withCallingHandlers({
[10:33:15.617]                   {
[10:33:15.617]                     b <- a
[10:33:15.617]                     a <- 2
[10:33:15.617]                     a * b
[10:33:15.617]                   }
[10:33:15.617]                 }, immediateCondition = function(cond) {
[10:33:15.617]                   sendCondition <- ...future.makeSendCondition()
[10:33:15.617]                   sendCondition(cond)
[10:33:15.617]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.617]                   {
[10:33:15.617]                     inherits <- base::inherits
[10:33:15.617]                     invokeRestart <- base::invokeRestart
[10:33:15.617]                     is.null <- base::is.null
[10:33:15.617]                     muffled <- FALSE
[10:33:15.617]                     if (inherits(cond, "message")) {
[10:33:15.617]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:15.617]                       if (muffled) 
[10:33:15.617]                         invokeRestart("muffleMessage")
[10:33:15.617]                     }
[10:33:15.617]                     else if (inherits(cond, "warning")) {
[10:33:15.617]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:15.617]                       if (muffled) 
[10:33:15.617]                         invokeRestart("muffleWarning")
[10:33:15.617]                     }
[10:33:15.617]                     else if (inherits(cond, "condition")) {
[10:33:15.617]                       if (!is.null(pattern)) {
[10:33:15.617]                         computeRestarts <- base::computeRestarts
[10:33:15.617]                         grepl <- base::grepl
[10:33:15.617]                         restarts <- computeRestarts(cond)
[10:33:15.617]                         for (restart in restarts) {
[10:33:15.617]                           name <- restart$name
[10:33:15.617]                           if (is.null(name)) 
[10:33:15.617]                             next
[10:33:15.617]                           if (!grepl(pattern, name)) 
[10:33:15.617]                             next
[10:33:15.617]                           invokeRestart(restart)
[10:33:15.617]                           muffled <- TRUE
[10:33:15.617]                           break
[10:33:15.617]                         }
[10:33:15.617]                       }
[10:33:15.617]                     }
[10:33:15.617]                     invisible(muffled)
[10:33:15.617]                   }
[10:33:15.617]                   muffleCondition(cond)
[10:33:15.617]                 })
[10:33:15.617]             }))
[10:33:15.617]             future::FutureResult(value = ...future.value$value, 
[10:33:15.617]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.617]                   ...future.rng), globalenv = if (FALSE) 
[10:33:15.617]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:15.617]                     ...future.globalenv.names))
[10:33:15.617]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:15.617]         }, condition = base::local({
[10:33:15.617]             c <- base::c
[10:33:15.617]             inherits <- base::inherits
[10:33:15.617]             invokeRestart <- base::invokeRestart
[10:33:15.617]             length <- base::length
[10:33:15.617]             list <- base::list
[10:33:15.617]             seq.int <- base::seq.int
[10:33:15.617]             signalCondition <- base::signalCondition
[10:33:15.617]             sys.calls <- base::sys.calls
[10:33:15.617]             `[[` <- base::`[[`
[10:33:15.617]             `+` <- base::`+`
[10:33:15.617]             `<<-` <- base::`<<-`
[10:33:15.617]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:15.617]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:15.617]                   3L)]
[10:33:15.617]             }
[10:33:15.617]             function(cond) {
[10:33:15.617]                 is_error <- inherits(cond, "error")
[10:33:15.617]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:15.617]                   NULL)
[10:33:15.617]                 if (is_error) {
[10:33:15.617]                   sessionInformation <- function() {
[10:33:15.617]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:15.617]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:15.617]                       search = base::search(), system = base::Sys.info())
[10:33:15.617]                   }
[10:33:15.617]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.617]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:15.617]                     cond$call), session = sessionInformation(), 
[10:33:15.617]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:15.617]                   signalCondition(cond)
[10:33:15.617]                 }
[10:33:15.617]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:15.617]                 "immediateCondition"))) {
[10:33:15.617]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:15.617]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.617]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:15.617]                   if (TRUE && !signal) {
[10:33:15.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.617]                     {
[10:33:15.617]                       inherits <- base::inherits
[10:33:15.617]                       invokeRestart <- base::invokeRestart
[10:33:15.617]                       is.null <- base::is.null
[10:33:15.617]                       muffled <- FALSE
[10:33:15.617]                       if (inherits(cond, "message")) {
[10:33:15.617]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.617]                         if (muffled) 
[10:33:15.617]                           invokeRestart("muffleMessage")
[10:33:15.617]                       }
[10:33:15.617]                       else if (inherits(cond, "warning")) {
[10:33:15.617]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.617]                         if (muffled) 
[10:33:15.617]                           invokeRestart("muffleWarning")
[10:33:15.617]                       }
[10:33:15.617]                       else if (inherits(cond, "condition")) {
[10:33:15.617]                         if (!is.null(pattern)) {
[10:33:15.617]                           computeRestarts <- base::computeRestarts
[10:33:15.617]                           grepl <- base::grepl
[10:33:15.617]                           restarts <- computeRestarts(cond)
[10:33:15.617]                           for (restart in restarts) {
[10:33:15.617]                             name <- restart$name
[10:33:15.617]                             if (is.null(name)) 
[10:33:15.617]                               next
[10:33:15.617]                             if (!grepl(pattern, name)) 
[10:33:15.617]                               next
[10:33:15.617]                             invokeRestart(restart)
[10:33:15.617]                             muffled <- TRUE
[10:33:15.617]                             break
[10:33:15.617]                           }
[10:33:15.617]                         }
[10:33:15.617]                       }
[10:33:15.617]                       invisible(muffled)
[10:33:15.617]                     }
[10:33:15.617]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.617]                   }
[10:33:15.617]                 }
[10:33:15.617]                 else {
[10:33:15.617]                   if (TRUE) {
[10:33:15.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.617]                     {
[10:33:15.617]                       inherits <- base::inherits
[10:33:15.617]                       invokeRestart <- base::invokeRestart
[10:33:15.617]                       is.null <- base::is.null
[10:33:15.617]                       muffled <- FALSE
[10:33:15.617]                       if (inherits(cond, "message")) {
[10:33:15.617]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.617]                         if (muffled) 
[10:33:15.617]                           invokeRestart("muffleMessage")
[10:33:15.617]                       }
[10:33:15.617]                       else if (inherits(cond, "warning")) {
[10:33:15.617]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.617]                         if (muffled) 
[10:33:15.617]                           invokeRestart("muffleWarning")
[10:33:15.617]                       }
[10:33:15.617]                       else if (inherits(cond, "condition")) {
[10:33:15.617]                         if (!is.null(pattern)) {
[10:33:15.617]                           computeRestarts <- base::computeRestarts
[10:33:15.617]                           grepl <- base::grepl
[10:33:15.617]                           restarts <- computeRestarts(cond)
[10:33:15.617]                           for (restart in restarts) {
[10:33:15.617]                             name <- restart$name
[10:33:15.617]                             if (is.null(name)) 
[10:33:15.617]                               next
[10:33:15.617]                             if (!grepl(pattern, name)) 
[10:33:15.617]                               next
[10:33:15.617]                             invokeRestart(restart)
[10:33:15.617]                             muffled <- TRUE
[10:33:15.617]                             break
[10:33:15.617]                           }
[10:33:15.617]                         }
[10:33:15.617]                       }
[10:33:15.617]                       invisible(muffled)
[10:33:15.617]                     }
[10:33:15.617]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.617]                   }
[10:33:15.617]                 }
[10:33:15.617]             }
[10:33:15.617]         }))
[10:33:15.617]     }, error = function(ex) {
[10:33:15.617]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:15.617]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.617]                 ...future.rng), started = ...future.startTime, 
[10:33:15.617]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:15.617]             version = "1.8"), class = "FutureResult")
[10:33:15.617]     }, finally = {
[10:33:15.617]         if (!identical(...future.workdir, getwd())) 
[10:33:15.617]             setwd(...future.workdir)
[10:33:15.617]         {
[10:33:15.617]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:15.617]                 ...future.oldOptions$nwarnings <- NULL
[10:33:15.617]             }
[10:33:15.617]             base::options(...future.oldOptions)
[10:33:15.617]             if (.Platform$OS.type == "windows") {
[10:33:15.617]                 old_names <- names(...future.oldEnvVars)
[10:33:15.617]                 envs <- base::Sys.getenv()
[10:33:15.617]                 names <- names(envs)
[10:33:15.617]                 common <- intersect(names, old_names)
[10:33:15.617]                 added <- setdiff(names, old_names)
[10:33:15.617]                 removed <- setdiff(old_names, names)
[10:33:15.617]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:15.617]                   envs[common]]
[10:33:15.617]                 NAMES <- toupper(changed)
[10:33:15.617]                 args <- list()
[10:33:15.617]                 for (kk in seq_along(NAMES)) {
[10:33:15.617]                   name <- changed[[kk]]
[10:33:15.617]                   NAME <- NAMES[[kk]]
[10:33:15.617]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.617]                     next
[10:33:15.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.617]                 }
[10:33:15.617]                 NAMES <- toupper(added)
[10:33:15.617]                 for (kk in seq_along(NAMES)) {
[10:33:15.617]                   name <- added[[kk]]
[10:33:15.617]                   NAME <- NAMES[[kk]]
[10:33:15.617]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.617]                     next
[10:33:15.617]                   args[[name]] <- ""
[10:33:15.617]                 }
[10:33:15.617]                 NAMES <- toupper(removed)
[10:33:15.617]                 for (kk in seq_along(NAMES)) {
[10:33:15.617]                   name <- removed[[kk]]
[10:33:15.617]                   NAME <- NAMES[[kk]]
[10:33:15.617]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.617]                     next
[10:33:15.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.617]                 }
[10:33:15.617]                 if (length(args) > 0) 
[10:33:15.617]                   base::do.call(base::Sys.setenv, args = args)
[10:33:15.617]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:15.617]             }
[10:33:15.617]             else {
[10:33:15.617]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:15.617]             }
[10:33:15.617]             {
[10:33:15.617]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:15.617]                   0L) {
[10:33:15.617]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:15.617]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:15.617]                   base::options(opts)
[10:33:15.617]                 }
[10:33:15.617]                 {
[10:33:15.617]                   {
[10:33:15.617]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:15.617]                     NULL
[10:33:15.617]                   }
[10:33:15.617]                   options(future.plan = NULL)
[10:33:15.617]                   if (is.na(NA_character_)) 
[10:33:15.617]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.617]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:15.617]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:15.617]                     .init = FALSE)
[10:33:15.617]                 }
[10:33:15.617]             }
[10:33:15.617]         }
[10:33:15.617]     })
[10:33:15.617]     if (TRUE) {
[10:33:15.617]         base::sink(type = "output", split = FALSE)
[10:33:15.617]         if (TRUE) {
[10:33:15.617]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:15.617]         }
[10:33:15.617]         else {
[10:33:15.617]             ...future.result["stdout"] <- base::list(NULL)
[10:33:15.617]         }
[10:33:15.617]         base::close(...future.stdout)
[10:33:15.617]         ...future.stdout <- NULL
[10:33:15.617]     }
[10:33:15.617]     ...future.result$conditions <- ...future.conditions
[10:33:15.617]     ...future.result$finished <- base::Sys.time()
[10:33:15.617]     ...future.result
[10:33:15.617] }
[10:33:15.619] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[10:33:15.620] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[10:33:15.620] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[10:33:15.620] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[10:33:15.621] MultisessionFuture started
[10:33:15.621] - Launch lazy future ... done
[10:33:15.621] run() for ‘MultisessionFuture’ ... done
[10:33:15.621] result() for ClusterFuture ...
[10:33:15.621] receiveMessageFromWorker() for ClusterFuture ...
[10:33:15.621] - Validating connection of MultisessionFuture
[10:33:15.663] - received message: FutureResult
[10:33:15.663] - Received FutureResult
[10:33:15.663] - Erased future from FutureRegistry
[10:33:15.663] result() for ClusterFuture ...
[10:33:15.663] - result already collected: FutureResult
[10:33:15.663] result() for ClusterFuture ... done
[10:33:15.663] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:15.663] result() for ClusterFuture ... done
[10:33:15.663] result() for ClusterFuture ...
[10:33:15.663] - result already collected: FutureResult
[10:33:15.664] result() for ClusterFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:15.664] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:15.664] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:15.666] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:33:15.666] Searching for globals ... DONE
[10:33:15.666] Resolving globals: TRUE
[10:33:15.666] Resolving any globals that are futures ...
[10:33:15.666] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:33:15.666] Resolving any globals that are futures ... DONE
[10:33:15.667] Resolving futures part of globals (recursively) ...
[10:33:15.667] resolve() on list ...
[10:33:15.667]  recursive: 99
[10:33:15.667]  length: 1
[10:33:15.668]  elements: ‘a’
[10:33:15.668]  length: 0 (resolved future 1)
[10:33:15.668] resolve() on list ... DONE
[10:33:15.668] - globals: [1] ‘a’
[10:33:15.668] Resolving futures part of globals (recursively) ... DONE
[10:33:15.668] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:15.668] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:33:15.669] - globals: [1] ‘a’
[10:33:15.669] 
[10:33:15.669] getGlobalsAndPackages() ... DONE
[10:33:15.669] run() for ‘Future’ ...
[10:33:15.669] - state: ‘created’
[10:33:15.669] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:15.683] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:15.683] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:15.683]   - Field: ‘node’
[10:33:15.683]   - Field: ‘label’
[10:33:15.683]   - Field: ‘local’
[10:33:15.683]   - Field: ‘owner’
[10:33:15.684]   - Field: ‘envir’
[10:33:15.684]   - Field: ‘workers’
[10:33:15.684]   - Field: ‘packages’
[10:33:15.684]   - Field: ‘gc’
[10:33:15.684]   - Field: ‘conditions’
[10:33:15.684]   - Field: ‘persistent’
[10:33:15.684]   - Field: ‘expr’
[10:33:15.684]   - Field: ‘uuid’
[10:33:15.684]   - Field: ‘seed’
[10:33:15.684]   - Field: ‘version’
[10:33:15.684]   - Field: ‘result’
[10:33:15.684]   - Field: ‘asynchronous’
[10:33:15.685]   - Field: ‘calls’
[10:33:15.685]   - Field: ‘globals’
[10:33:15.685]   - Field: ‘stdout’
[10:33:15.685]   - Field: ‘earlySignal’
[10:33:15.685]   - Field: ‘lazy’
[10:33:15.685]   - Field: ‘state’
[10:33:15.685] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:15.685] - Launch lazy future ...
[10:33:15.686] Packages needed by the future expression (n = 0): <none>
[10:33:15.686] Packages needed by future strategies (n = 0): <none>
[10:33:15.686] {
[10:33:15.686]     {
[10:33:15.686]         {
[10:33:15.686]             ...future.startTime <- base::Sys.time()
[10:33:15.686]             {
[10:33:15.686]                 {
[10:33:15.686]                   {
[10:33:15.686]                     {
[10:33:15.686]                       base::local({
[10:33:15.686]                         has_future <- base::requireNamespace("future", 
[10:33:15.686]                           quietly = TRUE)
[10:33:15.686]                         if (has_future) {
[10:33:15.686]                           ns <- base::getNamespace("future")
[10:33:15.686]                           version <- ns[[".package"]][["version"]]
[10:33:15.686]                           if (is.null(version)) 
[10:33:15.686]                             version <- utils::packageVersion("future")
[10:33:15.686]                         }
[10:33:15.686]                         else {
[10:33:15.686]                           version <- NULL
[10:33:15.686]                         }
[10:33:15.686]                         if (!has_future || version < "1.8.0") {
[10:33:15.686]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:15.686]                             "", base::R.version$version.string), 
[10:33:15.686]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:15.686]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:15.686]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:15.686]                               "release", "version")], collapse = " "), 
[10:33:15.686]                             hostname = base::Sys.info()[["nodename"]])
[10:33:15.686]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:15.686]                             info)
[10:33:15.686]                           info <- base::paste(info, collapse = "; ")
[10:33:15.686]                           if (!has_future) {
[10:33:15.686]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:15.686]                               info)
[10:33:15.686]                           }
[10:33:15.686]                           else {
[10:33:15.686]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:15.686]                               info, version)
[10:33:15.686]                           }
[10:33:15.686]                           base::stop(msg)
[10:33:15.686]                         }
[10:33:15.686]                       })
[10:33:15.686]                     }
[10:33:15.686]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:15.686]                     base::options(mc.cores = 1L)
[10:33:15.686]                   }
[10:33:15.686]                   ...future.strategy.old <- future::plan("list")
[10:33:15.686]                   options(future.plan = NULL)
[10:33:15.686]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.686]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:15.686]                 }
[10:33:15.686]                 ...future.workdir <- getwd()
[10:33:15.686]             }
[10:33:15.686]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:15.686]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:15.686]         }
[10:33:15.686]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:15.686]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:15.686]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:15.686]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:15.686]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:15.686]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:15.686]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:15.686]             base::names(...future.oldOptions))
[10:33:15.686]     }
[10:33:15.686]     if (FALSE) {
[10:33:15.686]     }
[10:33:15.686]     else {
[10:33:15.686]         if (TRUE) {
[10:33:15.686]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:15.686]                 open = "w")
[10:33:15.686]         }
[10:33:15.686]         else {
[10:33:15.686]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:15.686]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:15.686]         }
[10:33:15.686]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:15.686]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:15.686]             base::sink(type = "output", split = FALSE)
[10:33:15.686]             base::close(...future.stdout)
[10:33:15.686]         }, add = TRUE)
[10:33:15.686]     }
[10:33:15.686]     ...future.frame <- base::sys.nframe()
[10:33:15.686]     ...future.conditions <- base::list()
[10:33:15.686]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:15.686]     if (FALSE) {
[10:33:15.686]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:15.686]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:15.686]     }
[10:33:15.686]     ...future.result <- base::tryCatch({
[10:33:15.686]         base::withCallingHandlers({
[10:33:15.686]             ...future.value <- base::withVisible(base::local({
[10:33:15.686]                 ...future.makeSendCondition <- base::local({
[10:33:15.686]                   sendCondition <- NULL
[10:33:15.686]                   function(frame = 1L) {
[10:33:15.686]                     if (is.function(sendCondition)) 
[10:33:15.686]                       return(sendCondition)
[10:33:15.686]                     ns <- getNamespace("parallel")
[10:33:15.686]                     if (exists("sendData", mode = "function", 
[10:33:15.686]                       envir = ns)) {
[10:33:15.686]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:15.686]                         envir = ns)
[10:33:15.686]                       envir <- sys.frame(frame)
[10:33:15.686]                       master <- NULL
[10:33:15.686]                       while (!identical(envir, .GlobalEnv) && 
[10:33:15.686]                         !identical(envir, emptyenv())) {
[10:33:15.686]                         if (exists("master", mode = "list", envir = envir, 
[10:33:15.686]                           inherits = FALSE)) {
[10:33:15.686]                           master <- get("master", mode = "list", 
[10:33:15.686]                             envir = envir, inherits = FALSE)
[10:33:15.686]                           if (inherits(master, c("SOCKnode", 
[10:33:15.686]                             "SOCK0node"))) {
[10:33:15.686]                             sendCondition <<- function(cond) {
[10:33:15.686]                               data <- list(type = "VALUE", value = cond, 
[10:33:15.686]                                 success = TRUE)
[10:33:15.686]                               parallel_sendData(master, data)
[10:33:15.686]                             }
[10:33:15.686]                             return(sendCondition)
[10:33:15.686]                           }
[10:33:15.686]                         }
[10:33:15.686]                         frame <- frame + 1L
[10:33:15.686]                         envir <- sys.frame(frame)
[10:33:15.686]                       }
[10:33:15.686]                     }
[10:33:15.686]                     sendCondition <<- function(cond) NULL
[10:33:15.686]                   }
[10:33:15.686]                 })
[10:33:15.686]                 withCallingHandlers({
[10:33:15.686]                   {
[10:33:15.686]                     b <- a
[10:33:15.686]                     a <- 2
[10:33:15.686]                     a * b
[10:33:15.686]                   }
[10:33:15.686]                 }, immediateCondition = function(cond) {
[10:33:15.686]                   sendCondition <- ...future.makeSendCondition()
[10:33:15.686]                   sendCondition(cond)
[10:33:15.686]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.686]                   {
[10:33:15.686]                     inherits <- base::inherits
[10:33:15.686]                     invokeRestart <- base::invokeRestart
[10:33:15.686]                     is.null <- base::is.null
[10:33:15.686]                     muffled <- FALSE
[10:33:15.686]                     if (inherits(cond, "message")) {
[10:33:15.686]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:15.686]                       if (muffled) 
[10:33:15.686]                         invokeRestart("muffleMessage")
[10:33:15.686]                     }
[10:33:15.686]                     else if (inherits(cond, "warning")) {
[10:33:15.686]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:15.686]                       if (muffled) 
[10:33:15.686]                         invokeRestart("muffleWarning")
[10:33:15.686]                     }
[10:33:15.686]                     else if (inherits(cond, "condition")) {
[10:33:15.686]                       if (!is.null(pattern)) {
[10:33:15.686]                         computeRestarts <- base::computeRestarts
[10:33:15.686]                         grepl <- base::grepl
[10:33:15.686]                         restarts <- computeRestarts(cond)
[10:33:15.686]                         for (restart in restarts) {
[10:33:15.686]                           name <- restart$name
[10:33:15.686]                           if (is.null(name)) 
[10:33:15.686]                             next
[10:33:15.686]                           if (!grepl(pattern, name)) 
[10:33:15.686]                             next
[10:33:15.686]                           invokeRestart(restart)
[10:33:15.686]                           muffled <- TRUE
[10:33:15.686]                           break
[10:33:15.686]                         }
[10:33:15.686]                       }
[10:33:15.686]                     }
[10:33:15.686]                     invisible(muffled)
[10:33:15.686]                   }
[10:33:15.686]                   muffleCondition(cond)
[10:33:15.686]                 })
[10:33:15.686]             }))
[10:33:15.686]             future::FutureResult(value = ...future.value$value, 
[10:33:15.686]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.686]                   ...future.rng), globalenv = if (FALSE) 
[10:33:15.686]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:15.686]                     ...future.globalenv.names))
[10:33:15.686]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:15.686]         }, condition = base::local({
[10:33:15.686]             c <- base::c
[10:33:15.686]             inherits <- base::inherits
[10:33:15.686]             invokeRestart <- base::invokeRestart
[10:33:15.686]             length <- base::length
[10:33:15.686]             list <- base::list
[10:33:15.686]             seq.int <- base::seq.int
[10:33:15.686]             signalCondition <- base::signalCondition
[10:33:15.686]             sys.calls <- base::sys.calls
[10:33:15.686]             `[[` <- base::`[[`
[10:33:15.686]             `+` <- base::`+`
[10:33:15.686]             `<<-` <- base::`<<-`
[10:33:15.686]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:15.686]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:15.686]                   3L)]
[10:33:15.686]             }
[10:33:15.686]             function(cond) {
[10:33:15.686]                 is_error <- inherits(cond, "error")
[10:33:15.686]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:15.686]                   NULL)
[10:33:15.686]                 if (is_error) {
[10:33:15.686]                   sessionInformation <- function() {
[10:33:15.686]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:15.686]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:15.686]                       search = base::search(), system = base::Sys.info())
[10:33:15.686]                   }
[10:33:15.686]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.686]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:15.686]                     cond$call), session = sessionInformation(), 
[10:33:15.686]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:15.686]                   signalCondition(cond)
[10:33:15.686]                 }
[10:33:15.686]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:15.686]                 "immediateCondition"))) {
[10:33:15.686]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:15.686]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.686]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:15.686]                   if (TRUE && !signal) {
[10:33:15.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.686]                     {
[10:33:15.686]                       inherits <- base::inherits
[10:33:15.686]                       invokeRestart <- base::invokeRestart
[10:33:15.686]                       is.null <- base::is.null
[10:33:15.686]                       muffled <- FALSE
[10:33:15.686]                       if (inherits(cond, "message")) {
[10:33:15.686]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.686]                         if (muffled) 
[10:33:15.686]                           invokeRestart("muffleMessage")
[10:33:15.686]                       }
[10:33:15.686]                       else if (inherits(cond, "warning")) {
[10:33:15.686]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.686]                         if (muffled) 
[10:33:15.686]                           invokeRestart("muffleWarning")
[10:33:15.686]                       }
[10:33:15.686]                       else if (inherits(cond, "condition")) {
[10:33:15.686]                         if (!is.null(pattern)) {
[10:33:15.686]                           computeRestarts <- base::computeRestarts
[10:33:15.686]                           grepl <- base::grepl
[10:33:15.686]                           restarts <- computeRestarts(cond)
[10:33:15.686]                           for (restart in restarts) {
[10:33:15.686]                             name <- restart$name
[10:33:15.686]                             if (is.null(name)) 
[10:33:15.686]                               next
[10:33:15.686]                             if (!grepl(pattern, name)) 
[10:33:15.686]                               next
[10:33:15.686]                             invokeRestart(restart)
[10:33:15.686]                             muffled <- TRUE
[10:33:15.686]                             break
[10:33:15.686]                           }
[10:33:15.686]                         }
[10:33:15.686]                       }
[10:33:15.686]                       invisible(muffled)
[10:33:15.686]                     }
[10:33:15.686]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.686]                   }
[10:33:15.686]                 }
[10:33:15.686]                 else {
[10:33:15.686]                   if (TRUE) {
[10:33:15.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.686]                     {
[10:33:15.686]                       inherits <- base::inherits
[10:33:15.686]                       invokeRestart <- base::invokeRestart
[10:33:15.686]                       is.null <- base::is.null
[10:33:15.686]                       muffled <- FALSE
[10:33:15.686]                       if (inherits(cond, "message")) {
[10:33:15.686]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.686]                         if (muffled) 
[10:33:15.686]                           invokeRestart("muffleMessage")
[10:33:15.686]                       }
[10:33:15.686]                       else if (inherits(cond, "warning")) {
[10:33:15.686]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.686]                         if (muffled) 
[10:33:15.686]                           invokeRestart("muffleWarning")
[10:33:15.686]                       }
[10:33:15.686]                       else if (inherits(cond, "condition")) {
[10:33:15.686]                         if (!is.null(pattern)) {
[10:33:15.686]                           computeRestarts <- base::computeRestarts
[10:33:15.686]                           grepl <- base::grepl
[10:33:15.686]                           restarts <- computeRestarts(cond)
[10:33:15.686]                           for (restart in restarts) {
[10:33:15.686]                             name <- restart$name
[10:33:15.686]                             if (is.null(name)) 
[10:33:15.686]                               next
[10:33:15.686]                             if (!grepl(pattern, name)) 
[10:33:15.686]                               next
[10:33:15.686]                             invokeRestart(restart)
[10:33:15.686]                             muffled <- TRUE
[10:33:15.686]                             break
[10:33:15.686]                           }
[10:33:15.686]                         }
[10:33:15.686]                       }
[10:33:15.686]                       invisible(muffled)
[10:33:15.686]                     }
[10:33:15.686]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.686]                   }
[10:33:15.686]                 }
[10:33:15.686]             }
[10:33:15.686]         }))
[10:33:15.686]     }, error = function(ex) {
[10:33:15.686]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:15.686]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.686]                 ...future.rng), started = ...future.startTime, 
[10:33:15.686]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:15.686]             version = "1.8"), class = "FutureResult")
[10:33:15.686]     }, finally = {
[10:33:15.686]         if (!identical(...future.workdir, getwd())) 
[10:33:15.686]             setwd(...future.workdir)
[10:33:15.686]         {
[10:33:15.686]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:15.686]                 ...future.oldOptions$nwarnings <- NULL
[10:33:15.686]             }
[10:33:15.686]             base::options(...future.oldOptions)
[10:33:15.686]             if (.Platform$OS.type == "windows") {
[10:33:15.686]                 old_names <- names(...future.oldEnvVars)
[10:33:15.686]                 envs <- base::Sys.getenv()
[10:33:15.686]                 names <- names(envs)
[10:33:15.686]                 common <- intersect(names, old_names)
[10:33:15.686]                 added <- setdiff(names, old_names)
[10:33:15.686]                 removed <- setdiff(old_names, names)
[10:33:15.686]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:15.686]                   envs[common]]
[10:33:15.686]                 NAMES <- toupper(changed)
[10:33:15.686]                 args <- list()
[10:33:15.686]                 for (kk in seq_along(NAMES)) {
[10:33:15.686]                   name <- changed[[kk]]
[10:33:15.686]                   NAME <- NAMES[[kk]]
[10:33:15.686]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.686]                     next
[10:33:15.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.686]                 }
[10:33:15.686]                 NAMES <- toupper(added)
[10:33:15.686]                 for (kk in seq_along(NAMES)) {
[10:33:15.686]                   name <- added[[kk]]
[10:33:15.686]                   NAME <- NAMES[[kk]]
[10:33:15.686]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.686]                     next
[10:33:15.686]                   args[[name]] <- ""
[10:33:15.686]                 }
[10:33:15.686]                 NAMES <- toupper(removed)
[10:33:15.686]                 for (kk in seq_along(NAMES)) {
[10:33:15.686]                   name <- removed[[kk]]
[10:33:15.686]                   NAME <- NAMES[[kk]]
[10:33:15.686]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.686]                     next
[10:33:15.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.686]                 }
[10:33:15.686]                 if (length(args) > 0) 
[10:33:15.686]                   base::do.call(base::Sys.setenv, args = args)
[10:33:15.686]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:15.686]             }
[10:33:15.686]             else {
[10:33:15.686]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:15.686]             }
[10:33:15.686]             {
[10:33:15.686]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:15.686]                   0L) {
[10:33:15.686]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:15.686]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:15.686]                   base::options(opts)
[10:33:15.686]                 }
[10:33:15.686]                 {
[10:33:15.686]                   {
[10:33:15.686]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:15.686]                     NULL
[10:33:15.686]                   }
[10:33:15.686]                   options(future.plan = NULL)
[10:33:15.686]                   if (is.na(NA_character_)) 
[10:33:15.686]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.686]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:15.686]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:15.686]                     .init = FALSE)
[10:33:15.686]                 }
[10:33:15.686]             }
[10:33:15.686]         }
[10:33:15.686]     })
[10:33:15.686]     if (TRUE) {
[10:33:15.686]         base::sink(type = "output", split = FALSE)
[10:33:15.686]         if (TRUE) {
[10:33:15.686]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:15.686]         }
[10:33:15.686]         else {
[10:33:15.686]             ...future.result["stdout"] <- base::list(NULL)
[10:33:15.686]         }
[10:33:15.686]         base::close(...future.stdout)
[10:33:15.686]         ...future.stdout <- NULL
[10:33:15.686]     }
[10:33:15.686]     ...future.result$conditions <- ...future.conditions
[10:33:15.686]     ...future.result$finished <- base::Sys.time()
[10:33:15.686]     ...future.result
[10:33:15.686] }
[10:33:15.689] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[10:33:15.689] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[10:33:15.689] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[10:33:15.689] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[10:33:15.690] MultisessionFuture started
[10:33:15.690] - Launch lazy future ... done
[10:33:15.690] run() for ‘MultisessionFuture’ ... done
[10:33:15.690] result() for ClusterFuture ...
[10:33:15.690] receiveMessageFromWorker() for ClusterFuture ...
[10:33:15.690] - Validating connection of MultisessionFuture
[10:33:15.735] - received message: FutureResult
[10:33:15.735] - Received FutureResult
[10:33:15.735] - Erased future from FutureRegistry
[10:33:15.735] result() for ClusterFuture ...
[10:33:15.735] - result already collected: FutureResult
[10:33:15.735] result() for ClusterFuture ... done
[10:33:15.735] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:15.735] result() for ClusterFuture ... done
[10:33:15.735] result() for ClusterFuture ...
[10:33:15.735] - result already collected: FutureResult
[10:33:15.736] result() for ClusterFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:15.736] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:15.736] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:15.738] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:15.738] Searching for globals ... DONE
[10:33:15.738] Resolving globals: TRUE
[10:33:15.739] Resolving any globals that are futures ...
[10:33:15.739] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:15.739] Resolving any globals that are futures ... DONE
[10:33:15.739] Resolving futures part of globals (recursively) ...
[10:33:15.739] resolve() on list ...
[10:33:15.739]  recursive: 99
[10:33:15.740]  length: 2
[10:33:15.740]  elements: ‘a’, ‘ii’
[10:33:15.740]  length: 1 (resolved future 1)
[10:33:15.740]  length: 0 (resolved future 2)
[10:33:15.740] resolve() on list ... DONE
[10:33:15.740] - globals: [2] ‘a’, ‘ii’
[10:33:15.740] Resolving futures part of globals (recursively) ... DONE
[10:33:15.740] The total size of the 2 globals is 112 bytes (112 bytes)
[10:33:15.741] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:33:15.741] - globals: [2] ‘a’, ‘ii’
[10:33:15.741] 
[10:33:15.741] getGlobalsAndPackages() ... DONE
[10:33:15.741] run() for ‘Future’ ...
[10:33:15.741] - state: ‘created’
[10:33:15.741] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:15.757] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:15.757] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:15.757]   - Field: ‘node’
[10:33:15.758]   - Field: ‘label’
[10:33:15.758]   - Field: ‘local’
[10:33:15.758]   - Field: ‘owner’
[10:33:15.758]   - Field: ‘envir’
[10:33:15.758]   - Field: ‘workers’
[10:33:15.758]   - Field: ‘packages’
[10:33:15.758]   - Field: ‘gc’
[10:33:15.758]   - Field: ‘conditions’
[10:33:15.758]   - Field: ‘persistent’
[10:33:15.758]   - Field: ‘expr’
[10:33:15.758]   - Field: ‘uuid’
[10:33:15.758]   - Field: ‘seed’
[10:33:15.759]   - Field: ‘version’
[10:33:15.759]   - Field: ‘result’
[10:33:15.759]   - Field: ‘asynchronous’
[10:33:15.759]   - Field: ‘calls’
[10:33:15.759]   - Field: ‘globals’
[10:33:15.759]   - Field: ‘stdout’
[10:33:15.759]   - Field: ‘earlySignal’
[10:33:15.759]   - Field: ‘lazy’
[10:33:15.759]   - Field: ‘state’
[10:33:15.759] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:15.759] - Launch lazy future ...
[10:33:15.760] Packages needed by the future expression (n = 0): <none>
[10:33:15.760] Packages needed by future strategies (n = 0): <none>
[10:33:15.760] {
[10:33:15.760]     {
[10:33:15.760]         {
[10:33:15.760]             ...future.startTime <- base::Sys.time()
[10:33:15.760]             {
[10:33:15.760]                 {
[10:33:15.760]                   {
[10:33:15.760]                     {
[10:33:15.760]                       base::local({
[10:33:15.760]                         has_future <- base::requireNamespace("future", 
[10:33:15.760]                           quietly = TRUE)
[10:33:15.760]                         if (has_future) {
[10:33:15.760]                           ns <- base::getNamespace("future")
[10:33:15.760]                           version <- ns[[".package"]][["version"]]
[10:33:15.760]                           if (is.null(version)) 
[10:33:15.760]                             version <- utils::packageVersion("future")
[10:33:15.760]                         }
[10:33:15.760]                         else {
[10:33:15.760]                           version <- NULL
[10:33:15.760]                         }
[10:33:15.760]                         if (!has_future || version < "1.8.0") {
[10:33:15.760]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:15.760]                             "", base::R.version$version.string), 
[10:33:15.760]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:15.760]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:15.760]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:15.760]                               "release", "version")], collapse = " "), 
[10:33:15.760]                             hostname = base::Sys.info()[["nodename"]])
[10:33:15.760]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:15.760]                             info)
[10:33:15.760]                           info <- base::paste(info, collapse = "; ")
[10:33:15.760]                           if (!has_future) {
[10:33:15.760]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:15.760]                               info)
[10:33:15.760]                           }
[10:33:15.760]                           else {
[10:33:15.760]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:15.760]                               info, version)
[10:33:15.760]                           }
[10:33:15.760]                           base::stop(msg)
[10:33:15.760]                         }
[10:33:15.760]                       })
[10:33:15.760]                     }
[10:33:15.760]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:15.760]                     base::options(mc.cores = 1L)
[10:33:15.760]                   }
[10:33:15.760]                   ...future.strategy.old <- future::plan("list")
[10:33:15.760]                   options(future.plan = NULL)
[10:33:15.760]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.760]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:15.760]                 }
[10:33:15.760]                 ...future.workdir <- getwd()
[10:33:15.760]             }
[10:33:15.760]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:15.760]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:15.760]         }
[10:33:15.760]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:15.760]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:15.760]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:15.760]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:15.760]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:15.760]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:15.760]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:15.760]             base::names(...future.oldOptions))
[10:33:15.760]     }
[10:33:15.760]     if (FALSE) {
[10:33:15.760]     }
[10:33:15.760]     else {
[10:33:15.760]         if (TRUE) {
[10:33:15.760]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:15.760]                 open = "w")
[10:33:15.760]         }
[10:33:15.760]         else {
[10:33:15.760]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:15.760]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:15.760]         }
[10:33:15.760]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:15.760]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:15.760]             base::sink(type = "output", split = FALSE)
[10:33:15.760]             base::close(...future.stdout)
[10:33:15.760]         }, add = TRUE)
[10:33:15.760]     }
[10:33:15.760]     ...future.frame <- base::sys.nframe()
[10:33:15.760]     ...future.conditions <- base::list()
[10:33:15.760]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:15.760]     if (FALSE) {
[10:33:15.760]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:15.760]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:15.760]     }
[10:33:15.760]     ...future.result <- base::tryCatch({
[10:33:15.760]         base::withCallingHandlers({
[10:33:15.760]             ...future.value <- base::withVisible(base::local({
[10:33:15.760]                 ...future.makeSendCondition <- base::local({
[10:33:15.760]                   sendCondition <- NULL
[10:33:15.760]                   function(frame = 1L) {
[10:33:15.760]                     if (is.function(sendCondition)) 
[10:33:15.760]                       return(sendCondition)
[10:33:15.760]                     ns <- getNamespace("parallel")
[10:33:15.760]                     if (exists("sendData", mode = "function", 
[10:33:15.760]                       envir = ns)) {
[10:33:15.760]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:15.760]                         envir = ns)
[10:33:15.760]                       envir <- sys.frame(frame)
[10:33:15.760]                       master <- NULL
[10:33:15.760]                       while (!identical(envir, .GlobalEnv) && 
[10:33:15.760]                         !identical(envir, emptyenv())) {
[10:33:15.760]                         if (exists("master", mode = "list", envir = envir, 
[10:33:15.760]                           inherits = FALSE)) {
[10:33:15.760]                           master <- get("master", mode = "list", 
[10:33:15.760]                             envir = envir, inherits = FALSE)
[10:33:15.760]                           if (inherits(master, c("SOCKnode", 
[10:33:15.760]                             "SOCK0node"))) {
[10:33:15.760]                             sendCondition <<- function(cond) {
[10:33:15.760]                               data <- list(type = "VALUE", value = cond, 
[10:33:15.760]                                 success = TRUE)
[10:33:15.760]                               parallel_sendData(master, data)
[10:33:15.760]                             }
[10:33:15.760]                             return(sendCondition)
[10:33:15.760]                           }
[10:33:15.760]                         }
[10:33:15.760]                         frame <- frame + 1L
[10:33:15.760]                         envir <- sys.frame(frame)
[10:33:15.760]                       }
[10:33:15.760]                     }
[10:33:15.760]                     sendCondition <<- function(cond) NULL
[10:33:15.760]                   }
[10:33:15.760]                 })
[10:33:15.760]                 withCallingHandlers({
[10:33:15.760]                   {
[10:33:15.760]                     b <- a * ii
[10:33:15.760]                     a <- 0
[10:33:15.760]                     b
[10:33:15.760]                   }
[10:33:15.760]                 }, immediateCondition = function(cond) {
[10:33:15.760]                   sendCondition <- ...future.makeSendCondition()
[10:33:15.760]                   sendCondition(cond)
[10:33:15.760]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.760]                   {
[10:33:15.760]                     inherits <- base::inherits
[10:33:15.760]                     invokeRestart <- base::invokeRestart
[10:33:15.760]                     is.null <- base::is.null
[10:33:15.760]                     muffled <- FALSE
[10:33:15.760]                     if (inherits(cond, "message")) {
[10:33:15.760]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:15.760]                       if (muffled) 
[10:33:15.760]                         invokeRestart("muffleMessage")
[10:33:15.760]                     }
[10:33:15.760]                     else if (inherits(cond, "warning")) {
[10:33:15.760]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:15.760]                       if (muffled) 
[10:33:15.760]                         invokeRestart("muffleWarning")
[10:33:15.760]                     }
[10:33:15.760]                     else if (inherits(cond, "condition")) {
[10:33:15.760]                       if (!is.null(pattern)) {
[10:33:15.760]                         computeRestarts <- base::computeRestarts
[10:33:15.760]                         grepl <- base::grepl
[10:33:15.760]                         restarts <- computeRestarts(cond)
[10:33:15.760]                         for (restart in restarts) {
[10:33:15.760]                           name <- restart$name
[10:33:15.760]                           if (is.null(name)) 
[10:33:15.760]                             next
[10:33:15.760]                           if (!grepl(pattern, name)) 
[10:33:15.760]                             next
[10:33:15.760]                           invokeRestart(restart)
[10:33:15.760]                           muffled <- TRUE
[10:33:15.760]                           break
[10:33:15.760]                         }
[10:33:15.760]                       }
[10:33:15.760]                     }
[10:33:15.760]                     invisible(muffled)
[10:33:15.760]                   }
[10:33:15.760]                   muffleCondition(cond)
[10:33:15.760]                 })
[10:33:15.760]             }))
[10:33:15.760]             future::FutureResult(value = ...future.value$value, 
[10:33:15.760]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.760]                   ...future.rng), globalenv = if (FALSE) 
[10:33:15.760]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:15.760]                     ...future.globalenv.names))
[10:33:15.760]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:15.760]         }, condition = base::local({
[10:33:15.760]             c <- base::c
[10:33:15.760]             inherits <- base::inherits
[10:33:15.760]             invokeRestart <- base::invokeRestart
[10:33:15.760]             length <- base::length
[10:33:15.760]             list <- base::list
[10:33:15.760]             seq.int <- base::seq.int
[10:33:15.760]             signalCondition <- base::signalCondition
[10:33:15.760]             sys.calls <- base::sys.calls
[10:33:15.760]             `[[` <- base::`[[`
[10:33:15.760]             `+` <- base::`+`
[10:33:15.760]             `<<-` <- base::`<<-`
[10:33:15.760]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:15.760]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:15.760]                   3L)]
[10:33:15.760]             }
[10:33:15.760]             function(cond) {
[10:33:15.760]                 is_error <- inherits(cond, "error")
[10:33:15.760]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:15.760]                   NULL)
[10:33:15.760]                 if (is_error) {
[10:33:15.760]                   sessionInformation <- function() {
[10:33:15.760]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:15.760]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:15.760]                       search = base::search(), system = base::Sys.info())
[10:33:15.760]                   }
[10:33:15.760]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.760]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:15.760]                     cond$call), session = sessionInformation(), 
[10:33:15.760]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:15.760]                   signalCondition(cond)
[10:33:15.760]                 }
[10:33:15.760]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:15.760]                 "immediateCondition"))) {
[10:33:15.760]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:15.760]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.760]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:15.760]                   if (TRUE && !signal) {
[10:33:15.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.760]                     {
[10:33:15.760]                       inherits <- base::inherits
[10:33:15.760]                       invokeRestart <- base::invokeRestart
[10:33:15.760]                       is.null <- base::is.null
[10:33:15.760]                       muffled <- FALSE
[10:33:15.760]                       if (inherits(cond, "message")) {
[10:33:15.760]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.760]                         if (muffled) 
[10:33:15.760]                           invokeRestart("muffleMessage")
[10:33:15.760]                       }
[10:33:15.760]                       else if (inherits(cond, "warning")) {
[10:33:15.760]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.760]                         if (muffled) 
[10:33:15.760]                           invokeRestart("muffleWarning")
[10:33:15.760]                       }
[10:33:15.760]                       else if (inherits(cond, "condition")) {
[10:33:15.760]                         if (!is.null(pattern)) {
[10:33:15.760]                           computeRestarts <- base::computeRestarts
[10:33:15.760]                           grepl <- base::grepl
[10:33:15.760]                           restarts <- computeRestarts(cond)
[10:33:15.760]                           for (restart in restarts) {
[10:33:15.760]                             name <- restart$name
[10:33:15.760]                             if (is.null(name)) 
[10:33:15.760]                               next
[10:33:15.760]                             if (!grepl(pattern, name)) 
[10:33:15.760]                               next
[10:33:15.760]                             invokeRestart(restart)
[10:33:15.760]                             muffled <- TRUE
[10:33:15.760]                             break
[10:33:15.760]                           }
[10:33:15.760]                         }
[10:33:15.760]                       }
[10:33:15.760]                       invisible(muffled)
[10:33:15.760]                     }
[10:33:15.760]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.760]                   }
[10:33:15.760]                 }
[10:33:15.760]                 else {
[10:33:15.760]                   if (TRUE) {
[10:33:15.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.760]                     {
[10:33:15.760]                       inherits <- base::inherits
[10:33:15.760]                       invokeRestart <- base::invokeRestart
[10:33:15.760]                       is.null <- base::is.null
[10:33:15.760]                       muffled <- FALSE
[10:33:15.760]                       if (inherits(cond, "message")) {
[10:33:15.760]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.760]                         if (muffled) 
[10:33:15.760]                           invokeRestart("muffleMessage")
[10:33:15.760]                       }
[10:33:15.760]                       else if (inherits(cond, "warning")) {
[10:33:15.760]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.760]                         if (muffled) 
[10:33:15.760]                           invokeRestart("muffleWarning")
[10:33:15.760]                       }
[10:33:15.760]                       else if (inherits(cond, "condition")) {
[10:33:15.760]                         if (!is.null(pattern)) {
[10:33:15.760]                           computeRestarts <- base::computeRestarts
[10:33:15.760]                           grepl <- base::grepl
[10:33:15.760]                           restarts <- computeRestarts(cond)
[10:33:15.760]                           for (restart in restarts) {
[10:33:15.760]                             name <- restart$name
[10:33:15.760]                             if (is.null(name)) 
[10:33:15.760]                               next
[10:33:15.760]                             if (!grepl(pattern, name)) 
[10:33:15.760]                               next
[10:33:15.760]                             invokeRestart(restart)
[10:33:15.760]                             muffled <- TRUE
[10:33:15.760]                             break
[10:33:15.760]                           }
[10:33:15.760]                         }
[10:33:15.760]                       }
[10:33:15.760]                       invisible(muffled)
[10:33:15.760]                     }
[10:33:15.760]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.760]                   }
[10:33:15.760]                 }
[10:33:15.760]             }
[10:33:15.760]         }))
[10:33:15.760]     }, error = function(ex) {
[10:33:15.760]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:15.760]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.760]                 ...future.rng), started = ...future.startTime, 
[10:33:15.760]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:15.760]             version = "1.8"), class = "FutureResult")
[10:33:15.760]     }, finally = {
[10:33:15.760]         if (!identical(...future.workdir, getwd())) 
[10:33:15.760]             setwd(...future.workdir)
[10:33:15.760]         {
[10:33:15.760]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:15.760]                 ...future.oldOptions$nwarnings <- NULL
[10:33:15.760]             }
[10:33:15.760]             base::options(...future.oldOptions)
[10:33:15.760]             if (.Platform$OS.type == "windows") {
[10:33:15.760]                 old_names <- names(...future.oldEnvVars)
[10:33:15.760]                 envs <- base::Sys.getenv()
[10:33:15.760]                 names <- names(envs)
[10:33:15.760]                 common <- intersect(names, old_names)
[10:33:15.760]                 added <- setdiff(names, old_names)
[10:33:15.760]                 removed <- setdiff(old_names, names)
[10:33:15.760]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:15.760]                   envs[common]]
[10:33:15.760]                 NAMES <- toupper(changed)
[10:33:15.760]                 args <- list()
[10:33:15.760]                 for (kk in seq_along(NAMES)) {
[10:33:15.760]                   name <- changed[[kk]]
[10:33:15.760]                   NAME <- NAMES[[kk]]
[10:33:15.760]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.760]                     next
[10:33:15.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.760]                 }
[10:33:15.760]                 NAMES <- toupper(added)
[10:33:15.760]                 for (kk in seq_along(NAMES)) {
[10:33:15.760]                   name <- added[[kk]]
[10:33:15.760]                   NAME <- NAMES[[kk]]
[10:33:15.760]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.760]                     next
[10:33:15.760]                   args[[name]] <- ""
[10:33:15.760]                 }
[10:33:15.760]                 NAMES <- toupper(removed)
[10:33:15.760]                 for (kk in seq_along(NAMES)) {
[10:33:15.760]                   name <- removed[[kk]]
[10:33:15.760]                   NAME <- NAMES[[kk]]
[10:33:15.760]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.760]                     next
[10:33:15.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.760]                 }
[10:33:15.760]                 if (length(args) > 0) 
[10:33:15.760]                   base::do.call(base::Sys.setenv, args = args)
[10:33:15.760]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:15.760]             }
[10:33:15.760]             else {
[10:33:15.760]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:15.760]             }
[10:33:15.760]             {
[10:33:15.760]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:15.760]                   0L) {
[10:33:15.760]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:15.760]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:15.760]                   base::options(opts)
[10:33:15.760]                 }
[10:33:15.760]                 {
[10:33:15.760]                   {
[10:33:15.760]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:15.760]                     NULL
[10:33:15.760]                   }
[10:33:15.760]                   options(future.plan = NULL)
[10:33:15.760]                   if (is.na(NA_character_)) 
[10:33:15.760]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.760]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:15.760]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:15.760]                     .init = FALSE)
[10:33:15.760]                 }
[10:33:15.760]             }
[10:33:15.760]         }
[10:33:15.760]     })
[10:33:15.760]     if (TRUE) {
[10:33:15.760]         base::sink(type = "output", split = FALSE)
[10:33:15.760]         if (TRUE) {
[10:33:15.760]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:15.760]         }
[10:33:15.760]         else {
[10:33:15.760]             ...future.result["stdout"] <- base::list(NULL)
[10:33:15.760]         }
[10:33:15.760]         base::close(...future.stdout)
[10:33:15.760]         ...future.stdout <- NULL
[10:33:15.760]     }
[10:33:15.760]     ...future.result$conditions <- ...future.conditions
[10:33:15.760]     ...future.result$finished <- base::Sys.time()
[10:33:15.760]     ...future.result
[10:33:15.760] }
[10:33:15.763] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[10:33:15.763] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[10:33:15.763] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[10:33:15.763] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[10:33:15.764] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[10:33:15.764] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[10:33:15.764] MultisessionFuture started
[10:33:15.764] - Launch lazy future ... done
[10:33:15.764] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:15.765] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:15.765] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:15.767] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:15.767] Searching for globals ... DONE
[10:33:15.767] Resolving globals: TRUE
[10:33:15.767] Resolving any globals that are futures ...
[10:33:15.767] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:15.767] Resolving any globals that are futures ... DONE
[10:33:15.767] Resolving futures part of globals (recursively) ...
[10:33:15.768] resolve() on list ...
[10:33:15.768]  recursive: 99
[10:33:15.768]  length: 2
[10:33:15.768]  elements: ‘a’, ‘ii’
[10:33:15.768]  length: 1 (resolved future 1)
[10:33:15.768]  length: 0 (resolved future 2)
[10:33:15.768] resolve() on list ... DONE
[10:33:15.768] - globals: [2] ‘a’, ‘ii’
[10:33:15.768] Resolving futures part of globals (recursively) ... DONE
[10:33:15.769] The total size of the 2 globals is 112 bytes (112 bytes)
[10:33:15.769] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:33:15.769] - globals: [2] ‘a’, ‘ii’
[10:33:15.769] 
[10:33:15.769] getGlobalsAndPackages() ... DONE
[10:33:15.769] run() for ‘Future’ ...
[10:33:15.770] - state: ‘created’
[10:33:15.770] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:15.784] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:15.784] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:15.784]   - Field: ‘node’
[10:33:15.784]   - Field: ‘label’
[10:33:15.784]   - Field: ‘local’
[10:33:15.784]   - Field: ‘owner’
[10:33:15.784]   - Field: ‘envir’
[10:33:15.784]   - Field: ‘workers’
[10:33:15.784]   - Field: ‘packages’
[10:33:15.785]   - Field: ‘gc’
[10:33:15.785]   - Field: ‘conditions’
[10:33:15.785]   - Field: ‘persistent’
[10:33:15.785]   - Field: ‘expr’
[10:33:15.785]   - Field: ‘uuid’
[10:33:15.785]   - Field: ‘seed’
[10:33:15.785]   - Field: ‘version’
[10:33:15.785]   - Field: ‘result’
[10:33:15.785]   - Field: ‘asynchronous’
[10:33:15.785]   - Field: ‘calls’
[10:33:15.785]   - Field: ‘globals’
[10:33:15.786]   - Field: ‘stdout’
[10:33:15.786]   - Field: ‘earlySignal’
[10:33:15.786]   - Field: ‘lazy’
[10:33:15.786]   - Field: ‘state’
[10:33:15.786] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:15.786] - Launch lazy future ...
[10:33:15.786] Packages needed by the future expression (n = 0): <none>
[10:33:15.786] Packages needed by future strategies (n = 0): <none>
[10:33:15.787] {
[10:33:15.787]     {
[10:33:15.787]         {
[10:33:15.787]             ...future.startTime <- base::Sys.time()
[10:33:15.787]             {
[10:33:15.787]                 {
[10:33:15.787]                   {
[10:33:15.787]                     {
[10:33:15.787]                       base::local({
[10:33:15.787]                         has_future <- base::requireNamespace("future", 
[10:33:15.787]                           quietly = TRUE)
[10:33:15.787]                         if (has_future) {
[10:33:15.787]                           ns <- base::getNamespace("future")
[10:33:15.787]                           version <- ns[[".package"]][["version"]]
[10:33:15.787]                           if (is.null(version)) 
[10:33:15.787]                             version <- utils::packageVersion("future")
[10:33:15.787]                         }
[10:33:15.787]                         else {
[10:33:15.787]                           version <- NULL
[10:33:15.787]                         }
[10:33:15.787]                         if (!has_future || version < "1.8.0") {
[10:33:15.787]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:15.787]                             "", base::R.version$version.string), 
[10:33:15.787]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:15.787]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:15.787]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:15.787]                               "release", "version")], collapse = " "), 
[10:33:15.787]                             hostname = base::Sys.info()[["nodename"]])
[10:33:15.787]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:15.787]                             info)
[10:33:15.787]                           info <- base::paste(info, collapse = "; ")
[10:33:15.787]                           if (!has_future) {
[10:33:15.787]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:15.787]                               info)
[10:33:15.787]                           }
[10:33:15.787]                           else {
[10:33:15.787]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:15.787]                               info, version)
[10:33:15.787]                           }
[10:33:15.787]                           base::stop(msg)
[10:33:15.787]                         }
[10:33:15.787]                       })
[10:33:15.787]                     }
[10:33:15.787]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:15.787]                     base::options(mc.cores = 1L)
[10:33:15.787]                   }
[10:33:15.787]                   ...future.strategy.old <- future::plan("list")
[10:33:15.787]                   options(future.plan = NULL)
[10:33:15.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.787]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:15.787]                 }
[10:33:15.787]                 ...future.workdir <- getwd()
[10:33:15.787]             }
[10:33:15.787]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:15.787]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:15.787]         }
[10:33:15.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:15.787]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:15.787]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:15.787]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:15.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:15.787]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:15.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:15.787]             base::names(...future.oldOptions))
[10:33:15.787]     }
[10:33:15.787]     if (FALSE) {
[10:33:15.787]     }
[10:33:15.787]     else {
[10:33:15.787]         if (TRUE) {
[10:33:15.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:15.787]                 open = "w")
[10:33:15.787]         }
[10:33:15.787]         else {
[10:33:15.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:15.787]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:15.787]         }
[10:33:15.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:15.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:15.787]             base::sink(type = "output", split = FALSE)
[10:33:15.787]             base::close(...future.stdout)
[10:33:15.787]         }, add = TRUE)
[10:33:15.787]     }
[10:33:15.787]     ...future.frame <- base::sys.nframe()
[10:33:15.787]     ...future.conditions <- base::list()
[10:33:15.787]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:15.787]     if (FALSE) {
[10:33:15.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:15.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:15.787]     }
[10:33:15.787]     ...future.result <- base::tryCatch({
[10:33:15.787]         base::withCallingHandlers({
[10:33:15.787]             ...future.value <- base::withVisible(base::local({
[10:33:15.787]                 ...future.makeSendCondition <- base::local({
[10:33:15.787]                   sendCondition <- NULL
[10:33:15.787]                   function(frame = 1L) {
[10:33:15.787]                     if (is.function(sendCondition)) 
[10:33:15.787]                       return(sendCondition)
[10:33:15.787]                     ns <- getNamespace("parallel")
[10:33:15.787]                     if (exists("sendData", mode = "function", 
[10:33:15.787]                       envir = ns)) {
[10:33:15.787]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:15.787]                         envir = ns)
[10:33:15.787]                       envir <- sys.frame(frame)
[10:33:15.787]                       master <- NULL
[10:33:15.787]                       while (!identical(envir, .GlobalEnv) && 
[10:33:15.787]                         !identical(envir, emptyenv())) {
[10:33:15.787]                         if (exists("master", mode = "list", envir = envir, 
[10:33:15.787]                           inherits = FALSE)) {
[10:33:15.787]                           master <- get("master", mode = "list", 
[10:33:15.787]                             envir = envir, inherits = FALSE)
[10:33:15.787]                           if (inherits(master, c("SOCKnode", 
[10:33:15.787]                             "SOCK0node"))) {
[10:33:15.787]                             sendCondition <<- function(cond) {
[10:33:15.787]                               data <- list(type = "VALUE", value = cond, 
[10:33:15.787]                                 success = TRUE)
[10:33:15.787]                               parallel_sendData(master, data)
[10:33:15.787]                             }
[10:33:15.787]                             return(sendCondition)
[10:33:15.787]                           }
[10:33:15.787]                         }
[10:33:15.787]                         frame <- frame + 1L
[10:33:15.787]                         envir <- sys.frame(frame)
[10:33:15.787]                       }
[10:33:15.787]                     }
[10:33:15.787]                     sendCondition <<- function(cond) NULL
[10:33:15.787]                   }
[10:33:15.787]                 })
[10:33:15.787]                 withCallingHandlers({
[10:33:15.787]                   {
[10:33:15.787]                     b <- a * ii
[10:33:15.787]                     a <- 0
[10:33:15.787]                     b
[10:33:15.787]                   }
[10:33:15.787]                 }, immediateCondition = function(cond) {
[10:33:15.787]                   sendCondition <- ...future.makeSendCondition()
[10:33:15.787]                   sendCondition(cond)
[10:33:15.787]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.787]                   {
[10:33:15.787]                     inherits <- base::inherits
[10:33:15.787]                     invokeRestart <- base::invokeRestart
[10:33:15.787]                     is.null <- base::is.null
[10:33:15.787]                     muffled <- FALSE
[10:33:15.787]                     if (inherits(cond, "message")) {
[10:33:15.787]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:15.787]                       if (muffled) 
[10:33:15.787]                         invokeRestart("muffleMessage")
[10:33:15.787]                     }
[10:33:15.787]                     else if (inherits(cond, "warning")) {
[10:33:15.787]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:15.787]                       if (muffled) 
[10:33:15.787]                         invokeRestart("muffleWarning")
[10:33:15.787]                     }
[10:33:15.787]                     else if (inherits(cond, "condition")) {
[10:33:15.787]                       if (!is.null(pattern)) {
[10:33:15.787]                         computeRestarts <- base::computeRestarts
[10:33:15.787]                         grepl <- base::grepl
[10:33:15.787]                         restarts <- computeRestarts(cond)
[10:33:15.787]                         for (restart in restarts) {
[10:33:15.787]                           name <- restart$name
[10:33:15.787]                           if (is.null(name)) 
[10:33:15.787]                             next
[10:33:15.787]                           if (!grepl(pattern, name)) 
[10:33:15.787]                             next
[10:33:15.787]                           invokeRestart(restart)
[10:33:15.787]                           muffled <- TRUE
[10:33:15.787]                           break
[10:33:15.787]                         }
[10:33:15.787]                       }
[10:33:15.787]                     }
[10:33:15.787]                     invisible(muffled)
[10:33:15.787]                   }
[10:33:15.787]                   muffleCondition(cond)
[10:33:15.787]                 })
[10:33:15.787]             }))
[10:33:15.787]             future::FutureResult(value = ...future.value$value, 
[10:33:15.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.787]                   ...future.rng), globalenv = if (FALSE) 
[10:33:15.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:15.787]                     ...future.globalenv.names))
[10:33:15.787]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:15.787]         }, condition = base::local({
[10:33:15.787]             c <- base::c
[10:33:15.787]             inherits <- base::inherits
[10:33:15.787]             invokeRestart <- base::invokeRestart
[10:33:15.787]             length <- base::length
[10:33:15.787]             list <- base::list
[10:33:15.787]             seq.int <- base::seq.int
[10:33:15.787]             signalCondition <- base::signalCondition
[10:33:15.787]             sys.calls <- base::sys.calls
[10:33:15.787]             `[[` <- base::`[[`
[10:33:15.787]             `+` <- base::`+`
[10:33:15.787]             `<<-` <- base::`<<-`
[10:33:15.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:15.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:15.787]                   3L)]
[10:33:15.787]             }
[10:33:15.787]             function(cond) {
[10:33:15.787]                 is_error <- inherits(cond, "error")
[10:33:15.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:15.787]                   NULL)
[10:33:15.787]                 if (is_error) {
[10:33:15.787]                   sessionInformation <- function() {
[10:33:15.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:15.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:15.787]                       search = base::search(), system = base::Sys.info())
[10:33:15.787]                   }
[10:33:15.787]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:15.787]                     cond$call), session = sessionInformation(), 
[10:33:15.787]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:15.787]                   signalCondition(cond)
[10:33:15.787]                 }
[10:33:15.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:15.787]                 "immediateCondition"))) {
[10:33:15.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:15.787]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:15.787]                   if (TRUE && !signal) {
[10:33:15.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.787]                     {
[10:33:15.787]                       inherits <- base::inherits
[10:33:15.787]                       invokeRestart <- base::invokeRestart
[10:33:15.787]                       is.null <- base::is.null
[10:33:15.787]                       muffled <- FALSE
[10:33:15.787]                       if (inherits(cond, "message")) {
[10:33:15.787]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.787]                         if (muffled) 
[10:33:15.787]                           invokeRestart("muffleMessage")
[10:33:15.787]                       }
[10:33:15.787]                       else if (inherits(cond, "warning")) {
[10:33:15.787]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.787]                         if (muffled) 
[10:33:15.787]                           invokeRestart("muffleWarning")
[10:33:15.787]                       }
[10:33:15.787]                       else if (inherits(cond, "condition")) {
[10:33:15.787]                         if (!is.null(pattern)) {
[10:33:15.787]                           computeRestarts <- base::computeRestarts
[10:33:15.787]                           grepl <- base::grepl
[10:33:15.787]                           restarts <- computeRestarts(cond)
[10:33:15.787]                           for (restart in restarts) {
[10:33:15.787]                             name <- restart$name
[10:33:15.787]                             if (is.null(name)) 
[10:33:15.787]                               next
[10:33:15.787]                             if (!grepl(pattern, name)) 
[10:33:15.787]                               next
[10:33:15.787]                             invokeRestart(restart)
[10:33:15.787]                             muffled <- TRUE
[10:33:15.787]                             break
[10:33:15.787]                           }
[10:33:15.787]                         }
[10:33:15.787]                       }
[10:33:15.787]                       invisible(muffled)
[10:33:15.787]                     }
[10:33:15.787]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.787]                   }
[10:33:15.787]                 }
[10:33:15.787]                 else {
[10:33:15.787]                   if (TRUE) {
[10:33:15.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.787]                     {
[10:33:15.787]                       inherits <- base::inherits
[10:33:15.787]                       invokeRestart <- base::invokeRestart
[10:33:15.787]                       is.null <- base::is.null
[10:33:15.787]                       muffled <- FALSE
[10:33:15.787]                       if (inherits(cond, "message")) {
[10:33:15.787]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.787]                         if (muffled) 
[10:33:15.787]                           invokeRestart("muffleMessage")
[10:33:15.787]                       }
[10:33:15.787]                       else if (inherits(cond, "warning")) {
[10:33:15.787]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.787]                         if (muffled) 
[10:33:15.787]                           invokeRestart("muffleWarning")
[10:33:15.787]                       }
[10:33:15.787]                       else if (inherits(cond, "condition")) {
[10:33:15.787]                         if (!is.null(pattern)) {
[10:33:15.787]                           computeRestarts <- base::computeRestarts
[10:33:15.787]                           grepl <- base::grepl
[10:33:15.787]                           restarts <- computeRestarts(cond)
[10:33:15.787]                           for (restart in restarts) {
[10:33:15.787]                             name <- restart$name
[10:33:15.787]                             if (is.null(name)) 
[10:33:15.787]                               next
[10:33:15.787]                             if (!grepl(pattern, name)) 
[10:33:15.787]                               next
[10:33:15.787]                             invokeRestart(restart)
[10:33:15.787]                             muffled <- TRUE
[10:33:15.787]                             break
[10:33:15.787]                           }
[10:33:15.787]                         }
[10:33:15.787]                       }
[10:33:15.787]                       invisible(muffled)
[10:33:15.787]                     }
[10:33:15.787]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.787]                   }
[10:33:15.787]                 }
[10:33:15.787]             }
[10:33:15.787]         }))
[10:33:15.787]     }, error = function(ex) {
[10:33:15.787]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:15.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.787]                 ...future.rng), started = ...future.startTime, 
[10:33:15.787]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:15.787]             version = "1.8"), class = "FutureResult")
[10:33:15.787]     }, finally = {
[10:33:15.787]         if (!identical(...future.workdir, getwd())) 
[10:33:15.787]             setwd(...future.workdir)
[10:33:15.787]         {
[10:33:15.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:15.787]                 ...future.oldOptions$nwarnings <- NULL
[10:33:15.787]             }
[10:33:15.787]             base::options(...future.oldOptions)
[10:33:15.787]             if (.Platform$OS.type == "windows") {
[10:33:15.787]                 old_names <- names(...future.oldEnvVars)
[10:33:15.787]                 envs <- base::Sys.getenv()
[10:33:15.787]                 names <- names(envs)
[10:33:15.787]                 common <- intersect(names, old_names)
[10:33:15.787]                 added <- setdiff(names, old_names)
[10:33:15.787]                 removed <- setdiff(old_names, names)
[10:33:15.787]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:15.787]                   envs[common]]
[10:33:15.787]                 NAMES <- toupper(changed)
[10:33:15.787]                 args <- list()
[10:33:15.787]                 for (kk in seq_along(NAMES)) {
[10:33:15.787]                   name <- changed[[kk]]
[10:33:15.787]                   NAME <- NAMES[[kk]]
[10:33:15.787]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.787]                     next
[10:33:15.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.787]                 }
[10:33:15.787]                 NAMES <- toupper(added)
[10:33:15.787]                 for (kk in seq_along(NAMES)) {
[10:33:15.787]                   name <- added[[kk]]
[10:33:15.787]                   NAME <- NAMES[[kk]]
[10:33:15.787]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.787]                     next
[10:33:15.787]                   args[[name]] <- ""
[10:33:15.787]                 }
[10:33:15.787]                 NAMES <- toupper(removed)
[10:33:15.787]                 for (kk in seq_along(NAMES)) {
[10:33:15.787]                   name <- removed[[kk]]
[10:33:15.787]                   NAME <- NAMES[[kk]]
[10:33:15.787]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.787]                     next
[10:33:15.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.787]                 }
[10:33:15.787]                 if (length(args) > 0) 
[10:33:15.787]                   base::do.call(base::Sys.setenv, args = args)
[10:33:15.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:15.787]             }
[10:33:15.787]             else {
[10:33:15.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:15.787]             }
[10:33:15.787]             {
[10:33:15.787]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:15.787]                   0L) {
[10:33:15.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:15.787]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:15.787]                   base::options(opts)
[10:33:15.787]                 }
[10:33:15.787]                 {
[10:33:15.787]                   {
[10:33:15.787]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:15.787]                     NULL
[10:33:15.787]                   }
[10:33:15.787]                   options(future.plan = NULL)
[10:33:15.787]                   if (is.na(NA_character_)) 
[10:33:15.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:15.787]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:15.787]                     .init = FALSE)
[10:33:15.787]                 }
[10:33:15.787]             }
[10:33:15.787]         }
[10:33:15.787]     })
[10:33:15.787]     if (TRUE) {
[10:33:15.787]         base::sink(type = "output", split = FALSE)
[10:33:15.787]         if (TRUE) {
[10:33:15.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:15.787]         }
[10:33:15.787]         else {
[10:33:15.787]             ...future.result["stdout"] <- base::list(NULL)
[10:33:15.787]         }
[10:33:15.787]         base::close(...future.stdout)
[10:33:15.787]         ...future.stdout <- NULL
[10:33:15.787]     }
[10:33:15.787]     ...future.result$conditions <- ...future.conditions
[10:33:15.787]     ...future.result$finished <- base::Sys.time()
[10:33:15.787]     ...future.result
[10:33:15.787] }
[10:33:15.789] Poll #1 (0): usedNodes() = 2, workers = 2
[10:33:15.799] receiveMessageFromWorker() for ClusterFuture ...
[10:33:15.800] - Validating connection of MultisessionFuture
[10:33:15.800] - received message: FutureResult
[10:33:15.800] - Received FutureResult
[10:33:15.800] - Erased future from FutureRegistry
[10:33:15.800] result() for ClusterFuture ...
[10:33:15.801] - result already collected: FutureResult
[10:33:15.801] result() for ClusterFuture ... done
[10:33:15.801] signalConditions() ...
[10:33:15.801]  - include = ‘immediateCondition’
[10:33:15.801]  - exclude = 
[10:33:15.801]  - resignal = FALSE
[10:33:15.801]  - Number of conditions: 1
[10:33:15.801] signalConditions() ... done
[10:33:15.801] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:15.801] result() for ClusterFuture ...
[10:33:15.801] - result already collected: FutureResult
[10:33:15.802] result() for ClusterFuture ... done
[10:33:15.802] result() for ClusterFuture ...
[10:33:15.802] - result already collected: FutureResult
[10:33:15.802] result() for ClusterFuture ... done
[10:33:15.802] signalConditions() ...
[10:33:15.802]  - include = ‘immediateCondition’
[10:33:15.802]  - exclude = 
[10:33:15.802]  - resignal = FALSE
[10:33:15.802]  - Number of conditions: 1
[10:33:15.802] signalConditions() ... done
[10:33:15.803] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[10:33:15.803] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[10:33:15.804] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[10:33:15.804] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[10:33:15.804] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[10:33:15.804] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[10:33:15.805] MultisessionFuture started
[10:33:15.805] - Launch lazy future ... done
[10:33:15.805] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:15.805] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:15.806] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:15.808] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:15.808] Searching for globals ... DONE
[10:33:15.808] Resolving globals: TRUE
[10:33:15.808] Resolving any globals that are futures ...
[10:33:15.808] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:15.809] Resolving any globals that are futures ... DONE
[10:33:15.809] Resolving futures part of globals (recursively) ...
[10:33:15.809] resolve() on list ...
[10:33:15.809]  recursive: 99
[10:33:15.809]  length: 2
[10:33:15.809]  elements: ‘a’, ‘ii’
[10:33:15.810]  length: 1 (resolved future 1)
[10:33:15.810]  length: 0 (resolved future 2)
[10:33:15.810] resolve() on list ... DONE
[10:33:15.810] - globals: [2] ‘a’, ‘ii’
[10:33:15.810] Resolving futures part of globals (recursively) ... DONE
[10:33:15.810] The total size of the 2 globals is 112 bytes (112 bytes)
[10:33:15.810] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:33:15.811] - globals: [2] ‘a’, ‘ii’
[10:33:15.811] 
[10:33:15.811] getGlobalsAndPackages() ... DONE
[10:33:15.811] run() for ‘Future’ ...
[10:33:15.811] - state: ‘created’
[10:33:15.811] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:15.825] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:15.825] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:15.825]   - Field: ‘node’
[10:33:15.825]   - Field: ‘label’
[10:33:15.825]   - Field: ‘local’
[10:33:15.825]   - Field: ‘owner’
[10:33:15.825]   - Field: ‘envir’
[10:33:15.825]   - Field: ‘workers’
[10:33:15.826]   - Field: ‘packages’
[10:33:15.826]   - Field: ‘gc’
[10:33:15.826]   - Field: ‘conditions’
[10:33:15.826]   - Field: ‘persistent’
[10:33:15.826]   - Field: ‘expr’
[10:33:15.826]   - Field: ‘uuid’
[10:33:15.826]   - Field: ‘seed’
[10:33:15.826]   - Field: ‘version’
[10:33:15.826]   - Field: ‘result’
[10:33:15.826]   - Field: ‘asynchronous’
[10:33:15.826]   - Field: ‘calls’
[10:33:15.827]   - Field: ‘globals’
[10:33:15.827]   - Field: ‘stdout’
[10:33:15.827]   - Field: ‘earlySignal’
[10:33:15.827]   - Field: ‘lazy’
[10:33:15.827]   - Field: ‘state’
[10:33:15.827] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:15.827] - Launch lazy future ...
[10:33:15.827] Packages needed by the future expression (n = 0): <none>
[10:33:15.827] Packages needed by future strategies (n = 0): <none>
[10:33:15.828] {
[10:33:15.828]     {
[10:33:15.828]         {
[10:33:15.828]             ...future.startTime <- base::Sys.time()
[10:33:15.828]             {
[10:33:15.828]                 {
[10:33:15.828]                   {
[10:33:15.828]                     {
[10:33:15.828]                       base::local({
[10:33:15.828]                         has_future <- base::requireNamespace("future", 
[10:33:15.828]                           quietly = TRUE)
[10:33:15.828]                         if (has_future) {
[10:33:15.828]                           ns <- base::getNamespace("future")
[10:33:15.828]                           version <- ns[[".package"]][["version"]]
[10:33:15.828]                           if (is.null(version)) 
[10:33:15.828]                             version <- utils::packageVersion("future")
[10:33:15.828]                         }
[10:33:15.828]                         else {
[10:33:15.828]                           version <- NULL
[10:33:15.828]                         }
[10:33:15.828]                         if (!has_future || version < "1.8.0") {
[10:33:15.828]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:15.828]                             "", base::R.version$version.string), 
[10:33:15.828]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:15.828]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:15.828]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:15.828]                               "release", "version")], collapse = " "), 
[10:33:15.828]                             hostname = base::Sys.info()[["nodename"]])
[10:33:15.828]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:15.828]                             info)
[10:33:15.828]                           info <- base::paste(info, collapse = "; ")
[10:33:15.828]                           if (!has_future) {
[10:33:15.828]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:15.828]                               info)
[10:33:15.828]                           }
[10:33:15.828]                           else {
[10:33:15.828]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:15.828]                               info, version)
[10:33:15.828]                           }
[10:33:15.828]                           base::stop(msg)
[10:33:15.828]                         }
[10:33:15.828]                       })
[10:33:15.828]                     }
[10:33:15.828]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:15.828]                     base::options(mc.cores = 1L)
[10:33:15.828]                   }
[10:33:15.828]                   ...future.strategy.old <- future::plan("list")
[10:33:15.828]                   options(future.plan = NULL)
[10:33:15.828]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.828]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:15.828]                 }
[10:33:15.828]                 ...future.workdir <- getwd()
[10:33:15.828]             }
[10:33:15.828]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:15.828]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:15.828]         }
[10:33:15.828]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:15.828]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:15.828]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:15.828]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:15.828]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:15.828]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:15.828]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:15.828]             base::names(...future.oldOptions))
[10:33:15.828]     }
[10:33:15.828]     if (FALSE) {
[10:33:15.828]     }
[10:33:15.828]     else {
[10:33:15.828]         if (TRUE) {
[10:33:15.828]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:15.828]                 open = "w")
[10:33:15.828]         }
[10:33:15.828]         else {
[10:33:15.828]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:15.828]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:15.828]         }
[10:33:15.828]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:15.828]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:15.828]             base::sink(type = "output", split = FALSE)
[10:33:15.828]             base::close(...future.stdout)
[10:33:15.828]         }, add = TRUE)
[10:33:15.828]     }
[10:33:15.828]     ...future.frame <- base::sys.nframe()
[10:33:15.828]     ...future.conditions <- base::list()
[10:33:15.828]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:15.828]     if (FALSE) {
[10:33:15.828]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:15.828]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:15.828]     }
[10:33:15.828]     ...future.result <- base::tryCatch({
[10:33:15.828]         base::withCallingHandlers({
[10:33:15.828]             ...future.value <- base::withVisible(base::local({
[10:33:15.828]                 ...future.makeSendCondition <- base::local({
[10:33:15.828]                   sendCondition <- NULL
[10:33:15.828]                   function(frame = 1L) {
[10:33:15.828]                     if (is.function(sendCondition)) 
[10:33:15.828]                       return(sendCondition)
[10:33:15.828]                     ns <- getNamespace("parallel")
[10:33:15.828]                     if (exists("sendData", mode = "function", 
[10:33:15.828]                       envir = ns)) {
[10:33:15.828]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:15.828]                         envir = ns)
[10:33:15.828]                       envir <- sys.frame(frame)
[10:33:15.828]                       master <- NULL
[10:33:15.828]                       while (!identical(envir, .GlobalEnv) && 
[10:33:15.828]                         !identical(envir, emptyenv())) {
[10:33:15.828]                         if (exists("master", mode = "list", envir = envir, 
[10:33:15.828]                           inherits = FALSE)) {
[10:33:15.828]                           master <- get("master", mode = "list", 
[10:33:15.828]                             envir = envir, inherits = FALSE)
[10:33:15.828]                           if (inherits(master, c("SOCKnode", 
[10:33:15.828]                             "SOCK0node"))) {
[10:33:15.828]                             sendCondition <<- function(cond) {
[10:33:15.828]                               data <- list(type = "VALUE", value = cond, 
[10:33:15.828]                                 success = TRUE)
[10:33:15.828]                               parallel_sendData(master, data)
[10:33:15.828]                             }
[10:33:15.828]                             return(sendCondition)
[10:33:15.828]                           }
[10:33:15.828]                         }
[10:33:15.828]                         frame <- frame + 1L
[10:33:15.828]                         envir <- sys.frame(frame)
[10:33:15.828]                       }
[10:33:15.828]                     }
[10:33:15.828]                     sendCondition <<- function(cond) NULL
[10:33:15.828]                   }
[10:33:15.828]                 })
[10:33:15.828]                 withCallingHandlers({
[10:33:15.828]                   {
[10:33:15.828]                     b <- a * ii
[10:33:15.828]                     a <- 0
[10:33:15.828]                     b
[10:33:15.828]                   }
[10:33:15.828]                 }, immediateCondition = function(cond) {
[10:33:15.828]                   sendCondition <- ...future.makeSendCondition()
[10:33:15.828]                   sendCondition(cond)
[10:33:15.828]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.828]                   {
[10:33:15.828]                     inherits <- base::inherits
[10:33:15.828]                     invokeRestart <- base::invokeRestart
[10:33:15.828]                     is.null <- base::is.null
[10:33:15.828]                     muffled <- FALSE
[10:33:15.828]                     if (inherits(cond, "message")) {
[10:33:15.828]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:15.828]                       if (muffled) 
[10:33:15.828]                         invokeRestart("muffleMessage")
[10:33:15.828]                     }
[10:33:15.828]                     else if (inherits(cond, "warning")) {
[10:33:15.828]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:15.828]                       if (muffled) 
[10:33:15.828]                         invokeRestart("muffleWarning")
[10:33:15.828]                     }
[10:33:15.828]                     else if (inherits(cond, "condition")) {
[10:33:15.828]                       if (!is.null(pattern)) {
[10:33:15.828]                         computeRestarts <- base::computeRestarts
[10:33:15.828]                         grepl <- base::grepl
[10:33:15.828]                         restarts <- computeRestarts(cond)
[10:33:15.828]                         for (restart in restarts) {
[10:33:15.828]                           name <- restart$name
[10:33:15.828]                           if (is.null(name)) 
[10:33:15.828]                             next
[10:33:15.828]                           if (!grepl(pattern, name)) 
[10:33:15.828]                             next
[10:33:15.828]                           invokeRestart(restart)
[10:33:15.828]                           muffled <- TRUE
[10:33:15.828]                           break
[10:33:15.828]                         }
[10:33:15.828]                       }
[10:33:15.828]                     }
[10:33:15.828]                     invisible(muffled)
[10:33:15.828]                   }
[10:33:15.828]                   muffleCondition(cond)
[10:33:15.828]                 })
[10:33:15.828]             }))
[10:33:15.828]             future::FutureResult(value = ...future.value$value, 
[10:33:15.828]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.828]                   ...future.rng), globalenv = if (FALSE) 
[10:33:15.828]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:15.828]                     ...future.globalenv.names))
[10:33:15.828]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:15.828]         }, condition = base::local({
[10:33:15.828]             c <- base::c
[10:33:15.828]             inherits <- base::inherits
[10:33:15.828]             invokeRestart <- base::invokeRestart
[10:33:15.828]             length <- base::length
[10:33:15.828]             list <- base::list
[10:33:15.828]             seq.int <- base::seq.int
[10:33:15.828]             signalCondition <- base::signalCondition
[10:33:15.828]             sys.calls <- base::sys.calls
[10:33:15.828]             `[[` <- base::`[[`
[10:33:15.828]             `+` <- base::`+`
[10:33:15.828]             `<<-` <- base::`<<-`
[10:33:15.828]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:15.828]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:15.828]                   3L)]
[10:33:15.828]             }
[10:33:15.828]             function(cond) {
[10:33:15.828]                 is_error <- inherits(cond, "error")
[10:33:15.828]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:15.828]                   NULL)
[10:33:15.828]                 if (is_error) {
[10:33:15.828]                   sessionInformation <- function() {
[10:33:15.828]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:15.828]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:15.828]                       search = base::search(), system = base::Sys.info())
[10:33:15.828]                   }
[10:33:15.828]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.828]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:15.828]                     cond$call), session = sessionInformation(), 
[10:33:15.828]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:15.828]                   signalCondition(cond)
[10:33:15.828]                 }
[10:33:15.828]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:15.828]                 "immediateCondition"))) {
[10:33:15.828]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:15.828]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.828]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:15.828]                   if (TRUE && !signal) {
[10:33:15.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.828]                     {
[10:33:15.828]                       inherits <- base::inherits
[10:33:15.828]                       invokeRestart <- base::invokeRestart
[10:33:15.828]                       is.null <- base::is.null
[10:33:15.828]                       muffled <- FALSE
[10:33:15.828]                       if (inherits(cond, "message")) {
[10:33:15.828]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.828]                         if (muffled) 
[10:33:15.828]                           invokeRestart("muffleMessage")
[10:33:15.828]                       }
[10:33:15.828]                       else if (inherits(cond, "warning")) {
[10:33:15.828]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.828]                         if (muffled) 
[10:33:15.828]                           invokeRestart("muffleWarning")
[10:33:15.828]                       }
[10:33:15.828]                       else if (inherits(cond, "condition")) {
[10:33:15.828]                         if (!is.null(pattern)) {
[10:33:15.828]                           computeRestarts <- base::computeRestarts
[10:33:15.828]                           grepl <- base::grepl
[10:33:15.828]                           restarts <- computeRestarts(cond)
[10:33:15.828]                           for (restart in restarts) {
[10:33:15.828]                             name <- restart$name
[10:33:15.828]                             if (is.null(name)) 
[10:33:15.828]                               next
[10:33:15.828]                             if (!grepl(pattern, name)) 
[10:33:15.828]                               next
[10:33:15.828]                             invokeRestart(restart)
[10:33:15.828]                             muffled <- TRUE
[10:33:15.828]                             break
[10:33:15.828]                           }
[10:33:15.828]                         }
[10:33:15.828]                       }
[10:33:15.828]                       invisible(muffled)
[10:33:15.828]                     }
[10:33:15.828]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.828]                   }
[10:33:15.828]                 }
[10:33:15.828]                 else {
[10:33:15.828]                   if (TRUE) {
[10:33:15.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.828]                     {
[10:33:15.828]                       inherits <- base::inherits
[10:33:15.828]                       invokeRestart <- base::invokeRestart
[10:33:15.828]                       is.null <- base::is.null
[10:33:15.828]                       muffled <- FALSE
[10:33:15.828]                       if (inherits(cond, "message")) {
[10:33:15.828]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.828]                         if (muffled) 
[10:33:15.828]                           invokeRestart("muffleMessage")
[10:33:15.828]                       }
[10:33:15.828]                       else if (inherits(cond, "warning")) {
[10:33:15.828]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.828]                         if (muffled) 
[10:33:15.828]                           invokeRestart("muffleWarning")
[10:33:15.828]                       }
[10:33:15.828]                       else if (inherits(cond, "condition")) {
[10:33:15.828]                         if (!is.null(pattern)) {
[10:33:15.828]                           computeRestarts <- base::computeRestarts
[10:33:15.828]                           grepl <- base::grepl
[10:33:15.828]                           restarts <- computeRestarts(cond)
[10:33:15.828]                           for (restart in restarts) {
[10:33:15.828]                             name <- restart$name
[10:33:15.828]                             if (is.null(name)) 
[10:33:15.828]                               next
[10:33:15.828]                             if (!grepl(pattern, name)) 
[10:33:15.828]                               next
[10:33:15.828]                             invokeRestart(restart)
[10:33:15.828]                             muffled <- TRUE
[10:33:15.828]                             break
[10:33:15.828]                           }
[10:33:15.828]                         }
[10:33:15.828]                       }
[10:33:15.828]                       invisible(muffled)
[10:33:15.828]                     }
[10:33:15.828]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.828]                   }
[10:33:15.828]                 }
[10:33:15.828]             }
[10:33:15.828]         }))
[10:33:15.828]     }, error = function(ex) {
[10:33:15.828]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:15.828]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.828]                 ...future.rng), started = ...future.startTime, 
[10:33:15.828]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:15.828]             version = "1.8"), class = "FutureResult")
[10:33:15.828]     }, finally = {
[10:33:15.828]         if (!identical(...future.workdir, getwd())) 
[10:33:15.828]             setwd(...future.workdir)
[10:33:15.828]         {
[10:33:15.828]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:15.828]                 ...future.oldOptions$nwarnings <- NULL
[10:33:15.828]             }
[10:33:15.828]             base::options(...future.oldOptions)
[10:33:15.828]             if (.Platform$OS.type == "windows") {
[10:33:15.828]                 old_names <- names(...future.oldEnvVars)
[10:33:15.828]                 envs <- base::Sys.getenv()
[10:33:15.828]                 names <- names(envs)
[10:33:15.828]                 common <- intersect(names, old_names)
[10:33:15.828]                 added <- setdiff(names, old_names)
[10:33:15.828]                 removed <- setdiff(old_names, names)
[10:33:15.828]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:15.828]                   envs[common]]
[10:33:15.828]                 NAMES <- toupper(changed)
[10:33:15.828]                 args <- list()
[10:33:15.828]                 for (kk in seq_along(NAMES)) {
[10:33:15.828]                   name <- changed[[kk]]
[10:33:15.828]                   NAME <- NAMES[[kk]]
[10:33:15.828]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.828]                     next
[10:33:15.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.828]                 }
[10:33:15.828]                 NAMES <- toupper(added)
[10:33:15.828]                 for (kk in seq_along(NAMES)) {
[10:33:15.828]                   name <- added[[kk]]
[10:33:15.828]                   NAME <- NAMES[[kk]]
[10:33:15.828]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.828]                     next
[10:33:15.828]                   args[[name]] <- ""
[10:33:15.828]                 }
[10:33:15.828]                 NAMES <- toupper(removed)
[10:33:15.828]                 for (kk in seq_along(NAMES)) {
[10:33:15.828]                   name <- removed[[kk]]
[10:33:15.828]                   NAME <- NAMES[[kk]]
[10:33:15.828]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.828]                     next
[10:33:15.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.828]                 }
[10:33:15.828]                 if (length(args) > 0) 
[10:33:15.828]                   base::do.call(base::Sys.setenv, args = args)
[10:33:15.828]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:15.828]             }
[10:33:15.828]             else {
[10:33:15.828]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:15.828]             }
[10:33:15.828]             {
[10:33:15.828]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:15.828]                   0L) {
[10:33:15.828]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:15.828]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:15.828]                   base::options(opts)
[10:33:15.828]                 }
[10:33:15.828]                 {
[10:33:15.828]                   {
[10:33:15.828]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:15.828]                     NULL
[10:33:15.828]                   }
[10:33:15.828]                   options(future.plan = NULL)
[10:33:15.828]                   if (is.na(NA_character_)) 
[10:33:15.828]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.828]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:15.828]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:15.828]                     .init = FALSE)
[10:33:15.828]                 }
[10:33:15.828]             }
[10:33:15.828]         }
[10:33:15.828]     })
[10:33:15.828]     if (TRUE) {
[10:33:15.828]         base::sink(type = "output", split = FALSE)
[10:33:15.828]         if (TRUE) {
[10:33:15.828]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:15.828]         }
[10:33:15.828]         else {
[10:33:15.828]             ...future.result["stdout"] <- base::list(NULL)
[10:33:15.828]         }
[10:33:15.828]         base::close(...future.stdout)
[10:33:15.828]         ...future.stdout <- NULL
[10:33:15.828]     }
[10:33:15.828]     ...future.result$conditions <- ...future.conditions
[10:33:15.828]     ...future.result$finished <- base::Sys.time()
[10:33:15.828]     ...future.result
[10:33:15.828] }
[10:33:15.830] Poll #1 (0): usedNodes() = 2, workers = 2
[10:33:15.840] receiveMessageFromWorker() for ClusterFuture ...
[10:33:15.841] - Validating connection of MultisessionFuture
[10:33:15.841] - received message: FutureResult
[10:33:15.841] - Received FutureResult
[10:33:15.841] - Erased future from FutureRegistry
[10:33:15.841] result() for ClusterFuture ...
[10:33:15.841] - result already collected: FutureResult
[10:33:15.841] result() for ClusterFuture ... done
[10:33:15.841] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:15.841] result() for ClusterFuture ...
[10:33:15.842] - result already collected: FutureResult
[10:33:15.842] result() for ClusterFuture ... done
[10:33:15.842] result() for ClusterFuture ...
[10:33:15.842] - result already collected: FutureResult
[10:33:15.842] result() for ClusterFuture ... done
[10:33:15.842] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[10:33:15.843] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[10:33:15.843] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[10:33:15.843] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[10:33:15.843] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[10:33:15.843] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[10:33:15.844] MultisessionFuture started
[10:33:15.844] - Launch lazy future ... done
[10:33:15.844] run() for ‘MultisessionFuture’ ... done
[10:33:15.844] result() for ClusterFuture ...
[10:33:15.844] - result already collected: FutureResult
[10:33:15.844] result() for ClusterFuture ... done
[10:33:15.845] result() for ClusterFuture ...
[10:33:15.845] - result already collected: FutureResult
[10:33:15.845] result() for ClusterFuture ... done
[10:33:15.845] result() for ClusterFuture ...
[10:33:15.845] receiveMessageFromWorker() for ClusterFuture ...
[10:33:15.845] - Validating connection of MultisessionFuture
[10:33:15.845] - received message: FutureResult
[10:33:15.845] - Received FutureResult
[10:33:15.845] - Erased future from FutureRegistry
[10:33:15.846] result() for ClusterFuture ...
[10:33:15.846] - result already collected: FutureResult
[10:33:15.846] result() for ClusterFuture ... done
[10:33:15.846] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:15.846] result() for ClusterFuture ... done
[10:33:15.846] result() for ClusterFuture ...
[10:33:15.846] - result already collected: FutureResult
[10:33:15.846] result() for ClusterFuture ... done
[10:33:15.846] result() for ClusterFuture ...
[10:33:15.846] receiveMessageFromWorker() for ClusterFuture ...
[10:33:15.846] - Validating connection of MultisessionFuture
[10:33:15.886] - received message: FutureResult
[10:33:15.886] - Received FutureResult
[10:33:15.887] - Erased future from FutureRegistry
[10:33:15.887] result() for ClusterFuture ...
[10:33:15.887] - result already collected: FutureResult
[10:33:15.887] result() for ClusterFuture ... done
[10:33:15.887] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:15.887] result() for ClusterFuture ... done
[10:33:15.887] result() for ClusterFuture ...
[10:33:15.887] - result already collected: FutureResult
[10:33:15.887] result() for ClusterFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:15.888] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:15.888] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:15.890] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:15.890] Searching for globals ... DONE
[10:33:15.890] Resolving globals: TRUE
[10:33:15.890] Resolving any globals that are futures ...
[10:33:15.890] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:15.890] Resolving any globals that are futures ... DONE
[10:33:15.891] Resolving futures part of globals (recursively) ...
[10:33:15.891] resolve() on list ...
[10:33:15.891]  recursive: 99
[10:33:15.891]  length: 2
[10:33:15.891]  elements: ‘a’, ‘ii’
[10:33:15.891]  length: 1 (resolved future 1)
[10:33:15.891]  length: 0 (resolved future 2)
[10:33:15.892] resolve() on list ... DONE
[10:33:15.892] - globals: [2] ‘a’, ‘ii’
[10:33:15.892] Resolving futures part of globals (recursively) ... DONE
[10:33:15.892] The total size of the 2 globals is 112 bytes (112 bytes)
[10:33:15.892] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:33:15.892] - globals: [2] ‘a’, ‘ii’
[10:33:15.892] 
[10:33:15.893] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:15.893] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:15.893] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:15.895] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:15.895] Searching for globals ... DONE
[10:33:15.895] Resolving globals: TRUE
[10:33:15.895] Resolving any globals that are futures ...
[10:33:15.895] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:15.895] Resolving any globals that are futures ... DONE
[10:33:15.896] Resolving futures part of globals (recursively) ...
[10:33:15.896] resolve() on list ...
[10:33:15.896]  recursive: 99
[10:33:15.896]  length: 2
[10:33:15.896]  elements: ‘a’, ‘ii’
[10:33:15.896]  length: 1 (resolved future 1)
[10:33:15.897]  length: 0 (resolved future 2)
[10:33:15.897] resolve() on list ... DONE
[10:33:15.897] - globals: [2] ‘a’, ‘ii’
[10:33:15.897] Resolving futures part of globals (recursively) ... DONE
[10:33:15.897] The total size of the 2 globals is 112 bytes (112 bytes)
[10:33:15.897] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:33:15.897] - globals: [2] ‘a’, ‘ii’
[10:33:15.898] 
[10:33:15.898] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:15.898] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:15.898] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:15.900] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:15.900] Searching for globals ... DONE
[10:33:15.900] Resolving globals: TRUE
[10:33:15.900] Resolving any globals that are futures ...
[10:33:15.900] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:33:15.901] Resolving any globals that are futures ... DONE
[10:33:15.901] Resolving futures part of globals (recursively) ...
[10:33:15.901] resolve() on list ...
[10:33:15.901]  recursive: 99
[10:33:15.901]  length: 2
[10:33:15.901]  elements: ‘a’, ‘ii’
[10:33:15.901]  length: 1 (resolved future 1)
[10:33:15.902]  length: 0 (resolved future 2)
[10:33:15.902] resolve() on list ... DONE
[10:33:15.902] - globals: [2] ‘a’, ‘ii’
[10:33:15.902] Resolving futures part of globals (recursively) ... DONE
[10:33:15.902] The total size of the 2 globals is 112 bytes (112 bytes)
[10:33:15.902] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:33:15.902] - globals: [2] ‘a’, ‘ii’
[10:33:15.903] 
[10:33:15.903] getGlobalsAndPackages() ... DONE
[10:33:15.903] run() for ‘Future’ ...
[10:33:15.903] - state: ‘created’
[10:33:15.903] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:15.917] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:15.917] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:15.917]   - Field: ‘node’
[10:33:15.918]   - Field: ‘label’
[10:33:15.918]   - Field: ‘local’
[10:33:15.918]   - Field: ‘owner’
[10:33:15.918]   - Field: ‘envir’
[10:33:15.918]   - Field: ‘workers’
[10:33:15.918]   - Field: ‘packages’
[10:33:15.918]   - Field: ‘gc’
[10:33:15.918]   - Field: ‘conditions’
[10:33:15.918]   - Field: ‘persistent’
[10:33:15.918]   - Field: ‘expr’
[10:33:15.918]   - Field: ‘uuid’
[10:33:15.919]   - Field: ‘seed’
[10:33:15.919]   - Field: ‘version’
[10:33:15.919]   - Field: ‘result’
[10:33:15.919]   - Field: ‘asynchronous’
[10:33:15.919]   - Field: ‘calls’
[10:33:15.919]   - Field: ‘globals’
[10:33:15.919]   - Field: ‘stdout’
[10:33:15.919]   - Field: ‘earlySignal’
[10:33:15.919]   - Field: ‘lazy’
[10:33:15.919]   - Field: ‘state’
[10:33:15.920] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:15.920] - Launch lazy future ...
[10:33:15.920] Packages needed by the future expression (n = 0): <none>
[10:33:15.920] Packages needed by future strategies (n = 0): <none>
[10:33:15.920] {
[10:33:15.920]     {
[10:33:15.920]         {
[10:33:15.920]             ...future.startTime <- base::Sys.time()
[10:33:15.920]             {
[10:33:15.920]                 {
[10:33:15.920]                   {
[10:33:15.920]                     {
[10:33:15.920]                       base::local({
[10:33:15.920]                         has_future <- base::requireNamespace("future", 
[10:33:15.920]                           quietly = TRUE)
[10:33:15.920]                         if (has_future) {
[10:33:15.920]                           ns <- base::getNamespace("future")
[10:33:15.920]                           version <- ns[[".package"]][["version"]]
[10:33:15.920]                           if (is.null(version)) 
[10:33:15.920]                             version <- utils::packageVersion("future")
[10:33:15.920]                         }
[10:33:15.920]                         else {
[10:33:15.920]                           version <- NULL
[10:33:15.920]                         }
[10:33:15.920]                         if (!has_future || version < "1.8.0") {
[10:33:15.920]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:15.920]                             "", base::R.version$version.string), 
[10:33:15.920]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:15.920]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:15.920]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:15.920]                               "release", "version")], collapse = " "), 
[10:33:15.920]                             hostname = base::Sys.info()[["nodename"]])
[10:33:15.920]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:15.920]                             info)
[10:33:15.920]                           info <- base::paste(info, collapse = "; ")
[10:33:15.920]                           if (!has_future) {
[10:33:15.920]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:15.920]                               info)
[10:33:15.920]                           }
[10:33:15.920]                           else {
[10:33:15.920]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:15.920]                               info, version)
[10:33:15.920]                           }
[10:33:15.920]                           base::stop(msg)
[10:33:15.920]                         }
[10:33:15.920]                       })
[10:33:15.920]                     }
[10:33:15.920]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:15.920]                     base::options(mc.cores = 1L)
[10:33:15.920]                   }
[10:33:15.920]                   ...future.strategy.old <- future::plan("list")
[10:33:15.920]                   options(future.plan = NULL)
[10:33:15.920]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.920]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:15.920]                 }
[10:33:15.920]                 ...future.workdir <- getwd()
[10:33:15.920]             }
[10:33:15.920]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:15.920]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:15.920]         }
[10:33:15.920]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:15.920]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:15.920]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:15.920]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:15.920]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:15.920]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:15.920]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:15.920]             base::names(...future.oldOptions))
[10:33:15.920]     }
[10:33:15.920]     if (FALSE) {
[10:33:15.920]     }
[10:33:15.920]     else {
[10:33:15.920]         if (TRUE) {
[10:33:15.920]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:15.920]                 open = "w")
[10:33:15.920]         }
[10:33:15.920]         else {
[10:33:15.920]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:15.920]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:15.920]         }
[10:33:15.920]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:15.920]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:15.920]             base::sink(type = "output", split = FALSE)
[10:33:15.920]             base::close(...future.stdout)
[10:33:15.920]         }, add = TRUE)
[10:33:15.920]     }
[10:33:15.920]     ...future.frame <- base::sys.nframe()
[10:33:15.920]     ...future.conditions <- base::list()
[10:33:15.920]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:15.920]     if (FALSE) {
[10:33:15.920]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:15.920]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:15.920]     }
[10:33:15.920]     ...future.result <- base::tryCatch({
[10:33:15.920]         base::withCallingHandlers({
[10:33:15.920]             ...future.value <- base::withVisible(base::local({
[10:33:15.920]                 ...future.makeSendCondition <- base::local({
[10:33:15.920]                   sendCondition <- NULL
[10:33:15.920]                   function(frame = 1L) {
[10:33:15.920]                     if (is.function(sendCondition)) 
[10:33:15.920]                       return(sendCondition)
[10:33:15.920]                     ns <- getNamespace("parallel")
[10:33:15.920]                     if (exists("sendData", mode = "function", 
[10:33:15.920]                       envir = ns)) {
[10:33:15.920]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:15.920]                         envir = ns)
[10:33:15.920]                       envir <- sys.frame(frame)
[10:33:15.920]                       master <- NULL
[10:33:15.920]                       while (!identical(envir, .GlobalEnv) && 
[10:33:15.920]                         !identical(envir, emptyenv())) {
[10:33:15.920]                         if (exists("master", mode = "list", envir = envir, 
[10:33:15.920]                           inherits = FALSE)) {
[10:33:15.920]                           master <- get("master", mode = "list", 
[10:33:15.920]                             envir = envir, inherits = FALSE)
[10:33:15.920]                           if (inherits(master, c("SOCKnode", 
[10:33:15.920]                             "SOCK0node"))) {
[10:33:15.920]                             sendCondition <<- function(cond) {
[10:33:15.920]                               data <- list(type = "VALUE", value = cond, 
[10:33:15.920]                                 success = TRUE)
[10:33:15.920]                               parallel_sendData(master, data)
[10:33:15.920]                             }
[10:33:15.920]                             return(sendCondition)
[10:33:15.920]                           }
[10:33:15.920]                         }
[10:33:15.920]                         frame <- frame + 1L
[10:33:15.920]                         envir <- sys.frame(frame)
[10:33:15.920]                       }
[10:33:15.920]                     }
[10:33:15.920]                     sendCondition <<- function(cond) NULL
[10:33:15.920]                   }
[10:33:15.920]                 })
[10:33:15.920]                 withCallingHandlers({
[10:33:15.920]                   {
[10:33:15.920]                     b <- a * ii
[10:33:15.920]                     a <- 0
[10:33:15.920]                     b
[10:33:15.920]                   }
[10:33:15.920]                 }, immediateCondition = function(cond) {
[10:33:15.920]                   sendCondition <- ...future.makeSendCondition()
[10:33:15.920]                   sendCondition(cond)
[10:33:15.920]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.920]                   {
[10:33:15.920]                     inherits <- base::inherits
[10:33:15.920]                     invokeRestart <- base::invokeRestart
[10:33:15.920]                     is.null <- base::is.null
[10:33:15.920]                     muffled <- FALSE
[10:33:15.920]                     if (inherits(cond, "message")) {
[10:33:15.920]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:15.920]                       if (muffled) 
[10:33:15.920]                         invokeRestart("muffleMessage")
[10:33:15.920]                     }
[10:33:15.920]                     else if (inherits(cond, "warning")) {
[10:33:15.920]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:15.920]                       if (muffled) 
[10:33:15.920]                         invokeRestart("muffleWarning")
[10:33:15.920]                     }
[10:33:15.920]                     else if (inherits(cond, "condition")) {
[10:33:15.920]                       if (!is.null(pattern)) {
[10:33:15.920]                         computeRestarts <- base::computeRestarts
[10:33:15.920]                         grepl <- base::grepl
[10:33:15.920]                         restarts <- computeRestarts(cond)
[10:33:15.920]                         for (restart in restarts) {
[10:33:15.920]                           name <- restart$name
[10:33:15.920]                           if (is.null(name)) 
[10:33:15.920]                             next
[10:33:15.920]                           if (!grepl(pattern, name)) 
[10:33:15.920]                             next
[10:33:15.920]                           invokeRestart(restart)
[10:33:15.920]                           muffled <- TRUE
[10:33:15.920]                           break
[10:33:15.920]                         }
[10:33:15.920]                       }
[10:33:15.920]                     }
[10:33:15.920]                     invisible(muffled)
[10:33:15.920]                   }
[10:33:15.920]                   muffleCondition(cond)
[10:33:15.920]                 })
[10:33:15.920]             }))
[10:33:15.920]             future::FutureResult(value = ...future.value$value, 
[10:33:15.920]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.920]                   ...future.rng), globalenv = if (FALSE) 
[10:33:15.920]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:15.920]                     ...future.globalenv.names))
[10:33:15.920]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:15.920]         }, condition = base::local({
[10:33:15.920]             c <- base::c
[10:33:15.920]             inherits <- base::inherits
[10:33:15.920]             invokeRestart <- base::invokeRestart
[10:33:15.920]             length <- base::length
[10:33:15.920]             list <- base::list
[10:33:15.920]             seq.int <- base::seq.int
[10:33:15.920]             signalCondition <- base::signalCondition
[10:33:15.920]             sys.calls <- base::sys.calls
[10:33:15.920]             `[[` <- base::`[[`
[10:33:15.920]             `+` <- base::`+`
[10:33:15.920]             `<<-` <- base::`<<-`
[10:33:15.920]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:15.920]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:15.920]                   3L)]
[10:33:15.920]             }
[10:33:15.920]             function(cond) {
[10:33:15.920]                 is_error <- inherits(cond, "error")
[10:33:15.920]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:15.920]                   NULL)
[10:33:15.920]                 if (is_error) {
[10:33:15.920]                   sessionInformation <- function() {
[10:33:15.920]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:15.920]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:15.920]                       search = base::search(), system = base::Sys.info())
[10:33:15.920]                   }
[10:33:15.920]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.920]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:15.920]                     cond$call), session = sessionInformation(), 
[10:33:15.920]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:15.920]                   signalCondition(cond)
[10:33:15.920]                 }
[10:33:15.920]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:15.920]                 "immediateCondition"))) {
[10:33:15.920]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:15.920]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.920]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:15.920]                   if (TRUE && !signal) {
[10:33:15.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.920]                     {
[10:33:15.920]                       inherits <- base::inherits
[10:33:15.920]                       invokeRestart <- base::invokeRestart
[10:33:15.920]                       is.null <- base::is.null
[10:33:15.920]                       muffled <- FALSE
[10:33:15.920]                       if (inherits(cond, "message")) {
[10:33:15.920]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.920]                         if (muffled) 
[10:33:15.920]                           invokeRestart("muffleMessage")
[10:33:15.920]                       }
[10:33:15.920]                       else if (inherits(cond, "warning")) {
[10:33:15.920]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.920]                         if (muffled) 
[10:33:15.920]                           invokeRestart("muffleWarning")
[10:33:15.920]                       }
[10:33:15.920]                       else if (inherits(cond, "condition")) {
[10:33:15.920]                         if (!is.null(pattern)) {
[10:33:15.920]                           computeRestarts <- base::computeRestarts
[10:33:15.920]                           grepl <- base::grepl
[10:33:15.920]                           restarts <- computeRestarts(cond)
[10:33:15.920]                           for (restart in restarts) {
[10:33:15.920]                             name <- restart$name
[10:33:15.920]                             if (is.null(name)) 
[10:33:15.920]                               next
[10:33:15.920]                             if (!grepl(pattern, name)) 
[10:33:15.920]                               next
[10:33:15.920]                             invokeRestart(restart)
[10:33:15.920]                             muffled <- TRUE
[10:33:15.920]                             break
[10:33:15.920]                           }
[10:33:15.920]                         }
[10:33:15.920]                       }
[10:33:15.920]                       invisible(muffled)
[10:33:15.920]                     }
[10:33:15.920]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.920]                   }
[10:33:15.920]                 }
[10:33:15.920]                 else {
[10:33:15.920]                   if (TRUE) {
[10:33:15.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.920]                     {
[10:33:15.920]                       inherits <- base::inherits
[10:33:15.920]                       invokeRestart <- base::invokeRestart
[10:33:15.920]                       is.null <- base::is.null
[10:33:15.920]                       muffled <- FALSE
[10:33:15.920]                       if (inherits(cond, "message")) {
[10:33:15.920]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.920]                         if (muffled) 
[10:33:15.920]                           invokeRestart("muffleMessage")
[10:33:15.920]                       }
[10:33:15.920]                       else if (inherits(cond, "warning")) {
[10:33:15.920]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.920]                         if (muffled) 
[10:33:15.920]                           invokeRestart("muffleWarning")
[10:33:15.920]                       }
[10:33:15.920]                       else if (inherits(cond, "condition")) {
[10:33:15.920]                         if (!is.null(pattern)) {
[10:33:15.920]                           computeRestarts <- base::computeRestarts
[10:33:15.920]                           grepl <- base::grepl
[10:33:15.920]                           restarts <- computeRestarts(cond)
[10:33:15.920]                           for (restart in restarts) {
[10:33:15.920]                             name <- restart$name
[10:33:15.920]                             if (is.null(name)) 
[10:33:15.920]                               next
[10:33:15.920]                             if (!grepl(pattern, name)) 
[10:33:15.920]                               next
[10:33:15.920]                             invokeRestart(restart)
[10:33:15.920]                             muffled <- TRUE
[10:33:15.920]                             break
[10:33:15.920]                           }
[10:33:15.920]                         }
[10:33:15.920]                       }
[10:33:15.920]                       invisible(muffled)
[10:33:15.920]                     }
[10:33:15.920]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.920]                   }
[10:33:15.920]                 }
[10:33:15.920]             }
[10:33:15.920]         }))
[10:33:15.920]     }, error = function(ex) {
[10:33:15.920]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:15.920]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.920]                 ...future.rng), started = ...future.startTime, 
[10:33:15.920]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:15.920]             version = "1.8"), class = "FutureResult")
[10:33:15.920]     }, finally = {
[10:33:15.920]         if (!identical(...future.workdir, getwd())) 
[10:33:15.920]             setwd(...future.workdir)
[10:33:15.920]         {
[10:33:15.920]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:15.920]                 ...future.oldOptions$nwarnings <- NULL
[10:33:15.920]             }
[10:33:15.920]             base::options(...future.oldOptions)
[10:33:15.920]             if (.Platform$OS.type == "windows") {
[10:33:15.920]                 old_names <- names(...future.oldEnvVars)
[10:33:15.920]                 envs <- base::Sys.getenv()
[10:33:15.920]                 names <- names(envs)
[10:33:15.920]                 common <- intersect(names, old_names)
[10:33:15.920]                 added <- setdiff(names, old_names)
[10:33:15.920]                 removed <- setdiff(old_names, names)
[10:33:15.920]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:15.920]                   envs[common]]
[10:33:15.920]                 NAMES <- toupper(changed)
[10:33:15.920]                 args <- list()
[10:33:15.920]                 for (kk in seq_along(NAMES)) {
[10:33:15.920]                   name <- changed[[kk]]
[10:33:15.920]                   NAME <- NAMES[[kk]]
[10:33:15.920]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.920]                     next
[10:33:15.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.920]                 }
[10:33:15.920]                 NAMES <- toupper(added)
[10:33:15.920]                 for (kk in seq_along(NAMES)) {
[10:33:15.920]                   name <- added[[kk]]
[10:33:15.920]                   NAME <- NAMES[[kk]]
[10:33:15.920]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.920]                     next
[10:33:15.920]                   args[[name]] <- ""
[10:33:15.920]                 }
[10:33:15.920]                 NAMES <- toupper(removed)
[10:33:15.920]                 for (kk in seq_along(NAMES)) {
[10:33:15.920]                   name <- removed[[kk]]
[10:33:15.920]                   NAME <- NAMES[[kk]]
[10:33:15.920]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.920]                     next
[10:33:15.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.920]                 }
[10:33:15.920]                 if (length(args) > 0) 
[10:33:15.920]                   base::do.call(base::Sys.setenv, args = args)
[10:33:15.920]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:15.920]             }
[10:33:15.920]             else {
[10:33:15.920]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:15.920]             }
[10:33:15.920]             {
[10:33:15.920]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:15.920]                   0L) {
[10:33:15.920]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:15.920]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:15.920]                   base::options(opts)
[10:33:15.920]                 }
[10:33:15.920]                 {
[10:33:15.920]                   {
[10:33:15.920]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:15.920]                     NULL
[10:33:15.920]                   }
[10:33:15.920]                   options(future.plan = NULL)
[10:33:15.920]                   if (is.na(NA_character_)) 
[10:33:15.920]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.920]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:15.920]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:15.920]                     .init = FALSE)
[10:33:15.920]                 }
[10:33:15.920]             }
[10:33:15.920]         }
[10:33:15.920]     })
[10:33:15.920]     if (TRUE) {
[10:33:15.920]         base::sink(type = "output", split = FALSE)
[10:33:15.920]         if (TRUE) {
[10:33:15.920]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:15.920]         }
[10:33:15.920]         else {
[10:33:15.920]             ...future.result["stdout"] <- base::list(NULL)
[10:33:15.920]         }
[10:33:15.920]         base::close(...future.stdout)
[10:33:15.920]         ...future.stdout <- NULL
[10:33:15.920]     }
[10:33:15.920]     ...future.result$conditions <- ...future.conditions
[10:33:15.920]     ...future.result$finished <- base::Sys.time()
[10:33:15.920]     ...future.result
[10:33:15.920] }
[10:33:15.923] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[10:33:15.923] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[10:33:15.925] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[10:33:15.925] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[10:33:15.926] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[10:33:15.926] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[10:33:15.926] MultisessionFuture started
[10:33:15.926] - Launch lazy future ... done
[10:33:15.927] run() for ‘MultisessionFuture’ ... done
[10:33:15.927] result() for ClusterFuture ...
[10:33:15.927] receiveMessageFromWorker() for ClusterFuture ...
[10:33:15.927] - Validating connection of MultisessionFuture
[10:33:15.928] - received message: FutureResult
[10:33:15.928] - Received FutureResult
[10:33:15.928] - Erased future from FutureRegistry
[10:33:15.928] result() for ClusterFuture ...
[10:33:15.928] - result already collected: FutureResult
[10:33:15.928] result() for ClusterFuture ... done
[10:33:15.928] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:15.929] result() for ClusterFuture ... done
[10:33:15.929] result() for ClusterFuture ...
[10:33:15.929] - result already collected: FutureResult
[10:33:15.929] result() for ClusterFuture ... done
[10:33:15.929] run() for ‘Future’ ...
[10:33:15.929] - state: ‘created’
[10:33:15.929] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:15.943] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:15.943] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:15.943]   - Field: ‘node’
[10:33:15.943]   - Field: ‘label’
[10:33:15.943]   - Field: ‘local’
[10:33:15.943]   - Field: ‘owner’
[10:33:15.943]   - Field: ‘envir’
[10:33:15.943]   - Field: ‘workers’
[10:33:15.943]   - Field: ‘packages’
[10:33:15.943]   - Field: ‘gc’
[10:33:15.944]   - Field: ‘conditions’
[10:33:15.944]   - Field: ‘persistent’
[10:33:15.944]   - Field: ‘expr’
[10:33:15.944]   - Field: ‘uuid’
[10:33:15.944]   - Field: ‘seed’
[10:33:15.944]   - Field: ‘version’
[10:33:15.944]   - Field: ‘result’
[10:33:15.944]   - Field: ‘asynchronous’
[10:33:15.944]   - Field: ‘calls’
[10:33:15.944]   - Field: ‘globals’
[10:33:15.944]   - Field: ‘stdout’
[10:33:15.944]   - Field: ‘earlySignal’
[10:33:15.945]   - Field: ‘lazy’
[10:33:15.945]   - Field: ‘state’
[10:33:15.945] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:15.945] - Launch lazy future ...
[10:33:15.945] Packages needed by the future expression (n = 0): <none>
[10:33:15.945] Packages needed by future strategies (n = 0): <none>
[10:33:15.946] {
[10:33:15.946]     {
[10:33:15.946]         {
[10:33:15.946]             ...future.startTime <- base::Sys.time()
[10:33:15.946]             {
[10:33:15.946]                 {
[10:33:15.946]                   {
[10:33:15.946]                     {
[10:33:15.946]                       base::local({
[10:33:15.946]                         has_future <- base::requireNamespace("future", 
[10:33:15.946]                           quietly = TRUE)
[10:33:15.946]                         if (has_future) {
[10:33:15.946]                           ns <- base::getNamespace("future")
[10:33:15.946]                           version <- ns[[".package"]][["version"]]
[10:33:15.946]                           if (is.null(version)) 
[10:33:15.946]                             version <- utils::packageVersion("future")
[10:33:15.946]                         }
[10:33:15.946]                         else {
[10:33:15.946]                           version <- NULL
[10:33:15.946]                         }
[10:33:15.946]                         if (!has_future || version < "1.8.0") {
[10:33:15.946]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:15.946]                             "", base::R.version$version.string), 
[10:33:15.946]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:15.946]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:15.946]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:15.946]                               "release", "version")], collapse = " "), 
[10:33:15.946]                             hostname = base::Sys.info()[["nodename"]])
[10:33:15.946]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:15.946]                             info)
[10:33:15.946]                           info <- base::paste(info, collapse = "; ")
[10:33:15.946]                           if (!has_future) {
[10:33:15.946]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:15.946]                               info)
[10:33:15.946]                           }
[10:33:15.946]                           else {
[10:33:15.946]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:15.946]                               info, version)
[10:33:15.946]                           }
[10:33:15.946]                           base::stop(msg)
[10:33:15.946]                         }
[10:33:15.946]                       })
[10:33:15.946]                     }
[10:33:15.946]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:15.946]                     base::options(mc.cores = 1L)
[10:33:15.946]                   }
[10:33:15.946]                   ...future.strategy.old <- future::plan("list")
[10:33:15.946]                   options(future.plan = NULL)
[10:33:15.946]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.946]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:15.946]                 }
[10:33:15.946]                 ...future.workdir <- getwd()
[10:33:15.946]             }
[10:33:15.946]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:15.946]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:15.946]         }
[10:33:15.946]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:15.946]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:15.946]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:15.946]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:15.946]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:15.946]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:15.946]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:15.946]             base::names(...future.oldOptions))
[10:33:15.946]     }
[10:33:15.946]     if (FALSE) {
[10:33:15.946]     }
[10:33:15.946]     else {
[10:33:15.946]         if (TRUE) {
[10:33:15.946]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:15.946]                 open = "w")
[10:33:15.946]         }
[10:33:15.946]         else {
[10:33:15.946]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:15.946]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:15.946]         }
[10:33:15.946]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:15.946]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:15.946]             base::sink(type = "output", split = FALSE)
[10:33:15.946]             base::close(...future.stdout)
[10:33:15.946]         }, add = TRUE)
[10:33:15.946]     }
[10:33:15.946]     ...future.frame <- base::sys.nframe()
[10:33:15.946]     ...future.conditions <- base::list()
[10:33:15.946]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:15.946]     if (FALSE) {
[10:33:15.946]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:15.946]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:15.946]     }
[10:33:15.946]     ...future.result <- base::tryCatch({
[10:33:15.946]         base::withCallingHandlers({
[10:33:15.946]             ...future.value <- base::withVisible(base::local({
[10:33:15.946]                 ...future.makeSendCondition <- base::local({
[10:33:15.946]                   sendCondition <- NULL
[10:33:15.946]                   function(frame = 1L) {
[10:33:15.946]                     if (is.function(sendCondition)) 
[10:33:15.946]                       return(sendCondition)
[10:33:15.946]                     ns <- getNamespace("parallel")
[10:33:15.946]                     if (exists("sendData", mode = "function", 
[10:33:15.946]                       envir = ns)) {
[10:33:15.946]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:15.946]                         envir = ns)
[10:33:15.946]                       envir <- sys.frame(frame)
[10:33:15.946]                       master <- NULL
[10:33:15.946]                       while (!identical(envir, .GlobalEnv) && 
[10:33:15.946]                         !identical(envir, emptyenv())) {
[10:33:15.946]                         if (exists("master", mode = "list", envir = envir, 
[10:33:15.946]                           inherits = FALSE)) {
[10:33:15.946]                           master <- get("master", mode = "list", 
[10:33:15.946]                             envir = envir, inherits = FALSE)
[10:33:15.946]                           if (inherits(master, c("SOCKnode", 
[10:33:15.946]                             "SOCK0node"))) {
[10:33:15.946]                             sendCondition <<- function(cond) {
[10:33:15.946]                               data <- list(type = "VALUE", value = cond, 
[10:33:15.946]                                 success = TRUE)
[10:33:15.946]                               parallel_sendData(master, data)
[10:33:15.946]                             }
[10:33:15.946]                             return(sendCondition)
[10:33:15.946]                           }
[10:33:15.946]                         }
[10:33:15.946]                         frame <- frame + 1L
[10:33:15.946]                         envir <- sys.frame(frame)
[10:33:15.946]                       }
[10:33:15.946]                     }
[10:33:15.946]                     sendCondition <<- function(cond) NULL
[10:33:15.946]                   }
[10:33:15.946]                 })
[10:33:15.946]                 withCallingHandlers({
[10:33:15.946]                   {
[10:33:15.946]                     b <- a * ii
[10:33:15.946]                     a <- 0
[10:33:15.946]                     b
[10:33:15.946]                   }
[10:33:15.946]                 }, immediateCondition = function(cond) {
[10:33:15.946]                   sendCondition <- ...future.makeSendCondition()
[10:33:15.946]                   sendCondition(cond)
[10:33:15.946]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.946]                   {
[10:33:15.946]                     inherits <- base::inherits
[10:33:15.946]                     invokeRestart <- base::invokeRestart
[10:33:15.946]                     is.null <- base::is.null
[10:33:15.946]                     muffled <- FALSE
[10:33:15.946]                     if (inherits(cond, "message")) {
[10:33:15.946]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:15.946]                       if (muffled) 
[10:33:15.946]                         invokeRestart("muffleMessage")
[10:33:15.946]                     }
[10:33:15.946]                     else if (inherits(cond, "warning")) {
[10:33:15.946]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:15.946]                       if (muffled) 
[10:33:15.946]                         invokeRestart("muffleWarning")
[10:33:15.946]                     }
[10:33:15.946]                     else if (inherits(cond, "condition")) {
[10:33:15.946]                       if (!is.null(pattern)) {
[10:33:15.946]                         computeRestarts <- base::computeRestarts
[10:33:15.946]                         grepl <- base::grepl
[10:33:15.946]                         restarts <- computeRestarts(cond)
[10:33:15.946]                         for (restart in restarts) {
[10:33:15.946]                           name <- restart$name
[10:33:15.946]                           if (is.null(name)) 
[10:33:15.946]                             next
[10:33:15.946]                           if (!grepl(pattern, name)) 
[10:33:15.946]                             next
[10:33:15.946]                           invokeRestart(restart)
[10:33:15.946]                           muffled <- TRUE
[10:33:15.946]                           break
[10:33:15.946]                         }
[10:33:15.946]                       }
[10:33:15.946]                     }
[10:33:15.946]                     invisible(muffled)
[10:33:15.946]                   }
[10:33:15.946]                   muffleCondition(cond)
[10:33:15.946]                 })
[10:33:15.946]             }))
[10:33:15.946]             future::FutureResult(value = ...future.value$value, 
[10:33:15.946]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.946]                   ...future.rng), globalenv = if (FALSE) 
[10:33:15.946]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:15.946]                     ...future.globalenv.names))
[10:33:15.946]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:15.946]         }, condition = base::local({
[10:33:15.946]             c <- base::c
[10:33:15.946]             inherits <- base::inherits
[10:33:15.946]             invokeRestart <- base::invokeRestart
[10:33:15.946]             length <- base::length
[10:33:15.946]             list <- base::list
[10:33:15.946]             seq.int <- base::seq.int
[10:33:15.946]             signalCondition <- base::signalCondition
[10:33:15.946]             sys.calls <- base::sys.calls
[10:33:15.946]             `[[` <- base::`[[`
[10:33:15.946]             `+` <- base::`+`
[10:33:15.946]             `<<-` <- base::`<<-`
[10:33:15.946]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:15.946]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:15.946]                   3L)]
[10:33:15.946]             }
[10:33:15.946]             function(cond) {
[10:33:15.946]                 is_error <- inherits(cond, "error")
[10:33:15.946]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:15.946]                   NULL)
[10:33:15.946]                 if (is_error) {
[10:33:15.946]                   sessionInformation <- function() {
[10:33:15.946]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:15.946]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:15.946]                       search = base::search(), system = base::Sys.info())
[10:33:15.946]                   }
[10:33:15.946]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.946]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:15.946]                     cond$call), session = sessionInformation(), 
[10:33:15.946]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:15.946]                   signalCondition(cond)
[10:33:15.946]                 }
[10:33:15.946]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:15.946]                 "immediateCondition"))) {
[10:33:15.946]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:15.946]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.946]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:15.946]                   if (TRUE && !signal) {
[10:33:15.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.946]                     {
[10:33:15.946]                       inherits <- base::inherits
[10:33:15.946]                       invokeRestart <- base::invokeRestart
[10:33:15.946]                       is.null <- base::is.null
[10:33:15.946]                       muffled <- FALSE
[10:33:15.946]                       if (inherits(cond, "message")) {
[10:33:15.946]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.946]                         if (muffled) 
[10:33:15.946]                           invokeRestart("muffleMessage")
[10:33:15.946]                       }
[10:33:15.946]                       else if (inherits(cond, "warning")) {
[10:33:15.946]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.946]                         if (muffled) 
[10:33:15.946]                           invokeRestart("muffleWarning")
[10:33:15.946]                       }
[10:33:15.946]                       else if (inherits(cond, "condition")) {
[10:33:15.946]                         if (!is.null(pattern)) {
[10:33:15.946]                           computeRestarts <- base::computeRestarts
[10:33:15.946]                           grepl <- base::grepl
[10:33:15.946]                           restarts <- computeRestarts(cond)
[10:33:15.946]                           for (restart in restarts) {
[10:33:15.946]                             name <- restart$name
[10:33:15.946]                             if (is.null(name)) 
[10:33:15.946]                               next
[10:33:15.946]                             if (!grepl(pattern, name)) 
[10:33:15.946]                               next
[10:33:15.946]                             invokeRestart(restart)
[10:33:15.946]                             muffled <- TRUE
[10:33:15.946]                             break
[10:33:15.946]                           }
[10:33:15.946]                         }
[10:33:15.946]                       }
[10:33:15.946]                       invisible(muffled)
[10:33:15.946]                     }
[10:33:15.946]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.946]                   }
[10:33:15.946]                 }
[10:33:15.946]                 else {
[10:33:15.946]                   if (TRUE) {
[10:33:15.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.946]                     {
[10:33:15.946]                       inherits <- base::inherits
[10:33:15.946]                       invokeRestart <- base::invokeRestart
[10:33:15.946]                       is.null <- base::is.null
[10:33:15.946]                       muffled <- FALSE
[10:33:15.946]                       if (inherits(cond, "message")) {
[10:33:15.946]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.946]                         if (muffled) 
[10:33:15.946]                           invokeRestart("muffleMessage")
[10:33:15.946]                       }
[10:33:15.946]                       else if (inherits(cond, "warning")) {
[10:33:15.946]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.946]                         if (muffled) 
[10:33:15.946]                           invokeRestart("muffleWarning")
[10:33:15.946]                       }
[10:33:15.946]                       else if (inherits(cond, "condition")) {
[10:33:15.946]                         if (!is.null(pattern)) {
[10:33:15.946]                           computeRestarts <- base::computeRestarts
[10:33:15.946]                           grepl <- base::grepl
[10:33:15.946]                           restarts <- computeRestarts(cond)
[10:33:15.946]                           for (restart in restarts) {
[10:33:15.946]                             name <- restart$name
[10:33:15.946]                             if (is.null(name)) 
[10:33:15.946]                               next
[10:33:15.946]                             if (!grepl(pattern, name)) 
[10:33:15.946]                               next
[10:33:15.946]                             invokeRestart(restart)
[10:33:15.946]                             muffled <- TRUE
[10:33:15.946]                             break
[10:33:15.946]                           }
[10:33:15.946]                         }
[10:33:15.946]                       }
[10:33:15.946]                       invisible(muffled)
[10:33:15.946]                     }
[10:33:15.946]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.946]                   }
[10:33:15.946]                 }
[10:33:15.946]             }
[10:33:15.946]         }))
[10:33:15.946]     }, error = function(ex) {
[10:33:15.946]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:15.946]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.946]                 ...future.rng), started = ...future.startTime, 
[10:33:15.946]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:15.946]             version = "1.8"), class = "FutureResult")
[10:33:15.946]     }, finally = {
[10:33:15.946]         if (!identical(...future.workdir, getwd())) 
[10:33:15.946]             setwd(...future.workdir)
[10:33:15.946]         {
[10:33:15.946]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:15.946]                 ...future.oldOptions$nwarnings <- NULL
[10:33:15.946]             }
[10:33:15.946]             base::options(...future.oldOptions)
[10:33:15.946]             if (.Platform$OS.type == "windows") {
[10:33:15.946]                 old_names <- names(...future.oldEnvVars)
[10:33:15.946]                 envs <- base::Sys.getenv()
[10:33:15.946]                 names <- names(envs)
[10:33:15.946]                 common <- intersect(names, old_names)
[10:33:15.946]                 added <- setdiff(names, old_names)
[10:33:15.946]                 removed <- setdiff(old_names, names)
[10:33:15.946]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:15.946]                   envs[common]]
[10:33:15.946]                 NAMES <- toupper(changed)
[10:33:15.946]                 args <- list()
[10:33:15.946]                 for (kk in seq_along(NAMES)) {
[10:33:15.946]                   name <- changed[[kk]]
[10:33:15.946]                   NAME <- NAMES[[kk]]
[10:33:15.946]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.946]                     next
[10:33:15.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.946]                 }
[10:33:15.946]                 NAMES <- toupper(added)
[10:33:15.946]                 for (kk in seq_along(NAMES)) {
[10:33:15.946]                   name <- added[[kk]]
[10:33:15.946]                   NAME <- NAMES[[kk]]
[10:33:15.946]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.946]                     next
[10:33:15.946]                   args[[name]] <- ""
[10:33:15.946]                 }
[10:33:15.946]                 NAMES <- toupper(removed)
[10:33:15.946]                 for (kk in seq_along(NAMES)) {
[10:33:15.946]                   name <- removed[[kk]]
[10:33:15.946]                   NAME <- NAMES[[kk]]
[10:33:15.946]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.946]                     next
[10:33:15.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.946]                 }
[10:33:15.946]                 if (length(args) > 0) 
[10:33:15.946]                   base::do.call(base::Sys.setenv, args = args)
[10:33:15.946]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:15.946]             }
[10:33:15.946]             else {
[10:33:15.946]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:15.946]             }
[10:33:15.946]             {
[10:33:15.946]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:15.946]                   0L) {
[10:33:15.946]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:15.946]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:15.946]                   base::options(opts)
[10:33:15.946]                 }
[10:33:15.946]                 {
[10:33:15.946]                   {
[10:33:15.946]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:15.946]                     NULL
[10:33:15.946]                   }
[10:33:15.946]                   options(future.plan = NULL)
[10:33:15.946]                   if (is.na(NA_character_)) 
[10:33:15.946]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.946]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:15.946]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:15.946]                     .init = FALSE)
[10:33:15.946]                 }
[10:33:15.946]             }
[10:33:15.946]         }
[10:33:15.946]     })
[10:33:15.946]     if (TRUE) {
[10:33:15.946]         base::sink(type = "output", split = FALSE)
[10:33:15.946]         if (TRUE) {
[10:33:15.946]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:15.946]         }
[10:33:15.946]         else {
[10:33:15.946]             ...future.result["stdout"] <- base::list(NULL)
[10:33:15.946]         }
[10:33:15.946]         base::close(...future.stdout)
[10:33:15.946]         ...future.stdout <- NULL
[10:33:15.946]     }
[10:33:15.946]     ...future.result$conditions <- ...future.conditions
[10:33:15.946]     ...future.result$finished <- base::Sys.time()
[10:33:15.946]     ...future.result
[10:33:15.946] }
[10:33:15.948] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[10:33:15.948] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[10:33:15.948] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[10:33:15.949] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[10:33:15.949] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[10:33:15.949] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[10:33:15.950] MultisessionFuture started
[10:33:15.950] - Launch lazy future ... done
[10:33:15.950] run() for ‘MultisessionFuture’ ... done
[10:33:15.950] result() for ClusterFuture ...
[10:33:15.950] receiveMessageFromWorker() for ClusterFuture ...
[10:33:15.950] - Validating connection of MultisessionFuture
[10:33:15.951] - received message: FutureResult
[10:33:15.951] - Received FutureResult
[10:33:15.951] - Erased future from FutureRegistry
[10:33:15.951] result() for ClusterFuture ...
[10:33:15.951] - result already collected: FutureResult
[10:33:15.951] result() for ClusterFuture ... done
[10:33:15.952] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:15.952] result() for ClusterFuture ... done
[10:33:15.952] result() for ClusterFuture ...
[10:33:15.952] - result already collected: FutureResult
[10:33:15.952] result() for ClusterFuture ... done
[10:33:15.952] run() for ‘Future’ ...
[10:33:15.952] - state: ‘created’
[10:33:15.952] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:15.966] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:15.966] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:15.966]   - Field: ‘node’
[10:33:15.966]   - Field: ‘label’
[10:33:15.966]   - Field: ‘local’
[10:33:15.966]   - Field: ‘owner’
[10:33:15.966]   - Field: ‘envir’
[10:33:15.966]   - Field: ‘workers’
[10:33:15.966]   - Field: ‘packages’
[10:33:15.966]   - Field: ‘gc’
[10:33:15.967]   - Field: ‘conditions’
[10:33:15.967]   - Field: ‘persistent’
[10:33:15.967]   - Field: ‘expr’
[10:33:15.967]   - Field: ‘uuid’
[10:33:15.967]   - Field: ‘seed’
[10:33:15.967]   - Field: ‘version’
[10:33:15.967]   - Field: ‘result’
[10:33:15.967]   - Field: ‘asynchronous’
[10:33:15.967]   - Field: ‘calls’
[10:33:15.967]   - Field: ‘globals’
[10:33:15.967]   - Field: ‘stdout’
[10:33:15.968]   - Field: ‘earlySignal’
[10:33:15.968]   - Field: ‘lazy’
[10:33:15.968]   - Field: ‘state’
[10:33:15.968] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:15.968] - Launch lazy future ...
[10:33:15.968] Packages needed by the future expression (n = 0): <none>
[10:33:15.968] Packages needed by future strategies (n = 0): <none>
[10:33:15.969] {
[10:33:15.969]     {
[10:33:15.969]         {
[10:33:15.969]             ...future.startTime <- base::Sys.time()
[10:33:15.969]             {
[10:33:15.969]                 {
[10:33:15.969]                   {
[10:33:15.969]                     {
[10:33:15.969]                       base::local({
[10:33:15.969]                         has_future <- base::requireNamespace("future", 
[10:33:15.969]                           quietly = TRUE)
[10:33:15.969]                         if (has_future) {
[10:33:15.969]                           ns <- base::getNamespace("future")
[10:33:15.969]                           version <- ns[[".package"]][["version"]]
[10:33:15.969]                           if (is.null(version)) 
[10:33:15.969]                             version <- utils::packageVersion("future")
[10:33:15.969]                         }
[10:33:15.969]                         else {
[10:33:15.969]                           version <- NULL
[10:33:15.969]                         }
[10:33:15.969]                         if (!has_future || version < "1.8.0") {
[10:33:15.969]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:15.969]                             "", base::R.version$version.string), 
[10:33:15.969]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:15.969]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:15.969]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:15.969]                               "release", "version")], collapse = " "), 
[10:33:15.969]                             hostname = base::Sys.info()[["nodename"]])
[10:33:15.969]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:15.969]                             info)
[10:33:15.969]                           info <- base::paste(info, collapse = "; ")
[10:33:15.969]                           if (!has_future) {
[10:33:15.969]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:15.969]                               info)
[10:33:15.969]                           }
[10:33:15.969]                           else {
[10:33:15.969]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:15.969]                               info, version)
[10:33:15.969]                           }
[10:33:15.969]                           base::stop(msg)
[10:33:15.969]                         }
[10:33:15.969]                       })
[10:33:15.969]                     }
[10:33:15.969]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:15.969]                     base::options(mc.cores = 1L)
[10:33:15.969]                   }
[10:33:15.969]                   ...future.strategy.old <- future::plan("list")
[10:33:15.969]                   options(future.plan = NULL)
[10:33:15.969]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.969]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:15.969]                 }
[10:33:15.969]                 ...future.workdir <- getwd()
[10:33:15.969]             }
[10:33:15.969]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:15.969]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:15.969]         }
[10:33:15.969]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:15.969]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:15.969]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:15.969]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:15.969]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:15.969]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:15.969]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:15.969]             base::names(...future.oldOptions))
[10:33:15.969]     }
[10:33:15.969]     if (FALSE) {
[10:33:15.969]     }
[10:33:15.969]     else {
[10:33:15.969]         if (TRUE) {
[10:33:15.969]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:15.969]                 open = "w")
[10:33:15.969]         }
[10:33:15.969]         else {
[10:33:15.969]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:15.969]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:15.969]         }
[10:33:15.969]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:15.969]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:15.969]             base::sink(type = "output", split = FALSE)
[10:33:15.969]             base::close(...future.stdout)
[10:33:15.969]         }, add = TRUE)
[10:33:15.969]     }
[10:33:15.969]     ...future.frame <- base::sys.nframe()
[10:33:15.969]     ...future.conditions <- base::list()
[10:33:15.969]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:15.969]     if (FALSE) {
[10:33:15.969]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:15.969]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:15.969]     }
[10:33:15.969]     ...future.result <- base::tryCatch({
[10:33:15.969]         base::withCallingHandlers({
[10:33:15.969]             ...future.value <- base::withVisible(base::local({
[10:33:15.969]                 ...future.makeSendCondition <- base::local({
[10:33:15.969]                   sendCondition <- NULL
[10:33:15.969]                   function(frame = 1L) {
[10:33:15.969]                     if (is.function(sendCondition)) 
[10:33:15.969]                       return(sendCondition)
[10:33:15.969]                     ns <- getNamespace("parallel")
[10:33:15.969]                     if (exists("sendData", mode = "function", 
[10:33:15.969]                       envir = ns)) {
[10:33:15.969]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:15.969]                         envir = ns)
[10:33:15.969]                       envir <- sys.frame(frame)
[10:33:15.969]                       master <- NULL
[10:33:15.969]                       while (!identical(envir, .GlobalEnv) && 
[10:33:15.969]                         !identical(envir, emptyenv())) {
[10:33:15.969]                         if (exists("master", mode = "list", envir = envir, 
[10:33:15.969]                           inherits = FALSE)) {
[10:33:15.969]                           master <- get("master", mode = "list", 
[10:33:15.969]                             envir = envir, inherits = FALSE)
[10:33:15.969]                           if (inherits(master, c("SOCKnode", 
[10:33:15.969]                             "SOCK0node"))) {
[10:33:15.969]                             sendCondition <<- function(cond) {
[10:33:15.969]                               data <- list(type = "VALUE", value = cond, 
[10:33:15.969]                                 success = TRUE)
[10:33:15.969]                               parallel_sendData(master, data)
[10:33:15.969]                             }
[10:33:15.969]                             return(sendCondition)
[10:33:15.969]                           }
[10:33:15.969]                         }
[10:33:15.969]                         frame <- frame + 1L
[10:33:15.969]                         envir <- sys.frame(frame)
[10:33:15.969]                       }
[10:33:15.969]                     }
[10:33:15.969]                     sendCondition <<- function(cond) NULL
[10:33:15.969]                   }
[10:33:15.969]                 })
[10:33:15.969]                 withCallingHandlers({
[10:33:15.969]                   {
[10:33:15.969]                     b <- a * ii
[10:33:15.969]                     a <- 0
[10:33:15.969]                     b
[10:33:15.969]                   }
[10:33:15.969]                 }, immediateCondition = function(cond) {
[10:33:15.969]                   sendCondition <- ...future.makeSendCondition()
[10:33:15.969]                   sendCondition(cond)
[10:33:15.969]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.969]                   {
[10:33:15.969]                     inherits <- base::inherits
[10:33:15.969]                     invokeRestart <- base::invokeRestart
[10:33:15.969]                     is.null <- base::is.null
[10:33:15.969]                     muffled <- FALSE
[10:33:15.969]                     if (inherits(cond, "message")) {
[10:33:15.969]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:15.969]                       if (muffled) 
[10:33:15.969]                         invokeRestart("muffleMessage")
[10:33:15.969]                     }
[10:33:15.969]                     else if (inherits(cond, "warning")) {
[10:33:15.969]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:15.969]                       if (muffled) 
[10:33:15.969]                         invokeRestart("muffleWarning")
[10:33:15.969]                     }
[10:33:15.969]                     else if (inherits(cond, "condition")) {
[10:33:15.969]                       if (!is.null(pattern)) {
[10:33:15.969]                         computeRestarts <- base::computeRestarts
[10:33:15.969]                         grepl <- base::grepl
[10:33:15.969]                         restarts <- computeRestarts(cond)
[10:33:15.969]                         for (restart in restarts) {
[10:33:15.969]                           name <- restart$name
[10:33:15.969]                           if (is.null(name)) 
[10:33:15.969]                             next
[10:33:15.969]                           if (!grepl(pattern, name)) 
[10:33:15.969]                             next
[10:33:15.969]                           invokeRestart(restart)
[10:33:15.969]                           muffled <- TRUE
[10:33:15.969]                           break
[10:33:15.969]                         }
[10:33:15.969]                       }
[10:33:15.969]                     }
[10:33:15.969]                     invisible(muffled)
[10:33:15.969]                   }
[10:33:15.969]                   muffleCondition(cond)
[10:33:15.969]                 })
[10:33:15.969]             }))
[10:33:15.969]             future::FutureResult(value = ...future.value$value, 
[10:33:15.969]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.969]                   ...future.rng), globalenv = if (FALSE) 
[10:33:15.969]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:15.969]                     ...future.globalenv.names))
[10:33:15.969]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:15.969]         }, condition = base::local({
[10:33:15.969]             c <- base::c
[10:33:15.969]             inherits <- base::inherits
[10:33:15.969]             invokeRestart <- base::invokeRestart
[10:33:15.969]             length <- base::length
[10:33:15.969]             list <- base::list
[10:33:15.969]             seq.int <- base::seq.int
[10:33:15.969]             signalCondition <- base::signalCondition
[10:33:15.969]             sys.calls <- base::sys.calls
[10:33:15.969]             `[[` <- base::`[[`
[10:33:15.969]             `+` <- base::`+`
[10:33:15.969]             `<<-` <- base::`<<-`
[10:33:15.969]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:15.969]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:15.969]                   3L)]
[10:33:15.969]             }
[10:33:15.969]             function(cond) {
[10:33:15.969]                 is_error <- inherits(cond, "error")
[10:33:15.969]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:15.969]                   NULL)
[10:33:15.969]                 if (is_error) {
[10:33:15.969]                   sessionInformation <- function() {
[10:33:15.969]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:15.969]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:15.969]                       search = base::search(), system = base::Sys.info())
[10:33:15.969]                   }
[10:33:15.969]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.969]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:15.969]                     cond$call), session = sessionInformation(), 
[10:33:15.969]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:15.969]                   signalCondition(cond)
[10:33:15.969]                 }
[10:33:15.969]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:15.969]                 "immediateCondition"))) {
[10:33:15.969]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:15.969]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.969]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:15.969]                   if (TRUE && !signal) {
[10:33:15.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.969]                     {
[10:33:15.969]                       inherits <- base::inherits
[10:33:15.969]                       invokeRestart <- base::invokeRestart
[10:33:15.969]                       is.null <- base::is.null
[10:33:15.969]                       muffled <- FALSE
[10:33:15.969]                       if (inherits(cond, "message")) {
[10:33:15.969]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.969]                         if (muffled) 
[10:33:15.969]                           invokeRestart("muffleMessage")
[10:33:15.969]                       }
[10:33:15.969]                       else if (inherits(cond, "warning")) {
[10:33:15.969]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.969]                         if (muffled) 
[10:33:15.969]                           invokeRestart("muffleWarning")
[10:33:15.969]                       }
[10:33:15.969]                       else if (inherits(cond, "condition")) {
[10:33:15.969]                         if (!is.null(pattern)) {
[10:33:15.969]                           computeRestarts <- base::computeRestarts
[10:33:15.969]                           grepl <- base::grepl
[10:33:15.969]                           restarts <- computeRestarts(cond)
[10:33:15.969]                           for (restart in restarts) {
[10:33:15.969]                             name <- restart$name
[10:33:15.969]                             if (is.null(name)) 
[10:33:15.969]                               next
[10:33:15.969]                             if (!grepl(pattern, name)) 
[10:33:15.969]                               next
[10:33:15.969]                             invokeRestart(restart)
[10:33:15.969]                             muffled <- TRUE
[10:33:15.969]                             break
[10:33:15.969]                           }
[10:33:15.969]                         }
[10:33:15.969]                       }
[10:33:15.969]                       invisible(muffled)
[10:33:15.969]                     }
[10:33:15.969]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.969]                   }
[10:33:15.969]                 }
[10:33:15.969]                 else {
[10:33:15.969]                   if (TRUE) {
[10:33:15.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.969]                     {
[10:33:15.969]                       inherits <- base::inherits
[10:33:15.969]                       invokeRestart <- base::invokeRestart
[10:33:15.969]                       is.null <- base::is.null
[10:33:15.969]                       muffled <- FALSE
[10:33:15.969]                       if (inherits(cond, "message")) {
[10:33:15.969]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.969]                         if (muffled) 
[10:33:15.969]                           invokeRestart("muffleMessage")
[10:33:15.969]                       }
[10:33:15.969]                       else if (inherits(cond, "warning")) {
[10:33:15.969]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.969]                         if (muffled) 
[10:33:15.969]                           invokeRestart("muffleWarning")
[10:33:15.969]                       }
[10:33:15.969]                       else if (inherits(cond, "condition")) {
[10:33:15.969]                         if (!is.null(pattern)) {
[10:33:15.969]                           computeRestarts <- base::computeRestarts
[10:33:15.969]                           grepl <- base::grepl
[10:33:15.969]                           restarts <- computeRestarts(cond)
[10:33:15.969]                           for (restart in restarts) {
[10:33:15.969]                             name <- restart$name
[10:33:15.969]                             if (is.null(name)) 
[10:33:15.969]                               next
[10:33:15.969]                             if (!grepl(pattern, name)) 
[10:33:15.969]                               next
[10:33:15.969]                             invokeRestart(restart)
[10:33:15.969]                             muffled <- TRUE
[10:33:15.969]                             break
[10:33:15.969]                           }
[10:33:15.969]                         }
[10:33:15.969]                       }
[10:33:15.969]                       invisible(muffled)
[10:33:15.969]                     }
[10:33:15.969]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.969]                   }
[10:33:15.969]                 }
[10:33:15.969]             }
[10:33:15.969]         }))
[10:33:15.969]     }, error = function(ex) {
[10:33:15.969]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:15.969]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.969]                 ...future.rng), started = ...future.startTime, 
[10:33:15.969]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:15.969]             version = "1.8"), class = "FutureResult")
[10:33:15.969]     }, finally = {
[10:33:15.969]         if (!identical(...future.workdir, getwd())) 
[10:33:15.969]             setwd(...future.workdir)
[10:33:15.969]         {
[10:33:15.969]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:15.969]                 ...future.oldOptions$nwarnings <- NULL
[10:33:15.969]             }
[10:33:15.969]             base::options(...future.oldOptions)
[10:33:15.969]             if (.Platform$OS.type == "windows") {
[10:33:15.969]                 old_names <- names(...future.oldEnvVars)
[10:33:15.969]                 envs <- base::Sys.getenv()
[10:33:15.969]                 names <- names(envs)
[10:33:15.969]                 common <- intersect(names, old_names)
[10:33:15.969]                 added <- setdiff(names, old_names)
[10:33:15.969]                 removed <- setdiff(old_names, names)
[10:33:15.969]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:15.969]                   envs[common]]
[10:33:15.969]                 NAMES <- toupper(changed)
[10:33:15.969]                 args <- list()
[10:33:15.969]                 for (kk in seq_along(NAMES)) {
[10:33:15.969]                   name <- changed[[kk]]
[10:33:15.969]                   NAME <- NAMES[[kk]]
[10:33:15.969]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.969]                     next
[10:33:15.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.969]                 }
[10:33:15.969]                 NAMES <- toupper(added)
[10:33:15.969]                 for (kk in seq_along(NAMES)) {
[10:33:15.969]                   name <- added[[kk]]
[10:33:15.969]                   NAME <- NAMES[[kk]]
[10:33:15.969]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.969]                     next
[10:33:15.969]                   args[[name]] <- ""
[10:33:15.969]                 }
[10:33:15.969]                 NAMES <- toupper(removed)
[10:33:15.969]                 for (kk in seq_along(NAMES)) {
[10:33:15.969]                   name <- removed[[kk]]
[10:33:15.969]                   NAME <- NAMES[[kk]]
[10:33:15.969]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.969]                     next
[10:33:15.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.969]                 }
[10:33:15.969]                 if (length(args) > 0) 
[10:33:15.969]                   base::do.call(base::Sys.setenv, args = args)
[10:33:15.969]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:15.969]             }
[10:33:15.969]             else {
[10:33:15.969]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:15.969]             }
[10:33:15.969]             {
[10:33:15.969]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:15.969]                   0L) {
[10:33:15.969]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:15.969]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:15.969]                   base::options(opts)
[10:33:15.969]                 }
[10:33:15.969]                 {
[10:33:15.969]                   {
[10:33:15.969]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:15.969]                     NULL
[10:33:15.969]                   }
[10:33:15.969]                   options(future.plan = NULL)
[10:33:15.969]                   if (is.na(NA_character_)) 
[10:33:15.969]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.969]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:15.969]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:15.969]                     .init = FALSE)
[10:33:15.969]                 }
[10:33:15.969]             }
[10:33:15.969]         }
[10:33:15.969]     })
[10:33:15.969]     if (TRUE) {
[10:33:15.969]         base::sink(type = "output", split = FALSE)
[10:33:15.969]         if (TRUE) {
[10:33:15.969]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:15.969]         }
[10:33:15.969]         else {
[10:33:15.969]             ...future.result["stdout"] <- base::list(NULL)
[10:33:15.969]         }
[10:33:15.969]         base::close(...future.stdout)
[10:33:15.969]         ...future.stdout <- NULL
[10:33:15.969]     }
[10:33:15.969]     ...future.result$conditions <- ...future.conditions
[10:33:15.969]     ...future.result$finished <- base::Sys.time()
[10:33:15.969]     ...future.result
[10:33:15.969] }
[10:33:15.971] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[10:33:15.971] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[10:33:15.972] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[10:33:15.972] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[10:33:15.972] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[10:33:15.972] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[10:33:15.973] MultisessionFuture started
[10:33:15.973] - Launch lazy future ... done
[10:33:15.973] run() for ‘MultisessionFuture’ ... done
[10:33:15.973] result() for ClusterFuture ...
[10:33:15.973] receiveMessageFromWorker() for ClusterFuture ...
[10:33:15.974] - Validating connection of MultisessionFuture
[10:33:15.974] - received message: FutureResult
[10:33:15.975] - Received FutureResult
[10:33:15.975] - Erased future from FutureRegistry
[10:33:15.975] result() for ClusterFuture ...
[10:33:15.975] - result already collected: FutureResult
[10:33:15.975] result() for ClusterFuture ... done
[10:33:15.975] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:15.975] result() for ClusterFuture ... done
[10:33:15.975] result() for ClusterFuture ...
[10:33:15.975] - result already collected: FutureResult
[10:33:15.975] result() for ClusterFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:15.976] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:15.976] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:15.976] 
[10:33:15.977] Searching for globals ... DONE
[10:33:15.977] - globals: [0] <none>
[10:33:15.977] getGlobalsAndPackages() ... DONE
[10:33:15.977] run() for ‘Future’ ...
[10:33:15.977] - state: ‘created’
[10:33:15.977] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:15.992] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:15.992] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:15.992]   - Field: ‘node’
[10:33:15.992]   - Field: ‘label’
[10:33:15.992]   - Field: ‘local’
[10:33:15.992]   - Field: ‘owner’
[10:33:15.992]   - Field: ‘envir’
[10:33:15.992]   - Field: ‘workers’
[10:33:15.993]   - Field: ‘packages’
[10:33:15.993]   - Field: ‘gc’
[10:33:15.993]   - Field: ‘conditions’
[10:33:15.993]   - Field: ‘persistent’
[10:33:15.993]   - Field: ‘expr’
[10:33:15.993]   - Field: ‘uuid’
[10:33:15.993]   - Field: ‘seed’
[10:33:15.993]   - Field: ‘version’
[10:33:15.993]   - Field: ‘result’
[10:33:15.993]   - Field: ‘asynchronous’
[10:33:15.993]   - Field: ‘calls’
[10:33:15.994]   - Field: ‘globals’
[10:33:15.994]   - Field: ‘stdout’
[10:33:15.994]   - Field: ‘earlySignal’
[10:33:15.994]   - Field: ‘lazy’
[10:33:15.994]   - Field: ‘state’
[10:33:15.994] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:15.994] - Launch lazy future ...
[10:33:15.994] Packages needed by the future expression (n = 0): <none>
[10:33:15.994] Packages needed by future strategies (n = 0): <none>
[10:33:15.995] {
[10:33:15.995]     {
[10:33:15.995]         {
[10:33:15.995]             ...future.startTime <- base::Sys.time()
[10:33:15.995]             {
[10:33:15.995]                 {
[10:33:15.995]                   {
[10:33:15.995]                     {
[10:33:15.995]                       base::local({
[10:33:15.995]                         has_future <- base::requireNamespace("future", 
[10:33:15.995]                           quietly = TRUE)
[10:33:15.995]                         if (has_future) {
[10:33:15.995]                           ns <- base::getNamespace("future")
[10:33:15.995]                           version <- ns[[".package"]][["version"]]
[10:33:15.995]                           if (is.null(version)) 
[10:33:15.995]                             version <- utils::packageVersion("future")
[10:33:15.995]                         }
[10:33:15.995]                         else {
[10:33:15.995]                           version <- NULL
[10:33:15.995]                         }
[10:33:15.995]                         if (!has_future || version < "1.8.0") {
[10:33:15.995]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:15.995]                             "", base::R.version$version.string), 
[10:33:15.995]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:15.995]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:15.995]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:15.995]                               "release", "version")], collapse = " "), 
[10:33:15.995]                             hostname = base::Sys.info()[["nodename"]])
[10:33:15.995]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:15.995]                             info)
[10:33:15.995]                           info <- base::paste(info, collapse = "; ")
[10:33:15.995]                           if (!has_future) {
[10:33:15.995]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:15.995]                               info)
[10:33:15.995]                           }
[10:33:15.995]                           else {
[10:33:15.995]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:15.995]                               info, version)
[10:33:15.995]                           }
[10:33:15.995]                           base::stop(msg)
[10:33:15.995]                         }
[10:33:15.995]                       })
[10:33:15.995]                     }
[10:33:15.995]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:15.995]                     base::options(mc.cores = 1L)
[10:33:15.995]                   }
[10:33:15.995]                   ...future.strategy.old <- future::plan("list")
[10:33:15.995]                   options(future.plan = NULL)
[10:33:15.995]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.995]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:15.995]                 }
[10:33:15.995]                 ...future.workdir <- getwd()
[10:33:15.995]             }
[10:33:15.995]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:15.995]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:15.995]         }
[10:33:15.995]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:15.995]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:15.995]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:15.995]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:15.995]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:15.995]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:15.995]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:15.995]             base::names(...future.oldOptions))
[10:33:15.995]     }
[10:33:15.995]     if (FALSE) {
[10:33:15.995]     }
[10:33:15.995]     else {
[10:33:15.995]         if (TRUE) {
[10:33:15.995]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:15.995]                 open = "w")
[10:33:15.995]         }
[10:33:15.995]         else {
[10:33:15.995]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:15.995]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:15.995]         }
[10:33:15.995]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:15.995]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:15.995]             base::sink(type = "output", split = FALSE)
[10:33:15.995]             base::close(...future.stdout)
[10:33:15.995]         }, add = TRUE)
[10:33:15.995]     }
[10:33:15.995]     ...future.frame <- base::sys.nframe()
[10:33:15.995]     ...future.conditions <- base::list()
[10:33:15.995]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:15.995]     if (FALSE) {
[10:33:15.995]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:15.995]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:15.995]     }
[10:33:15.995]     ...future.result <- base::tryCatch({
[10:33:15.995]         base::withCallingHandlers({
[10:33:15.995]             ...future.value <- base::withVisible(base::local({
[10:33:15.995]                 ...future.makeSendCondition <- base::local({
[10:33:15.995]                   sendCondition <- NULL
[10:33:15.995]                   function(frame = 1L) {
[10:33:15.995]                     if (is.function(sendCondition)) 
[10:33:15.995]                       return(sendCondition)
[10:33:15.995]                     ns <- getNamespace("parallel")
[10:33:15.995]                     if (exists("sendData", mode = "function", 
[10:33:15.995]                       envir = ns)) {
[10:33:15.995]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:15.995]                         envir = ns)
[10:33:15.995]                       envir <- sys.frame(frame)
[10:33:15.995]                       master <- NULL
[10:33:15.995]                       while (!identical(envir, .GlobalEnv) && 
[10:33:15.995]                         !identical(envir, emptyenv())) {
[10:33:15.995]                         if (exists("master", mode = "list", envir = envir, 
[10:33:15.995]                           inherits = FALSE)) {
[10:33:15.995]                           master <- get("master", mode = "list", 
[10:33:15.995]                             envir = envir, inherits = FALSE)
[10:33:15.995]                           if (inherits(master, c("SOCKnode", 
[10:33:15.995]                             "SOCK0node"))) {
[10:33:15.995]                             sendCondition <<- function(cond) {
[10:33:15.995]                               data <- list(type = "VALUE", value = cond, 
[10:33:15.995]                                 success = TRUE)
[10:33:15.995]                               parallel_sendData(master, data)
[10:33:15.995]                             }
[10:33:15.995]                             return(sendCondition)
[10:33:15.995]                           }
[10:33:15.995]                         }
[10:33:15.995]                         frame <- frame + 1L
[10:33:15.995]                         envir <- sys.frame(frame)
[10:33:15.995]                       }
[10:33:15.995]                     }
[10:33:15.995]                     sendCondition <<- function(cond) NULL
[10:33:15.995]                   }
[10:33:15.995]                 })
[10:33:15.995]                 withCallingHandlers({
[10:33:15.995]                   1
[10:33:15.995]                 }, immediateCondition = function(cond) {
[10:33:15.995]                   sendCondition <- ...future.makeSendCondition()
[10:33:15.995]                   sendCondition(cond)
[10:33:15.995]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.995]                   {
[10:33:15.995]                     inherits <- base::inherits
[10:33:15.995]                     invokeRestart <- base::invokeRestart
[10:33:15.995]                     is.null <- base::is.null
[10:33:15.995]                     muffled <- FALSE
[10:33:15.995]                     if (inherits(cond, "message")) {
[10:33:15.995]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:15.995]                       if (muffled) 
[10:33:15.995]                         invokeRestart("muffleMessage")
[10:33:15.995]                     }
[10:33:15.995]                     else if (inherits(cond, "warning")) {
[10:33:15.995]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:15.995]                       if (muffled) 
[10:33:15.995]                         invokeRestart("muffleWarning")
[10:33:15.995]                     }
[10:33:15.995]                     else if (inherits(cond, "condition")) {
[10:33:15.995]                       if (!is.null(pattern)) {
[10:33:15.995]                         computeRestarts <- base::computeRestarts
[10:33:15.995]                         grepl <- base::grepl
[10:33:15.995]                         restarts <- computeRestarts(cond)
[10:33:15.995]                         for (restart in restarts) {
[10:33:15.995]                           name <- restart$name
[10:33:15.995]                           if (is.null(name)) 
[10:33:15.995]                             next
[10:33:15.995]                           if (!grepl(pattern, name)) 
[10:33:15.995]                             next
[10:33:15.995]                           invokeRestart(restart)
[10:33:15.995]                           muffled <- TRUE
[10:33:15.995]                           break
[10:33:15.995]                         }
[10:33:15.995]                       }
[10:33:15.995]                     }
[10:33:15.995]                     invisible(muffled)
[10:33:15.995]                   }
[10:33:15.995]                   muffleCondition(cond)
[10:33:15.995]                 })
[10:33:15.995]             }))
[10:33:15.995]             future::FutureResult(value = ...future.value$value, 
[10:33:15.995]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.995]                   ...future.rng), globalenv = if (FALSE) 
[10:33:15.995]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:15.995]                     ...future.globalenv.names))
[10:33:15.995]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:15.995]         }, condition = base::local({
[10:33:15.995]             c <- base::c
[10:33:15.995]             inherits <- base::inherits
[10:33:15.995]             invokeRestart <- base::invokeRestart
[10:33:15.995]             length <- base::length
[10:33:15.995]             list <- base::list
[10:33:15.995]             seq.int <- base::seq.int
[10:33:15.995]             signalCondition <- base::signalCondition
[10:33:15.995]             sys.calls <- base::sys.calls
[10:33:15.995]             `[[` <- base::`[[`
[10:33:15.995]             `+` <- base::`+`
[10:33:15.995]             `<<-` <- base::`<<-`
[10:33:15.995]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:15.995]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:15.995]                   3L)]
[10:33:15.995]             }
[10:33:15.995]             function(cond) {
[10:33:15.995]                 is_error <- inherits(cond, "error")
[10:33:15.995]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:15.995]                   NULL)
[10:33:15.995]                 if (is_error) {
[10:33:15.995]                   sessionInformation <- function() {
[10:33:15.995]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:15.995]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:15.995]                       search = base::search(), system = base::Sys.info())
[10:33:15.995]                   }
[10:33:15.995]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.995]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:15.995]                     cond$call), session = sessionInformation(), 
[10:33:15.995]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:15.995]                   signalCondition(cond)
[10:33:15.995]                 }
[10:33:15.995]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:15.995]                 "immediateCondition"))) {
[10:33:15.995]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:15.995]                   ...future.conditions[[length(...future.conditions) + 
[10:33:15.995]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:15.995]                   if (TRUE && !signal) {
[10:33:15.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.995]                     {
[10:33:15.995]                       inherits <- base::inherits
[10:33:15.995]                       invokeRestart <- base::invokeRestart
[10:33:15.995]                       is.null <- base::is.null
[10:33:15.995]                       muffled <- FALSE
[10:33:15.995]                       if (inherits(cond, "message")) {
[10:33:15.995]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.995]                         if (muffled) 
[10:33:15.995]                           invokeRestart("muffleMessage")
[10:33:15.995]                       }
[10:33:15.995]                       else if (inherits(cond, "warning")) {
[10:33:15.995]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.995]                         if (muffled) 
[10:33:15.995]                           invokeRestart("muffleWarning")
[10:33:15.995]                       }
[10:33:15.995]                       else if (inherits(cond, "condition")) {
[10:33:15.995]                         if (!is.null(pattern)) {
[10:33:15.995]                           computeRestarts <- base::computeRestarts
[10:33:15.995]                           grepl <- base::grepl
[10:33:15.995]                           restarts <- computeRestarts(cond)
[10:33:15.995]                           for (restart in restarts) {
[10:33:15.995]                             name <- restart$name
[10:33:15.995]                             if (is.null(name)) 
[10:33:15.995]                               next
[10:33:15.995]                             if (!grepl(pattern, name)) 
[10:33:15.995]                               next
[10:33:15.995]                             invokeRestart(restart)
[10:33:15.995]                             muffled <- TRUE
[10:33:15.995]                             break
[10:33:15.995]                           }
[10:33:15.995]                         }
[10:33:15.995]                       }
[10:33:15.995]                       invisible(muffled)
[10:33:15.995]                     }
[10:33:15.995]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.995]                   }
[10:33:15.995]                 }
[10:33:15.995]                 else {
[10:33:15.995]                   if (TRUE) {
[10:33:15.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:15.995]                     {
[10:33:15.995]                       inherits <- base::inherits
[10:33:15.995]                       invokeRestart <- base::invokeRestart
[10:33:15.995]                       is.null <- base::is.null
[10:33:15.995]                       muffled <- FALSE
[10:33:15.995]                       if (inherits(cond, "message")) {
[10:33:15.995]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:15.995]                         if (muffled) 
[10:33:15.995]                           invokeRestart("muffleMessage")
[10:33:15.995]                       }
[10:33:15.995]                       else if (inherits(cond, "warning")) {
[10:33:15.995]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:15.995]                         if (muffled) 
[10:33:15.995]                           invokeRestart("muffleWarning")
[10:33:15.995]                       }
[10:33:15.995]                       else if (inherits(cond, "condition")) {
[10:33:15.995]                         if (!is.null(pattern)) {
[10:33:15.995]                           computeRestarts <- base::computeRestarts
[10:33:15.995]                           grepl <- base::grepl
[10:33:15.995]                           restarts <- computeRestarts(cond)
[10:33:15.995]                           for (restart in restarts) {
[10:33:15.995]                             name <- restart$name
[10:33:15.995]                             if (is.null(name)) 
[10:33:15.995]                               next
[10:33:15.995]                             if (!grepl(pattern, name)) 
[10:33:15.995]                               next
[10:33:15.995]                             invokeRestart(restart)
[10:33:15.995]                             muffled <- TRUE
[10:33:15.995]                             break
[10:33:15.995]                           }
[10:33:15.995]                         }
[10:33:15.995]                       }
[10:33:15.995]                       invisible(muffled)
[10:33:15.995]                     }
[10:33:15.995]                     muffleCondition(cond, pattern = "^muffle")
[10:33:15.995]                   }
[10:33:15.995]                 }
[10:33:15.995]             }
[10:33:15.995]         }))
[10:33:15.995]     }, error = function(ex) {
[10:33:15.995]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:15.995]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:15.995]                 ...future.rng), started = ...future.startTime, 
[10:33:15.995]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:15.995]             version = "1.8"), class = "FutureResult")
[10:33:15.995]     }, finally = {
[10:33:15.995]         if (!identical(...future.workdir, getwd())) 
[10:33:15.995]             setwd(...future.workdir)
[10:33:15.995]         {
[10:33:15.995]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:15.995]                 ...future.oldOptions$nwarnings <- NULL
[10:33:15.995]             }
[10:33:15.995]             base::options(...future.oldOptions)
[10:33:15.995]             if (.Platform$OS.type == "windows") {
[10:33:15.995]                 old_names <- names(...future.oldEnvVars)
[10:33:15.995]                 envs <- base::Sys.getenv()
[10:33:15.995]                 names <- names(envs)
[10:33:15.995]                 common <- intersect(names, old_names)
[10:33:15.995]                 added <- setdiff(names, old_names)
[10:33:15.995]                 removed <- setdiff(old_names, names)
[10:33:15.995]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:15.995]                   envs[common]]
[10:33:15.995]                 NAMES <- toupper(changed)
[10:33:15.995]                 args <- list()
[10:33:15.995]                 for (kk in seq_along(NAMES)) {
[10:33:15.995]                   name <- changed[[kk]]
[10:33:15.995]                   NAME <- NAMES[[kk]]
[10:33:15.995]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.995]                     next
[10:33:15.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.995]                 }
[10:33:15.995]                 NAMES <- toupper(added)
[10:33:15.995]                 for (kk in seq_along(NAMES)) {
[10:33:15.995]                   name <- added[[kk]]
[10:33:15.995]                   NAME <- NAMES[[kk]]
[10:33:15.995]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.995]                     next
[10:33:15.995]                   args[[name]] <- ""
[10:33:15.995]                 }
[10:33:15.995]                 NAMES <- toupper(removed)
[10:33:15.995]                 for (kk in seq_along(NAMES)) {
[10:33:15.995]                   name <- removed[[kk]]
[10:33:15.995]                   NAME <- NAMES[[kk]]
[10:33:15.995]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:15.995]                     next
[10:33:15.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:15.995]                 }
[10:33:15.995]                 if (length(args) > 0) 
[10:33:15.995]                   base::do.call(base::Sys.setenv, args = args)
[10:33:15.995]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:15.995]             }
[10:33:15.995]             else {
[10:33:15.995]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:15.995]             }
[10:33:15.995]             {
[10:33:15.995]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:15.995]                   0L) {
[10:33:15.995]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:15.995]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:15.995]                   base::options(opts)
[10:33:15.995]                 }
[10:33:15.995]                 {
[10:33:15.995]                   {
[10:33:15.995]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:15.995]                     NULL
[10:33:15.995]                   }
[10:33:15.995]                   options(future.plan = NULL)
[10:33:15.995]                   if (is.na(NA_character_)) 
[10:33:15.995]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:15.995]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:15.995]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:15.995]                     .init = FALSE)
[10:33:15.995]                 }
[10:33:15.995]             }
[10:33:15.995]         }
[10:33:15.995]     })
[10:33:15.995]     if (TRUE) {
[10:33:15.995]         base::sink(type = "output", split = FALSE)
[10:33:15.995]         if (TRUE) {
[10:33:15.995]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:15.995]         }
[10:33:15.995]         else {
[10:33:15.995]             ...future.result["stdout"] <- base::list(NULL)
[10:33:15.995]         }
[10:33:15.995]         base::close(...future.stdout)
[10:33:15.995]         ...future.stdout <- NULL
[10:33:15.995]     }
[10:33:15.995]     ...future.result$conditions <- ...future.conditions
[10:33:15.995]     ...future.result$finished <- base::Sys.time()
[10:33:15.995]     ...future.result
[10:33:15.995] }
[10:33:15.998] MultisessionFuture started
[10:33:15.998] - Launch lazy future ... done
[10:33:15.998] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:15.998] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:15.999] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:16.000] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:16.000] Searching for globals ... DONE
[10:33:16.000] Resolving globals: TRUE
[10:33:16.000] Resolving any globals that are futures ...
[10:33:16.000] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:16.000] Resolving any globals that are futures ... DONE
[10:33:16.001] Resolving futures part of globals (recursively) ...
[10:33:16.001] resolve() on list ...
[10:33:16.001]  recursive: 99
[10:33:16.001]  length: 1
[10:33:16.001]  elements: ‘a’
[10:33:16.002] receiveMessageFromWorker() for ClusterFuture ...
[10:33:16.002] - Validating connection of MultisessionFuture
[10:33:16.002] - received message: FutureResult
[10:33:16.002] - Received FutureResult
[10:33:16.002] - Erased future from FutureRegistry
[10:33:16.002] result() for ClusterFuture ...
[10:33:16.002] - result already collected: FutureResult
[10:33:16.002] result() for ClusterFuture ... done
[10:33:16.002] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:16.003] Future #1
[10:33:16.003] result() for ClusterFuture ...
[10:33:16.003] - result already collected: FutureResult
[10:33:16.003] result() for ClusterFuture ... done
[10:33:16.003] result() for ClusterFuture ...
[10:33:16.003] - result already collected: FutureResult
[10:33:16.003] result() for ClusterFuture ... done
[10:33:16.003] A MultisessionFuture was resolved
[10:33:16.003]  length: 0 (resolved future 1)
[10:33:16.003] resolve() on list ... DONE
[10:33:16.003] - globals: [1] ‘a’
[10:33:16.004] Resolving futures part of globals (recursively) ... DONE
[10:33:16.006] The total size of the 1 globals is 1.57 MiB (1646728 bytes)
[10:33:16.006] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[10:33:16.006] - globals: [1] ‘a’
[10:33:16.006] - packages: [1] ‘future’
[10:33:16.006] getGlobalsAndPackages() ... DONE
[10:33:16.007] run() for ‘Future’ ...
[10:33:16.007] - state: ‘created’
[10:33:16.007] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:16.020] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:16.020] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:16.020]   - Field: ‘node’
[10:33:16.020]   - Field: ‘label’
[10:33:16.020]   - Field: ‘local’
[10:33:16.021]   - Field: ‘owner’
[10:33:16.021]   - Field: ‘envir’
[10:33:16.021]   - Field: ‘workers’
[10:33:16.021]   - Field: ‘packages’
[10:33:16.021]   - Field: ‘gc’
[10:33:16.021]   - Field: ‘conditions’
[10:33:16.021]   - Field: ‘persistent’
[10:33:16.021]   - Field: ‘expr’
[10:33:16.021]   - Field: ‘uuid’
[10:33:16.021]   - Field: ‘seed’
[10:33:16.021]   - Field: ‘version’
[10:33:16.022]   - Field: ‘result’
[10:33:16.022]   - Field: ‘asynchronous’
[10:33:16.022]   - Field: ‘calls’
[10:33:16.022]   - Field: ‘globals’
[10:33:16.022]   - Field: ‘stdout’
[10:33:16.022]   - Field: ‘earlySignal’
[10:33:16.022]   - Field: ‘lazy’
[10:33:16.022]   - Field: ‘state’
[10:33:16.022] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:16.022] - Launch lazy future ...
[10:33:16.023] Packages needed by the future expression (n = 1): ‘future’
[10:33:16.023] Packages needed by future strategies (n = 0): <none>
[10:33:16.023] {
[10:33:16.023]     {
[10:33:16.023]         {
[10:33:16.023]             ...future.startTime <- base::Sys.time()
[10:33:16.023]             {
[10:33:16.023]                 {
[10:33:16.023]                   {
[10:33:16.023]                     {
[10:33:16.023]                       {
[10:33:16.023]                         base::local({
[10:33:16.023]                           has_future <- base::requireNamespace("future", 
[10:33:16.023]                             quietly = TRUE)
[10:33:16.023]                           if (has_future) {
[10:33:16.023]                             ns <- base::getNamespace("future")
[10:33:16.023]                             version <- ns[[".package"]][["version"]]
[10:33:16.023]                             if (is.null(version)) 
[10:33:16.023]                               version <- utils::packageVersion("future")
[10:33:16.023]                           }
[10:33:16.023]                           else {
[10:33:16.023]                             version <- NULL
[10:33:16.023]                           }
[10:33:16.023]                           if (!has_future || version < "1.8.0") {
[10:33:16.023]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:16.023]                               "", base::R.version$version.string), 
[10:33:16.023]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:16.023]                                 base::R.version$platform, 8 * 
[10:33:16.023]                                   base::.Machine$sizeof.pointer), 
[10:33:16.023]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:16.023]                                 "release", "version")], collapse = " "), 
[10:33:16.023]                               hostname = base::Sys.info()[["nodename"]])
[10:33:16.023]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:16.023]                               info)
[10:33:16.023]                             info <- base::paste(info, collapse = "; ")
[10:33:16.023]                             if (!has_future) {
[10:33:16.023]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:16.023]                                 info)
[10:33:16.023]                             }
[10:33:16.023]                             else {
[10:33:16.023]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:16.023]                                 info, version)
[10:33:16.023]                             }
[10:33:16.023]                             base::stop(msg)
[10:33:16.023]                           }
[10:33:16.023]                         })
[10:33:16.023]                       }
[10:33:16.023]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:16.023]                       base::options(mc.cores = 1L)
[10:33:16.023]                     }
[10:33:16.023]                     base::local({
[10:33:16.023]                       for (pkg in "future") {
[10:33:16.023]                         base::loadNamespace(pkg)
[10:33:16.023]                         base::library(pkg, character.only = TRUE)
[10:33:16.023]                       }
[10:33:16.023]                     })
[10:33:16.023]                   }
[10:33:16.023]                   ...future.strategy.old <- future::plan("list")
[10:33:16.023]                   options(future.plan = NULL)
[10:33:16.023]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:16.023]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:16.023]                 }
[10:33:16.023]                 ...future.workdir <- getwd()
[10:33:16.023]             }
[10:33:16.023]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:16.023]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:16.023]         }
[10:33:16.023]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:16.023]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:16.023]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:16.023]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:16.023]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:16.023]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:16.023]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:16.023]             base::names(...future.oldOptions))
[10:33:16.023]     }
[10:33:16.023]     if (FALSE) {
[10:33:16.023]     }
[10:33:16.023]     else {
[10:33:16.023]         if (TRUE) {
[10:33:16.023]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:16.023]                 open = "w")
[10:33:16.023]         }
[10:33:16.023]         else {
[10:33:16.023]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:16.023]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:16.023]         }
[10:33:16.023]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:16.023]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:16.023]             base::sink(type = "output", split = FALSE)
[10:33:16.023]             base::close(...future.stdout)
[10:33:16.023]         }, add = TRUE)
[10:33:16.023]     }
[10:33:16.023]     ...future.frame <- base::sys.nframe()
[10:33:16.023]     ...future.conditions <- base::list()
[10:33:16.023]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:16.023]     if (FALSE) {
[10:33:16.023]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:16.023]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:16.023]     }
[10:33:16.023]     ...future.result <- base::tryCatch({
[10:33:16.023]         base::withCallingHandlers({
[10:33:16.023]             ...future.value <- base::withVisible(base::local({
[10:33:16.023]                 ...future.makeSendCondition <- base::local({
[10:33:16.023]                   sendCondition <- NULL
[10:33:16.023]                   function(frame = 1L) {
[10:33:16.023]                     if (is.function(sendCondition)) 
[10:33:16.023]                       return(sendCondition)
[10:33:16.023]                     ns <- getNamespace("parallel")
[10:33:16.023]                     if (exists("sendData", mode = "function", 
[10:33:16.023]                       envir = ns)) {
[10:33:16.023]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:16.023]                         envir = ns)
[10:33:16.023]                       envir <- sys.frame(frame)
[10:33:16.023]                       master <- NULL
[10:33:16.023]                       while (!identical(envir, .GlobalEnv) && 
[10:33:16.023]                         !identical(envir, emptyenv())) {
[10:33:16.023]                         if (exists("master", mode = "list", envir = envir, 
[10:33:16.023]                           inherits = FALSE)) {
[10:33:16.023]                           master <- get("master", mode = "list", 
[10:33:16.023]                             envir = envir, inherits = FALSE)
[10:33:16.023]                           if (inherits(master, c("SOCKnode", 
[10:33:16.023]                             "SOCK0node"))) {
[10:33:16.023]                             sendCondition <<- function(cond) {
[10:33:16.023]                               data <- list(type = "VALUE", value = cond, 
[10:33:16.023]                                 success = TRUE)
[10:33:16.023]                               parallel_sendData(master, data)
[10:33:16.023]                             }
[10:33:16.023]                             return(sendCondition)
[10:33:16.023]                           }
[10:33:16.023]                         }
[10:33:16.023]                         frame <- frame + 1L
[10:33:16.023]                         envir <- sys.frame(frame)
[10:33:16.023]                       }
[10:33:16.023]                     }
[10:33:16.023]                     sendCondition <<- function(cond) NULL
[10:33:16.023]                   }
[10:33:16.023]                 })
[10:33:16.023]                 withCallingHandlers({
[10:33:16.023]                   value(a) + 1
[10:33:16.023]                 }, immediateCondition = function(cond) {
[10:33:16.023]                   sendCondition <- ...future.makeSendCondition()
[10:33:16.023]                   sendCondition(cond)
[10:33:16.023]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.023]                   {
[10:33:16.023]                     inherits <- base::inherits
[10:33:16.023]                     invokeRestart <- base::invokeRestart
[10:33:16.023]                     is.null <- base::is.null
[10:33:16.023]                     muffled <- FALSE
[10:33:16.023]                     if (inherits(cond, "message")) {
[10:33:16.023]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:16.023]                       if (muffled) 
[10:33:16.023]                         invokeRestart("muffleMessage")
[10:33:16.023]                     }
[10:33:16.023]                     else if (inherits(cond, "warning")) {
[10:33:16.023]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:16.023]                       if (muffled) 
[10:33:16.023]                         invokeRestart("muffleWarning")
[10:33:16.023]                     }
[10:33:16.023]                     else if (inherits(cond, "condition")) {
[10:33:16.023]                       if (!is.null(pattern)) {
[10:33:16.023]                         computeRestarts <- base::computeRestarts
[10:33:16.023]                         grepl <- base::grepl
[10:33:16.023]                         restarts <- computeRestarts(cond)
[10:33:16.023]                         for (restart in restarts) {
[10:33:16.023]                           name <- restart$name
[10:33:16.023]                           if (is.null(name)) 
[10:33:16.023]                             next
[10:33:16.023]                           if (!grepl(pattern, name)) 
[10:33:16.023]                             next
[10:33:16.023]                           invokeRestart(restart)
[10:33:16.023]                           muffled <- TRUE
[10:33:16.023]                           break
[10:33:16.023]                         }
[10:33:16.023]                       }
[10:33:16.023]                     }
[10:33:16.023]                     invisible(muffled)
[10:33:16.023]                   }
[10:33:16.023]                   muffleCondition(cond)
[10:33:16.023]                 })
[10:33:16.023]             }))
[10:33:16.023]             future::FutureResult(value = ...future.value$value, 
[10:33:16.023]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:16.023]                   ...future.rng), globalenv = if (FALSE) 
[10:33:16.023]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:16.023]                     ...future.globalenv.names))
[10:33:16.023]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:16.023]         }, condition = base::local({
[10:33:16.023]             c <- base::c
[10:33:16.023]             inherits <- base::inherits
[10:33:16.023]             invokeRestart <- base::invokeRestart
[10:33:16.023]             length <- base::length
[10:33:16.023]             list <- base::list
[10:33:16.023]             seq.int <- base::seq.int
[10:33:16.023]             signalCondition <- base::signalCondition
[10:33:16.023]             sys.calls <- base::sys.calls
[10:33:16.023]             `[[` <- base::`[[`
[10:33:16.023]             `+` <- base::`+`
[10:33:16.023]             `<<-` <- base::`<<-`
[10:33:16.023]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:16.023]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:16.023]                   3L)]
[10:33:16.023]             }
[10:33:16.023]             function(cond) {
[10:33:16.023]                 is_error <- inherits(cond, "error")
[10:33:16.023]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:16.023]                   NULL)
[10:33:16.023]                 if (is_error) {
[10:33:16.023]                   sessionInformation <- function() {
[10:33:16.023]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:16.023]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:16.023]                       search = base::search(), system = base::Sys.info())
[10:33:16.023]                   }
[10:33:16.023]                   ...future.conditions[[length(...future.conditions) + 
[10:33:16.023]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:16.023]                     cond$call), session = sessionInformation(), 
[10:33:16.023]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:16.023]                   signalCondition(cond)
[10:33:16.023]                 }
[10:33:16.023]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:16.023]                 "immediateCondition"))) {
[10:33:16.023]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:16.023]                   ...future.conditions[[length(...future.conditions) + 
[10:33:16.023]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:16.023]                   if (TRUE && !signal) {
[10:33:16.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.023]                     {
[10:33:16.023]                       inherits <- base::inherits
[10:33:16.023]                       invokeRestart <- base::invokeRestart
[10:33:16.023]                       is.null <- base::is.null
[10:33:16.023]                       muffled <- FALSE
[10:33:16.023]                       if (inherits(cond, "message")) {
[10:33:16.023]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:16.023]                         if (muffled) 
[10:33:16.023]                           invokeRestart("muffleMessage")
[10:33:16.023]                       }
[10:33:16.023]                       else if (inherits(cond, "warning")) {
[10:33:16.023]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:16.023]                         if (muffled) 
[10:33:16.023]                           invokeRestart("muffleWarning")
[10:33:16.023]                       }
[10:33:16.023]                       else if (inherits(cond, "condition")) {
[10:33:16.023]                         if (!is.null(pattern)) {
[10:33:16.023]                           computeRestarts <- base::computeRestarts
[10:33:16.023]                           grepl <- base::grepl
[10:33:16.023]                           restarts <- computeRestarts(cond)
[10:33:16.023]                           for (restart in restarts) {
[10:33:16.023]                             name <- restart$name
[10:33:16.023]                             if (is.null(name)) 
[10:33:16.023]                               next
[10:33:16.023]                             if (!grepl(pattern, name)) 
[10:33:16.023]                               next
[10:33:16.023]                             invokeRestart(restart)
[10:33:16.023]                             muffled <- TRUE
[10:33:16.023]                             break
[10:33:16.023]                           }
[10:33:16.023]                         }
[10:33:16.023]                       }
[10:33:16.023]                       invisible(muffled)
[10:33:16.023]                     }
[10:33:16.023]                     muffleCondition(cond, pattern = "^muffle")
[10:33:16.023]                   }
[10:33:16.023]                 }
[10:33:16.023]                 else {
[10:33:16.023]                   if (TRUE) {
[10:33:16.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.023]                     {
[10:33:16.023]                       inherits <- base::inherits
[10:33:16.023]                       invokeRestart <- base::invokeRestart
[10:33:16.023]                       is.null <- base::is.null
[10:33:16.023]                       muffled <- FALSE
[10:33:16.023]                       if (inherits(cond, "message")) {
[10:33:16.023]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:16.023]                         if (muffled) 
[10:33:16.023]                           invokeRestart("muffleMessage")
[10:33:16.023]                       }
[10:33:16.023]                       else if (inherits(cond, "warning")) {
[10:33:16.023]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:16.023]                         if (muffled) 
[10:33:16.023]                           invokeRestart("muffleWarning")
[10:33:16.023]                       }
[10:33:16.023]                       else if (inherits(cond, "condition")) {
[10:33:16.023]                         if (!is.null(pattern)) {
[10:33:16.023]                           computeRestarts <- base::computeRestarts
[10:33:16.023]                           grepl <- base::grepl
[10:33:16.023]                           restarts <- computeRestarts(cond)
[10:33:16.023]                           for (restart in restarts) {
[10:33:16.023]                             name <- restart$name
[10:33:16.023]                             if (is.null(name)) 
[10:33:16.023]                               next
[10:33:16.023]                             if (!grepl(pattern, name)) 
[10:33:16.023]                               next
[10:33:16.023]                             invokeRestart(restart)
[10:33:16.023]                             muffled <- TRUE
[10:33:16.023]                             break
[10:33:16.023]                           }
[10:33:16.023]                         }
[10:33:16.023]                       }
[10:33:16.023]                       invisible(muffled)
[10:33:16.023]                     }
[10:33:16.023]                     muffleCondition(cond, pattern = "^muffle")
[10:33:16.023]                   }
[10:33:16.023]                 }
[10:33:16.023]             }
[10:33:16.023]         }))
[10:33:16.023]     }, error = function(ex) {
[10:33:16.023]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:16.023]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:16.023]                 ...future.rng), started = ...future.startTime, 
[10:33:16.023]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:16.023]             version = "1.8"), class = "FutureResult")
[10:33:16.023]     }, finally = {
[10:33:16.023]         if (!identical(...future.workdir, getwd())) 
[10:33:16.023]             setwd(...future.workdir)
[10:33:16.023]         {
[10:33:16.023]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:16.023]                 ...future.oldOptions$nwarnings <- NULL
[10:33:16.023]             }
[10:33:16.023]             base::options(...future.oldOptions)
[10:33:16.023]             if (.Platform$OS.type == "windows") {
[10:33:16.023]                 old_names <- names(...future.oldEnvVars)
[10:33:16.023]                 envs <- base::Sys.getenv()
[10:33:16.023]                 names <- names(envs)
[10:33:16.023]                 common <- intersect(names, old_names)
[10:33:16.023]                 added <- setdiff(names, old_names)
[10:33:16.023]                 removed <- setdiff(old_names, names)
[10:33:16.023]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:16.023]                   envs[common]]
[10:33:16.023]                 NAMES <- toupper(changed)
[10:33:16.023]                 args <- list()
[10:33:16.023]                 for (kk in seq_along(NAMES)) {
[10:33:16.023]                   name <- changed[[kk]]
[10:33:16.023]                   NAME <- NAMES[[kk]]
[10:33:16.023]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.023]                     next
[10:33:16.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:16.023]                 }
[10:33:16.023]                 NAMES <- toupper(added)
[10:33:16.023]                 for (kk in seq_along(NAMES)) {
[10:33:16.023]                   name <- added[[kk]]
[10:33:16.023]                   NAME <- NAMES[[kk]]
[10:33:16.023]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.023]                     next
[10:33:16.023]                   args[[name]] <- ""
[10:33:16.023]                 }
[10:33:16.023]                 NAMES <- toupper(removed)
[10:33:16.023]                 for (kk in seq_along(NAMES)) {
[10:33:16.023]                   name <- removed[[kk]]
[10:33:16.023]                   NAME <- NAMES[[kk]]
[10:33:16.023]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.023]                     next
[10:33:16.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:16.023]                 }
[10:33:16.023]                 if (length(args) > 0) 
[10:33:16.023]                   base::do.call(base::Sys.setenv, args = args)
[10:33:16.023]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:16.023]             }
[10:33:16.023]             else {
[10:33:16.023]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:16.023]             }
[10:33:16.023]             {
[10:33:16.023]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:16.023]                   0L) {
[10:33:16.023]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:16.023]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:16.023]                   base::options(opts)
[10:33:16.023]                 }
[10:33:16.023]                 {
[10:33:16.023]                   {
[10:33:16.023]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:16.023]                     NULL
[10:33:16.023]                   }
[10:33:16.023]                   options(future.plan = NULL)
[10:33:16.023]                   if (is.na(NA_character_)) 
[10:33:16.023]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:16.023]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:16.023]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:16.023]                     .init = FALSE)
[10:33:16.023]                 }
[10:33:16.023]             }
[10:33:16.023]         }
[10:33:16.023]     })
[10:33:16.023]     if (TRUE) {
[10:33:16.023]         base::sink(type = "output", split = FALSE)
[10:33:16.023]         if (TRUE) {
[10:33:16.023]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:16.023]         }
[10:33:16.023]         else {
[10:33:16.023]             ...future.result["stdout"] <- base::list(NULL)
[10:33:16.023]         }
[10:33:16.023]         base::close(...future.stdout)
[10:33:16.023]         ...future.stdout <- NULL
[10:33:16.023]     }
[10:33:16.023]     ...future.result$conditions <- ...future.conditions
[10:33:16.023]     ...future.result$finished <- base::Sys.time()
[10:33:16.023]     ...future.result
[10:33:16.023] }
[10:33:16.026] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[10:33:16.027] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[10:33:16.077] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[10:33:16.078] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[10:33:16.078] MultisessionFuture started
[10:33:16.078] - Launch lazy future ... done
[10:33:16.078] run() for ‘MultisessionFuture’ ... done
[10:33:16.079] result() for ClusterFuture ...
[10:33:16.079] receiveMessageFromWorker() for ClusterFuture ...
[10:33:16.079] - Validating connection of MultisessionFuture
[10:33:16.126] - received message: FutureResult
[10:33:16.127] - Received FutureResult
[10:33:16.127] - Erased future from FutureRegistry
[10:33:16.127] result() for ClusterFuture ...
[10:33:16.127] - result already collected: FutureResult
[10:33:16.127] result() for ClusterFuture ... done
[10:33:16.127] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:16.127] result() for ClusterFuture ... done
[10:33:16.127] result() for ClusterFuture ...
[10:33:16.127] - result already collected: FutureResult
[10:33:16.127] result() for ClusterFuture ... done
value(b) = 2
[10:33:16.128] result() for ClusterFuture ...
[10:33:16.128] - result already collected: FutureResult
[10:33:16.128] result() for ClusterFuture ... done
[10:33:16.128] result() for ClusterFuture ...
[10:33:16.128] - result already collected: FutureResult
[10:33:16.128] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:16.128] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:16.129] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:16.129] 
[10:33:16.129] Searching for globals ... DONE
[10:33:16.129] - globals: [0] <none>
[10:33:16.129] getGlobalsAndPackages() ... DONE
[10:33:16.130] run() for ‘Future’ ...
[10:33:16.130] - state: ‘created’
[10:33:16.130] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:16.144] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:16.144] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:16.144]   - Field: ‘node’
[10:33:16.144]   - Field: ‘label’
[10:33:16.144]   - Field: ‘local’
[10:33:16.144]   - Field: ‘owner’
[10:33:16.144]   - Field: ‘envir’
[10:33:16.145]   - Field: ‘workers’
[10:33:16.145]   - Field: ‘packages’
[10:33:16.145]   - Field: ‘gc’
[10:33:16.145]   - Field: ‘conditions’
[10:33:16.145]   - Field: ‘persistent’
[10:33:16.145]   - Field: ‘expr’
[10:33:16.145]   - Field: ‘uuid’
[10:33:16.145]   - Field: ‘seed’
[10:33:16.145]   - Field: ‘version’
[10:33:16.145]   - Field: ‘result’
[10:33:16.145]   - Field: ‘asynchronous’
[10:33:16.146]   - Field: ‘calls’
[10:33:16.146]   - Field: ‘globals’
[10:33:16.146]   - Field: ‘stdout’
[10:33:16.146]   - Field: ‘earlySignal’
[10:33:16.146]   - Field: ‘lazy’
[10:33:16.146]   - Field: ‘state’
[10:33:16.146] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:16.146] - Launch lazy future ...
[10:33:16.147] Packages needed by the future expression (n = 0): <none>
[10:33:16.147] Packages needed by future strategies (n = 0): <none>
[10:33:16.147] {
[10:33:16.147]     {
[10:33:16.147]         {
[10:33:16.147]             ...future.startTime <- base::Sys.time()
[10:33:16.147]             {
[10:33:16.147]                 {
[10:33:16.147]                   {
[10:33:16.147]                     {
[10:33:16.147]                       base::local({
[10:33:16.147]                         has_future <- base::requireNamespace("future", 
[10:33:16.147]                           quietly = TRUE)
[10:33:16.147]                         if (has_future) {
[10:33:16.147]                           ns <- base::getNamespace("future")
[10:33:16.147]                           version <- ns[[".package"]][["version"]]
[10:33:16.147]                           if (is.null(version)) 
[10:33:16.147]                             version <- utils::packageVersion("future")
[10:33:16.147]                         }
[10:33:16.147]                         else {
[10:33:16.147]                           version <- NULL
[10:33:16.147]                         }
[10:33:16.147]                         if (!has_future || version < "1.8.0") {
[10:33:16.147]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:16.147]                             "", base::R.version$version.string), 
[10:33:16.147]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:16.147]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:16.147]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:16.147]                               "release", "version")], collapse = " "), 
[10:33:16.147]                             hostname = base::Sys.info()[["nodename"]])
[10:33:16.147]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:16.147]                             info)
[10:33:16.147]                           info <- base::paste(info, collapse = "; ")
[10:33:16.147]                           if (!has_future) {
[10:33:16.147]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:16.147]                               info)
[10:33:16.147]                           }
[10:33:16.147]                           else {
[10:33:16.147]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:16.147]                               info, version)
[10:33:16.147]                           }
[10:33:16.147]                           base::stop(msg)
[10:33:16.147]                         }
[10:33:16.147]                       })
[10:33:16.147]                     }
[10:33:16.147]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:16.147]                     base::options(mc.cores = 1L)
[10:33:16.147]                   }
[10:33:16.147]                   ...future.strategy.old <- future::plan("list")
[10:33:16.147]                   options(future.plan = NULL)
[10:33:16.147]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:16.147]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:16.147]                 }
[10:33:16.147]                 ...future.workdir <- getwd()
[10:33:16.147]             }
[10:33:16.147]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:16.147]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:16.147]         }
[10:33:16.147]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:16.147]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:16.147]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:16.147]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:16.147]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:16.147]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:16.147]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:16.147]             base::names(...future.oldOptions))
[10:33:16.147]     }
[10:33:16.147]     if (FALSE) {
[10:33:16.147]     }
[10:33:16.147]     else {
[10:33:16.147]         if (TRUE) {
[10:33:16.147]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:16.147]                 open = "w")
[10:33:16.147]         }
[10:33:16.147]         else {
[10:33:16.147]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:16.147]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:16.147]         }
[10:33:16.147]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:16.147]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:16.147]             base::sink(type = "output", split = FALSE)
[10:33:16.147]             base::close(...future.stdout)
[10:33:16.147]         }, add = TRUE)
[10:33:16.147]     }
[10:33:16.147]     ...future.frame <- base::sys.nframe()
[10:33:16.147]     ...future.conditions <- base::list()
[10:33:16.147]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:16.147]     if (FALSE) {
[10:33:16.147]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:16.147]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:16.147]     }
[10:33:16.147]     ...future.result <- base::tryCatch({
[10:33:16.147]         base::withCallingHandlers({
[10:33:16.147]             ...future.value <- base::withVisible(base::local({
[10:33:16.147]                 ...future.makeSendCondition <- base::local({
[10:33:16.147]                   sendCondition <- NULL
[10:33:16.147]                   function(frame = 1L) {
[10:33:16.147]                     if (is.function(sendCondition)) 
[10:33:16.147]                       return(sendCondition)
[10:33:16.147]                     ns <- getNamespace("parallel")
[10:33:16.147]                     if (exists("sendData", mode = "function", 
[10:33:16.147]                       envir = ns)) {
[10:33:16.147]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:16.147]                         envir = ns)
[10:33:16.147]                       envir <- sys.frame(frame)
[10:33:16.147]                       master <- NULL
[10:33:16.147]                       while (!identical(envir, .GlobalEnv) && 
[10:33:16.147]                         !identical(envir, emptyenv())) {
[10:33:16.147]                         if (exists("master", mode = "list", envir = envir, 
[10:33:16.147]                           inherits = FALSE)) {
[10:33:16.147]                           master <- get("master", mode = "list", 
[10:33:16.147]                             envir = envir, inherits = FALSE)
[10:33:16.147]                           if (inherits(master, c("SOCKnode", 
[10:33:16.147]                             "SOCK0node"))) {
[10:33:16.147]                             sendCondition <<- function(cond) {
[10:33:16.147]                               data <- list(type = "VALUE", value = cond, 
[10:33:16.147]                                 success = TRUE)
[10:33:16.147]                               parallel_sendData(master, data)
[10:33:16.147]                             }
[10:33:16.147]                             return(sendCondition)
[10:33:16.147]                           }
[10:33:16.147]                         }
[10:33:16.147]                         frame <- frame + 1L
[10:33:16.147]                         envir <- sys.frame(frame)
[10:33:16.147]                       }
[10:33:16.147]                     }
[10:33:16.147]                     sendCondition <<- function(cond) NULL
[10:33:16.147]                   }
[10:33:16.147]                 })
[10:33:16.147]                 withCallingHandlers({
[10:33:16.147]                   1
[10:33:16.147]                 }, immediateCondition = function(cond) {
[10:33:16.147]                   sendCondition <- ...future.makeSendCondition()
[10:33:16.147]                   sendCondition(cond)
[10:33:16.147]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.147]                   {
[10:33:16.147]                     inherits <- base::inherits
[10:33:16.147]                     invokeRestart <- base::invokeRestart
[10:33:16.147]                     is.null <- base::is.null
[10:33:16.147]                     muffled <- FALSE
[10:33:16.147]                     if (inherits(cond, "message")) {
[10:33:16.147]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:16.147]                       if (muffled) 
[10:33:16.147]                         invokeRestart("muffleMessage")
[10:33:16.147]                     }
[10:33:16.147]                     else if (inherits(cond, "warning")) {
[10:33:16.147]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:16.147]                       if (muffled) 
[10:33:16.147]                         invokeRestart("muffleWarning")
[10:33:16.147]                     }
[10:33:16.147]                     else if (inherits(cond, "condition")) {
[10:33:16.147]                       if (!is.null(pattern)) {
[10:33:16.147]                         computeRestarts <- base::computeRestarts
[10:33:16.147]                         grepl <- base::grepl
[10:33:16.147]                         restarts <- computeRestarts(cond)
[10:33:16.147]                         for (restart in restarts) {
[10:33:16.147]                           name <- restart$name
[10:33:16.147]                           if (is.null(name)) 
[10:33:16.147]                             next
[10:33:16.147]                           if (!grepl(pattern, name)) 
[10:33:16.147]                             next
[10:33:16.147]                           invokeRestart(restart)
[10:33:16.147]                           muffled <- TRUE
[10:33:16.147]                           break
[10:33:16.147]                         }
[10:33:16.147]                       }
[10:33:16.147]                     }
[10:33:16.147]                     invisible(muffled)
[10:33:16.147]                   }
[10:33:16.147]                   muffleCondition(cond)
[10:33:16.147]                 })
[10:33:16.147]             }))
[10:33:16.147]             future::FutureResult(value = ...future.value$value, 
[10:33:16.147]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:16.147]                   ...future.rng), globalenv = if (FALSE) 
[10:33:16.147]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:16.147]                     ...future.globalenv.names))
[10:33:16.147]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:16.147]         }, condition = base::local({
[10:33:16.147]             c <- base::c
[10:33:16.147]             inherits <- base::inherits
[10:33:16.147]             invokeRestart <- base::invokeRestart
[10:33:16.147]             length <- base::length
[10:33:16.147]             list <- base::list
[10:33:16.147]             seq.int <- base::seq.int
[10:33:16.147]             signalCondition <- base::signalCondition
[10:33:16.147]             sys.calls <- base::sys.calls
[10:33:16.147]             `[[` <- base::`[[`
[10:33:16.147]             `+` <- base::`+`
[10:33:16.147]             `<<-` <- base::`<<-`
[10:33:16.147]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:16.147]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:16.147]                   3L)]
[10:33:16.147]             }
[10:33:16.147]             function(cond) {
[10:33:16.147]                 is_error <- inherits(cond, "error")
[10:33:16.147]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:16.147]                   NULL)
[10:33:16.147]                 if (is_error) {
[10:33:16.147]                   sessionInformation <- function() {
[10:33:16.147]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:16.147]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:16.147]                       search = base::search(), system = base::Sys.info())
[10:33:16.147]                   }
[10:33:16.147]                   ...future.conditions[[length(...future.conditions) + 
[10:33:16.147]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:16.147]                     cond$call), session = sessionInformation(), 
[10:33:16.147]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:16.147]                   signalCondition(cond)
[10:33:16.147]                 }
[10:33:16.147]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:16.147]                 "immediateCondition"))) {
[10:33:16.147]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:16.147]                   ...future.conditions[[length(...future.conditions) + 
[10:33:16.147]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:16.147]                   if (TRUE && !signal) {
[10:33:16.147]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.147]                     {
[10:33:16.147]                       inherits <- base::inherits
[10:33:16.147]                       invokeRestart <- base::invokeRestart
[10:33:16.147]                       is.null <- base::is.null
[10:33:16.147]                       muffled <- FALSE
[10:33:16.147]                       if (inherits(cond, "message")) {
[10:33:16.147]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:16.147]                         if (muffled) 
[10:33:16.147]                           invokeRestart("muffleMessage")
[10:33:16.147]                       }
[10:33:16.147]                       else if (inherits(cond, "warning")) {
[10:33:16.147]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:16.147]                         if (muffled) 
[10:33:16.147]                           invokeRestart("muffleWarning")
[10:33:16.147]                       }
[10:33:16.147]                       else if (inherits(cond, "condition")) {
[10:33:16.147]                         if (!is.null(pattern)) {
[10:33:16.147]                           computeRestarts <- base::computeRestarts
[10:33:16.147]                           grepl <- base::grepl
[10:33:16.147]                           restarts <- computeRestarts(cond)
[10:33:16.147]                           for (restart in restarts) {
[10:33:16.147]                             name <- restart$name
[10:33:16.147]                             if (is.null(name)) 
[10:33:16.147]                               next
[10:33:16.147]                             if (!grepl(pattern, name)) 
[10:33:16.147]                               next
[10:33:16.147]                             invokeRestart(restart)
[10:33:16.147]                             muffled <- TRUE
[10:33:16.147]                             break
[10:33:16.147]                           }
[10:33:16.147]                         }
[10:33:16.147]                       }
[10:33:16.147]                       invisible(muffled)
[10:33:16.147]                     }
[10:33:16.147]                     muffleCondition(cond, pattern = "^muffle")
[10:33:16.147]                   }
[10:33:16.147]                 }
[10:33:16.147]                 else {
[10:33:16.147]                   if (TRUE) {
[10:33:16.147]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.147]                     {
[10:33:16.147]                       inherits <- base::inherits
[10:33:16.147]                       invokeRestart <- base::invokeRestart
[10:33:16.147]                       is.null <- base::is.null
[10:33:16.147]                       muffled <- FALSE
[10:33:16.147]                       if (inherits(cond, "message")) {
[10:33:16.147]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:16.147]                         if (muffled) 
[10:33:16.147]                           invokeRestart("muffleMessage")
[10:33:16.147]                       }
[10:33:16.147]                       else if (inherits(cond, "warning")) {
[10:33:16.147]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:16.147]                         if (muffled) 
[10:33:16.147]                           invokeRestart("muffleWarning")
[10:33:16.147]                       }
[10:33:16.147]                       else if (inherits(cond, "condition")) {
[10:33:16.147]                         if (!is.null(pattern)) {
[10:33:16.147]                           computeRestarts <- base::computeRestarts
[10:33:16.147]                           grepl <- base::grepl
[10:33:16.147]                           restarts <- computeRestarts(cond)
[10:33:16.147]                           for (restart in restarts) {
[10:33:16.147]                             name <- restart$name
[10:33:16.147]                             if (is.null(name)) 
[10:33:16.147]                               next
[10:33:16.147]                             if (!grepl(pattern, name)) 
[10:33:16.147]                               next
[10:33:16.147]                             invokeRestart(restart)
[10:33:16.147]                             muffled <- TRUE
[10:33:16.147]                             break
[10:33:16.147]                           }
[10:33:16.147]                         }
[10:33:16.147]                       }
[10:33:16.147]                       invisible(muffled)
[10:33:16.147]                     }
[10:33:16.147]                     muffleCondition(cond, pattern = "^muffle")
[10:33:16.147]                   }
[10:33:16.147]                 }
[10:33:16.147]             }
[10:33:16.147]         }))
[10:33:16.147]     }, error = function(ex) {
[10:33:16.147]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:16.147]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:16.147]                 ...future.rng), started = ...future.startTime, 
[10:33:16.147]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:16.147]             version = "1.8"), class = "FutureResult")
[10:33:16.147]     }, finally = {
[10:33:16.147]         if (!identical(...future.workdir, getwd())) 
[10:33:16.147]             setwd(...future.workdir)
[10:33:16.147]         {
[10:33:16.147]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:16.147]                 ...future.oldOptions$nwarnings <- NULL
[10:33:16.147]             }
[10:33:16.147]             base::options(...future.oldOptions)
[10:33:16.147]             if (.Platform$OS.type == "windows") {
[10:33:16.147]                 old_names <- names(...future.oldEnvVars)
[10:33:16.147]                 envs <- base::Sys.getenv()
[10:33:16.147]                 names <- names(envs)
[10:33:16.147]                 common <- intersect(names, old_names)
[10:33:16.147]                 added <- setdiff(names, old_names)
[10:33:16.147]                 removed <- setdiff(old_names, names)
[10:33:16.147]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:16.147]                   envs[common]]
[10:33:16.147]                 NAMES <- toupper(changed)
[10:33:16.147]                 args <- list()
[10:33:16.147]                 for (kk in seq_along(NAMES)) {
[10:33:16.147]                   name <- changed[[kk]]
[10:33:16.147]                   NAME <- NAMES[[kk]]
[10:33:16.147]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.147]                     next
[10:33:16.147]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:16.147]                 }
[10:33:16.147]                 NAMES <- toupper(added)
[10:33:16.147]                 for (kk in seq_along(NAMES)) {
[10:33:16.147]                   name <- added[[kk]]
[10:33:16.147]                   NAME <- NAMES[[kk]]
[10:33:16.147]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.147]                     next
[10:33:16.147]                   args[[name]] <- ""
[10:33:16.147]                 }
[10:33:16.147]                 NAMES <- toupper(removed)
[10:33:16.147]                 for (kk in seq_along(NAMES)) {
[10:33:16.147]                   name <- removed[[kk]]
[10:33:16.147]                   NAME <- NAMES[[kk]]
[10:33:16.147]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.147]                     next
[10:33:16.147]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:16.147]                 }
[10:33:16.147]                 if (length(args) > 0) 
[10:33:16.147]                   base::do.call(base::Sys.setenv, args = args)
[10:33:16.147]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:16.147]             }
[10:33:16.147]             else {
[10:33:16.147]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:16.147]             }
[10:33:16.147]             {
[10:33:16.147]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:16.147]                   0L) {
[10:33:16.147]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:16.147]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:16.147]                   base::options(opts)
[10:33:16.147]                 }
[10:33:16.147]                 {
[10:33:16.147]                   {
[10:33:16.147]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:16.147]                     NULL
[10:33:16.147]                   }
[10:33:16.147]                   options(future.plan = NULL)
[10:33:16.147]                   if (is.na(NA_character_)) 
[10:33:16.147]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:16.147]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:16.147]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:16.147]                     .init = FALSE)
[10:33:16.147]                 }
[10:33:16.147]             }
[10:33:16.147]         }
[10:33:16.147]     })
[10:33:16.147]     if (TRUE) {
[10:33:16.147]         base::sink(type = "output", split = FALSE)
[10:33:16.147]         if (TRUE) {
[10:33:16.147]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:16.147]         }
[10:33:16.147]         else {
[10:33:16.147]             ...future.result["stdout"] <- base::list(NULL)
[10:33:16.147]         }
[10:33:16.147]         base::close(...future.stdout)
[10:33:16.147]         ...future.stdout <- NULL
[10:33:16.147]     }
[10:33:16.147]     ...future.result$conditions <- ...future.conditions
[10:33:16.147]     ...future.result$finished <- base::Sys.time()
[10:33:16.147]     ...future.result
[10:33:16.147] }
[10:33:16.150] MultisessionFuture started
[10:33:16.150] - Launch lazy future ... done
[10:33:16.150] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:16.151] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:16.151] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:16.152] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:16.152] Searching for globals ... DONE
[10:33:16.152] Resolving globals: TRUE
[10:33:16.152] Resolving any globals that are futures ...
[10:33:16.152] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:16.152] Resolving any globals that are futures ... DONE
[10:33:16.152] Resolving futures part of globals (recursively) ...
[10:33:16.153] resolve() on list ...
[10:33:16.153]  recursive: 99
[10:33:16.153]  length: 1
[10:33:16.153]  elements: ‘a’
[10:33:16.195] receiveMessageFromWorker() for ClusterFuture ...
[10:33:16.195] - Validating connection of MultisessionFuture
[10:33:16.195] - received message: FutureResult
[10:33:16.195] - Received FutureResult
[10:33:16.195] - Erased future from FutureRegistry
[10:33:16.195] result() for ClusterFuture ...
[10:33:16.196] - result already collected: FutureResult
[10:33:16.196] result() for ClusterFuture ... done
[10:33:16.196] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:16.196] Future #1
[10:33:16.196] result() for ClusterFuture ...
[10:33:16.196] - result already collected: FutureResult
[10:33:16.196] result() for ClusterFuture ... done
[10:33:16.196] result() for ClusterFuture ...
[10:33:16.196] - result already collected: FutureResult
[10:33:16.196] result() for ClusterFuture ... done
[10:33:16.197] A MultisessionFuture was resolved
[10:33:16.197]  length: 0 (resolved future 1)
[10:33:16.197] resolve() on list ... DONE
[10:33:16.197] - globals: [1] ‘a’
[10:33:16.197] Resolving futures part of globals (recursively) ... DONE
[10:33:16.201] The total size of the 1 globals is 1.57 MiB (1646728 bytes)
[10:33:16.202] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[10:33:16.202] - globals: [1] ‘a’
[10:33:16.202] - packages: [1] ‘future’
[10:33:16.202] getGlobalsAndPackages() ... DONE
[10:33:16.202] run() for ‘Future’ ...
[10:33:16.202] - state: ‘created’
[10:33:16.203] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:16.216] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:16.216] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:16.217]   - Field: ‘node’
[10:33:16.217]   - Field: ‘label’
[10:33:16.217]   - Field: ‘local’
[10:33:16.217]   - Field: ‘owner’
[10:33:16.217]   - Field: ‘envir’
[10:33:16.217]   - Field: ‘workers’
[10:33:16.217]   - Field: ‘packages’
[10:33:16.217]   - Field: ‘gc’
[10:33:16.217]   - Field: ‘conditions’
[10:33:16.217]   - Field: ‘persistent’
[10:33:16.218]   - Field: ‘expr’
[10:33:16.218]   - Field: ‘uuid’
[10:33:16.218]   - Field: ‘seed’
[10:33:16.218]   - Field: ‘version’
[10:33:16.218]   - Field: ‘result’
[10:33:16.218]   - Field: ‘asynchronous’
[10:33:16.218]   - Field: ‘calls’
[10:33:16.218]   - Field: ‘globals’
[10:33:16.218]   - Field: ‘stdout’
[10:33:16.218]   - Field: ‘earlySignal’
[10:33:16.218]   - Field: ‘lazy’
[10:33:16.219]   - Field: ‘state’
[10:33:16.219] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:16.219] - Launch lazy future ...
[10:33:16.219] Packages needed by the future expression (n = 1): ‘future’
[10:33:16.219] Packages needed by future strategies (n = 0): <none>
[10:33:16.220] {
[10:33:16.220]     {
[10:33:16.220]         {
[10:33:16.220]             ...future.startTime <- base::Sys.time()
[10:33:16.220]             {
[10:33:16.220]                 {
[10:33:16.220]                   {
[10:33:16.220]                     {
[10:33:16.220]                       {
[10:33:16.220]                         base::local({
[10:33:16.220]                           has_future <- base::requireNamespace("future", 
[10:33:16.220]                             quietly = TRUE)
[10:33:16.220]                           if (has_future) {
[10:33:16.220]                             ns <- base::getNamespace("future")
[10:33:16.220]                             version <- ns[[".package"]][["version"]]
[10:33:16.220]                             if (is.null(version)) 
[10:33:16.220]                               version <- utils::packageVersion("future")
[10:33:16.220]                           }
[10:33:16.220]                           else {
[10:33:16.220]                             version <- NULL
[10:33:16.220]                           }
[10:33:16.220]                           if (!has_future || version < "1.8.0") {
[10:33:16.220]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:16.220]                               "", base::R.version$version.string), 
[10:33:16.220]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:16.220]                                 base::R.version$platform, 8 * 
[10:33:16.220]                                   base::.Machine$sizeof.pointer), 
[10:33:16.220]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:16.220]                                 "release", "version")], collapse = " "), 
[10:33:16.220]                               hostname = base::Sys.info()[["nodename"]])
[10:33:16.220]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:16.220]                               info)
[10:33:16.220]                             info <- base::paste(info, collapse = "; ")
[10:33:16.220]                             if (!has_future) {
[10:33:16.220]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:16.220]                                 info)
[10:33:16.220]                             }
[10:33:16.220]                             else {
[10:33:16.220]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:16.220]                                 info, version)
[10:33:16.220]                             }
[10:33:16.220]                             base::stop(msg)
[10:33:16.220]                           }
[10:33:16.220]                         })
[10:33:16.220]                       }
[10:33:16.220]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:16.220]                       base::options(mc.cores = 1L)
[10:33:16.220]                     }
[10:33:16.220]                     base::local({
[10:33:16.220]                       for (pkg in "future") {
[10:33:16.220]                         base::loadNamespace(pkg)
[10:33:16.220]                         base::library(pkg, character.only = TRUE)
[10:33:16.220]                       }
[10:33:16.220]                     })
[10:33:16.220]                   }
[10:33:16.220]                   ...future.strategy.old <- future::plan("list")
[10:33:16.220]                   options(future.plan = NULL)
[10:33:16.220]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:16.220]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:16.220]                 }
[10:33:16.220]                 ...future.workdir <- getwd()
[10:33:16.220]             }
[10:33:16.220]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:16.220]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:16.220]         }
[10:33:16.220]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:16.220]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:16.220]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:16.220]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:16.220]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:16.220]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:16.220]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:16.220]             base::names(...future.oldOptions))
[10:33:16.220]     }
[10:33:16.220]     if (FALSE) {
[10:33:16.220]     }
[10:33:16.220]     else {
[10:33:16.220]         if (TRUE) {
[10:33:16.220]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:16.220]                 open = "w")
[10:33:16.220]         }
[10:33:16.220]         else {
[10:33:16.220]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:16.220]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:16.220]         }
[10:33:16.220]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:16.220]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:16.220]             base::sink(type = "output", split = FALSE)
[10:33:16.220]             base::close(...future.stdout)
[10:33:16.220]         }, add = TRUE)
[10:33:16.220]     }
[10:33:16.220]     ...future.frame <- base::sys.nframe()
[10:33:16.220]     ...future.conditions <- base::list()
[10:33:16.220]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:16.220]     if (FALSE) {
[10:33:16.220]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:16.220]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:16.220]     }
[10:33:16.220]     ...future.result <- base::tryCatch({
[10:33:16.220]         base::withCallingHandlers({
[10:33:16.220]             ...future.value <- base::withVisible(base::local({
[10:33:16.220]                 ...future.makeSendCondition <- base::local({
[10:33:16.220]                   sendCondition <- NULL
[10:33:16.220]                   function(frame = 1L) {
[10:33:16.220]                     if (is.function(sendCondition)) 
[10:33:16.220]                       return(sendCondition)
[10:33:16.220]                     ns <- getNamespace("parallel")
[10:33:16.220]                     if (exists("sendData", mode = "function", 
[10:33:16.220]                       envir = ns)) {
[10:33:16.220]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:16.220]                         envir = ns)
[10:33:16.220]                       envir <- sys.frame(frame)
[10:33:16.220]                       master <- NULL
[10:33:16.220]                       while (!identical(envir, .GlobalEnv) && 
[10:33:16.220]                         !identical(envir, emptyenv())) {
[10:33:16.220]                         if (exists("master", mode = "list", envir = envir, 
[10:33:16.220]                           inherits = FALSE)) {
[10:33:16.220]                           master <- get("master", mode = "list", 
[10:33:16.220]                             envir = envir, inherits = FALSE)
[10:33:16.220]                           if (inherits(master, c("SOCKnode", 
[10:33:16.220]                             "SOCK0node"))) {
[10:33:16.220]                             sendCondition <<- function(cond) {
[10:33:16.220]                               data <- list(type = "VALUE", value = cond, 
[10:33:16.220]                                 success = TRUE)
[10:33:16.220]                               parallel_sendData(master, data)
[10:33:16.220]                             }
[10:33:16.220]                             return(sendCondition)
[10:33:16.220]                           }
[10:33:16.220]                         }
[10:33:16.220]                         frame <- frame + 1L
[10:33:16.220]                         envir <- sys.frame(frame)
[10:33:16.220]                       }
[10:33:16.220]                     }
[10:33:16.220]                     sendCondition <<- function(cond) NULL
[10:33:16.220]                   }
[10:33:16.220]                 })
[10:33:16.220]                 withCallingHandlers({
[10:33:16.220]                   value(a) + 1
[10:33:16.220]                 }, immediateCondition = function(cond) {
[10:33:16.220]                   sendCondition <- ...future.makeSendCondition()
[10:33:16.220]                   sendCondition(cond)
[10:33:16.220]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.220]                   {
[10:33:16.220]                     inherits <- base::inherits
[10:33:16.220]                     invokeRestart <- base::invokeRestart
[10:33:16.220]                     is.null <- base::is.null
[10:33:16.220]                     muffled <- FALSE
[10:33:16.220]                     if (inherits(cond, "message")) {
[10:33:16.220]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:16.220]                       if (muffled) 
[10:33:16.220]                         invokeRestart("muffleMessage")
[10:33:16.220]                     }
[10:33:16.220]                     else if (inherits(cond, "warning")) {
[10:33:16.220]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:16.220]                       if (muffled) 
[10:33:16.220]                         invokeRestart("muffleWarning")
[10:33:16.220]                     }
[10:33:16.220]                     else if (inherits(cond, "condition")) {
[10:33:16.220]                       if (!is.null(pattern)) {
[10:33:16.220]                         computeRestarts <- base::computeRestarts
[10:33:16.220]                         grepl <- base::grepl
[10:33:16.220]                         restarts <- computeRestarts(cond)
[10:33:16.220]                         for (restart in restarts) {
[10:33:16.220]                           name <- restart$name
[10:33:16.220]                           if (is.null(name)) 
[10:33:16.220]                             next
[10:33:16.220]                           if (!grepl(pattern, name)) 
[10:33:16.220]                             next
[10:33:16.220]                           invokeRestart(restart)
[10:33:16.220]                           muffled <- TRUE
[10:33:16.220]                           break
[10:33:16.220]                         }
[10:33:16.220]                       }
[10:33:16.220]                     }
[10:33:16.220]                     invisible(muffled)
[10:33:16.220]                   }
[10:33:16.220]                   muffleCondition(cond)
[10:33:16.220]                 })
[10:33:16.220]             }))
[10:33:16.220]             future::FutureResult(value = ...future.value$value, 
[10:33:16.220]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:16.220]                   ...future.rng), globalenv = if (FALSE) 
[10:33:16.220]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:16.220]                     ...future.globalenv.names))
[10:33:16.220]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:16.220]         }, condition = base::local({
[10:33:16.220]             c <- base::c
[10:33:16.220]             inherits <- base::inherits
[10:33:16.220]             invokeRestart <- base::invokeRestart
[10:33:16.220]             length <- base::length
[10:33:16.220]             list <- base::list
[10:33:16.220]             seq.int <- base::seq.int
[10:33:16.220]             signalCondition <- base::signalCondition
[10:33:16.220]             sys.calls <- base::sys.calls
[10:33:16.220]             `[[` <- base::`[[`
[10:33:16.220]             `+` <- base::`+`
[10:33:16.220]             `<<-` <- base::`<<-`
[10:33:16.220]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:16.220]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:16.220]                   3L)]
[10:33:16.220]             }
[10:33:16.220]             function(cond) {
[10:33:16.220]                 is_error <- inherits(cond, "error")
[10:33:16.220]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:16.220]                   NULL)
[10:33:16.220]                 if (is_error) {
[10:33:16.220]                   sessionInformation <- function() {
[10:33:16.220]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:16.220]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:16.220]                       search = base::search(), system = base::Sys.info())
[10:33:16.220]                   }
[10:33:16.220]                   ...future.conditions[[length(...future.conditions) + 
[10:33:16.220]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:16.220]                     cond$call), session = sessionInformation(), 
[10:33:16.220]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:16.220]                   signalCondition(cond)
[10:33:16.220]                 }
[10:33:16.220]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:16.220]                 "immediateCondition"))) {
[10:33:16.220]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:16.220]                   ...future.conditions[[length(...future.conditions) + 
[10:33:16.220]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:16.220]                   if (TRUE && !signal) {
[10:33:16.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.220]                     {
[10:33:16.220]                       inherits <- base::inherits
[10:33:16.220]                       invokeRestart <- base::invokeRestart
[10:33:16.220]                       is.null <- base::is.null
[10:33:16.220]                       muffled <- FALSE
[10:33:16.220]                       if (inherits(cond, "message")) {
[10:33:16.220]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:16.220]                         if (muffled) 
[10:33:16.220]                           invokeRestart("muffleMessage")
[10:33:16.220]                       }
[10:33:16.220]                       else if (inherits(cond, "warning")) {
[10:33:16.220]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:16.220]                         if (muffled) 
[10:33:16.220]                           invokeRestart("muffleWarning")
[10:33:16.220]                       }
[10:33:16.220]                       else if (inherits(cond, "condition")) {
[10:33:16.220]                         if (!is.null(pattern)) {
[10:33:16.220]                           computeRestarts <- base::computeRestarts
[10:33:16.220]                           grepl <- base::grepl
[10:33:16.220]                           restarts <- computeRestarts(cond)
[10:33:16.220]                           for (restart in restarts) {
[10:33:16.220]                             name <- restart$name
[10:33:16.220]                             if (is.null(name)) 
[10:33:16.220]                               next
[10:33:16.220]                             if (!grepl(pattern, name)) 
[10:33:16.220]                               next
[10:33:16.220]                             invokeRestart(restart)
[10:33:16.220]                             muffled <- TRUE
[10:33:16.220]                             break
[10:33:16.220]                           }
[10:33:16.220]                         }
[10:33:16.220]                       }
[10:33:16.220]                       invisible(muffled)
[10:33:16.220]                     }
[10:33:16.220]                     muffleCondition(cond, pattern = "^muffle")
[10:33:16.220]                   }
[10:33:16.220]                 }
[10:33:16.220]                 else {
[10:33:16.220]                   if (TRUE) {
[10:33:16.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.220]                     {
[10:33:16.220]                       inherits <- base::inherits
[10:33:16.220]                       invokeRestart <- base::invokeRestart
[10:33:16.220]                       is.null <- base::is.null
[10:33:16.220]                       muffled <- FALSE
[10:33:16.220]                       if (inherits(cond, "message")) {
[10:33:16.220]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:16.220]                         if (muffled) 
[10:33:16.220]                           invokeRestart("muffleMessage")
[10:33:16.220]                       }
[10:33:16.220]                       else if (inherits(cond, "warning")) {
[10:33:16.220]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:16.220]                         if (muffled) 
[10:33:16.220]                           invokeRestart("muffleWarning")
[10:33:16.220]                       }
[10:33:16.220]                       else if (inherits(cond, "condition")) {
[10:33:16.220]                         if (!is.null(pattern)) {
[10:33:16.220]                           computeRestarts <- base::computeRestarts
[10:33:16.220]                           grepl <- base::grepl
[10:33:16.220]                           restarts <- computeRestarts(cond)
[10:33:16.220]                           for (restart in restarts) {
[10:33:16.220]                             name <- restart$name
[10:33:16.220]                             if (is.null(name)) 
[10:33:16.220]                               next
[10:33:16.220]                             if (!grepl(pattern, name)) 
[10:33:16.220]                               next
[10:33:16.220]                             invokeRestart(restart)
[10:33:16.220]                             muffled <- TRUE
[10:33:16.220]                             break
[10:33:16.220]                           }
[10:33:16.220]                         }
[10:33:16.220]                       }
[10:33:16.220]                       invisible(muffled)
[10:33:16.220]                     }
[10:33:16.220]                     muffleCondition(cond, pattern = "^muffle")
[10:33:16.220]                   }
[10:33:16.220]                 }
[10:33:16.220]             }
[10:33:16.220]         }))
[10:33:16.220]     }, error = function(ex) {
[10:33:16.220]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:16.220]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:16.220]                 ...future.rng), started = ...future.startTime, 
[10:33:16.220]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:16.220]             version = "1.8"), class = "FutureResult")
[10:33:16.220]     }, finally = {
[10:33:16.220]         if (!identical(...future.workdir, getwd())) 
[10:33:16.220]             setwd(...future.workdir)
[10:33:16.220]         {
[10:33:16.220]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:16.220]                 ...future.oldOptions$nwarnings <- NULL
[10:33:16.220]             }
[10:33:16.220]             base::options(...future.oldOptions)
[10:33:16.220]             if (.Platform$OS.type == "windows") {
[10:33:16.220]                 old_names <- names(...future.oldEnvVars)
[10:33:16.220]                 envs <- base::Sys.getenv()
[10:33:16.220]                 names <- names(envs)
[10:33:16.220]                 common <- intersect(names, old_names)
[10:33:16.220]                 added <- setdiff(names, old_names)
[10:33:16.220]                 removed <- setdiff(old_names, names)
[10:33:16.220]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:16.220]                   envs[common]]
[10:33:16.220]                 NAMES <- toupper(changed)
[10:33:16.220]                 args <- list()
[10:33:16.220]                 for (kk in seq_along(NAMES)) {
[10:33:16.220]                   name <- changed[[kk]]
[10:33:16.220]                   NAME <- NAMES[[kk]]
[10:33:16.220]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.220]                     next
[10:33:16.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:16.220]                 }
[10:33:16.220]                 NAMES <- toupper(added)
[10:33:16.220]                 for (kk in seq_along(NAMES)) {
[10:33:16.220]                   name <- added[[kk]]
[10:33:16.220]                   NAME <- NAMES[[kk]]
[10:33:16.220]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.220]                     next
[10:33:16.220]                   args[[name]] <- ""
[10:33:16.220]                 }
[10:33:16.220]                 NAMES <- toupper(removed)
[10:33:16.220]                 for (kk in seq_along(NAMES)) {
[10:33:16.220]                   name <- removed[[kk]]
[10:33:16.220]                   NAME <- NAMES[[kk]]
[10:33:16.220]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.220]                     next
[10:33:16.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:16.220]                 }
[10:33:16.220]                 if (length(args) > 0) 
[10:33:16.220]                   base::do.call(base::Sys.setenv, args = args)
[10:33:16.220]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:16.220]             }
[10:33:16.220]             else {
[10:33:16.220]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:16.220]             }
[10:33:16.220]             {
[10:33:16.220]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:16.220]                   0L) {
[10:33:16.220]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:16.220]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:16.220]                   base::options(opts)
[10:33:16.220]                 }
[10:33:16.220]                 {
[10:33:16.220]                   {
[10:33:16.220]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:16.220]                     NULL
[10:33:16.220]                   }
[10:33:16.220]                   options(future.plan = NULL)
[10:33:16.220]                   if (is.na(NA_character_)) 
[10:33:16.220]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:16.220]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:16.220]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:16.220]                     .init = FALSE)
[10:33:16.220]                 }
[10:33:16.220]             }
[10:33:16.220]         }
[10:33:16.220]     })
[10:33:16.220]     if (TRUE) {
[10:33:16.220]         base::sink(type = "output", split = FALSE)
[10:33:16.220]         if (TRUE) {
[10:33:16.220]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:16.220]         }
[10:33:16.220]         else {
[10:33:16.220]             ...future.result["stdout"] <- base::list(NULL)
[10:33:16.220]         }
[10:33:16.220]         base::close(...future.stdout)
[10:33:16.220]         ...future.stdout <- NULL
[10:33:16.220]     }
[10:33:16.220]     ...future.result$conditions <- ...future.conditions
[10:33:16.220]     ...future.result$finished <- base::Sys.time()
[10:33:16.220]     ...future.result
[10:33:16.220] }
[10:33:16.222] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[10:33:16.224] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[10:33:16.277] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[10:33:16.277] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[10:33:16.278] MultisessionFuture started
[10:33:16.278] - Launch lazy future ... done
[10:33:16.278] run() for ‘MultisessionFuture’ ... done
[10:33:16.278] result() for ClusterFuture ...
[10:33:16.278] receiveMessageFromWorker() for ClusterFuture ...
[10:33:16.278] - Validating connection of MultisessionFuture
[10:33:16.323] - received message: FutureResult
[10:33:16.323] - Received FutureResult
[10:33:16.323] - Erased future from FutureRegistry
[10:33:16.323] result() for ClusterFuture ...
[10:33:16.323] - result already collected: FutureResult
[10:33:16.323] result() for ClusterFuture ... done
[10:33:16.323] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:16.323] result() for ClusterFuture ... done
[10:33:16.324] result() for ClusterFuture ...
[10:33:16.324] - result already collected: FutureResult
[10:33:16.324] result() for ClusterFuture ... done
value(b) = 2
[10:33:16.324] result() for ClusterFuture ...
[10:33:16.324] - result already collected: FutureResult
[10:33:16.324] result() for ClusterFuture ... done
[10:33:16.324] result() for ClusterFuture ...
[10:33:16.324] - result already collected: FutureResult
[10:33:16.324] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:16.325] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:16.325] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:16.325] 
[10:33:16.325] Searching for globals ... DONE
[10:33:16.325] - globals: [0] <none>
[10:33:16.326] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:16.326] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:16.326] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:16.327] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:16.327] Searching for globals ... DONE
[10:33:16.327] Resolving globals: TRUE
[10:33:16.327] Resolving any globals that are futures ...
[10:33:16.327] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:16.327] Resolving any globals that are futures ... DONE
[10:33:16.328] Resolving futures part of globals (recursively) ...
[10:33:16.328] resolve() on list ...
[10:33:16.328]  recursive: 99
[10:33:16.328]  length: 1
[10:33:16.328]  elements: ‘a’
[10:33:16.328] run() for ‘Future’ ...
[10:33:16.328] - state: ‘created’
[10:33:16.328] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:16.343] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:16.343] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:16.343]   - Field: ‘node’
[10:33:16.344]   - Field: ‘label’
[10:33:16.344]   - Field: ‘local’
[10:33:16.344]   - Field: ‘owner’
[10:33:16.344]   - Field: ‘envir’
[10:33:16.344]   - Field: ‘workers’
[10:33:16.344]   - Field: ‘packages’
[10:33:16.344]   - Field: ‘gc’
[10:33:16.344]   - Field: ‘conditions’
[10:33:16.344]   - Field: ‘persistent’
[10:33:16.344]   - Field: ‘expr’
[10:33:16.345]   - Field: ‘uuid’
[10:33:16.345]   - Field: ‘seed’
[10:33:16.345]   - Field: ‘version’
[10:33:16.345]   - Field: ‘result’
[10:33:16.345]   - Field: ‘asynchronous’
[10:33:16.345]   - Field: ‘calls’
[10:33:16.345]   - Field: ‘globals’
[10:33:16.345]   - Field: ‘stdout’
[10:33:16.345]   - Field: ‘earlySignal’
[10:33:16.345]   - Field: ‘lazy’
[10:33:16.346]   - Field: ‘state’
[10:33:16.346] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:16.346] - Launch lazy future ...
[10:33:16.346] Packages needed by the future expression (n = 0): <none>
[10:33:16.346] Packages needed by future strategies (n = 0): <none>
[10:33:16.347] {
[10:33:16.347]     {
[10:33:16.347]         {
[10:33:16.347]             ...future.startTime <- base::Sys.time()
[10:33:16.347]             {
[10:33:16.347]                 {
[10:33:16.347]                   {
[10:33:16.347]                     {
[10:33:16.347]                       base::local({
[10:33:16.347]                         has_future <- base::requireNamespace("future", 
[10:33:16.347]                           quietly = TRUE)
[10:33:16.347]                         if (has_future) {
[10:33:16.347]                           ns <- base::getNamespace("future")
[10:33:16.347]                           version <- ns[[".package"]][["version"]]
[10:33:16.347]                           if (is.null(version)) 
[10:33:16.347]                             version <- utils::packageVersion("future")
[10:33:16.347]                         }
[10:33:16.347]                         else {
[10:33:16.347]                           version <- NULL
[10:33:16.347]                         }
[10:33:16.347]                         if (!has_future || version < "1.8.0") {
[10:33:16.347]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:16.347]                             "", base::R.version$version.string), 
[10:33:16.347]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:16.347]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:16.347]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:16.347]                               "release", "version")], collapse = " "), 
[10:33:16.347]                             hostname = base::Sys.info()[["nodename"]])
[10:33:16.347]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:16.347]                             info)
[10:33:16.347]                           info <- base::paste(info, collapse = "; ")
[10:33:16.347]                           if (!has_future) {
[10:33:16.347]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:16.347]                               info)
[10:33:16.347]                           }
[10:33:16.347]                           else {
[10:33:16.347]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:16.347]                               info, version)
[10:33:16.347]                           }
[10:33:16.347]                           base::stop(msg)
[10:33:16.347]                         }
[10:33:16.347]                       })
[10:33:16.347]                     }
[10:33:16.347]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:16.347]                     base::options(mc.cores = 1L)
[10:33:16.347]                   }
[10:33:16.347]                   ...future.strategy.old <- future::plan("list")
[10:33:16.347]                   options(future.plan = NULL)
[10:33:16.347]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:16.347]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:16.347]                 }
[10:33:16.347]                 ...future.workdir <- getwd()
[10:33:16.347]             }
[10:33:16.347]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:16.347]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:16.347]         }
[10:33:16.347]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:16.347]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:16.347]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:16.347]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:16.347]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:16.347]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:16.347]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:16.347]             base::names(...future.oldOptions))
[10:33:16.347]     }
[10:33:16.347]     if (FALSE) {
[10:33:16.347]     }
[10:33:16.347]     else {
[10:33:16.347]         if (TRUE) {
[10:33:16.347]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:16.347]                 open = "w")
[10:33:16.347]         }
[10:33:16.347]         else {
[10:33:16.347]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:16.347]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:16.347]         }
[10:33:16.347]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:16.347]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:16.347]             base::sink(type = "output", split = FALSE)
[10:33:16.347]             base::close(...future.stdout)
[10:33:16.347]         }, add = TRUE)
[10:33:16.347]     }
[10:33:16.347]     ...future.frame <- base::sys.nframe()
[10:33:16.347]     ...future.conditions <- base::list()
[10:33:16.347]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:16.347]     if (FALSE) {
[10:33:16.347]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:16.347]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:16.347]     }
[10:33:16.347]     ...future.result <- base::tryCatch({
[10:33:16.347]         base::withCallingHandlers({
[10:33:16.347]             ...future.value <- base::withVisible(base::local({
[10:33:16.347]                 ...future.makeSendCondition <- base::local({
[10:33:16.347]                   sendCondition <- NULL
[10:33:16.347]                   function(frame = 1L) {
[10:33:16.347]                     if (is.function(sendCondition)) 
[10:33:16.347]                       return(sendCondition)
[10:33:16.347]                     ns <- getNamespace("parallel")
[10:33:16.347]                     if (exists("sendData", mode = "function", 
[10:33:16.347]                       envir = ns)) {
[10:33:16.347]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:16.347]                         envir = ns)
[10:33:16.347]                       envir <- sys.frame(frame)
[10:33:16.347]                       master <- NULL
[10:33:16.347]                       while (!identical(envir, .GlobalEnv) && 
[10:33:16.347]                         !identical(envir, emptyenv())) {
[10:33:16.347]                         if (exists("master", mode = "list", envir = envir, 
[10:33:16.347]                           inherits = FALSE)) {
[10:33:16.347]                           master <- get("master", mode = "list", 
[10:33:16.347]                             envir = envir, inherits = FALSE)
[10:33:16.347]                           if (inherits(master, c("SOCKnode", 
[10:33:16.347]                             "SOCK0node"))) {
[10:33:16.347]                             sendCondition <<- function(cond) {
[10:33:16.347]                               data <- list(type = "VALUE", value = cond, 
[10:33:16.347]                                 success = TRUE)
[10:33:16.347]                               parallel_sendData(master, data)
[10:33:16.347]                             }
[10:33:16.347]                             return(sendCondition)
[10:33:16.347]                           }
[10:33:16.347]                         }
[10:33:16.347]                         frame <- frame + 1L
[10:33:16.347]                         envir <- sys.frame(frame)
[10:33:16.347]                       }
[10:33:16.347]                     }
[10:33:16.347]                     sendCondition <<- function(cond) NULL
[10:33:16.347]                   }
[10:33:16.347]                 })
[10:33:16.347]                 withCallingHandlers({
[10:33:16.347]                   1
[10:33:16.347]                 }, immediateCondition = function(cond) {
[10:33:16.347]                   sendCondition <- ...future.makeSendCondition()
[10:33:16.347]                   sendCondition(cond)
[10:33:16.347]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.347]                   {
[10:33:16.347]                     inherits <- base::inherits
[10:33:16.347]                     invokeRestart <- base::invokeRestart
[10:33:16.347]                     is.null <- base::is.null
[10:33:16.347]                     muffled <- FALSE
[10:33:16.347]                     if (inherits(cond, "message")) {
[10:33:16.347]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:16.347]                       if (muffled) 
[10:33:16.347]                         invokeRestart("muffleMessage")
[10:33:16.347]                     }
[10:33:16.347]                     else if (inherits(cond, "warning")) {
[10:33:16.347]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:16.347]                       if (muffled) 
[10:33:16.347]                         invokeRestart("muffleWarning")
[10:33:16.347]                     }
[10:33:16.347]                     else if (inherits(cond, "condition")) {
[10:33:16.347]                       if (!is.null(pattern)) {
[10:33:16.347]                         computeRestarts <- base::computeRestarts
[10:33:16.347]                         grepl <- base::grepl
[10:33:16.347]                         restarts <- computeRestarts(cond)
[10:33:16.347]                         for (restart in restarts) {
[10:33:16.347]                           name <- restart$name
[10:33:16.347]                           if (is.null(name)) 
[10:33:16.347]                             next
[10:33:16.347]                           if (!grepl(pattern, name)) 
[10:33:16.347]                             next
[10:33:16.347]                           invokeRestart(restart)
[10:33:16.347]                           muffled <- TRUE
[10:33:16.347]                           break
[10:33:16.347]                         }
[10:33:16.347]                       }
[10:33:16.347]                     }
[10:33:16.347]                     invisible(muffled)
[10:33:16.347]                   }
[10:33:16.347]                   muffleCondition(cond)
[10:33:16.347]                 })
[10:33:16.347]             }))
[10:33:16.347]             future::FutureResult(value = ...future.value$value, 
[10:33:16.347]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:16.347]                   ...future.rng), globalenv = if (FALSE) 
[10:33:16.347]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:16.347]                     ...future.globalenv.names))
[10:33:16.347]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:16.347]         }, condition = base::local({
[10:33:16.347]             c <- base::c
[10:33:16.347]             inherits <- base::inherits
[10:33:16.347]             invokeRestart <- base::invokeRestart
[10:33:16.347]             length <- base::length
[10:33:16.347]             list <- base::list
[10:33:16.347]             seq.int <- base::seq.int
[10:33:16.347]             signalCondition <- base::signalCondition
[10:33:16.347]             sys.calls <- base::sys.calls
[10:33:16.347]             `[[` <- base::`[[`
[10:33:16.347]             `+` <- base::`+`
[10:33:16.347]             `<<-` <- base::`<<-`
[10:33:16.347]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:16.347]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:16.347]                   3L)]
[10:33:16.347]             }
[10:33:16.347]             function(cond) {
[10:33:16.347]                 is_error <- inherits(cond, "error")
[10:33:16.347]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:16.347]                   NULL)
[10:33:16.347]                 if (is_error) {
[10:33:16.347]                   sessionInformation <- function() {
[10:33:16.347]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:16.347]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:16.347]                       search = base::search(), system = base::Sys.info())
[10:33:16.347]                   }
[10:33:16.347]                   ...future.conditions[[length(...future.conditions) + 
[10:33:16.347]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:16.347]                     cond$call), session = sessionInformation(), 
[10:33:16.347]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:16.347]                   signalCondition(cond)
[10:33:16.347]                 }
[10:33:16.347]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:16.347]                 "immediateCondition"))) {
[10:33:16.347]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:16.347]                   ...future.conditions[[length(...future.conditions) + 
[10:33:16.347]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:16.347]                   if (TRUE && !signal) {
[10:33:16.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.347]                     {
[10:33:16.347]                       inherits <- base::inherits
[10:33:16.347]                       invokeRestart <- base::invokeRestart
[10:33:16.347]                       is.null <- base::is.null
[10:33:16.347]                       muffled <- FALSE
[10:33:16.347]                       if (inherits(cond, "message")) {
[10:33:16.347]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:16.347]                         if (muffled) 
[10:33:16.347]                           invokeRestart("muffleMessage")
[10:33:16.347]                       }
[10:33:16.347]                       else if (inherits(cond, "warning")) {
[10:33:16.347]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:16.347]                         if (muffled) 
[10:33:16.347]                           invokeRestart("muffleWarning")
[10:33:16.347]                       }
[10:33:16.347]                       else if (inherits(cond, "condition")) {
[10:33:16.347]                         if (!is.null(pattern)) {
[10:33:16.347]                           computeRestarts <- base::computeRestarts
[10:33:16.347]                           grepl <- base::grepl
[10:33:16.347]                           restarts <- computeRestarts(cond)
[10:33:16.347]                           for (restart in restarts) {
[10:33:16.347]                             name <- restart$name
[10:33:16.347]                             if (is.null(name)) 
[10:33:16.347]                               next
[10:33:16.347]                             if (!grepl(pattern, name)) 
[10:33:16.347]                               next
[10:33:16.347]                             invokeRestart(restart)
[10:33:16.347]                             muffled <- TRUE
[10:33:16.347]                             break
[10:33:16.347]                           }
[10:33:16.347]                         }
[10:33:16.347]                       }
[10:33:16.347]                       invisible(muffled)
[10:33:16.347]                     }
[10:33:16.347]                     muffleCondition(cond, pattern = "^muffle")
[10:33:16.347]                   }
[10:33:16.347]                 }
[10:33:16.347]                 else {
[10:33:16.347]                   if (TRUE) {
[10:33:16.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.347]                     {
[10:33:16.347]                       inherits <- base::inherits
[10:33:16.347]                       invokeRestart <- base::invokeRestart
[10:33:16.347]                       is.null <- base::is.null
[10:33:16.347]                       muffled <- FALSE
[10:33:16.347]                       if (inherits(cond, "message")) {
[10:33:16.347]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:16.347]                         if (muffled) 
[10:33:16.347]                           invokeRestart("muffleMessage")
[10:33:16.347]                       }
[10:33:16.347]                       else if (inherits(cond, "warning")) {
[10:33:16.347]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:16.347]                         if (muffled) 
[10:33:16.347]                           invokeRestart("muffleWarning")
[10:33:16.347]                       }
[10:33:16.347]                       else if (inherits(cond, "condition")) {
[10:33:16.347]                         if (!is.null(pattern)) {
[10:33:16.347]                           computeRestarts <- base::computeRestarts
[10:33:16.347]                           grepl <- base::grepl
[10:33:16.347]                           restarts <- computeRestarts(cond)
[10:33:16.347]                           for (restart in restarts) {
[10:33:16.347]                             name <- restart$name
[10:33:16.347]                             if (is.null(name)) 
[10:33:16.347]                               next
[10:33:16.347]                             if (!grepl(pattern, name)) 
[10:33:16.347]                               next
[10:33:16.347]                             invokeRestart(restart)
[10:33:16.347]                             muffled <- TRUE
[10:33:16.347]                             break
[10:33:16.347]                           }
[10:33:16.347]                         }
[10:33:16.347]                       }
[10:33:16.347]                       invisible(muffled)
[10:33:16.347]                     }
[10:33:16.347]                     muffleCondition(cond, pattern = "^muffle")
[10:33:16.347]                   }
[10:33:16.347]                 }
[10:33:16.347]             }
[10:33:16.347]         }))
[10:33:16.347]     }, error = function(ex) {
[10:33:16.347]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:16.347]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:16.347]                 ...future.rng), started = ...future.startTime, 
[10:33:16.347]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:16.347]             version = "1.8"), class = "FutureResult")
[10:33:16.347]     }, finally = {
[10:33:16.347]         if (!identical(...future.workdir, getwd())) 
[10:33:16.347]             setwd(...future.workdir)
[10:33:16.347]         {
[10:33:16.347]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:16.347]                 ...future.oldOptions$nwarnings <- NULL
[10:33:16.347]             }
[10:33:16.347]             base::options(...future.oldOptions)
[10:33:16.347]             if (.Platform$OS.type == "windows") {
[10:33:16.347]                 old_names <- names(...future.oldEnvVars)
[10:33:16.347]                 envs <- base::Sys.getenv()
[10:33:16.347]                 names <- names(envs)
[10:33:16.347]                 common <- intersect(names, old_names)
[10:33:16.347]                 added <- setdiff(names, old_names)
[10:33:16.347]                 removed <- setdiff(old_names, names)
[10:33:16.347]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:16.347]                   envs[common]]
[10:33:16.347]                 NAMES <- toupper(changed)
[10:33:16.347]                 args <- list()
[10:33:16.347]                 for (kk in seq_along(NAMES)) {
[10:33:16.347]                   name <- changed[[kk]]
[10:33:16.347]                   NAME <- NAMES[[kk]]
[10:33:16.347]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.347]                     next
[10:33:16.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:16.347]                 }
[10:33:16.347]                 NAMES <- toupper(added)
[10:33:16.347]                 for (kk in seq_along(NAMES)) {
[10:33:16.347]                   name <- added[[kk]]
[10:33:16.347]                   NAME <- NAMES[[kk]]
[10:33:16.347]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.347]                     next
[10:33:16.347]                   args[[name]] <- ""
[10:33:16.347]                 }
[10:33:16.347]                 NAMES <- toupper(removed)
[10:33:16.347]                 for (kk in seq_along(NAMES)) {
[10:33:16.347]                   name <- removed[[kk]]
[10:33:16.347]                   NAME <- NAMES[[kk]]
[10:33:16.347]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.347]                     next
[10:33:16.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:16.347]                 }
[10:33:16.347]                 if (length(args) > 0) 
[10:33:16.347]                   base::do.call(base::Sys.setenv, args = args)
[10:33:16.347]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:16.347]             }
[10:33:16.347]             else {
[10:33:16.347]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:16.347]             }
[10:33:16.347]             {
[10:33:16.347]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:16.347]                   0L) {
[10:33:16.347]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:16.347]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:16.347]                   base::options(opts)
[10:33:16.347]                 }
[10:33:16.347]                 {
[10:33:16.347]                   {
[10:33:16.347]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:16.347]                     NULL
[10:33:16.347]                   }
[10:33:16.347]                   options(future.plan = NULL)
[10:33:16.347]                   if (is.na(NA_character_)) 
[10:33:16.347]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:16.347]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:16.347]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:16.347]                     .init = FALSE)
[10:33:16.347]                 }
[10:33:16.347]             }
[10:33:16.347]         }
[10:33:16.347]     })
[10:33:16.347]     if (TRUE) {
[10:33:16.347]         base::sink(type = "output", split = FALSE)
[10:33:16.347]         if (TRUE) {
[10:33:16.347]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:16.347]         }
[10:33:16.347]         else {
[10:33:16.347]             ...future.result["stdout"] <- base::list(NULL)
[10:33:16.347]         }
[10:33:16.347]         base::close(...future.stdout)
[10:33:16.347]         ...future.stdout <- NULL
[10:33:16.347]     }
[10:33:16.347]     ...future.result$conditions <- ...future.conditions
[10:33:16.347]     ...future.result$finished <- base::Sys.time()
[10:33:16.347]     ...future.result
[10:33:16.347] }
[10:33:16.349] MultisessionFuture started
[10:33:16.349] - Launch lazy future ... done
[10:33:16.350] run() for ‘MultisessionFuture’ ... done
[10:33:16.394] receiveMessageFromWorker() for ClusterFuture ...
[10:33:16.395] - Validating connection of MultisessionFuture
[10:33:16.395] - received message: FutureResult
[10:33:16.395] - Received FutureResult
[10:33:16.395] - Erased future from FutureRegistry
[10:33:16.395] result() for ClusterFuture ...
[10:33:16.395] - result already collected: FutureResult
[10:33:16.395] result() for ClusterFuture ... done
[10:33:16.396] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:16.396] Future #1
[10:33:16.396] result() for ClusterFuture ...
[10:33:16.396] - result already collected: FutureResult
[10:33:16.396] result() for ClusterFuture ... done
[10:33:16.396] result() for ClusterFuture ...
[10:33:16.396] - result already collected: FutureResult
[10:33:16.396] result() for ClusterFuture ... done
[10:33:16.396] A MultisessionFuture was resolved
[10:33:16.396]  length: 0 (resolved future 1)
[10:33:16.397] resolve() on list ... DONE
[10:33:16.397] - globals: [1] ‘a’
[10:33:16.397] Resolving futures part of globals (recursively) ... DONE
[10:33:16.399] The total size of the 1 globals is 1.57 MiB (1646896 bytes)
[10:33:16.399] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[10:33:16.399] - globals: [1] ‘a’
[10:33:16.399] - packages: [1] ‘future’
[10:33:16.400] getGlobalsAndPackages() ... DONE
[10:33:16.400] run() for ‘Future’ ...
[10:33:16.400] - state: ‘created’
[10:33:16.400] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:16.414] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:16.414] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:16.414]   - Field: ‘node’
[10:33:16.414]   - Field: ‘label’
[10:33:16.414]   - Field: ‘local’
[10:33:16.414]   - Field: ‘owner’
[10:33:16.414]   - Field: ‘envir’
[10:33:16.414]   - Field: ‘workers’
[10:33:16.414]   - Field: ‘packages’
[10:33:16.414]   - Field: ‘gc’
[10:33:16.415]   - Field: ‘conditions’
[10:33:16.415]   - Field: ‘persistent’
[10:33:16.415]   - Field: ‘expr’
[10:33:16.415]   - Field: ‘uuid’
[10:33:16.415]   - Field: ‘seed’
[10:33:16.415]   - Field: ‘version’
[10:33:16.415]   - Field: ‘result’
[10:33:16.415]   - Field: ‘asynchronous’
[10:33:16.415]   - Field: ‘calls’
[10:33:16.415]   - Field: ‘globals’
[10:33:16.415]   - Field: ‘stdout’
[10:33:16.416]   - Field: ‘earlySignal’
[10:33:16.416]   - Field: ‘lazy’
[10:33:16.416]   - Field: ‘state’
[10:33:16.416] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:16.416] - Launch lazy future ...
[10:33:16.416] Packages needed by the future expression (n = 1): ‘future’
[10:33:16.416] Packages needed by future strategies (n = 0): <none>
[10:33:16.417] {
[10:33:16.417]     {
[10:33:16.417]         {
[10:33:16.417]             ...future.startTime <- base::Sys.time()
[10:33:16.417]             {
[10:33:16.417]                 {
[10:33:16.417]                   {
[10:33:16.417]                     {
[10:33:16.417]                       {
[10:33:16.417]                         base::local({
[10:33:16.417]                           has_future <- base::requireNamespace("future", 
[10:33:16.417]                             quietly = TRUE)
[10:33:16.417]                           if (has_future) {
[10:33:16.417]                             ns <- base::getNamespace("future")
[10:33:16.417]                             version <- ns[[".package"]][["version"]]
[10:33:16.417]                             if (is.null(version)) 
[10:33:16.417]                               version <- utils::packageVersion("future")
[10:33:16.417]                           }
[10:33:16.417]                           else {
[10:33:16.417]                             version <- NULL
[10:33:16.417]                           }
[10:33:16.417]                           if (!has_future || version < "1.8.0") {
[10:33:16.417]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:16.417]                               "", base::R.version$version.string), 
[10:33:16.417]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:16.417]                                 base::R.version$platform, 8 * 
[10:33:16.417]                                   base::.Machine$sizeof.pointer), 
[10:33:16.417]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:16.417]                                 "release", "version")], collapse = " "), 
[10:33:16.417]                               hostname = base::Sys.info()[["nodename"]])
[10:33:16.417]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:16.417]                               info)
[10:33:16.417]                             info <- base::paste(info, collapse = "; ")
[10:33:16.417]                             if (!has_future) {
[10:33:16.417]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:16.417]                                 info)
[10:33:16.417]                             }
[10:33:16.417]                             else {
[10:33:16.417]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:16.417]                                 info, version)
[10:33:16.417]                             }
[10:33:16.417]                             base::stop(msg)
[10:33:16.417]                           }
[10:33:16.417]                         })
[10:33:16.417]                       }
[10:33:16.417]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:16.417]                       base::options(mc.cores = 1L)
[10:33:16.417]                     }
[10:33:16.417]                     base::local({
[10:33:16.417]                       for (pkg in "future") {
[10:33:16.417]                         base::loadNamespace(pkg)
[10:33:16.417]                         base::library(pkg, character.only = TRUE)
[10:33:16.417]                       }
[10:33:16.417]                     })
[10:33:16.417]                   }
[10:33:16.417]                   ...future.strategy.old <- future::plan("list")
[10:33:16.417]                   options(future.plan = NULL)
[10:33:16.417]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:16.417]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:16.417]                 }
[10:33:16.417]                 ...future.workdir <- getwd()
[10:33:16.417]             }
[10:33:16.417]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:16.417]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:16.417]         }
[10:33:16.417]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:16.417]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:16.417]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:16.417]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:16.417]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:16.417]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:16.417]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:16.417]             base::names(...future.oldOptions))
[10:33:16.417]     }
[10:33:16.417]     if (FALSE) {
[10:33:16.417]     }
[10:33:16.417]     else {
[10:33:16.417]         if (TRUE) {
[10:33:16.417]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:16.417]                 open = "w")
[10:33:16.417]         }
[10:33:16.417]         else {
[10:33:16.417]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:16.417]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:16.417]         }
[10:33:16.417]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:16.417]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:16.417]             base::sink(type = "output", split = FALSE)
[10:33:16.417]             base::close(...future.stdout)
[10:33:16.417]         }, add = TRUE)
[10:33:16.417]     }
[10:33:16.417]     ...future.frame <- base::sys.nframe()
[10:33:16.417]     ...future.conditions <- base::list()
[10:33:16.417]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:16.417]     if (FALSE) {
[10:33:16.417]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:16.417]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:16.417]     }
[10:33:16.417]     ...future.result <- base::tryCatch({
[10:33:16.417]         base::withCallingHandlers({
[10:33:16.417]             ...future.value <- base::withVisible(base::local({
[10:33:16.417]                 ...future.makeSendCondition <- base::local({
[10:33:16.417]                   sendCondition <- NULL
[10:33:16.417]                   function(frame = 1L) {
[10:33:16.417]                     if (is.function(sendCondition)) 
[10:33:16.417]                       return(sendCondition)
[10:33:16.417]                     ns <- getNamespace("parallel")
[10:33:16.417]                     if (exists("sendData", mode = "function", 
[10:33:16.417]                       envir = ns)) {
[10:33:16.417]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:16.417]                         envir = ns)
[10:33:16.417]                       envir <- sys.frame(frame)
[10:33:16.417]                       master <- NULL
[10:33:16.417]                       while (!identical(envir, .GlobalEnv) && 
[10:33:16.417]                         !identical(envir, emptyenv())) {
[10:33:16.417]                         if (exists("master", mode = "list", envir = envir, 
[10:33:16.417]                           inherits = FALSE)) {
[10:33:16.417]                           master <- get("master", mode = "list", 
[10:33:16.417]                             envir = envir, inherits = FALSE)
[10:33:16.417]                           if (inherits(master, c("SOCKnode", 
[10:33:16.417]                             "SOCK0node"))) {
[10:33:16.417]                             sendCondition <<- function(cond) {
[10:33:16.417]                               data <- list(type = "VALUE", value = cond, 
[10:33:16.417]                                 success = TRUE)
[10:33:16.417]                               parallel_sendData(master, data)
[10:33:16.417]                             }
[10:33:16.417]                             return(sendCondition)
[10:33:16.417]                           }
[10:33:16.417]                         }
[10:33:16.417]                         frame <- frame + 1L
[10:33:16.417]                         envir <- sys.frame(frame)
[10:33:16.417]                       }
[10:33:16.417]                     }
[10:33:16.417]                     sendCondition <<- function(cond) NULL
[10:33:16.417]                   }
[10:33:16.417]                 })
[10:33:16.417]                 withCallingHandlers({
[10:33:16.417]                   value(a) + 1
[10:33:16.417]                 }, immediateCondition = function(cond) {
[10:33:16.417]                   sendCondition <- ...future.makeSendCondition()
[10:33:16.417]                   sendCondition(cond)
[10:33:16.417]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.417]                   {
[10:33:16.417]                     inherits <- base::inherits
[10:33:16.417]                     invokeRestart <- base::invokeRestart
[10:33:16.417]                     is.null <- base::is.null
[10:33:16.417]                     muffled <- FALSE
[10:33:16.417]                     if (inherits(cond, "message")) {
[10:33:16.417]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:16.417]                       if (muffled) 
[10:33:16.417]                         invokeRestart("muffleMessage")
[10:33:16.417]                     }
[10:33:16.417]                     else if (inherits(cond, "warning")) {
[10:33:16.417]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:16.417]                       if (muffled) 
[10:33:16.417]                         invokeRestart("muffleWarning")
[10:33:16.417]                     }
[10:33:16.417]                     else if (inherits(cond, "condition")) {
[10:33:16.417]                       if (!is.null(pattern)) {
[10:33:16.417]                         computeRestarts <- base::computeRestarts
[10:33:16.417]                         grepl <- base::grepl
[10:33:16.417]                         restarts <- computeRestarts(cond)
[10:33:16.417]                         for (restart in restarts) {
[10:33:16.417]                           name <- restart$name
[10:33:16.417]                           if (is.null(name)) 
[10:33:16.417]                             next
[10:33:16.417]                           if (!grepl(pattern, name)) 
[10:33:16.417]                             next
[10:33:16.417]                           invokeRestart(restart)
[10:33:16.417]                           muffled <- TRUE
[10:33:16.417]                           break
[10:33:16.417]                         }
[10:33:16.417]                       }
[10:33:16.417]                     }
[10:33:16.417]                     invisible(muffled)
[10:33:16.417]                   }
[10:33:16.417]                   muffleCondition(cond)
[10:33:16.417]                 })
[10:33:16.417]             }))
[10:33:16.417]             future::FutureResult(value = ...future.value$value, 
[10:33:16.417]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:16.417]                   ...future.rng), globalenv = if (FALSE) 
[10:33:16.417]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:16.417]                     ...future.globalenv.names))
[10:33:16.417]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:16.417]         }, condition = base::local({
[10:33:16.417]             c <- base::c
[10:33:16.417]             inherits <- base::inherits
[10:33:16.417]             invokeRestart <- base::invokeRestart
[10:33:16.417]             length <- base::length
[10:33:16.417]             list <- base::list
[10:33:16.417]             seq.int <- base::seq.int
[10:33:16.417]             signalCondition <- base::signalCondition
[10:33:16.417]             sys.calls <- base::sys.calls
[10:33:16.417]             `[[` <- base::`[[`
[10:33:16.417]             `+` <- base::`+`
[10:33:16.417]             `<<-` <- base::`<<-`
[10:33:16.417]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:16.417]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:16.417]                   3L)]
[10:33:16.417]             }
[10:33:16.417]             function(cond) {
[10:33:16.417]                 is_error <- inherits(cond, "error")
[10:33:16.417]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:16.417]                   NULL)
[10:33:16.417]                 if (is_error) {
[10:33:16.417]                   sessionInformation <- function() {
[10:33:16.417]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:16.417]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:16.417]                       search = base::search(), system = base::Sys.info())
[10:33:16.417]                   }
[10:33:16.417]                   ...future.conditions[[length(...future.conditions) + 
[10:33:16.417]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:16.417]                     cond$call), session = sessionInformation(), 
[10:33:16.417]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:16.417]                   signalCondition(cond)
[10:33:16.417]                 }
[10:33:16.417]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:16.417]                 "immediateCondition"))) {
[10:33:16.417]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:16.417]                   ...future.conditions[[length(...future.conditions) + 
[10:33:16.417]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:16.417]                   if (TRUE && !signal) {
[10:33:16.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.417]                     {
[10:33:16.417]                       inherits <- base::inherits
[10:33:16.417]                       invokeRestart <- base::invokeRestart
[10:33:16.417]                       is.null <- base::is.null
[10:33:16.417]                       muffled <- FALSE
[10:33:16.417]                       if (inherits(cond, "message")) {
[10:33:16.417]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:16.417]                         if (muffled) 
[10:33:16.417]                           invokeRestart("muffleMessage")
[10:33:16.417]                       }
[10:33:16.417]                       else if (inherits(cond, "warning")) {
[10:33:16.417]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:16.417]                         if (muffled) 
[10:33:16.417]                           invokeRestart("muffleWarning")
[10:33:16.417]                       }
[10:33:16.417]                       else if (inherits(cond, "condition")) {
[10:33:16.417]                         if (!is.null(pattern)) {
[10:33:16.417]                           computeRestarts <- base::computeRestarts
[10:33:16.417]                           grepl <- base::grepl
[10:33:16.417]                           restarts <- computeRestarts(cond)
[10:33:16.417]                           for (restart in restarts) {
[10:33:16.417]                             name <- restart$name
[10:33:16.417]                             if (is.null(name)) 
[10:33:16.417]                               next
[10:33:16.417]                             if (!grepl(pattern, name)) 
[10:33:16.417]                               next
[10:33:16.417]                             invokeRestart(restart)
[10:33:16.417]                             muffled <- TRUE
[10:33:16.417]                             break
[10:33:16.417]                           }
[10:33:16.417]                         }
[10:33:16.417]                       }
[10:33:16.417]                       invisible(muffled)
[10:33:16.417]                     }
[10:33:16.417]                     muffleCondition(cond, pattern = "^muffle")
[10:33:16.417]                   }
[10:33:16.417]                 }
[10:33:16.417]                 else {
[10:33:16.417]                   if (TRUE) {
[10:33:16.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.417]                     {
[10:33:16.417]                       inherits <- base::inherits
[10:33:16.417]                       invokeRestart <- base::invokeRestart
[10:33:16.417]                       is.null <- base::is.null
[10:33:16.417]                       muffled <- FALSE
[10:33:16.417]                       if (inherits(cond, "message")) {
[10:33:16.417]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:16.417]                         if (muffled) 
[10:33:16.417]                           invokeRestart("muffleMessage")
[10:33:16.417]                       }
[10:33:16.417]                       else if (inherits(cond, "warning")) {
[10:33:16.417]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:16.417]                         if (muffled) 
[10:33:16.417]                           invokeRestart("muffleWarning")
[10:33:16.417]                       }
[10:33:16.417]                       else if (inherits(cond, "condition")) {
[10:33:16.417]                         if (!is.null(pattern)) {
[10:33:16.417]                           computeRestarts <- base::computeRestarts
[10:33:16.417]                           grepl <- base::grepl
[10:33:16.417]                           restarts <- computeRestarts(cond)
[10:33:16.417]                           for (restart in restarts) {
[10:33:16.417]                             name <- restart$name
[10:33:16.417]                             if (is.null(name)) 
[10:33:16.417]                               next
[10:33:16.417]                             if (!grepl(pattern, name)) 
[10:33:16.417]                               next
[10:33:16.417]                             invokeRestart(restart)
[10:33:16.417]                             muffled <- TRUE
[10:33:16.417]                             break
[10:33:16.417]                           }
[10:33:16.417]                         }
[10:33:16.417]                       }
[10:33:16.417]                       invisible(muffled)
[10:33:16.417]                     }
[10:33:16.417]                     muffleCondition(cond, pattern = "^muffle")
[10:33:16.417]                   }
[10:33:16.417]                 }
[10:33:16.417]             }
[10:33:16.417]         }))
[10:33:16.417]     }, error = function(ex) {
[10:33:16.417]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:16.417]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:16.417]                 ...future.rng), started = ...future.startTime, 
[10:33:16.417]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:16.417]             version = "1.8"), class = "FutureResult")
[10:33:16.417]     }, finally = {
[10:33:16.417]         if (!identical(...future.workdir, getwd())) 
[10:33:16.417]             setwd(...future.workdir)
[10:33:16.417]         {
[10:33:16.417]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:16.417]                 ...future.oldOptions$nwarnings <- NULL
[10:33:16.417]             }
[10:33:16.417]             base::options(...future.oldOptions)
[10:33:16.417]             if (.Platform$OS.type == "windows") {
[10:33:16.417]                 old_names <- names(...future.oldEnvVars)
[10:33:16.417]                 envs <- base::Sys.getenv()
[10:33:16.417]                 names <- names(envs)
[10:33:16.417]                 common <- intersect(names, old_names)
[10:33:16.417]                 added <- setdiff(names, old_names)
[10:33:16.417]                 removed <- setdiff(old_names, names)
[10:33:16.417]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:16.417]                   envs[common]]
[10:33:16.417]                 NAMES <- toupper(changed)
[10:33:16.417]                 args <- list()
[10:33:16.417]                 for (kk in seq_along(NAMES)) {
[10:33:16.417]                   name <- changed[[kk]]
[10:33:16.417]                   NAME <- NAMES[[kk]]
[10:33:16.417]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.417]                     next
[10:33:16.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:16.417]                 }
[10:33:16.417]                 NAMES <- toupper(added)
[10:33:16.417]                 for (kk in seq_along(NAMES)) {
[10:33:16.417]                   name <- added[[kk]]
[10:33:16.417]                   NAME <- NAMES[[kk]]
[10:33:16.417]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.417]                     next
[10:33:16.417]                   args[[name]] <- ""
[10:33:16.417]                 }
[10:33:16.417]                 NAMES <- toupper(removed)
[10:33:16.417]                 for (kk in seq_along(NAMES)) {
[10:33:16.417]                   name <- removed[[kk]]
[10:33:16.417]                   NAME <- NAMES[[kk]]
[10:33:16.417]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.417]                     next
[10:33:16.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:16.417]                 }
[10:33:16.417]                 if (length(args) > 0) 
[10:33:16.417]                   base::do.call(base::Sys.setenv, args = args)
[10:33:16.417]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:16.417]             }
[10:33:16.417]             else {
[10:33:16.417]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:16.417]             }
[10:33:16.417]             {
[10:33:16.417]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:16.417]                   0L) {
[10:33:16.417]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:16.417]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:16.417]                   base::options(opts)
[10:33:16.417]                 }
[10:33:16.417]                 {
[10:33:16.417]                   {
[10:33:16.417]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:16.417]                     NULL
[10:33:16.417]                   }
[10:33:16.417]                   options(future.plan = NULL)
[10:33:16.417]                   if (is.na(NA_character_)) 
[10:33:16.417]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:16.417]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:16.417]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:16.417]                     .init = FALSE)
[10:33:16.417]                 }
[10:33:16.417]             }
[10:33:16.417]         }
[10:33:16.417]     })
[10:33:16.417]     if (TRUE) {
[10:33:16.417]         base::sink(type = "output", split = FALSE)
[10:33:16.417]         if (TRUE) {
[10:33:16.417]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:16.417]         }
[10:33:16.417]         else {
[10:33:16.417]             ...future.result["stdout"] <- base::list(NULL)
[10:33:16.417]         }
[10:33:16.417]         base::close(...future.stdout)
[10:33:16.417]         ...future.stdout <- NULL
[10:33:16.417]     }
[10:33:16.417]     ...future.result$conditions <- ...future.conditions
[10:33:16.417]     ...future.result$finished <- base::Sys.time()
[10:33:16.417]     ...future.result
[10:33:16.417] }
[10:33:16.419] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[10:33:16.421] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[10:33:16.473] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[10:33:16.473] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[10:33:16.474] MultisessionFuture started
[10:33:16.474] - Launch lazy future ... done
[10:33:16.474] run() for ‘MultisessionFuture’ ... done
[10:33:16.474] result() for ClusterFuture ...
[10:33:16.474] receiveMessageFromWorker() for ClusterFuture ...
[10:33:16.474] - Validating connection of MultisessionFuture
[10:33:16.519] - received message: FutureResult
[10:33:16.519] - Received FutureResult
[10:33:16.519] - Erased future from FutureRegistry
[10:33:16.519] result() for ClusterFuture ...
[10:33:16.519] - result already collected: FutureResult
[10:33:16.519] result() for ClusterFuture ... done
[10:33:16.519] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:16.520] result() for ClusterFuture ... done
[10:33:16.520] result() for ClusterFuture ...
[10:33:16.520] - result already collected: FutureResult
[10:33:16.520] result() for ClusterFuture ... done
value(b) = 2
[10:33:16.520] result() for ClusterFuture ...
[10:33:16.520] - result already collected: FutureResult
[10:33:16.520] result() for ClusterFuture ... done
[10:33:16.520] result() for ClusterFuture ...
[10:33:16.520] - result already collected: FutureResult
[10:33:16.520] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:16.521] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:16.521] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:16.521] 
[10:33:16.521] Searching for globals ... DONE
[10:33:16.522] - globals: [0] <none>
[10:33:16.522] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:16.522] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:16.522] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:16.523] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:33:16.523] Searching for globals ... DONE
[10:33:16.523] Resolving globals: TRUE
[10:33:16.523] Resolving any globals that are futures ...
[10:33:16.523] - globals: [3] ‘+’, ‘value’, ‘a’
[10:33:16.523] Resolving any globals that are futures ... DONE
[10:33:16.524] Resolving futures part of globals (recursively) ...
[10:33:16.524] resolve() on list ...
[10:33:16.524]  recursive: 99
[10:33:16.524]  length: 1
[10:33:16.524]  elements: ‘a’
[10:33:16.524] run() for ‘Future’ ...
[10:33:16.524] - state: ‘created’
[10:33:16.524] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:16.538] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:16.538] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:16.538]   - Field: ‘node’
[10:33:16.538]   - Field: ‘label’
[10:33:16.539]   - Field: ‘local’
[10:33:16.539]   - Field: ‘owner’
[10:33:16.539]   - Field: ‘envir’
[10:33:16.539]   - Field: ‘workers’
[10:33:16.539]   - Field: ‘packages’
[10:33:16.539]   - Field: ‘gc’
[10:33:16.539]   - Field: ‘conditions’
[10:33:16.539]   - Field: ‘persistent’
[10:33:16.539]   - Field: ‘expr’
[10:33:16.539]   - Field: ‘uuid’
[10:33:16.539]   - Field: ‘seed’
[10:33:16.539]   - Field: ‘version’
[10:33:16.540]   - Field: ‘result’
[10:33:16.540]   - Field: ‘asynchronous’
[10:33:16.540]   - Field: ‘calls’
[10:33:16.540]   - Field: ‘globals’
[10:33:16.540]   - Field: ‘stdout’
[10:33:16.540]   - Field: ‘earlySignal’
[10:33:16.540]   - Field: ‘lazy’
[10:33:16.540]   - Field: ‘state’
[10:33:16.540] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:16.540] - Launch lazy future ...
[10:33:16.541] Packages needed by the future expression (n = 0): <none>
[10:33:16.541] Packages needed by future strategies (n = 0): <none>
[10:33:16.541] {
[10:33:16.541]     {
[10:33:16.541]         {
[10:33:16.541]             ...future.startTime <- base::Sys.time()
[10:33:16.541]             {
[10:33:16.541]                 {
[10:33:16.541]                   {
[10:33:16.541]                     {
[10:33:16.541]                       base::local({
[10:33:16.541]                         has_future <- base::requireNamespace("future", 
[10:33:16.541]                           quietly = TRUE)
[10:33:16.541]                         if (has_future) {
[10:33:16.541]                           ns <- base::getNamespace("future")
[10:33:16.541]                           version <- ns[[".package"]][["version"]]
[10:33:16.541]                           if (is.null(version)) 
[10:33:16.541]                             version <- utils::packageVersion("future")
[10:33:16.541]                         }
[10:33:16.541]                         else {
[10:33:16.541]                           version <- NULL
[10:33:16.541]                         }
[10:33:16.541]                         if (!has_future || version < "1.8.0") {
[10:33:16.541]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:16.541]                             "", base::R.version$version.string), 
[10:33:16.541]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:16.541]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:16.541]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:16.541]                               "release", "version")], collapse = " "), 
[10:33:16.541]                             hostname = base::Sys.info()[["nodename"]])
[10:33:16.541]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:16.541]                             info)
[10:33:16.541]                           info <- base::paste(info, collapse = "; ")
[10:33:16.541]                           if (!has_future) {
[10:33:16.541]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:16.541]                               info)
[10:33:16.541]                           }
[10:33:16.541]                           else {
[10:33:16.541]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:16.541]                               info, version)
[10:33:16.541]                           }
[10:33:16.541]                           base::stop(msg)
[10:33:16.541]                         }
[10:33:16.541]                       })
[10:33:16.541]                     }
[10:33:16.541]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:16.541]                     base::options(mc.cores = 1L)
[10:33:16.541]                   }
[10:33:16.541]                   ...future.strategy.old <- future::plan("list")
[10:33:16.541]                   options(future.plan = NULL)
[10:33:16.541]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:16.541]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:16.541]                 }
[10:33:16.541]                 ...future.workdir <- getwd()
[10:33:16.541]             }
[10:33:16.541]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:16.541]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:16.541]         }
[10:33:16.541]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:16.541]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:16.541]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:16.541]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:16.541]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:16.541]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:16.541]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:16.541]             base::names(...future.oldOptions))
[10:33:16.541]     }
[10:33:16.541]     if (FALSE) {
[10:33:16.541]     }
[10:33:16.541]     else {
[10:33:16.541]         if (TRUE) {
[10:33:16.541]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:16.541]                 open = "w")
[10:33:16.541]         }
[10:33:16.541]         else {
[10:33:16.541]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:16.541]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:16.541]         }
[10:33:16.541]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:16.541]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:16.541]             base::sink(type = "output", split = FALSE)
[10:33:16.541]             base::close(...future.stdout)
[10:33:16.541]         }, add = TRUE)
[10:33:16.541]     }
[10:33:16.541]     ...future.frame <- base::sys.nframe()
[10:33:16.541]     ...future.conditions <- base::list()
[10:33:16.541]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:16.541]     if (FALSE) {
[10:33:16.541]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:16.541]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:16.541]     }
[10:33:16.541]     ...future.result <- base::tryCatch({
[10:33:16.541]         base::withCallingHandlers({
[10:33:16.541]             ...future.value <- base::withVisible(base::local({
[10:33:16.541]                 ...future.makeSendCondition <- base::local({
[10:33:16.541]                   sendCondition <- NULL
[10:33:16.541]                   function(frame = 1L) {
[10:33:16.541]                     if (is.function(sendCondition)) 
[10:33:16.541]                       return(sendCondition)
[10:33:16.541]                     ns <- getNamespace("parallel")
[10:33:16.541]                     if (exists("sendData", mode = "function", 
[10:33:16.541]                       envir = ns)) {
[10:33:16.541]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:16.541]                         envir = ns)
[10:33:16.541]                       envir <- sys.frame(frame)
[10:33:16.541]                       master <- NULL
[10:33:16.541]                       while (!identical(envir, .GlobalEnv) && 
[10:33:16.541]                         !identical(envir, emptyenv())) {
[10:33:16.541]                         if (exists("master", mode = "list", envir = envir, 
[10:33:16.541]                           inherits = FALSE)) {
[10:33:16.541]                           master <- get("master", mode = "list", 
[10:33:16.541]                             envir = envir, inherits = FALSE)
[10:33:16.541]                           if (inherits(master, c("SOCKnode", 
[10:33:16.541]                             "SOCK0node"))) {
[10:33:16.541]                             sendCondition <<- function(cond) {
[10:33:16.541]                               data <- list(type = "VALUE", value = cond, 
[10:33:16.541]                                 success = TRUE)
[10:33:16.541]                               parallel_sendData(master, data)
[10:33:16.541]                             }
[10:33:16.541]                             return(sendCondition)
[10:33:16.541]                           }
[10:33:16.541]                         }
[10:33:16.541]                         frame <- frame + 1L
[10:33:16.541]                         envir <- sys.frame(frame)
[10:33:16.541]                       }
[10:33:16.541]                     }
[10:33:16.541]                     sendCondition <<- function(cond) NULL
[10:33:16.541]                   }
[10:33:16.541]                 })
[10:33:16.541]                 withCallingHandlers({
[10:33:16.541]                   1
[10:33:16.541]                 }, immediateCondition = function(cond) {
[10:33:16.541]                   sendCondition <- ...future.makeSendCondition()
[10:33:16.541]                   sendCondition(cond)
[10:33:16.541]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.541]                   {
[10:33:16.541]                     inherits <- base::inherits
[10:33:16.541]                     invokeRestart <- base::invokeRestart
[10:33:16.541]                     is.null <- base::is.null
[10:33:16.541]                     muffled <- FALSE
[10:33:16.541]                     if (inherits(cond, "message")) {
[10:33:16.541]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:16.541]                       if (muffled) 
[10:33:16.541]                         invokeRestart("muffleMessage")
[10:33:16.541]                     }
[10:33:16.541]                     else if (inherits(cond, "warning")) {
[10:33:16.541]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:16.541]                       if (muffled) 
[10:33:16.541]                         invokeRestart("muffleWarning")
[10:33:16.541]                     }
[10:33:16.541]                     else if (inherits(cond, "condition")) {
[10:33:16.541]                       if (!is.null(pattern)) {
[10:33:16.541]                         computeRestarts <- base::computeRestarts
[10:33:16.541]                         grepl <- base::grepl
[10:33:16.541]                         restarts <- computeRestarts(cond)
[10:33:16.541]                         for (restart in restarts) {
[10:33:16.541]                           name <- restart$name
[10:33:16.541]                           if (is.null(name)) 
[10:33:16.541]                             next
[10:33:16.541]                           if (!grepl(pattern, name)) 
[10:33:16.541]                             next
[10:33:16.541]                           invokeRestart(restart)
[10:33:16.541]                           muffled <- TRUE
[10:33:16.541]                           break
[10:33:16.541]                         }
[10:33:16.541]                       }
[10:33:16.541]                     }
[10:33:16.541]                     invisible(muffled)
[10:33:16.541]                   }
[10:33:16.541]                   muffleCondition(cond)
[10:33:16.541]                 })
[10:33:16.541]             }))
[10:33:16.541]             future::FutureResult(value = ...future.value$value, 
[10:33:16.541]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:16.541]                   ...future.rng), globalenv = if (FALSE) 
[10:33:16.541]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:16.541]                     ...future.globalenv.names))
[10:33:16.541]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:16.541]         }, condition = base::local({
[10:33:16.541]             c <- base::c
[10:33:16.541]             inherits <- base::inherits
[10:33:16.541]             invokeRestart <- base::invokeRestart
[10:33:16.541]             length <- base::length
[10:33:16.541]             list <- base::list
[10:33:16.541]             seq.int <- base::seq.int
[10:33:16.541]             signalCondition <- base::signalCondition
[10:33:16.541]             sys.calls <- base::sys.calls
[10:33:16.541]             `[[` <- base::`[[`
[10:33:16.541]             `+` <- base::`+`
[10:33:16.541]             `<<-` <- base::`<<-`
[10:33:16.541]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:16.541]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:16.541]                   3L)]
[10:33:16.541]             }
[10:33:16.541]             function(cond) {
[10:33:16.541]                 is_error <- inherits(cond, "error")
[10:33:16.541]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:16.541]                   NULL)
[10:33:16.541]                 if (is_error) {
[10:33:16.541]                   sessionInformation <- function() {
[10:33:16.541]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:16.541]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:16.541]                       search = base::search(), system = base::Sys.info())
[10:33:16.541]                   }
[10:33:16.541]                   ...future.conditions[[length(...future.conditions) + 
[10:33:16.541]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:16.541]                     cond$call), session = sessionInformation(), 
[10:33:16.541]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:16.541]                   signalCondition(cond)
[10:33:16.541]                 }
[10:33:16.541]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:16.541]                 "immediateCondition"))) {
[10:33:16.541]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:16.541]                   ...future.conditions[[length(...future.conditions) + 
[10:33:16.541]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:16.541]                   if (TRUE && !signal) {
[10:33:16.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.541]                     {
[10:33:16.541]                       inherits <- base::inherits
[10:33:16.541]                       invokeRestart <- base::invokeRestart
[10:33:16.541]                       is.null <- base::is.null
[10:33:16.541]                       muffled <- FALSE
[10:33:16.541]                       if (inherits(cond, "message")) {
[10:33:16.541]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:16.541]                         if (muffled) 
[10:33:16.541]                           invokeRestart("muffleMessage")
[10:33:16.541]                       }
[10:33:16.541]                       else if (inherits(cond, "warning")) {
[10:33:16.541]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:16.541]                         if (muffled) 
[10:33:16.541]                           invokeRestart("muffleWarning")
[10:33:16.541]                       }
[10:33:16.541]                       else if (inherits(cond, "condition")) {
[10:33:16.541]                         if (!is.null(pattern)) {
[10:33:16.541]                           computeRestarts <- base::computeRestarts
[10:33:16.541]                           grepl <- base::grepl
[10:33:16.541]                           restarts <- computeRestarts(cond)
[10:33:16.541]                           for (restart in restarts) {
[10:33:16.541]                             name <- restart$name
[10:33:16.541]                             if (is.null(name)) 
[10:33:16.541]                               next
[10:33:16.541]                             if (!grepl(pattern, name)) 
[10:33:16.541]                               next
[10:33:16.541]                             invokeRestart(restart)
[10:33:16.541]                             muffled <- TRUE
[10:33:16.541]                             break
[10:33:16.541]                           }
[10:33:16.541]                         }
[10:33:16.541]                       }
[10:33:16.541]                       invisible(muffled)
[10:33:16.541]                     }
[10:33:16.541]                     muffleCondition(cond, pattern = "^muffle")
[10:33:16.541]                   }
[10:33:16.541]                 }
[10:33:16.541]                 else {
[10:33:16.541]                   if (TRUE) {
[10:33:16.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.541]                     {
[10:33:16.541]                       inherits <- base::inherits
[10:33:16.541]                       invokeRestart <- base::invokeRestart
[10:33:16.541]                       is.null <- base::is.null
[10:33:16.541]                       muffled <- FALSE
[10:33:16.541]                       if (inherits(cond, "message")) {
[10:33:16.541]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:16.541]                         if (muffled) 
[10:33:16.541]                           invokeRestart("muffleMessage")
[10:33:16.541]                       }
[10:33:16.541]                       else if (inherits(cond, "warning")) {
[10:33:16.541]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:16.541]                         if (muffled) 
[10:33:16.541]                           invokeRestart("muffleWarning")
[10:33:16.541]                       }
[10:33:16.541]                       else if (inherits(cond, "condition")) {
[10:33:16.541]                         if (!is.null(pattern)) {
[10:33:16.541]                           computeRestarts <- base::computeRestarts
[10:33:16.541]                           grepl <- base::grepl
[10:33:16.541]                           restarts <- computeRestarts(cond)
[10:33:16.541]                           for (restart in restarts) {
[10:33:16.541]                             name <- restart$name
[10:33:16.541]                             if (is.null(name)) 
[10:33:16.541]                               next
[10:33:16.541]                             if (!grepl(pattern, name)) 
[10:33:16.541]                               next
[10:33:16.541]                             invokeRestart(restart)
[10:33:16.541]                             muffled <- TRUE
[10:33:16.541]                             break
[10:33:16.541]                           }
[10:33:16.541]                         }
[10:33:16.541]                       }
[10:33:16.541]                       invisible(muffled)
[10:33:16.541]                     }
[10:33:16.541]                     muffleCondition(cond, pattern = "^muffle")
[10:33:16.541]                   }
[10:33:16.541]                 }
[10:33:16.541]             }
[10:33:16.541]         }))
[10:33:16.541]     }, error = function(ex) {
[10:33:16.541]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:16.541]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:16.541]                 ...future.rng), started = ...future.startTime, 
[10:33:16.541]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:16.541]             version = "1.8"), class = "FutureResult")
[10:33:16.541]     }, finally = {
[10:33:16.541]         if (!identical(...future.workdir, getwd())) 
[10:33:16.541]             setwd(...future.workdir)
[10:33:16.541]         {
[10:33:16.541]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:16.541]                 ...future.oldOptions$nwarnings <- NULL
[10:33:16.541]             }
[10:33:16.541]             base::options(...future.oldOptions)
[10:33:16.541]             if (.Platform$OS.type == "windows") {
[10:33:16.541]                 old_names <- names(...future.oldEnvVars)
[10:33:16.541]                 envs <- base::Sys.getenv()
[10:33:16.541]                 names <- names(envs)
[10:33:16.541]                 common <- intersect(names, old_names)
[10:33:16.541]                 added <- setdiff(names, old_names)
[10:33:16.541]                 removed <- setdiff(old_names, names)
[10:33:16.541]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:16.541]                   envs[common]]
[10:33:16.541]                 NAMES <- toupper(changed)
[10:33:16.541]                 args <- list()
[10:33:16.541]                 for (kk in seq_along(NAMES)) {
[10:33:16.541]                   name <- changed[[kk]]
[10:33:16.541]                   NAME <- NAMES[[kk]]
[10:33:16.541]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.541]                     next
[10:33:16.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:16.541]                 }
[10:33:16.541]                 NAMES <- toupper(added)
[10:33:16.541]                 for (kk in seq_along(NAMES)) {
[10:33:16.541]                   name <- added[[kk]]
[10:33:16.541]                   NAME <- NAMES[[kk]]
[10:33:16.541]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.541]                     next
[10:33:16.541]                   args[[name]] <- ""
[10:33:16.541]                 }
[10:33:16.541]                 NAMES <- toupper(removed)
[10:33:16.541]                 for (kk in seq_along(NAMES)) {
[10:33:16.541]                   name <- removed[[kk]]
[10:33:16.541]                   NAME <- NAMES[[kk]]
[10:33:16.541]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.541]                     next
[10:33:16.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:16.541]                 }
[10:33:16.541]                 if (length(args) > 0) 
[10:33:16.541]                   base::do.call(base::Sys.setenv, args = args)
[10:33:16.541]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:16.541]             }
[10:33:16.541]             else {
[10:33:16.541]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:16.541]             }
[10:33:16.541]             {
[10:33:16.541]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:16.541]                   0L) {
[10:33:16.541]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:16.541]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:16.541]                   base::options(opts)
[10:33:16.541]                 }
[10:33:16.541]                 {
[10:33:16.541]                   {
[10:33:16.541]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:16.541]                     NULL
[10:33:16.541]                   }
[10:33:16.541]                   options(future.plan = NULL)
[10:33:16.541]                   if (is.na(NA_character_)) 
[10:33:16.541]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:16.541]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:16.541]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:16.541]                     .init = FALSE)
[10:33:16.541]                 }
[10:33:16.541]             }
[10:33:16.541]         }
[10:33:16.541]     })
[10:33:16.541]     if (TRUE) {
[10:33:16.541]         base::sink(type = "output", split = FALSE)
[10:33:16.541]         if (TRUE) {
[10:33:16.541]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:16.541]         }
[10:33:16.541]         else {
[10:33:16.541]             ...future.result["stdout"] <- base::list(NULL)
[10:33:16.541]         }
[10:33:16.541]         base::close(...future.stdout)
[10:33:16.541]         ...future.stdout <- NULL
[10:33:16.541]     }
[10:33:16.541]     ...future.result$conditions <- ...future.conditions
[10:33:16.541]     ...future.result$finished <- base::Sys.time()
[10:33:16.541]     ...future.result
[10:33:16.541] }
[10:33:16.544] MultisessionFuture started
[10:33:16.544] - Launch lazy future ... done
[10:33:16.544] run() for ‘MultisessionFuture’ ... done
[10:33:16.586] receiveMessageFromWorker() for ClusterFuture ...
[10:33:16.587] - Validating connection of MultisessionFuture
[10:33:16.587] - received message: FutureResult
[10:33:16.587] - Received FutureResult
[10:33:16.587] - Erased future from FutureRegistry
[10:33:16.587] result() for ClusterFuture ...
[10:33:16.587] - result already collected: FutureResult
[10:33:16.587] result() for ClusterFuture ... done
[10:33:16.587] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:16.587] Future #1
[10:33:16.587] result() for ClusterFuture ...
[10:33:16.587] - result already collected: FutureResult
[10:33:16.588] result() for ClusterFuture ... done
[10:33:16.588] result() for ClusterFuture ...
[10:33:16.588] - result already collected: FutureResult
[10:33:16.588] result() for ClusterFuture ... done
[10:33:16.588] A MultisessionFuture was resolved
[10:33:16.588]  length: 0 (resolved future 1)
[10:33:16.588] resolve() on list ... DONE
[10:33:16.588] - globals: [1] ‘a’
[10:33:16.588] Resolving futures part of globals (recursively) ... DONE
[10:33:16.590] The total size of the 1 globals is 1.57 MiB (1646896 bytes)
[10:33:16.591] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[10:33:16.591] - globals: [1] ‘a’
[10:33:16.591] - packages: [1] ‘future’
[10:33:16.591] getGlobalsAndPackages() ... DONE
[10:33:16.591] run() for ‘Future’ ...
[10:33:16.591] - state: ‘created’
[10:33:16.591] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:16.605] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:16.605] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:16.605]   - Field: ‘node’
[10:33:16.605]   - Field: ‘label’
[10:33:16.606]   - Field: ‘local’
[10:33:16.606]   - Field: ‘owner’
[10:33:16.606]   - Field: ‘envir’
[10:33:16.606]   - Field: ‘workers’
[10:33:16.606]   - Field: ‘packages’
[10:33:16.606]   - Field: ‘gc’
[10:33:16.606]   - Field: ‘conditions’
[10:33:16.606]   - Field: ‘persistent’
[10:33:16.606]   - Field: ‘expr’
[10:33:16.606]   - Field: ‘uuid’
[10:33:16.606]   - Field: ‘seed’
[10:33:16.607]   - Field: ‘version’
[10:33:16.607]   - Field: ‘result’
[10:33:16.607]   - Field: ‘asynchronous’
[10:33:16.607]   - Field: ‘calls’
[10:33:16.607]   - Field: ‘globals’
[10:33:16.607]   - Field: ‘stdout’
[10:33:16.607]   - Field: ‘earlySignal’
[10:33:16.607]   - Field: ‘lazy’
[10:33:16.613]   - Field: ‘state’
[10:33:16.613] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:16.613] - Launch lazy future ...
[10:33:16.613] Packages needed by the future expression (n = 1): ‘future’
[10:33:16.613] Packages needed by future strategies (n = 0): <none>
[10:33:16.614] {
[10:33:16.614]     {
[10:33:16.614]         {
[10:33:16.614]             ...future.startTime <- base::Sys.time()
[10:33:16.614]             {
[10:33:16.614]                 {
[10:33:16.614]                   {
[10:33:16.614]                     {
[10:33:16.614]                       {
[10:33:16.614]                         base::local({
[10:33:16.614]                           has_future <- base::requireNamespace("future", 
[10:33:16.614]                             quietly = TRUE)
[10:33:16.614]                           if (has_future) {
[10:33:16.614]                             ns <- base::getNamespace("future")
[10:33:16.614]                             version <- ns[[".package"]][["version"]]
[10:33:16.614]                             if (is.null(version)) 
[10:33:16.614]                               version <- utils::packageVersion("future")
[10:33:16.614]                           }
[10:33:16.614]                           else {
[10:33:16.614]                             version <- NULL
[10:33:16.614]                           }
[10:33:16.614]                           if (!has_future || version < "1.8.0") {
[10:33:16.614]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:16.614]                               "", base::R.version$version.string), 
[10:33:16.614]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:16.614]                                 base::R.version$platform, 8 * 
[10:33:16.614]                                   base::.Machine$sizeof.pointer), 
[10:33:16.614]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:16.614]                                 "release", "version")], collapse = " "), 
[10:33:16.614]                               hostname = base::Sys.info()[["nodename"]])
[10:33:16.614]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:16.614]                               info)
[10:33:16.614]                             info <- base::paste(info, collapse = "; ")
[10:33:16.614]                             if (!has_future) {
[10:33:16.614]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:16.614]                                 info)
[10:33:16.614]                             }
[10:33:16.614]                             else {
[10:33:16.614]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:16.614]                                 info, version)
[10:33:16.614]                             }
[10:33:16.614]                             base::stop(msg)
[10:33:16.614]                           }
[10:33:16.614]                         })
[10:33:16.614]                       }
[10:33:16.614]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:16.614]                       base::options(mc.cores = 1L)
[10:33:16.614]                     }
[10:33:16.614]                     base::local({
[10:33:16.614]                       for (pkg in "future") {
[10:33:16.614]                         base::loadNamespace(pkg)
[10:33:16.614]                         base::library(pkg, character.only = TRUE)
[10:33:16.614]                       }
[10:33:16.614]                     })
[10:33:16.614]                   }
[10:33:16.614]                   ...future.strategy.old <- future::plan("list")
[10:33:16.614]                   options(future.plan = NULL)
[10:33:16.614]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:16.614]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:16.614]                 }
[10:33:16.614]                 ...future.workdir <- getwd()
[10:33:16.614]             }
[10:33:16.614]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:16.614]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:16.614]         }
[10:33:16.614]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:16.614]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:16.614]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:16.614]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:16.614]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:16.614]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:16.614]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:16.614]             base::names(...future.oldOptions))
[10:33:16.614]     }
[10:33:16.614]     if (FALSE) {
[10:33:16.614]     }
[10:33:16.614]     else {
[10:33:16.614]         if (TRUE) {
[10:33:16.614]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:16.614]                 open = "w")
[10:33:16.614]         }
[10:33:16.614]         else {
[10:33:16.614]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:16.614]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:16.614]         }
[10:33:16.614]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:16.614]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:16.614]             base::sink(type = "output", split = FALSE)
[10:33:16.614]             base::close(...future.stdout)
[10:33:16.614]         }, add = TRUE)
[10:33:16.614]     }
[10:33:16.614]     ...future.frame <- base::sys.nframe()
[10:33:16.614]     ...future.conditions <- base::list()
[10:33:16.614]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:16.614]     if (FALSE) {
[10:33:16.614]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:16.614]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:16.614]     }
[10:33:16.614]     ...future.result <- base::tryCatch({
[10:33:16.614]         base::withCallingHandlers({
[10:33:16.614]             ...future.value <- base::withVisible(base::local({
[10:33:16.614]                 ...future.makeSendCondition <- base::local({
[10:33:16.614]                   sendCondition <- NULL
[10:33:16.614]                   function(frame = 1L) {
[10:33:16.614]                     if (is.function(sendCondition)) 
[10:33:16.614]                       return(sendCondition)
[10:33:16.614]                     ns <- getNamespace("parallel")
[10:33:16.614]                     if (exists("sendData", mode = "function", 
[10:33:16.614]                       envir = ns)) {
[10:33:16.614]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:16.614]                         envir = ns)
[10:33:16.614]                       envir <- sys.frame(frame)
[10:33:16.614]                       master <- NULL
[10:33:16.614]                       while (!identical(envir, .GlobalEnv) && 
[10:33:16.614]                         !identical(envir, emptyenv())) {
[10:33:16.614]                         if (exists("master", mode = "list", envir = envir, 
[10:33:16.614]                           inherits = FALSE)) {
[10:33:16.614]                           master <- get("master", mode = "list", 
[10:33:16.614]                             envir = envir, inherits = FALSE)
[10:33:16.614]                           if (inherits(master, c("SOCKnode", 
[10:33:16.614]                             "SOCK0node"))) {
[10:33:16.614]                             sendCondition <<- function(cond) {
[10:33:16.614]                               data <- list(type = "VALUE", value = cond, 
[10:33:16.614]                                 success = TRUE)
[10:33:16.614]                               parallel_sendData(master, data)
[10:33:16.614]                             }
[10:33:16.614]                             return(sendCondition)
[10:33:16.614]                           }
[10:33:16.614]                         }
[10:33:16.614]                         frame <- frame + 1L
[10:33:16.614]                         envir <- sys.frame(frame)
[10:33:16.614]                       }
[10:33:16.614]                     }
[10:33:16.614]                     sendCondition <<- function(cond) NULL
[10:33:16.614]                   }
[10:33:16.614]                 })
[10:33:16.614]                 withCallingHandlers({
[10:33:16.614]                   value(a) + 1
[10:33:16.614]                 }, immediateCondition = function(cond) {
[10:33:16.614]                   sendCondition <- ...future.makeSendCondition()
[10:33:16.614]                   sendCondition(cond)
[10:33:16.614]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.614]                   {
[10:33:16.614]                     inherits <- base::inherits
[10:33:16.614]                     invokeRestart <- base::invokeRestart
[10:33:16.614]                     is.null <- base::is.null
[10:33:16.614]                     muffled <- FALSE
[10:33:16.614]                     if (inherits(cond, "message")) {
[10:33:16.614]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:16.614]                       if (muffled) 
[10:33:16.614]                         invokeRestart("muffleMessage")
[10:33:16.614]                     }
[10:33:16.614]                     else if (inherits(cond, "warning")) {
[10:33:16.614]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:16.614]                       if (muffled) 
[10:33:16.614]                         invokeRestart("muffleWarning")
[10:33:16.614]                     }
[10:33:16.614]                     else if (inherits(cond, "condition")) {
[10:33:16.614]                       if (!is.null(pattern)) {
[10:33:16.614]                         computeRestarts <- base::computeRestarts
[10:33:16.614]                         grepl <- base::grepl
[10:33:16.614]                         restarts <- computeRestarts(cond)
[10:33:16.614]                         for (restart in restarts) {
[10:33:16.614]                           name <- restart$name
[10:33:16.614]                           if (is.null(name)) 
[10:33:16.614]                             next
[10:33:16.614]                           if (!grepl(pattern, name)) 
[10:33:16.614]                             next
[10:33:16.614]                           invokeRestart(restart)
[10:33:16.614]                           muffled <- TRUE
[10:33:16.614]                           break
[10:33:16.614]                         }
[10:33:16.614]                       }
[10:33:16.614]                     }
[10:33:16.614]                     invisible(muffled)
[10:33:16.614]                   }
[10:33:16.614]                   muffleCondition(cond)
[10:33:16.614]                 })
[10:33:16.614]             }))
[10:33:16.614]             future::FutureResult(value = ...future.value$value, 
[10:33:16.614]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:16.614]                   ...future.rng), globalenv = if (FALSE) 
[10:33:16.614]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:16.614]                     ...future.globalenv.names))
[10:33:16.614]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:16.614]         }, condition = base::local({
[10:33:16.614]             c <- base::c
[10:33:16.614]             inherits <- base::inherits
[10:33:16.614]             invokeRestart <- base::invokeRestart
[10:33:16.614]             length <- base::length
[10:33:16.614]             list <- base::list
[10:33:16.614]             seq.int <- base::seq.int
[10:33:16.614]             signalCondition <- base::signalCondition
[10:33:16.614]             sys.calls <- base::sys.calls
[10:33:16.614]             `[[` <- base::`[[`
[10:33:16.614]             `+` <- base::`+`
[10:33:16.614]             `<<-` <- base::`<<-`
[10:33:16.614]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:16.614]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:16.614]                   3L)]
[10:33:16.614]             }
[10:33:16.614]             function(cond) {
[10:33:16.614]                 is_error <- inherits(cond, "error")
[10:33:16.614]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:16.614]                   NULL)
[10:33:16.614]                 if (is_error) {
[10:33:16.614]                   sessionInformation <- function() {
[10:33:16.614]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:16.614]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:16.614]                       search = base::search(), system = base::Sys.info())
[10:33:16.614]                   }
[10:33:16.614]                   ...future.conditions[[length(...future.conditions) + 
[10:33:16.614]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:16.614]                     cond$call), session = sessionInformation(), 
[10:33:16.614]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:16.614]                   signalCondition(cond)
[10:33:16.614]                 }
[10:33:16.614]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:16.614]                 "immediateCondition"))) {
[10:33:16.614]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:16.614]                   ...future.conditions[[length(...future.conditions) + 
[10:33:16.614]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:16.614]                   if (TRUE && !signal) {
[10:33:16.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.614]                     {
[10:33:16.614]                       inherits <- base::inherits
[10:33:16.614]                       invokeRestart <- base::invokeRestart
[10:33:16.614]                       is.null <- base::is.null
[10:33:16.614]                       muffled <- FALSE
[10:33:16.614]                       if (inherits(cond, "message")) {
[10:33:16.614]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:16.614]                         if (muffled) 
[10:33:16.614]                           invokeRestart("muffleMessage")
[10:33:16.614]                       }
[10:33:16.614]                       else if (inherits(cond, "warning")) {
[10:33:16.614]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:16.614]                         if (muffled) 
[10:33:16.614]                           invokeRestart("muffleWarning")
[10:33:16.614]                       }
[10:33:16.614]                       else if (inherits(cond, "condition")) {
[10:33:16.614]                         if (!is.null(pattern)) {
[10:33:16.614]                           computeRestarts <- base::computeRestarts
[10:33:16.614]                           grepl <- base::grepl
[10:33:16.614]                           restarts <- computeRestarts(cond)
[10:33:16.614]                           for (restart in restarts) {
[10:33:16.614]                             name <- restart$name
[10:33:16.614]                             if (is.null(name)) 
[10:33:16.614]                               next
[10:33:16.614]                             if (!grepl(pattern, name)) 
[10:33:16.614]                               next
[10:33:16.614]                             invokeRestart(restart)
[10:33:16.614]                             muffled <- TRUE
[10:33:16.614]                             break
[10:33:16.614]                           }
[10:33:16.614]                         }
[10:33:16.614]                       }
[10:33:16.614]                       invisible(muffled)
[10:33:16.614]                     }
[10:33:16.614]                     muffleCondition(cond, pattern = "^muffle")
[10:33:16.614]                   }
[10:33:16.614]                 }
[10:33:16.614]                 else {
[10:33:16.614]                   if (TRUE) {
[10:33:16.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.614]                     {
[10:33:16.614]                       inherits <- base::inherits
[10:33:16.614]                       invokeRestart <- base::invokeRestart
[10:33:16.614]                       is.null <- base::is.null
[10:33:16.614]                       muffled <- FALSE
[10:33:16.614]                       if (inherits(cond, "message")) {
[10:33:16.614]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:16.614]                         if (muffled) 
[10:33:16.614]                           invokeRestart("muffleMessage")
[10:33:16.614]                       }
[10:33:16.614]                       else if (inherits(cond, "warning")) {
[10:33:16.614]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:16.614]                         if (muffled) 
[10:33:16.614]                           invokeRestart("muffleWarning")
[10:33:16.614]                       }
[10:33:16.614]                       else if (inherits(cond, "condition")) {
[10:33:16.614]                         if (!is.null(pattern)) {
[10:33:16.614]                           computeRestarts <- base::computeRestarts
[10:33:16.614]                           grepl <- base::grepl
[10:33:16.614]                           restarts <- computeRestarts(cond)
[10:33:16.614]                           for (restart in restarts) {
[10:33:16.614]                             name <- restart$name
[10:33:16.614]                             if (is.null(name)) 
[10:33:16.614]                               next
[10:33:16.614]                             if (!grepl(pattern, name)) 
[10:33:16.614]                               next
[10:33:16.614]                             invokeRestart(restart)
[10:33:16.614]                             muffled <- TRUE
[10:33:16.614]                             break
[10:33:16.614]                           }
[10:33:16.614]                         }
[10:33:16.614]                       }
[10:33:16.614]                       invisible(muffled)
[10:33:16.614]                     }
[10:33:16.614]                     muffleCondition(cond, pattern = "^muffle")
[10:33:16.614]                   }
[10:33:16.614]                 }
[10:33:16.614]             }
[10:33:16.614]         }))
[10:33:16.614]     }, error = function(ex) {
[10:33:16.614]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:16.614]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:16.614]                 ...future.rng), started = ...future.startTime, 
[10:33:16.614]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:16.614]             version = "1.8"), class = "FutureResult")
[10:33:16.614]     }, finally = {
[10:33:16.614]         if (!identical(...future.workdir, getwd())) 
[10:33:16.614]             setwd(...future.workdir)
[10:33:16.614]         {
[10:33:16.614]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:16.614]                 ...future.oldOptions$nwarnings <- NULL
[10:33:16.614]             }
[10:33:16.614]             base::options(...future.oldOptions)
[10:33:16.614]             if (.Platform$OS.type == "windows") {
[10:33:16.614]                 old_names <- names(...future.oldEnvVars)
[10:33:16.614]                 envs <- base::Sys.getenv()
[10:33:16.614]                 names <- names(envs)
[10:33:16.614]                 common <- intersect(names, old_names)
[10:33:16.614]                 added <- setdiff(names, old_names)
[10:33:16.614]                 removed <- setdiff(old_names, names)
[10:33:16.614]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:16.614]                   envs[common]]
[10:33:16.614]                 NAMES <- toupper(changed)
[10:33:16.614]                 args <- list()
[10:33:16.614]                 for (kk in seq_along(NAMES)) {
[10:33:16.614]                   name <- changed[[kk]]
[10:33:16.614]                   NAME <- NAMES[[kk]]
[10:33:16.614]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.614]                     next
[10:33:16.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:16.614]                 }
[10:33:16.614]                 NAMES <- toupper(added)
[10:33:16.614]                 for (kk in seq_along(NAMES)) {
[10:33:16.614]                   name <- added[[kk]]
[10:33:16.614]                   NAME <- NAMES[[kk]]
[10:33:16.614]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.614]                     next
[10:33:16.614]                   args[[name]] <- ""
[10:33:16.614]                 }
[10:33:16.614]                 NAMES <- toupper(removed)
[10:33:16.614]                 for (kk in seq_along(NAMES)) {
[10:33:16.614]                   name <- removed[[kk]]
[10:33:16.614]                   NAME <- NAMES[[kk]]
[10:33:16.614]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.614]                     next
[10:33:16.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:16.614]                 }
[10:33:16.614]                 if (length(args) > 0) 
[10:33:16.614]                   base::do.call(base::Sys.setenv, args = args)
[10:33:16.614]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:16.614]             }
[10:33:16.614]             else {
[10:33:16.614]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:16.614]             }
[10:33:16.614]             {
[10:33:16.614]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:16.614]                   0L) {
[10:33:16.614]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:16.614]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:16.614]                   base::options(opts)
[10:33:16.614]                 }
[10:33:16.614]                 {
[10:33:16.614]                   {
[10:33:16.614]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:16.614]                     NULL
[10:33:16.614]                   }
[10:33:16.614]                   options(future.plan = NULL)
[10:33:16.614]                   if (is.na(NA_character_)) 
[10:33:16.614]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:16.614]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:16.614]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:16.614]                     .init = FALSE)
[10:33:16.614]                 }
[10:33:16.614]             }
[10:33:16.614]         }
[10:33:16.614]     })
[10:33:16.614]     if (TRUE) {
[10:33:16.614]         base::sink(type = "output", split = FALSE)
[10:33:16.614]         if (TRUE) {
[10:33:16.614]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:16.614]         }
[10:33:16.614]         else {
[10:33:16.614]             ...future.result["stdout"] <- base::list(NULL)
[10:33:16.614]         }
[10:33:16.614]         base::close(...future.stdout)
[10:33:16.614]         ...future.stdout <- NULL
[10:33:16.614]     }
[10:33:16.614]     ...future.result$conditions <- ...future.conditions
[10:33:16.614]     ...future.result$finished <- base::Sys.time()
[10:33:16.614]     ...future.result
[10:33:16.614] }
[10:33:16.617] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[10:33:16.619] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[10:33:16.669] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[10:33:16.669] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[10:33:16.670] MultisessionFuture started
[10:33:16.670] - Launch lazy future ... done
[10:33:16.670] run() for ‘MultisessionFuture’ ... done
[10:33:16.670] result() for ClusterFuture ...
[10:33:16.670] receiveMessageFromWorker() for ClusterFuture ...
[10:33:16.670] - Validating connection of MultisessionFuture
[10:33:16.715] - received message: FutureResult
[10:33:16.715] - Received FutureResult
[10:33:16.715] - Erased future from FutureRegistry
[10:33:16.715] result() for ClusterFuture ...
[10:33:16.715] - result already collected: FutureResult
[10:33:16.715] result() for ClusterFuture ... done
[10:33:16.715] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:16.715] result() for ClusterFuture ... done
[10:33:16.716] result() for ClusterFuture ...
[10:33:16.716] - result already collected: FutureResult
[10:33:16.716] result() for ClusterFuture ... done
value(b) = 2
[10:33:16.716] result() for ClusterFuture ...
[10:33:16.716] - result already collected: FutureResult
[10:33:16.716] result() for ClusterFuture ... done
[10:33:16.716] result() for ClusterFuture ...
[10:33:16.716] - result already collected: FutureResult
[10:33:16.716] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:16.717] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:16.717] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:16.718] - globals found: [2] ‘{’, ‘pkg’
[10:33:16.718] Searching for globals ... DONE
[10:33:16.718] Resolving globals: TRUE
[10:33:16.718] Resolving any globals that are futures ...
[10:33:16.718] - globals: [2] ‘{’, ‘pkg’
[10:33:16.718] Resolving any globals that are futures ... DONE
[10:33:16.719] Resolving futures part of globals (recursively) ...
[10:33:16.719] resolve() on list ...
[10:33:16.719]  recursive: 99
[10:33:16.719]  length: 1
[10:33:16.719]  elements: ‘pkg’
[10:33:16.719]  length: 0 (resolved future 1)
[10:33:16.719] resolve() on list ... DONE
[10:33:16.719] - globals: [1] ‘pkg’
[10:33:16.719] Resolving futures part of globals (recursively) ... DONE
[10:33:16.720] The total size of the 1 globals is 112 bytes (112 bytes)
[10:33:16.720] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[10:33:16.720] - globals: [1] ‘pkg’
[10:33:16.720] 
[10:33:16.720] getGlobalsAndPackages() ... DONE
[10:33:16.720] Packages needed by the future expression (n = 0): <none>
[10:33:16.721] Packages needed by future strategies (n = 0): <none>
[10:33:16.721] {
[10:33:16.721]     {
[10:33:16.721]         {
[10:33:16.721]             ...future.startTime <- base::Sys.time()
[10:33:16.721]             {
[10:33:16.721]                 {
[10:33:16.721]                   {
[10:33:16.721]                     base::local({
[10:33:16.721]                       has_future <- base::requireNamespace("future", 
[10:33:16.721]                         quietly = TRUE)
[10:33:16.721]                       if (has_future) {
[10:33:16.721]                         ns <- base::getNamespace("future")
[10:33:16.721]                         version <- ns[[".package"]][["version"]]
[10:33:16.721]                         if (is.null(version)) 
[10:33:16.721]                           version <- utils::packageVersion("future")
[10:33:16.721]                       }
[10:33:16.721]                       else {
[10:33:16.721]                         version <- NULL
[10:33:16.721]                       }
[10:33:16.721]                       if (!has_future || version < "1.8.0") {
[10:33:16.721]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:16.721]                           "", base::R.version$version.string), 
[10:33:16.721]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:16.721]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:16.721]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:16.721]                             "release", "version")], collapse = " "), 
[10:33:16.721]                           hostname = base::Sys.info()[["nodename"]])
[10:33:16.721]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:16.721]                           info)
[10:33:16.721]                         info <- base::paste(info, collapse = "; ")
[10:33:16.721]                         if (!has_future) {
[10:33:16.721]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:16.721]                             info)
[10:33:16.721]                         }
[10:33:16.721]                         else {
[10:33:16.721]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:16.721]                             info, version)
[10:33:16.721]                         }
[10:33:16.721]                         base::stop(msg)
[10:33:16.721]                       }
[10:33:16.721]                     })
[10:33:16.721]                   }
[10:33:16.721]                   ...future.strategy.old <- future::plan("list")
[10:33:16.721]                   options(future.plan = NULL)
[10:33:16.721]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:16.721]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:16.721]                 }
[10:33:16.721]                 ...future.workdir <- getwd()
[10:33:16.721]             }
[10:33:16.721]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:16.721]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:16.721]         }
[10:33:16.721]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:16.721]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:16.721]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:16.721]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:16.721]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:16.721]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:16.721]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:16.721]             base::names(...future.oldOptions))
[10:33:16.721]     }
[10:33:16.721]     if (FALSE) {
[10:33:16.721]     }
[10:33:16.721]     else {
[10:33:16.721]         if (TRUE) {
[10:33:16.721]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:16.721]                 open = "w")
[10:33:16.721]         }
[10:33:16.721]         else {
[10:33:16.721]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:16.721]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:16.721]         }
[10:33:16.721]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:16.721]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:16.721]             base::sink(type = "output", split = FALSE)
[10:33:16.721]             base::close(...future.stdout)
[10:33:16.721]         }, add = TRUE)
[10:33:16.721]     }
[10:33:16.721]     ...future.frame <- base::sys.nframe()
[10:33:16.721]     ...future.conditions <- base::list()
[10:33:16.721]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:16.721]     if (FALSE) {
[10:33:16.721]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:16.721]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:16.721]     }
[10:33:16.721]     ...future.result <- base::tryCatch({
[10:33:16.721]         base::withCallingHandlers({
[10:33:16.721]             ...future.value <- base::withVisible(base::local({
[10:33:16.721]                 pkg
[10:33:16.721]             }))
[10:33:16.721]             future::FutureResult(value = ...future.value$value, 
[10:33:16.721]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:16.721]                   ...future.rng), globalenv = if (FALSE) 
[10:33:16.721]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:16.721]                     ...future.globalenv.names))
[10:33:16.721]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:16.721]         }, condition = base::local({
[10:33:16.721]             c <- base::c
[10:33:16.721]             inherits <- base::inherits
[10:33:16.721]             invokeRestart <- base::invokeRestart
[10:33:16.721]             length <- base::length
[10:33:16.721]             list <- base::list
[10:33:16.721]             seq.int <- base::seq.int
[10:33:16.721]             signalCondition <- base::signalCondition
[10:33:16.721]             sys.calls <- base::sys.calls
[10:33:16.721]             `[[` <- base::`[[`
[10:33:16.721]             `+` <- base::`+`
[10:33:16.721]             `<<-` <- base::`<<-`
[10:33:16.721]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:16.721]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:16.721]                   3L)]
[10:33:16.721]             }
[10:33:16.721]             function(cond) {
[10:33:16.721]                 is_error <- inherits(cond, "error")
[10:33:16.721]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:16.721]                   NULL)
[10:33:16.721]                 if (is_error) {
[10:33:16.721]                   sessionInformation <- function() {
[10:33:16.721]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:16.721]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:16.721]                       search = base::search(), system = base::Sys.info())
[10:33:16.721]                   }
[10:33:16.721]                   ...future.conditions[[length(...future.conditions) + 
[10:33:16.721]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:16.721]                     cond$call), session = sessionInformation(), 
[10:33:16.721]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:16.721]                   signalCondition(cond)
[10:33:16.721]                 }
[10:33:16.721]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:16.721]                 "immediateCondition"))) {
[10:33:16.721]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:16.721]                   ...future.conditions[[length(...future.conditions) + 
[10:33:16.721]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:16.721]                   if (TRUE && !signal) {
[10:33:16.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.721]                     {
[10:33:16.721]                       inherits <- base::inherits
[10:33:16.721]                       invokeRestart <- base::invokeRestart
[10:33:16.721]                       is.null <- base::is.null
[10:33:16.721]                       muffled <- FALSE
[10:33:16.721]                       if (inherits(cond, "message")) {
[10:33:16.721]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:16.721]                         if (muffled) 
[10:33:16.721]                           invokeRestart("muffleMessage")
[10:33:16.721]                       }
[10:33:16.721]                       else if (inherits(cond, "warning")) {
[10:33:16.721]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:16.721]                         if (muffled) 
[10:33:16.721]                           invokeRestart("muffleWarning")
[10:33:16.721]                       }
[10:33:16.721]                       else if (inherits(cond, "condition")) {
[10:33:16.721]                         if (!is.null(pattern)) {
[10:33:16.721]                           computeRestarts <- base::computeRestarts
[10:33:16.721]                           grepl <- base::grepl
[10:33:16.721]                           restarts <- computeRestarts(cond)
[10:33:16.721]                           for (restart in restarts) {
[10:33:16.721]                             name <- restart$name
[10:33:16.721]                             if (is.null(name)) 
[10:33:16.721]                               next
[10:33:16.721]                             if (!grepl(pattern, name)) 
[10:33:16.721]                               next
[10:33:16.721]                             invokeRestart(restart)
[10:33:16.721]                             muffled <- TRUE
[10:33:16.721]                             break
[10:33:16.721]                           }
[10:33:16.721]                         }
[10:33:16.721]                       }
[10:33:16.721]                       invisible(muffled)
[10:33:16.721]                     }
[10:33:16.721]                     muffleCondition(cond, pattern = "^muffle")
[10:33:16.721]                   }
[10:33:16.721]                 }
[10:33:16.721]                 else {
[10:33:16.721]                   if (TRUE) {
[10:33:16.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.721]                     {
[10:33:16.721]                       inherits <- base::inherits
[10:33:16.721]                       invokeRestart <- base::invokeRestart
[10:33:16.721]                       is.null <- base::is.null
[10:33:16.721]                       muffled <- FALSE
[10:33:16.721]                       if (inherits(cond, "message")) {
[10:33:16.721]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:16.721]                         if (muffled) 
[10:33:16.721]                           invokeRestart("muffleMessage")
[10:33:16.721]                       }
[10:33:16.721]                       else if (inherits(cond, "warning")) {
[10:33:16.721]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:16.721]                         if (muffled) 
[10:33:16.721]                           invokeRestart("muffleWarning")
[10:33:16.721]                       }
[10:33:16.721]                       else if (inherits(cond, "condition")) {
[10:33:16.721]                         if (!is.null(pattern)) {
[10:33:16.721]                           computeRestarts <- base::computeRestarts
[10:33:16.721]                           grepl <- base::grepl
[10:33:16.721]                           restarts <- computeRestarts(cond)
[10:33:16.721]                           for (restart in restarts) {
[10:33:16.721]                             name <- restart$name
[10:33:16.721]                             if (is.null(name)) 
[10:33:16.721]                               next
[10:33:16.721]                             if (!grepl(pattern, name)) 
[10:33:16.721]                               next
[10:33:16.721]                             invokeRestart(restart)
[10:33:16.721]                             muffled <- TRUE
[10:33:16.721]                             break
[10:33:16.721]                           }
[10:33:16.721]                         }
[10:33:16.721]                       }
[10:33:16.721]                       invisible(muffled)
[10:33:16.721]                     }
[10:33:16.721]                     muffleCondition(cond, pattern = "^muffle")
[10:33:16.721]                   }
[10:33:16.721]                 }
[10:33:16.721]             }
[10:33:16.721]         }))
[10:33:16.721]     }, error = function(ex) {
[10:33:16.721]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:16.721]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:16.721]                 ...future.rng), started = ...future.startTime, 
[10:33:16.721]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:16.721]             version = "1.8"), class = "FutureResult")
[10:33:16.721]     }, finally = {
[10:33:16.721]         if (!identical(...future.workdir, getwd())) 
[10:33:16.721]             setwd(...future.workdir)
[10:33:16.721]         {
[10:33:16.721]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:16.721]                 ...future.oldOptions$nwarnings <- NULL
[10:33:16.721]             }
[10:33:16.721]             base::options(...future.oldOptions)
[10:33:16.721]             if (.Platform$OS.type == "windows") {
[10:33:16.721]                 old_names <- names(...future.oldEnvVars)
[10:33:16.721]                 envs <- base::Sys.getenv()
[10:33:16.721]                 names <- names(envs)
[10:33:16.721]                 common <- intersect(names, old_names)
[10:33:16.721]                 added <- setdiff(names, old_names)
[10:33:16.721]                 removed <- setdiff(old_names, names)
[10:33:16.721]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:16.721]                   envs[common]]
[10:33:16.721]                 NAMES <- toupper(changed)
[10:33:16.721]                 args <- list()
[10:33:16.721]                 for (kk in seq_along(NAMES)) {
[10:33:16.721]                   name <- changed[[kk]]
[10:33:16.721]                   NAME <- NAMES[[kk]]
[10:33:16.721]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.721]                     next
[10:33:16.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:16.721]                 }
[10:33:16.721]                 NAMES <- toupper(added)
[10:33:16.721]                 for (kk in seq_along(NAMES)) {
[10:33:16.721]                   name <- added[[kk]]
[10:33:16.721]                   NAME <- NAMES[[kk]]
[10:33:16.721]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.721]                     next
[10:33:16.721]                   args[[name]] <- ""
[10:33:16.721]                 }
[10:33:16.721]                 NAMES <- toupper(removed)
[10:33:16.721]                 for (kk in seq_along(NAMES)) {
[10:33:16.721]                   name <- removed[[kk]]
[10:33:16.721]                   NAME <- NAMES[[kk]]
[10:33:16.721]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.721]                     next
[10:33:16.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:16.721]                 }
[10:33:16.721]                 if (length(args) > 0) 
[10:33:16.721]                   base::do.call(base::Sys.setenv, args = args)
[10:33:16.721]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:16.721]             }
[10:33:16.721]             else {
[10:33:16.721]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:16.721]             }
[10:33:16.721]             {
[10:33:16.721]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:16.721]                   0L) {
[10:33:16.721]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:16.721]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:16.721]                   base::options(opts)
[10:33:16.721]                 }
[10:33:16.721]                 {
[10:33:16.721]                   {
[10:33:16.721]                     NULL
[10:33:16.721]                     RNGkind("Mersenne-Twister")
[10:33:16.721]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:16.721]                       inherits = FALSE)
[10:33:16.721]                   }
[10:33:16.721]                   options(future.plan = NULL)
[10:33:16.721]                   if (is.na(NA_character_)) 
[10:33:16.721]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:16.721]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:16.721]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:16.721]                     .init = FALSE)
[10:33:16.721]                 }
[10:33:16.721]             }
[10:33:16.721]         }
[10:33:16.721]     })
[10:33:16.721]     if (TRUE) {
[10:33:16.721]         base::sink(type = "output", split = FALSE)
[10:33:16.721]         if (TRUE) {
[10:33:16.721]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:16.721]         }
[10:33:16.721]         else {
[10:33:16.721]             ...future.result["stdout"] <- base::list(NULL)
[10:33:16.721]         }
[10:33:16.721]         base::close(...future.stdout)
[10:33:16.721]         ...future.stdout <- NULL
[10:33:16.721]     }
[10:33:16.721]     ...future.result$conditions <- ...future.conditions
[10:33:16.721]     ...future.result$finished <- base::Sys.time()
[10:33:16.721]     ...future.result
[10:33:16.721] }
[10:33:16.723] assign_globals() ...
[10:33:16.723] List of 1
[10:33:16.723]  $ pkg: chr "foo"
[10:33:16.723]  - attr(*, "where")=List of 1
[10:33:16.723]   ..$ pkg:<environment: R_EmptyEnv> 
[10:33:16.723]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:16.723]  - attr(*, "resolved")= logi TRUE
[10:33:16.723]  - attr(*, "total_size")= num 112
[10:33:16.725] - copied ‘pkg’ to environment
[10:33:16.725] assign_globals() ... done
[10:33:16.725] plan(): Setting new future strategy stack:
[10:33:16.725] List of future strategies:
[10:33:16.725] 1. sequential:
[10:33:16.725]    - args: function (..., envir = parent.frame())
[10:33:16.725]    - tweaked: FALSE
[10:33:16.725]    - call: NULL
[10:33:16.726] plan(): nbrOfWorkers() = 1
[10:33:16.726] plan(): Setting new future strategy stack:
[10:33:16.726] List of future strategies:
[10:33:16.726] 1. multisession:
[10:33:16.726]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:16.726]    - tweaked: FALSE
[10:33:16.726]    - call: plan(strategy)
[10:33:16.730] plan(): nbrOfWorkers() = 2
[10:33:16.730] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:16.731] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:16.731] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:16.733] - globals found: [3] ‘{’, ‘<-’, ‘+’
[10:33:16.733] Searching for globals ... DONE
[10:33:16.733] Resolving globals: TRUE
[10:33:16.733] Resolving any globals that are futures ...
[10:33:16.733] - globals: [3] ‘{’, ‘<-’, ‘+’
[10:33:16.733] Resolving any globals that are futures ... DONE
[10:33:16.733] 
[10:33:16.733] 
[10:33:16.734] getGlobalsAndPackages() ... DONE
[10:33:16.734] run() for ‘Future’ ...
[10:33:16.734] - state: ‘created’
[10:33:16.734] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:16.749] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:16.749] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:16.749]   - Field: ‘node’
[10:33:16.750]   - Field: ‘label’
[10:33:16.750]   - Field: ‘local’
[10:33:16.750]   - Field: ‘owner’
[10:33:16.750]   - Field: ‘envir’
[10:33:16.750]   - Field: ‘workers’
[10:33:16.750]   - Field: ‘packages’
[10:33:16.750]   - Field: ‘gc’
[10:33:16.750]   - Field: ‘conditions’
[10:33:16.750]   - Field: ‘persistent’
[10:33:16.750]   - Field: ‘expr’
[10:33:16.750]   - Field: ‘uuid’
[10:33:16.751]   - Field: ‘seed’
[10:33:16.751]   - Field: ‘version’
[10:33:16.751]   - Field: ‘result’
[10:33:16.751]   - Field: ‘asynchronous’
[10:33:16.751]   - Field: ‘calls’
[10:33:16.751]   - Field: ‘globals’
[10:33:16.751]   - Field: ‘stdout’
[10:33:16.751]   - Field: ‘earlySignal’
[10:33:16.751]   - Field: ‘lazy’
[10:33:16.751]   - Field: ‘state’
[10:33:16.751] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:16.752] - Launch lazy future ...
[10:33:16.752] Packages needed by the future expression (n = 0): <none>
[10:33:16.752] Packages needed by future strategies (n = 0): <none>
[10:33:16.752] {
[10:33:16.752]     {
[10:33:16.752]         {
[10:33:16.752]             ...future.startTime <- base::Sys.time()
[10:33:16.752]             {
[10:33:16.752]                 {
[10:33:16.752]                   {
[10:33:16.752]                     {
[10:33:16.752]                       base::local({
[10:33:16.752]                         has_future <- base::requireNamespace("future", 
[10:33:16.752]                           quietly = TRUE)
[10:33:16.752]                         if (has_future) {
[10:33:16.752]                           ns <- base::getNamespace("future")
[10:33:16.752]                           version <- ns[[".package"]][["version"]]
[10:33:16.752]                           if (is.null(version)) 
[10:33:16.752]                             version <- utils::packageVersion("future")
[10:33:16.752]                         }
[10:33:16.752]                         else {
[10:33:16.752]                           version <- NULL
[10:33:16.752]                         }
[10:33:16.752]                         if (!has_future || version < "1.8.0") {
[10:33:16.752]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:16.752]                             "", base::R.version$version.string), 
[10:33:16.752]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:16.752]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:16.752]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:16.752]                               "release", "version")], collapse = " "), 
[10:33:16.752]                             hostname = base::Sys.info()[["nodename"]])
[10:33:16.752]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:16.752]                             info)
[10:33:16.752]                           info <- base::paste(info, collapse = "; ")
[10:33:16.752]                           if (!has_future) {
[10:33:16.752]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:16.752]                               info)
[10:33:16.752]                           }
[10:33:16.752]                           else {
[10:33:16.752]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:16.752]                               info, version)
[10:33:16.752]                           }
[10:33:16.752]                           base::stop(msg)
[10:33:16.752]                         }
[10:33:16.752]                       })
[10:33:16.752]                     }
[10:33:16.752]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:16.752]                     base::options(mc.cores = 1L)
[10:33:16.752]                   }
[10:33:16.752]                   ...future.strategy.old <- future::plan("list")
[10:33:16.752]                   options(future.plan = NULL)
[10:33:16.752]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:16.752]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:16.752]                 }
[10:33:16.752]                 ...future.workdir <- getwd()
[10:33:16.752]             }
[10:33:16.752]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:16.752]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:16.752]         }
[10:33:16.752]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:16.752]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:16.752]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:16.752]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:16.752]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:16.752]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:16.752]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:16.752]             base::names(...future.oldOptions))
[10:33:16.752]     }
[10:33:16.752]     if (FALSE) {
[10:33:16.752]     }
[10:33:16.752]     else {
[10:33:16.752]         if (TRUE) {
[10:33:16.752]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:16.752]                 open = "w")
[10:33:16.752]         }
[10:33:16.752]         else {
[10:33:16.752]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:16.752]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:16.752]         }
[10:33:16.752]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:16.752]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:16.752]             base::sink(type = "output", split = FALSE)
[10:33:16.752]             base::close(...future.stdout)
[10:33:16.752]         }, add = TRUE)
[10:33:16.752]     }
[10:33:16.752]     ...future.frame <- base::sys.nframe()
[10:33:16.752]     ...future.conditions <- base::list()
[10:33:16.752]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:16.752]     if (FALSE) {
[10:33:16.752]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:16.752]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:16.752]     }
[10:33:16.752]     ...future.result <- base::tryCatch({
[10:33:16.752]         base::withCallingHandlers({
[10:33:16.752]             ...future.value <- base::withVisible(base::local({
[10:33:16.752]                 ...future.makeSendCondition <- base::local({
[10:33:16.752]                   sendCondition <- NULL
[10:33:16.752]                   function(frame = 1L) {
[10:33:16.752]                     if (is.function(sendCondition)) 
[10:33:16.752]                       return(sendCondition)
[10:33:16.752]                     ns <- getNamespace("parallel")
[10:33:16.752]                     if (exists("sendData", mode = "function", 
[10:33:16.752]                       envir = ns)) {
[10:33:16.752]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:16.752]                         envir = ns)
[10:33:16.752]                       envir <- sys.frame(frame)
[10:33:16.752]                       master <- NULL
[10:33:16.752]                       while (!identical(envir, .GlobalEnv) && 
[10:33:16.752]                         !identical(envir, emptyenv())) {
[10:33:16.752]                         if (exists("master", mode = "list", envir = envir, 
[10:33:16.752]                           inherits = FALSE)) {
[10:33:16.752]                           master <- get("master", mode = "list", 
[10:33:16.752]                             envir = envir, inherits = FALSE)
[10:33:16.752]                           if (inherits(master, c("SOCKnode", 
[10:33:16.752]                             "SOCK0node"))) {
[10:33:16.752]                             sendCondition <<- function(cond) {
[10:33:16.752]                               data <- list(type = "VALUE", value = cond, 
[10:33:16.752]                                 success = TRUE)
[10:33:16.752]                               parallel_sendData(master, data)
[10:33:16.752]                             }
[10:33:16.752]                             return(sendCondition)
[10:33:16.752]                           }
[10:33:16.752]                         }
[10:33:16.752]                         frame <- frame + 1L
[10:33:16.752]                         envir <- sys.frame(frame)
[10:33:16.752]                       }
[10:33:16.752]                     }
[10:33:16.752]                     sendCondition <<- function(cond) NULL
[10:33:16.752]                   }
[10:33:16.752]                 })
[10:33:16.752]                 withCallingHandlers({
[10:33:16.752]                   {
[10:33:16.752]                     x <- 0
[10:33:16.752]                     x <- x + 1
[10:33:16.752]                     x
[10:33:16.752]                   }
[10:33:16.752]                 }, immediateCondition = function(cond) {
[10:33:16.752]                   sendCondition <- ...future.makeSendCondition()
[10:33:16.752]                   sendCondition(cond)
[10:33:16.752]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.752]                   {
[10:33:16.752]                     inherits <- base::inherits
[10:33:16.752]                     invokeRestart <- base::invokeRestart
[10:33:16.752]                     is.null <- base::is.null
[10:33:16.752]                     muffled <- FALSE
[10:33:16.752]                     if (inherits(cond, "message")) {
[10:33:16.752]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:16.752]                       if (muffled) 
[10:33:16.752]                         invokeRestart("muffleMessage")
[10:33:16.752]                     }
[10:33:16.752]                     else if (inherits(cond, "warning")) {
[10:33:16.752]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:16.752]                       if (muffled) 
[10:33:16.752]                         invokeRestart("muffleWarning")
[10:33:16.752]                     }
[10:33:16.752]                     else if (inherits(cond, "condition")) {
[10:33:16.752]                       if (!is.null(pattern)) {
[10:33:16.752]                         computeRestarts <- base::computeRestarts
[10:33:16.752]                         grepl <- base::grepl
[10:33:16.752]                         restarts <- computeRestarts(cond)
[10:33:16.752]                         for (restart in restarts) {
[10:33:16.752]                           name <- restart$name
[10:33:16.752]                           if (is.null(name)) 
[10:33:16.752]                             next
[10:33:16.752]                           if (!grepl(pattern, name)) 
[10:33:16.752]                             next
[10:33:16.752]                           invokeRestart(restart)
[10:33:16.752]                           muffled <- TRUE
[10:33:16.752]                           break
[10:33:16.752]                         }
[10:33:16.752]                       }
[10:33:16.752]                     }
[10:33:16.752]                     invisible(muffled)
[10:33:16.752]                   }
[10:33:16.752]                   muffleCondition(cond)
[10:33:16.752]                 })
[10:33:16.752]             }))
[10:33:16.752]             future::FutureResult(value = ...future.value$value, 
[10:33:16.752]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:16.752]                   ...future.rng), globalenv = if (FALSE) 
[10:33:16.752]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:16.752]                     ...future.globalenv.names))
[10:33:16.752]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:16.752]         }, condition = base::local({
[10:33:16.752]             c <- base::c
[10:33:16.752]             inherits <- base::inherits
[10:33:16.752]             invokeRestart <- base::invokeRestart
[10:33:16.752]             length <- base::length
[10:33:16.752]             list <- base::list
[10:33:16.752]             seq.int <- base::seq.int
[10:33:16.752]             signalCondition <- base::signalCondition
[10:33:16.752]             sys.calls <- base::sys.calls
[10:33:16.752]             `[[` <- base::`[[`
[10:33:16.752]             `+` <- base::`+`
[10:33:16.752]             `<<-` <- base::`<<-`
[10:33:16.752]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:16.752]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:16.752]                   3L)]
[10:33:16.752]             }
[10:33:16.752]             function(cond) {
[10:33:16.752]                 is_error <- inherits(cond, "error")
[10:33:16.752]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:16.752]                   NULL)
[10:33:16.752]                 if (is_error) {
[10:33:16.752]                   sessionInformation <- function() {
[10:33:16.752]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:16.752]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:16.752]                       search = base::search(), system = base::Sys.info())
[10:33:16.752]                   }
[10:33:16.752]                   ...future.conditions[[length(...future.conditions) + 
[10:33:16.752]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:16.752]                     cond$call), session = sessionInformation(), 
[10:33:16.752]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:16.752]                   signalCondition(cond)
[10:33:16.752]                 }
[10:33:16.752]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:16.752]                 "immediateCondition"))) {
[10:33:16.752]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:16.752]                   ...future.conditions[[length(...future.conditions) + 
[10:33:16.752]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:16.752]                   if (TRUE && !signal) {
[10:33:16.752]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.752]                     {
[10:33:16.752]                       inherits <- base::inherits
[10:33:16.752]                       invokeRestart <- base::invokeRestart
[10:33:16.752]                       is.null <- base::is.null
[10:33:16.752]                       muffled <- FALSE
[10:33:16.752]                       if (inherits(cond, "message")) {
[10:33:16.752]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:16.752]                         if (muffled) 
[10:33:16.752]                           invokeRestart("muffleMessage")
[10:33:16.752]                       }
[10:33:16.752]                       else if (inherits(cond, "warning")) {
[10:33:16.752]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:16.752]                         if (muffled) 
[10:33:16.752]                           invokeRestart("muffleWarning")
[10:33:16.752]                       }
[10:33:16.752]                       else if (inherits(cond, "condition")) {
[10:33:16.752]                         if (!is.null(pattern)) {
[10:33:16.752]                           computeRestarts <- base::computeRestarts
[10:33:16.752]                           grepl <- base::grepl
[10:33:16.752]                           restarts <- computeRestarts(cond)
[10:33:16.752]                           for (restart in restarts) {
[10:33:16.752]                             name <- restart$name
[10:33:16.752]                             if (is.null(name)) 
[10:33:16.752]                               next
[10:33:16.752]                             if (!grepl(pattern, name)) 
[10:33:16.752]                               next
[10:33:16.752]                             invokeRestart(restart)
[10:33:16.752]                             muffled <- TRUE
[10:33:16.752]                             break
[10:33:16.752]                           }
[10:33:16.752]                         }
[10:33:16.752]                       }
[10:33:16.752]                       invisible(muffled)
[10:33:16.752]                     }
[10:33:16.752]                     muffleCondition(cond, pattern = "^muffle")
[10:33:16.752]                   }
[10:33:16.752]                 }
[10:33:16.752]                 else {
[10:33:16.752]                   if (TRUE) {
[10:33:16.752]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.752]                     {
[10:33:16.752]                       inherits <- base::inherits
[10:33:16.752]                       invokeRestart <- base::invokeRestart
[10:33:16.752]                       is.null <- base::is.null
[10:33:16.752]                       muffled <- FALSE
[10:33:16.752]                       if (inherits(cond, "message")) {
[10:33:16.752]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:16.752]                         if (muffled) 
[10:33:16.752]                           invokeRestart("muffleMessage")
[10:33:16.752]                       }
[10:33:16.752]                       else if (inherits(cond, "warning")) {
[10:33:16.752]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:16.752]                         if (muffled) 
[10:33:16.752]                           invokeRestart("muffleWarning")
[10:33:16.752]                       }
[10:33:16.752]                       else if (inherits(cond, "condition")) {
[10:33:16.752]                         if (!is.null(pattern)) {
[10:33:16.752]                           computeRestarts <- base::computeRestarts
[10:33:16.752]                           grepl <- base::grepl
[10:33:16.752]                           restarts <- computeRestarts(cond)
[10:33:16.752]                           for (restart in restarts) {
[10:33:16.752]                             name <- restart$name
[10:33:16.752]                             if (is.null(name)) 
[10:33:16.752]                               next
[10:33:16.752]                             if (!grepl(pattern, name)) 
[10:33:16.752]                               next
[10:33:16.752]                             invokeRestart(restart)
[10:33:16.752]                             muffled <- TRUE
[10:33:16.752]                             break
[10:33:16.752]                           }
[10:33:16.752]                         }
[10:33:16.752]                       }
[10:33:16.752]                       invisible(muffled)
[10:33:16.752]                     }
[10:33:16.752]                     muffleCondition(cond, pattern = "^muffle")
[10:33:16.752]                   }
[10:33:16.752]                 }
[10:33:16.752]             }
[10:33:16.752]         }))
[10:33:16.752]     }, error = function(ex) {
[10:33:16.752]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:16.752]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:16.752]                 ...future.rng), started = ...future.startTime, 
[10:33:16.752]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:16.752]             version = "1.8"), class = "FutureResult")
[10:33:16.752]     }, finally = {
[10:33:16.752]         if (!identical(...future.workdir, getwd())) 
[10:33:16.752]             setwd(...future.workdir)
[10:33:16.752]         {
[10:33:16.752]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:16.752]                 ...future.oldOptions$nwarnings <- NULL
[10:33:16.752]             }
[10:33:16.752]             base::options(...future.oldOptions)
[10:33:16.752]             if (.Platform$OS.type == "windows") {
[10:33:16.752]                 old_names <- names(...future.oldEnvVars)
[10:33:16.752]                 envs <- base::Sys.getenv()
[10:33:16.752]                 names <- names(envs)
[10:33:16.752]                 common <- intersect(names, old_names)
[10:33:16.752]                 added <- setdiff(names, old_names)
[10:33:16.752]                 removed <- setdiff(old_names, names)
[10:33:16.752]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:16.752]                   envs[common]]
[10:33:16.752]                 NAMES <- toupper(changed)
[10:33:16.752]                 args <- list()
[10:33:16.752]                 for (kk in seq_along(NAMES)) {
[10:33:16.752]                   name <- changed[[kk]]
[10:33:16.752]                   NAME <- NAMES[[kk]]
[10:33:16.752]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.752]                     next
[10:33:16.752]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:16.752]                 }
[10:33:16.752]                 NAMES <- toupper(added)
[10:33:16.752]                 for (kk in seq_along(NAMES)) {
[10:33:16.752]                   name <- added[[kk]]
[10:33:16.752]                   NAME <- NAMES[[kk]]
[10:33:16.752]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.752]                     next
[10:33:16.752]                   args[[name]] <- ""
[10:33:16.752]                 }
[10:33:16.752]                 NAMES <- toupper(removed)
[10:33:16.752]                 for (kk in seq_along(NAMES)) {
[10:33:16.752]                   name <- removed[[kk]]
[10:33:16.752]                   NAME <- NAMES[[kk]]
[10:33:16.752]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.752]                     next
[10:33:16.752]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:16.752]                 }
[10:33:16.752]                 if (length(args) > 0) 
[10:33:16.752]                   base::do.call(base::Sys.setenv, args = args)
[10:33:16.752]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:16.752]             }
[10:33:16.752]             else {
[10:33:16.752]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:16.752]             }
[10:33:16.752]             {
[10:33:16.752]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:16.752]                   0L) {
[10:33:16.752]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:16.752]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:16.752]                   base::options(opts)
[10:33:16.752]                 }
[10:33:16.752]                 {
[10:33:16.752]                   {
[10:33:16.752]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:16.752]                     NULL
[10:33:16.752]                   }
[10:33:16.752]                   options(future.plan = NULL)
[10:33:16.752]                   if (is.na(NA_character_)) 
[10:33:16.752]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:16.752]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:16.752]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:16.752]                     .init = FALSE)
[10:33:16.752]                 }
[10:33:16.752]             }
[10:33:16.752]         }
[10:33:16.752]     })
[10:33:16.752]     if (TRUE) {
[10:33:16.752]         base::sink(type = "output", split = FALSE)
[10:33:16.752]         if (TRUE) {
[10:33:16.752]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:16.752]         }
[10:33:16.752]         else {
[10:33:16.752]             ...future.result["stdout"] <- base::list(NULL)
[10:33:16.752]         }
[10:33:16.752]         base::close(...future.stdout)
[10:33:16.752]         ...future.stdout <- NULL
[10:33:16.752]     }
[10:33:16.752]     ...future.result$conditions <- ...future.conditions
[10:33:16.752]     ...future.result$finished <- base::Sys.time()
[10:33:16.752]     ...future.result
[10:33:16.752] }
[10:33:16.755] MultisessionFuture started
[10:33:16.755] - Launch lazy future ... done
[10:33:16.755] run() for ‘MultisessionFuture’ ... done
[10:33:16.755] result() for ClusterFuture ...
[10:33:16.755] receiveMessageFromWorker() for ClusterFuture ...
[10:33:16.756] - Validating connection of MultisessionFuture
[10:33:16.798] - received message: FutureResult
[10:33:16.799] - Received FutureResult
[10:33:16.799] - Erased future from FutureRegistry
[10:33:16.799] result() for ClusterFuture ...
[10:33:16.799] - result already collected: FutureResult
[10:33:16.799] result() for ClusterFuture ... done
[10:33:16.799] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:16.799] result() for ClusterFuture ... done
[10:33:16.799] result() for ClusterFuture ...
[10:33:16.799] - result already collected: FutureResult
[10:33:16.799] result() for ClusterFuture ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:16.800] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:16.800] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:16.801] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[10:33:16.801] Searching for globals ... DONE
[10:33:16.802] Resolving globals: TRUE
[10:33:16.802] Resolving any globals that are futures ...
[10:33:16.802] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[10:33:16.802] Resolving any globals that are futures ... DONE
[10:33:16.802] Resolving futures part of globals (recursively) ...
[10:33:16.802] resolve() on list ...
[10:33:16.802]  recursive: 99
[10:33:16.803]  length: 1
[10:33:16.803]  elements: ‘x’
[10:33:16.803]  length: 0 (resolved future 1)
[10:33:16.803] resolve() on list ... DONE
[10:33:16.803] - globals: [1] ‘x’
[10:33:16.803] Resolving futures part of globals (recursively) ... DONE
[10:33:16.803] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:16.803] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[10:33:16.804] - globals: [1] ‘x’
[10:33:16.804] 
[10:33:16.804] getGlobalsAndPackages() ... DONE
[10:33:16.804] run() for ‘Future’ ...
[10:33:16.804] - state: ‘created’
[10:33:16.804] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:16.817] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:16.818] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:16.818]   - Field: ‘node’
[10:33:16.818]   - Field: ‘label’
[10:33:16.818]   - Field: ‘local’
[10:33:16.818]   - Field: ‘owner’
[10:33:16.818]   - Field: ‘envir’
[10:33:16.818]   - Field: ‘workers’
[10:33:16.818]   - Field: ‘packages’
[10:33:16.818]   - Field: ‘gc’
[10:33:16.819]   - Field: ‘conditions’
[10:33:16.819]   - Field: ‘persistent’
[10:33:16.819]   - Field: ‘expr’
[10:33:16.819]   - Field: ‘uuid’
[10:33:16.819]   - Field: ‘seed’
[10:33:16.819]   - Field: ‘version’
[10:33:16.819]   - Field: ‘result’
[10:33:16.819]   - Field: ‘asynchronous’
[10:33:16.819]   - Field: ‘calls’
[10:33:16.819]   - Field: ‘globals’
[10:33:16.819]   - Field: ‘stdout’
[10:33:16.820]   - Field: ‘earlySignal’
[10:33:16.820]   - Field: ‘lazy’
[10:33:16.820]   - Field: ‘state’
[10:33:16.820] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:16.820] - Launch lazy future ...
[10:33:16.820] Packages needed by the future expression (n = 0): <none>
[10:33:16.820] Packages needed by future strategies (n = 0): <none>
[10:33:16.821] {
[10:33:16.821]     {
[10:33:16.821]         {
[10:33:16.821]             ...future.startTime <- base::Sys.time()
[10:33:16.821]             {
[10:33:16.821]                 {
[10:33:16.821]                   {
[10:33:16.821]                     {
[10:33:16.821]                       base::local({
[10:33:16.821]                         has_future <- base::requireNamespace("future", 
[10:33:16.821]                           quietly = TRUE)
[10:33:16.821]                         if (has_future) {
[10:33:16.821]                           ns <- base::getNamespace("future")
[10:33:16.821]                           version <- ns[[".package"]][["version"]]
[10:33:16.821]                           if (is.null(version)) 
[10:33:16.821]                             version <- utils::packageVersion("future")
[10:33:16.821]                         }
[10:33:16.821]                         else {
[10:33:16.821]                           version <- NULL
[10:33:16.821]                         }
[10:33:16.821]                         if (!has_future || version < "1.8.0") {
[10:33:16.821]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:16.821]                             "", base::R.version$version.string), 
[10:33:16.821]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:16.821]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:16.821]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:16.821]                               "release", "version")], collapse = " "), 
[10:33:16.821]                             hostname = base::Sys.info()[["nodename"]])
[10:33:16.821]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:16.821]                             info)
[10:33:16.821]                           info <- base::paste(info, collapse = "; ")
[10:33:16.821]                           if (!has_future) {
[10:33:16.821]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:16.821]                               info)
[10:33:16.821]                           }
[10:33:16.821]                           else {
[10:33:16.821]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:16.821]                               info, version)
[10:33:16.821]                           }
[10:33:16.821]                           base::stop(msg)
[10:33:16.821]                         }
[10:33:16.821]                       })
[10:33:16.821]                     }
[10:33:16.821]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:16.821]                     base::options(mc.cores = 1L)
[10:33:16.821]                   }
[10:33:16.821]                   ...future.strategy.old <- future::plan("list")
[10:33:16.821]                   options(future.plan = NULL)
[10:33:16.821]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:16.821]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:16.821]                 }
[10:33:16.821]                 ...future.workdir <- getwd()
[10:33:16.821]             }
[10:33:16.821]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:16.821]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:16.821]         }
[10:33:16.821]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:16.821]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:16.821]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:16.821]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:16.821]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:16.821]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:16.821]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:16.821]             base::names(...future.oldOptions))
[10:33:16.821]     }
[10:33:16.821]     if (FALSE) {
[10:33:16.821]     }
[10:33:16.821]     else {
[10:33:16.821]         if (TRUE) {
[10:33:16.821]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:16.821]                 open = "w")
[10:33:16.821]         }
[10:33:16.821]         else {
[10:33:16.821]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:16.821]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:16.821]         }
[10:33:16.821]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:16.821]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:16.821]             base::sink(type = "output", split = FALSE)
[10:33:16.821]             base::close(...future.stdout)
[10:33:16.821]         }, add = TRUE)
[10:33:16.821]     }
[10:33:16.821]     ...future.frame <- base::sys.nframe()
[10:33:16.821]     ...future.conditions <- base::list()
[10:33:16.821]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:16.821]     if (FALSE) {
[10:33:16.821]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:16.821]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:16.821]     }
[10:33:16.821]     ...future.result <- base::tryCatch({
[10:33:16.821]         base::withCallingHandlers({
[10:33:16.821]             ...future.value <- base::withVisible(base::local({
[10:33:16.821]                 ...future.makeSendCondition <- base::local({
[10:33:16.821]                   sendCondition <- NULL
[10:33:16.821]                   function(frame = 1L) {
[10:33:16.821]                     if (is.function(sendCondition)) 
[10:33:16.821]                       return(sendCondition)
[10:33:16.821]                     ns <- getNamespace("parallel")
[10:33:16.821]                     if (exists("sendData", mode = "function", 
[10:33:16.821]                       envir = ns)) {
[10:33:16.821]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:16.821]                         envir = ns)
[10:33:16.821]                       envir <- sys.frame(frame)
[10:33:16.821]                       master <- NULL
[10:33:16.821]                       while (!identical(envir, .GlobalEnv) && 
[10:33:16.821]                         !identical(envir, emptyenv())) {
[10:33:16.821]                         if (exists("master", mode = "list", envir = envir, 
[10:33:16.821]                           inherits = FALSE)) {
[10:33:16.821]                           master <- get("master", mode = "list", 
[10:33:16.821]                             envir = envir, inherits = FALSE)
[10:33:16.821]                           if (inherits(master, c("SOCKnode", 
[10:33:16.821]                             "SOCK0node"))) {
[10:33:16.821]                             sendCondition <<- function(cond) {
[10:33:16.821]                               data <- list(type = "VALUE", value = cond, 
[10:33:16.821]                                 success = TRUE)
[10:33:16.821]                               parallel_sendData(master, data)
[10:33:16.821]                             }
[10:33:16.821]                             return(sendCondition)
[10:33:16.821]                           }
[10:33:16.821]                         }
[10:33:16.821]                         frame <- frame + 1L
[10:33:16.821]                         envir <- sys.frame(frame)
[10:33:16.821]                       }
[10:33:16.821]                     }
[10:33:16.821]                     sendCondition <<- function(cond) NULL
[10:33:16.821]                   }
[10:33:16.821]                 })
[10:33:16.821]                 withCallingHandlers({
[10:33:16.821]                   {
[10:33:16.821]                     x <- x + 1
[10:33:16.821]                     x
[10:33:16.821]                   }
[10:33:16.821]                 }, immediateCondition = function(cond) {
[10:33:16.821]                   sendCondition <- ...future.makeSendCondition()
[10:33:16.821]                   sendCondition(cond)
[10:33:16.821]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.821]                   {
[10:33:16.821]                     inherits <- base::inherits
[10:33:16.821]                     invokeRestart <- base::invokeRestart
[10:33:16.821]                     is.null <- base::is.null
[10:33:16.821]                     muffled <- FALSE
[10:33:16.821]                     if (inherits(cond, "message")) {
[10:33:16.821]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:16.821]                       if (muffled) 
[10:33:16.821]                         invokeRestart("muffleMessage")
[10:33:16.821]                     }
[10:33:16.821]                     else if (inherits(cond, "warning")) {
[10:33:16.821]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:16.821]                       if (muffled) 
[10:33:16.821]                         invokeRestart("muffleWarning")
[10:33:16.821]                     }
[10:33:16.821]                     else if (inherits(cond, "condition")) {
[10:33:16.821]                       if (!is.null(pattern)) {
[10:33:16.821]                         computeRestarts <- base::computeRestarts
[10:33:16.821]                         grepl <- base::grepl
[10:33:16.821]                         restarts <- computeRestarts(cond)
[10:33:16.821]                         for (restart in restarts) {
[10:33:16.821]                           name <- restart$name
[10:33:16.821]                           if (is.null(name)) 
[10:33:16.821]                             next
[10:33:16.821]                           if (!grepl(pattern, name)) 
[10:33:16.821]                             next
[10:33:16.821]                           invokeRestart(restart)
[10:33:16.821]                           muffled <- TRUE
[10:33:16.821]                           break
[10:33:16.821]                         }
[10:33:16.821]                       }
[10:33:16.821]                     }
[10:33:16.821]                     invisible(muffled)
[10:33:16.821]                   }
[10:33:16.821]                   muffleCondition(cond)
[10:33:16.821]                 })
[10:33:16.821]             }))
[10:33:16.821]             future::FutureResult(value = ...future.value$value, 
[10:33:16.821]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:16.821]                   ...future.rng), globalenv = if (FALSE) 
[10:33:16.821]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:16.821]                     ...future.globalenv.names))
[10:33:16.821]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:16.821]         }, condition = base::local({
[10:33:16.821]             c <- base::c
[10:33:16.821]             inherits <- base::inherits
[10:33:16.821]             invokeRestart <- base::invokeRestart
[10:33:16.821]             length <- base::length
[10:33:16.821]             list <- base::list
[10:33:16.821]             seq.int <- base::seq.int
[10:33:16.821]             signalCondition <- base::signalCondition
[10:33:16.821]             sys.calls <- base::sys.calls
[10:33:16.821]             `[[` <- base::`[[`
[10:33:16.821]             `+` <- base::`+`
[10:33:16.821]             `<<-` <- base::`<<-`
[10:33:16.821]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:16.821]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:16.821]                   3L)]
[10:33:16.821]             }
[10:33:16.821]             function(cond) {
[10:33:16.821]                 is_error <- inherits(cond, "error")
[10:33:16.821]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:16.821]                   NULL)
[10:33:16.821]                 if (is_error) {
[10:33:16.821]                   sessionInformation <- function() {
[10:33:16.821]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:16.821]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:16.821]                       search = base::search(), system = base::Sys.info())
[10:33:16.821]                   }
[10:33:16.821]                   ...future.conditions[[length(...future.conditions) + 
[10:33:16.821]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:16.821]                     cond$call), session = sessionInformation(), 
[10:33:16.821]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:16.821]                   signalCondition(cond)
[10:33:16.821]                 }
[10:33:16.821]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:16.821]                 "immediateCondition"))) {
[10:33:16.821]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:16.821]                   ...future.conditions[[length(...future.conditions) + 
[10:33:16.821]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:16.821]                   if (TRUE && !signal) {
[10:33:16.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.821]                     {
[10:33:16.821]                       inherits <- base::inherits
[10:33:16.821]                       invokeRestart <- base::invokeRestart
[10:33:16.821]                       is.null <- base::is.null
[10:33:16.821]                       muffled <- FALSE
[10:33:16.821]                       if (inherits(cond, "message")) {
[10:33:16.821]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:16.821]                         if (muffled) 
[10:33:16.821]                           invokeRestart("muffleMessage")
[10:33:16.821]                       }
[10:33:16.821]                       else if (inherits(cond, "warning")) {
[10:33:16.821]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:16.821]                         if (muffled) 
[10:33:16.821]                           invokeRestart("muffleWarning")
[10:33:16.821]                       }
[10:33:16.821]                       else if (inherits(cond, "condition")) {
[10:33:16.821]                         if (!is.null(pattern)) {
[10:33:16.821]                           computeRestarts <- base::computeRestarts
[10:33:16.821]                           grepl <- base::grepl
[10:33:16.821]                           restarts <- computeRestarts(cond)
[10:33:16.821]                           for (restart in restarts) {
[10:33:16.821]                             name <- restart$name
[10:33:16.821]                             if (is.null(name)) 
[10:33:16.821]                               next
[10:33:16.821]                             if (!grepl(pattern, name)) 
[10:33:16.821]                               next
[10:33:16.821]                             invokeRestart(restart)
[10:33:16.821]                             muffled <- TRUE
[10:33:16.821]                             break
[10:33:16.821]                           }
[10:33:16.821]                         }
[10:33:16.821]                       }
[10:33:16.821]                       invisible(muffled)
[10:33:16.821]                     }
[10:33:16.821]                     muffleCondition(cond, pattern = "^muffle")
[10:33:16.821]                   }
[10:33:16.821]                 }
[10:33:16.821]                 else {
[10:33:16.821]                   if (TRUE) {
[10:33:16.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.821]                     {
[10:33:16.821]                       inherits <- base::inherits
[10:33:16.821]                       invokeRestart <- base::invokeRestart
[10:33:16.821]                       is.null <- base::is.null
[10:33:16.821]                       muffled <- FALSE
[10:33:16.821]                       if (inherits(cond, "message")) {
[10:33:16.821]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:16.821]                         if (muffled) 
[10:33:16.821]                           invokeRestart("muffleMessage")
[10:33:16.821]                       }
[10:33:16.821]                       else if (inherits(cond, "warning")) {
[10:33:16.821]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:16.821]                         if (muffled) 
[10:33:16.821]                           invokeRestart("muffleWarning")
[10:33:16.821]                       }
[10:33:16.821]                       else if (inherits(cond, "condition")) {
[10:33:16.821]                         if (!is.null(pattern)) {
[10:33:16.821]                           computeRestarts <- base::computeRestarts
[10:33:16.821]                           grepl <- base::grepl
[10:33:16.821]                           restarts <- computeRestarts(cond)
[10:33:16.821]                           for (restart in restarts) {
[10:33:16.821]                             name <- restart$name
[10:33:16.821]                             if (is.null(name)) 
[10:33:16.821]                               next
[10:33:16.821]                             if (!grepl(pattern, name)) 
[10:33:16.821]                               next
[10:33:16.821]                             invokeRestart(restart)
[10:33:16.821]                             muffled <- TRUE
[10:33:16.821]                             break
[10:33:16.821]                           }
[10:33:16.821]                         }
[10:33:16.821]                       }
[10:33:16.821]                       invisible(muffled)
[10:33:16.821]                     }
[10:33:16.821]                     muffleCondition(cond, pattern = "^muffle")
[10:33:16.821]                   }
[10:33:16.821]                 }
[10:33:16.821]             }
[10:33:16.821]         }))
[10:33:16.821]     }, error = function(ex) {
[10:33:16.821]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:16.821]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:16.821]                 ...future.rng), started = ...future.startTime, 
[10:33:16.821]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:16.821]             version = "1.8"), class = "FutureResult")
[10:33:16.821]     }, finally = {
[10:33:16.821]         if (!identical(...future.workdir, getwd())) 
[10:33:16.821]             setwd(...future.workdir)
[10:33:16.821]         {
[10:33:16.821]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:16.821]                 ...future.oldOptions$nwarnings <- NULL
[10:33:16.821]             }
[10:33:16.821]             base::options(...future.oldOptions)
[10:33:16.821]             if (.Platform$OS.type == "windows") {
[10:33:16.821]                 old_names <- names(...future.oldEnvVars)
[10:33:16.821]                 envs <- base::Sys.getenv()
[10:33:16.821]                 names <- names(envs)
[10:33:16.821]                 common <- intersect(names, old_names)
[10:33:16.821]                 added <- setdiff(names, old_names)
[10:33:16.821]                 removed <- setdiff(old_names, names)
[10:33:16.821]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:16.821]                   envs[common]]
[10:33:16.821]                 NAMES <- toupper(changed)
[10:33:16.821]                 args <- list()
[10:33:16.821]                 for (kk in seq_along(NAMES)) {
[10:33:16.821]                   name <- changed[[kk]]
[10:33:16.821]                   NAME <- NAMES[[kk]]
[10:33:16.821]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.821]                     next
[10:33:16.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:16.821]                 }
[10:33:16.821]                 NAMES <- toupper(added)
[10:33:16.821]                 for (kk in seq_along(NAMES)) {
[10:33:16.821]                   name <- added[[kk]]
[10:33:16.821]                   NAME <- NAMES[[kk]]
[10:33:16.821]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.821]                     next
[10:33:16.821]                   args[[name]] <- ""
[10:33:16.821]                 }
[10:33:16.821]                 NAMES <- toupper(removed)
[10:33:16.821]                 for (kk in seq_along(NAMES)) {
[10:33:16.821]                   name <- removed[[kk]]
[10:33:16.821]                   NAME <- NAMES[[kk]]
[10:33:16.821]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.821]                     next
[10:33:16.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:16.821]                 }
[10:33:16.821]                 if (length(args) > 0) 
[10:33:16.821]                   base::do.call(base::Sys.setenv, args = args)
[10:33:16.821]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:16.821]             }
[10:33:16.821]             else {
[10:33:16.821]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:16.821]             }
[10:33:16.821]             {
[10:33:16.821]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:16.821]                   0L) {
[10:33:16.821]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:16.821]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:16.821]                   base::options(opts)
[10:33:16.821]                 }
[10:33:16.821]                 {
[10:33:16.821]                   {
[10:33:16.821]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:16.821]                     NULL
[10:33:16.821]                   }
[10:33:16.821]                   options(future.plan = NULL)
[10:33:16.821]                   if (is.na(NA_character_)) 
[10:33:16.821]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:16.821]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:16.821]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:16.821]                     .init = FALSE)
[10:33:16.821]                 }
[10:33:16.821]             }
[10:33:16.821]         }
[10:33:16.821]     })
[10:33:16.821]     if (TRUE) {
[10:33:16.821]         base::sink(type = "output", split = FALSE)
[10:33:16.821]         if (TRUE) {
[10:33:16.821]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:16.821]         }
[10:33:16.821]         else {
[10:33:16.821]             ...future.result["stdout"] <- base::list(NULL)
[10:33:16.821]         }
[10:33:16.821]         base::close(...future.stdout)
[10:33:16.821]         ...future.stdout <- NULL
[10:33:16.821]     }
[10:33:16.821]     ...future.result$conditions <- ...future.conditions
[10:33:16.821]     ...future.result$finished <- base::Sys.time()
[10:33:16.821]     ...future.result
[10:33:16.821] }
[10:33:16.823] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[10:33:16.823] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[10:33:16.824] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[10:33:16.824] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[10:33:16.824] MultisessionFuture started
[10:33:16.824] - Launch lazy future ... done
[10:33:16.825] run() for ‘MultisessionFuture’ ... done
[10:33:16.825] result() for ClusterFuture ...
[10:33:16.825] receiveMessageFromWorker() for ClusterFuture ...
[10:33:16.825] - Validating connection of MultisessionFuture
[10:33:16.866] - received message: FutureResult
[10:33:16.867] - Received FutureResult
[10:33:16.867] - Erased future from FutureRegistry
[10:33:16.867] result() for ClusterFuture ...
[10:33:16.867] - result already collected: FutureResult
[10:33:16.867] result() for ClusterFuture ... done
[10:33:16.867] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:16.867] result() for ClusterFuture ... done
[10:33:16.867] result() for ClusterFuture ...
[10:33:16.867] - result already collected: FutureResult
[10:33:16.867] result() for ClusterFuture ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:16.868] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:16.868] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:33:16.870] - globals found: [3] ‘{’, ‘<-’, ‘x’
[10:33:16.870] Searching for globals ... DONE
[10:33:16.870] Resolving globals: TRUE
[10:33:16.870] Resolving any globals that are futures ...
[10:33:16.870] - globals: [3] ‘{’, ‘<-’, ‘x’
[10:33:16.870] Resolving any globals that are futures ... DONE
[10:33:16.870] Resolving futures part of globals (recursively) ...
[10:33:16.871] resolve() on list ...
[10:33:16.871]  recursive: 99
[10:33:16.871]  length: 1
[10:33:16.871]  elements: ‘x’
[10:33:16.871]  length: 0 (resolved future 1)
[10:33:16.871] resolve() on list ... DONE
[10:33:16.871] - globals: [1] ‘x’
[10:33:16.871] Resolving futures part of globals (recursively) ... DONE
[10:33:16.871] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[10:33:16.872] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[10:33:16.872] - globals: [1] ‘x’
[10:33:16.872] 
[10:33:16.872] getGlobalsAndPackages() ... DONE
[10:33:16.872] run() for ‘Future’ ...
[10:33:16.872] - state: ‘created’
[10:33:16.872] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:16.886] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:16.886] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:16.886]   - Field: ‘node’
[10:33:16.886]   - Field: ‘label’
[10:33:16.886]   - Field: ‘local’
[10:33:16.887]   - Field: ‘owner’
[10:33:16.887]   - Field: ‘envir’
[10:33:16.887]   - Field: ‘workers’
[10:33:16.887]   - Field: ‘packages’
[10:33:16.887]   - Field: ‘gc’
[10:33:16.887]   - Field: ‘conditions’
[10:33:16.887]   - Field: ‘persistent’
[10:33:16.887]   - Field: ‘expr’
[10:33:16.887]   - Field: ‘uuid’
[10:33:16.887]   - Field: ‘seed’
[10:33:16.887]   - Field: ‘version’
[10:33:16.888]   - Field: ‘result’
[10:33:16.888]   - Field: ‘asynchronous’
[10:33:16.888]   - Field: ‘calls’
[10:33:16.888]   - Field: ‘globals’
[10:33:16.888]   - Field: ‘stdout’
[10:33:16.888]   - Field: ‘earlySignal’
[10:33:16.888]   - Field: ‘lazy’
[10:33:16.888]   - Field: ‘state’
[10:33:16.888] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:16.888] - Launch lazy future ...
[10:33:16.889] Packages needed by the future expression (n = 0): <none>
[10:33:16.889] Packages needed by future strategies (n = 0): <none>
[10:33:16.889] {
[10:33:16.889]     {
[10:33:16.889]         {
[10:33:16.889]             ...future.startTime <- base::Sys.time()
[10:33:16.889]             {
[10:33:16.889]                 {
[10:33:16.889]                   {
[10:33:16.889]                     {
[10:33:16.889]                       base::local({
[10:33:16.889]                         has_future <- base::requireNamespace("future", 
[10:33:16.889]                           quietly = TRUE)
[10:33:16.889]                         if (has_future) {
[10:33:16.889]                           ns <- base::getNamespace("future")
[10:33:16.889]                           version <- ns[[".package"]][["version"]]
[10:33:16.889]                           if (is.null(version)) 
[10:33:16.889]                             version <- utils::packageVersion("future")
[10:33:16.889]                         }
[10:33:16.889]                         else {
[10:33:16.889]                           version <- NULL
[10:33:16.889]                         }
[10:33:16.889]                         if (!has_future || version < "1.8.0") {
[10:33:16.889]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:16.889]                             "", base::R.version$version.string), 
[10:33:16.889]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:16.889]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:16.889]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:16.889]                               "release", "version")], collapse = " "), 
[10:33:16.889]                             hostname = base::Sys.info()[["nodename"]])
[10:33:16.889]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:16.889]                             info)
[10:33:16.889]                           info <- base::paste(info, collapse = "; ")
[10:33:16.889]                           if (!has_future) {
[10:33:16.889]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:16.889]                               info)
[10:33:16.889]                           }
[10:33:16.889]                           else {
[10:33:16.889]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:16.889]                               info, version)
[10:33:16.889]                           }
[10:33:16.889]                           base::stop(msg)
[10:33:16.889]                         }
[10:33:16.889]                       })
[10:33:16.889]                     }
[10:33:16.889]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:16.889]                     base::options(mc.cores = 1L)
[10:33:16.889]                   }
[10:33:16.889]                   ...future.strategy.old <- future::plan("list")
[10:33:16.889]                   options(future.plan = NULL)
[10:33:16.889]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:16.889]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:16.889]                 }
[10:33:16.889]                 ...future.workdir <- getwd()
[10:33:16.889]             }
[10:33:16.889]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:16.889]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:16.889]         }
[10:33:16.889]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:16.889]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:33:16.889]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:16.889]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:16.889]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:16.889]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:16.889]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:16.889]             base::names(...future.oldOptions))
[10:33:16.889]     }
[10:33:16.889]     if (FALSE) {
[10:33:16.889]     }
[10:33:16.889]     else {
[10:33:16.889]         if (TRUE) {
[10:33:16.889]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:16.889]                 open = "w")
[10:33:16.889]         }
[10:33:16.889]         else {
[10:33:16.889]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:16.889]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:16.889]         }
[10:33:16.889]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:16.889]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:16.889]             base::sink(type = "output", split = FALSE)
[10:33:16.889]             base::close(...future.stdout)
[10:33:16.889]         }, add = TRUE)
[10:33:16.889]     }
[10:33:16.889]     ...future.frame <- base::sys.nframe()
[10:33:16.889]     ...future.conditions <- base::list()
[10:33:16.889]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:16.889]     if (FALSE) {
[10:33:16.889]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:16.889]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:16.889]     }
[10:33:16.889]     ...future.result <- base::tryCatch({
[10:33:16.889]         base::withCallingHandlers({
[10:33:16.889]             ...future.value <- base::withVisible(base::local({
[10:33:16.889]                 ...future.makeSendCondition <- base::local({
[10:33:16.889]                   sendCondition <- NULL
[10:33:16.889]                   function(frame = 1L) {
[10:33:16.889]                     if (is.function(sendCondition)) 
[10:33:16.889]                       return(sendCondition)
[10:33:16.889]                     ns <- getNamespace("parallel")
[10:33:16.889]                     if (exists("sendData", mode = "function", 
[10:33:16.889]                       envir = ns)) {
[10:33:16.889]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:16.889]                         envir = ns)
[10:33:16.889]                       envir <- sys.frame(frame)
[10:33:16.889]                       master <- NULL
[10:33:16.889]                       while (!identical(envir, .GlobalEnv) && 
[10:33:16.889]                         !identical(envir, emptyenv())) {
[10:33:16.889]                         if (exists("master", mode = "list", envir = envir, 
[10:33:16.889]                           inherits = FALSE)) {
[10:33:16.889]                           master <- get("master", mode = "list", 
[10:33:16.889]                             envir = envir, inherits = FALSE)
[10:33:16.889]                           if (inherits(master, c("SOCKnode", 
[10:33:16.889]                             "SOCK0node"))) {
[10:33:16.889]                             sendCondition <<- function(cond) {
[10:33:16.889]                               data <- list(type = "VALUE", value = cond, 
[10:33:16.889]                                 success = TRUE)
[10:33:16.889]                               parallel_sendData(master, data)
[10:33:16.889]                             }
[10:33:16.889]                             return(sendCondition)
[10:33:16.889]                           }
[10:33:16.889]                         }
[10:33:16.889]                         frame <- frame + 1L
[10:33:16.889]                         envir <- sys.frame(frame)
[10:33:16.889]                       }
[10:33:16.889]                     }
[10:33:16.889]                     sendCondition <<- function(cond) NULL
[10:33:16.889]                   }
[10:33:16.889]                 })
[10:33:16.889]                 withCallingHandlers({
[10:33:16.889]                   {
[10:33:16.889]                     x <- x()
[10:33:16.889]                     x
[10:33:16.889]                   }
[10:33:16.889]                 }, immediateCondition = function(cond) {
[10:33:16.889]                   sendCondition <- ...future.makeSendCondition()
[10:33:16.889]                   sendCondition(cond)
[10:33:16.889]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.889]                   {
[10:33:16.889]                     inherits <- base::inherits
[10:33:16.889]                     invokeRestart <- base::invokeRestart
[10:33:16.889]                     is.null <- base::is.null
[10:33:16.889]                     muffled <- FALSE
[10:33:16.889]                     if (inherits(cond, "message")) {
[10:33:16.889]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:16.889]                       if (muffled) 
[10:33:16.889]                         invokeRestart("muffleMessage")
[10:33:16.889]                     }
[10:33:16.889]                     else if (inherits(cond, "warning")) {
[10:33:16.889]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:16.889]                       if (muffled) 
[10:33:16.889]                         invokeRestart("muffleWarning")
[10:33:16.889]                     }
[10:33:16.889]                     else if (inherits(cond, "condition")) {
[10:33:16.889]                       if (!is.null(pattern)) {
[10:33:16.889]                         computeRestarts <- base::computeRestarts
[10:33:16.889]                         grepl <- base::grepl
[10:33:16.889]                         restarts <- computeRestarts(cond)
[10:33:16.889]                         for (restart in restarts) {
[10:33:16.889]                           name <- restart$name
[10:33:16.889]                           if (is.null(name)) 
[10:33:16.889]                             next
[10:33:16.889]                           if (!grepl(pattern, name)) 
[10:33:16.889]                             next
[10:33:16.889]                           invokeRestart(restart)
[10:33:16.889]                           muffled <- TRUE
[10:33:16.889]                           break
[10:33:16.889]                         }
[10:33:16.889]                       }
[10:33:16.889]                     }
[10:33:16.889]                     invisible(muffled)
[10:33:16.889]                   }
[10:33:16.889]                   muffleCondition(cond)
[10:33:16.889]                 })
[10:33:16.889]             }))
[10:33:16.889]             future::FutureResult(value = ...future.value$value, 
[10:33:16.889]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:16.889]                   ...future.rng), globalenv = if (FALSE) 
[10:33:16.889]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:16.889]                     ...future.globalenv.names))
[10:33:16.889]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:16.889]         }, condition = base::local({
[10:33:16.889]             c <- base::c
[10:33:16.889]             inherits <- base::inherits
[10:33:16.889]             invokeRestart <- base::invokeRestart
[10:33:16.889]             length <- base::length
[10:33:16.889]             list <- base::list
[10:33:16.889]             seq.int <- base::seq.int
[10:33:16.889]             signalCondition <- base::signalCondition
[10:33:16.889]             sys.calls <- base::sys.calls
[10:33:16.889]             `[[` <- base::`[[`
[10:33:16.889]             `+` <- base::`+`
[10:33:16.889]             `<<-` <- base::`<<-`
[10:33:16.889]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:16.889]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:16.889]                   3L)]
[10:33:16.889]             }
[10:33:16.889]             function(cond) {
[10:33:16.889]                 is_error <- inherits(cond, "error")
[10:33:16.889]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:16.889]                   NULL)
[10:33:16.889]                 if (is_error) {
[10:33:16.889]                   sessionInformation <- function() {
[10:33:16.889]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:16.889]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:16.889]                       search = base::search(), system = base::Sys.info())
[10:33:16.889]                   }
[10:33:16.889]                   ...future.conditions[[length(...future.conditions) + 
[10:33:16.889]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:16.889]                     cond$call), session = sessionInformation(), 
[10:33:16.889]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:16.889]                   signalCondition(cond)
[10:33:16.889]                 }
[10:33:16.889]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:16.889]                 "immediateCondition"))) {
[10:33:16.889]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:16.889]                   ...future.conditions[[length(...future.conditions) + 
[10:33:16.889]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:16.889]                   if (TRUE && !signal) {
[10:33:16.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.889]                     {
[10:33:16.889]                       inherits <- base::inherits
[10:33:16.889]                       invokeRestart <- base::invokeRestart
[10:33:16.889]                       is.null <- base::is.null
[10:33:16.889]                       muffled <- FALSE
[10:33:16.889]                       if (inherits(cond, "message")) {
[10:33:16.889]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:16.889]                         if (muffled) 
[10:33:16.889]                           invokeRestart("muffleMessage")
[10:33:16.889]                       }
[10:33:16.889]                       else if (inherits(cond, "warning")) {
[10:33:16.889]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:16.889]                         if (muffled) 
[10:33:16.889]                           invokeRestart("muffleWarning")
[10:33:16.889]                       }
[10:33:16.889]                       else if (inherits(cond, "condition")) {
[10:33:16.889]                         if (!is.null(pattern)) {
[10:33:16.889]                           computeRestarts <- base::computeRestarts
[10:33:16.889]                           grepl <- base::grepl
[10:33:16.889]                           restarts <- computeRestarts(cond)
[10:33:16.889]                           for (restart in restarts) {
[10:33:16.889]                             name <- restart$name
[10:33:16.889]                             if (is.null(name)) 
[10:33:16.889]                               next
[10:33:16.889]                             if (!grepl(pattern, name)) 
[10:33:16.889]                               next
[10:33:16.889]                             invokeRestart(restart)
[10:33:16.889]                             muffled <- TRUE
[10:33:16.889]                             break
[10:33:16.889]                           }
[10:33:16.889]                         }
[10:33:16.889]                       }
[10:33:16.889]                       invisible(muffled)
[10:33:16.889]                     }
[10:33:16.889]                     muffleCondition(cond, pattern = "^muffle")
[10:33:16.889]                   }
[10:33:16.889]                 }
[10:33:16.889]                 else {
[10:33:16.889]                   if (TRUE) {
[10:33:16.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:16.889]                     {
[10:33:16.889]                       inherits <- base::inherits
[10:33:16.889]                       invokeRestart <- base::invokeRestart
[10:33:16.889]                       is.null <- base::is.null
[10:33:16.889]                       muffled <- FALSE
[10:33:16.889]                       if (inherits(cond, "message")) {
[10:33:16.889]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:16.889]                         if (muffled) 
[10:33:16.889]                           invokeRestart("muffleMessage")
[10:33:16.889]                       }
[10:33:16.889]                       else if (inherits(cond, "warning")) {
[10:33:16.889]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:16.889]                         if (muffled) 
[10:33:16.889]                           invokeRestart("muffleWarning")
[10:33:16.889]                       }
[10:33:16.889]                       else if (inherits(cond, "condition")) {
[10:33:16.889]                         if (!is.null(pattern)) {
[10:33:16.889]                           computeRestarts <- base::computeRestarts
[10:33:16.889]                           grepl <- base::grepl
[10:33:16.889]                           restarts <- computeRestarts(cond)
[10:33:16.889]                           for (restart in restarts) {
[10:33:16.889]                             name <- restart$name
[10:33:16.889]                             if (is.null(name)) 
[10:33:16.889]                               next
[10:33:16.889]                             if (!grepl(pattern, name)) 
[10:33:16.889]                               next
[10:33:16.889]                             invokeRestart(restart)
[10:33:16.889]                             muffled <- TRUE
[10:33:16.889]                             break
[10:33:16.889]                           }
[10:33:16.889]                         }
[10:33:16.889]                       }
[10:33:16.889]                       invisible(muffled)
[10:33:16.889]                     }
[10:33:16.889]                     muffleCondition(cond, pattern = "^muffle")
[10:33:16.889]                   }
[10:33:16.889]                 }
[10:33:16.889]             }
[10:33:16.889]         }))
[10:33:16.889]     }, error = function(ex) {
[10:33:16.889]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:16.889]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:16.889]                 ...future.rng), started = ...future.startTime, 
[10:33:16.889]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:16.889]             version = "1.8"), class = "FutureResult")
[10:33:16.889]     }, finally = {
[10:33:16.889]         if (!identical(...future.workdir, getwd())) 
[10:33:16.889]             setwd(...future.workdir)
[10:33:16.889]         {
[10:33:16.889]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:16.889]                 ...future.oldOptions$nwarnings <- NULL
[10:33:16.889]             }
[10:33:16.889]             base::options(...future.oldOptions)
[10:33:16.889]             if (.Platform$OS.type == "windows") {
[10:33:16.889]                 old_names <- names(...future.oldEnvVars)
[10:33:16.889]                 envs <- base::Sys.getenv()
[10:33:16.889]                 names <- names(envs)
[10:33:16.889]                 common <- intersect(names, old_names)
[10:33:16.889]                 added <- setdiff(names, old_names)
[10:33:16.889]                 removed <- setdiff(old_names, names)
[10:33:16.889]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:16.889]                   envs[common]]
[10:33:16.889]                 NAMES <- toupper(changed)
[10:33:16.889]                 args <- list()
[10:33:16.889]                 for (kk in seq_along(NAMES)) {
[10:33:16.889]                   name <- changed[[kk]]
[10:33:16.889]                   NAME <- NAMES[[kk]]
[10:33:16.889]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.889]                     next
[10:33:16.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:16.889]                 }
[10:33:16.889]                 NAMES <- toupper(added)
[10:33:16.889]                 for (kk in seq_along(NAMES)) {
[10:33:16.889]                   name <- added[[kk]]
[10:33:16.889]                   NAME <- NAMES[[kk]]
[10:33:16.889]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.889]                     next
[10:33:16.889]                   args[[name]] <- ""
[10:33:16.889]                 }
[10:33:16.889]                 NAMES <- toupper(removed)
[10:33:16.889]                 for (kk in seq_along(NAMES)) {
[10:33:16.889]                   name <- removed[[kk]]
[10:33:16.889]                   NAME <- NAMES[[kk]]
[10:33:16.889]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:16.889]                     next
[10:33:16.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:16.889]                 }
[10:33:16.889]                 if (length(args) > 0) 
[10:33:16.889]                   base::do.call(base::Sys.setenv, args = args)
[10:33:16.889]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:16.889]             }
[10:33:16.889]             else {
[10:33:16.889]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:16.889]             }
[10:33:16.889]             {
[10:33:16.889]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:16.889]                   0L) {
[10:33:16.889]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:16.889]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:16.889]                   base::options(opts)
[10:33:16.889]                 }
[10:33:16.889]                 {
[10:33:16.889]                   {
[10:33:16.889]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:16.889]                     NULL
[10:33:16.889]                   }
[10:33:16.889]                   options(future.plan = NULL)
[10:33:16.889]                   if (is.na(NA_character_)) 
[10:33:16.889]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:16.889]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:16.889]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:16.889]                     .init = FALSE)
[10:33:16.889]                 }
[10:33:16.889]             }
[10:33:16.889]         }
[10:33:16.889]     })
[10:33:16.889]     if (TRUE) {
[10:33:16.889]         base::sink(type = "output", split = FALSE)
[10:33:16.889]         if (TRUE) {
[10:33:16.889]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:16.889]         }
[10:33:16.889]         else {
[10:33:16.889]             ...future.result["stdout"] <- base::list(NULL)
[10:33:16.889]         }
[10:33:16.889]         base::close(...future.stdout)
[10:33:16.889]         ...future.stdout <- NULL
[10:33:16.889]     }
[10:33:16.889]     ...future.result$conditions <- ...future.conditions
[10:33:16.889]     ...future.result$finished <- base::Sys.time()
[10:33:16.889]     ...future.result
[10:33:16.889] }
[10:33:16.892] Exporting 1 global objects (1.01 KiB) to cluster node #1 ...
[10:33:16.892] Exporting ‘x’ (1.01 KiB) to cluster node #1 ...
[10:33:16.892] Exporting ‘x’ (1.01 KiB) to cluster node #1 ... DONE
[10:33:16.892] Exporting 1 global objects (1.01 KiB) to cluster node #1 ... DONE
[10:33:16.893] MultisessionFuture started
[10:33:16.893] - Launch lazy future ... done
[10:33:16.893] run() for ‘MultisessionFuture’ ... done
[10:33:16.893] result() for ClusterFuture ...
[10:33:16.893] receiveMessageFromWorker() for ClusterFuture ...
[10:33:16.893] - Validating connection of MultisessionFuture
[10:33:16.934] - received message: FutureResult
[10:33:16.935] - Received FutureResult
[10:33:16.935] - Erased future from FutureRegistry
[10:33:16.935] result() for ClusterFuture ...
[10:33:16.935] - result already collected: FutureResult
[10:33:16.935] result() for ClusterFuture ... done
[10:33:16.935] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:16.935] result() for ClusterFuture ... done
[10:33:16.935] result() for ClusterFuture ...
[10:33:16.935] - result already collected: FutureResult
[10:33:16.935] result() for ClusterFuture ... done
value(f) = ‘TRUE’
Testing with 2 cores ... DONE
> 
> message("*** Tricky use cases related to globals ... DONE")
*** Tricky use cases related to globals ... DONE
> 
> source("incl/end.R")
[10:33:16.936] plan(): Setting new future strategy stack:
[10:33:16.936] List of future strategies:
[10:33:16.936] 1. FutureStrategy:
[10:33:16.936]    - args: function (..., envir = parent.frame())
[10:33:16.936]    - tweaked: FALSE
[10:33:16.936]    - call: future::plan(oplan)
[10:33:16.937] plan(): nbrOfWorkers() = 1
> 
