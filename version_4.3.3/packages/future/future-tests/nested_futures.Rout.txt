
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:33:36.109] plan(): Setting new future strategy stack:
[10:33:36.109] List of future strategies:
[10:33:36.109] 1. sequential:
[10:33:36.109]    - args: function (..., envir = parent.frame())
[10:33:36.109]    - tweaked: FALSE
[10:33:36.109]    - call: future::plan("sequential")
[10:33:36.123] plan(): nbrOfWorkers() = 1
> 
> strategies <- supportedStrategies()
> 
> message("*** Nested futures ...")
*** Nested futures ...
> 
> for (strategy1 in strategies) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   for (strategy2 in strategies) {
+     message(sprintf("- plan(list('%s', '%s')) ...", strategy1, strategy2))
+     plan(list(a = strategy1, b = strategy2))
+     
+     nested <- plan("list")
+     stopifnot(
+       length(nested) == 2L,
+       all(names(nested) == c("a", "b")),
+       inherits(plan("next"), strategy1)
+     )
+ 
+     x %<-% {
+       a <- 1L
+ 
+       ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+       ## we're exporting the plan() function including its local stack!
+       plan_a <- unclass(future::plan("list"))
+       nested_a <- nested[-1]
+ 
+       stopifnot(
+         length(nested_a) == 1L,
+         length(plan_a) == 1L,
+         inherits(plan_a[[1]], "future"),
+         inherits(future::plan("next"), strategy2)
+       )
+ 
+       ## Attribute 'init' is modified at run time
+       for (kk in seq_along(plan_a)) attr(plan_a[[kk]], "init") <- NULL
+       for (kk in seq_along(nested_a)) attr(nested_a[[kk]], "init") <- NULL
+       stopifnot(all.equal(plan_a, nested_a))
+ 
+       y %<-% {
+         b <- 2L
+         
+         ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+         ## we're exporting the plan() function including its local stack!
+         plan_b <- future::plan("list")
+         nested_b <- nested_a[-1]
+ 
+         stopifnot(
+           length(nested_b) == 0L,
+           length(plan_b) == 1L,
+           inherits(plan_b[[1]], "future"),
+           inherits(future::plan("next"), "sequential")
+         )
+ 
+         list(a = a, nested_a = nested_a, plan_a = plan_a,
+              b = b, nested_b = nested_b, plan_b = plan_b)
+       }
+       y
+     }
+ 
+     str(x)
+ 
+     stopifnot(
+       length(x) == 3 * length(nested),
+       all(names(x) == c("a", "nested_a", "plan_a",
+                         "b", "nested_b", "plan_b")),
+ 
+       x$a == 1L,
+       length(x$nested_a) == 1L,
+       is.list(x$plan_a),
+       length(x$plan_a) == 1L,
+       inherits(x$plan_a[[1]], "future"),
+ 
+       x$b == 2L,
+       length(x$nested_b) == 0L,
+       is.list(x$plan_b),
+       length(x$plan_b) == 1L,
+       inherits(x$plan_b[[1]], "future"),
+       inherits(x$plan_b[[1]], "sequential")
+     )
+ 
+     ## Attribute 'init' is modified at run time
+     for (kk in seq_along(x$plan_a)) attr(x$plan_a[[kk]], "init") <- NULL
+     for (kk in seq_along(nested)) attr(nested[[kk]], "init") <- NULL
+     stopifnot(all.equal(x$plan_a, nested[-1L]))
+ 
+     rm(list = c("nested", "x"))
+ 
+ 
+     ## Nested futures and globals
+     ## In future (<= 1.7.0), the below would produce an error saying
+     ## "Failed to locate global object in the relevant environments: 'a'"
+     ## Related to https://github.com/HenrikBengtsson/globals/issues/35
+     data <- data.frame(a = 1:3, b = 3:1)
+     y_truth <- subset(data, a == 2)
+     f <- future({
+       value(future( subset(data, a == 2) ))
+     })
+     y <- value(f)
+     stopifnot(identical(y, y_truth))
+     
+     message(sprintf("- plan(list('%s', '%s')) ... DONE", strategy1, strategy2))
+   }
+ }
- plan(list('sequential', 'sequential')) ...
[10:33:36.174] plan(): Setting new future strategy stack:
[10:33:36.174] List of future strategies:
[10:33:36.174] 1. sequential:
[10:33:36.174]    - args: function (..., envir = parent.frame())
[10:33:36.174]    - tweaked: FALSE
[10:33:36.174]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:36.174] 2. sequential:
[10:33:36.174]    - args: function (..., envir = parent.frame())
[10:33:36.174]    - tweaked: FALSE
[10:33:36.174]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:36.186] plan(): nbrOfWorkers() = 1
[10:33:36.187] getGlobalsAndPackages() ...
[10:33:36.188] Searching for globals...
[10:33:36.209] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:33:36.209] Searching for globals ... DONE
[10:33:36.210] Resolving globals: FALSE
[10:33:36.211] The total size of the 2 globals is 22.60 KiB (23144 bytes)
[10:33:36.212] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 22.60 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (22.48 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[10:33:36.212] - globals: [2] ‘nested’, ‘strategy2’
[10:33:36.212] - packages: [1] ‘future’
[10:33:36.212] getGlobalsAndPackages() ... DONE
[10:33:36.213] run() for ‘Future’ ...
[10:33:36.213] - state: ‘created’
[10:33:36.213] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:36.214] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:36.214] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:36.214]   - Field: ‘label’
[10:33:36.214]   - Field: ‘local’
[10:33:36.214]   - Field: ‘owner’
[10:33:36.214]   - Field: ‘envir’
[10:33:36.214]   - Field: ‘packages’
[10:33:36.214]   - Field: ‘gc’
[10:33:36.214]   - Field: ‘conditions’
[10:33:36.214]   - Field: ‘expr’
[10:33:36.215]   - Field: ‘uuid’
[10:33:36.215]   - Field: ‘seed’
[10:33:36.215]   - Field: ‘version’
[10:33:36.215]   - Field: ‘result’
[10:33:36.215]   - Field: ‘asynchronous’
[10:33:36.215]   - Field: ‘calls’
[10:33:36.215]   - Field: ‘globals’
[10:33:36.215]   - Field: ‘stdout’
[10:33:36.215]   - Field: ‘earlySignal’
[10:33:36.215]   - Field: ‘lazy’
[10:33:36.215]   - Field: ‘state’
[10:33:36.216] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:36.216] - Launch lazy future ...
[10:33:36.216] Packages needed by the future expression (n = 1): ‘future’
[10:33:36.217] Packages needed by future strategies (n = 1): ‘future’
[10:33:36.217] {
[10:33:36.217]     {
[10:33:36.217]         {
[10:33:36.217]             ...future.startTime <- base::Sys.time()
[10:33:36.217]             {
[10:33:36.217]                 {
[10:33:36.217]                   {
[10:33:36.217]                     {
[10:33:36.217]                       base::local({
[10:33:36.217]                         has_future <- base::requireNamespace("future", 
[10:33:36.217]                           quietly = TRUE)
[10:33:36.217]                         if (has_future) {
[10:33:36.217]                           ns <- base::getNamespace("future")
[10:33:36.217]                           version <- ns[[".package"]][["version"]]
[10:33:36.217]                           if (is.null(version)) 
[10:33:36.217]                             version <- utils::packageVersion("future")
[10:33:36.217]                         }
[10:33:36.217]                         else {
[10:33:36.217]                           version <- NULL
[10:33:36.217]                         }
[10:33:36.217]                         if (!has_future || version < "1.8.0") {
[10:33:36.217]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:36.217]                             "", base::R.version$version.string), 
[10:33:36.217]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:36.217]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:36.217]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:36.217]                               "release", "version")], collapse = " "), 
[10:33:36.217]                             hostname = base::Sys.info()[["nodename"]])
[10:33:36.217]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:36.217]                             info)
[10:33:36.217]                           info <- base::paste(info, collapse = "; ")
[10:33:36.217]                           if (!has_future) {
[10:33:36.217]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:36.217]                               info)
[10:33:36.217]                           }
[10:33:36.217]                           else {
[10:33:36.217]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:36.217]                               info, version)
[10:33:36.217]                           }
[10:33:36.217]                           base::stop(msg)
[10:33:36.217]                         }
[10:33:36.217]                       })
[10:33:36.217]                     }
[10:33:36.217]                     base::local({
[10:33:36.217]                       for (pkg in "future") {
[10:33:36.217]                         base::loadNamespace(pkg)
[10:33:36.217]                         base::library(pkg, character.only = TRUE)
[10:33:36.217]                       }
[10:33:36.217]                     })
[10:33:36.217]                   }
[10:33:36.217]                   ...future.strategy.old <- future::plan("list")
[10:33:36.217]                   options(future.plan = NULL)
[10:33:36.217]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:36.217]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:33:36.217]                   {
[10:33:36.217]                     future <- SequentialFuture(..., envir = envir)
[10:33:36.217]                     if (!future$lazy) 
[10:33:36.217]                       future <- run(future)
[10:33:36.217]                     invisible(future)
[10:33:36.217]                   }), .cleanup = FALSE, .init = FALSE)
[10:33:36.217]                 }
[10:33:36.217]                 ...future.workdir <- getwd()
[10:33:36.217]             }
[10:33:36.217]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:36.217]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:36.217]         }
[10:33:36.217]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:36.217]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:36.217]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:36.217]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:36.217]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:36.217]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:36.217]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:36.217]             base::names(...future.oldOptions))
[10:33:36.217]     }
[10:33:36.217]     if (FALSE) {
[10:33:36.217]     }
[10:33:36.217]     else {
[10:33:36.217]         if (TRUE) {
[10:33:36.217]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:36.217]                 open = "w")
[10:33:36.217]         }
[10:33:36.217]         else {
[10:33:36.217]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:36.217]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:36.217]         }
[10:33:36.217]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:36.217]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:36.217]             base::sink(type = "output", split = FALSE)
[10:33:36.217]             base::close(...future.stdout)
[10:33:36.217]         }, add = TRUE)
[10:33:36.217]     }
[10:33:36.217]     ...future.frame <- base::sys.nframe()
[10:33:36.217]     ...future.conditions <- base::list()
[10:33:36.217]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:36.217]     if (FALSE) {
[10:33:36.217]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:36.217]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:36.217]     }
[10:33:36.217]     ...future.result <- base::tryCatch({
[10:33:36.217]         base::withCallingHandlers({
[10:33:36.217]             ...future.value <- base::withVisible(base::local({
[10:33:36.217]                 a <- 1L
[10:33:36.217]                 plan_a <- unclass(future::plan("list"))
[10:33:36.217]                 nested_a <- nested[-1]
[10:33:36.217]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:33:36.217]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:33:36.217]                   strategy2))
[10:33:36.217]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:33:36.217]                   "init") <- NULL
[10:33:36.217]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:33:36.217]                   "init") <- NULL
[10:33:36.217]                 stopifnot(all.equal(plan_a, nested_a))
[10:33:36.217]                 y %<-% {
[10:33:36.217]                   b <- 2L
[10:33:36.217]                   plan_b <- future::plan("list")
[10:33:36.217]                   nested_b <- nested_a[-1]
[10:33:36.217]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:33:36.217]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:33:36.217]                     "sequential"))
[10:33:36.217]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:33:36.217]                     b = b, nested_b = nested_b, plan_b = plan_b)
[10:33:36.217]                 }
[10:33:36.217]                 y
[10:33:36.217]             }))
[10:33:36.217]             future::FutureResult(value = ...future.value$value, 
[10:33:36.217]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:36.217]                   ...future.rng), globalenv = if (FALSE) 
[10:33:36.217]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:36.217]                     ...future.globalenv.names))
[10:33:36.217]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:36.217]         }, condition = base::local({
[10:33:36.217]             c <- base::c
[10:33:36.217]             inherits <- base::inherits
[10:33:36.217]             invokeRestart <- base::invokeRestart
[10:33:36.217]             length <- base::length
[10:33:36.217]             list <- base::list
[10:33:36.217]             seq.int <- base::seq.int
[10:33:36.217]             signalCondition <- base::signalCondition
[10:33:36.217]             sys.calls <- base::sys.calls
[10:33:36.217]             `[[` <- base::`[[`
[10:33:36.217]             `+` <- base::`+`
[10:33:36.217]             `<<-` <- base::`<<-`
[10:33:36.217]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:36.217]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:36.217]                   3L)]
[10:33:36.217]             }
[10:33:36.217]             function(cond) {
[10:33:36.217]                 is_error <- inherits(cond, "error")
[10:33:36.217]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:36.217]                   NULL)
[10:33:36.217]                 if (is_error) {
[10:33:36.217]                   sessionInformation <- function() {
[10:33:36.217]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:36.217]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:36.217]                       search = base::search(), system = base::Sys.info())
[10:33:36.217]                   }
[10:33:36.217]                   ...future.conditions[[length(...future.conditions) + 
[10:33:36.217]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:36.217]                     cond$call), session = sessionInformation(), 
[10:33:36.217]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:36.217]                   signalCondition(cond)
[10:33:36.217]                 }
[10:33:36.217]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:36.217]                 "immediateCondition"))) {
[10:33:36.217]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:36.217]                   ...future.conditions[[length(...future.conditions) + 
[10:33:36.217]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:36.217]                   if (TRUE && !signal) {
[10:33:36.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:36.217]                     {
[10:33:36.217]                       inherits <- base::inherits
[10:33:36.217]                       invokeRestart <- base::invokeRestart
[10:33:36.217]                       is.null <- base::is.null
[10:33:36.217]                       muffled <- FALSE
[10:33:36.217]                       if (inherits(cond, "message")) {
[10:33:36.217]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:36.217]                         if (muffled) 
[10:33:36.217]                           invokeRestart("muffleMessage")
[10:33:36.217]                       }
[10:33:36.217]                       else if (inherits(cond, "warning")) {
[10:33:36.217]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:36.217]                         if (muffled) 
[10:33:36.217]                           invokeRestart("muffleWarning")
[10:33:36.217]                       }
[10:33:36.217]                       else if (inherits(cond, "condition")) {
[10:33:36.217]                         if (!is.null(pattern)) {
[10:33:36.217]                           computeRestarts <- base::computeRestarts
[10:33:36.217]                           grepl <- base::grepl
[10:33:36.217]                           restarts <- computeRestarts(cond)
[10:33:36.217]                           for (restart in restarts) {
[10:33:36.217]                             name <- restart$name
[10:33:36.217]                             if (is.null(name)) 
[10:33:36.217]                               next
[10:33:36.217]                             if (!grepl(pattern, name)) 
[10:33:36.217]                               next
[10:33:36.217]                             invokeRestart(restart)
[10:33:36.217]                             muffled <- TRUE
[10:33:36.217]                             break
[10:33:36.217]                           }
[10:33:36.217]                         }
[10:33:36.217]                       }
[10:33:36.217]                       invisible(muffled)
[10:33:36.217]                     }
[10:33:36.217]                     muffleCondition(cond, pattern = "^muffle")
[10:33:36.217]                   }
[10:33:36.217]                 }
[10:33:36.217]                 else {
[10:33:36.217]                   if (TRUE) {
[10:33:36.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:36.217]                     {
[10:33:36.217]                       inherits <- base::inherits
[10:33:36.217]                       invokeRestart <- base::invokeRestart
[10:33:36.217]                       is.null <- base::is.null
[10:33:36.217]                       muffled <- FALSE
[10:33:36.217]                       if (inherits(cond, "message")) {
[10:33:36.217]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:36.217]                         if (muffled) 
[10:33:36.217]                           invokeRestart("muffleMessage")
[10:33:36.217]                       }
[10:33:36.217]                       else if (inherits(cond, "warning")) {
[10:33:36.217]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:36.217]                         if (muffled) 
[10:33:36.217]                           invokeRestart("muffleWarning")
[10:33:36.217]                       }
[10:33:36.217]                       else if (inherits(cond, "condition")) {
[10:33:36.217]                         if (!is.null(pattern)) {
[10:33:36.217]                           computeRestarts <- base::computeRestarts
[10:33:36.217]                           grepl <- base::grepl
[10:33:36.217]                           restarts <- computeRestarts(cond)
[10:33:36.217]                           for (restart in restarts) {
[10:33:36.217]                             name <- restart$name
[10:33:36.217]                             if (is.null(name)) 
[10:33:36.217]                               next
[10:33:36.217]                             if (!grepl(pattern, name)) 
[10:33:36.217]                               next
[10:33:36.217]                             invokeRestart(restart)
[10:33:36.217]                             muffled <- TRUE
[10:33:36.217]                             break
[10:33:36.217]                           }
[10:33:36.217]                         }
[10:33:36.217]                       }
[10:33:36.217]                       invisible(muffled)
[10:33:36.217]                     }
[10:33:36.217]                     muffleCondition(cond, pattern = "^muffle")
[10:33:36.217]                   }
[10:33:36.217]                 }
[10:33:36.217]             }
[10:33:36.217]         }))
[10:33:36.217]     }, error = function(ex) {
[10:33:36.217]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:36.217]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:36.217]                 ...future.rng), started = ...future.startTime, 
[10:33:36.217]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:36.217]             version = "1.8"), class = "FutureResult")
[10:33:36.217]     }, finally = {
[10:33:36.217]         if (!identical(...future.workdir, getwd())) 
[10:33:36.217]             setwd(...future.workdir)
[10:33:36.217]         {
[10:33:36.217]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:36.217]                 ...future.oldOptions$nwarnings <- NULL
[10:33:36.217]             }
[10:33:36.217]             base::options(...future.oldOptions)
[10:33:36.217]             if (.Platform$OS.type == "windows") {
[10:33:36.217]                 old_names <- names(...future.oldEnvVars)
[10:33:36.217]                 envs <- base::Sys.getenv()
[10:33:36.217]                 names <- names(envs)
[10:33:36.217]                 common <- intersect(names, old_names)
[10:33:36.217]                 added <- setdiff(names, old_names)
[10:33:36.217]                 removed <- setdiff(old_names, names)
[10:33:36.217]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:36.217]                   envs[common]]
[10:33:36.217]                 NAMES <- toupper(changed)
[10:33:36.217]                 args <- list()
[10:33:36.217]                 for (kk in seq_along(NAMES)) {
[10:33:36.217]                   name <- changed[[kk]]
[10:33:36.217]                   NAME <- NAMES[[kk]]
[10:33:36.217]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.217]                     next
[10:33:36.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:36.217]                 }
[10:33:36.217]                 NAMES <- toupper(added)
[10:33:36.217]                 for (kk in seq_along(NAMES)) {
[10:33:36.217]                   name <- added[[kk]]
[10:33:36.217]                   NAME <- NAMES[[kk]]
[10:33:36.217]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.217]                     next
[10:33:36.217]                   args[[name]] <- ""
[10:33:36.217]                 }
[10:33:36.217]                 NAMES <- toupper(removed)
[10:33:36.217]                 for (kk in seq_along(NAMES)) {
[10:33:36.217]                   name <- removed[[kk]]
[10:33:36.217]                   NAME <- NAMES[[kk]]
[10:33:36.217]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.217]                     next
[10:33:36.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:36.217]                 }
[10:33:36.217]                 if (length(args) > 0) 
[10:33:36.217]                   base::do.call(base::Sys.setenv, args = args)
[10:33:36.217]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:36.217]             }
[10:33:36.217]             else {
[10:33:36.217]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:36.217]             }
[10:33:36.217]             {
[10:33:36.217]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:36.217]                   0L) {
[10:33:36.217]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:36.217]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:36.217]                   base::options(opts)
[10:33:36.217]                 }
[10:33:36.217]                 {
[10:33:36.217]                   {
[10:33:36.217]                     NULL
[10:33:36.217]                     RNGkind("Mersenne-Twister")
[10:33:36.217]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:36.217]                       inherits = FALSE)
[10:33:36.217]                   }
[10:33:36.217]                   options(future.plan = NULL)
[10:33:36.217]                   if (is.na(NA_character_)) 
[10:33:36.217]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:36.217]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:36.217]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:36.217]                     .init = FALSE)
[10:33:36.217]                 }
[10:33:36.217]             }
[10:33:36.217]         }
[10:33:36.217]     })
[10:33:36.217]     if (TRUE) {
[10:33:36.217]         base::sink(type = "output", split = FALSE)
[10:33:36.217]         if (TRUE) {
[10:33:36.217]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:36.217]         }
[10:33:36.217]         else {
[10:33:36.217]             ...future.result["stdout"] <- base::list(NULL)
[10:33:36.217]         }
[10:33:36.217]         base::close(...future.stdout)
[10:33:36.217]         ...future.stdout <- NULL
[10:33:36.217]     }
[10:33:36.217]     ...future.result$conditions <- ...future.conditions
[10:33:36.217]     ...future.result$finished <- base::Sys.time()
[10:33:36.217]     ...future.result
[10:33:36.217] }
[10:33:36.219] assign_globals() ...
[10:33:36.220] List of 2
[10:33:36.220]  $ nested   :List of 2
[10:33:36.220]   ..$ a:function (..., envir = parent.frame())  
[10:33:36.220]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:33:36.220]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:33:36.220]   ..$ b:function (..., envir = parent.frame())  
[10:33:36.220]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:33:36.220]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:33:36.220]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:33:36.220]  $ strategy2: chr "sequential"
[10:33:36.220]  - attr(*, "where")=List of 2
[10:33:36.220]   ..$ nested   :<environment: R_EmptyEnv> 
[10:33:36.220]   ..$ strategy2:<environment: R_EmptyEnv> 
[10:33:36.220]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:36.220]  - attr(*, "resolved")= logi FALSE
[10:33:36.220]  - attr(*, "total_size")= num 23144
[10:33:36.220]  - attr(*, "already-done")= logi TRUE
[10:33:36.226] - copied ‘nested’ to environment
[10:33:36.226] - copied ‘strategy2’ to environment
[10:33:36.226] assign_globals() ... done
[10:33:36.227] plan(): Setting new future strategy stack:
[10:33:36.227] List of future strategies:
[10:33:36.227] 1. sequential:
[10:33:36.227]    - args: function (..., envir = parent.frame())
[10:33:36.227]    - tweaked: FALSE
[10:33:36.227]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:36.227] plan(): nbrOfWorkers() = 1
[10:33:36.263] plan(): Setting new future strategy stack:
[10:33:36.263] List of future strategies:
[10:33:36.263] 1. sequential:
[10:33:36.263]    - args: function (..., envir = parent.frame())
[10:33:36.263]    - tweaked: FALSE
[10:33:36.263]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:36.263] 2. sequential:
[10:33:36.263]    - args: function (..., envir = parent.frame())
[10:33:36.263]    - tweaked: FALSE
[10:33:36.263]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:36.264] plan(): nbrOfWorkers() = 1
[10:33:36.264] SequentialFuture started (and completed)
[10:33:36.264] signalConditions() ...
[10:33:36.264]  - include = ‘immediateCondition’
[10:33:36.264]  - exclude = 
[10:33:36.264]  - resignal = FALSE
[10:33:36.264]  - Number of conditions: 54
[10:33:36.264] signalConditions() ... done
[10:33:36.264] - Launch lazy future ... done
[10:33:36.265] run() for ‘SequentialFuture’ ... done
[10:33:36.265] signalConditions() ...
[10:33:36.265]  - include = ‘immediateCondition’
[10:33:36.265]  - exclude = 
[10:33:36.265]  - resignal = FALSE
[10:33:36.265]  - Number of conditions: 54
[10:33:36.265] signalConditions() ... done
[10:33:36.265] Future state: ‘finished’
[10:33:36.265] signalConditions() ...
[10:33:36.265]  - include = ‘condition’
[10:33:36.266]  - exclude = ‘immediateCondition’
[10:33:36.266]  - resignal = TRUE
[10:33:36.266]  - Number of conditions: 54
[10:33:36.266]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.228] getGlobalsAndPackages() ...
[10:33:36.266]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.229] Searching for globals...
[10:33:36.266]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.246] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[10:33:36.266]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.247] Searching for globals ... DONE
[10:33:36.266]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.247] Resolving globals: FALSE
[10:33:36.266]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.247] The total size of the 3 globals is 22.54 KiB (23080 bytes)
[10:33:36.267]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.248] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 22.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (11.24 KiB of class ‘list’), ‘plan_a’ (11.24 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[10:33:36.267]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.248] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[10:33:36.267]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.248] 
[10:33:36.267]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.248] getGlobalsAndPackages() ... DONE
[10:33:36.267]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.248] run() for ‘Future’ ...
[10:33:36.267]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.248] - state: ‘created’
[10:33:36.267]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.249] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:36.267]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.249] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:36.268]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.249] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:36.268]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.249]   - Field: ‘label’
[10:33:36.268]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.249]   - Field: ‘local’
[10:33:36.268]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.249]   - Field: ‘owner’
[10:33:36.268]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.249]   - Field: ‘envir’
[10:33:36.268]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.250]   - Field: ‘packages’
[10:33:36.268]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.250]   - Field: ‘gc’
[10:33:36.268]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.250]   - Field: ‘conditions’
[10:33:36.269]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.250]   - Field: ‘expr’
[10:33:36.269]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.250]   - Field: ‘uuid’
[10:33:36.269]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.250]   - Field: ‘seed’
[10:33:36.269]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.250]   - Field: ‘version’
[10:33:36.269]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.250]   - Field: ‘result’
[10:33:36.269]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.250]   - Field: ‘asynchronous’
[10:33:36.269]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.250]   - Field: ‘calls’
[10:33:36.270]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.250]   - Field: ‘globals’
[10:33:36.270]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.251]   - Field: ‘stdout’
[10:33:36.270]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.251]   - Field: ‘earlySignal’
[10:33:36.270]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.251]   - Field: ‘lazy’
[10:33:36.270]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.251]   - Field: ‘state’
[10:33:36.270]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.251] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:36.270]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.251] - Launch lazy future ...
[10:33:36.270]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.251] Packages needed by the future expression (n = 0): <none>
[10:33:36.271]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.251] Packages needed by future strategies (n = 0): <none>
[10:33:36.271]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.252] {
[10:33:36.252]     {
[10:33:36.252]         {
[10:33:36.252]             ...future.startTime <- base::Sys.time()
[10:33:36.252]             {
[10:33:36.252]                 {
[10:33:36.252]                   {
[10:33:36.252]                     base::local({
[10:33:36.252]                       has_future <- base::requireNamespace("future", 
[10:33:36.252]                         quietly = TRUE)
[10:33:36.252]                       if (has_future) {
[10:33:36.252]                         ns <- base::getNamespace("future")
[10:33:36.252]                         version <- ns[[".package"]][["version"]]
[10:33:36.252]                         if (is.null(version)) 
[10:33:36.252]                           version <- utils::packageVersion("future")
[10:33:36.252]                       }
[10:33:36.252]                       else {
[10:33:36.252]                         version <- NULL
[10:33:36.252]                       }
[10:33:36.252]                       if (!has_future || version < "1.8.0") {
[10:33:36.252]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:36.252]                           "", base::R.version$version.string), 
[10:33:36.252]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:36.252]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:36.252]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:36.252]                             "release", "version")], collapse = " "), 
[10:33:36.252]                           hostname = base::Sys.info()[["nodename"]])
[10:33:36.252]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:36.252]                           info)
[10:33:36.252]                         info <- base::paste(info, collapse = "; ")
[10:33:36.252]                         if (!has_future) {
[10:33:36.252]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:36.252]                             info)
[10:33:36.252]                         }
[10:33:36.252]                         else {
[10:33:36.252]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:36.252]                             info, version)
[10:33:36.252]                         }
[10:33:36.252]                         base::stop(msg)
[10:33:36.252]                       }
[10:33:36.252]                     })
[10:33:36.252]                   }
[10:33:36.252]                   ...future.strategy.old <- future::plan("list")
[10:33:36.252]                   options(future.plan = NULL)
[10:33:36.252]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:36.252]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:36.252]                 }
[10:33:36.252]                 ...future.workdir <- getwd()
[10:33:36.252]             }
[10:33:36.252]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:36.252]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:36.252]         }
[10:33:36.252]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:36.252]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:36.252]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:36.252]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:36.252]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:36.252]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:36.252]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:36.252]             base::names(...future.oldOptions))
[10:33:36.252]     }
[10:33:36.252]     if (FALSE) {
[10:33:36.252]     }
[10:33:36.252]     else {
[10:33:36.252]         if (TRUE) {
[10:33:36.252]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:36.252]                 open = "w")
[10:33:36.252]         }
[10:33:36.252]         else {
[10:33:36.252]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:36.252]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:36.252]         }
[10:33:36.252]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:36.252]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:36.252]             base::sink(type = "output", split = FALSE)
[10:33:36.252]             base::close(...future.stdout)
[10:33:36.252]         }, add = TRUE)
[10:33:36.252]     }
[10:33:36.252]     ...future.frame <- base::sys.nframe()
[10:33:36.252]     ...future.conditions <- base::list()
[10:33:36.252]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:36.252]     if (FALSE) {
[10:33:36.252]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:36.252]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:36.252]     }
[10:33:36.252]     ...future.result <- base::tryCatch({
[10:33:36.252]         base::withCallingHandlers({
[10:33:36.252]             ...future.value <- base::withVisible(base::local({
[10:33:36.252]                 b <- 2L
[10:33:36.252]                 plan_b <- future::plan("list")
[10:33:36.252]                 nested_b <- nested_a[-1]
[10:33:36.252]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:33:36.252]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:33:36.252]                   "sequential"))
[10:33:36.252]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:33:36.252]                   b = b, nested_b = nested_b, plan_b = plan_b)
[10:33:36.252]             }))
[10:33:36.252]             future::FutureResult(value = ...future.value$value, 
[10:33:36.252]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:36.252]                   ...future.rng), globalenv = if (FALSE) 
[10:33:36.252]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:36.252]                     ...future.globalenv.names))
[10:33:36.252]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:36.252]         }, condition = base::local({
[10:33:36.252]             c <- base::c
[10:33:36.252]             inherits <- base::inherits
[10:33:36.252]             invokeRestart <- base::invokeRestart
[10:33:36.252]             length <- base::length
[10:33:36.252]             list <- base::list
[10:33:36.252]             seq.int <- base::seq.int
[10:33:36.252]             signalCondition <- base::signalCondition
[10:33:36.252]             sys.calls <- base::sys.calls
[10:33:36.252]             `[[` <- base::`[[`
[10:33:36.252]             `+` <- base::`+`
[10:33:36.252]             `<<-` <- base::`<<-`
[10:33:36.252]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:36.252]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:36.252]                   3L)]
[10:33:36.252]             }
[10:33:36.252]             function(cond) {
[10:33:36.252]                 is_error <- inherits(cond, "error")
[10:33:36.252]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:36.252]                   NULL)
[10:33:36.252]                 if (is_error) {
[10:33:36.252]                   sessionInformation <- function() {
[10:33:36.252]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:36.252]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:36.252]                       search = base::search(), system = base::Sys.info())
[10:33:36.252]                   }
[10:33:36.252]                   ...future.conditions[[length(...future.conditions) + 
[10:33:36.252]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:36.252]                     cond$call), session = sessionInformation(), 
[10:33:36.252]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:36.252]                   signalCondition(cond)
[10:33:36.252]                 }
[10:33:36.252]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:36.252]                 "immediateCondition"))) {
[10:33:36.252]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:36.252]                   ...future.conditions[[length(...future.conditions) + 
[10:33:36.252]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:36.252]                   if (TRUE && !signal) {
[10:33:36.252]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:36.252]                     {
[10:33:36.252]                       inherits <- base::inherits
[10:33:36.252]                       invokeRestart <- base::invokeRestart
[10:33:36.252]                       is.null <- base::is.null
[10:33:36.252]                       muffled <- FALSE
[10:33:36.252]                       if (inherits(cond, "message")) {
[10:33:36.252]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:36.252]                         if (muffled) 
[10:33:36.252]                           invokeRestart("muffleMessage")
[10:33:36.252]                       }
[10:33:36.252]                       else if (inherits(cond, "warning")) {
[10:33:36.252]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:36.252]                         if (muffled) 
[10:33:36.252]                           invokeRestart("muffleWarning")
[10:33:36.252]                       }
[10:33:36.252]                       else if (inherits(cond, "condition")) {
[10:33:36.252]                         if (!is.null(pattern)) {
[10:33:36.252]                           computeRestarts <- base::computeRestarts
[10:33:36.252]                           grepl <- base::grepl
[10:33:36.252]                           restarts <- computeRestarts(cond)
[10:33:36.252]                           for (restart in restarts) {
[10:33:36.252]                             name <- restart$name
[10:33:36.252]                             if (is.null(name)) 
[10:33:36.252]                               next
[10:33:36.252]                             if (!grepl(pattern, name)) 
[10:33:36.252]                               next
[10:33:36.252]                             invokeRestart(restart)
[10:33:36.252]                             muffled <- TRUE
[10:33:36.252]                             break
[10:33:36.252]                           }
[10:33:36.252]                         }
[10:33:36.252]                       }
[10:33:36.252]                       invisible(muffled)
[10:33:36.252]                     }
[10:33:36.252]                     muffleCondition(cond, pattern = "^muffle")
[10:33:36.252]                   }
[10:33:36.252]                 }
[10:33:36.252]                 else {
[10:33:36.252]                   if (TRUE) {
[10:33:36.252]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:36.252]                     {
[10:33:36.252]                       inherits <- base::inherits
[10:33:36.252]                       invokeRestart <- base::invokeRestart
[10:33:36.252]                       is.null <- base::is.null
[10:33:36.252]                       muffled <- FALSE
[10:33:36.252]                       if (inherits(cond, "message")) {
[10:33:36.252]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:36.252]                         if (muffled) 
[10:33:36.252]                           invokeRestart("muffleMessage")
[10:33:36.252]                       }
[10:33:36.252]                       else if (inherits(cond, "warning")) {
[10:33:36.252]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:36.252]                         if (muffled) 
[10:33:36.252]                           invokeRestart("muffleWarning")
[10:33:36.252]                       }
[10:33:36.252]                       else if (inherits(cond, "condition")) {
[10:33:36.252]                         if (!is.null(pattern)) {
[10:33:36.252]                           computeRestarts <- base::computeRestarts
[10:33:36.252]                           grepl <- base::grepl
[10:33:36.252]                           restarts <- computeRestarts(cond)
[10:33:36.252]                           for (restart in restarts) {
[10:33:36.252]                             name <- restart$name
[10:33:36.252]                             if (is.null(name)) 
[10:33:36.252]                               next
[10:33:36.252]                             if (!grepl(pattern, name)) 
[10:33:36.252]                               next
[10:33:36.252]                             invokeRestart(restart)
[10:33:36.252]                             muffled <- TRUE
[10:33:36.252]                             break
[10:33:36.252]                           }
[10:33:36.252]                         }
[10:33:36.252]                       }
[10:33:36.252]                       invisible(muffled)
[10:33:36.252]                     }
[10:33:36.252]                     muffleCondition(cond, pattern = "^muffle")
[10:33:36.252]                   }
[10:33:36.252]                 }
[10:33:36.252]             }
[10:33:36.252]         }))
[10:33:36.252]     }, error = function(ex) {
[10:33:36.252]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:36.252]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:36.252]                 ...future.rng), started = ...future.startTime, 
[10:33:36.252]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:36.252]             version = "1.8"), class = "FutureResult")
[10:33:36.252]     }, finally = {
[10:33:36.252]         if (!identical(...future.workdir, getwd())) 
[10:33:36.252]             setwd(...future.workdir)
[10:33:36.252]         {
[10:33:36.252]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:36.252]                 ...future.oldOptions$nwarnings <- NULL
[10:33:36.252]             }
[10:33:36.252]             base::options(...future.oldOptions)
[10:33:36.252]             if (.Platform$OS.type == "windows") {
[10:33:36.252]                 old_names <- names(...future.oldEnvVars)
[10:33:36.252]                 envs <- base::Sys.getenv()
[10:33:36.252]                 names <- names(envs)
[10:33:36.252]                 common <- intersect(names, old_names)
[10:33:36.252]                 added <- setdiff(names, old_names)
[10:33:36.252]                 removed <- setdiff(old_names, names)
[10:33:36.252]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:36.252]                   envs[common]]
[10:33:36.252]                 NAMES <- toupper(changed)
[10:33:36.252]                 args <- list()
[10:33:36.252]                 for (kk in seq_along(NAMES)) {
[10:33:36.252]                   name <- changed[[kk]]
[10:33:36.252]                   NAME <- NAMES[[kk]]
[10:33:36.252]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.252]                     next
[10:33:36.252]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:36.252]                 }
[10:33:36.252]                 NAMES <- toupper(added)
[10:33:36.252]                 for (kk in seq_along(NAMES)) {
[10:33:36.252]                   name <- added[[kk]]
[10:33:36.252]                   NAME <- NAMES[[kk]]
[10:33:36.252]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.252]                     next
[10:33:36.252]                   args[[name]] <- ""
[10:33:36.252]                 }
[10:33:36.252]                 NAMES <- toupper(removed)
[10:33:36.252]                 for (kk in seq_along(NAMES)) {
[10:33:36.252]                   name <- removed[[kk]]
[10:33:36.252]                   NAME <- NAMES[[kk]]
[10:33:36.252]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.252]                     next
[10:33:36.252]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:36.252]                 }
[10:33:36.252]                 if (length(args) > 0) 
[10:33:36.252]                   base::do.call(base::Sys.setenv, args = args)
[10:33:36.252]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:36.252]             }
[10:33:36.252]             else {
[10:33:36.252]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:36.252]             }
[10:33:36.252]             {
[10:33:36.252]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:36.252]                   0L) {
[10:33:36.252]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:36.252]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:36.252]                   base::options(opts)
[10:33:36.252]                 }
[10:33:36.252]                 {
[10:33:36.252]                   {
[10:33:36.252]                     NULL
[10:33:36.252]                     RNGkind("Mersenne-Twister")
[10:33:36.252]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:36.252]                       inherits = FALSE)
[10:33:36.252]                   }
[10:33:36.252]                   options(future.plan = NULL)
[10:33:36.252]                   if (is.na(NA_character_)) 
[10:33:36.252]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:36.252]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:36.252]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:36.252]                     .init = FALSE)
[10:33:36.252]                 }
[10:33:36.252]             }
[10:33:36.252]         }
[10:33:36.252]     })
[10:33:36.252]     if (TRUE) {
[10:33:36.252]         base::sink(type = "output", split = FALSE)
[10:33:36.252]         if (TRUE) {
[10:33:36.252]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:36.252]         }
[10:33:36.252]         else {
[10:33:36.252]             ...future.result["stdout"] <- base::list(NULL)
[10:33:36.252]         }
[10:33:36.252]         base::close(...future.stdout)
[10:33:36.252]         ...future.stdout <- NULL
[10:33:36.252]     }
[10:33:36.252]     ...future.result$conditions <- ...future.conditions
[10:33:36.252]     ...future.result$finished <- base::Sys.time()
[10:33:36.252]     ...future.result
[10:33:36.252] }
[10:33:36.271]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.253] assign_globals() ...
[10:33:36.271]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.253] List of 3
[10:33:36.253]  $ nested_a:List of 1
[10:33:36.253]   ..$ b:function (..., envir = parent.frame())  
[10:33:36.253]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:33:36.253]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:33:36.253]  $ a       : int 1
[10:33:36.253]  $ plan_a  :List of 1
[10:33:36.253]   ..$ b:function (..., envir = parent.frame())  
[10:33:36.253]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:33:36.253]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:33:36.253]  - attr(*, "where")=List of 3
[10:33:36.253]   ..$ nested_a:<environment: R_EmptyEnv> 
[10:33:36.253]   ..$ a       :<environment: R_EmptyEnv> 
[10:33:36.253]   ..$ plan_a  :<environment: R_EmptyEnv> 
[10:33:36.253]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:36.253]  - attr(*, "resolved")= logi FALSE
[10:33:36.253]  - attr(*, "total_size")= num 23080
[10:33:36.253]  - attr(*, "already-done")= logi TRUE
[10:33:36.271]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.259] - copied ‘nested_a’ to environment
[10:33:36.271]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.259] - copied ‘a’ to environment
[10:33:36.271]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.259] - copied ‘plan_a’ to environment
[10:33:36.271]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.259] assign_globals() ... done
[10:33:36.272]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.259] plan(): Setting new future strategy stack:
[10:33:36.272]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.260] List of future strategies:
[10:33:36.260] 1. sequential:
[10:33:36.260]    - args: function (..., envir = parent.frame())
[10:33:36.260]    - tweaked: FALSE
[10:33:36.260]    - call: NULL
[10:33:36.272]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.260] plan(): nbrOfWorkers() = 1
[10:33:36.272]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.261] plan(): Setting new future strategy stack:
[10:33:36.272]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.261] List of future strategies:
[10:33:36.261] 1. sequential:
[10:33:36.261]    - args: function (..., envir = parent.frame())
[10:33:36.261]    - tweaked: FALSE
[10:33:36.261]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:36.272]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.262] plan(): nbrOfWorkers() = 1
[10:33:36.272]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.262] SequentialFuture started (and completed)
[10:33:36.272]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.262] - Launch lazy future ... done
[10:33:36.273]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.262] run() for ‘SequentialFuture’ ... done
[10:33:36.273] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:33:36.278] getGlobalsAndPackages() ...
[10:33:36.278] Searching for globals...
[10:33:36.280] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:33:36.280] Searching for globals ... DONE
[10:33:36.280] Resolving globals: FALSE
[10:33:36.280] The total size of the 1 globals is 128 bytes (128 bytes)
[10:33:36.281] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:33:36.281] - globals: [1] ‘data’
[10:33:36.281] - packages: [1] ‘future’
[10:33:36.281] getGlobalsAndPackages() ... DONE
[10:33:36.281] run() for ‘Future’ ...
[10:33:36.281] - state: ‘created’
[10:33:36.282] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:36.282] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:36.282] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:36.282]   - Field: ‘label’
[10:33:36.282]   - Field: ‘local’
[10:33:36.282]   - Field: ‘owner’
[10:33:36.282]   - Field: ‘envir’
[10:33:36.282]   - Field: ‘packages’
[10:33:36.282]   - Field: ‘gc’
[10:33:36.283]   - Field: ‘conditions’
[10:33:36.283]   - Field: ‘expr’
[10:33:36.283]   - Field: ‘uuid’
[10:33:36.283]   - Field: ‘seed’
[10:33:36.283]   - Field: ‘version’
[10:33:36.283]   - Field: ‘result’
[10:33:36.283]   - Field: ‘asynchronous’
[10:33:36.283]   - Field: ‘calls’
[10:33:36.283]   - Field: ‘globals’
[10:33:36.283]   - Field: ‘stdout’
[10:33:36.283]   - Field: ‘earlySignal’
[10:33:36.283]   - Field: ‘lazy’
[10:33:36.284]   - Field: ‘state’
[10:33:36.284] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:36.284] - Launch lazy future ...
[10:33:36.284] Packages needed by the future expression (n = 1): ‘future’
[10:33:36.284] Packages needed by future strategies (n = 1): ‘future’
[10:33:36.284] {
[10:33:36.284]     {
[10:33:36.284]         {
[10:33:36.284]             ...future.startTime <- base::Sys.time()
[10:33:36.284]             {
[10:33:36.284]                 {
[10:33:36.284]                   {
[10:33:36.284]                     {
[10:33:36.284]                       base::local({
[10:33:36.284]                         has_future <- base::requireNamespace("future", 
[10:33:36.284]                           quietly = TRUE)
[10:33:36.284]                         if (has_future) {
[10:33:36.284]                           ns <- base::getNamespace("future")
[10:33:36.284]                           version <- ns[[".package"]][["version"]]
[10:33:36.284]                           if (is.null(version)) 
[10:33:36.284]                             version <- utils::packageVersion("future")
[10:33:36.284]                         }
[10:33:36.284]                         else {
[10:33:36.284]                           version <- NULL
[10:33:36.284]                         }
[10:33:36.284]                         if (!has_future || version < "1.8.0") {
[10:33:36.284]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:36.284]                             "", base::R.version$version.string), 
[10:33:36.284]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:36.284]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:36.284]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:36.284]                               "release", "version")], collapse = " "), 
[10:33:36.284]                             hostname = base::Sys.info()[["nodename"]])
[10:33:36.284]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:36.284]                             info)
[10:33:36.284]                           info <- base::paste(info, collapse = "; ")
[10:33:36.284]                           if (!has_future) {
[10:33:36.284]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:36.284]                               info)
[10:33:36.284]                           }
[10:33:36.284]                           else {
[10:33:36.284]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:36.284]                               info, version)
[10:33:36.284]                           }
[10:33:36.284]                           base::stop(msg)
[10:33:36.284]                         }
[10:33:36.284]                       })
[10:33:36.284]                     }
[10:33:36.284]                     base::local({
[10:33:36.284]                       for (pkg in "future") {
[10:33:36.284]                         base::loadNamespace(pkg)
[10:33:36.284]                         base::library(pkg, character.only = TRUE)
[10:33:36.284]                       }
[10:33:36.284]                     })
[10:33:36.284]                   }
[10:33:36.284]                   ...future.strategy.old <- future::plan("list")
[10:33:36.284]                   options(future.plan = NULL)
[10:33:36.284]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:36.284]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:33:36.284]                   {
[10:33:36.284]                     future <- SequentialFuture(..., envir = envir)
[10:33:36.284]                     if (!future$lazy) 
[10:33:36.284]                       future <- run(future)
[10:33:36.284]                     invisible(future)
[10:33:36.284]                   }), .cleanup = FALSE, .init = FALSE)
[10:33:36.284]                 }
[10:33:36.284]                 ...future.workdir <- getwd()
[10:33:36.284]             }
[10:33:36.284]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:36.284]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:36.284]         }
[10:33:36.284]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:36.284]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:36.284]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:36.284]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:36.284]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:36.284]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:36.284]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:36.284]             base::names(...future.oldOptions))
[10:33:36.284]     }
[10:33:36.284]     if (FALSE) {
[10:33:36.284]     }
[10:33:36.284]     else {
[10:33:36.284]         if (TRUE) {
[10:33:36.284]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:36.284]                 open = "w")
[10:33:36.284]         }
[10:33:36.284]         else {
[10:33:36.284]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:36.284]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:36.284]         }
[10:33:36.284]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:36.284]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:36.284]             base::sink(type = "output", split = FALSE)
[10:33:36.284]             base::close(...future.stdout)
[10:33:36.284]         }, add = TRUE)
[10:33:36.284]     }
[10:33:36.284]     ...future.frame <- base::sys.nframe()
[10:33:36.284]     ...future.conditions <- base::list()
[10:33:36.284]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:36.284]     if (FALSE) {
[10:33:36.284]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:36.284]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:36.284]     }
[10:33:36.284]     ...future.result <- base::tryCatch({
[10:33:36.284]         base::withCallingHandlers({
[10:33:36.284]             ...future.value <- base::withVisible(base::local({
[10:33:36.284]                 value(future(subset(data, a == 2)))
[10:33:36.284]             }))
[10:33:36.284]             future::FutureResult(value = ...future.value$value, 
[10:33:36.284]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:36.284]                   ...future.rng), globalenv = if (FALSE) 
[10:33:36.284]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:36.284]                     ...future.globalenv.names))
[10:33:36.284]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:36.284]         }, condition = base::local({
[10:33:36.284]             c <- base::c
[10:33:36.284]             inherits <- base::inherits
[10:33:36.284]             invokeRestart <- base::invokeRestart
[10:33:36.284]             length <- base::length
[10:33:36.284]             list <- base::list
[10:33:36.284]             seq.int <- base::seq.int
[10:33:36.284]             signalCondition <- base::signalCondition
[10:33:36.284]             sys.calls <- base::sys.calls
[10:33:36.284]             `[[` <- base::`[[`
[10:33:36.284]             `+` <- base::`+`
[10:33:36.284]             `<<-` <- base::`<<-`
[10:33:36.284]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:36.284]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:36.284]                   3L)]
[10:33:36.284]             }
[10:33:36.284]             function(cond) {
[10:33:36.284]                 is_error <- inherits(cond, "error")
[10:33:36.284]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:36.284]                   NULL)
[10:33:36.284]                 if (is_error) {
[10:33:36.284]                   sessionInformation <- function() {
[10:33:36.284]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:36.284]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:36.284]                       search = base::search(), system = base::Sys.info())
[10:33:36.284]                   }
[10:33:36.284]                   ...future.conditions[[length(...future.conditions) + 
[10:33:36.284]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:36.284]                     cond$call), session = sessionInformation(), 
[10:33:36.284]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:36.284]                   signalCondition(cond)
[10:33:36.284]                 }
[10:33:36.284]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:36.284]                 "immediateCondition"))) {
[10:33:36.284]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:36.284]                   ...future.conditions[[length(...future.conditions) + 
[10:33:36.284]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:36.284]                   if (TRUE && !signal) {
[10:33:36.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:36.284]                     {
[10:33:36.284]                       inherits <- base::inherits
[10:33:36.284]                       invokeRestart <- base::invokeRestart
[10:33:36.284]                       is.null <- base::is.null
[10:33:36.284]                       muffled <- FALSE
[10:33:36.284]                       if (inherits(cond, "message")) {
[10:33:36.284]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:36.284]                         if (muffled) 
[10:33:36.284]                           invokeRestart("muffleMessage")
[10:33:36.284]                       }
[10:33:36.284]                       else if (inherits(cond, "warning")) {
[10:33:36.284]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:36.284]                         if (muffled) 
[10:33:36.284]                           invokeRestart("muffleWarning")
[10:33:36.284]                       }
[10:33:36.284]                       else if (inherits(cond, "condition")) {
[10:33:36.284]                         if (!is.null(pattern)) {
[10:33:36.284]                           computeRestarts <- base::computeRestarts
[10:33:36.284]                           grepl <- base::grepl
[10:33:36.284]                           restarts <- computeRestarts(cond)
[10:33:36.284]                           for (restart in restarts) {
[10:33:36.284]                             name <- restart$name
[10:33:36.284]                             if (is.null(name)) 
[10:33:36.284]                               next
[10:33:36.284]                             if (!grepl(pattern, name)) 
[10:33:36.284]                               next
[10:33:36.284]                             invokeRestart(restart)
[10:33:36.284]                             muffled <- TRUE
[10:33:36.284]                             break
[10:33:36.284]                           }
[10:33:36.284]                         }
[10:33:36.284]                       }
[10:33:36.284]                       invisible(muffled)
[10:33:36.284]                     }
[10:33:36.284]                     muffleCondition(cond, pattern = "^muffle")
[10:33:36.284]                   }
[10:33:36.284]                 }
[10:33:36.284]                 else {
[10:33:36.284]                   if (TRUE) {
[10:33:36.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:36.284]                     {
[10:33:36.284]                       inherits <- base::inherits
[10:33:36.284]                       invokeRestart <- base::invokeRestart
[10:33:36.284]                       is.null <- base::is.null
[10:33:36.284]                       muffled <- FALSE
[10:33:36.284]                       if (inherits(cond, "message")) {
[10:33:36.284]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:36.284]                         if (muffled) 
[10:33:36.284]                           invokeRestart("muffleMessage")
[10:33:36.284]                       }
[10:33:36.284]                       else if (inherits(cond, "warning")) {
[10:33:36.284]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:36.284]                         if (muffled) 
[10:33:36.284]                           invokeRestart("muffleWarning")
[10:33:36.284]                       }
[10:33:36.284]                       else if (inherits(cond, "condition")) {
[10:33:36.284]                         if (!is.null(pattern)) {
[10:33:36.284]                           computeRestarts <- base::computeRestarts
[10:33:36.284]                           grepl <- base::grepl
[10:33:36.284]                           restarts <- computeRestarts(cond)
[10:33:36.284]                           for (restart in restarts) {
[10:33:36.284]                             name <- restart$name
[10:33:36.284]                             if (is.null(name)) 
[10:33:36.284]                               next
[10:33:36.284]                             if (!grepl(pattern, name)) 
[10:33:36.284]                               next
[10:33:36.284]                             invokeRestart(restart)
[10:33:36.284]                             muffled <- TRUE
[10:33:36.284]                             break
[10:33:36.284]                           }
[10:33:36.284]                         }
[10:33:36.284]                       }
[10:33:36.284]                       invisible(muffled)
[10:33:36.284]                     }
[10:33:36.284]                     muffleCondition(cond, pattern = "^muffle")
[10:33:36.284]                   }
[10:33:36.284]                 }
[10:33:36.284]             }
[10:33:36.284]         }))
[10:33:36.284]     }, error = function(ex) {
[10:33:36.284]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:36.284]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:36.284]                 ...future.rng), started = ...future.startTime, 
[10:33:36.284]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:36.284]             version = "1.8"), class = "FutureResult")
[10:33:36.284]     }, finally = {
[10:33:36.284]         if (!identical(...future.workdir, getwd())) 
[10:33:36.284]             setwd(...future.workdir)
[10:33:36.284]         {
[10:33:36.284]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:36.284]                 ...future.oldOptions$nwarnings <- NULL
[10:33:36.284]             }
[10:33:36.284]             base::options(...future.oldOptions)
[10:33:36.284]             if (.Platform$OS.type == "windows") {
[10:33:36.284]                 old_names <- names(...future.oldEnvVars)
[10:33:36.284]                 envs <- base::Sys.getenv()
[10:33:36.284]                 names <- names(envs)
[10:33:36.284]                 common <- intersect(names, old_names)
[10:33:36.284]                 added <- setdiff(names, old_names)
[10:33:36.284]                 removed <- setdiff(old_names, names)
[10:33:36.284]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:36.284]                   envs[common]]
[10:33:36.284]                 NAMES <- toupper(changed)
[10:33:36.284]                 args <- list()
[10:33:36.284]                 for (kk in seq_along(NAMES)) {
[10:33:36.284]                   name <- changed[[kk]]
[10:33:36.284]                   NAME <- NAMES[[kk]]
[10:33:36.284]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.284]                     next
[10:33:36.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:36.284]                 }
[10:33:36.284]                 NAMES <- toupper(added)
[10:33:36.284]                 for (kk in seq_along(NAMES)) {
[10:33:36.284]                   name <- added[[kk]]
[10:33:36.284]                   NAME <- NAMES[[kk]]
[10:33:36.284]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.284]                     next
[10:33:36.284]                   args[[name]] <- ""
[10:33:36.284]                 }
[10:33:36.284]                 NAMES <- toupper(removed)
[10:33:36.284]                 for (kk in seq_along(NAMES)) {
[10:33:36.284]                   name <- removed[[kk]]
[10:33:36.284]                   NAME <- NAMES[[kk]]
[10:33:36.284]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.284]                     next
[10:33:36.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:36.284]                 }
[10:33:36.284]                 if (length(args) > 0) 
[10:33:36.284]                   base::do.call(base::Sys.setenv, args = args)
[10:33:36.284]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:36.284]             }
[10:33:36.284]             else {
[10:33:36.284]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:36.284]             }
[10:33:36.284]             {
[10:33:36.284]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:36.284]                   0L) {
[10:33:36.284]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:36.284]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:36.284]                   base::options(opts)
[10:33:36.284]                 }
[10:33:36.284]                 {
[10:33:36.284]                   {
[10:33:36.284]                     NULL
[10:33:36.284]                     RNGkind("Mersenne-Twister")
[10:33:36.284]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:36.284]                       inherits = FALSE)
[10:33:36.284]                   }
[10:33:36.284]                   options(future.plan = NULL)
[10:33:36.284]                   if (is.na(NA_character_)) 
[10:33:36.284]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:36.284]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:36.284]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:36.284]                     .init = FALSE)
[10:33:36.284]                 }
[10:33:36.284]             }
[10:33:36.284]         }
[10:33:36.284]     })
[10:33:36.284]     if (TRUE) {
[10:33:36.284]         base::sink(type = "output", split = FALSE)
[10:33:36.284]         if (TRUE) {
[10:33:36.284]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:36.284]         }
[10:33:36.284]         else {
[10:33:36.284]             ...future.result["stdout"] <- base::list(NULL)
[10:33:36.284]         }
[10:33:36.284]         base::close(...future.stdout)
[10:33:36.284]         ...future.stdout <- NULL
[10:33:36.284]     }
[10:33:36.284]     ...future.result$conditions <- ...future.conditions
[10:33:36.284]     ...future.result$finished <- base::Sys.time()
[10:33:36.284]     ...future.result
[10:33:36.284] }
[10:33:36.286] assign_globals() ...
[10:33:36.286] List of 1
[10:33:36.286]  $ data:'data.frame':	3 obs. of  2 variables:
[10:33:36.286]   ..$ a: int [1:3] 1 2 3
[10:33:36.286]   ..$ b: int [1:3] 3 2 1
[10:33:36.286]  - attr(*, "where")=List of 1
[10:33:36.286]   ..$ data:<environment: R_EmptyEnv> 
[10:33:36.286]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:36.286]  - attr(*, "resolved")= logi FALSE
[10:33:36.286]  - attr(*, "total_size")= num 128
[10:33:36.286]  - attr(*, "already-done")= logi TRUE
[10:33:36.289] - copied ‘data’ to environment
[10:33:36.289] assign_globals() ... done
[10:33:36.290] plan(): Setting new future strategy stack:
[10:33:36.290] List of future strategies:
[10:33:36.290] 1. sequential:
[10:33:36.290]    - args: function (..., envir = parent.frame())
[10:33:36.290]    - tweaked: FALSE
[10:33:36.290]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:36.290] plan(): nbrOfWorkers() = 1
[10:33:36.318] plan(): Setting new future strategy stack:
[10:33:36.318] List of future strategies:
[10:33:36.318] 1. sequential:
[10:33:36.318]    - args: function (..., envir = parent.frame())
[10:33:36.318]    - tweaked: FALSE
[10:33:36.318]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:36.318] 2. sequential:
[10:33:36.318]    - args: function (..., envir = parent.frame())
[10:33:36.318]    - tweaked: FALSE
[10:33:36.318]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:36.319] plan(): nbrOfWorkers() = 1
[10:33:36.319] SequentialFuture started (and completed)
[10:33:36.319] signalConditions() ...
[10:33:36.319]  - include = ‘immediateCondition’
[10:33:36.319]  - exclude = 
[10:33:36.319]  - resignal = FALSE
[10:33:36.319]  - Number of conditions: 52
[10:33:36.319] signalConditions() ... done
[10:33:36.319] - Launch lazy future ... done
[10:33:36.319] run() for ‘SequentialFuture’ ... done
[10:33:36.320] signalConditions() ...
[10:33:36.320]  - include = ‘immediateCondition’
[10:33:36.320]  - exclude = 
[10:33:36.320]  - resignal = FALSE
[10:33:36.320]  - Number of conditions: 52
[10:33:36.320] signalConditions() ... done
[10:33:36.320] Future state: ‘finished’
[10:33:36.320] signalConditions() ...
[10:33:36.320]  - include = ‘condition’
[10:33:36.320]  - exclude = ‘immediateCondition’
[10:33:36.321]  - resignal = TRUE
[10:33:36.321]  - Number of conditions: 52
[10:33:36.321]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.291] getGlobalsAndPackages() ...
[10:33:36.321]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.291] Searching for globals...
[10:33:36.321]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.305] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[10:33:36.321]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.305] Searching for globals ... DONE
[10:33:36.321]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.305] Resolving globals: FALSE
[10:33:36.321]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.306] The total size of the 1 globals is 128 bytes (128 bytes)
[10:33:36.322]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.306] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:33:36.323]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.306] - globals: [1] ‘data’
[10:33:36.323]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.306] 
[10:33:36.323]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.306] getGlobalsAndPackages() ... DONE
[10:33:36.323]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.307] run() for ‘Future’ ...
[10:33:36.323]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.307] - state: ‘created’
[10:33:36.323]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.307] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:36.324]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.307] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:36.324]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.307] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:36.324]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.307]   - Field: ‘label’
[10:33:36.324]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.308]   - Field: ‘local’
[10:33:36.324]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.308]   - Field: ‘owner’
[10:33:36.324]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.308]   - Field: ‘envir’
[10:33:36.324]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.308]   - Field: ‘packages’
[10:33:36.325]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.308]   - Field: ‘gc’
[10:33:36.325]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.308]   - Field: ‘conditions’
[10:33:36.325]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.308]   - Field: ‘expr’
[10:33:36.325]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.308]   - Field: ‘uuid’
[10:33:36.325]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.308]   - Field: ‘seed’
[10:33:36.325]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.309]   - Field: ‘version’
[10:33:36.325]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.309]   - Field: ‘result’
[10:33:36.325]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.309]   - Field: ‘asynchronous’
[10:33:36.326]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.309]   - Field: ‘calls’
[10:33:36.326]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.309]   - Field: ‘globals’
[10:33:36.326]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.309]   - Field: ‘stdout’
[10:33:36.326]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.309]   - Field: ‘earlySignal’
[10:33:36.326]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.309]   - Field: ‘lazy’
[10:33:36.326]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.309]   - Field: ‘state’
[10:33:36.326]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.309] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:36.326]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.310] - Launch lazy future ...
[10:33:36.327]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.310] Packages needed by the future expression (n = 0): <none>
[10:33:36.327]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.310] Packages needed by future strategies (n = 0): <none>
[10:33:36.327]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.310] {
[10:33:36.310]     {
[10:33:36.310]         {
[10:33:36.310]             ...future.startTime <- base::Sys.time()
[10:33:36.310]             {
[10:33:36.310]                 {
[10:33:36.310]                   {
[10:33:36.310]                     base::local({
[10:33:36.310]                       has_future <- base::requireNamespace("future", 
[10:33:36.310]                         quietly = TRUE)
[10:33:36.310]                       if (has_future) {
[10:33:36.310]                         ns <- base::getNamespace("future")
[10:33:36.310]                         version <- ns[[".package"]][["version"]]
[10:33:36.310]                         if (is.null(version)) 
[10:33:36.310]                           version <- utils::packageVersion("future")
[10:33:36.310]                       }
[10:33:36.310]                       else {
[10:33:36.310]                         version <- NULL
[10:33:36.310]                       }
[10:33:36.310]                       if (!has_future || version < "1.8.0") {
[10:33:36.310]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:36.310]                           "", base::R.version$version.string), 
[10:33:36.310]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:36.310]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:36.310]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:36.310]                             "release", "version")], collapse = " "), 
[10:33:36.310]                           hostname = base::Sys.info()[["nodename"]])
[10:33:36.310]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:36.310]                           info)
[10:33:36.310]                         info <- base::paste(info, collapse = "; ")
[10:33:36.310]                         if (!has_future) {
[10:33:36.310]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:36.310]                             info)
[10:33:36.310]                         }
[10:33:36.310]                         else {
[10:33:36.310]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:36.310]                             info, version)
[10:33:36.310]                         }
[10:33:36.310]                         base::stop(msg)
[10:33:36.310]                       }
[10:33:36.310]                     })
[10:33:36.310]                   }
[10:33:36.310]                   ...future.strategy.old <- future::plan("list")
[10:33:36.310]                   options(future.plan = NULL)
[10:33:36.310]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:36.310]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:36.310]                 }
[10:33:36.310]                 ...future.workdir <- getwd()
[10:33:36.310]             }
[10:33:36.310]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:36.310]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:36.310]         }
[10:33:36.310]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:36.310]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:36.310]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:36.310]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:36.310]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:36.310]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:36.310]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:36.310]             base::names(...future.oldOptions))
[10:33:36.310]     }
[10:33:36.310]     if (FALSE) {
[10:33:36.310]     }
[10:33:36.310]     else {
[10:33:36.310]         if (TRUE) {
[10:33:36.310]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:36.310]                 open = "w")
[10:33:36.310]         }
[10:33:36.310]         else {
[10:33:36.310]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:36.310]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:36.310]         }
[10:33:36.310]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:36.310]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:36.310]             base::sink(type = "output", split = FALSE)
[10:33:36.310]             base::close(...future.stdout)
[10:33:36.310]         }, add = TRUE)
[10:33:36.310]     }
[10:33:36.310]     ...future.frame <- base::sys.nframe()
[10:33:36.310]     ...future.conditions <- base::list()
[10:33:36.310]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:36.310]     if (FALSE) {
[10:33:36.310]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:36.310]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:36.310]     }
[10:33:36.310]     ...future.result <- base::tryCatch({
[10:33:36.310]         base::withCallingHandlers({
[10:33:36.310]             ...future.value <- base::withVisible(base::local(subset(data, 
[10:33:36.310]                 a == 2)))
[10:33:36.310]             future::FutureResult(value = ...future.value$value, 
[10:33:36.310]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:36.310]                   ...future.rng), globalenv = if (FALSE) 
[10:33:36.310]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:36.310]                     ...future.globalenv.names))
[10:33:36.310]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:36.310]         }, condition = base::local({
[10:33:36.310]             c <- base::c
[10:33:36.310]             inherits <- base::inherits
[10:33:36.310]             invokeRestart <- base::invokeRestart
[10:33:36.310]             length <- base::length
[10:33:36.310]             list <- base::list
[10:33:36.310]             seq.int <- base::seq.int
[10:33:36.310]             signalCondition <- base::signalCondition
[10:33:36.310]             sys.calls <- base::sys.calls
[10:33:36.310]             `[[` <- base::`[[`
[10:33:36.310]             `+` <- base::`+`
[10:33:36.310]             `<<-` <- base::`<<-`
[10:33:36.310]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:36.310]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:36.310]                   3L)]
[10:33:36.310]             }
[10:33:36.310]             function(cond) {
[10:33:36.310]                 is_error <- inherits(cond, "error")
[10:33:36.310]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:36.310]                   NULL)
[10:33:36.310]                 if (is_error) {
[10:33:36.310]                   sessionInformation <- function() {
[10:33:36.310]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:36.310]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:36.310]                       search = base::search(), system = base::Sys.info())
[10:33:36.310]                   }
[10:33:36.310]                   ...future.conditions[[length(...future.conditions) + 
[10:33:36.310]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:36.310]                     cond$call), session = sessionInformation(), 
[10:33:36.310]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:36.310]                   signalCondition(cond)
[10:33:36.310]                 }
[10:33:36.310]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:36.310]                 "immediateCondition"))) {
[10:33:36.310]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:36.310]                   ...future.conditions[[length(...future.conditions) + 
[10:33:36.310]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:36.310]                   if (TRUE && !signal) {
[10:33:36.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:36.310]                     {
[10:33:36.310]                       inherits <- base::inherits
[10:33:36.310]                       invokeRestart <- base::invokeRestart
[10:33:36.310]                       is.null <- base::is.null
[10:33:36.310]                       muffled <- FALSE
[10:33:36.310]                       if (inherits(cond, "message")) {
[10:33:36.310]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:36.310]                         if (muffled) 
[10:33:36.310]                           invokeRestart("muffleMessage")
[10:33:36.310]                       }
[10:33:36.310]                       else if (inherits(cond, "warning")) {
[10:33:36.310]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:36.310]                         if (muffled) 
[10:33:36.310]                           invokeRestart("muffleWarning")
[10:33:36.310]                       }
[10:33:36.310]                       else if (inherits(cond, "condition")) {
[10:33:36.310]                         if (!is.null(pattern)) {
[10:33:36.310]                           computeRestarts <- base::computeRestarts
[10:33:36.310]                           grepl <- base::grepl
[10:33:36.310]                           restarts <- computeRestarts(cond)
[10:33:36.310]                           for (restart in restarts) {
[10:33:36.310]                             name <- restart$name
[10:33:36.310]                             if (is.null(name)) 
[10:33:36.310]                               next
[10:33:36.310]                             if (!grepl(pattern, name)) 
[10:33:36.310]                               next
[10:33:36.310]                             invokeRestart(restart)
[10:33:36.310]                             muffled <- TRUE
[10:33:36.310]                             break
[10:33:36.310]                           }
[10:33:36.310]                         }
[10:33:36.310]                       }
[10:33:36.310]                       invisible(muffled)
[10:33:36.310]                     }
[10:33:36.310]                     muffleCondition(cond, pattern = "^muffle")
[10:33:36.310]                   }
[10:33:36.310]                 }
[10:33:36.310]                 else {
[10:33:36.310]                   if (TRUE) {
[10:33:36.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:36.310]                     {
[10:33:36.310]                       inherits <- base::inherits
[10:33:36.310]                       invokeRestart <- base::invokeRestart
[10:33:36.310]                       is.null <- base::is.null
[10:33:36.310]                       muffled <- FALSE
[10:33:36.310]                       if (inherits(cond, "message")) {
[10:33:36.310]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:36.310]                         if (muffled) 
[10:33:36.310]                           invokeRestart("muffleMessage")
[10:33:36.310]                       }
[10:33:36.310]                       else if (inherits(cond, "warning")) {
[10:33:36.310]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:36.310]                         if (muffled) 
[10:33:36.310]                           invokeRestart("muffleWarning")
[10:33:36.310]                       }
[10:33:36.310]                       else if (inherits(cond, "condition")) {
[10:33:36.310]                         if (!is.null(pattern)) {
[10:33:36.310]                           computeRestarts <- base::computeRestarts
[10:33:36.310]                           grepl <- base::grepl
[10:33:36.310]                           restarts <- computeRestarts(cond)
[10:33:36.310]                           for (restart in restarts) {
[10:33:36.310]                             name <- restart$name
[10:33:36.310]                             if (is.null(name)) 
[10:33:36.310]                               next
[10:33:36.310]                             if (!grepl(pattern, name)) 
[10:33:36.310]                               next
[10:33:36.310]                             invokeRestart(restart)
[10:33:36.310]                             muffled <- TRUE
[10:33:36.310]                             break
[10:33:36.310]                           }
[10:33:36.310]                         }
[10:33:36.310]                       }
[10:33:36.310]                       invisible(muffled)
[10:33:36.310]                     }
[10:33:36.310]                     muffleCondition(cond, pattern = "^muffle")
[10:33:36.310]                   }
[10:33:36.310]                 }
[10:33:36.310]             }
[10:33:36.310]         }))
[10:33:36.310]     }, error = function(ex) {
[10:33:36.310]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:36.310]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:36.310]                 ...future.rng), started = ...future.startTime, 
[10:33:36.310]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:36.310]             version = "1.8"), class = "FutureResult")
[10:33:36.310]     }, finally = {
[10:33:36.310]         if (!identical(...future.workdir, getwd())) 
[10:33:36.310]             setwd(...future.workdir)
[10:33:36.310]         {
[10:33:36.310]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:36.310]                 ...future.oldOptions$nwarnings <- NULL
[10:33:36.310]             }
[10:33:36.310]             base::options(...future.oldOptions)
[10:33:36.310]             if (.Platform$OS.type == "windows") {
[10:33:36.310]                 old_names <- names(...future.oldEnvVars)
[10:33:36.310]                 envs <- base::Sys.getenv()
[10:33:36.310]                 names <- names(envs)
[10:33:36.310]                 common <- intersect(names, old_names)
[10:33:36.310]                 added <- setdiff(names, old_names)
[10:33:36.310]                 removed <- setdiff(old_names, names)
[10:33:36.310]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:36.310]                   envs[common]]
[10:33:36.310]                 NAMES <- toupper(changed)
[10:33:36.310]                 args <- list()
[10:33:36.310]                 for (kk in seq_along(NAMES)) {
[10:33:36.310]                   name <- changed[[kk]]
[10:33:36.310]                   NAME <- NAMES[[kk]]
[10:33:36.310]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.310]                     next
[10:33:36.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:36.310]                 }
[10:33:36.310]                 NAMES <- toupper(added)
[10:33:36.310]                 for (kk in seq_along(NAMES)) {
[10:33:36.310]                   name <- added[[kk]]
[10:33:36.310]                   NAME <- NAMES[[kk]]
[10:33:36.310]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.310]                     next
[10:33:36.310]                   args[[name]] <- ""
[10:33:36.310]                 }
[10:33:36.310]                 NAMES <- toupper(removed)
[10:33:36.310]                 for (kk in seq_along(NAMES)) {
[10:33:36.310]                   name <- removed[[kk]]
[10:33:36.310]                   NAME <- NAMES[[kk]]
[10:33:36.310]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.310]                     next
[10:33:36.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:36.310]                 }
[10:33:36.310]                 if (length(args) > 0) 
[10:33:36.310]                   base::do.call(base::Sys.setenv, args = args)
[10:33:36.310]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:36.310]             }
[10:33:36.310]             else {
[10:33:36.310]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:36.310]             }
[10:33:36.310]             {
[10:33:36.310]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:36.310]                   0L) {
[10:33:36.310]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:36.310]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:36.310]                   base::options(opts)
[10:33:36.310]                 }
[10:33:36.310]                 {
[10:33:36.310]                   {
[10:33:36.310]                     NULL
[10:33:36.310]                     RNGkind("Mersenne-Twister")
[10:33:36.310]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:36.310]                       inherits = FALSE)
[10:33:36.310]                   }
[10:33:36.310]                   options(future.plan = NULL)
[10:33:36.310]                   if (is.na(NA_character_)) 
[10:33:36.310]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:36.310]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:36.310]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:36.310]                     .init = FALSE)
[10:33:36.310]                 }
[10:33:36.310]             }
[10:33:36.310]         }
[10:33:36.310]     })
[10:33:36.310]     if (TRUE) {
[10:33:36.310]         base::sink(type = "output", split = FALSE)
[10:33:36.310]         if (TRUE) {
[10:33:36.310]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:36.310]         }
[10:33:36.310]         else {
[10:33:36.310]             ...future.result["stdout"] <- base::list(NULL)
[10:33:36.310]         }
[10:33:36.310]         base::close(...future.stdout)
[10:33:36.310]         ...future.stdout <- NULL
[10:33:36.310]     }
[10:33:36.310]     ...future.result$conditions <- ...future.conditions
[10:33:36.310]     ...future.result$finished <- base::Sys.time()
[10:33:36.310]     ...future.result
[10:33:36.310] }
[10:33:36.327]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.312] assign_globals() ...
[10:33:36.327]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.312] List of 1
[10:33:36.312]  $ data:'data.frame':	3 obs. of  2 variables:
[10:33:36.312]   ..$ a: int [1:3] 1 2 3
[10:33:36.312]   ..$ b: int [1:3] 3 2 1
[10:33:36.312]  - attr(*, "where")=List of 1
[10:33:36.312]   ..$ data:<environment: R_EmptyEnv> 
[10:33:36.312]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:36.312]  - attr(*, "resolved")= logi FALSE
[10:33:36.312]  - attr(*, "total_size")= num 128
[10:33:36.312]  - attr(*, "already-done")= logi TRUE
[10:33:36.327]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.315] - copied ‘data’ to environment
[10:33:36.327]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.315] assign_globals() ... done
[10:33:36.328]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.315] plan(): Setting new future strategy stack:
[10:33:36.328]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.315] List of future strategies:
[10:33:36.315] 1. sequential:
[10:33:36.315]    - args: function (..., envir = parent.frame())
[10:33:36.315]    - tweaked: FALSE
[10:33:36.315]    - call: NULL
[10:33:36.328]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.316] plan(): nbrOfWorkers() = 1
[10:33:36.328]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.317] plan(): Setting new future strategy stack:
[10:33:36.328]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.317] List of future strategies:
[10:33:36.317] 1. sequential:
[10:33:36.317]    - args: function (..., envir = parent.frame())
[10:33:36.317]    - tweaked: FALSE
[10:33:36.317]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:36.328]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.317] plan(): nbrOfWorkers() = 1
[10:33:36.328]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.317] SequentialFuture started (and completed)
[10:33:36.328]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.317] - Launch lazy future ... done
[10:33:36.329]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.318] run() for ‘SequentialFuture’ ... done
[10:33:36.329] signalConditions() ... done
- plan(list('sequential', 'sequential')) ... DONE
- plan(list('sequential', 'multicore')) ...
[10:33:36.329] plan(): Setting new future strategy stack:
[10:33:36.329] List of future strategies:
[10:33:36.329] 1. sequential:
[10:33:36.329]    - args: function (..., envir = parent.frame())
[10:33:36.329]    - tweaked: FALSE
[10:33:36.329]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:36.329] 2. multicore:
[10:33:36.329]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:36.329]    - tweaked: FALSE
[10:33:36.329]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:36.330] plan(): nbrOfWorkers() = 1
[10:33:36.330] getGlobalsAndPackages() ...
[10:33:36.330] Searching for globals...
[10:33:36.346] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:33:36.346] Searching for globals ... DONE
[10:33:36.346] Resolving globals: FALSE
[10:33:36.347] The total size of the 2 globals is 57.84 KiB (59224 bytes)
[10:33:36.348] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 57.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (57.72 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[10:33:36.348] - globals: [2] ‘nested’, ‘strategy2’
[10:33:36.348] - packages: [1] ‘future’
[10:33:36.348] getGlobalsAndPackages() ... DONE
[10:33:36.348] run() for ‘Future’ ...
[10:33:36.348] - state: ‘created’
[10:33:36.348] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:36.349] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:36.349] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:36.349]   - Field: ‘label’
[10:33:36.349]   - Field: ‘local’
[10:33:36.349]   - Field: ‘owner’
[10:33:36.349]   - Field: ‘envir’
[10:33:36.349]   - Field: ‘packages’
[10:33:36.349]   - Field: ‘gc’
[10:33:36.350]   - Field: ‘conditions’
[10:33:36.350]   - Field: ‘expr’
[10:33:36.350]   - Field: ‘uuid’
[10:33:36.350]   - Field: ‘seed’
[10:33:36.350]   - Field: ‘version’
[10:33:36.350]   - Field: ‘result’
[10:33:36.350]   - Field: ‘asynchronous’
[10:33:36.350]   - Field: ‘calls’
[10:33:36.350]   - Field: ‘globals’
[10:33:36.350]   - Field: ‘stdout’
[10:33:36.350]   - Field: ‘earlySignal’
[10:33:36.350]   - Field: ‘lazy’
[10:33:36.351]   - Field: ‘state’
[10:33:36.351] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:36.351] - Launch lazy future ...
[10:33:36.351] Packages needed by the future expression (n = 1): ‘future’
[10:33:36.351] Packages needed by future strategies (n = 1): ‘future’
[10:33:36.352] {
[10:33:36.352]     {
[10:33:36.352]         {
[10:33:36.352]             ...future.startTime <- base::Sys.time()
[10:33:36.352]             {
[10:33:36.352]                 {
[10:33:36.352]                   {
[10:33:36.352]                     {
[10:33:36.352]                       base::local({
[10:33:36.352]                         has_future <- base::requireNamespace("future", 
[10:33:36.352]                           quietly = TRUE)
[10:33:36.352]                         if (has_future) {
[10:33:36.352]                           ns <- base::getNamespace("future")
[10:33:36.352]                           version <- ns[[".package"]][["version"]]
[10:33:36.352]                           if (is.null(version)) 
[10:33:36.352]                             version <- utils::packageVersion("future")
[10:33:36.352]                         }
[10:33:36.352]                         else {
[10:33:36.352]                           version <- NULL
[10:33:36.352]                         }
[10:33:36.352]                         if (!has_future || version < "1.8.0") {
[10:33:36.352]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:36.352]                             "", base::R.version$version.string), 
[10:33:36.352]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:36.352]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:36.352]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:36.352]                               "release", "version")], collapse = " "), 
[10:33:36.352]                             hostname = base::Sys.info()[["nodename"]])
[10:33:36.352]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:36.352]                             info)
[10:33:36.352]                           info <- base::paste(info, collapse = "; ")
[10:33:36.352]                           if (!has_future) {
[10:33:36.352]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:36.352]                               info)
[10:33:36.352]                           }
[10:33:36.352]                           else {
[10:33:36.352]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:36.352]                               info, version)
[10:33:36.352]                           }
[10:33:36.352]                           base::stop(msg)
[10:33:36.352]                         }
[10:33:36.352]                       })
[10:33:36.352]                     }
[10:33:36.352]                     base::local({
[10:33:36.352]                       for (pkg in "future") {
[10:33:36.352]                         base::loadNamespace(pkg)
[10:33:36.352]                         base::library(pkg, character.only = TRUE)
[10:33:36.352]                       }
[10:33:36.352]                     })
[10:33:36.352]                   }
[10:33:36.352]                   ...future.strategy.old <- future::plan("list")
[10:33:36.352]                   options(future.plan = NULL)
[10:33:36.352]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:36.352]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:33:36.352]                     envir = parent.frame()) 
[10:33:36.352]                   {
[10:33:36.352]                     default_workers <- missing(workers)
[10:33:36.352]                     if (is.function(workers)) 
[10:33:36.352]                       workers <- workers()
[10:33:36.352]                     workers <- structure(as.integer(workers), 
[10:33:36.352]                       class = class(workers))
[10:33:36.352]                     stop_if_not(is.finite(workers), workers >= 
[10:33:36.352]                       1L)
[10:33:36.352]                     if ((workers == 1L && !inherits(workers, 
[10:33:36.352]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:33:36.352]                       if (default_workers) 
[10:33:36.352]                         supportsMulticore(warn = TRUE)
[10:33:36.352]                       return(sequential(..., envir = envir))
[10:33:36.352]                     }
[10:33:36.352]                     oopts <- options(mc.cores = workers)
[10:33:36.352]                     on.exit(options(oopts))
[10:33:36.352]                     future <- MulticoreFuture(..., workers = workers, 
[10:33:36.352]                       envir = envir)
[10:33:36.352]                     if (!future$lazy) 
[10:33:36.352]                       future <- run(future)
[10:33:36.352]                     invisible(future)
[10:33:36.352]                   }), .cleanup = FALSE, .init = FALSE)
[10:33:36.352]                 }
[10:33:36.352]                 ...future.workdir <- getwd()
[10:33:36.352]             }
[10:33:36.352]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:36.352]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:36.352]         }
[10:33:36.352]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:36.352]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:36.352]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:36.352]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:36.352]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:36.352]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:36.352]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:36.352]             base::names(...future.oldOptions))
[10:33:36.352]     }
[10:33:36.352]     if (FALSE) {
[10:33:36.352]     }
[10:33:36.352]     else {
[10:33:36.352]         if (TRUE) {
[10:33:36.352]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:36.352]                 open = "w")
[10:33:36.352]         }
[10:33:36.352]         else {
[10:33:36.352]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:36.352]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:36.352]         }
[10:33:36.352]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:36.352]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:36.352]             base::sink(type = "output", split = FALSE)
[10:33:36.352]             base::close(...future.stdout)
[10:33:36.352]         }, add = TRUE)
[10:33:36.352]     }
[10:33:36.352]     ...future.frame <- base::sys.nframe()
[10:33:36.352]     ...future.conditions <- base::list()
[10:33:36.352]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:36.352]     if (FALSE) {
[10:33:36.352]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:36.352]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:36.352]     }
[10:33:36.352]     ...future.result <- base::tryCatch({
[10:33:36.352]         base::withCallingHandlers({
[10:33:36.352]             ...future.value <- base::withVisible(base::local({
[10:33:36.352]                 a <- 1L
[10:33:36.352]                 plan_a <- unclass(future::plan("list"))
[10:33:36.352]                 nested_a <- nested[-1]
[10:33:36.352]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:33:36.352]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:33:36.352]                   strategy2))
[10:33:36.352]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:33:36.352]                   "init") <- NULL
[10:33:36.352]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:33:36.352]                   "init") <- NULL
[10:33:36.352]                 stopifnot(all.equal(plan_a, nested_a))
[10:33:36.352]                 y %<-% {
[10:33:36.352]                   b <- 2L
[10:33:36.352]                   plan_b <- future::plan("list")
[10:33:36.352]                   nested_b <- nested_a[-1]
[10:33:36.352]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:33:36.352]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:33:36.352]                     "sequential"))
[10:33:36.352]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:33:36.352]                     b = b, nested_b = nested_b, plan_b = plan_b)
[10:33:36.352]                 }
[10:33:36.352]                 y
[10:33:36.352]             }))
[10:33:36.352]             future::FutureResult(value = ...future.value$value, 
[10:33:36.352]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:36.352]                   ...future.rng), globalenv = if (FALSE) 
[10:33:36.352]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:36.352]                     ...future.globalenv.names))
[10:33:36.352]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:36.352]         }, condition = base::local({
[10:33:36.352]             c <- base::c
[10:33:36.352]             inherits <- base::inherits
[10:33:36.352]             invokeRestart <- base::invokeRestart
[10:33:36.352]             length <- base::length
[10:33:36.352]             list <- base::list
[10:33:36.352]             seq.int <- base::seq.int
[10:33:36.352]             signalCondition <- base::signalCondition
[10:33:36.352]             sys.calls <- base::sys.calls
[10:33:36.352]             `[[` <- base::`[[`
[10:33:36.352]             `+` <- base::`+`
[10:33:36.352]             `<<-` <- base::`<<-`
[10:33:36.352]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:36.352]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:36.352]                   3L)]
[10:33:36.352]             }
[10:33:36.352]             function(cond) {
[10:33:36.352]                 is_error <- inherits(cond, "error")
[10:33:36.352]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:36.352]                   NULL)
[10:33:36.352]                 if (is_error) {
[10:33:36.352]                   sessionInformation <- function() {
[10:33:36.352]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:36.352]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:36.352]                       search = base::search(), system = base::Sys.info())
[10:33:36.352]                   }
[10:33:36.352]                   ...future.conditions[[length(...future.conditions) + 
[10:33:36.352]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:36.352]                     cond$call), session = sessionInformation(), 
[10:33:36.352]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:36.352]                   signalCondition(cond)
[10:33:36.352]                 }
[10:33:36.352]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:36.352]                 "immediateCondition"))) {
[10:33:36.352]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:36.352]                   ...future.conditions[[length(...future.conditions) + 
[10:33:36.352]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:36.352]                   if (TRUE && !signal) {
[10:33:36.352]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:36.352]                     {
[10:33:36.352]                       inherits <- base::inherits
[10:33:36.352]                       invokeRestart <- base::invokeRestart
[10:33:36.352]                       is.null <- base::is.null
[10:33:36.352]                       muffled <- FALSE
[10:33:36.352]                       if (inherits(cond, "message")) {
[10:33:36.352]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:36.352]                         if (muffled) 
[10:33:36.352]                           invokeRestart("muffleMessage")
[10:33:36.352]                       }
[10:33:36.352]                       else if (inherits(cond, "warning")) {
[10:33:36.352]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:36.352]                         if (muffled) 
[10:33:36.352]                           invokeRestart("muffleWarning")
[10:33:36.352]                       }
[10:33:36.352]                       else if (inherits(cond, "condition")) {
[10:33:36.352]                         if (!is.null(pattern)) {
[10:33:36.352]                           computeRestarts <- base::computeRestarts
[10:33:36.352]                           grepl <- base::grepl
[10:33:36.352]                           restarts <- computeRestarts(cond)
[10:33:36.352]                           for (restart in restarts) {
[10:33:36.352]                             name <- restart$name
[10:33:36.352]                             if (is.null(name)) 
[10:33:36.352]                               next
[10:33:36.352]                             if (!grepl(pattern, name)) 
[10:33:36.352]                               next
[10:33:36.352]                             invokeRestart(restart)
[10:33:36.352]                             muffled <- TRUE
[10:33:36.352]                             break
[10:33:36.352]                           }
[10:33:36.352]                         }
[10:33:36.352]                       }
[10:33:36.352]                       invisible(muffled)
[10:33:36.352]                     }
[10:33:36.352]                     muffleCondition(cond, pattern = "^muffle")
[10:33:36.352]                   }
[10:33:36.352]                 }
[10:33:36.352]                 else {
[10:33:36.352]                   if (TRUE) {
[10:33:36.352]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:36.352]                     {
[10:33:36.352]                       inherits <- base::inherits
[10:33:36.352]                       invokeRestart <- base::invokeRestart
[10:33:36.352]                       is.null <- base::is.null
[10:33:36.352]                       muffled <- FALSE
[10:33:36.352]                       if (inherits(cond, "message")) {
[10:33:36.352]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:36.352]                         if (muffled) 
[10:33:36.352]                           invokeRestart("muffleMessage")
[10:33:36.352]                       }
[10:33:36.352]                       else if (inherits(cond, "warning")) {
[10:33:36.352]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:36.352]                         if (muffled) 
[10:33:36.352]                           invokeRestart("muffleWarning")
[10:33:36.352]                       }
[10:33:36.352]                       else if (inherits(cond, "condition")) {
[10:33:36.352]                         if (!is.null(pattern)) {
[10:33:36.352]                           computeRestarts <- base::computeRestarts
[10:33:36.352]                           grepl <- base::grepl
[10:33:36.352]                           restarts <- computeRestarts(cond)
[10:33:36.352]                           for (restart in restarts) {
[10:33:36.352]                             name <- restart$name
[10:33:36.352]                             if (is.null(name)) 
[10:33:36.352]                               next
[10:33:36.352]                             if (!grepl(pattern, name)) 
[10:33:36.352]                               next
[10:33:36.352]                             invokeRestart(restart)
[10:33:36.352]                             muffled <- TRUE
[10:33:36.352]                             break
[10:33:36.352]                           }
[10:33:36.352]                         }
[10:33:36.352]                       }
[10:33:36.352]                       invisible(muffled)
[10:33:36.352]                     }
[10:33:36.352]                     muffleCondition(cond, pattern = "^muffle")
[10:33:36.352]                   }
[10:33:36.352]                 }
[10:33:36.352]             }
[10:33:36.352]         }))
[10:33:36.352]     }, error = function(ex) {
[10:33:36.352]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:36.352]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:36.352]                 ...future.rng), started = ...future.startTime, 
[10:33:36.352]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:36.352]             version = "1.8"), class = "FutureResult")
[10:33:36.352]     }, finally = {
[10:33:36.352]         if (!identical(...future.workdir, getwd())) 
[10:33:36.352]             setwd(...future.workdir)
[10:33:36.352]         {
[10:33:36.352]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:36.352]                 ...future.oldOptions$nwarnings <- NULL
[10:33:36.352]             }
[10:33:36.352]             base::options(...future.oldOptions)
[10:33:36.352]             if (.Platform$OS.type == "windows") {
[10:33:36.352]                 old_names <- names(...future.oldEnvVars)
[10:33:36.352]                 envs <- base::Sys.getenv()
[10:33:36.352]                 names <- names(envs)
[10:33:36.352]                 common <- intersect(names, old_names)
[10:33:36.352]                 added <- setdiff(names, old_names)
[10:33:36.352]                 removed <- setdiff(old_names, names)
[10:33:36.352]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:36.352]                   envs[common]]
[10:33:36.352]                 NAMES <- toupper(changed)
[10:33:36.352]                 args <- list()
[10:33:36.352]                 for (kk in seq_along(NAMES)) {
[10:33:36.352]                   name <- changed[[kk]]
[10:33:36.352]                   NAME <- NAMES[[kk]]
[10:33:36.352]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.352]                     next
[10:33:36.352]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:36.352]                 }
[10:33:36.352]                 NAMES <- toupper(added)
[10:33:36.352]                 for (kk in seq_along(NAMES)) {
[10:33:36.352]                   name <- added[[kk]]
[10:33:36.352]                   NAME <- NAMES[[kk]]
[10:33:36.352]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.352]                     next
[10:33:36.352]                   args[[name]] <- ""
[10:33:36.352]                 }
[10:33:36.352]                 NAMES <- toupper(removed)
[10:33:36.352]                 for (kk in seq_along(NAMES)) {
[10:33:36.352]                   name <- removed[[kk]]
[10:33:36.352]                   NAME <- NAMES[[kk]]
[10:33:36.352]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.352]                     next
[10:33:36.352]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:36.352]                 }
[10:33:36.352]                 if (length(args) > 0) 
[10:33:36.352]                   base::do.call(base::Sys.setenv, args = args)
[10:33:36.352]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:36.352]             }
[10:33:36.352]             else {
[10:33:36.352]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:36.352]             }
[10:33:36.352]             {
[10:33:36.352]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:36.352]                   0L) {
[10:33:36.352]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:36.352]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:36.352]                   base::options(opts)
[10:33:36.352]                 }
[10:33:36.352]                 {
[10:33:36.352]                   {
[10:33:36.352]                     NULL
[10:33:36.352]                     RNGkind("Mersenne-Twister")
[10:33:36.352]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:36.352]                       inherits = FALSE)
[10:33:36.352]                   }
[10:33:36.352]                   options(future.plan = NULL)
[10:33:36.352]                   if (is.na(NA_character_)) 
[10:33:36.352]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:36.352]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:36.352]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:36.352]                     .init = FALSE)
[10:33:36.352]                 }
[10:33:36.352]             }
[10:33:36.352]         }
[10:33:36.352]     })
[10:33:36.352]     if (TRUE) {
[10:33:36.352]         base::sink(type = "output", split = FALSE)
[10:33:36.352]         if (TRUE) {
[10:33:36.352]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:36.352]         }
[10:33:36.352]         else {
[10:33:36.352]             ...future.result["stdout"] <- base::list(NULL)
[10:33:36.352]         }
[10:33:36.352]         base::close(...future.stdout)
[10:33:36.352]         ...future.stdout <- NULL
[10:33:36.352]     }
[10:33:36.352]     ...future.result$conditions <- ...future.conditions
[10:33:36.352]     ...future.result$finished <- base::Sys.time()
[10:33:36.352]     ...future.result
[10:33:36.352] }
[10:33:36.353] assign_globals() ...
[10:33:36.354] List of 2
[10:33:36.354]  $ nested   :List of 2
[10:33:36.354]   ..$ a:function (..., envir = parent.frame())  
[10:33:36.354]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:33:36.354]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:33:36.354]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:33:36.354]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:33:36.354]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:33:36.354]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:33:36.354]  $ strategy2: chr "multicore"
[10:33:36.354]  - attr(*, "where")=List of 2
[10:33:36.354]   ..$ nested   :<environment: R_EmptyEnv> 
[10:33:36.354]   ..$ strategy2:<environment: R_EmptyEnv> 
[10:33:36.354]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:36.354]  - attr(*, "resolved")= logi FALSE
[10:33:36.354]  - attr(*, "total_size")= num 59224
[10:33:36.354]  - attr(*, "already-done")= logi TRUE
[10:33:36.358] - copied ‘nested’ to environment
[10:33:36.358] - copied ‘strategy2’ to environment
[10:33:36.358] assign_globals() ... done
[10:33:36.359] plan(): Setting new future strategy stack:
[10:33:36.359] List of future strategies:
[10:33:36.359] 1. multicore:
[10:33:36.359]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:36.359]    - tweaked: FALSE
[10:33:36.359]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:36.365] plan(): nbrOfWorkers() = 2
[10:33:36.423] plan(): Setting new future strategy stack:
[10:33:36.423] List of future strategies:
[10:33:36.423] 1. sequential:
[10:33:36.423]    - args: function (..., envir = parent.frame())
[10:33:36.423]    - tweaked: FALSE
[10:33:36.423]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:36.423] 2. multicore:
[10:33:36.423]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:36.423]    - tweaked: FALSE
[10:33:36.423]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:36.424] plan(): nbrOfWorkers() = 1
[10:33:36.424] SequentialFuture started (and completed)
[10:33:36.424] signalConditions() ...
[10:33:36.424]  - include = ‘immediateCondition’
[10:33:36.425]  - exclude = 
[10:33:36.425]  - resignal = FALSE
[10:33:36.425]  - Number of conditions: 57
[10:33:36.425] signalConditions() ... done
[10:33:36.425] - Launch lazy future ... done
[10:33:36.425] run() for ‘SequentialFuture’ ... done
[10:33:36.426] signalConditions() ...
[10:33:36.426]  - include = ‘immediateCondition’
[10:33:36.426]  - exclude = 
[10:33:36.426]  - resignal = FALSE
[10:33:36.426]  - Number of conditions: 57
[10:33:36.426] signalConditions() ... done
[10:33:36.426] Future state: ‘finished’
[10:33:36.427] signalConditions() ...
[10:33:36.427]  - include = ‘condition’
[10:33:36.427]  - exclude = ‘immediateCondition’
[10:33:36.427]  - resignal = TRUE
[10:33:36.427]  - Number of conditions: 57
[10:33:36.427]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.366] getGlobalsAndPackages() ...
[10:33:36.427]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.366] Searching for globals...
[10:33:36.427]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.384] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[10:33:36.428]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.384] Searching for globals ... DONE
[10:33:36.428]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.384] Resolving globals: FALSE
[10:33:36.428]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.385] The total size of the 3 globals is 93.01 KiB (95240 bytes)
[10:33:36.428]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.386] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 93.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (46.48 KiB of class ‘list’), ‘plan_a’ (46.48 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[10:33:36.428]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.386] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[10:33:36.428]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.386] 
[10:33:36.429]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.386] getGlobalsAndPackages() ... DONE
[10:33:36.429]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.386] run() for ‘Future’ ...
[10:33:36.429]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.386] - state: ‘created’
[10:33:36.429]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.387] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:36.429]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.390] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:36.429]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.390] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:36.430]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.391]   - Field: ‘label’
[10:33:36.430]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.391]   - Field: ‘local’
[10:33:36.430]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.391]   - Field: ‘owner’
[10:33:36.430]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.391]   - Field: ‘envir’
[10:33:36.430]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.391]   - Field: ‘workers’
[10:33:36.430]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.391]   - Field: ‘packages’
[10:33:36.430]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.391]   - Field: ‘gc’
[10:33:36.431]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.391]   - Field: ‘job’
[10:33:36.431]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.391]   - Field: ‘conditions’
[10:33:36.431]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.392]   - Field: ‘expr’
[10:33:36.431]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.392]   - Field: ‘uuid’
[10:33:36.431]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.392]   - Field: ‘seed’
[10:33:36.431]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.392]   - Field: ‘version’
[10:33:36.432]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.392]   - Field: ‘result’
[10:33:36.432]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.392]   - Field: ‘asynchronous’
[10:33:36.432]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.392]   - Field: ‘calls’
[10:33:36.432]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.392]   - Field: ‘globals’
[10:33:36.432]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.392]   - Field: ‘stdout’
[10:33:36.432]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.392]   - Field: ‘earlySignal’
[10:33:36.433]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.393]   - Field: ‘lazy’
[10:33:36.433]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.393]   - Field: ‘state’
[10:33:36.433]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.393] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:36.433]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.393] - Launch lazy future ...
[10:33:36.433]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.394] Packages needed by the future expression (n = 0): <none>
[10:33:36.433]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.394] Packages needed by future strategies (n = 0): <none>
[10:33:36.434]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.395] {
[10:33:36.395]     {
[10:33:36.395]         {
[10:33:36.395]             ...future.startTime <- base::Sys.time()
[10:33:36.395]             {
[10:33:36.395]                 {
[10:33:36.395]                   {
[10:33:36.395]                     {
[10:33:36.395]                       base::local({
[10:33:36.395]                         has_future <- base::requireNamespace("future", 
[10:33:36.395]                           quietly = TRUE)
[10:33:36.395]                         if (has_future) {
[10:33:36.395]                           ns <- base::getNamespace("future")
[10:33:36.395]                           version <- ns[[".package"]][["version"]]
[10:33:36.395]                           if (is.null(version)) 
[10:33:36.395]                             version <- utils::packageVersion("future")
[10:33:36.395]                         }
[10:33:36.395]                         else {
[10:33:36.395]                           version <- NULL
[10:33:36.395]                         }
[10:33:36.395]                         if (!has_future || version < "1.8.0") {
[10:33:36.395]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:36.395]                             "", base::R.version$version.string), 
[10:33:36.395]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:36.395]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:36.395]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:36.395]                               "release", "version")], collapse = " "), 
[10:33:36.395]                             hostname = base::Sys.info()[["nodename"]])
[10:33:36.395]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:36.395]                             info)
[10:33:36.395]                           info <- base::paste(info, collapse = "; ")
[10:33:36.395]                           if (!has_future) {
[10:33:36.395]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:36.395]                               info)
[10:33:36.395]                           }
[10:33:36.395]                           else {
[10:33:36.395]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:36.395]                               info, version)
[10:33:36.395]                           }
[10:33:36.395]                           base::stop(msg)
[10:33:36.395]                         }
[10:33:36.395]                       })
[10:33:36.395]                     }
[10:33:36.395]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:36.395]                     base::options(mc.cores = 1L)
[10:33:36.395]                   }
[10:33:36.395]                   ...future.strategy.old <- future::plan("list")
[10:33:36.395]                   options(future.plan = NULL)
[10:33:36.395]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:36.395]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:36.395]                 }
[10:33:36.395]                 ...future.workdir <- getwd()
[10:33:36.395]             }
[10:33:36.395]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:36.395]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:36.395]         }
[10:33:36.395]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:36.395]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:36.395]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:36.395]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:36.395]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:36.395]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:36.395]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:36.395]             base::names(...future.oldOptions))
[10:33:36.395]     }
[10:33:36.395]     if (FALSE) {
[10:33:36.395]     }
[10:33:36.395]     else {
[10:33:36.395]         if (TRUE) {
[10:33:36.395]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:36.395]                 open = "w")
[10:33:36.395]         }
[10:33:36.395]         else {
[10:33:36.395]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:36.395]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:36.395]         }
[10:33:36.395]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:36.395]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:36.395]             base::sink(type = "output", split = FALSE)
[10:33:36.395]             base::close(...future.stdout)
[10:33:36.395]         }, add = TRUE)
[10:33:36.395]     }
[10:33:36.395]     ...future.frame <- base::sys.nframe()
[10:33:36.395]     ...future.conditions <- base::list()
[10:33:36.395]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:36.395]     if (FALSE) {
[10:33:36.395]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:36.395]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:36.395]     }
[10:33:36.395]     ...future.result <- base::tryCatch({
[10:33:36.395]         base::withCallingHandlers({
[10:33:36.395]             ...future.value <- base::withVisible(base::local({
[10:33:36.395]                 withCallingHandlers({
[10:33:36.395]                   {
[10:33:36.395]                     b <- 2L
[10:33:36.395]                     plan_b <- future::plan("list")
[10:33:36.395]                     nested_b <- nested_a[-1]
[10:33:36.395]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:33:36.395]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:33:36.395]                       "sequential"))
[10:33:36.395]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:33:36.395]                       b = b, nested_b = nested_b, plan_b = plan_b)
[10:33:36.395]                   }
[10:33:36.395]                 }, immediateCondition = function(cond) {
[10:33:36.395]                   save_rds <- function (object, pathname, ...) 
[10:33:36.395]                   {
[10:33:36.395]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:36.395]                     if (file_test("-f", pathname_tmp)) {
[10:33:36.395]                       fi_tmp <- file.info(pathname_tmp)
[10:33:36.395]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:36.395]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:36.395]                         fi_tmp[["mtime"]])
[10:33:36.395]                     }
[10:33:36.395]                     tryCatch({
[10:33:36.395]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:36.395]                     }, error = function(ex) {
[10:33:36.395]                       msg <- conditionMessage(ex)
[10:33:36.395]                       fi_tmp <- file.info(pathname_tmp)
[10:33:36.395]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:36.395]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:36.395]                         fi_tmp[["mtime"]], msg)
[10:33:36.395]                       ex$message <- msg
[10:33:36.395]                       stop(ex)
[10:33:36.395]                     })
[10:33:36.395]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:36.395]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:36.395]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:36.395]                       fi_tmp <- file.info(pathname_tmp)
[10:33:36.395]                       fi <- file.info(pathname)
[10:33:36.395]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:36.395]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:36.395]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:36.395]                         fi[["size"]], fi[["mtime"]])
[10:33:36.395]                       stop(msg)
[10:33:36.395]                     }
[10:33:36.395]                     invisible(pathname)
[10:33:36.395]                   }
[10:33:36.395]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:36.395]                     rootPath = tempdir()) 
[10:33:36.395]                   {
[10:33:36.395]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:36.395]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:36.395]                       tmpdir = path, fileext = ".rds")
[10:33:36.395]                     save_rds(obj, file)
[10:33:36.395]                   }
[10:33:36.395]                   saveImmediateCondition(cond, path = "/tmp/RtmpTlTEh1/.future/immediateConditions")
[10:33:36.395]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:36.395]                   {
[10:33:36.395]                     inherits <- base::inherits
[10:33:36.395]                     invokeRestart <- base::invokeRestart
[10:33:36.395]                     is.null <- base::is.null
[10:33:36.395]                     muffled <- FALSE
[10:33:36.395]                     if (inherits(cond, "message")) {
[10:33:36.395]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:36.395]                       if (muffled) 
[10:33:36.395]                         invokeRestart("muffleMessage")
[10:33:36.395]                     }
[10:33:36.395]                     else if (inherits(cond, "warning")) {
[10:33:36.395]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:36.395]                       if (muffled) 
[10:33:36.395]                         invokeRestart("muffleWarning")
[10:33:36.395]                     }
[10:33:36.395]                     else if (inherits(cond, "condition")) {
[10:33:36.395]                       if (!is.null(pattern)) {
[10:33:36.395]                         computeRestarts <- base::computeRestarts
[10:33:36.395]                         grepl <- base::grepl
[10:33:36.395]                         restarts <- computeRestarts(cond)
[10:33:36.395]                         for (restart in restarts) {
[10:33:36.395]                           name <- restart$name
[10:33:36.395]                           if (is.null(name)) 
[10:33:36.395]                             next
[10:33:36.395]                           if (!grepl(pattern, name)) 
[10:33:36.395]                             next
[10:33:36.395]                           invokeRestart(restart)
[10:33:36.395]                           muffled <- TRUE
[10:33:36.395]                           break
[10:33:36.395]                         }
[10:33:36.395]                       }
[10:33:36.395]                     }
[10:33:36.395]                     invisible(muffled)
[10:33:36.395]                   }
[10:33:36.395]                   muffleCondition(cond)
[10:33:36.395]                 })
[10:33:36.395]             }))
[10:33:36.395]             future::FutureResult(value = ...future.value$value, 
[10:33:36.395]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:36.395]                   ...future.rng), globalenv = if (FALSE) 
[10:33:36.395]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:36.395]                     ...future.globalenv.names))
[10:33:36.395]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:36.395]         }, condition = base::local({
[10:33:36.395]             c <- base::c
[10:33:36.395]             inherits <- base::inherits
[10:33:36.395]             invokeRestart <- base::invokeRestart
[10:33:36.395]             length <- base::length
[10:33:36.395]             list <- base::list
[10:33:36.395]             seq.int <- base::seq.int
[10:33:36.395]             signalCondition <- base::signalCondition
[10:33:36.395]             sys.calls <- base::sys.calls
[10:33:36.395]             `[[` <- base::`[[`
[10:33:36.395]             `+` <- base::`+`
[10:33:36.395]             `<<-` <- base::`<<-`
[10:33:36.395]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:36.395]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:36.395]                   3L)]
[10:33:36.395]             }
[10:33:36.395]             function(cond) {
[10:33:36.395]                 is_error <- inherits(cond, "error")
[10:33:36.395]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:36.395]                   NULL)
[10:33:36.395]                 if (is_error) {
[10:33:36.395]                   sessionInformation <- function() {
[10:33:36.395]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:36.395]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:36.395]                       search = base::search(), system = base::Sys.info())
[10:33:36.395]                   }
[10:33:36.395]                   ...future.conditions[[length(...future.conditions) + 
[10:33:36.395]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:36.395]                     cond$call), session = sessionInformation(), 
[10:33:36.395]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:36.395]                   signalCondition(cond)
[10:33:36.395]                 }
[10:33:36.395]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:36.395]                 "immediateCondition"))) {
[10:33:36.395]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:36.395]                   ...future.conditions[[length(...future.conditions) + 
[10:33:36.395]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:36.395]                   if (TRUE && !signal) {
[10:33:36.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:36.395]                     {
[10:33:36.395]                       inherits <- base::inherits
[10:33:36.395]                       invokeRestart <- base::invokeRestart
[10:33:36.395]                       is.null <- base::is.null
[10:33:36.395]                       muffled <- FALSE
[10:33:36.395]                       if (inherits(cond, "message")) {
[10:33:36.395]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:36.395]                         if (muffled) 
[10:33:36.395]                           invokeRestart("muffleMessage")
[10:33:36.395]                       }
[10:33:36.395]                       else if (inherits(cond, "warning")) {
[10:33:36.395]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:36.395]                         if (muffled) 
[10:33:36.395]                           invokeRestart("muffleWarning")
[10:33:36.395]                       }
[10:33:36.395]                       else if (inherits(cond, "condition")) {
[10:33:36.395]                         if (!is.null(pattern)) {
[10:33:36.395]                           computeRestarts <- base::computeRestarts
[10:33:36.395]                           grepl <- base::grepl
[10:33:36.395]                           restarts <- computeRestarts(cond)
[10:33:36.395]                           for (restart in restarts) {
[10:33:36.395]                             name <- restart$name
[10:33:36.395]                             if (is.null(name)) 
[10:33:36.395]                               next
[10:33:36.395]                             if (!grepl(pattern, name)) 
[10:33:36.395]                               next
[10:33:36.395]                             invokeRestart(restart)
[10:33:36.395]                             muffled <- TRUE
[10:33:36.395]                             break
[10:33:36.395]                           }
[10:33:36.395]                         }
[10:33:36.395]                       }
[10:33:36.395]                       invisible(muffled)
[10:33:36.395]                     }
[10:33:36.395]                     muffleCondition(cond, pattern = "^muffle")
[10:33:36.395]                   }
[10:33:36.395]                 }
[10:33:36.395]                 else {
[10:33:36.395]                   if (TRUE) {
[10:33:36.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:36.395]                     {
[10:33:36.395]                       inherits <- base::inherits
[10:33:36.395]                       invokeRestart <- base::invokeRestart
[10:33:36.395]                       is.null <- base::is.null
[10:33:36.395]                       muffled <- FALSE
[10:33:36.395]                       if (inherits(cond, "message")) {
[10:33:36.395]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:36.395]                         if (muffled) 
[10:33:36.395]                           invokeRestart("muffleMessage")
[10:33:36.395]                       }
[10:33:36.395]                       else if (inherits(cond, "warning")) {
[10:33:36.395]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:36.395]                         if (muffled) 
[10:33:36.395]                           invokeRestart("muffleWarning")
[10:33:36.395]                       }
[10:33:36.395]                       else if (inherits(cond, "condition")) {
[10:33:36.395]                         if (!is.null(pattern)) {
[10:33:36.395]                           computeRestarts <- base::computeRestarts
[10:33:36.395]                           grepl <- base::grepl
[10:33:36.395]                           restarts <- computeRestarts(cond)
[10:33:36.395]                           for (restart in restarts) {
[10:33:36.395]                             name <- restart$name
[10:33:36.395]                             if (is.null(name)) 
[10:33:36.395]                               next
[10:33:36.395]                             if (!grepl(pattern, name)) 
[10:33:36.395]                               next
[10:33:36.395]                             invokeRestart(restart)
[10:33:36.395]                             muffled <- TRUE
[10:33:36.395]                             break
[10:33:36.395]                           }
[10:33:36.395]                         }
[10:33:36.395]                       }
[10:33:36.395]                       invisible(muffled)
[10:33:36.395]                     }
[10:33:36.395]                     muffleCondition(cond, pattern = "^muffle")
[10:33:36.395]                   }
[10:33:36.395]                 }
[10:33:36.395]             }
[10:33:36.395]         }))
[10:33:36.395]     }, error = function(ex) {
[10:33:36.395]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:36.395]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:36.395]                 ...future.rng), started = ...future.startTime, 
[10:33:36.395]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:36.395]             version = "1.8"), class = "FutureResult")
[10:33:36.395]     }, finally = {
[10:33:36.395]         if (!identical(...future.workdir, getwd())) 
[10:33:36.395]             setwd(...future.workdir)
[10:33:36.395]         {
[10:33:36.395]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:36.395]                 ...future.oldOptions$nwarnings <- NULL
[10:33:36.395]             }
[10:33:36.395]             base::options(...future.oldOptions)
[10:33:36.395]             if (.Platform$OS.type == "windows") {
[10:33:36.395]                 old_names <- names(...future.oldEnvVars)
[10:33:36.395]                 envs <- base::Sys.getenv()
[10:33:36.395]                 names <- names(envs)
[10:33:36.395]                 common <- intersect(names, old_names)
[10:33:36.395]                 added <- setdiff(names, old_names)
[10:33:36.395]                 removed <- setdiff(old_names, names)
[10:33:36.395]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:36.395]                   envs[common]]
[10:33:36.395]                 NAMES <- toupper(changed)
[10:33:36.395]                 args <- list()
[10:33:36.395]                 for (kk in seq_along(NAMES)) {
[10:33:36.395]                   name <- changed[[kk]]
[10:33:36.395]                   NAME <- NAMES[[kk]]
[10:33:36.395]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.395]                     next
[10:33:36.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:36.395]                 }
[10:33:36.395]                 NAMES <- toupper(added)
[10:33:36.395]                 for (kk in seq_along(NAMES)) {
[10:33:36.395]                   name <- added[[kk]]
[10:33:36.395]                   NAME <- NAMES[[kk]]
[10:33:36.395]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.395]                     next
[10:33:36.395]                   args[[name]] <- ""
[10:33:36.395]                 }
[10:33:36.395]                 NAMES <- toupper(removed)
[10:33:36.395]                 for (kk in seq_along(NAMES)) {
[10:33:36.395]                   name <- removed[[kk]]
[10:33:36.395]                   NAME <- NAMES[[kk]]
[10:33:36.395]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.395]                     next
[10:33:36.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:36.395]                 }
[10:33:36.395]                 if (length(args) > 0) 
[10:33:36.395]                   base::do.call(base::Sys.setenv, args = args)
[10:33:36.395]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:36.395]             }
[10:33:36.395]             else {
[10:33:36.395]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:36.395]             }
[10:33:36.395]             {
[10:33:36.395]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:36.395]                   0L) {
[10:33:36.395]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:36.395]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:36.395]                   base::options(opts)
[10:33:36.395]                 }
[10:33:36.395]                 {
[10:33:36.395]                   {
[10:33:36.395]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:36.395]                     NULL
[10:33:36.395]                   }
[10:33:36.395]                   options(future.plan = NULL)
[10:33:36.395]                   if (is.na(NA_character_)) 
[10:33:36.395]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:36.395]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:36.395]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:36.395]                     .init = FALSE)
[10:33:36.395]                 }
[10:33:36.395]             }
[10:33:36.395]         }
[10:33:36.395]     })
[10:33:36.395]     if (TRUE) {
[10:33:36.395]         base::sink(type = "output", split = FALSE)
[10:33:36.395]         if (TRUE) {
[10:33:36.395]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:36.395]         }
[10:33:36.395]         else {
[10:33:36.395]             ...future.result["stdout"] <- base::list(NULL)
[10:33:36.395]         }
[10:33:36.395]         base::close(...future.stdout)
[10:33:36.395]         ...future.stdout <- NULL
[10:33:36.395]     }
[10:33:36.395]     ...future.result$conditions <- ...future.conditions
[10:33:36.395]     ...future.result$finished <- base::Sys.time()
[10:33:36.395]     ...future.result
[10:33:36.395] }
[10:33:36.434]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.397] assign_globals() ...
[10:33:36.434]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.397] List of 3
[10:33:36.397]  $ nested_a:List of 1
[10:33:36.397]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:33:36.397]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:33:36.397]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:33:36.397]  $ a       : int 1
[10:33:36.397]  $ plan_a  :List of 1
[10:33:36.397]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:33:36.397]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:33:36.397]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:33:36.397]  - attr(*, "where")=List of 3
[10:33:36.397]   ..$ nested_a:<environment: R_EmptyEnv> 
[10:33:36.397]   ..$ a       :<environment: R_EmptyEnv> 
[10:33:36.397]   ..$ plan_a  :<environment: R_EmptyEnv> 
[10:33:36.397]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:36.397]  - attr(*, "resolved")= logi FALSE
[10:33:36.397]  - attr(*, "total_size")= num 95240
[10:33:36.397]  - attr(*, "already-done")= logi TRUE
[10:33:36.434]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.402] - copied ‘nested_a’ to environment
[10:33:36.434]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.402] - copied ‘a’ to environment
[10:33:36.434]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.402] - copied ‘plan_a’ to environment
[10:33:36.434]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.402] assign_globals() ... done
[10:33:36.435]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.402] requestCore(): workers = 2
[10:33:36.435]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.405] MulticoreFuture started
[10:33:36.435]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.406] - Launch lazy future ... done
[10:33:36.435]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.406] run() for ‘MulticoreFuture’ ... done
[10:33:36.435]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.407] result() for MulticoreFuture ...
[10:33:36.435]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.419] result() for MulticoreFuture ...
[10:33:36.436]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.419] result() for MulticoreFuture ... done
[10:33:36.436]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.419] result() for MulticoreFuture ... done
[10:33:36.436]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.419] result() for MulticoreFuture ...
[10:33:36.436]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.422] result() for MulticoreFuture ... done
[10:33:36.436] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:33:36.442] getGlobalsAndPackages() ...
[10:33:36.442] Searching for globals...
[10:33:36.443] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:33:36.444] Searching for globals ... DONE
[10:33:36.444] Resolving globals: FALSE
[10:33:36.444] The total size of the 1 globals is 128 bytes (128 bytes)
[10:33:36.445] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:33:36.445] - globals: [1] ‘data’
[10:33:36.445] - packages: [1] ‘future’
[10:33:36.445] getGlobalsAndPackages() ... DONE
[10:33:36.445] run() for ‘Future’ ...
[10:33:36.445] - state: ‘created’
[10:33:36.446] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:36.446] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:36.446] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:36.446]   - Field: ‘label’
[10:33:36.446]   - Field: ‘local’
[10:33:36.446]   - Field: ‘owner’
[10:33:36.446]   - Field: ‘envir’
[10:33:36.447]   - Field: ‘packages’
[10:33:36.447]   - Field: ‘gc’
[10:33:36.448]   - Field: ‘conditions’
[10:33:36.448]   - Field: ‘expr’
[10:33:36.448]   - Field: ‘uuid’
[10:33:36.448]   - Field: ‘seed’
[10:33:36.448]   - Field: ‘version’
[10:33:36.449]   - Field: ‘result’
[10:33:36.449]   - Field: ‘asynchronous’
[10:33:36.449]   - Field: ‘calls’
[10:33:36.449]   - Field: ‘globals’
[10:33:36.449]   - Field: ‘stdout’
[10:33:36.449]   - Field: ‘earlySignal’
[10:33:36.449]   - Field: ‘lazy’
[10:33:36.449]   - Field: ‘state’
[10:33:36.449] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:36.449] - Launch lazy future ...
[10:33:36.450] Packages needed by the future expression (n = 1): ‘future’
[10:33:36.450] Packages needed by future strategies (n = 1): ‘future’
[10:33:36.450] {
[10:33:36.450]     {
[10:33:36.450]         {
[10:33:36.450]             ...future.startTime <- base::Sys.time()
[10:33:36.450]             {
[10:33:36.450]                 {
[10:33:36.450]                   {
[10:33:36.450]                     {
[10:33:36.450]                       base::local({
[10:33:36.450]                         has_future <- base::requireNamespace("future", 
[10:33:36.450]                           quietly = TRUE)
[10:33:36.450]                         if (has_future) {
[10:33:36.450]                           ns <- base::getNamespace("future")
[10:33:36.450]                           version <- ns[[".package"]][["version"]]
[10:33:36.450]                           if (is.null(version)) 
[10:33:36.450]                             version <- utils::packageVersion("future")
[10:33:36.450]                         }
[10:33:36.450]                         else {
[10:33:36.450]                           version <- NULL
[10:33:36.450]                         }
[10:33:36.450]                         if (!has_future || version < "1.8.0") {
[10:33:36.450]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:36.450]                             "", base::R.version$version.string), 
[10:33:36.450]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:36.450]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:36.450]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:36.450]                               "release", "version")], collapse = " "), 
[10:33:36.450]                             hostname = base::Sys.info()[["nodename"]])
[10:33:36.450]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:36.450]                             info)
[10:33:36.450]                           info <- base::paste(info, collapse = "; ")
[10:33:36.450]                           if (!has_future) {
[10:33:36.450]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:36.450]                               info)
[10:33:36.450]                           }
[10:33:36.450]                           else {
[10:33:36.450]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:36.450]                               info, version)
[10:33:36.450]                           }
[10:33:36.450]                           base::stop(msg)
[10:33:36.450]                         }
[10:33:36.450]                       })
[10:33:36.450]                     }
[10:33:36.450]                     base::local({
[10:33:36.450]                       for (pkg in "future") {
[10:33:36.450]                         base::loadNamespace(pkg)
[10:33:36.450]                         base::library(pkg, character.only = TRUE)
[10:33:36.450]                       }
[10:33:36.450]                     })
[10:33:36.450]                   }
[10:33:36.450]                   ...future.strategy.old <- future::plan("list")
[10:33:36.450]                   options(future.plan = NULL)
[10:33:36.450]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:36.450]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:33:36.450]                     envir = parent.frame()) 
[10:33:36.450]                   {
[10:33:36.450]                     default_workers <- missing(workers)
[10:33:36.450]                     if (is.function(workers)) 
[10:33:36.450]                       workers <- workers()
[10:33:36.450]                     workers <- structure(as.integer(workers), 
[10:33:36.450]                       class = class(workers))
[10:33:36.450]                     stop_if_not(is.finite(workers), workers >= 
[10:33:36.450]                       1L)
[10:33:36.450]                     if ((workers == 1L && !inherits(workers, 
[10:33:36.450]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:33:36.450]                       if (default_workers) 
[10:33:36.450]                         supportsMulticore(warn = TRUE)
[10:33:36.450]                       return(sequential(..., envir = envir))
[10:33:36.450]                     }
[10:33:36.450]                     oopts <- options(mc.cores = workers)
[10:33:36.450]                     on.exit(options(oopts))
[10:33:36.450]                     future <- MulticoreFuture(..., workers = workers, 
[10:33:36.450]                       envir = envir)
[10:33:36.450]                     if (!future$lazy) 
[10:33:36.450]                       future <- run(future)
[10:33:36.450]                     invisible(future)
[10:33:36.450]                   }), .cleanup = FALSE, .init = FALSE)
[10:33:36.450]                 }
[10:33:36.450]                 ...future.workdir <- getwd()
[10:33:36.450]             }
[10:33:36.450]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:36.450]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:36.450]         }
[10:33:36.450]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:36.450]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:36.450]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:36.450]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:36.450]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:36.450]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:36.450]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:36.450]             base::names(...future.oldOptions))
[10:33:36.450]     }
[10:33:36.450]     if (FALSE) {
[10:33:36.450]     }
[10:33:36.450]     else {
[10:33:36.450]         if (TRUE) {
[10:33:36.450]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:36.450]                 open = "w")
[10:33:36.450]         }
[10:33:36.450]         else {
[10:33:36.450]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:36.450]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:36.450]         }
[10:33:36.450]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:36.450]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:36.450]             base::sink(type = "output", split = FALSE)
[10:33:36.450]             base::close(...future.stdout)
[10:33:36.450]         }, add = TRUE)
[10:33:36.450]     }
[10:33:36.450]     ...future.frame <- base::sys.nframe()
[10:33:36.450]     ...future.conditions <- base::list()
[10:33:36.450]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:36.450]     if (FALSE) {
[10:33:36.450]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:36.450]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:36.450]     }
[10:33:36.450]     ...future.result <- base::tryCatch({
[10:33:36.450]         base::withCallingHandlers({
[10:33:36.450]             ...future.value <- base::withVisible(base::local({
[10:33:36.450]                 value(future(subset(data, a == 2)))
[10:33:36.450]             }))
[10:33:36.450]             future::FutureResult(value = ...future.value$value, 
[10:33:36.450]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:36.450]                   ...future.rng), globalenv = if (FALSE) 
[10:33:36.450]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:36.450]                     ...future.globalenv.names))
[10:33:36.450]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:36.450]         }, condition = base::local({
[10:33:36.450]             c <- base::c
[10:33:36.450]             inherits <- base::inherits
[10:33:36.450]             invokeRestart <- base::invokeRestart
[10:33:36.450]             length <- base::length
[10:33:36.450]             list <- base::list
[10:33:36.450]             seq.int <- base::seq.int
[10:33:36.450]             signalCondition <- base::signalCondition
[10:33:36.450]             sys.calls <- base::sys.calls
[10:33:36.450]             `[[` <- base::`[[`
[10:33:36.450]             `+` <- base::`+`
[10:33:36.450]             `<<-` <- base::`<<-`
[10:33:36.450]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:36.450]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:36.450]                   3L)]
[10:33:36.450]             }
[10:33:36.450]             function(cond) {
[10:33:36.450]                 is_error <- inherits(cond, "error")
[10:33:36.450]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:36.450]                   NULL)
[10:33:36.450]                 if (is_error) {
[10:33:36.450]                   sessionInformation <- function() {
[10:33:36.450]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:36.450]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:36.450]                       search = base::search(), system = base::Sys.info())
[10:33:36.450]                   }
[10:33:36.450]                   ...future.conditions[[length(...future.conditions) + 
[10:33:36.450]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:36.450]                     cond$call), session = sessionInformation(), 
[10:33:36.450]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:36.450]                   signalCondition(cond)
[10:33:36.450]                 }
[10:33:36.450]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:36.450]                 "immediateCondition"))) {
[10:33:36.450]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:36.450]                   ...future.conditions[[length(...future.conditions) + 
[10:33:36.450]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:36.450]                   if (TRUE && !signal) {
[10:33:36.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:36.450]                     {
[10:33:36.450]                       inherits <- base::inherits
[10:33:36.450]                       invokeRestart <- base::invokeRestart
[10:33:36.450]                       is.null <- base::is.null
[10:33:36.450]                       muffled <- FALSE
[10:33:36.450]                       if (inherits(cond, "message")) {
[10:33:36.450]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:36.450]                         if (muffled) 
[10:33:36.450]                           invokeRestart("muffleMessage")
[10:33:36.450]                       }
[10:33:36.450]                       else if (inherits(cond, "warning")) {
[10:33:36.450]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:36.450]                         if (muffled) 
[10:33:36.450]                           invokeRestart("muffleWarning")
[10:33:36.450]                       }
[10:33:36.450]                       else if (inherits(cond, "condition")) {
[10:33:36.450]                         if (!is.null(pattern)) {
[10:33:36.450]                           computeRestarts <- base::computeRestarts
[10:33:36.450]                           grepl <- base::grepl
[10:33:36.450]                           restarts <- computeRestarts(cond)
[10:33:36.450]                           for (restart in restarts) {
[10:33:36.450]                             name <- restart$name
[10:33:36.450]                             if (is.null(name)) 
[10:33:36.450]                               next
[10:33:36.450]                             if (!grepl(pattern, name)) 
[10:33:36.450]                               next
[10:33:36.450]                             invokeRestart(restart)
[10:33:36.450]                             muffled <- TRUE
[10:33:36.450]                             break
[10:33:36.450]                           }
[10:33:36.450]                         }
[10:33:36.450]                       }
[10:33:36.450]                       invisible(muffled)
[10:33:36.450]                     }
[10:33:36.450]                     muffleCondition(cond, pattern = "^muffle")
[10:33:36.450]                   }
[10:33:36.450]                 }
[10:33:36.450]                 else {
[10:33:36.450]                   if (TRUE) {
[10:33:36.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:36.450]                     {
[10:33:36.450]                       inherits <- base::inherits
[10:33:36.450]                       invokeRestart <- base::invokeRestart
[10:33:36.450]                       is.null <- base::is.null
[10:33:36.450]                       muffled <- FALSE
[10:33:36.450]                       if (inherits(cond, "message")) {
[10:33:36.450]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:36.450]                         if (muffled) 
[10:33:36.450]                           invokeRestart("muffleMessage")
[10:33:36.450]                       }
[10:33:36.450]                       else if (inherits(cond, "warning")) {
[10:33:36.450]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:36.450]                         if (muffled) 
[10:33:36.450]                           invokeRestart("muffleWarning")
[10:33:36.450]                       }
[10:33:36.450]                       else if (inherits(cond, "condition")) {
[10:33:36.450]                         if (!is.null(pattern)) {
[10:33:36.450]                           computeRestarts <- base::computeRestarts
[10:33:36.450]                           grepl <- base::grepl
[10:33:36.450]                           restarts <- computeRestarts(cond)
[10:33:36.450]                           for (restart in restarts) {
[10:33:36.450]                             name <- restart$name
[10:33:36.450]                             if (is.null(name)) 
[10:33:36.450]                               next
[10:33:36.450]                             if (!grepl(pattern, name)) 
[10:33:36.450]                               next
[10:33:36.450]                             invokeRestart(restart)
[10:33:36.450]                             muffled <- TRUE
[10:33:36.450]                             break
[10:33:36.450]                           }
[10:33:36.450]                         }
[10:33:36.450]                       }
[10:33:36.450]                       invisible(muffled)
[10:33:36.450]                     }
[10:33:36.450]                     muffleCondition(cond, pattern = "^muffle")
[10:33:36.450]                   }
[10:33:36.450]                 }
[10:33:36.450]             }
[10:33:36.450]         }))
[10:33:36.450]     }, error = function(ex) {
[10:33:36.450]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:36.450]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:36.450]                 ...future.rng), started = ...future.startTime, 
[10:33:36.450]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:36.450]             version = "1.8"), class = "FutureResult")
[10:33:36.450]     }, finally = {
[10:33:36.450]         if (!identical(...future.workdir, getwd())) 
[10:33:36.450]             setwd(...future.workdir)
[10:33:36.450]         {
[10:33:36.450]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:36.450]                 ...future.oldOptions$nwarnings <- NULL
[10:33:36.450]             }
[10:33:36.450]             base::options(...future.oldOptions)
[10:33:36.450]             if (.Platform$OS.type == "windows") {
[10:33:36.450]                 old_names <- names(...future.oldEnvVars)
[10:33:36.450]                 envs <- base::Sys.getenv()
[10:33:36.450]                 names <- names(envs)
[10:33:36.450]                 common <- intersect(names, old_names)
[10:33:36.450]                 added <- setdiff(names, old_names)
[10:33:36.450]                 removed <- setdiff(old_names, names)
[10:33:36.450]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:36.450]                   envs[common]]
[10:33:36.450]                 NAMES <- toupper(changed)
[10:33:36.450]                 args <- list()
[10:33:36.450]                 for (kk in seq_along(NAMES)) {
[10:33:36.450]                   name <- changed[[kk]]
[10:33:36.450]                   NAME <- NAMES[[kk]]
[10:33:36.450]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.450]                     next
[10:33:36.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:36.450]                 }
[10:33:36.450]                 NAMES <- toupper(added)
[10:33:36.450]                 for (kk in seq_along(NAMES)) {
[10:33:36.450]                   name <- added[[kk]]
[10:33:36.450]                   NAME <- NAMES[[kk]]
[10:33:36.450]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.450]                     next
[10:33:36.450]                   args[[name]] <- ""
[10:33:36.450]                 }
[10:33:36.450]                 NAMES <- toupper(removed)
[10:33:36.450]                 for (kk in seq_along(NAMES)) {
[10:33:36.450]                   name <- removed[[kk]]
[10:33:36.450]                   NAME <- NAMES[[kk]]
[10:33:36.450]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.450]                     next
[10:33:36.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:36.450]                 }
[10:33:36.450]                 if (length(args) > 0) 
[10:33:36.450]                   base::do.call(base::Sys.setenv, args = args)
[10:33:36.450]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:36.450]             }
[10:33:36.450]             else {
[10:33:36.450]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:36.450]             }
[10:33:36.450]             {
[10:33:36.450]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:36.450]                   0L) {
[10:33:36.450]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:36.450]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:36.450]                   base::options(opts)
[10:33:36.450]                 }
[10:33:36.450]                 {
[10:33:36.450]                   {
[10:33:36.450]                     NULL
[10:33:36.450]                     RNGkind("Mersenne-Twister")
[10:33:36.450]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:36.450]                       inherits = FALSE)
[10:33:36.450]                   }
[10:33:36.450]                   options(future.plan = NULL)
[10:33:36.450]                   if (is.na(NA_character_)) 
[10:33:36.450]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:36.450]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:36.450]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:36.450]                     .init = FALSE)
[10:33:36.450]                 }
[10:33:36.450]             }
[10:33:36.450]         }
[10:33:36.450]     })
[10:33:36.450]     if (TRUE) {
[10:33:36.450]         base::sink(type = "output", split = FALSE)
[10:33:36.450]         if (TRUE) {
[10:33:36.450]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:36.450]         }
[10:33:36.450]         else {
[10:33:36.450]             ...future.result["stdout"] <- base::list(NULL)
[10:33:36.450]         }
[10:33:36.450]         base::close(...future.stdout)
[10:33:36.450]         ...future.stdout <- NULL
[10:33:36.450]     }
[10:33:36.450]     ...future.result$conditions <- ...future.conditions
[10:33:36.450]     ...future.result$finished <- base::Sys.time()
[10:33:36.450]     ...future.result
[10:33:36.450] }
[10:33:36.452] assign_globals() ...
[10:33:36.452] List of 1
[10:33:36.452]  $ data:'data.frame':	3 obs. of  2 variables:
[10:33:36.452]   ..$ a: int [1:3] 1 2 3
[10:33:36.452]   ..$ b: int [1:3] 3 2 1
[10:33:36.452]  - attr(*, "where")=List of 1
[10:33:36.452]   ..$ data:<environment: R_EmptyEnv> 
[10:33:36.452]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:36.452]  - attr(*, "resolved")= logi FALSE
[10:33:36.452]  - attr(*, "total_size")= num 128
[10:33:36.452]  - attr(*, "already-done")= logi TRUE
[10:33:36.455] - copied ‘data’ to environment
[10:33:36.455] assign_globals() ... done
[10:33:36.456] plan(): Setting new future strategy stack:
[10:33:36.456] List of future strategies:
[10:33:36.456] 1. multicore:
[10:33:36.456]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:36.456]    - tweaked: FALSE
[10:33:36.456]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:36.460] plan(): nbrOfWorkers() = 2
[10:33:36.506] plan(): Setting new future strategy stack:
[10:33:36.506] List of future strategies:
[10:33:36.506] 1. sequential:
[10:33:36.506]    - args: function (..., envir = parent.frame())
[10:33:36.506]    - tweaked: FALSE
[10:33:36.506]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:36.506] 2. multicore:
[10:33:36.506]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:36.506]    - tweaked: FALSE
[10:33:36.506]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:36.507] plan(): nbrOfWorkers() = 1
[10:33:36.507] SequentialFuture started (and completed)
[10:33:36.507] signalConditions() ...
[10:33:36.507]  - include = ‘immediateCondition’
[10:33:36.507]  - exclude = 
[10:33:36.507]  - resignal = FALSE
[10:33:36.508]  - Number of conditions: 55
[10:33:36.508] signalConditions() ... done
[10:33:36.508] - Launch lazy future ... done
[10:33:36.508] run() for ‘SequentialFuture’ ... done
[10:33:36.508] signalConditions() ...
[10:33:36.508]  - include = ‘immediateCondition’
[10:33:36.508]  - exclude = 
[10:33:36.508]  - resignal = FALSE
[10:33:36.509]  - Number of conditions: 55
[10:33:36.511] signalConditions() ... done
[10:33:36.511] Future state: ‘finished’
[10:33:36.512] signalConditions() ...
[10:33:36.512]  - include = ‘condition’
[10:33:36.512]  - exclude = ‘immediateCondition’
[10:33:36.512]  - resignal = TRUE
[10:33:36.512]  - Number of conditions: 55
[10:33:36.512]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.460] getGlobalsAndPackages() ...
[10:33:36.512]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.461] Searching for globals...
[10:33:36.513]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.476] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[10:33:36.513]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.476] Searching for globals ... DONE
[10:33:36.513]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.476] Resolving globals: FALSE
[10:33:36.513]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.476] The total size of the 1 globals is 128 bytes (128 bytes)
[10:33:36.513]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.477] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:33:36.514]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.477] - globals: [1] ‘data’
[10:33:36.514]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.477] 
[10:33:36.514]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.477] getGlobalsAndPackages() ... DONE
[10:33:36.514]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.477] run() for ‘Future’ ...
[10:33:36.514]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.477] - state: ‘created’
[10:33:36.515]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.478] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:36.515]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.481] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:36.515]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.482] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:36.515]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.482]   - Field: ‘label’
[10:33:36.515]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.482]   - Field: ‘local’
[10:33:36.516]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.482]   - Field: ‘owner’
[10:33:36.516]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.482]   - Field: ‘envir’
[10:33:36.516]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.482]   - Field: ‘workers’
[10:33:36.516]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.483]   - Field: ‘packages’
[10:33:36.516]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.483]   - Field: ‘gc’
[10:33:36.516]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.483]   - Field: ‘job’
[10:33:36.517]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.483]   - Field: ‘conditions’
[10:33:36.517]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.483]   - Field: ‘expr’
[10:33:36.517]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.483]   - Field: ‘uuid’
[10:33:36.517]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.483]   - Field: ‘seed’
[10:33:36.517]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.483]   - Field: ‘version’
[10:33:36.517]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.483]   - Field: ‘result’
[10:33:36.518]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.484]   - Field: ‘asynchronous’
[10:33:36.518]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.484]   - Field: ‘calls’
[10:33:36.518]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.484]   - Field: ‘globals’
[10:33:36.518]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.484]   - Field: ‘stdout’
[10:33:36.518]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.484]   - Field: ‘earlySignal’
[10:33:36.518]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.484]   - Field: ‘lazy’
[10:33:36.519]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.484]   - Field: ‘state’
[10:33:36.519]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.484] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:36.519]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.484] - Launch lazy future ...
[10:33:36.519]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.485] Packages needed by the future expression (n = 0): <none>
[10:33:36.519]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.485] Packages needed by future strategies (n = 0): <none>
[10:33:36.519]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.485] {
[10:33:36.485]     {
[10:33:36.485]         {
[10:33:36.485]             ...future.startTime <- base::Sys.time()
[10:33:36.485]             {
[10:33:36.485]                 {
[10:33:36.485]                   {
[10:33:36.485]                     {
[10:33:36.485]                       base::local({
[10:33:36.485]                         has_future <- base::requireNamespace("future", 
[10:33:36.485]                           quietly = TRUE)
[10:33:36.485]                         if (has_future) {
[10:33:36.485]                           ns <- base::getNamespace("future")
[10:33:36.485]                           version <- ns[[".package"]][["version"]]
[10:33:36.485]                           if (is.null(version)) 
[10:33:36.485]                             version <- utils::packageVersion("future")
[10:33:36.485]                         }
[10:33:36.485]                         else {
[10:33:36.485]                           version <- NULL
[10:33:36.485]                         }
[10:33:36.485]                         if (!has_future || version < "1.8.0") {
[10:33:36.485]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:36.485]                             "", base::R.version$version.string), 
[10:33:36.485]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:36.485]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:36.485]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:36.485]                               "release", "version")], collapse = " "), 
[10:33:36.485]                             hostname = base::Sys.info()[["nodename"]])
[10:33:36.485]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:36.485]                             info)
[10:33:36.485]                           info <- base::paste(info, collapse = "; ")
[10:33:36.485]                           if (!has_future) {
[10:33:36.485]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:36.485]                               info)
[10:33:36.485]                           }
[10:33:36.485]                           else {
[10:33:36.485]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:36.485]                               info, version)
[10:33:36.485]                           }
[10:33:36.485]                           base::stop(msg)
[10:33:36.485]                         }
[10:33:36.485]                       })
[10:33:36.485]                     }
[10:33:36.485]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:36.485]                     base::options(mc.cores = 1L)
[10:33:36.485]                   }
[10:33:36.485]                   ...future.strategy.old <- future::plan("list")
[10:33:36.485]                   options(future.plan = NULL)
[10:33:36.485]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:36.485]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:36.485]                 }
[10:33:36.485]                 ...future.workdir <- getwd()
[10:33:36.485]             }
[10:33:36.485]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:36.485]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:36.485]         }
[10:33:36.485]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:36.485]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:36.485]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:36.485]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:36.485]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:36.485]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:36.485]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:36.485]             base::names(...future.oldOptions))
[10:33:36.485]     }
[10:33:36.485]     if (FALSE) {
[10:33:36.485]     }
[10:33:36.485]     else {
[10:33:36.485]         if (TRUE) {
[10:33:36.485]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:36.485]                 open = "w")
[10:33:36.485]         }
[10:33:36.485]         else {
[10:33:36.485]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:36.485]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:36.485]         }
[10:33:36.485]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:36.485]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:36.485]             base::sink(type = "output", split = FALSE)
[10:33:36.485]             base::close(...future.stdout)
[10:33:36.485]         }, add = TRUE)
[10:33:36.485]     }
[10:33:36.485]     ...future.frame <- base::sys.nframe()
[10:33:36.485]     ...future.conditions <- base::list()
[10:33:36.485]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:36.485]     if (FALSE) {
[10:33:36.485]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:36.485]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:36.485]     }
[10:33:36.485]     ...future.result <- base::tryCatch({
[10:33:36.485]         base::withCallingHandlers({
[10:33:36.485]             ...future.value <- base::withVisible(base::local({
[10:33:36.485]                 withCallingHandlers({
[10:33:36.485]                   subset(data, a == 2)
[10:33:36.485]                 }, immediateCondition = function(cond) {
[10:33:36.485]                   save_rds <- function (object, pathname, ...) 
[10:33:36.485]                   {
[10:33:36.485]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:36.485]                     if (file_test("-f", pathname_tmp)) {
[10:33:36.485]                       fi_tmp <- file.info(pathname_tmp)
[10:33:36.485]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:36.485]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:36.485]                         fi_tmp[["mtime"]])
[10:33:36.485]                     }
[10:33:36.485]                     tryCatch({
[10:33:36.485]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:36.485]                     }, error = function(ex) {
[10:33:36.485]                       msg <- conditionMessage(ex)
[10:33:36.485]                       fi_tmp <- file.info(pathname_tmp)
[10:33:36.485]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:36.485]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:36.485]                         fi_tmp[["mtime"]], msg)
[10:33:36.485]                       ex$message <- msg
[10:33:36.485]                       stop(ex)
[10:33:36.485]                     })
[10:33:36.485]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:36.485]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:36.485]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:36.485]                       fi_tmp <- file.info(pathname_tmp)
[10:33:36.485]                       fi <- file.info(pathname)
[10:33:36.485]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:36.485]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:36.485]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:36.485]                         fi[["size"]], fi[["mtime"]])
[10:33:36.485]                       stop(msg)
[10:33:36.485]                     }
[10:33:36.485]                     invisible(pathname)
[10:33:36.485]                   }
[10:33:36.485]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:36.485]                     rootPath = tempdir()) 
[10:33:36.485]                   {
[10:33:36.485]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:36.485]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:36.485]                       tmpdir = path, fileext = ".rds")
[10:33:36.485]                     save_rds(obj, file)
[10:33:36.485]                   }
[10:33:36.485]                   saveImmediateCondition(cond, path = "/tmp/RtmpTlTEh1/.future/immediateConditions")
[10:33:36.485]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:36.485]                   {
[10:33:36.485]                     inherits <- base::inherits
[10:33:36.485]                     invokeRestart <- base::invokeRestart
[10:33:36.485]                     is.null <- base::is.null
[10:33:36.485]                     muffled <- FALSE
[10:33:36.485]                     if (inherits(cond, "message")) {
[10:33:36.485]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:36.485]                       if (muffled) 
[10:33:36.485]                         invokeRestart("muffleMessage")
[10:33:36.485]                     }
[10:33:36.485]                     else if (inherits(cond, "warning")) {
[10:33:36.485]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:36.485]                       if (muffled) 
[10:33:36.485]                         invokeRestart("muffleWarning")
[10:33:36.485]                     }
[10:33:36.485]                     else if (inherits(cond, "condition")) {
[10:33:36.485]                       if (!is.null(pattern)) {
[10:33:36.485]                         computeRestarts <- base::computeRestarts
[10:33:36.485]                         grepl <- base::grepl
[10:33:36.485]                         restarts <- computeRestarts(cond)
[10:33:36.485]                         for (restart in restarts) {
[10:33:36.485]                           name <- restart$name
[10:33:36.485]                           if (is.null(name)) 
[10:33:36.485]                             next
[10:33:36.485]                           if (!grepl(pattern, name)) 
[10:33:36.485]                             next
[10:33:36.485]                           invokeRestart(restart)
[10:33:36.485]                           muffled <- TRUE
[10:33:36.485]                           break
[10:33:36.485]                         }
[10:33:36.485]                       }
[10:33:36.485]                     }
[10:33:36.485]                     invisible(muffled)
[10:33:36.485]                   }
[10:33:36.485]                   muffleCondition(cond)
[10:33:36.485]                 })
[10:33:36.485]             }))
[10:33:36.485]             future::FutureResult(value = ...future.value$value, 
[10:33:36.485]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:36.485]                   ...future.rng), globalenv = if (FALSE) 
[10:33:36.485]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:36.485]                     ...future.globalenv.names))
[10:33:36.485]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:36.485]         }, condition = base::local({
[10:33:36.485]             c <- base::c
[10:33:36.485]             inherits <- base::inherits
[10:33:36.485]             invokeRestart <- base::invokeRestart
[10:33:36.485]             length <- base::length
[10:33:36.485]             list <- base::list
[10:33:36.485]             seq.int <- base::seq.int
[10:33:36.485]             signalCondition <- base::signalCondition
[10:33:36.485]             sys.calls <- base::sys.calls
[10:33:36.485]             `[[` <- base::`[[`
[10:33:36.485]             `+` <- base::`+`
[10:33:36.485]             `<<-` <- base::`<<-`
[10:33:36.485]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:36.485]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:36.485]                   3L)]
[10:33:36.485]             }
[10:33:36.485]             function(cond) {
[10:33:36.485]                 is_error <- inherits(cond, "error")
[10:33:36.485]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:36.485]                   NULL)
[10:33:36.485]                 if (is_error) {
[10:33:36.485]                   sessionInformation <- function() {
[10:33:36.485]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:36.485]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:36.485]                       search = base::search(), system = base::Sys.info())
[10:33:36.485]                   }
[10:33:36.485]                   ...future.conditions[[length(...future.conditions) + 
[10:33:36.485]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:36.485]                     cond$call), session = sessionInformation(), 
[10:33:36.485]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:36.485]                   signalCondition(cond)
[10:33:36.485]                 }
[10:33:36.485]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:36.485]                 "immediateCondition"))) {
[10:33:36.485]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:36.485]                   ...future.conditions[[length(...future.conditions) + 
[10:33:36.485]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:36.485]                   if (TRUE && !signal) {
[10:33:36.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:36.485]                     {
[10:33:36.485]                       inherits <- base::inherits
[10:33:36.485]                       invokeRestart <- base::invokeRestart
[10:33:36.485]                       is.null <- base::is.null
[10:33:36.485]                       muffled <- FALSE
[10:33:36.485]                       if (inherits(cond, "message")) {
[10:33:36.485]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:36.485]                         if (muffled) 
[10:33:36.485]                           invokeRestart("muffleMessage")
[10:33:36.485]                       }
[10:33:36.485]                       else if (inherits(cond, "warning")) {
[10:33:36.485]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:36.485]                         if (muffled) 
[10:33:36.485]                           invokeRestart("muffleWarning")
[10:33:36.485]                       }
[10:33:36.485]                       else if (inherits(cond, "condition")) {
[10:33:36.485]                         if (!is.null(pattern)) {
[10:33:36.485]                           computeRestarts <- base::computeRestarts
[10:33:36.485]                           grepl <- base::grepl
[10:33:36.485]                           restarts <- computeRestarts(cond)
[10:33:36.485]                           for (restart in restarts) {
[10:33:36.485]                             name <- restart$name
[10:33:36.485]                             if (is.null(name)) 
[10:33:36.485]                               next
[10:33:36.485]                             if (!grepl(pattern, name)) 
[10:33:36.485]                               next
[10:33:36.485]                             invokeRestart(restart)
[10:33:36.485]                             muffled <- TRUE
[10:33:36.485]                             break
[10:33:36.485]                           }
[10:33:36.485]                         }
[10:33:36.485]                       }
[10:33:36.485]                       invisible(muffled)
[10:33:36.485]                     }
[10:33:36.485]                     muffleCondition(cond, pattern = "^muffle")
[10:33:36.485]                   }
[10:33:36.485]                 }
[10:33:36.485]                 else {
[10:33:36.485]                   if (TRUE) {
[10:33:36.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:36.485]                     {
[10:33:36.485]                       inherits <- base::inherits
[10:33:36.485]                       invokeRestart <- base::invokeRestart
[10:33:36.485]                       is.null <- base::is.null
[10:33:36.485]                       muffled <- FALSE
[10:33:36.485]                       if (inherits(cond, "message")) {
[10:33:36.485]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:36.485]                         if (muffled) 
[10:33:36.485]                           invokeRestart("muffleMessage")
[10:33:36.485]                       }
[10:33:36.485]                       else if (inherits(cond, "warning")) {
[10:33:36.485]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:36.485]                         if (muffled) 
[10:33:36.485]                           invokeRestart("muffleWarning")
[10:33:36.485]                       }
[10:33:36.485]                       else if (inherits(cond, "condition")) {
[10:33:36.485]                         if (!is.null(pattern)) {
[10:33:36.485]                           computeRestarts <- base::computeRestarts
[10:33:36.485]                           grepl <- base::grepl
[10:33:36.485]                           restarts <- computeRestarts(cond)
[10:33:36.485]                           for (restart in restarts) {
[10:33:36.485]                             name <- restart$name
[10:33:36.485]                             if (is.null(name)) 
[10:33:36.485]                               next
[10:33:36.485]                             if (!grepl(pattern, name)) 
[10:33:36.485]                               next
[10:33:36.485]                             invokeRestart(restart)
[10:33:36.485]                             muffled <- TRUE
[10:33:36.485]                             break
[10:33:36.485]                           }
[10:33:36.485]                         }
[10:33:36.485]                       }
[10:33:36.485]                       invisible(muffled)
[10:33:36.485]                     }
[10:33:36.485]                     muffleCondition(cond, pattern = "^muffle")
[10:33:36.485]                   }
[10:33:36.485]                 }
[10:33:36.485]             }
[10:33:36.485]         }))
[10:33:36.485]     }, error = function(ex) {
[10:33:36.485]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:36.485]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:36.485]                 ...future.rng), started = ...future.startTime, 
[10:33:36.485]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:36.485]             version = "1.8"), class = "FutureResult")
[10:33:36.485]     }, finally = {
[10:33:36.485]         if (!identical(...future.workdir, getwd())) 
[10:33:36.485]             setwd(...future.workdir)
[10:33:36.485]         {
[10:33:36.485]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:36.485]                 ...future.oldOptions$nwarnings <- NULL
[10:33:36.485]             }
[10:33:36.485]             base::options(...future.oldOptions)
[10:33:36.485]             if (.Platform$OS.type == "windows") {
[10:33:36.485]                 old_names <- names(...future.oldEnvVars)
[10:33:36.485]                 envs <- base::Sys.getenv()
[10:33:36.485]                 names <- names(envs)
[10:33:36.485]                 common <- intersect(names, old_names)
[10:33:36.485]                 added <- setdiff(names, old_names)
[10:33:36.485]                 removed <- setdiff(old_names, names)
[10:33:36.485]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:36.485]                   envs[common]]
[10:33:36.485]                 NAMES <- toupper(changed)
[10:33:36.485]                 args <- list()
[10:33:36.485]                 for (kk in seq_along(NAMES)) {
[10:33:36.485]                   name <- changed[[kk]]
[10:33:36.485]                   NAME <- NAMES[[kk]]
[10:33:36.485]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.485]                     next
[10:33:36.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:36.485]                 }
[10:33:36.485]                 NAMES <- toupper(added)
[10:33:36.485]                 for (kk in seq_along(NAMES)) {
[10:33:36.485]                   name <- added[[kk]]
[10:33:36.485]                   NAME <- NAMES[[kk]]
[10:33:36.485]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.485]                     next
[10:33:36.485]                   args[[name]] <- ""
[10:33:36.485]                 }
[10:33:36.485]                 NAMES <- toupper(removed)
[10:33:36.485]                 for (kk in seq_along(NAMES)) {
[10:33:36.485]                   name <- removed[[kk]]
[10:33:36.485]                   NAME <- NAMES[[kk]]
[10:33:36.485]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.485]                     next
[10:33:36.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:36.485]                 }
[10:33:36.485]                 if (length(args) > 0) 
[10:33:36.485]                   base::do.call(base::Sys.setenv, args = args)
[10:33:36.485]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:36.485]             }
[10:33:36.485]             else {
[10:33:36.485]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:36.485]             }
[10:33:36.485]             {
[10:33:36.485]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:36.485]                   0L) {
[10:33:36.485]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:36.485]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:36.485]                   base::options(opts)
[10:33:36.485]                 }
[10:33:36.485]                 {
[10:33:36.485]                   {
[10:33:36.485]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:36.485]                     NULL
[10:33:36.485]                   }
[10:33:36.485]                   options(future.plan = NULL)
[10:33:36.485]                   if (is.na(NA_character_)) 
[10:33:36.485]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:36.485]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:36.485]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:36.485]                     .init = FALSE)
[10:33:36.485]                 }
[10:33:36.485]             }
[10:33:36.485]         }
[10:33:36.485]     })
[10:33:36.485]     if (TRUE) {
[10:33:36.485]         base::sink(type = "output", split = FALSE)
[10:33:36.485]         if (TRUE) {
[10:33:36.485]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:36.485]         }
[10:33:36.485]         else {
[10:33:36.485]             ...future.result["stdout"] <- base::list(NULL)
[10:33:36.485]         }
[10:33:36.485]         base::close(...future.stdout)
[10:33:36.485]         ...future.stdout <- NULL
[10:33:36.485]     }
[10:33:36.485]     ...future.result$conditions <- ...future.conditions
[10:33:36.485]     ...future.result$finished <- base::Sys.time()
[10:33:36.485]     ...future.result
[10:33:36.485] }
[10:33:36.520]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.487] assign_globals() ...
[10:33:36.520]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.487] List of 1
[10:33:36.487]  $ data:'data.frame':	3 obs. of  2 variables:
[10:33:36.487]   ..$ a: int [1:3] 1 2 3
[10:33:36.487]   ..$ b: int [1:3] 3 2 1
[10:33:36.487]  - attr(*, "where")=List of 1
[10:33:36.487]   ..$ data:<environment: R_EmptyEnv> 
[10:33:36.487]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:36.487]  - attr(*, "resolved")= logi FALSE
[10:33:36.487]  - attr(*, "total_size")= num 128
[10:33:36.487]  - attr(*, "already-done")= logi TRUE
[10:33:36.520]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.491] - copied ‘data’ to environment
[10:33:36.520]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.491] assign_globals() ... done
[10:33:36.520]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.491] requestCore(): workers = 2
[10:33:36.520]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.493] MulticoreFuture started
[10:33:36.521]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.494] - Launch lazy future ... done
[10:33:36.521]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.494] run() for ‘MulticoreFuture’ ... done
[10:33:36.521]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.495] result() for MulticoreFuture ...
[10:33:36.521]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.504] result() for MulticoreFuture ...
[10:33:36.521]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.504] result() for MulticoreFuture ... done
[10:33:36.521]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.504] result() for MulticoreFuture ... done
[10:33:36.522]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.504] result() for MulticoreFuture ...
[10:33:36.522]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.505] result() for MulticoreFuture ... done
[10:33:36.522] signalConditions() ... done
- plan(list('sequential', 'multicore')) ... DONE
- plan(list('sequential', 'multisession')) ...
[10:33:36.523] plan(): Setting new future strategy stack:
[10:33:36.523] List of future strategies:
[10:33:36.523] 1. sequential:
[10:33:36.523]    - args: function (..., envir = parent.frame())
[10:33:36.523]    - tweaked: FALSE
[10:33:36.523]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:36.523] 2. multisession:
[10:33:36.523]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:36.523]    - tweaked: FALSE
[10:33:36.523]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:36.523] plan(): nbrOfWorkers() = 1
[10:33:36.524] getGlobalsAndPackages() ...
[10:33:36.524] Searching for globals...
[10:33:36.543] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:33:36.543] Searching for globals ... DONE
[10:33:36.543] Resolving globals: FALSE
[10:33:36.544] The total size of the 2 globals is 55.41 KiB (56736 bytes)
[10:33:36.544] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 55.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (55.29 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[10:33:36.544] - globals: [2] ‘nested’, ‘strategy2’
[10:33:36.545] - packages: [1] ‘future’
[10:33:36.545] getGlobalsAndPackages() ... DONE
[10:33:36.545] run() for ‘Future’ ...
[10:33:36.545] - state: ‘created’
[10:33:36.545] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:36.546] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:36.546] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:36.546]   - Field: ‘label’
[10:33:36.546]   - Field: ‘local’
[10:33:36.546]   - Field: ‘owner’
[10:33:36.546]   - Field: ‘envir’
[10:33:36.546]   - Field: ‘packages’
[10:33:36.546]   - Field: ‘gc’
[10:33:36.546]   - Field: ‘conditions’
[10:33:36.546]   - Field: ‘expr’
[10:33:36.547]   - Field: ‘uuid’
[10:33:36.547]   - Field: ‘seed’
[10:33:36.547]   - Field: ‘version’
[10:33:36.547]   - Field: ‘result’
[10:33:36.547]   - Field: ‘asynchronous’
[10:33:36.547]   - Field: ‘calls’
[10:33:36.547]   - Field: ‘globals’
[10:33:36.547]   - Field: ‘stdout’
[10:33:36.547]   - Field: ‘earlySignal’
[10:33:36.547]   - Field: ‘lazy’
[10:33:36.547]   - Field: ‘state’
[10:33:36.548] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:36.548] - Launch lazy future ...
[10:33:36.548] Packages needed by the future expression (n = 1): ‘future’
[10:33:36.548] Packages needed by future strategies (n = 1): ‘future’
[10:33:36.549] {
[10:33:36.549]     {
[10:33:36.549]         {
[10:33:36.549]             ...future.startTime <- base::Sys.time()
[10:33:36.549]             {
[10:33:36.549]                 {
[10:33:36.549]                   {
[10:33:36.549]                     {
[10:33:36.549]                       base::local({
[10:33:36.549]                         has_future <- base::requireNamespace("future", 
[10:33:36.549]                           quietly = TRUE)
[10:33:36.549]                         if (has_future) {
[10:33:36.549]                           ns <- base::getNamespace("future")
[10:33:36.549]                           version <- ns[[".package"]][["version"]]
[10:33:36.549]                           if (is.null(version)) 
[10:33:36.549]                             version <- utils::packageVersion("future")
[10:33:36.549]                         }
[10:33:36.549]                         else {
[10:33:36.549]                           version <- NULL
[10:33:36.549]                         }
[10:33:36.549]                         if (!has_future || version < "1.8.0") {
[10:33:36.549]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:36.549]                             "", base::R.version$version.string), 
[10:33:36.549]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:36.549]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:36.549]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:36.549]                               "release", "version")], collapse = " "), 
[10:33:36.549]                             hostname = base::Sys.info()[["nodename"]])
[10:33:36.549]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:36.549]                             info)
[10:33:36.549]                           info <- base::paste(info, collapse = "; ")
[10:33:36.549]                           if (!has_future) {
[10:33:36.549]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:36.549]                               info)
[10:33:36.549]                           }
[10:33:36.549]                           else {
[10:33:36.549]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:36.549]                               info, version)
[10:33:36.549]                           }
[10:33:36.549]                           base::stop(msg)
[10:33:36.549]                         }
[10:33:36.549]                       })
[10:33:36.549]                     }
[10:33:36.549]                     base::local({
[10:33:36.549]                       for (pkg in "future") {
[10:33:36.549]                         base::loadNamespace(pkg)
[10:33:36.549]                         base::library(pkg, character.only = TRUE)
[10:33:36.549]                       }
[10:33:36.549]                     })
[10:33:36.549]                   }
[10:33:36.549]                   ...future.strategy.old <- future::plan("list")
[10:33:36.549]                   options(future.plan = NULL)
[10:33:36.549]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:36.549]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:33:36.549]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:33:36.549]                     envir = parent.frame()) 
[10:33:36.549]                   {
[10:33:36.549]                     if (is.function(workers)) 
[10:33:36.549]                       workers <- workers()
[10:33:36.549]                     workers <- structure(as.integer(workers), 
[10:33:36.549]                       class = class(workers))
[10:33:36.549]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:33:36.549]                       workers >= 1)
[10:33:36.549]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:33:36.549]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:33:36.549]                     }
[10:33:36.549]                     future <- MultisessionFuture(..., workers = workers, 
[10:33:36.549]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:33:36.549]                       envir = envir)
[10:33:36.549]                     if (!future$lazy) 
[10:33:36.549]                       future <- run(future)
[10:33:36.549]                     invisible(future)
[10:33:36.549]                   }), .cleanup = FALSE, .init = FALSE)
[10:33:36.549]                 }
[10:33:36.549]                 ...future.workdir <- getwd()
[10:33:36.549]             }
[10:33:36.549]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:36.549]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:36.549]         }
[10:33:36.549]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:36.549]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:36.549]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:36.549]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:36.549]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:36.549]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:36.549]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:36.549]             base::names(...future.oldOptions))
[10:33:36.549]     }
[10:33:36.549]     if (FALSE) {
[10:33:36.549]     }
[10:33:36.549]     else {
[10:33:36.549]         if (TRUE) {
[10:33:36.549]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:36.549]                 open = "w")
[10:33:36.549]         }
[10:33:36.549]         else {
[10:33:36.549]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:36.549]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:36.549]         }
[10:33:36.549]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:36.549]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:36.549]             base::sink(type = "output", split = FALSE)
[10:33:36.549]             base::close(...future.stdout)
[10:33:36.549]         }, add = TRUE)
[10:33:36.549]     }
[10:33:36.549]     ...future.frame <- base::sys.nframe()
[10:33:36.549]     ...future.conditions <- base::list()
[10:33:36.549]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:36.549]     if (FALSE) {
[10:33:36.549]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:36.549]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:36.549]     }
[10:33:36.549]     ...future.result <- base::tryCatch({
[10:33:36.549]         base::withCallingHandlers({
[10:33:36.549]             ...future.value <- base::withVisible(base::local({
[10:33:36.549]                 a <- 1L
[10:33:36.549]                 plan_a <- unclass(future::plan("list"))
[10:33:36.549]                 nested_a <- nested[-1]
[10:33:36.549]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:33:36.549]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:33:36.549]                   strategy2))
[10:33:36.549]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:33:36.549]                   "init") <- NULL
[10:33:36.549]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:33:36.549]                   "init") <- NULL
[10:33:36.549]                 stopifnot(all.equal(plan_a, nested_a))
[10:33:36.549]                 y %<-% {
[10:33:36.549]                   b <- 2L
[10:33:36.549]                   plan_b <- future::plan("list")
[10:33:36.549]                   nested_b <- nested_a[-1]
[10:33:36.549]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:33:36.549]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:33:36.549]                     "sequential"))
[10:33:36.549]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:33:36.549]                     b = b, nested_b = nested_b, plan_b = plan_b)
[10:33:36.549]                 }
[10:33:36.549]                 y
[10:33:36.549]             }))
[10:33:36.549]             future::FutureResult(value = ...future.value$value, 
[10:33:36.549]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:36.549]                   ...future.rng), globalenv = if (FALSE) 
[10:33:36.549]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:36.549]                     ...future.globalenv.names))
[10:33:36.549]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:36.549]         }, condition = base::local({
[10:33:36.549]             c <- base::c
[10:33:36.549]             inherits <- base::inherits
[10:33:36.549]             invokeRestart <- base::invokeRestart
[10:33:36.549]             length <- base::length
[10:33:36.549]             list <- base::list
[10:33:36.549]             seq.int <- base::seq.int
[10:33:36.549]             signalCondition <- base::signalCondition
[10:33:36.549]             sys.calls <- base::sys.calls
[10:33:36.549]             `[[` <- base::`[[`
[10:33:36.549]             `+` <- base::`+`
[10:33:36.549]             `<<-` <- base::`<<-`
[10:33:36.549]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:36.549]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:36.549]                   3L)]
[10:33:36.549]             }
[10:33:36.549]             function(cond) {
[10:33:36.549]                 is_error <- inherits(cond, "error")
[10:33:36.549]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:36.549]                   NULL)
[10:33:36.549]                 if (is_error) {
[10:33:36.549]                   sessionInformation <- function() {
[10:33:36.549]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:36.549]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:36.549]                       search = base::search(), system = base::Sys.info())
[10:33:36.549]                   }
[10:33:36.549]                   ...future.conditions[[length(...future.conditions) + 
[10:33:36.549]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:36.549]                     cond$call), session = sessionInformation(), 
[10:33:36.549]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:36.549]                   signalCondition(cond)
[10:33:36.549]                 }
[10:33:36.549]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:36.549]                 "immediateCondition"))) {
[10:33:36.549]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:36.549]                   ...future.conditions[[length(...future.conditions) + 
[10:33:36.549]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:36.549]                   if (TRUE && !signal) {
[10:33:36.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:36.549]                     {
[10:33:36.549]                       inherits <- base::inherits
[10:33:36.549]                       invokeRestart <- base::invokeRestart
[10:33:36.549]                       is.null <- base::is.null
[10:33:36.549]                       muffled <- FALSE
[10:33:36.549]                       if (inherits(cond, "message")) {
[10:33:36.549]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:36.549]                         if (muffled) 
[10:33:36.549]                           invokeRestart("muffleMessage")
[10:33:36.549]                       }
[10:33:36.549]                       else if (inherits(cond, "warning")) {
[10:33:36.549]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:36.549]                         if (muffled) 
[10:33:36.549]                           invokeRestart("muffleWarning")
[10:33:36.549]                       }
[10:33:36.549]                       else if (inherits(cond, "condition")) {
[10:33:36.549]                         if (!is.null(pattern)) {
[10:33:36.549]                           computeRestarts <- base::computeRestarts
[10:33:36.549]                           grepl <- base::grepl
[10:33:36.549]                           restarts <- computeRestarts(cond)
[10:33:36.549]                           for (restart in restarts) {
[10:33:36.549]                             name <- restart$name
[10:33:36.549]                             if (is.null(name)) 
[10:33:36.549]                               next
[10:33:36.549]                             if (!grepl(pattern, name)) 
[10:33:36.549]                               next
[10:33:36.549]                             invokeRestart(restart)
[10:33:36.549]                             muffled <- TRUE
[10:33:36.549]                             break
[10:33:36.549]                           }
[10:33:36.549]                         }
[10:33:36.549]                       }
[10:33:36.549]                       invisible(muffled)
[10:33:36.549]                     }
[10:33:36.549]                     muffleCondition(cond, pattern = "^muffle")
[10:33:36.549]                   }
[10:33:36.549]                 }
[10:33:36.549]                 else {
[10:33:36.549]                   if (TRUE) {
[10:33:36.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:36.549]                     {
[10:33:36.549]                       inherits <- base::inherits
[10:33:36.549]                       invokeRestart <- base::invokeRestart
[10:33:36.549]                       is.null <- base::is.null
[10:33:36.549]                       muffled <- FALSE
[10:33:36.549]                       if (inherits(cond, "message")) {
[10:33:36.549]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:36.549]                         if (muffled) 
[10:33:36.549]                           invokeRestart("muffleMessage")
[10:33:36.549]                       }
[10:33:36.549]                       else if (inherits(cond, "warning")) {
[10:33:36.549]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:36.549]                         if (muffled) 
[10:33:36.549]                           invokeRestart("muffleWarning")
[10:33:36.549]                       }
[10:33:36.549]                       else if (inherits(cond, "condition")) {
[10:33:36.549]                         if (!is.null(pattern)) {
[10:33:36.549]                           computeRestarts <- base::computeRestarts
[10:33:36.549]                           grepl <- base::grepl
[10:33:36.549]                           restarts <- computeRestarts(cond)
[10:33:36.549]                           for (restart in restarts) {
[10:33:36.549]                             name <- restart$name
[10:33:36.549]                             if (is.null(name)) 
[10:33:36.549]                               next
[10:33:36.549]                             if (!grepl(pattern, name)) 
[10:33:36.549]                               next
[10:33:36.549]                             invokeRestart(restart)
[10:33:36.549]                             muffled <- TRUE
[10:33:36.549]                             break
[10:33:36.549]                           }
[10:33:36.549]                         }
[10:33:36.549]                       }
[10:33:36.549]                       invisible(muffled)
[10:33:36.549]                     }
[10:33:36.549]                     muffleCondition(cond, pattern = "^muffle")
[10:33:36.549]                   }
[10:33:36.549]                 }
[10:33:36.549]             }
[10:33:36.549]         }))
[10:33:36.549]     }, error = function(ex) {
[10:33:36.549]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:36.549]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:36.549]                 ...future.rng), started = ...future.startTime, 
[10:33:36.549]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:36.549]             version = "1.8"), class = "FutureResult")
[10:33:36.549]     }, finally = {
[10:33:36.549]         if (!identical(...future.workdir, getwd())) 
[10:33:36.549]             setwd(...future.workdir)
[10:33:36.549]         {
[10:33:36.549]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:36.549]                 ...future.oldOptions$nwarnings <- NULL
[10:33:36.549]             }
[10:33:36.549]             base::options(...future.oldOptions)
[10:33:36.549]             if (.Platform$OS.type == "windows") {
[10:33:36.549]                 old_names <- names(...future.oldEnvVars)
[10:33:36.549]                 envs <- base::Sys.getenv()
[10:33:36.549]                 names <- names(envs)
[10:33:36.549]                 common <- intersect(names, old_names)
[10:33:36.549]                 added <- setdiff(names, old_names)
[10:33:36.549]                 removed <- setdiff(old_names, names)
[10:33:36.549]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:36.549]                   envs[common]]
[10:33:36.549]                 NAMES <- toupper(changed)
[10:33:36.549]                 args <- list()
[10:33:36.549]                 for (kk in seq_along(NAMES)) {
[10:33:36.549]                   name <- changed[[kk]]
[10:33:36.549]                   NAME <- NAMES[[kk]]
[10:33:36.549]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.549]                     next
[10:33:36.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:36.549]                 }
[10:33:36.549]                 NAMES <- toupper(added)
[10:33:36.549]                 for (kk in seq_along(NAMES)) {
[10:33:36.549]                   name <- added[[kk]]
[10:33:36.549]                   NAME <- NAMES[[kk]]
[10:33:36.549]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.549]                     next
[10:33:36.549]                   args[[name]] <- ""
[10:33:36.549]                 }
[10:33:36.549]                 NAMES <- toupper(removed)
[10:33:36.549]                 for (kk in seq_along(NAMES)) {
[10:33:36.549]                   name <- removed[[kk]]
[10:33:36.549]                   NAME <- NAMES[[kk]]
[10:33:36.549]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:36.549]                     next
[10:33:36.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:36.549]                 }
[10:33:36.549]                 if (length(args) > 0) 
[10:33:36.549]                   base::do.call(base::Sys.setenv, args = args)
[10:33:36.549]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:36.549]             }
[10:33:36.549]             else {
[10:33:36.549]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:36.549]             }
[10:33:36.549]             {
[10:33:36.549]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:36.549]                   0L) {
[10:33:36.549]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:36.549]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:36.549]                   base::options(opts)
[10:33:36.549]                 }
[10:33:36.549]                 {
[10:33:36.549]                   {
[10:33:36.549]                     NULL
[10:33:36.549]                     RNGkind("Mersenne-Twister")
[10:33:36.549]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:36.549]                       inherits = FALSE)
[10:33:36.549]                   }
[10:33:36.549]                   options(future.plan = NULL)
[10:33:36.549]                   if (is.na(NA_character_)) 
[10:33:36.549]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:36.549]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:36.549]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:36.549]                     .init = FALSE)
[10:33:36.549]                 }
[10:33:36.549]             }
[10:33:36.549]         }
[10:33:36.549]     })
[10:33:36.549]     if (TRUE) {
[10:33:36.549]         base::sink(type = "output", split = FALSE)
[10:33:36.549]         if (TRUE) {
[10:33:36.549]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:36.549]         }
[10:33:36.549]         else {
[10:33:36.549]             ...future.result["stdout"] <- base::list(NULL)
[10:33:36.549]         }
[10:33:36.549]         base::close(...future.stdout)
[10:33:36.549]         ...future.stdout <- NULL
[10:33:36.549]     }
[10:33:36.549]     ...future.result$conditions <- ...future.conditions
[10:33:36.549]     ...future.result$finished <- base::Sys.time()
[10:33:36.549]     ...future.result
[10:33:36.549] }
[10:33:36.551] assign_globals() ...
[10:33:36.551] List of 2
[10:33:36.551]  $ nested   :List of 2
[10:33:36.551]   ..$ a:function (..., envir = parent.frame())  
[10:33:36.551]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:33:36.551]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:33:36.551]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[10:33:36.551]     envir = parent.frame())  
[10:33:36.551]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[10:33:36.551]   .. ..- attr(*, "init")= logi TRUE
[10:33:36.551]   .. ..- attr(*, "untweakable")= chr "persistent"
[10:33:36.551]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:33:36.551]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:33:36.551]  $ strategy2: chr "multisession"
[10:33:36.551]  - attr(*, "where")=List of 2
[10:33:36.551]   ..$ nested   :<environment: R_EmptyEnv> 
[10:33:36.551]   ..$ strategy2:<environment: R_EmptyEnv> 
[10:33:36.551]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:36.551]  - attr(*, "resolved")= logi FALSE
[10:33:36.551]  - attr(*, "total_size")= num 56736
[10:33:36.551]  - attr(*, "already-done")= logi TRUE
[10:33:36.557] - copied ‘nested’ to environment
[10:33:36.557] - copied ‘strategy2’ to environment
[10:33:36.557] assign_globals() ... done
[10:33:36.558] plan(): Setting new future strategy stack:
[10:33:36.558] List of future strategies:
[10:33:36.558] 1. multisession:
[10:33:36.558]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:36.558]    - tweaked: FALSE
[10:33:36.558]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:36.562] plan(): nbrOfWorkers() = 2
[10:33:37.317] plan(): Setting new future strategy stack:
[10:33:37.317] List of future strategies:
[10:33:37.317] 1. sequential:
[10:33:37.317]    - args: function (..., envir = parent.frame())
[10:33:37.317]    - tweaked: FALSE
[10:33:37.317]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.317] 2. multisession:
[10:33:37.317]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:37.317]    - tweaked: FALSE
[10:33:37.317]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.318] plan(): nbrOfWorkers() = 1
[10:33:37.318] SequentialFuture started (and completed)
[10:33:37.318] signalConditions() ...
[10:33:37.318]  - include = ‘immediateCondition’
[10:33:37.319]  - exclude = 
[10:33:37.319]  - resignal = FALSE
[10:33:37.319]  - Number of conditions: 98
[10:33:37.319] signalConditions() ... done
[10:33:37.319] - Launch lazy future ... done
[10:33:37.319] run() for ‘SequentialFuture’ ... done
[10:33:37.320] signalConditions() ...
[10:33:37.320]  - include = ‘immediateCondition’
[10:33:37.320]  - exclude = 
[10:33:37.320]  - resignal = FALSE
[10:33:37.320]  - Number of conditions: 98
[10:33:37.320] signalConditions() ... done
[10:33:37.320] Future state: ‘finished’
[10:33:37.320] signalConditions() ...
[10:33:37.321]  - include = ‘condition’
[10:33:37.321]  - exclude = ‘immediateCondition’
[10:33:37.321]  - resignal = TRUE
[10:33:37.321]  - Number of conditions: 98
[10:33:37.321]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.563] getGlobalsAndPackages() ...
[10:33:37.321]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.563] Searching for globals...
[10:33:37.321]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.581] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[10:33:37.322]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.581] Searching for globals ... DONE
[10:33:37.322]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.581] Resolving globals: FALSE
[10:33:37.322]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.582] The total size of the 3 globals is 87.82 KiB (89928 bytes)
[10:33:37.322]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.582] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 87.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (43.88 KiB of class ‘list’), ‘plan_a’ (43.88 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[10:33:37.322]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.582] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[10:33:37.322]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.583] 
[10:33:37.323]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.583] getGlobalsAndPackages() ... DONE
[10:33:37.323]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.583] run() for ‘Future’ ...
[10:33:37.323]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.583] - state: ‘created’
[10:33:37.323]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.583] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:37.323]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.589] [local output] makeClusterPSOCK() ...
[10:33:37.323]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.651] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:33:37.324]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.652] [local output] Base port: 11848
[10:33:37.324]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.653] [local output] Getting setup options for 2 cluster nodes ...
[10:33:37.324]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.653] [local output]  - Node 1 of 2 ...
[10:33:37.324]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.653] [local output] localMachine=TRUE => revtunnel=FALSE

[10:33:37.324]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.654] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpTlTEh1/worker.rank=1.parallelly.parent=87069.1541d61a93be9.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpTlTEh1/worker.rank=1.parallelly.parent=87069.1541d61a93be9.pid")'’
[10:33:37.325]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.841] - Possible to infer worker's PID: TRUE
[10:33:37.325]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.842] [local output] Rscript port: 11848

[10:33:37.325]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.842] [local output]  - Node 2 of 2 ...
[10:33:37.325]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.842] [local output] localMachine=TRUE => revtunnel=FALSE

[10:33:37.325]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.843] [local output] Rscript port: 11848

[10:33:37.325]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.843] [local output] Getting setup options for 2 cluster nodes ... done
[10:33:37.326]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.844] [local output]  - Parallel setup requested for some PSOCK nodes
[10:33:37.326]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.844] [local output] Setting up PSOCK nodes in parallel
[10:33:37.326]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.844] List of 36
[10:33:36.844]  $ worker          : chr "localhost"
[10:33:36.844]   ..- attr(*, "localhost")= logi TRUE
[10:33:36.844]  $ master          : chr "localhost"
[10:33:36.844]  $ port            : int 11848
[10:33:36.844]  $ connectTimeout  : num 120
[10:33:36.844]  $ timeout         : num 2592000
[10:33:36.844]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:33:36.844]  $ homogeneous     : logi TRUE
[10:33:36.844]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:33:36.844]  $ rscript_envs    : NULL
[10:33:36.844]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:33:36.844]  $ rscript_startup : NULL
[10:33:36.844]  $ rscript_sh      : chr "sh"
[10:33:36.844]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:33:36.844]  $ methods         : logi TRUE
[10:33:36.844]  $ socketOptions   : chr "no-delay"
[10:33:36.844]  $ useXDR          : logi FALSE
[10:33:36.844]  $ outfile         : chr "/dev/null"
[10:33:36.844]  $ renice          : int NA
[10:33:36.844]  $ rshcmd          : NULL
[10:33:36.844]  $ user            : chr(0) 
[10:33:36.844]  $ revtunnel       : logi FALSE
[10:33:36.844]  $ rshlogfile      : NULL
[10:33:36.844]  $ rshopts         : chr(0) 
[10:33:36.844]  $ rank            : int 1
[10:33:36.844]  $ manual          : logi FALSE
[10:33:36.844]  $ dryrun          : logi FALSE
[10:33:36.844]  $ quiet           : logi FALSE
[10:33:36.844]  $ setup_strategy  : chr "parallel"
[10:33:36.844]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:33:36.844]  $ pidfile         : chr "/tmp/RtmpTlTEh1/worker.rank=1.parallelly.parent=87069.1541d61a93be9.pid"
[10:33:36.844]  $ rshcmd_label    : NULL
[10:33:36.844]  $ rsh_call        : NULL
[10:33:36.844]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:33:36.844]  $ localMachine    : logi TRUE
[10:33:36.844]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:33:36.844]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:33:36.844]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:33:36.844]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:33:36.844]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:33:36.844]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:33:36.844]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:33:36.844]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:33:36.844]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:33:36.844]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:33:36.844]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:33:36.844]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:33:36.844]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:33:36.844]  $ arguments       :List of 28
[10:33:36.844]   ..$ worker          : chr "localhost"
[10:33:36.844]   ..$ master          : NULL
[10:33:36.844]   ..$ port            : int 11848
[10:33:36.844]   ..$ connectTimeout  : num 120
[10:33:36.844]   ..$ timeout         : num 2592000
[10:33:36.844]   ..$ rscript         : NULL
[10:33:36.844]   ..$ homogeneous     : NULL
[10:33:36.844]   ..$ rscript_args    : NULL
[10:33:36.844]   ..$ rscript_envs    : NULL
[10:33:36.844]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:33:36.844]   ..$ rscript_startup : NULL
[10:33:36.844]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:33:36.844]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:33:36.844]   ..$ methods         : logi TRUE
[10:33:36.844]   ..$ socketOptions   : chr "no-delay"
[10:33:36.844]   ..$ useXDR          : logi FALSE
[10:33:36.844]   ..$ outfile         : chr "/dev/null"
[10:33:36.844]   ..$ renice          : int NA
[10:33:36.844]   ..$ rshcmd          : NULL
[10:33:36.844]   ..$ user            : NULL
[10:33:36.844]   ..$ revtunnel       : logi NA
[10:33:36.844]   ..$ rshlogfile      : NULL
[10:33:36.844]   ..$ rshopts         : NULL
[10:33:36.844]   ..$ rank            : int 1
[10:33:36.844]   ..$ manual          : logi FALSE
[10:33:36.844]   ..$ dryrun          : logi FALSE
[10:33:36.844]   ..$ quiet           : logi FALSE
[10:33:36.844]   ..$ setup_strategy  : chr "parallel"
[10:33:36.844]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:33:37.326]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.861] [local output] System call to launch all workers:
[10:33:37.326]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.861] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpTlTEh1/worker.rank=1.parallelly.parent=87069.1541d61a93be9.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11848 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:33:37.326]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.861] [local output] Starting PSOCK main server
[10:33:37.327]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.867] [local output] Workers launched
[10:33:37.327]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.867] [local output] Waiting for workers to connect back
[10:33:37.327]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:36.867]  - [local output] 0 workers out of 2 ready
[10:33:37.327]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.116]  - [local output] 0 workers out of 2 ready
[10:33:37.327]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.116]  - [local output] 1 workers out of 2 ready
[10:33:37.327]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.118]  - [local output] 1 workers out of 2 ready
[10:33:37.328]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.118]  - [local output] 2 workers out of 2 ready
[10:33:37.328]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.119] [local output] Launching of workers completed
[10:33:37.328]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.119] [local output] Collecting session information from workers
[10:33:37.328]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.120] [local output]  - Worker #1 of 2
[10:33:37.328]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.120] [local output]  - Worker #2 of 2
[10:33:37.328]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.120] [local output] makeClusterPSOCK() ... done
[10:33:37.329]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.131] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:37.329]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.131] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:37.329]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.131]   - Field: ‘node’
[10:33:37.329]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.132]   - Field: ‘label’
[10:33:37.329]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.132]   - Field: ‘local’
[10:33:37.330]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.132]   - Field: ‘owner’
[10:33:37.330]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.132]   - Field: ‘envir’
[10:33:37.330]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.132]   - Field: ‘workers’
[10:33:37.330]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.132]   - Field: ‘packages’
[10:33:37.330]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.132]   - Field: ‘gc’
[10:33:37.330]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.132]   - Field: ‘conditions’
[10:33:37.331]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.133]   - Field: ‘persistent’
[10:33:37.331]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.133]   - Field: ‘expr’
[10:33:37.331]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.133]   - Field: ‘uuid’
[10:33:37.331]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.133]   - Field: ‘seed’
[10:33:37.331]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.133]   - Field: ‘version’
[10:33:37.331]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.133]   - Field: ‘result’
[10:33:37.332]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.133]   - Field: ‘asynchronous’
[10:33:37.332]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.134]   - Field: ‘calls’
[10:33:37.332]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.134]   - Field: ‘globals’
[10:33:37.332]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.134]   - Field: ‘stdout’
[10:33:37.332]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.134]   - Field: ‘earlySignal’
[10:33:37.332]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.134]   - Field: ‘lazy’
[10:33:37.333]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.134]   - Field: ‘state’
[10:33:37.333]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.134] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:37.333]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.134] - Launch lazy future ...
[10:33:37.333]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.135] Packages needed by the future expression (n = 0): <none>
[10:33:37.333]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.135] Packages needed by future strategies (n = 0): <none>
[10:33:37.333]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.136] {
[10:33:37.136]     {
[10:33:37.136]         {
[10:33:37.136]             ...future.startTime <- base::Sys.time()
[10:33:37.136]             {
[10:33:37.136]                 {
[10:33:37.136]                   {
[10:33:37.136]                     {
[10:33:37.136]                       base::local({
[10:33:37.136]                         has_future <- base::requireNamespace("future", 
[10:33:37.136]                           quietly = TRUE)
[10:33:37.136]                         if (has_future) {
[10:33:37.136]                           ns <- base::getNamespace("future")
[10:33:37.136]                           version <- ns[[".package"]][["version"]]
[10:33:37.136]                           if (is.null(version)) 
[10:33:37.136]                             version <- utils::packageVersion("future")
[10:33:37.136]                         }
[10:33:37.136]                         else {
[10:33:37.136]                           version <- NULL
[10:33:37.136]                         }
[10:33:37.136]                         if (!has_future || version < "1.8.0") {
[10:33:37.136]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:37.136]                             "", base::R.version$version.string), 
[10:33:37.136]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:37.136]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:37.136]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:37.136]                               "release", "version")], collapse = " "), 
[10:33:37.136]                             hostname = base::Sys.info()[["nodename"]])
[10:33:37.136]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:37.136]                             info)
[10:33:37.136]                           info <- base::paste(info, collapse = "; ")
[10:33:37.136]                           if (!has_future) {
[10:33:37.136]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:37.136]                               info)
[10:33:37.136]                           }
[10:33:37.136]                           else {
[10:33:37.136]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:37.136]                               info, version)
[10:33:37.136]                           }
[10:33:37.136]                           base::stop(msg)
[10:33:37.136]                         }
[10:33:37.136]                       })
[10:33:37.136]                     }
[10:33:37.136]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:37.136]                     base::options(mc.cores = 1L)
[10:33:37.136]                   }
[10:33:37.136]                   ...future.strategy.old <- future::plan("list")
[10:33:37.136]                   options(future.plan = NULL)
[10:33:37.136]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.136]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:37.136]                 }
[10:33:37.136]                 ...future.workdir <- getwd()
[10:33:37.136]             }
[10:33:37.136]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:37.136]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:37.136]         }
[10:33:37.136]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:37.136]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:37.136]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:37.136]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:37.136]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:37.136]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:37.136]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:37.136]             base::names(...future.oldOptions))
[10:33:37.136]     }
[10:33:37.136]     if (FALSE) {
[10:33:37.136]     }
[10:33:37.136]     else {
[10:33:37.136]         if (TRUE) {
[10:33:37.136]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:37.136]                 open = "w")
[10:33:37.136]         }
[10:33:37.136]         else {
[10:33:37.136]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:37.136]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:37.136]         }
[10:33:37.136]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:37.136]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:37.136]             base::sink(type = "output", split = FALSE)
[10:33:37.136]             base::close(...future.stdout)
[10:33:37.136]         }, add = TRUE)
[10:33:37.136]     }
[10:33:37.136]     ...future.frame <- base::sys.nframe()
[10:33:37.136]     ...future.conditions <- base::list()
[10:33:37.136]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:37.136]     if (FALSE) {
[10:33:37.136]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:37.136]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:37.136]     }
[10:33:37.136]     ...future.result <- base::tryCatch({
[10:33:37.136]         base::withCallingHandlers({
[10:33:37.136]             ...future.value <- base::withVisible(base::local({
[10:33:37.136]                 ...future.makeSendCondition <- base::local({
[10:33:37.136]                   sendCondition <- NULL
[10:33:37.136]                   function(frame = 1L) {
[10:33:37.136]                     if (is.function(sendCondition)) 
[10:33:37.136]                       return(sendCondition)
[10:33:37.136]                     ns <- getNamespace("parallel")
[10:33:37.136]                     if (exists("sendData", mode = "function", 
[10:33:37.136]                       envir = ns)) {
[10:33:37.136]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:37.136]                         envir = ns)
[10:33:37.136]                       envir <- sys.frame(frame)
[10:33:37.136]                       master <- NULL
[10:33:37.136]                       while (!identical(envir, .GlobalEnv) && 
[10:33:37.136]                         !identical(envir, emptyenv())) {
[10:33:37.136]                         if (exists("master", mode = "list", envir = envir, 
[10:33:37.136]                           inherits = FALSE)) {
[10:33:37.136]                           master <- get("master", mode = "list", 
[10:33:37.136]                             envir = envir, inherits = FALSE)
[10:33:37.136]                           if (inherits(master, c("SOCKnode", 
[10:33:37.136]                             "SOCK0node"))) {
[10:33:37.136]                             sendCondition <<- function(cond) {
[10:33:37.136]                               data <- list(type = "VALUE", value = cond, 
[10:33:37.136]                                 success = TRUE)
[10:33:37.136]                               parallel_sendData(master, data)
[10:33:37.136]                             }
[10:33:37.136]                             return(sendCondition)
[10:33:37.136]                           }
[10:33:37.136]                         }
[10:33:37.136]                         frame <- frame + 1L
[10:33:37.136]                         envir <- sys.frame(frame)
[10:33:37.136]                       }
[10:33:37.136]                     }
[10:33:37.136]                     sendCondition <<- function(cond) NULL
[10:33:37.136]                   }
[10:33:37.136]                 })
[10:33:37.136]                 withCallingHandlers({
[10:33:37.136]                   {
[10:33:37.136]                     b <- 2L
[10:33:37.136]                     plan_b <- future::plan("list")
[10:33:37.136]                     nested_b <- nested_a[-1]
[10:33:37.136]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:33:37.136]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:33:37.136]                       "sequential"))
[10:33:37.136]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:33:37.136]                       b = b, nested_b = nested_b, plan_b = plan_b)
[10:33:37.136]                   }
[10:33:37.136]                 }, immediateCondition = function(cond) {
[10:33:37.136]                   sendCondition <- ...future.makeSendCondition()
[10:33:37.136]                   sendCondition(cond)
[10:33:37.136]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.136]                   {
[10:33:37.136]                     inherits <- base::inherits
[10:33:37.136]                     invokeRestart <- base::invokeRestart
[10:33:37.136]                     is.null <- base::is.null
[10:33:37.136]                     muffled <- FALSE
[10:33:37.136]                     if (inherits(cond, "message")) {
[10:33:37.136]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:37.136]                       if (muffled) 
[10:33:37.136]                         invokeRestart("muffleMessage")
[10:33:37.136]                     }
[10:33:37.136]                     else if (inherits(cond, "warning")) {
[10:33:37.136]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:37.136]                       if (muffled) 
[10:33:37.136]                         invokeRestart("muffleWarning")
[10:33:37.136]                     }
[10:33:37.136]                     else if (inherits(cond, "condition")) {
[10:33:37.136]                       if (!is.null(pattern)) {
[10:33:37.136]                         computeRestarts <- base::computeRestarts
[10:33:37.136]                         grepl <- base::grepl
[10:33:37.136]                         restarts <- computeRestarts(cond)
[10:33:37.136]                         for (restart in restarts) {
[10:33:37.136]                           name <- restart$name
[10:33:37.136]                           if (is.null(name)) 
[10:33:37.136]                             next
[10:33:37.136]                           if (!grepl(pattern, name)) 
[10:33:37.136]                             next
[10:33:37.136]                           invokeRestart(restart)
[10:33:37.136]                           muffled <- TRUE
[10:33:37.136]                           break
[10:33:37.136]                         }
[10:33:37.136]                       }
[10:33:37.136]                     }
[10:33:37.136]                     invisible(muffled)
[10:33:37.136]                   }
[10:33:37.136]                   muffleCondition(cond)
[10:33:37.136]                 })
[10:33:37.136]             }))
[10:33:37.136]             future::FutureResult(value = ...future.value$value, 
[10:33:37.136]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.136]                   ...future.rng), globalenv = if (FALSE) 
[10:33:37.136]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:37.136]                     ...future.globalenv.names))
[10:33:37.136]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:37.136]         }, condition = base::local({
[10:33:37.136]             c <- base::c
[10:33:37.136]             inherits <- base::inherits
[10:33:37.136]             invokeRestart <- base::invokeRestart
[10:33:37.136]             length <- base::length
[10:33:37.136]             list <- base::list
[10:33:37.136]             seq.int <- base::seq.int
[10:33:37.136]             signalCondition <- base::signalCondition
[10:33:37.136]             sys.calls <- base::sys.calls
[10:33:37.136]             `[[` <- base::`[[`
[10:33:37.136]             `+` <- base::`+`
[10:33:37.136]             `<<-` <- base::`<<-`
[10:33:37.136]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:37.136]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:37.136]                   3L)]
[10:33:37.136]             }
[10:33:37.136]             function(cond) {
[10:33:37.136]                 is_error <- inherits(cond, "error")
[10:33:37.136]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:37.136]                   NULL)
[10:33:37.136]                 if (is_error) {
[10:33:37.136]                   sessionInformation <- function() {
[10:33:37.136]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:37.136]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:37.136]                       search = base::search(), system = base::Sys.info())
[10:33:37.136]                   }
[10:33:37.136]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.136]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:37.136]                     cond$call), session = sessionInformation(), 
[10:33:37.136]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:37.136]                   signalCondition(cond)
[10:33:37.136]                 }
[10:33:37.136]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:37.136]                 "immediateCondition"))) {
[10:33:37.136]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:37.136]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.136]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:37.136]                   if (TRUE && !signal) {
[10:33:37.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.136]                     {
[10:33:37.136]                       inherits <- base::inherits
[10:33:37.136]                       invokeRestart <- base::invokeRestart
[10:33:37.136]                       is.null <- base::is.null
[10:33:37.136]                       muffled <- FALSE
[10:33:37.136]                       if (inherits(cond, "message")) {
[10:33:37.136]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.136]                         if (muffled) 
[10:33:37.136]                           invokeRestart("muffleMessage")
[10:33:37.136]                       }
[10:33:37.136]                       else if (inherits(cond, "warning")) {
[10:33:37.136]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.136]                         if (muffled) 
[10:33:37.136]                           invokeRestart("muffleWarning")
[10:33:37.136]                       }
[10:33:37.136]                       else if (inherits(cond, "condition")) {
[10:33:37.136]                         if (!is.null(pattern)) {
[10:33:37.136]                           computeRestarts <- base::computeRestarts
[10:33:37.136]                           grepl <- base::grepl
[10:33:37.136]                           restarts <- computeRestarts(cond)
[10:33:37.136]                           for (restart in restarts) {
[10:33:37.136]                             name <- restart$name
[10:33:37.136]                             if (is.null(name)) 
[10:33:37.136]                               next
[10:33:37.136]                             if (!grepl(pattern, name)) 
[10:33:37.136]                               next
[10:33:37.136]                             invokeRestart(restart)
[10:33:37.136]                             muffled <- TRUE
[10:33:37.136]                             break
[10:33:37.136]                           }
[10:33:37.136]                         }
[10:33:37.136]                       }
[10:33:37.136]                       invisible(muffled)
[10:33:37.136]                     }
[10:33:37.136]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.136]                   }
[10:33:37.136]                 }
[10:33:37.136]                 else {
[10:33:37.136]                   if (TRUE) {
[10:33:37.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.136]                     {
[10:33:37.136]                       inherits <- base::inherits
[10:33:37.136]                       invokeRestart <- base::invokeRestart
[10:33:37.136]                       is.null <- base::is.null
[10:33:37.136]                       muffled <- FALSE
[10:33:37.136]                       if (inherits(cond, "message")) {
[10:33:37.136]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.136]                         if (muffled) 
[10:33:37.136]                           invokeRestart("muffleMessage")
[10:33:37.136]                       }
[10:33:37.136]                       else if (inherits(cond, "warning")) {
[10:33:37.136]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.136]                         if (muffled) 
[10:33:37.136]                           invokeRestart("muffleWarning")
[10:33:37.136]                       }
[10:33:37.136]                       else if (inherits(cond, "condition")) {
[10:33:37.136]                         if (!is.null(pattern)) {
[10:33:37.136]                           computeRestarts <- base::computeRestarts
[10:33:37.136]                           grepl <- base::grepl
[10:33:37.136]                           restarts <- computeRestarts(cond)
[10:33:37.136]                           for (restart in restarts) {
[10:33:37.136]                             name <- restart$name
[10:33:37.136]                             if (is.null(name)) 
[10:33:37.136]                               next
[10:33:37.136]                             if (!grepl(pattern, name)) 
[10:33:37.136]                               next
[10:33:37.136]                             invokeRestart(restart)
[10:33:37.136]                             muffled <- TRUE
[10:33:37.136]                             break
[10:33:37.136]                           }
[10:33:37.136]                         }
[10:33:37.136]                       }
[10:33:37.136]                       invisible(muffled)
[10:33:37.136]                     }
[10:33:37.136]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.136]                   }
[10:33:37.136]                 }
[10:33:37.136]             }
[10:33:37.136]         }))
[10:33:37.136]     }, error = function(ex) {
[10:33:37.136]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:37.136]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.136]                 ...future.rng), started = ...future.startTime, 
[10:33:37.136]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:37.136]             version = "1.8"), class = "FutureResult")
[10:33:37.136]     }, finally = {
[10:33:37.136]         if (!identical(...future.workdir, getwd())) 
[10:33:37.136]             setwd(...future.workdir)
[10:33:37.136]         {
[10:33:37.136]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:37.136]                 ...future.oldOptions$nwarnings <- NULL
[10:33:37.136]             }
[10:33:37.136]             base::options(...future.oldOptions)
[10:33:37.136]             if (.Platform$OS.type == "windows") {
[10:33:37.136]                 old_names <- names(...future.oldEnvVars)
[10:33:37.136]                 envs <- base::Sys.getenv()
[10:33:37.136]                 names <- names(envs)
[10:33:37.136]                 common <- intersect(names, old_names)
[10:33:37.136]                 added <- setdiff(names, old_names)
[10:33:37.136]                 removed <- setdiff(old_names, names)
[10:33:37.136]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:37.136]                   envs[common]]
[10:33:37.136]                 NAMES <- toupper(changed)
[10:33:37.136]                 args <- list()
[10:33:37.136]                 for (kk in seq_along(NAMES)) {
[10:33:37.136]                   name <- changed[[kk]]
[10:33:37.136]                   NAME <- NAMES[[kk]]
[10:33:37.136]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.136]                     next
[10:33:37.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.136]                 }
[10:33:37.136]                 NAMES <- toupper(added)
[10:33:37.136]                 for (kk in seq_along(NAMES)) {
[10:33:37.136]                   name <- added[[kk]]
[10:33:37.136]                   NAME <- NAMES[[kk]]
[10:33:37.136]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.136]                     next
[10:33:37.136]                   args[[name]] <- ""
[10:33:37.136]                 }
[10:33:37.136]                 NAMES <- toupper(removed)
[10:33:37.136]                 for (kk in seq_along(NAMES)) {
[10:33:37.136]                   name <- removed[[kk]]
[10:33:37.136]                   NAME <- NAMES[[kk]]
[10:33:37.136]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.136]                     next
[10:33:37.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.136]                 }
[10:33:37.136]                 if (length(args) > 0) 
[10:33:37.136]                   base::do.call(base::Sys.setenv, args = args)
[10:33:37.136]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:37.136]             }
[10:33:37.136]             else {
[10:33:37.136]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:37.136]             }
[10:33:37.136]             {
[10:33:37.136]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:37.136]                   0L) {
[10:33:37.136]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:37.136]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:37.136]                   base::options(opts)
[10:33:37.136]                 }
[10:33:37.136]                 {
[10:33:37.136]                   {
[10:33:37.136]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:37.136]                     NULL
[10:33:37.136]                   }
[10:33:37.136]                   options(future.plan = NULL)
[10:33:37.136]                   if (is.na(NA_character_)) 
[10:33:37.136]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.136]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:37.136]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:37.136]                     .init = FALSE)
[10:33:37.136]                 }
[10:33:37.136]             }
[10:33:37.136]         }
[10:33:37.136]     })
[10:33:37.136]     if (TRUE) {
[10:33:37.136]         base::sink(type = "output", split = FALSE)
[10:33:37.136]         if (TRUE) {
[10:33:37.136]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:37.136]         }
[10:33:37.136]         else {
[10:33:37.136]             ...future.result["stdout"] <- base::list(NULL)
[10:33:37.136]         }
[10:33:37.136]         base::close(...future.stdout)
[10:33:37.136]         ...future.stdout <- NULL
[10:33:37.136]     }
[10:33:37.136]     ...future.result$conditions <- ...future.conditions
[10:33:37.136]     ...future.result$finished <- base::Sys.time()
[10:33:37.136]     ...future.result
[10:33:37.136] }
[10:33:37.334]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.191] Exporting 3 global objects (87.82 KiB) to cluster node #1 ...
[10:33:37.334]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.191] Exporting ‘nested_a’ (43.88 KiB) to cluster node #1 ...
[10:33:37.334]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.192] Exporting ‘nested_a’ (43.88 KiB) to cluster node #1 ... DONE
[10:33:37.334]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.192] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[10:33:37.334]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.192] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[10:33:37.334]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.193] Exporting ‘plan_a’ (43.88 KiB) to cluster node #1 ...
[10:33:37.335]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.237] Exporting ‘plan_a’ (43.88 KiB) to cluster node #1 ... DONE
[10:33:37.335]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.237] Exporting 3 global objects (87.82 KiB) to cluster node #1 ... DONE
[10:33:37.335]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.238] MultisessionFuture started
[10:33:37.335]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.238] - Launch lazy future ... done
[10:33:37.335]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.239] run() for ‘MultisessionFuture’ ... done
[10:33:37.335]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.239] result() for ClusterFuture ...
[10:33:37.336]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.239] receiveMessageFromWorker() for ClusterFuture ...
[10:33:37.336]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.240] - Validating connection of MultisessionFuture
[10:33:37.336]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.315] - received message: FutureResult
[10:33:37.336]  - Condition #89: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.315] - Received FutureResult
[10:33:37.336]  - Condition #90: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.315] - Erased future from FutureRegistry
[10:33:37.336]  - Condition #91: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.316] result() for ClusterFuture ...
[10:33:37.337]  - Condition #92: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.316] - result already collected: FutureResult
[10:33:37.337]  - Condition #93: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.316] result() for ClusterFuture ... done
[10:33:37.337]  - Condition #94: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.316] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:37.337]  - Condition #95: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.316] result() for ClusterFuture ... done
[10:33:37.337]  - Condition #96: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.316] result() for ClusterFuture ...
[10:33:37.337]  - Condition #97: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.316] - result already collected: FutureResult
[10:33:37.338]  - Condition #98: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.316] result() for ClusterFuture ... done
[10:33:37.338] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:33:37.345] getGlobalsAndPackages() ...
[10:33:37.345] Searching for globals...
[10:33:37.346] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:33:37.346] Searching for globals ... DONE
[10:33:37.347] Resolving globals: FALSE
[10:33:37.347] The total size of the 1 globals is 128 bytes (128 bytes)
[10:33:37.348] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:33:37.348] - globals: [1] ‘data’
[10:33:37.348] - packages: [1] ‘future’
[10:33:37.348] getGlobalsAndPackages() ... DONE
[10:33:37.348] run() for ‘Future’ ...
[10:33:37.349] - state: ‘created’
[10:33:37.349] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:37.349] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:37.349] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:37.349]   - Field: ‘label’
[10:33:37.349]   - Field: ‘local’
[10:33:37.350]   - Field: ‘owner’
[10:33:37.350]   - Field: ‘envir’
[10:33:37.350]   - Field: ‘packages’
[10:33:37.350]   - Field: ‘gc’
[10:33:37.350]   - Field: ‘conditions’
[10:33:37.350]   - Field: ‘expr’
[10:33:37.350]   - Field: ‘uuid’
[10:33:37.350]   - Field: ‘seed’
[10:33:37.350]   - Field: ‘version’
[10:33:37.351]   - Field: ‘result’
[10:33:37.351]   - Field: ‘asynchronous’
[10:33:37.351]   - Field: ‘calls’
[10:33:37.351]   - Field: ‘globals’
[10:33:37.351]   - Field: ‘stdout’
[10:33:37.351]   - Field: ‘earlySignal’
[10:33:37.351]   - Field: ‘lazy’
[10:33:37.351]   - Field: ‘state’
[10:33:37.352] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:37.352] - Launch lazy future ...
[10:33:37.352] Packages needed by the future expression (n = 1): ‘future’
[10:33:37.352] Packages needed by future strategies (n = 1): ‘future’
[10:33:37.353] {
[10:33:37.353]     {
[10:33:37.353]         {
[10:33:37.353]             ...future.startTime <- base::Sys.time()
[10:33:37.353]             {
[10:33:37.353]                 {
[10:33:37.353]                   {
[10:33:37.353]                     {
[10:33:37.353]                       base::local({
[10:33:37.353]                         has_future <- base::requireNamespace("future", 
[10:33:37.353]                           quietly = TRUE)
[10:33:37.353]                         if (has_future) {
[10:33:37.353]                           ns <- base::getNamespace("future")
[10:33:37.353]                           version <- ns[[".package"]][["version"]]
[10:33:37.353]                           if (is.null(version)) 
[10:33:37.353]                             version <- utils::packageVersion("future")
[10:33:37.353]                         }
[10:33:37.353]                         else {
[10:33:37.353]                           version <- NULL
[10:33:37.353]                         }
[10:33:37.353]                         if (!has_future || version < "1.8.0") {
[10:33:37.353]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:37.353]                             "", base::R.version$version.string), 
[10:33:37.353]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:37.353]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:37.353]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:37.353]                               "release", "version")], collapse = " "), 
[10:33:37.353]                             hostname = base::Sys.info()[["nodename"]])
[10:33:37.353]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:37.353]                             info)
[10:33:37.353]                           info <- base::paste(info, collapse = "; ")
[10:33:37.353]                           if (!has_future) {
[10:33:37.353]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:37.353]                               info)
[10:33:37.353]                           }
[10:33:37.353]                           else {
[10:33:37.353]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:37.353]                               info, version)
[10:33:37.353]                           }
[10:33:37.353]                           base::stop(msg)
[10:33:37.353]                         }
[10:33:37.353]                       })
[10:33:37.353]                     }
[10:33:37.353]                     base::local({
[10:33:37.353]                       for (pkg in "future") {
[10:33:37.353]                         base::loadNamespace(pkg)
[10:33:37.353]                         base::library(pkg, character.only = TRUE)
[10:33:37.353]                       }
[10:33:37.353]                     })
[10:33:37.353]                   }
[10:33:37.353]                   ...future.strategy.old <- future::plan("list")
[10:33:37.353]                   options(future.plan = NULL)
[10:33:37.353]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.353]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:33:37.353]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:33:37.353]                     envir = parent.frame()) 
[10:33:37.353]                   {
[10:33:37.353]                     if (is.function(workers)) 
[10:33:37.353]                       workers <- workers()
[10:33:37.353]                     workers <- structure(as.integer(workers), 
[10:33:37.353]                       class = class(workers))
[10:33:37.353]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:33:37.353]                       workers >= 1)
[10:33:37.353]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:33:37.353]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:33:37.353]                     }
[10:33:37.353]                     future <- MultisessionFuture(..., workers = workers, 
[10:33:37.353]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:33:37.353]                       envir = envir)
[10:33:37.353]                     if (!future$lazy) 
[10:33:37.353]                       future <- run(future)
[10:33:37.353]                     invisible(future)
[10:33:37.353]                   }), .cleanup = FALSE, .init = FALSE)
[10:33:37.353]                 }
[10:33:37.353]                 ...future.workdir <- getwd()
[10:33:37.353]             }
[10:33:37.353]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:37.353]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:37.353]         }
[10:33:37.353]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:37.353]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:37.353]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:37.353]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:37.353]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:37.353]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:37.353]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:37.353]             base::names(...future.oldOptions))
[10:33:37.353]     }
[10:33:37.353]     if (FALSE) {
[10:33:37.353]     }
[10:33:37.353]     else {
[10:33:37.353]         if (TRUE) {
[10:33:37.353]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:37.353]                 open = "w")
[10:33:37.353]         }
[10:33:37.353]         else {
[10:33:37.353]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:37.353]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:37.353]         }
[10:33:37.353]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:37.353]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:37.353]             base::sink(type = "output", split = FALSE)
[10:33:37.353]             base::close(...future.stdout)
[10:33:37.353]         }, add = TRUE)
[10:33:37.353]     }
[10:33:37.353]     ...future.frame <- base::sys.nframe()
[10:33:37.353]     ...future.conditions <- base::list()
[10:33:37.353]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:37.353]     if (FALSE) {
[10:33:37.353]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:37.353]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:37.353]     }
[10:33:37.353]     ...future.result <- base::tryCatch({
[10:33:37.353]         base::withCallingHandlers({
[10:33:37.353]             ...future.value <- base::withVisible(base::local({
[10:33:37.353]                 value(future(subset(data, a == 2)))
[10:33:37.353]             }))
[10:33:37.353]             future::FutureResult(value = ...future.value$value, 
[10:33:37.353]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.353]                   ...future.rng), globalenv = if (FALSE) 
[10:33:37.353]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:37.353]                     ...future.globalenv.names))
[10:33:37.353]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:37.353]         }, condition = base::local({
[10:33:37.353]             c <- base::c
[10:33:37.353]             inherits <- base::inherits
[10:33:37.353]             invokeRestart <- base::invokeRestart
[10:33:37.353]             length <- base::length
[10:33:37.353]             list <- base::list
[10:33:37.353]             seq.int <- base::seq.int
[10:33:37.353]             signalCondition <- base::signalCondition
[10:33:37.353]             sys.calls <- base::sys.calls
[10:33:37.353]             `[[` <- base::`[[`
[10:33:37.353]             `+` <- base::`+`
[10:33:37.353]             `<<-` <- base::`<<-`
[10:33:37.353]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:37.353]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:37.353]                   3L)]
[10:33:37.353]             }
[10:33:37.353]             function(cond) {
[10:33:37.353]                 is_error <- inherits(cond, "error")
[10:33:37.353]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:37.353]                   NULL)
[10:33:37.353]                 if (is_error) {
[10:33:37.353]                   sessionInformation <- function() {
[10:33:37.353]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:37.353]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:37.353]                       search = base::search(), system = base::Sys.info())
[10:33:37.353]                   }
[10:33:37.353]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.353]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:37.353]                     cond$call), session = sessionInformation(), 
[10:33:37.353]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:37.353]                   signalCondition(cond)
[10:33:37.353]                 }
[10:33:37.353]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:37.353]                 "immediateCondition"))) {
[10:33:37.353]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:37.353]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.353]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:37.353]                   if (TRUE && !signal) {
[10:33:37.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.353]                     {
[10:33:37.353]                       inherits <- base::inherits
[10:33:37.353]                       invokeRestart <- base::invokeRestart
[10:33:37.353]                       is.null <- base::is.null
[10:33:37.353]                       muffled <- FALSE
[10:33:37.353]                       if (inherits(cond, "message")) {
[10:33:37.353]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.353]                         if (muffled) 
[10:33:37.353]                           invokeRestart("muffleMessage")
[10:33:37.353]                       }
[10:33:37.353]                       else if (inherits(cond, "warning")) {
[10:33:37.353]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.353]                         if (muffled) 
[10:33:37.353]                           invokeRestart("muffleWarning")
[10:33:37.353]                       }
[10:33:37.353]                       else if (inherits(cond, "condition")) {
[10:33:37.353]                         if (!is.null(pattern)) {
[10:33:37.353]                           computeRestarts <- base::computeRestarts
[10:33:37.353]                           grepl <- base::grepl
[10:33:37.353]                           restarts <- computeRestarts(cond)
[10:33:37.353]                           for (restart in restarts) {
[10:33:37.353]                             name <- restart$name
[10:33:37.353]                             if (is.null(name)) 
[10:33:37.353]                               next
[10:33:37.353]                             if (!grepl(pattern, name)) 
[10:33:37.353]                               next
[10:33:37.353]                             invokeRestart(restart)
[10:33:37.353]                             muffled <- TRUE
[10:33:37.353]                             break
[10:33:37.353]                           }
[10:33:37.353]                         }
[10:33:37.353]                       }
[10:33:37.353]                       invisible(muffled)
[10:33:37.353]                     }
[10:33:37.353]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.353]                   }
[10:33:37.353]                 }
[10:33:37.353]                 else {
[10:33:37.353]                   if (TRUE) {
[10:33:37.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.353]                     {
[10:33:37.353]                       inherits <- base::inherits
[10:33:37.353]                       invokeRestart <- base::invokeRestart
[10:33:37.353]                       is.null <- base::is.null
[10:33:37.353]                       muffled <- FALSE
[10:33:37.353]                       if (inherits(cond, "message")) {
[10:33:37.353]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.353]                         if (muffled) 
[10:33:37.353]                           invokeRestart("muffleMessage")
[10:33:37.353]                       }
[10:33:37.353]                       else if (inherits(cond, "warning")) {
[10:33:37.353]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.353]                         if (muffled) 
[10:33:37.353]                           invokeRestart("muffleWarning")
[10:33:37.353]                       }
[10:33:37.353]                       else if (inherits(cond, "condition")) {
[10:33:37.353]                         if (!is.null(pattern)) {
[10:33:37.353]                           computeRestarts <- base::computeRestarts
[10:33:37.353]                           grepl <- base::grepl
[10:33:37.353]                           restarts <- computeRestarts(cond)
[10:33:37.353]                           for (restart in restarts) {
[10:33:37.353]                             name <- restart$name
[10:33:37.353]                             if (is.null(name)) 
[10:33:37.353]                               next
[10:33:37.353]                             if (!grepl(pattern, name)) 
[10:33:37.353]                               next
[10:33:37.353]                             invokeRestart(restart)
[10:33:37.353]                             muffled <- TRUE
[10:33:37.353]                             break
[10:33:37.353]                           }
[10:33:37.353]                         }
[10:33:37.353]                       }
[10:33:37.353]                       invisible(muffled)
[10:33:37.353]                     }
[10:33:37.353]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.353]                   }
[10:33:37.353]                 }
[10:33:37.353]             }
[10:33:37.353]         }))
[10:33:37.353]     }, error = function(ex) {
[10:33:37.353]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:37.353]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.353]                 ...future.rng), started = ...future.startTime, 
[10:33:37.353]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:37.353]             version = "1.8"), class = "FutureResult")
[10:33:37.353]     }, finally = {
[10:33:37.353]         if (!identical(...future.workdir, getwd())) 
[10:33:37.353]             setwd(...future.workdir)
[10:33:37.353]         {
[10:33:37.353]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:37.353]                 ...future.oldOptions$nwarnings <- NULL
[10:33:37.353]             }
[10:33:37.353]             base::options(...future.oldOptions)
[10:33:37.353]             if (.Platform$OS.type == "windows") {
[10:33:37.353]                 old_names <- names(...future.oldEnvVars)
[10:33:37.353]                 envs <- base::Sys.getenv()
[10:33:37.353]                 names <- names(envs)
[10:33:37.353]                 common <- intersect(names, old_names)
[10:33:37.353]                 added <- setdiff(names, old_names)
[10:33:37.353]                 removed <- setdiff(old_names, names)
[10:33:37.353]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:37.353]                   envs[common]]
[10:33:37.353]                 NAMES <- toupper(changed)
[10:33:37.353]                 args <- list()
[10:33:37.353]                 for (kk in seq_along(NAMES)) {
[10:33:37.353]                   name <- changed[[kk]]
[10:33:37.353]                   NAME <- NAMES[[kk]]
[10:33:37.353]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.353]                     next
[10:33:37.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.353]                 }
[10:33:37.353]                 NAMES <- toupper(added)
[10:33:37.353]                 for (kk in seq_along(NAMES)) {
[10:33:37.353]                   name <- added[[kk]]
[10:33:37.353]                   NAME <- NAMES[[kk]]
[10:33:37.353]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.353]                     next
[10:33:37.353]                   args[[name]] <- ""
[10:33:37.353]                 }
[10:33:37.353]                 NAMES <- toupper(removed)
[10:33:37.353]                 for (kk in seq_along(NAMES)) {
[10:33:37.353]                   name <- removed[[kk]]
[10:33:37.353]                   NAME <- NAMES[[kk]]
[10:33:37.353]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.353]                     next
[10:33:37.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.353]                 }
[10:33:37.353]                 if (length(args) > 0) 
[10:33:37.353]                   base::do.call(base::Sys.setenv, args = args)
[10:33:37.353]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:37.353]             }
[10:33:37.353]             else {
[10:33:37.353]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:37.353]             }
[10:33:37.353]             {
[10:33:37.353]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:37.353]                   0L) {
[10:33:37.353]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:37.353]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:37.353]                   base::options(opts)
[10:33:37.353]                 }
[10:33:37.353]                 {
[10:33:37.353]                   {
[10:33:37.353]                     NULL
[10:33:37.353]                     RNGkind("Mersenne-Twister")
[10:33:37.353]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:37.353]                       inherits = FALSE)
[10:33:37.353]                   }
[10:33:37.353]                   options(future.plan = NULL)
[10:33:37.353]                   if (is.na(NA_character_)) 
[10:33:37.353]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.353]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:37.353]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:37.353]                     .init = FALSE)
[10:33:37.353]                 }
[10:33:37.353]             }
[10:33:37.353]         }
[10:33:37.353]     })
[10:33:37.353]     if (TRUE) {
[10:33:37.353]         base::sink(type = "output", split = FALSE)
[10:33:37.353]         if (TRUE) {
[10:33:37.353]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:37.353]         }
[10:33:37.353]         else {
[10:33:37.353]             ...future.result["stdout"] <- base::list(NULL)
[10:33:37.353]         }
[10:33:37.353]         base::close(...future.stdout)
[10:33:37.353]         ...future.stdout <- NULL
[10:33:37.353]     }
[10:33:37.353]     ...future.result$conditions <- ...future.conditions
[10:33:37.353]     ...future.result$finished <- base::Sys.time()
[10:33:37.353]     ...future.result
[10:33:37.353] }
[10:33:37.355] assign_globals() ...
[10:33:37.355] List of 1
[10:33:37.355]  $ data:'data.frame':	3 obs. of  2 variables:
[10:33:37.355]   ..$ a: int [1:3] 1 2 3
[10:33:37.355]   ..$ b: int [1:3] 3 2 1
[10:33:37.355]  - attr(*, "where")=List of 1
[10:33:37.355]   ..$ data:<environment: R_EmptyEnv> 
[10:33:37.355]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:37.355]  - attr(*, "resolved")= logi FALSE
[10:33:37.355]  - attr(*, "total_size")= num 128
[10:33:37.355]  - attr(*, "already-done")= logi TRUE
[10:33:37.360] - copied ‘data’ to environment
[10:33:37.360] assign_globals() ... done
[10:33:37.361] plan(): Setting new future strategy stack:
[10:33:37.361] List of future strategies:
[10:33:37.361] 1. multisession:
[10:33:37.361]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:37.361]    - tweaked: FALSE
[10:33:37.361]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.364] plan(): nbrOfWorkers() = 2
[10:33:37.409] plan(): Setting new future strategy stack:
[10:33:37.409] List of future strategies:
[10:33:37.409] 1. sequential:
[10:33:37.409]    - args: function (..., envir = parent.frame())
[10:33:37.409]    - tweaked: FALSE
[10:33:37.409]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.409] 2. multisession:
[10:33:37.409]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:37.409]    - tweaked: FALSE
[10:33:37.409]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.409] plan(): nbrOfWorkers() = 1
[10:33:37.410] SequentialFuture started (and completed)
[10:33:37.410] signalConditions() ...
[10:33:37.410]  - include = ‘immediateCondition’
[10:33:37.410]  - exclude = 
[10:33:37.410]  - resignal = FALSE
[10:33:37.410]  - Number of conditions: 63
[10:33:37.410] signalConditions() ... done
[10:33:37.410] - Launch lazy future ... done
[10:33:37.410] run() for ‘SequentialFuture’ ... done
[10:33:37.410] signalConditions() ...
[10:33:37.411]  - include = ‘immediateCondition’
[10:33:37.411]  - exclude = 
[10:33:37.411]  - resignal = FALSE
[10:33:37.411]  - Number of conditions: 63
[10:33:37.411] signalConditions() ... done
[10:33:37.411] Future state: ‘finished’
[10:33:37.411] signalConditions() ...
[10:33:37.411]  - include = ‘condition’
[10:33:37.411]  - exclude = ‘immediateCondition’
[10:33:37.411]  - resignal = TRUE
[10:33:37.412]  - Number of conditions: 63
[10:33:37.412]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.365] getGlobalsAndPackages() ...
[10:33:37.412]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.365] Searching for globals...
[10:33:37.412]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.378] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[10:33:37.412]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.378] Searching for globals ... DONE
[10:33:37.412]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.379] Resolving globals: FALSE
[10:33:37.412]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.379] The total size of the 1 globals is 128 bytes (128 bytes)
[10:33:37.412]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.379] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:33:37.413]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.380] - globals: [1] ‘data’
[10:33:37.413]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.380] 
[10:33:37.413]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.380] getGlobalsAndPackages() ... DONE
[10:33:37.413]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.380] run() for ‘Future’ ...
[10:33:37.413]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.380] - state: ‘created’
[10:33:37.413]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.380] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:37.413]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.394] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:37.414]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.394] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:37.414]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.395]   - Field: ‘node’
[10:33:37.414]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.395]   - Field: ‘label’
[10:33:37.414]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.395]   - Field: ‘local’
[10:33:37.414]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.395]   - Field: ‘owner’
[10:33:37.414]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.395]   - Field: ‘envir’
[10:33:37.414]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.395]   - Field: ‘workers’
[10:33:37.414]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.395]   - Field: ‘packages’
[10:33:37.415]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.395]   - Field: ‘gc’
[10:33:37.415]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.395]   - Field: ‘conditions’
[10:33:37.415]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.396]   - Field: ‘persistent’
[10:33:37.415]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.396]   - Field: ‘expr’
[10:33:37.415]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.396]   - Field: ‘uuid’
[10:33:37.415]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.396]   - Field: ‘seed’
[10:33:37.415]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.396]   - Field: ‘version’
[10:33:37.415]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.396]   - Field: ‘result’
[10:33:37.416]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.396]   - Field: ‘asynchronous’
[10:33:37.416]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.396]   - Field: ‘calls’
[10:33:37.416]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.396]   - Field: ‘globals’
[10:33:37.416]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.396]   - Field: ‘stdout’
[10:33:37.416]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.397]   - Field: ‘earlySignal’
[10:33:37.416]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.397]   - Field: ‘lazy’
[10:33:37.416]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.397]   - Field: ‘state’
[10:33:37.417]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.397] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:37.417]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.397] - Launch lazy future ...
[10:33:37.417]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.397] Packages needed by the future expression (n = 0): <none>
[10:33:37.417]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.397] Packages needed by future strategies (n = 0): <none>
[10:33:37.417]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.398] {
[10:33:37.398]     {
[10:33:37.398]         {
[10:33:37.398]             ...future.startTime <- base::Sys.time()
[10:33:37.398]             {
[10:33:37.398]                 {
[10:33:37.398]                   {
[10:33:37.398]                     {
[10:33:37.398]                       base::local({
[10:33:37.398]                         has_future <- base::requireNamespace("future", 
[10:33:37.398]                           quietly = TRUE)
[10:33:37.398]                         if (has_future) {
[10:33:37.398]                           ns <- base::getNamespace("future")
[10:33:37.398]                           version <- ns[[".package"]][["version"]]
[10:33:37.398]                           if (is.null(version)) 
[10:33:37.398]                             version <- utils::packageVersion("future")
[10:33:37.398]                         }
[10:33:37.398]                         else {
[10:33:37.398]                           version <- NULL
[10:33:37.398]                         }
[10:33:37.398]                         if (!has_future || version < "1.8.0") {
[10:33:37.398]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:37.398]                             "", base::R.version$version.string), 
[10:33:37.398]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:37.398]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:37.398]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:37.398]                               "release", "version")], collapse = " "), 
[10:33:37.398]                             hostname = base::Sys.info()[["nodename"]])
[10:33:37.398]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:37.398]                             info)
[10:33:37.398]                           info <- base::paste(info, collapse = "; ")
[10:33:37.398]                           if (!has_future) {
[10:33:37.398]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:37.398]                               info)
[10:33:37.398]                           }
[10:33:37.398]                           else {
[10:33:37.398]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:37.398]                               info, version)
[10:33:37.398]                           }
[10:33:37.398]                           base::stop(msg)
[10:33:37.398]                         }
[10:33:37.398]                       })
[10:33:37.398]                     }
[10:33:37.398]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:37.398]                     base::options(mc.cores = 1L)
[10:33:37.398]                   }
[10:33:37.398]                   ...future.strategy.old <- future::plan("list")
[10:33:37.398]                   options(future.plan = NULL)
[10:33:37.398]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.398]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:37.398]                 }
[10:33:37.398]                 ...future.workdir <- getwd()
[10:33:37.398]             }
[10:33:37.398]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:37.398]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:37.398]         }
[10:33:37.398]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:37.398]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:37.398]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:37.398]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:37.398]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:37.398]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:37.398]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:37.398]             base::names(...future.oldOptions))
[10:33:37.398]     }
[10:33:37.398]     if (FALSE) {
[10:33:37.398]     }
[10:33:37.398]     else {
[10:33:37.398]         if (TRUE) {
[10:33:37.398]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:37.398]                 open = "w")
[10:33:37.398]         }
[10:33:37.398]         else {
[10:33:37.398]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:37.398]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:37.398]         }
[10:33:37.398]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:37.398]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:37.398]             base::sink(type = "output", split = FALSE)
[10:33:37.398]             base::close(...future.stdout)
[10:33:37.398]         }, add = TRUE)
[10:33:37.398]     }
[10:33:37.398]     ...future.frame <- base::sys.nframe()
[10:33:37.398]     ...future.conditions <- base::list()
[10:33:37.398]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:37.398]     if (FALSE) {
[10:33:37.398]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:37.398]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:37.398]     }
[10:33:37.398]     ...future.result <- base::tryCatch({
[10:33:37.398]         base::withCallingHandlers({
[10:33:37.398]             ...future.value <- base::withVisible(base::local({
[10:33:37.398]                 ...future.makeSendCondition <- base::local({
[10:33:37.398]                   sendCondition <- NULL
[10:33:37.398]                   function(frame = 1L) {
[10:33:37.398]                     if (is.function(sendCondition)) 
[10:33:37.398]                       return(sendCondition)
[10:33:37.398]                     ns <- getNamespace("parallel")
[10:33:37.398]                     if (exists("sendData", mode = "function", 
[10:33:37.398]                       envir = ns)) {
[10:33:37.398]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:37.398]                         envir = ns)
[10:33:37.398]                       envir <- sys.frame(frame)
[10:33:37.398]                       master <- NULL
[10:33:37.398]                       while (!identical(envir, .GlobalEnv) && 
[10:33:37.398]                         !identical(envir, emptyenv())) {
[10:33:37.398]                         if (exists("master", mode = "list", envir = envir, 
[10:33:37.398]                           inherits = FALSE)) {
[10:33:37.398]                           master <- get("master", mode = "list", 
[10:33:37.398]                             envir = envir, inherits = FALSE)
[10:33:37.398]                           if (inherits(master, c("SOCKnode", 
[10:33:37.398]                             "SOCK0node"))) {
[10:33:37.398]                             sendCondition <<- function(cond) {
[10:33:37.398]                               data <- list(type = "VALUE", value = cond, 
[10:33:37.398]                                 success = TRUE)
[10:33:37.398]                               parallel_sendData(master, data)
[10:33:37.398]                             }
[10:33:37.398]                             return(sendCondition)
[10:33:37.398]                           }
[10:33:37.398]                         }
[10:33:37.398]                         frame <- frame + 1L
[10:33:37.398]                         envir <- sys.frame(frame)
[10:33:37.398]                       }
[10:33:37.398]                     }
[10:33:37.398]                     sendCondition <<- function(cond) NULL
[10:33:37.398]                   }
[10:33:37.398]                 })
[10:33:37.398]                 withCallingHandlers({
[10:33:37.398]                   subset(data, a == 2)
[10:33:37.398]                 }, immediateCondition = function(cond) {
[10:33:37.398]                   sendCondition <- ...future.makeSendCondition()
[10:33:37.398]                   sendCondition(cond)
[10:33:37.398]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.398]                   {
[10:33:37.398]                     inherits <- base::inherits
[10:33:37.398]                     invokeRestart <- base::invokeRestart
[10:33:37.398]                     is.null <- base::is.null
[10:33:37.398]                     muffled <- FALSE
[10:33:37.398]                     if (inherits(cond, "message")) {
[10:33:37.398]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:37.398]                       if (muffled) 
[10:33:37.398]                         invokeRestart("muffleMessage")
[10:33:37.398]                     }
[10:33:37.398]                     else if (inherits(cond, "warning")) {
[10:33:37.398]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:37.398]                       if (muffled) 
[10:33:37.398]                         invokeRestart("muffleWarning")
[10:33:37.398]                     }
[10:33:37.398]                     else if (inherits(cond, "condition")) {
[10:33:37.398]                       if (!is.null(pattern)) {
[10:33:37.398]                         computeRestarts <- base::computeRestarts
[10:33:37.398]                         grepl <- base::grepl
[10:33:37.398]                         restarts <- computeRestarts(cond)
[10:33:37.398]                         for (restart in restarts) {
[10:33:37.398]                           name <- restart$name
[10:33:37.398]                           if (is.null(name)) 
[10:33:37.398]                             next
[10:33:37.398]                           if (!grepl(pattern, name)) 
[10:33:37.398]                             next
[10:33:37.398]                           invokeRestart(restart)
[10:33:37.398]                           muffled <- TRUE
[10:33:37.398]                           break
[10:33:37.398]                         }
[10:33:37.398]                       }
[10:33:37.398]                     }
[10:33:37.398]                     invisible(muffled)
[10:33:37.398]                   }
[10:33:37.398]                   muffleCondition(cond)
[10:33:37.398]                 })
[10:33:37.398]             }))
[10:33:37.398]             future::FutureResult(value = ...future.value$value, 
[10:33:37.398]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.398]                   ...future.rng), globalenv = if (FALSE) 
[10:33:37.398]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:37.398]                     ...future.globalenv.names))
[10:33:37.398]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:37.398]         }, condition = base::local({
[10:33:37.398]             c <- base::c
[10:33:37.398]             inherits <- base::inherits
[10:33:37.398]             invokeRestart <- base::invokeRestart
[10:33:37.398]             length <- base::length
[10:33:37.398]             list <- base::list
[10:33:37.398]             seq.int <- base::seq.int
[10:33:37.398]             signalCondition <- base::signalCondition
[10:33:37.398]             sys.calls <- base::sys.calls
[10:33:37.398]             `[[` <- base::`[[`
[10:33:37.398]             `+` <- base::`+`
[10:33:37.398]             `<<-` <- base::`<<-`
[10:33:37.398]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:37.398]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:37.398]                   3L)]
[10:33:37.398]             }
[10:33:37.398]             function(cond) {
[10:33:37.398]                 is_error <- inherits(cond, "error")
[10:33:37.398]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:37.398]                   NULL)
[10:33:37.398]                 if (is_error) {
[10:33:37.398]                   sessionInformation <- function() {
[10:33:37.398]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:37.398]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:37.398]                       search = base::search(), system = base::Sys.info())
[10:33:37.398]                   }
[10:33:37.398]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.398]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:37.398]                     cond$call), session = sessionInformation(), 
[10:33:37.398]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:37.398]                   signalCondition(cond)
[10:33:37.398]                 }
[10:33:37.398]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:37.398]                 "immediateCondition"))) {
[10:33:37.398]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:37.398]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.398]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:37.398]                   if (TRUE && !signal) {
[10:33:37.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.398]                     {
[10:33:37.398]                       inherits <- base::inherits
[10:33:37.398]                       invokeRestart <- base::invokeRestart
[10:33:37.398]                       is.null <- base::is.null
[10:33:37.398]                       muffled <- FALSE
[10:33:37.398]                       if (inherits(cond, "message")) {
[10:33:37.398]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.398]                         if (muffled) 
[10:33:37.398]                           invokeRestart("muffleMessage")
[10:33:37.398]                       }
[10:33:37.398]                       else if (inherits(cond, "warning")) {
[10:33:37.398]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.398]                         if (muffled) 
[10:33:37.398]                           invokeRestart("muffleWarning")
[10:33:37.398]                       }
[10:33:37.398]                       else if (inherits(cond, "condition")) {
[10:33:37.398]                         if (!is.null(pattern)) {
[10:33:37.398]                           computeRestarts <- base::computeRestarts
[10:33:37.398]                           grepl <- base::grepl
[10:33:37.398]                           restarts <- computeRestarts(cond)
[10:33:37.398]                           for (restart in restarts) {
[10:33:37.398]                             name <- restart$name
[10:33:37.398]                             if (is.null(name)) 
[10:33:37.398]                               next
[10:33:37.398]                             if (!grepl(pattern, name)) 
[10:33:37.398]                               next
[10:33:37.398]                             invokeRestart(restart)
[10:33:37.398]                             muffled <- TRUE
[10:33:37.398]                             break
[10:33:37.398]                           }
[10:33:37.398]                         }
[10:33:37.398]                       }
[10:33:37.398]                       invisible(muffled)
[10:33:37.398]                     }
[10:33:37.398]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.398]                   }
[10:33:37.398]                 }
[10:33:37.398]                 else {
[10:33:37.398]                   if (TRUE) {
[10:33:37.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.398]                     {
[10:33:37.398]                       inherits <- base::inherits
[10:33:37.398]                       invokeRestart <- base::invokeRestart
[10:33:37.398]                       is.null <- base::is.null
[10:33:37.398]                       muffled <- FALSE
[10:33:37.398]                       if (inherits(cond, "message")) {
[10:33:37.398]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.398]                         if (muffled) 
[10:33:37.398]                           invokeRestart("muffleMessage")
[10:33:37.398]                       }
[10:33:37.398]                       else if (inherits(cond, "warning")) {
[10:33:37.398]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.398]                         if (muffled) 
[10:33:37.398]                           invokeRestart("muffleWarning")
[10:33:37.398]                       }
[10:33:37.398]                       else if (inherits(cond, "condition")) {
[10:33:37.398]                         if (!is.null(pattern)) {
[10:33:37.398]                           computeRestarts <- base::computeRestarts
[10:33:37.398]                           grepl <- base::grepl
[10:33:37.398]                           restarts <- computeRestarts(cond)
[10:33:37.398]                           for (restart in restarts) {
[10:33:37.398]                             name <- restart$name
[10:33:37.398]                             if (is.null(name)) 
[10:33:37.398]                               next
[10:33:37.398]                             if (!grepl(pattern, name)) 
[10:33:37.398]                               next
[10:33:37.398]                             invokeRestart(restart)
[10:33:37.398]                             muffled <- TRUE
[10:33:37.398]                             break
[10:33:37.398]                           }
[10:33:37.398]                         }
[10:33:37.398]                       }
[10:33:37.398]                       invisible(muffled)
[10:33:37.398]                     }
[10:33:37.398]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.398]                   }
[10:33:37.398]                 }
[10:33:37.398]             }
[10:33:37.398]         }))
[10:33:37.398]     }, error = function(ex) {
[10:33:37.398]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:37.398]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.398]                 ...future.rng), started = ...future.startTime, 
[10:33:37.398]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:37.398]             version = "1.8"), class = "FutureResult")
[10:33:37.398]     }, finally = {
[10:33:37.398]         if (!identical(...future.workdir, getwd())) 
[10:33:37.398]             setwd(...future.workdir)
[10:33:37.398]         {
[10:33:37.398]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:37.398]                 ...future.oldOptions$nwarnings <- NULL
[10:33:37.398]             }
[10:33:37.398]             base::options(...future.oldOptions)
[10:33:37.398]             if (.Platform$OS.type == "windows") {
[10:33:37.398]                 old_names <- names(...future.oldEnvVars)
[10:33:37.398]                 envs <- base::Sys.getenv()
[10:33:37.398]                 names <- names(envs)
[10:33:37.398]                 common <- intersect(names, old_names)
[10:33:37.398]                 added <- setdiff(names, old_names)
[10:33:37.398]                 removed <- setdiff(old_names, names)
[10:33:37.398]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:37.398]                   envs[common]]
[10:33:37.398]                 NAMES <- toupper(changed)
[10:33:37.398]                 args <- list()
[10:33:37.398]                 for (kk in seq_along(NAMES)) {
[10:33:37.398]                   name <- changed[[kk]]
[10:33:37.398]                   NAME <- NAMES[[kk]]
[10:33:37.398]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.398]                     next
[10:33:37.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.398]                 }
[10:33:37.398]                 NAMES <- toupper(added)
[10:33:37.398]                 for (kk in seq_along(NAMES)) {
[10:33:37.398]                   name <- added[[kk]]
[10:33:37.398]                   NAME <- NAMES[[kk]]
[10:33:37.398]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.398]                     next
[10:33:37.398]                   args[[name]] <- ""
[10:33:37.398]                 }
[10:33:37.398]                 NAMES <- toupper(removed)
[10:33:37.398]                 for (kk in seq_along(NAMES)) {
[10:33:37.398]                   name <- removed[[kk]]
[10:33:37.398]                   NAME <- NAMES[[kk]]
[10:33:37.398]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.398]                     next
[10:33:37.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.398]                 }
[10:33:37.398]                 if (length(args) > 0) 
[10:33:37.398]                   base::do.call(base::Sys.setenv, args = args)
[10:33:37.398]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:37.398]             }
[10:33:37.398]             else {
[10:33:37.398]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:37.398]             }
[10:33:37.398]             {
[10:33:37.398]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:37.398]                   0L) {
[10:33:37.398]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:37.398]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:37.398]                   base::options(opts)
[10:33:37.398]                 }
[10:33:37.398]                 {
[10:33:37.398]                   {
[10:33:37.398]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:37.398]                     NULL
[10:33:37.398]                   }
[10:33:37.398]                   options(future.plan = NULL)
[10:33:37.398]                   if (is.na(NA_character_)) 
[10:33:37.398]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.398]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:37.398]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:37.398]                     .init = FALSE)
[10:33:37.398]                 }
[10:33:37.398]             }
[10:33:37.398]         }
[10:33:37.398]     })
[10:33:37.398]     if (TRUE) {
[10:33:37.398]         base::sink(type = "output", split = FALSE)
[10:33:37.398]         if (TRUE) {
[10:33:37.398]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:37.398]         }
[10:33:37.398]         else {
[10:33:37.398]             ...future.result["stdout"] <- base::list(NULL)
[10:33:37.398]         }
[10:33:37.398]         base::close(...future.stdout)
[10:33:37.398]         ...future.stdout <- NULL
[10:33:37.398]     }
[10:33:37.398]     ...future.result$conditions <- ...future.conditions
[10:33:37.398]     ...future.result$finished <- base::Sys.time()
[10:33:37.398]     ...future.result
[10:33:37.398] }
[10:33:37.417]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.401] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[10:33:37.417]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.401] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[10:33:37.418]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.401] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[10:33:37.418]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.401] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[10:33:37.418]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.402] MultisessionFuture started
[10:33:37.418]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.402] - Launch lazy future ... done
[10:33:37.418]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.402] run() for ‘MultisessionFuture’ ... done
[10:33:37.418]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.402] result() for ClusterFuture ...
[10:33:37.418]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.402] receiveMessageFromWorker() for ClusterFuture ...
[10:33:37.418]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.402] - Validating connection of MultisessionFuture
[10:33:37.419]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.407] - received message: FutureResult
[10:33:37.419]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.407] - Received FutureResult
[10:33:37.419]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.407] - Erased future from FutureRegistry
[10:33:37.419]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.407] result() for ClusterFuture ...
[10:33:37.419]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.407] - result already collected: FutureResult
[10:33:37.419]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.408] result() for ClusterFuture ... done
[10:33:37.419]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.408] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:37.420]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.408] result() for ClusterFuture ... done
[10:33:37.420]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.408] result() for ClusterFuture ...
[10:33:37.420]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.408] - result already collected: FutureResult
[10:33:37.420]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.408] result() for ClusterFuture ... done
[10:33:37.420] signalConditions() ... done
- plan(list('sequential', 'multisession')) ... DONE
- plan(list('multicore', 'sequential')) ...
[10:33:37.420] plan(): Setting new future strategy stack:
[10:33:37.420] List of future strategies:
[10:33:37.420] 1. multicore:
[10:33:37.420]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:37.420]    - tweaked: FALSE
[10:33:37.420]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.420] 2. sequential:
[10:33:37.420]    - args: function (..., envir = parent.frame())
[10:33:37.420]    - tweaked: FALSE
[10:33:37.420]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.425] plan(): nbrOfWorkers() = 2
[10:33:37.426] getGlobalsAndPackages() ...
[10:33:37.426] Searching for globals...
[10:33:37.446] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:33:37.446] Searching for globals ... DONE
[10:33:37.446] Resolving globals: FALSE
[10:33:37.447] The total size of the 2 globals is 57.84 KiB (59224 bytes)
[10:33:37.448] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 57.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (57.72 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[10:33:37.448] - globals: [2] ‘nested’, ‘strategy2’
[10:33:37.448] - packages: [1] ‘future’
[10:33:37.448] getGlobalsAndPackages() ... DONE
[10:33:37.449] run() for ‘Future’ ...
[10:33:37.449] - state: ‘created’
[10:33:37.449] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:37.452] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:37.453] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:37.453]   - Field: ‘label’
[10:33:37.453]   - Field: ‘local’
[10:33:37.453]   - Field: ‘owner’
[10:33:37.453]   - Field: ‘envir’
[10:33:37.453]   - Field: ‘workers’
[10:33:37.453]   - Field: ‘packages’
[10:33:37.453]   - Field: ‘gc’
[10:33:37.453]   - Field: ‘job’
[10:33:37.453]   - Field: ‘conditions’
[10:33:37.454]   - Field: ‘expr’
[10:33:37.454]   - Field: ‘uuid’
[10:33:37.454]   - Field: ‘seed’
[10:33:37.454]   - Field: ‘version’
[10:33:37.454]   - Field: ‘result’
[10:33:37.454]   - Field: ‘asynchronous’
[10:33:37.454]   - Field: ‘calls’
[10:33:37.454]   - Field: ‘globals’
[10:33:37.454]   - Field: ‘stdout’
[10:33:37.454]   - Field: ‘earlySignal’
[10:33:37.454]   - Field: ‘lazy’
[10:33:37.455]   - Field: ‘state’
[10:33:37.455] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:37.455] - Launch lazy future ...
[10:33:37.455] Packages needed by the future expression (n = 1): ‘future’
[10:33:37.455] Packages needed by future strategies (n = 1): ‘future’
[10:33:37.456] {
[10:33:37.456]     {
[10:33:37.456]         {
[10:33:37.456]             ...future.startTime <- base::Sys.time()
[10:33:37.456]             {
[10:33:37.456]                 {
[10:33:37.456]                   {
[10:33:37.456]                     {
[10:33:37.456]                       {
[10:33:37.456]                         base::local({
[10:33:37.456]                           has_future <- base::requireNamespace("future", 
[10:33:37.456]                             quietly = TRUE)
[10:33:37.456]                           if (has_future) {
[10:33:37.456]                             ns <- base::getNamespace("future")
[10:33:37.456]                             version <- ns[[".package"]][["version"]]
[10:33:37.456]                             if (is.null(version)) 
[10:33:37.456]                               version <- utils::packageVersion("future")
[10:33:37.456]                           }
[10:33:37.456]                           else {
[10:33:37.456]                             version <- NULL
[10:33:37.456]                           }
[10:33:37.456]                           if (!has_future || version < "1.8.0") {
[10:33:37.456]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:37.456]                               "", base::R.version$version.string), 
[10:33:37.456]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:37.456]                                 base::R.version$platform, 8 * 
[10:33:37.456]                                   base::.Machine$sizeof.pointer), 
[10:33:37.456]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:37.456]                                 "release", "version")], collapse = " "), 
[10:33:37.456]                               hostname = base::Sys.info()[["nodename"]])
[10:33:37.456]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:37.456]                               info)
[10:33:37.456]                             info <- base::paste(info, collapse = "; ")
[10:33:37.456]                             if (!has_future) {
[10:33:37.456]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:37.456]                                 info)
[10:33:37.456]                             }
[10:33:37.456]                             else {
[10:33:37.456]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:37.456]                                 info, version)
[10:33:37.456]                             }
[10:33:37.456]                             base::stop(msg)
[10:33:37.456]                           }
[10:33:37.456]                         })
[10:33:37.456]                       }
[10:33:37.456]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:37.456]                       base::options(mc.cores = 1L)
[10:33:37.456]                     }
[10:33:37.456]                     base::local({
[10:33:37.456]                       for (pkg in "future") {
[10:33:37.456]                         base::loadNamespace(pkg)
[10:33:37.456]                         base::library(pkg, character.only = TRUE)
[10:33:37.456]                       }
[10:33:37.456]                     })
[10:33:37.456]                   }
[10:33:37.456]                   ...future.strategy.old <- future::plan("list")
[10:33:37.456]                   options(future.plan = NULL)
[10:33:37.456]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.456]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:33:37.456]                   {
[10:33:37.456]                     future <- SequentialFuture(..., envir = envir)
[10:33:37.456]                     if (!future$lazy) 
[10:33:37.456]                       future <- run(future)
[10:33:37.456]                     invisible(future)
[10:33:37.456]                   }), .cleanup = FALSE, .init = FALSE)
[10:33:37.456]                 }
[10:33:37.456]                 ...future.workdir <- getwd()
[10:33:37.456]             }
[10:33:37.456]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:37.456]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:37.456]         }
[10:33:37.456]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:37.456]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:37.456]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:37.456]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:37.456]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:37.456]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:37.456]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:37.456]             base::names(...future.oldOptions))
[10:33:37.456]     }
[10:33:37.456]     if (FALSE) {
[10:33:37.456]     }
[10:33:37.456]     else {
[10:33:37.456]         if (TRUE) {
[10:33:37.456]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:37.456]                 open = "w")
[10:33:37.456]         }
[10:33:37.456]         else {
[10:33:37.456]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:37.456]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:37.456]         }
[10:33:37.456]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:37.456]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:37.456]             base::sink(type = "output", split = FALSE)
[10:33:37.456]             base::close(...future.stdout)
[10:33:37.456]         }, add = TRUE)
[10:33:37.456]     }
[10:33:37.456]     ...future.frame <- base::sys.nframe()
[10:33:37.456]     ...future.conditions <- base::list()
[10:33:37.456]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:37.456]     if (FALSE) {
[10:33:37.456]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:37.456]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:37.456]     }
[10:33:37.456]     ...future.result <- base::tryCatch({
[10:33:37.456]         base::withCallingHandlers({
[10:33:37.456]             ...future.value <- base::withVisible(base::local({
[10:33:37.456]                 withCallingHandlers({
[10:33:37.456]                   {
[10:33:37.456]                     a <- 1L
[10:33:37.456]                     plan_a <- unclass(future::plan("list"))
[10:33:37.456]                     nested_a <- nested[-1]
[10:33:37.456]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:33:37.456]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:33:37.456]                       strategy2))
[10:33:37.456]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:33:37.456]                       "init") <- NULL
[10:33:37.456]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:33:37.456]                       "init") <- NULL
[10:33:37.456]                     stopifnot(all.equal(plan_a, nested_a))
[10:33:37.456]                     y %<-% {
[10:33:37.456]                       b <- 2L
[10:33:37.456]                       plan_b <- future::plan("list")
[10:33:37.456]                       nested_b <- nested_a[-1]
[10:33:37.456]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:33:37.456]                         1L, inherits(plan_b[[1]], "future"), 
[10:33:37.456]                         inherits(future::plan("next"), "sequential"))
[10:33:37.456]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:33:37.456]                         b = b, nested_b = nested_b, plan_b = plan_b)
[10:33:37.456]                     }
[10:33:37.456]                     y
[10:33:37.456]                   }
[10:33:37.456]                 }, immediateCondition = function(cond) {
[10:33:37.456]                   save_rds <- function (object, pathname, ...) 
[10:33:37.456]                   {
[10:33:37.456]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:37.456]                     if (file_test("-f", pathname_tmp)) {
[10:33:37.456]                       fi_tmp <- file.info(pathname_tmp)
[10:33:37.456]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:37.456]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:37.456]                         fi_tmp[["mtime"]])
[10:33:37.456]                     }
[10:33:37.456]                     tryCatch({
[10:33:37.456]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:37.456]                     }, error = function(ex) {
[10:33:37.456]                       msg <- conditionMessage(ex)
[10:33:37.456]                       fi_tmp <- file.info(pathname_tmp)
[10:33:37.456]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:37.456]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:37.456]                         fi_tmp[["mtime"]], msg)
[10:33:37.456]                       ex$message <- msg
[10:33:37.456]                       stop(ex)
[10:33:37.456]                     })
[10:33:37.456]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:37.456]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:37.456]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:37.456]                       fi_tmp <- file.info(pathname_tmp)
[10:33:37.456]                       fi <- file.info(pathname)
[10:33:37.456]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:37.456]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:37.456]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:37.456]                         fi[["size"]], fi[["mtime"]])
[10:33:37.456]                       stop(msg)
[10:33:37.456]                     }
[10:33:37.456]                     invisible(pathname)
[10:33:37.456]                   }
[10:33:37.456]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:37.456]                     rootPath = tempdir()) 
[10:33:37.456]                   {
[10:33:37.456]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:37.456]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:37.456]                       tmpdir = path, fileext = ".rds")
[10:33:37.456]                     save_rds(obj, file)
[10:33:37.456]                   }
[10:33:37.456]                   saveImmediateCondition(cond, path = "/tmp/RtmpTlTEh1/.future/immediateConditions")
[10:33:37.456]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.456]                   {
[10:33:37.456]                     inherits <- base::inherits
[10:33:37.456]                     invokeRestart <- base::invokeRestart
[10:33:37.456]                     is.null <- base::is.null
[10:33:37.456]                     muffled <- FALSE
[10:33:37.456]                     if (inherits(cond, "message")) {
[10:33:37.456]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:37.456]                       if (muffled) 
[10:33:37.456]                         invokeRestart("muffleMessage")
[10:33:37.456]                     }
[10:33:37.456]                     else if (inherits(cond, "warning")) {
[10:33:37.456]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:37.456]                       if (muffled) 
[10:33:37.456]                         invokeRestart("muffleWarning")
[10:33:37.456]                     }
[10:33:37.456]                     else if (inherits(cond, "condition")) {
[10:33:37.456]                       if (!is.null(pattern)) {
[10:33:37.456]                         computeRestarts <- base::computeRestarts
[10:33:37.456]                         grepl <- base::grepl
[10:33:37.456]                         restarts <- computeRestarts(cond)
[10:33:37.456]                         for (restart in restarts) {
[10:33:37.456]                           name <- restart$name
[10:33:37.456]                           if (is.null(name)) 
[10:33:37.456]                             next
[10:33:37.456]                           if (!grepl(pattern, name)) 
[10:33:37.456]                             next
[10:33:37.456]                           invokeRestart(restart)
[10:33:37.456]                           muffled <- TRUE
[10:33:37.456]                           break
[10:33:37.456]                         }
[10:33:37.456]                       }
[10:33:37.456]                     }
[10:33:37.456]                     invisible(muffled)
[10:33:37.456]                   }
[10:33:37.456]                   muffleCondition(cond)
[10:33:37.456]                 })
[10:33:37.456]             }))
[10:33:37.456]             future::FutureResult(value = ...future.value$value, 
[10:33:37.456]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.456]                   ...future.rng), globalenv = if (FALSE) 
[10:33:37.456]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:37.456]                     ...future.globalenv.names))
[10:33:37.456]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:37.456]         }, condition = base::local({
[10:33:37.456]             c <- base::c
[10:33:37.456]             inherits <- base::inherits
[10:33:37.456]             invokeRestart <- base::invokeRestart
[10:33:37.456]             length <- base::length
[10:33:37.456]             list <- base::list
[10:33:37.456]             seq.int <- base::seq.int
[10:33:37.456]             signalCondition <- base::signalCondition
[10:33:37.456]             sys.calls <- base::sys.calls
[10:33:37.456]             `[[` <- base::`[[`
[10:33:37.456]             `+` <- base::`+`
[10:33:37.456]             `<<-` <- base::`<<-`
[10:33:37.456]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:37.456]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:37.456]                   3L)]
[10:33:37.456]             }
[10:33:37.456]             function(cond) {
[10:33:37.456]                 is_error <- inherits(cond, "error")
[10:33:37.456]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:37.456]                   NULL)
[10:33:37.456]                 if (is_error) {
[10:33:37.456]                   sessionInformation <- function() {
[10:33:37.456]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:37.456]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:37.456]                       search = base::search(), system = base::Sys.info())
[10:33:37.456]                   }
[10:33:37.456]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.456]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:37.456]                     cond$call), session = sessionInformation(), 
[10:33:37.456]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:37.456]                   signalCondition(cond)
[10:33:37.456]                 }
[10:33:37.456]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:37.456]                 "immediateCondition"))) {
[10:33:37.456]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:37.456]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.456]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:37.456]                   if (TRUE && !signal) {
[10:33:37.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.456]                     {
[10:33:37.456]                       inherits <- base::inherits
[10:33:37.456]                       invokeRestart <- base::invokeRestart
[10:33:37.456]                       is.null <- base::is.null
[10:33:37.456]                       muffled <- FALSE
[10:33:37.456]                       if (inherits(cond, "message")) {
[10:33:37.456]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.456]                         if (muffled) 
[10:33:37.456]                           invokeRestart("muffleMessage")
[10:33:37.456]                       }
[10:33:37.456]                       else if (inherits(cond, "warning")) {
[10:33:37.456]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.456]                         if (muffled) 
[10:33:37.456]                           invokeRestart("muffleWarning")
[10:33:37.456]                       }
[10:33:37.456]                       else if (inherits(cond, "condition")) {
[10:33:37.456]                         if (!is.null(pattern)) {
[10:33:37.456]                           computeRestarts <- base::computeRestarts
[10:33:37.456]                           grepl <- base::grepl
[10:33:37.456]                           restarts <- computeRestarts(cond)
[10:33:37.456]                           for (restart in restarts) {
[10:33:37.456]                             name <- restart$name
[10:33:37.456]                             if (is.null(name)) 
[10:33:37.456]                               next
[10:33:37.456]                             if (!grepl(pattern, name)) 
[10:33:37.456]                               next
[10:33:37.456]                             invokeRestart(restart)
[10:33:37.456]                             muffled <- TRUE
[10:33:37.456]                             break
[10:33:37.456]                           }
[10:33:37.456]                         }
[10:33:37.456]                       }
[10:33:37.456]                       invisible(muffled)
[10:33:37.456]                     }
[10:33:37.456]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.456]                   }
[10:33:37.456]                 }
[10:33:37.456]                 else {
[10:33:37.456]                   if (TRUE) {
[10:33:37.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.456]                     {
[10:33:37.456]                       inherits <- base::inherits
[10:33:37.456]                       invokeRestart <- base::invokeRestart
[10:33:37.456]                       is.null <- base::is.null
[10:33:37.456]                       muffled <- FALSE
[10:33:37.456]                       if (inherits(cond, "message")) {
[10:33:37.456]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.456]                         if (muffled) 
[10:33:37.456]                           invokeRestart("muffleMessage")
[10:33:37.456]                       }
[10:33:37.456]                       else if (inherits(cond, "warning")) {
[10:33:37.456]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.456]                         if (muffled) 
[10:33:37.456]                           invokeRestart("muffleWarning")
[10:33:37.456]                       }
[10:33:37.456]                       else if (inherits(cond, "condition")) {
[10:33:37.456]                         if (!is.null(pattern)) {
[10:33:37.456]                           computeRestarts <- base::computeRestarts
[10:33:37.456]                           grepl <- base::grepl
[10:33:37.456]                           restarts <- computeRestarts(cond)
[10:33:37.456]                           for (restart in restarts) {
[10:33:37.456]                             name <- restart$name
[10:33:37.456]                             if (is.null(name)) 
[10:33:37.456]                               next
[10:33:37.456]                             if (!grepl(pattern, name)) 
[10:33:37.456]                               next
[10:33:37.456]                             invokeRestart(restart)
[10:33:37.456]                             muffled <- TRUE
[10:33:37.456]                             break
[10:33:37.456]                           }
[10:33:37.456]                         }
[10:33:37.456]                       }
[10:33:37.456]                       invisible(muffled)
[10:33:37.456]                     }
[10:33:37.456]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.456]                   }
[10:33:37.456]                 }
[10:33:37.456]             }
[10:33:37.456]         }))
[10:33:37.456]     }, error = function(ex) {
[10:33:37.456]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:37.456]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.456]                 ...future.rng), started = ...future.startTime, 
[10:33:37.456]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:37.456]             version = "1.8"), class = "FutureResult")
[10:33:37.456]     }, finally = {
[10:33:37.456]         if (!identical(...future.workdir, getwd())) 
[10:33:37.456]             setwd(...future.workdir)
[10:33:37.456]         {
[10:33:37.456]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:37.456]                 ...future.oldOptions$nwarnings <- NULL
[10:33:37.456]             }
[10:33:37.456]             base::options(...future.oldOptions)
[10:33:37.456]             if (.Platform$OS.type == "windows") {
[10:33:37.456]                 old_names <- names(...future.oldEnvVars)
[10:33:37.456]                 envs <- base::Sys.getenv()
[10:33:37.456]                 names <- names(envs)
[10:33:37.456]                 common <- intersect(names, old_names)
[10:33:37.456]                 added <- setdiff(names, old_names)
[10:33:37.456]                 removed <- setdiff(old_names, names)
[10:33:37.456]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:37.456]                   envs[common]]
[10:33:37.456]                 NAMES <- toupper(changed)
[10:33:37.456]                 args <- list()
[10:33:37.456]                 for (kk in seq_along(NAMES)) {
[10:33:37.456]                   name <- changed[[kk]]
[10:33:37.456]                   NAME <- NAMES[[kk]]
[10:33:37.456]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.456]                     next
[10:33:37.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.456]                 }
[10:33:37.456]                 NAMES <- toupper(added)
[10:33:37.456]                 for (kk in seq_along(NAMES)) {
[10:33:37.456]                   name <- added[[kk]]
[10:33:37.456]                   NAME <- NAMES[[kk]]
[10:33:37.456]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.456]                     next
[10:33:37.456]                   args[[name]] <- ""
[10:33:37.456]                 }
[10:33:37.456]                 NAMES <- toupper(removed)
[10:33:37.456]                 for (kk in seq_along(NAMES)) {
[10:33:37.456]                   name <- removed[[kk]]
[10:33:37.456]                   NAME <- NAMES[[kk]]
[10:33:37.456]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.456]                     next
[10:33:37.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.456]                 }
[10:33:37.456]                 if (length(args) > 0) 
[10:33:37.456]                   base::do.call(base::Sys.setenv, args = args)
[10:33:37.456]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:37.456]             }
[10:33:37.456]             else {
[10:33:37.456]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:37.456]             }
[10:33:37.456]             {
[10:33:37.456]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:37.456]                   0L) {
[10:33:37.456]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:37.456]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:37.456]                   base::options(opts)
[10:33:37.456]                 }
[10:33:37.456]                 {
[10:33:37.456]                   {
[10:33:37.456]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:37.456]                     NULL
[10:33:37.456]                   }
[10:33:37.456]                   options(future.plan = NULL)
[10:33:37.456]                   if (is.na(NA_character_)) 
[10:33:37.456]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.456]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:37.456]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:37.456]                     .init = FALSE)
[10:33:37.456]                 }
[10:33:37.456]             }
[10:33:37.456]         }
[10:33:37.456]     })
[10:33:37.456]     if (TRUE) {
[10:33:37.456]         base::sink(type = "output", split = FALSE)
[10:33:37.456]         if (TRUE) {
[10:33:37.456]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:37.456]         }
[10:33:37.456]         else {
[10:33:37.456]             ...future.result["stdout"] <- base::list(NULL)
[10:33:37.456]         }
[10:33:37.456]         base::close(...future.stdout)
[10:33:37.456]         ...future.stdout <- NULL
[10:33:37.456]     }
[10:33:37.456]     ...future.result$conditions <- ...future.conditions
[10:33:37.456]     ...future.result$finished <- base::Sys.time()
[10:33:37.456]     ...future.result
[10:33:37.456] }
[10:33:37.458] assign_globals() ...
[10:33:37.458] List of 2
[10:33:37.458]  $ nested   :List of 2
[10:33:37.458]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:33:37.458]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:33:37.458]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:33:37.458]   ..$ b:function (..., envir = parent.frame())  
[10:33:37.458]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:33:37.458]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:33:37.458]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:33:37.458]  $ strategy2: chr "sequential"
[10:33:37.458]  - attr(*, "where")=List of 2
[10:33:37.458]   ..$ nested   :<environment: R_EmptyEnv> 
[10:33:37.458]   ..$ strategy2:<environment: R_EmptyEnv> 
[10:33:37.458]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:37.458]  - attr(*, "resolved")= logi FALSE
[10:33:37.458]  - attr(*, "total_size")= num 59224
[10:33:37.458]  - attr(*, "already-done")= logi TRUE
[10:33:37.463] - copied ‘nested’ to environment
[10:33:37.463] - copied ‘strategy2’ to environment
[10:33:37.463] assign_globals() ... done
[10:33:37.463] requestCore(): workers = 2
[10:33:37.465] MulticoreFuture started
[10:33:37.466] - Launch lazy future ... done
[10:33:37.466] run() for ‘MulticoreFuture’ ... done
[10:33:37.467] result() for MulticoreFuture ...
[10:33:37.467] plan(): Setting new future strategy stack:
[10:33:37.467] List of future strategies:
[10:33:37.467] 1. sequential:
[10:33:37.467]    - args: function (..., envir = parent.frame())
[10:33:37.467]    - tweaked: FALSE
[10:33:37.467]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.468] plan(): nbrOfWorkers() = 1
[10:33:37.505] plan(): Setting new future strategy stack:
[10:33:37.505] List of future strategies:
[10:33:37.505] 1. multicore:
[10:33:37.505]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:37.505]    - tweaked: FALSE
[10:33:37.505]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.505] 2. sequential:
[10:33:37.505]    - args: function (..., envir = parent.frame())
[10:33:37.505]    - tweaked: FALSE
[10:33:37.505]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.509] plan(): nbrOfWorkers() = 2
[10:33:37.510] result() for MulticoreFuture ...
[10:33:37.511] result() for MulticoreFuture ... done
[10:33:37.511] signalConditions() ...
[10:33:37.511]  - include = ‘immediateCondition’
[10:33:37.511]  - exclude = 
[10:33:37.511]  - resignal = FALSE
[10:33:37.511]  - Number of conditions: 54
[10:33:37.511] signalConditions() ... done
[10:33:37.512] result() for MulticoreFuture ... done
[10:33:37.512] result() for MulticoreFuture ...
[10:33:37.512] result() for MulticoreFuture ... done
[10:33:37.512] signalConditions() ...
[10:33:37.512]  - include = ‘immediateCondition’
[10:33:37.512]  - exclude = 
[10:33:37.512]  - resignal = FALSE
[10:33:37.512]  - Number of conditions: 54
[10:33:37.513] signalConditions() ... done
[10:33:37.513] Future state: ‘finished’
[10:33:37.513] result() for MulticoreFuture ...
[10:33:37.513] result() for MulticoreFuture ... done
[10:33:37.513] signalConditions() ...
[10:33:37.513]  - include = ‘condition’
[10:33:37.513]  - exclude = ‘immediateCondition’
[10:33:37.513]  - resignal = TRUE
[10:33:37.514]  - Number of conditions: 54
[10:33:37.514]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.470] getGlobalsAndPackages() ...
[10:33:37.514]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.470] Searching for globals...
[10:33:37.514]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.480] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[10:33:37.514]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.480] Searching for globals ... DONE
[10:33:37.514]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.481] Resolving globals: FALSE
[10:33:37.515]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.482] The total size of the 3 globals is 22.54 KiB (23080 bytes)
[10:33:37.515]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.483] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 22.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (11.24 KiB of class ‘list’), ‘plan_a’ (11.24 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[10:33:37.515]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.483] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[10:33:37.515]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.483] 
[10:33:37.515]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.483] getGlobalsAndPackages() ... DONE
[10:33:37.516]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.484] run() for ‘Future’ ...
[10:33:37.516]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.484] - state: ‘created’
[10:33:37.516]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.485] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:37.516]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.485] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:37.516]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.485] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:37.516]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.485]   - Field: ‘label’
[10:33:37.517]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.486]   - Field: ‘local’
[10:33:37.517]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.486]   - Field: ‘owner’
[10:33:37.517]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.486]   - Field: ‘envir’
[10:33:37.517]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.486]   - Field: ‘packages’
[10:33:37.517]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.486]   - Field: ‘gc’
[10:33:37.518]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.486]   - Field: ‘conditions’
[10:33:37.518]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.487]   - Field: ‘expr’
[10:33:37.518]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.487]   - Field: ‘uuid’
[10:33:37.518]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.487]   - Field: ‘seed’
[10:33:37.518]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.487]   - Field: ‘version’
[10:33:37.519]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.487]   - Field: ‘result’
[10:33:37.519]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.487]   - Field: ‘asynchronous’
[10:33:37.519]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.488]   - Field: ‘calls’
[10:33:37.519]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.488]   - Field: ‘globals’
[10:33:37.519]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.488]   - Field: ‘stdout’
[10:33:37.520]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.488]   - Field: ‘earlySignal’
[10:33:37.520]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.488]   - Field: ‘lazy’
[10:33:37.520]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.488]   - Field: ‘state’
[10:33:37.520]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.489] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:37.520]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.489] - Launch lazy future ...
[10:33:37.520]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.489] Packages needed by the future expression (n = 0): <none>
[10:33:37.521]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.489] Packages needed by future strategies (n = 0): <none>
[10:33:37.521]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.490] {
[10:33:37.490]     {
[10:33:37.490]         {
[10:33:37.490]             ...future.startTime <- base::Sys.time()
[10:33:37.490]             {
[10:33:37.490]                 {
[10:33:37.490]                   {
[10:33:37.490]                     base::local({
[10:33:37.490]                       has_future <- base::requireNamespace("future", 
[10:33:37.490]                         quietly = TRUE)
[10:33:37.490]                       if (has_future) {
[10:33:37.490]                         ns <- base::getNamespace("future")
[10:33:37.490]                         version <- ns[[".package"]][["version"]]
[10:33:37.490]                         if (is.null(version)) 
[10:33:37.490]                           version <- utils::packageVersion("future")
[10:33:37.490]                       }
[10:33:37.490]                       else {
[10:33:37.490]                         version <- NULL
[10:33:37.490]                       }
[10:33:37.490]                       if (!has_future || version < "1.8.0") {
[10:33:37.490]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:37.490]                           "", base::R.version$version.string), 
[10:33:37.490]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:37.490]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:37.490]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:37.490]                             "release", "version")], collapse = " "), 
[10:33:37.490]                           hostname = base::Sys.info()[["nodename"]])
[10:33:37.490]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:37.490]                           info)
[10:33:37.490]                         info <- base::paste(info, collapse = "; ")
[10:33:37.490]                         if (!has_future) {
[10:33:37.490]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:37.490]                             info)
[10:33:37.490]                         }
[10:33:37.490]                         else {
[10:33:37.490]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:37.490]                             info, version)
[10:33:37.490]                         }
[10:33:37.490]                         base::stop(msg)
[10:33:37.490]                       }
[10:33:37.490]                     })
[10:33:37.490]                   }
[10:33:37.490]                   ...future.strategy.old <- future::plan("list")
[10:33:37.490]                   options(future.plan = NULL)
[10:33:37.490]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.490]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:37.490]                 }
[10:33:37.490]                 ...future.workdir <- getwd()
[10:33:37.490]             }
[10:33:37.490]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:37.490]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:37.490]         }
[10:33:37.490]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:37.490]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:37.490]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:37.490]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:37.490]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:37.490]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:37.490]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:37.490]             base::names(...future.oldOptions))
[10:33:37.490]     }
[10:33:37.490]     if (FALSE) {
[10:33:37.490]     }
[10:33:37.490]     else {
[10:33:37.490]         if (TRUE) {
[10:33:37.490]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:37.490]                 open = "w")
[10:33:37.490]         }
[10:33:37.490]         else {
[10:33:37.490]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:37.490]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:37.490]         }
[10:33:37.490]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:37.490]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:37.490]             base::sink(type = "output", split = FALSE)
[10:33:37.490]             base::close(...future.stdout)
[10:33:37.490]         }, add = TRUE)
[10:33:37.490]     }
[10:33:37.490]     ...future.frame <- base::sys.nframe()
[10:33:37.490]     ...future.conditions <- base::list()
[10:33:37.490]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:37.490]     if (FALSE) {
[10:33:37.490]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:37.490]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:37.490]     }
[10:33:37.490]     ...future.result <- base::tryCatch({
[10:33:37.490]         base::withCallingHandlers({
[10:33:37.490]             ...future.value <- base::withVisible(base::local({
[10:33:37.490]                 b <- 2L
[10:33:37.490]                 plan_b <- future::plan("list")
[10:33:37.490]                 nested_b <- nested_a[-1]
[10:33:37.490]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:33:37.490]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:33:37.490]                   "sequential"))
[10:33:37.490]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:33:37.490]                   b = b, nested_b = nested_b, plan_b = plan_b)
[10:33:37.490]             }))
[10:33:37.490]             future::FutureResult(value = ...future.value$value, 
[10:33:37.490]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.490]                   ...future.rng), globalenv = if (FALSE) 
[10:33:37.490]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:37.490]                     ...future.globalenv.names))
[10:33:37.490]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:37.490]         }, condition = base::local({
[10:33:37.490]             c <- base::c
[10:33:37.490]             inherits <- base::inherits
[10:33:37.490]             invokeRestart <- base::invokeRestart
[10:33:37.490]             length <- base::length
[10:33:37.490]             list <- base::list
[10:33:37.490]             seq.int <- base::seq.int
[10:33:37.490]             signalCondition <- base::signalCondition
[10:33:37.490]             sys.calls <- base::sys.calls
[10:33:37.490]             `[[` <- base::`[[`
[10:33:37.490]             `+` <- base::`+`
[10:33:37.490]             `<<-` <- base::`<<-`
[10:33:37.490]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:37.490]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:37.490]                   3L)]
[10:33:37.490]             }
[10:33:37.490]             function(cond) {
[10:33:37.490]                 is_error <- inherits(cond, "error")
[10:33:37.490]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:37.490]                   NULL)
[10:33:37.490]                 if (is_error) {
[10:33:37.490]                   sessionInformation <- function() {
[10:33:37.490]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:37.490]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:37.490]                       search = base::search(), system = base::Sys.info())
[10:33:37.490]                   }
[10:33:37.490]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.490]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:37.490]                     cond$call), session = sessionInformation(), 
[10:33:37.490]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:37.490]                   signalCondition(cond)
[10:33:37.490]                 }
[10:33:37.490]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:37.490]                 "immediateCondition"))) {
[10:33:37.490]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:37.490]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.490]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:37.490]                   if (TRUE && !signal) {
[10:33:37.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.490]                     {
[10:33:37.490]                       inherits <- base::inherits
[10:33:37.490]                       invokeRestart <- base::invokeRestart
[10:33:37.490]                       is.null <- base::is.null
[10:33:37.490]                       muffled <- FALSE
[10:33:37.490]                       if (inherits(cond, "message")) {
[10:33:37.490]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.490]                         if (muffled) 
[10:33:37.490]                           invokeRestart("muffleMessage")
[10:33:37.490]                       }
[10:33:37.490]                       else if (inherits(cond, "warning")) {
[10:33:37.490]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.490]                         if (muffled) 
[10:33:37.490]                           invokeRestart("muffleWarning")
[10:33:37.490]                       }
[10:33:37.490]                       else if (inherits(cond, "condition")) {
[10:33:37.490]                         if (!is.null(pattern)) {
[10:33:37.490]                           computeRestarts <- base::computeRestarts
[10:33:37.490]                           grepl <- base::grepl
[10:33:37.490]                           restarts <- computeRestarts(cond)
[10:33:37.490]                           for (restart in restarts) {
[10:33:37.490]                             name <- restart$name
[10:33:37.490]                             if (is.null(name)) 
[10:33:37.490]                               next
[10:33:37.490]                             if (!grepl(pattern, name)) 
[10:33:37.490]                               next
[10:33:37.490]                             invokeRestart(restart)
[10:33:37.490]                             muffled <- TRUE
[10:33:37.490]                             break
[10:33:37.490]                           }
[10:33:37.490]                         }
[10:33:37.490]                       }
[10:33:37.490]                       invisible(muffled)
[10:33:37.490]                     }
[10:33:37.490]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.490]                   }
[10:33:37.490]                 }
[10:33:37.490]                 else {
[10:33:37.490]                   if (TRUE) {
[10:33:37.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.490]                     {
[10:33:37.490]                       inherits <- base::inherits
[10:33:37.490]                       invokeRestart <- base::invokeRestart
[10:33:37.490]                       is.null <- base::is.null
[10:33:37.490]                       muffled <- FALSE
[10:33:37.490]                       if (inherits(cond, "message")) {
[10:33:37.490]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.490]                         if (muffled) 
[10:33:37.490]                           invokeRestart("muffleMessage")
[10:33:37.490]                       }
[10:33:37.490]                       else if (inherits(cond, "warning")) {
[10:33:37.490]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.490]                         if (muffled) 
[10:33:37.490]                           invokeRestart("muffleWarning")
[10:33:37.490]                       }
[10:33:37.490]                       else if (inherits(cond, "condition")) {
[10:33:37.490]                         if (!is.null(pattern)) {
[10:33:37.490]                           computeRestarts <- base::computeRestarts
[10:33:37.490]                           grepl <- base::grepl
[10:33:37.490]                           restarts <- computeRestarts(cond)
[10:33:37.490]                           for (restart in restarts) {
[10:33:37.490]                             name <- restart$name
[10:33:37.490]                             if (is.null(name)) 
[10:33:37.490]                               next
[10:33:37.490]                             if (!grepl(pattern, name)) 
[10:33:37.490]                               next
[10:33:37.490]                             invokeRestart(restart)
[10:33:37.490]                             muffled <- TRUE
[10:33:37.490]                             break
[10:33:37.490]                           }
[10:33:37.490]                         }
[10:33:37.490]                       }
[10:33:37.490]                       invisible(muffled)
[10:33:37.490]                     }
[10:33:37.490]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.490]                   }
[10:33:37.490]                 }
[10:33:37.490]             }
[10:33:37.490]         }))
[10:33:37.490]     }, error = function(ex) {
[10:33:37.490]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:37.490]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.490]                 ...future.rng), started = ...future.startTime, 
[10:33:37.490]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:37.490]             version = "1.8"), class = "FutureResult")
[10:33:37.490]     }, finally = {
[10:33:37.490]         if (!identical(...future.workdir, getwd())) 
[10:33:37.490]             setwd(...future.workdir)
[10:33:37.490]         {
[10:33:37.490]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:37.490]                 ...future.oldOptions$nwarnings <- NULL
[10:33:37.490]             }
[10:33:37.490]             base::options(...future.oldOptions)
[10:33:37.490]             if (.Platform$OS.type == "windows") {
[10:33:37.490]                 old_names <- names(...future.oldEnvVars)
[10:33:37.490]                 envs <- base::Sys.getenv()
[10:33:37.490]                 names <- names(envs)
[10:33:37.490]                 common <- intersect(names, old_names)
[10:33:37.490]                 added <- setdiff(names, old_names)
[10:33:37.490]                 removed <- setdiff(old_names, names)
[10:33:37.490]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:37.490]                   envs[common]]
[10:33:37.490]                 NAMES <- toupper(changed)
[10:33:37.490]                 args <- list()
[10:33:37.490]                 for (kk in seq_along(NAMES)) {
[10:33:37.490]                   name <- changed[[kk]]
[10:33:37.490]                   NAME <- NAMES[[kk]]
[10:33:37.490]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.490]                     next
[10:33:37.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.490]                 }
[10:33:37.490]                 NAMES <- toupper(added)
[10:33:37.490]                 for (kk in seq_along(NAMES)) {
[10:33:37.490]                   name <- added[[kk]]
[10:33:37.490]                   NAME <- NAMES[[kk]]
[10:33:37.490]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.490]                     next
[10:33:37.490]                   args[[name]] <- ""
[10:33:37.490]                 }
[10:33:37.490]                 NAMES <- toupper(removed)
[10:33:37.490]                 for (kk in seq_along(NAMES)) {
[10:33:37.490]                   name <- removed[[kk]]
[10:33:37.490]                   NAME <- NAMES[[kk]]
[10:33:37.490]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.490]                     next
[10:33:37.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.490]                 }
[10:33:37.490]                 if (length(args) > 0) 
[10:33:37.490]                   base::do.call(base::Sys.setenv, args = args)
[10:33:37.490]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:37.490]             }
[10:33:37.490]             else {
[10:33:37.490]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:37.490]             }
[10:33:37.490]             {
[10:33:37.490]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:37.490]                   0L) {
[10:33:37.490]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:37.490]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:37.490]                   base::options(opts)
[10:33:37.490]                 }
[10:33:37.490]                 {
[10:33:37.490]                   {
[10:33:37.490]                     NULL
[10:33:37.490]                     RNGkind("Mersenne-Twister")
[10:33:37.490]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:37.490]                       inherits = FALSE)
[10:33:37.490]                   }
[10:33:37.490]                   options(future.plan = NULL)
[10:33:37.490]                   if (is.na(NA_character_)) 
[10:33:37.490]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.490]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:37.490]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:37.490]                     .init = FALSE)
[10:33:37.490]                 }
[10:33:37.490]             }
[10:33:37.490]         }
[10:33:37.490]     })
[10:33:37.490]     if (TRUE) {
[10:33:37.490]         base::sink(type = "output", split = FALSE)
[10:33:37.490]         if (TRUE) {
[10:33:37.490]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:37.490]         }
[10:33:37.490]         else {
[10:33:37.490]             ...future.result["stdout"] <- base::list(NULL)
[10:33:37.490]         }
[10:33:37.490]         base::close(...future.stdout)
[10:33:37.490]         ...future.stdout <- NULL
[10:33:37.490]     }
[10:33:37.490]     ...future.result$conditions <- ...future.conditions
[10:33:37.490]     ...future.result$finished <- base::Sys.time()
[10:33:37.490]     ...future.result
[10:33:37.490] }
[10:33:37.521]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.492] assign_globals() ...
[10:33:37.521]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.493] List of 3
[10:33:37.493]  $ nested_a:List of 1
[10:33:37.493]   ..$ b:function (..., envir = parent.frame())  
[10:33:37.493]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:33:37.493]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:33:37.493]  $ a       : int 1
[10:33:37.493]  $ plan_a  :List of 1
[10:33:37.493]   ..$ b:function (..., envir = parent.frame())  
[10:33:37.493]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:33:37.493]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:33:37.493]  - attr(*, "where")=List of 3
[10:33:37.493]   ..$ nested_a:<environment: R_EmptyEnv> 
[10:33:37.493]   ..$ a       :<environment: R_EmptyEnv> 
[10:33:37.493]   ..$ plan_a  :<environment: R_EmptyEnv> 
[10:33:37.493]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:37.493]  - attr(*, "resolved")= logi FALSE
[10:33:37.493]  - attr(*, "total_size")= num 23080
[10:33:37.493]  - attr(*, "already-done")= logi TRUE
[10:33:37.521]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.500] - copied ‘nested_a’ to environment
[10:33:37.522]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.500] - copied ‘a’ to environment
[10:33:37.522]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.500] - copied ‘plan_a’ to environment
[10:33:37.522]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.501] assign_globals() ... done
[10:33:37.522]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.501] plan(): Setting new future strategy stack:
[10:33:37.522]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.501] List of future strategies:
[10:33:37.501] 1. sequential:
[10:33:37.501]    - args: function (..., envir = parent.frame())
[10:33:37.501]    - tweaked: FALSE
[10:33:37.501]    - call: NULL
[10:33:37.522]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.502] plan(): nbrOfWorkers() = 1
[10:33:37.523]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.503] plan(): Setting new future strategy stack:
[10:33:37.523]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.503] List of future strategies:
[10:33:37.503] 1. sequential:
[10:33:37.503]    - args: function (..., envir = parent.frame())
[10:33:37.503]    - tweaked: FALSE
[10:33:37.503]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.523]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.503] plan(): nbrOfWorkers() = 1
[10:33:37.523]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.504] SequentialFuture started (and completed)
[10:33:37.523]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.504] - Launch lazy future ... done
[10:33:37.523]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.504] run() for ‘SequentialFuture’ ... done
[10:33:37.524] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:33:37.530] getGlobalsAndPackages() ...
[10:33:37.530] Searching for globals...
[10:33:37.531] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:33:37.532] Searching for globals ... DONE
[10:33:37.532] Resolving globals: FALSE
[10:33:37.532] The total size of the 1 globals is 128 bytes (128 bytes)
[10:33:37.533] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:33:37.533] - globals: [1] ‘data’
[10:33:37.533] - packages: [1] ‘future’
[10:33:37.533] getGlobalsAndPackages() ... DONE
[10:33:37.534] run() for ‘Future’ ...
[10:33:37.534] - state: ‘created’
[10:33:37.534] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:37.538] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:37.538] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:37.539]   - Field: ‘label’
[10:33:37.539]   - Field: ‘local’
[10:33:37.539]   - Field: ‘owner’
[10:33:37.539]   - Field: ‘envir’
[10:33:37.539]   - Field: ‘workers’
[10:33:37.539]   - Field: ‘packages’
[10:33:37.540]   - Field: ‘gc’
[10:33:37.540]   - Field: ‘job’
[10:33:37.540]   - Field: ‘conditions’
[10:33:37.540]   - Field: ‘expr’
[10:33:37.540]   - Field: ‘uuid’
[10:33:37.540]   - Field: ‘seed’
[10:33:37.540]   - Field: ‘version’
[10:33:37.540]   - Field: ‘result’
[10:33:37.541]   - Field: ‘asynchronous’
[10:33:37.541]   - Field: ‘calls’
[10:33:37.541]   - Field: ‘globals’
[10:33:37.541]   - Field: ‘stdout’
[10:33:37.541]   - Field: ‘earlySignal’
[10:33:37.541]   - Field: ‘lazy’
[10:33:37.541]   - Field: ‘state’
[10:33:37.541] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:37.542] - Launch lazy future ...
[10:33:37.542] Packages needed by the future expression (n = 1): ‘future’
[10:33:37.542] Packages needed by future strategies (n = 1): ‘future’
[10:33:37.543] {
[10:33:37.543]     {
[10:33:37.543]         {
[10:33:37.543]             ...future.startTime <- base::Sys.time()
[10:33:37.543]             {
[10:33:37.543]                 {
[10:33:37.543]                   {
[10:33:37.543]                     {
[10:33:37.543]                       {
[10:33:37.543]                         base::local({
[10:33:37.543]                           has_future <- base::requireNamespace("future", 
[10:33:37.543]                             quietly = TRUE)
[10:33:37.543]                           if (has_future) {
[10:33:37.543]                             ns <- base::getNamespace("future")
[10:33:37.543]                             version <- ns[[".package"]][["version"]]
[10:33:37.543]                             if (is.null(version)) 
[10:33:37.543]                               version <- utils::packageVersion("future")
[10:33:37.543]                           }
[10:33:37.543]                           else {
[10:33:37.543]                             version <- NULL
[10:33:37.543]                           }
[10:33:37.543]                           if (!has_future || version < "1.8.0") {
[10:33:37.543]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:37.543]                               "", base::R.version$version.string), 
[10:33:37.543]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:37.543]                                 base::R.version$platform, 8 * 
[10:33:37.543]                                   base::.Machine$sizeof.pointer), 
[10:33:37.543]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:37.543]                                 "release", "version")], collapse = " "), 
[10:33:37.543]                               hostname = base::Sys.info()[["nodename"]])
[10:33:37.543]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:37.543]                               info)
[10:33:37.543]                             info <- base::paste(info, collapse = "; ")
[10:33:37.543]                             if (!has_future) {
[10:33:37.543]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:37.543]                                 info)
[10:33:37.543]                             }
[10:33:37.543]                             else {
[10:33:37.543]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:37.543]                                 info, version)
[10:33:37.543]                             }
[10:33:37.543]                             base::stop(msg)
[10:33:37.543]                           }
[10:33:37.543]                         })
[10:33:37.543]                       }
[10:33:37.543]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:37.543]                       base::options(mc.cores = 1L)
[10:33:37.543]                     }
[10:33:37.543]                     base::local({
[10:33:37.543]                       for (pkg in "future") {
[10:33:37.543]                         base::loadNamespace(pkg)
[10:33:37.543]                         base::library(pkg, character.only = TRUE)
[10:33:37.543]                       }
[10:33:37.543]                     })
[10:33:37.543]                   }
[10:33:37.543]                   ...future.strategy.old <- future::plan("list")
[10:33:37.543]                   options(future.plan = NULL)
[10:33:37.543]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.543]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:33:37.543]                   {
[10:33:37.543]                     future <- SequentialFuture(..., envir = envir)
[10:33:37.543]                     if (!future$lazy) 
[10:33:37.543]                       future <- run(future)
[10:33:37.543]                     invisible(future)
[10:33:37.543]                   }), .cleanup = FALSE, .init = FALSE)
[10:33:37.543]                 }
[10:33:37.543]                 ...future.workdir <- getwd()
[10:33:37.543]             }
[10:33:37.543]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:37.543]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:37.543]         }
[10:33:37.543]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:37.543]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:37.543]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:37.543]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:37.543]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:37.543]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:37.543]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:37.543]             base::names(...future.oldOptions))
[10:33:37.543]     }
[10:33:37.543]     if (FALSE) {
[10:33:37.543]     }
[10:33:37.543]     else {
[10:33:37.543]         if (TRUE) {
[10:33:37.543]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:37.543]                 open = "w")
[10:33:37.543]         }
[10:33:37.543]         else {
[10:33:37.543]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:37.543]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:37.543]         }
[10:33:37.543]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:37.543]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:37.543]             base::sink(type = "output", split = FALSE)
[10:33:37.543]             base::close(...future.stdout)
[10:33:37.543]         }, add = TRUE)
[10:33:37.543]     }
[10:33:37.543]     ...future.frame <- base::sys.nframe()
[10:33:37.543]     ...future.conditions <- base::list()
[10:33:37.543]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:37.543]     if (FALSE) {
[10:33:37.543]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:37.543]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:37.543]     }
[10:33:37.543]     ...future.result <- base::tryCatch({
[10:33:37.543]         base::withCallingHandlers({
[10:33:37.543]             ...future.value <- base::withVisible(base::local({
[10:33:37.543]                 withCallingHandlers({
[10:33:37.543]                   {
[10:33:37.543]                     value(future(subset(data, a == 2)))
[10:33:37.543]                   }
[10:33:37.543]                 }, immediateCondition = function(cond) {
[10:33:37.543]                   save_rds <- function (object, pathname, ...) 
[10:33:37.543]                   {
[10:33:37.543]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:37.543]                     if (file_test("-f", pathname_tmp)) {
[10:33:37.543]                       fi_tmp <- file.info(pathname_tmp)
[10:33:37.543]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:37.543]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:37.543]                         fi_tmp[["mtime"]])
[10:33:37.543]                     }
[10:33:37.543]                     tryCatch({
[10:33:37.543]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:37.543]                     }, error = function(ex) {
[10:33:37.543]                       msg <- conditionMessage(ex)
[10:33:37.543]                       fi_tmp <- file.info(pathname_tmp)
[10:33:37.543]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:37.543]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:37.543]                         fi_tmp[["mtime"]], msg)
[10:33:37.543]                       ex$message <- msg
[10:33:37.543]                       stop(ex)
[10:33:37.543]                     })
[10:33:37.543]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:37.543]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:37.543]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:37.543]                       fi_tmp <- file.info(pathname_tmp)
[10:33:37.543]                       fi <- file.info(pathname)
[10:33:37.543]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:37.543]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:37.543]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:37.543]                         fi[["size"]], fi[["mtime"]])
[10:33:37.543]                       stop(msg)
[10:33:37.543]                     }
[10:33:37.543]                     invisible(pathname)
[10:33:37.543]                   }
[10:33:37.543]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:37.543]                     rootPath = tempdir()) 
[10:33:37.543]                   {
[10:33:37.543]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:37.543]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:37.543]                       tmpdir = path, fileext = ".rds")
[10:33:37.543]                     save_rds(obj, file)
[10:33:37.543]                   }
[10:33:37.543]                   saveImmediateCondition(cond, path = "/tmp/RtmpTlTEh1/.future/immediateConditions")
[10:33:37.543]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.543]                   {
[10:33:37.543]                     inherits <- base::inherits
[10:33:37.543]                     invokeRestart <- base::invokeRestart
[10:33:37.543]                     is.null <- base::is.null
[10:33:37.543]                     muffled <- FALSE
[10:33:37.543]                     if (inherits(cond, "message")) {
[10:33:37.543]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:37.543]                       if (muffled) 
[10:33:37.543]                         invokeRestart("muffleMessage")
[10:33:37.543]                     }
[10:33:37.543]                     else if (inherits(cond, "warning")) {
[10:33:37.543]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:37.543]                       if (muffled) 
[10:33:37.543]                         invokeRestart("muffleWarning")
[10:33:37.543]                     }
[10:33:37.543]                     else if (inherits(cond, "condition")) {
[10:33:37.543]                       if (!is.null(pattern)) {
[10:33:37.543]                         computeRestarts <- base::computeRestarts
[10:33:37.543]                         grepl <- base::grepl
[10:33:37.543]                         restarts <- computeRestarts(cond)
[10:33:37.543]                         for (restart in restarts) {
[10:33:37.543]                           name <- restart$name
[10:33:37.543]                           if (is.null(name)) 
[10:33:37.543]                             next
[10:33:37.543]                           if (!grepl(pattern, name)) 
[10:33:37.543]                             next
[10:33:37.543]                           invokeRestart(restart)
[10:33:37.543]                           muffled <- TRUE
[10:33:37.543]                           break
[10:33:37.543]                         }
[10:33:37.543]                       }
[10:33:37.543]                     }
[10:33:37.543]                     invisible(muffled)
[10:33:37.543]                   }
[10:33:37.543]                   muffleCondition(cond)
[10:33:37.543]                 })
[10:33:37.543]             }))
[10:33:37.543]             future::FutureResult(value = ...future.value$value, 
[10:33:37.543]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.543]                   ...future.rng), globalenv = if (FALSE) 
[10:33:37.543]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:37.543]                     ...future.globalenv.names))
[10:33:37.543]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:37.543]         }, condition = base::local({
[10:33:37.543]             c <- base::c
[10:33:37.543]             inherits <- base::inherits
[10:33:37.543]             invokeRestart <- base::invokeRestart
[10:33:37.543]             length <- base::length
[10:33:37.543]             list <- base::list
[10:33:37.543]             seq.int <- base::seq.int
[10:33:37.543]             signalCondition <- base::signalCondition
[10:33:37.543]             sys.calls <- base::sys.calls
[10:33:37.543]             `[[` <- base::`[[`
[10:33:37.543]             `+` <- base::`+`
[10:33:37.543]             `<<-` <- base::`<<-`
[10:33:37.543]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:37.543]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:37.543]                   3L)]
[10:33:37.543]             }
[10:33:37.543]             function(cond) {
[10:33:37.543]                 is_error <- inherits(cond, "error")
[10:33:37.543]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:37.543]                   NULL)
[10:33:37.543]                 if (is_error) {
[10:33:37.543]                   sessionInformation <- function() {
[10:33:37.543]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:37.543]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:37.543]                       search = base::search(), system = base::Sys.info())
[10:33:37.543]                   }
[10:33:37.543]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.543]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:37.543]                     cond$call), session = sessionInformation(), 
[10:33:37.543]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:37.543]                   signalCondition(cond)
[10:33:37.543]                 }
[10:33:37.543]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:37.543]                 "immediateCondition"))) {
[10:33:37.543]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:37.543]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.543]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:37.543]                   if (TRUE && !signal) {
[10:33:37.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.543]                     {
[10:33:37.543]                       inherits <- base::inherits
[10:33:37.543]                       invokeRestart <- base::invokeRestart
[10:33:37.543]                       is.null <- base::is.null
[10:33:37.543]                       muffled <- FALSE
[10:33:37.543]                       if (inherits(cond, "message")) {
[10:33:37.543]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.543]                         if (muffled) 
[10:33:37.543]                           invokeRestart("muffleMessage")
[10:33:37.543]                       }
[10:33:37.543]                       else if (inherits(cond, "warning")) {
[10:33:37.543]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.543]                         if (muffled) 
[10:33:37.543]                           invokeRestart("muffleWarning")
[10:33:37.543]                       }
[10:33:37.543]                       else if (inherits(cond, "condition")) {
[10:33:37.543]                         if (!is.null(pattern)) {
[10:33:37.543]                           computeRestarts <- base::computeRestarts
[10:33:37.543]                           grepl <- base::grepl
[10:33:37.543]                           restarts <- computeRestarts(cond)
[10:33:37.543]                           for (restart in restarts) {
[10:33:37.543]                             name <- restart$name
[10:33:37.543]                             if (is.null(name)) 
[10:33:37.543]                               next
[10:33:37.543]                             if (!grepl(pattern, name)) 
[10:33:37.543]                               next
[10:33:37.543]                             invokeRestart(restart)
[10:33:37.543]                             muffled <- TRUE
[10:33:37.543]                             break
[10:33:37.543]                           }
[10:33:37.543]                         }
[10:33:37.543]                       }
[10:33:37.543]                       invisible(muffled)
[10:33:37.543]                     }
[10:33:37.543]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.543]                   }
[10:33:37.543]                 }
[10:33:37.543]                 else {
[10:33:37.543]                   if (TRUE) {
[10:33:37.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.543]                     {
[10:33:37.543]                       inherits <- base::inherits
[10:33:37.543]                       invokeRestart <- base::invokeRestart
[10:33:37.543]                       is.null <- base::is.null
[10:33:37.543]                       muffled <- FALSE
[10:33:37.543]                       if (inherits(cond, "message")) {
[10:33:37.543]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.543]                         if (muffled) 
[10:33:37.543]                           invokeRestart("muffleMessage")
[10:33:37.543]                       }
[10:33:37.543]                       else if (inherits(cond, "warning")) {
[10:33:37.543]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.543]                         if (muffled) 
[10:33:37.543]                           invokeRestart("muffleWarning")
[10:33:37.543]                       }
[10:33:37.543]                       else if (inherits(cond, "condition")) {
[10:33:37.543]                         if (!is.null(pattern)) {
[10:33:37.543]                           computeRestarts <- base::computeRestarts
[10:33:37.543]                           grepl <- base::grepl
[10:33:37.543]                           restarts <- computeRestarts(cond)
[10:33:37.543]                           for (restart in restarts) {
[10:33:37.543]                             name <- restart$name
[10:33:37.543]                             if (is.null(name)) 
[10:33:37.543]                               next
[10:33:37.543]                             if (!grepl(pattern, name)) 
[10:33:37.543]                               next
[10:33:37.543]                             invokeRestart(restart)
[10:33:37.543]                             muffled <- TRUE
[10:33:37.543]                             break
[10:33:37.543]                           }
[10:33:37.543]                         }
[10:33:37.543]                       }
[10:33:37.543]                       invisible(muffled)
[10:33:37.543]                     }
[10:33:37.543]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.543]                   }
[10:33:37.543]                 }
[10:33:37.543]             }
[10:33:37.543]         }))
[10:33:37.543]     }, error = function(ex) {
[10:33:37.543]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:37.543]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.543]                 ...future.rng), started = ...future.startTime, 
[10:33:37.543]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:37.543]             version = "1.8"), class = "FutureResult")
[10:33:37.543]     }, finally = {
[10:33:37.543]         if (!identical(...future.workdir, getwd())) 
[10:33:37.543]             setwd(...future.workdir)
[10:33:37.543]         {
[10:33:37.543]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:37.543]                 ...future.oldOptions$nwarnings <- NULL
[10:33:37.543]             }
[10:33:37.543]             base::options(...future.oldOptions)
[10:33:37.543]             if (.Platform$OS.type == "windows") {
[10:33:37.543]                 old_names <- names(...future.oldEnvVars)
[10:33:37.543]                 envs <- base::Sys.getenv()
[10:33:37.543]                 names <- names(envs)
[10:33:37.543]                 common <- intersect(names, old_names)
[10:33:37.543]                 added <- setdiff(names, old_names)
[10:33:37.543]                 removed <- setdiff(old_names, names)
[10:33:37.543]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:37.543]                   envs[common]]
[10:33:37.543]                 NAMES <- toupper(changed)
[10:33:37.543]                 args <- list()
[10:33:37.543]                 for (kk in seq_along(NAMES)) {
[10:33:37.543]                   name <- changed[[kk]]
[10:33:37.543]                   NAME <- NAMES[[kk]]
[10:33:37.543]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.543]                     next
[10:33:37.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.543]                 }
[10:33:37.543]                 NAMES <- toupper(added)
[10:33:37.543]                 for (kk in seq_along(NAMES)) {
[10:33:37.543]                   name <- added[[kk]]
[10:33:37.543]                   NAME <- NAMES[[kk]]
[10:33:37.543]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.543]                     next
[10:33:37.543]                   args[[name]] <- ""
[10:33:37.543]                 }
[10:33:37.543]                 NAMES <- toupper(removed)
[10:33:37.543]                 for (kk in seq_along(NAMES)) {
[10:33:37.543]                   name <- removed[[kk]]
[10:33:37.543]                   NAME <- NAMES[[kk]]
[10:33:37.543]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.543]                     next
[10:33:37.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.543]                 }
[10:33:37.543]                 if (length(args) > 0) 
[10:33:37.543]                   base::do.call(base::Sys.setenv, args = args)
[10:33:37.543]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:37.543]             }
[10:33:37.543]             else {
[10:33:37.543]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:37.543]             }
[10:33:37.543]             {
[10:33:37.543]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:37.543]                   0L) {
[10:33:37.543]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:37.543]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:37.543]                   base::options(opts)
[10:33:37.543]                 }
[10:33:37.543]                 {
[10:33:37.543]                   {
[10:33:37.543]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:37.543]                     NULL
[10:33:37.543]                   }
[10:33:37.543]                   options(future.plan = NULL)
[10:33:37.543]                   if (is.na(NA_character_)) 
[10:33:37.543]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.543]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:37.543]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:37.543]                     .init = FALSE)
[10:33:37.543]                 }
[10:33:37.543]             }
[10:33:37.543]         }
[10:33:37.543]     })
[10:33:37.543]     if (TRUE) {
[10:33:37.543]         base::sink(type = "output", split = FALSE)
[10:33:37.543]         if (TRUE) {
[10:33:37.543]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:37.543]         }
[10:33:37.543]         else {
[10:33:37.543]             ...future.result["stdout"] <- base::list(NULL)
[10:33:37.543]         }
[10:33:37.543]         base::close(...future.stdout)
[10:33:37.543]         ...future.stdout <- NULL
[10:33:37.543]     }
[10:33:37.543]     ...future.result$conditions <- ...future.conditions
[10:33:37.543]     ...future.result$finished <- base::Sys.time()
[10:33:37.543]     ...future.result
[10:33:37.543] }
[10:33:37.545] assign_globals() ...
[10:33:37.545] List of 1
[10:33:37.545]  $ data:'data.frame':	3 obs. of  2 variables:
[10:33:37.545]   ..$ a: int [1:3] 1 2 3
[10:33:37.545]   ..$ b: int [1:3] 3 2 1
[10:33:37.545]  - attr(*, "where")=List of 1
[10:33:37.545]   ..$ data:<environment: R_EmptyEnv> 
[10:33:37.545]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:37.545]  - attr(*, "resolved")= logi FALSE
[10:33:37.545]  - attr(*, "total_size")= num 128
[10:33:37.545]  - attr(*, "already-done")= logi TRUE
[10:33:37.549] - copied ‘data’ to environment
[10:33:37.549] assign_globals() ... done
[10:33:37.549] requestCore(): workers = 2
[10:33:37.552] MulticoreFuture started
[10:33:37.552] - Launch lazy future ... done
[10:33:37.552] run() for ‘MulticoreFuture’ ... done
[10:33:37.552] result() for MulticoreFuture ...
[10:33:37.553] plan(): Setting new future strategy stack:
[10:33:37.553] List of future strategies:
[10:33:37.553] 1. sequential:
[10:33:37.553]    - args: function (..., envir = parent.frame())
[10:33:37.553]    - tweaked: FALSE
[10:33:37.553]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.554] plan(): nbrOfWorkers() = 1
[10:33:37.578] plan(): Setting new future strategy stack:
[10:33:37.578] List of future strategies:
[10:33:37.578] 1. multicore:
[10:33:37.578]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:37.578]    - tweaked: FALSE
[10:33:37.578]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.578] 2. sequential:
[10:33:37.578]    - args: function (..., envir = parent.frame())
[10:33:37.578]    - tweaked: FALSE
[10:33:37.578]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.582] plan(): nbrOfWorkers() = 2
[10:33:37.584] result() for MulticoreFuture ...
[10:33:37.584] result() for MulticoreFuture ... done
[10:33:37.584] signalConditions() ...
[10:33:37.584]  - include = ‘immediateCondition’
[10:33:37.584]  - exclude = 
[10:33:37.584]  - resignal = FALSE
[10:33:37.584]  - Number of conditions: 52
[10:33:37.584] signalConditions() ... done
[10:33:37.585] result() for MulticoreFuture ... done
[10:33:37.585] result() for MulticoreFuture ...
[10:33:37.585] result() for MulticoreFuture ... done
[10:33:37.585] signalConditions() ...
[10:33:37.585]  - include = ‘immediateCondition’
[10:33:37.585]  - exclude = 
[10:33:37.585]  - resignal = FALSE
[10:33:37.585]  - Number of conditions: 52
[10:33:37.585] signalConditions() ... done
[10:33:37.586] Future state: ‘finished’
[10:33:37.586] result() for MulticoreFuture ...
[10:33:37.586] result() for MulticoreFuture ... done
[10:33:37.586] signalConditions() ...
[10:33:37.586]  - include = ‘condition’
[10:33:37.586]  - exclude = ‘immediateCondition’
[10:33:37.586]  - resignal = TRUE
[10:33:37.586]  - Number of conditions: 52
[10:33:37.587]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.555] getGlobalsAndPackages() ...
[10:33:37.587]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.555] Searching for globals...
[10:33:37.587]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.557] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[10:33:37.587]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.558] Searching for globals ... DONE
[10:33:37.587]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.558] Resolving globals: FALSE
[10:33:37.587]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.559] The total size of the 1 globals is 128 bytes (128 bytes)
[10:33:37.588]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.559] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:33:37.588]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.560] - globals: [1] ‘data’
[10:33:37.588]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.560] 
[10:33:37.588]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.560] getGlobalsAndPackages() ... DONE
[10:33:37.588]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.561] run() for ‘Future’ ...
[10:33:37.588]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.561] - state: ‘created’
[10:33:37.588]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.561] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:37.589]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.562] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:37.589]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.562] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:37.589]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.562]   - Field: ‘label’
[10:33:37.589]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.562]   - Field: ‘local’
[10:33:37.589]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.562]   - Field: ‘owner’
[10:33:37.589]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.562]   - Field: ‘envir’
[10:33:37.590]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.563]   - Field: ‘packages’
[10:33:37.590]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.563]   - Field: ‘gc’
[10:33:37.590]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.563]   - Field: ‘conditions’
[10:33:37.590]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.563]   - Field: ‘expr’
[10:33:37.590]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.563]   - Field: ‘uuid’
[10:33:37.590]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.563]   - Field: ‘seed’
[10:33:37.591]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.564]   - Field: ‘version’
[10:33:37.591]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.564]   - Field: ‘result’
[10:33:37.591]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.564]   - Field: ‘asynchronous’
[10:33:37.591]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.564]   - Field: ‘calls’
[10:33:37.591]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.564]   - Field: ‘globals’
[10:33:37.591]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.564]   - Field: ‘stdout’
[10:33:37.591]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.564]   - Field: ‘earlySignal’
[10:33:37.592]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.565]   - Field: ‘lazy’
[10:33:37.592]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.565]   - Field: ‘state’
[10:33:37.592]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.565] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:37.592]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.565] - Launch lazy future ...
[10:33:37.592]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.565] Packages needed by the future expression (n = 0): <none>
[10:33:37.592]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.566] Packages needed by future strategies (n = 0): <none>
[10:33:37.593]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.566] {
[10:33:37.566]     {
[10:33:37.566]         {
[10:33:37.566]             ...future.startTime <- base::Sys.time()
[10:33:37.566]             {
[10:33:37.566]                 {
[10:33:37.566]                   {
[10:33:37.566]                     base::local({
[10:33:37.566]                       has_future <- base::requireNamespace("future", 
[10:33:37.566]                         quietly = TRUE)
[10:33:37.566]                       if (has_future) {
[10:33:37.566]                         ns <- base::getNamespace("future")
[10:33:37.566]                         version <- ns[[".package"]][["version"]]
[10:33:37.566]                         if (is.null(version)) 
[10:33:37.566]                           version <- utils::packageVersion("future")
[10:33:37.566]                       }
[10:33:37.566]                       else {
[10:33:37.566]                         version <- NULL
[10:33:37.566]                       }
[10:33:37.566]                       if (!has_future || version < "1.8.0") {
[10:33:37.566]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:37.566]                           "", base::R.version$version.string), 
[10:33:37.566]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:37.566]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:37.566]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:37.566]                             "release", "version")], collapse = " "), 
[10:33:37.566]                           hostname = base::Sys.info()[["nodename"]])
[10:33:37.566]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:37.566]                           info)
[10:33:37.566]                         info <- base::paste(info, collapse = "; ")
[10:33:37.566]                         if (!has_future) {
[10:33:37.566]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:37.566]                             info)
[10:33:37.566]                         }
[10:33:37.566]                         else {
[10:33:37.566]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:37.566]                             info, version)
[10:33:37.566]                         }
[10:33:37.566]                         base::stop(msg)
[10:33:37.566]                       }
[10:33:37.566]                     })
[10:33:37.566]                   }
[10:33:37.566]                   ...future.strategy.old <- future::plan("list")
[10:33:37.566]                   options(future.plan = NULL)
[10:33:37.566]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.566]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:37.566]                 }
[10:33:37.566]                 ...future.workdir <- getwd()
[10:33:37.566]             }
[10:33:37.566]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:37.566]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:37.566]         }
[10:33:37.566]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:37.566]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:37.566]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:37.566]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:37.566]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:37.566]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:37.566]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:37.566]             base::names(...future.oldOptions))
[10:33:37.566]     }
[10:33:37.566]     if (FALSE) {
[10:33:37.566]     }
[10:33:37.566]     else {
[10:33:37.566]         if (TRUE) {
[10:33:37.566]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:37.566]                 open = "w")
[10:33:37.566]         }
[10:33:37.566]         else {
[10:33:37.566]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:37.566]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:37.566]         }
[10:33:37.566]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:37.566]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:37.566]             base::sink(type = "output", split = FALSE)
[10:33:37.566]             base::close(...future.stdout)
[10:33:37.566]         }, add = TRUE)
[10:33:37.566]     }
[10:33:37.566]     ...future.frame <- base::sys.nframe()
[10:33:37.566]     ...future.conditions <- base::list()
[10:33:37.566]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:37.566]     if (FALSE) {
[10:33:37.566]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:37.566]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:37.566]     }
[10:33:37.566]     ...future.result <- base::tryCatch({
[10:33:37.566]         base::withCallingHandlers({
[10:33:37.566]             ...future.value <- base::withVisible(base::local(subset(data, 
[10:33:37.566]                 a == 2)))
[10:33:37.566]             future::FutureResult(value = ...future.value$value, 
[10:33:37.566]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.566]                   ...future.rng), globalenv = if (FALSE) 
[10:33:37.566]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:37.566]                     ...future.globalenv.names))
[10:33:37.566]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:37.566]         }, condition = base::local({
[10:33:37.566]             c <- base::c
[10:33:37.566]             inherits <- base::inherits
[10:33:37.566]             invokeRestart <- base::invokeRestart
[10:33:37.566]             length <- base::length
[10:33:37.566]             list <- base::list
[10:33:37.566]             seq.int <- base::seq.int
[10:33:37.566]             signalCondition <- base::signalCondition
[10:33:37.566]             sys.calls <- base::sys.calls
[10:33:37.566]             `[[` <- base::`[[`
[10:33:37.566]             `+` <- base::`+`
[10:33:37.566]             `<<-` <- base::`<<-`
[10:33:37.566]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:37.566]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:37.566]                   3L)]
[10:33:37.566]             }
[10:33:37.566]             function(cond) {
[10:33:37.566]                 is_error <- inherits(cond, "error")
[10:33:37.566]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:37.566]                   NULL)
[10:33:37.566]                 if (is_error) {
[10:33:37.566]                   sessionInformation <- function() {
[10:33:37.566]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:37.566]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:37.566]                       search = base::search(), system = base::Sys.info())
[10:33:37.566]                   }
[10:33:37.566]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.566]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:37.566]                     cond$call), session = sessionInformation(), 
[10:33:37.566]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:37.566]                   signalCondition(cond)
[10:33:37.566]                 }
[10:33:37.566]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:37.566]                 "immediateCondition"))) {
[10:33:37.566]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:37.566]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.566]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:37.566]                   if (TRUE && !signal) {
[10:33:37.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.566]                     {
[10:33:37.566]                       inherits <- base::inherits
[10:33:37.566]                       invokeRestart <- base::invokeRestart
[10:33:37.566]                       is.null <- base::is.null
[10:33:37.566]                       muffled <- FALSE
[10:33:37.566]                       if (inherits(cond, "message")) {
[10:33:37.566]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.566]                         if (muffled) 
[10:33:37.566]                           invokeRestart("muffleMessage")
[10:33:37.566]                       }
[10:33:37.566]                       else if (inherits(cond, "warning")) {
[10:33:37.566]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.566]                         if (muffled) 
[10:33:37.566]                           invokeRestart("muffleWarning")
[10:33:37.566]                       }
[10:33:37.566]                       else if (inherits(cond, "condition")) {
[10:33:37.566]                         if (!is.null(pattern)) {
[10:33:37.566]                           computeRestarts <- base::computeRestarts
[10:33:37.566]                           grepl <- base::grepl
[10:33:37.566]                           restarts <- computeRestarts(cond)
[10:33:37.566]                           for (restart in restarts) {
[10:33:37.566]                             name <- restart$name
[10:33:37.566]                             if (is.null(name)) 
[10:33:37.566]                               next
[10:33:37.566]                             if (!grepl(pattern, name)) 
[10:33:37.566]                               next
[10:33:37.566]                             invokeRestart(restart)
[10:33:37.566]                             muffled <- TRUE
[10:33:37.566]                             break
[10:33:37.566]                           }
[10:33:37.566]                         }
[10:33:37.566]                       }
[10:33:37.566]                       invisible(muffled)
[10:33:37.566]                     }
[10:33:37.566]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.566]                   }
[10:33:37.566]                 }
[10:33:37.566]                 else {
[10:33:37.566]                   if (TRUE) {
[10:33:37.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.566]                     {
[10:33:37.566]                       inherits <- base::inherits
[10:33:37.566]                       invokeRestart <- base::invokeRestart
[10:33:37.566]                       is.null <- base::is.null
[10:33:37.566]                       muffled <- FALSE
[10:33:37.566]                       if (inherits(cond, "message")) {
[10:33:37.566]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.566]                         if (muffled) 
[10:33:37.566]                           invokeRestart("muffleMessage")
[10:33:37.566]                       }
[10:33:37.566]                       else if (inherits(cond, "warning")) {
[10:33:37.566]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.566]                         if (muffled) 
[10:33:37.566]                           invokeRestart("muffleWarning")
[10:33:37.566]                       }
[10:33:37.566]                       else if (inherits(cond, "condition")) {
[10:33:37.566]                         if (!is.null(pattern)) {
[10:33:37.566]                           computeRestarts <- base::computeRestarts
[10:33:37.566]                           grepl <- base::grepl
[10:33:37.566]                           restarts <- computeRestarts(cond)
[10:33:37.566]                           for (restart in restarts) {
[10:33:37.566]                             name <- restart$name
[10:33:37.566]                             if (is.null(name)) 
[10:33:37.566]                               next
[10:33:37.566]                             if (!grepl(pattern, name)) 
[10:33:37.566]                               next
[10:33:37.566]                             invokeRestart(restart)
[10:33:37.566]                             muffled <- TRUE
[10:33:37.566]                             break
[10:33:37.566]                           }
[10:33:37.566]                         }
[10:33:37.566]                       }
[10:33:37.566]                       invisible(muffled)
[10:33:37.566]                     }
[10:33:37.566]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.566]                   }
[10:33:37.566]                 }
[10:33:37.566]             }
[10:33:37.566]         }))
[10:33:37.566]     }, error = function(ex) {
[10:33:37.566]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:37.566]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.566]                 ...future.rng), started = ...future.startTime, 
[10:33:37.566]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:37.566]             version = "1.8"), class = "FutureResult")
[10:33:37.566]     }, finally = {
[10:33:37.566]         if (!identical(...future.workdir, getwd())) 
[10:33:37.566]             setwd(...future.workdir)
[10:33:37.566]         {
[10:33:37.566]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:37.566]                 ...future.oldOptions$nwarnings <- NULL
[10:33:37.566]             }
[10:33:37.566]             base::options(...future.oldOptions)
[10:33:37.566]             if (.Platform$OS.type == "windows") {
[10:33:37.566]                 old_names <- names(...future.oldEnvVars)
[10:33:37.566]                 envs <- base::Sys.getenv()
[10:33:37.566]                 names <- names(envs)
[10:33:37.566]                 common <- intersect(names, old_names)
[10:33:37.566]                 added <- setdiff(names, old_names)
[10:33:37.566]                 removed <- setdiff(old_names, names)
[10:33:37.566]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:37.566]                   envs[common]]
[10:33:37.566]                 NAMES <- toupper(changed)
[10:33:37.566]                 args <- list()
[10:33:37.566]                 for (kk in seq_along(NAMES)) {
[10:33:37.566]                   name <- changed[[kk]]
[10:33:37.566]                   NAME <- NAMES[[kk]]
[10:33:37.566]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.566]                     next
[10:33:37.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.566]                 }
[10:33:37.566]                 NAMES <- toupper(added)
[10:33:37.566]                 for (kk in seq_along(NAMES)) {
[10:33:37.566]                   name <- added[[kk]]
[10:33:37.566]                   NAME <- NAMES[[kk]]
[10:33:37.566]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.566]                     next
[10:33:37.566]                   args[[name]] <- ""
[10:33:37.566]                 }
[10:33:37.566]                 NAMES <- toupper(removed)
[10:33:37.566]                 for (kk in seq_along(NAMES)) {
[10:33:37.566]                   name <- removed[[kk]]
[10:33:37.566]                   NAME <- NAMES[[kk]]
[10:33:37.566]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.566]                     next
[10:33:37.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.566]                 }
[10:33:37.566]                 if (length(args) > 0) 
[10:33:37.566]                   base::do.call(base::Sys.setenv, args = args)
[10:33:37.566]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:37.566]             }
[10:33:37.566]             else {
[10:33:37.566]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:37.566]             }
[10:33:37.566]             {
[10:33:37.566]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:37.566]                   0L) {
[10:33:37.566]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:37.566]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:37.566]                   base::options(opts)
[10:33:37.566]                 }
[10:33:37.566]                 {
[10:33:37.566]                   {
[10:33:37.566]                     NULL
[10:33:37.566]                     RNGkind("Mersenne-Twister")
[10:33:37.566]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:37.566]                       inherits = FALSE)
[10:33:37.566]                   }
[10:33:37.566]                   options(future.plan = NULL)
[10:33:37.566]                   if (is.na(NA_character_)) 
[10:33:37.566]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.566]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:37.566]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:37.566]                     .init = FALSE)
[10:33:37.566]                 }
[10:33:37.566]             }
[10:33:37.566]         }
[10:33:37.566]     })
[10:33:37.566]     if (TRUE) {
[10:33:37.566]         base::sink(type = "output", split = FALSE)
[10:33:37.566]         if (TRUE) {
[10:33:37.566]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:37.566]         }
[10:33:37.566]         else {
[10:33:37.566]             ...future.result["stdout"] <- base::list(NULL)
[10:33:37.566]         }
[10:33:37.566]         base::close(...future.stdout)
[10:33:37.566]         ...future.stdout <- NULL
[10:33:37.566]     }
[10:33:37.566]     ...future.result$conditions <- ...future.conditions
[10:33:37.566]     ...future.result$finished <- base::Sys.time()
[10:33:37.566]     ...future.result
[10:33:37.566] }
[10:33:37.593]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.569] assign_globals() ...
[10:33:37.593]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.569] List of 1
[10:33:37.569]  $ data:'data.frame':	3 obs. of  2 variables:
[10:33:37.569]   ..$ a: int [1:3] 1 2 3
[10:33:37.569]   ..$ b: int [1:3] 3 2 1
[10:33:37.569]  - attr(*, "where")=List of 1
[10:33:37.569]   ..$ data:<environment: R_EmptyEnv> 
[10:33:37.569]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:37.569]  - attr(*, "resolved")= logi FALSE
[10:33:37.569]  - attr(*, "total_size")= num 128
[10:33:37.569]  - attr(*, "already-done")= logi TRUE
[10:33:37.593]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.574] - copied ‘data’ to environment
[10:33:37.593]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.574] assign_globals() ... done
[10:33:37.593]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.574] plan(): Setting new future strategy stack:
[10:33:37.593]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.574] List of future strategies:
[10:33:37.574] 1. sequential:
[10:33:37.574]    - args: function (..., envir = parent.frame())
[10:33:37.574]    - tweaked: FALSE
[10:33:37.574]    - call: NULL
[10:33:37.594]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.575] plan(): nbrOfWorkers() = 1
[10:33:37.594]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.576] plan(): Setting new future strategy stack:
[10:33:37.594]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.576] List of future strategies:
[10:33:37.576] 1. sequential:
[10:33:37.576]    - args: function (..., envir = parent.frame())
[10:33:37.576]    - tweaked: FALSE
[10:33:37.576]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.594]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.576] plan(): nbrOfWorkers() = 1
[10:33:37.594]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.577] SequentialFuture started (and completed)
[10:33:37.594]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.577] - Launch lazy future ... done
[10:33:37.595]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.577] run() for ‘SequentialFuture’ ... done
[10:33:37.595] signalConditions() ... done
- plan(list('multicore', 'sequential')) ... DONE
- plan(list('multicore', 'multicore')) ...
[10:33:37.595] plan(): Setting new future strategy stack:
[10:33:37.595] List of future strategies:
[10:33:37.595] 1. multicore:
[10:33:37.595]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:37.595]    - tweaked: FALSE
[10:33:37.595]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.595] 2. multicore:
[10:33:37.595]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:37.595]    - tweaked: FALSE
[10:33:37.595]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.600] plan(): nbrOfWorkers() = 2
[10:33:37.600] getGlobalsAndPackages() ...
[10:33:37.600] Searching for globals...
[10:33:37.622] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:33:37.622] Searching for globals ... DONE
[10:33:37.623] Resolving globals: FALSE
[10:33:37.624] The total size of the 2 globals is 93.07 KiB (95304 bytes)
[10:33:37.624] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 93.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (92.95 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[10:33:37.624] - globals: [2] ‘nested’, ‘strategy2’
[10:33:37.625] - packages: [1] ‘future’
[10:33:37.625] getGlobalsAndPackages() ... DONE
[10:33:37.625] run() for ‘Future’ ...
[10:33:37.625] - state: ‘created’
[10:33:37.625] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:37.629] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:37.630] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:37.630]   - Field: ‘label’
[10:33:37.630]   - Field: ‘local’
[10:33:37.630]   - Field: ‘owner’
[10:33:37.630]   - Field: ‘envir’
[10:33:37.630]   - Field: ‘workers’
[10:33:37.630]   - Field: ‘packages’
[10:33:37.630]   - Field: ‘gc’
[10:33:37.630]   - Field: ‘job’
[10:33:37.631]   - Field: ‘conditions’
[10:33:37.631]   - Field: ‘expr’
[10:33:37.631]   - Field: ‘uuid’
[10:33:37.631]   - Field: ‘seed’
[10:33:37.631]   - Field: ‘version’
[10:33:37.631]   - Field: ‘result’
[10:33:37.631]   - Field: ‘asynchronous’
[10:33:37.631]   - Field: ‘calls’
[10:33:37.631]   - Field: ‘globals’
[10:33:37.632]   - Field: ‘stdout’
[10:33:37.632]   - Field: ‘earlySignal’
[10:33:37.632]   - Field: ‘lazy’
[10:33:37.632]   - Field: ‘state’
[10:33:37.632] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:37.632] - Launch lazy future ...
[10:33:37.632] Packages needed by the future expression (n = 1): ‘future’
[10:33:37.633] Packages needed by future strategies (n = 1): ‘future’
[10:33:37.633] {
[10:33:37.633]     {
[10:33:37.633]         {
[10:33:37.633]             ...future.startTime <- base::Sys.time()
[10:33:37.633]             {
[10:33:37.633]                 {
[10:33:37.633]                   {
[10:33:37.633]                     {
[10:33:37.633]                       {
[10:33:37.633]                         base::local({
[10:33:37.633]                           has_future <- base::requireNamespace("future", 
[10:33:37.633]                             quietly = TRUE)
[10:33:37.633]                           if (has_future) {
[10:33:37.633]                             ns <- base::getNamespace("future")
[10:33:37.633]                             version <- ns[[".package"]][["version"]]
[10:33:37.633]                             if (is.null(version)) 
[10:33:37.633]                               version <- utils::packageVersion("future")
[10:33:37.633]                           }
[10:33:37.633]                           else {
[10:33:37.633]                             version <- NULL
[10:33:37.633]                           }
[10:33:37.633]                           if (!has_future || version < "1.8.0") {
[10:33:37.633]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:37.633]                               "", base::R.version$version.string), 
[10:33:37.633]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:37.633]                                 base::R.version$platform, 8 * 
[10:33:37.633]                                   base::.Machine$sizeof.pointer), 
[10:33:37.633]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:37.633]                                 "release", "version")], collapse = " "), 
[10:33:37.633]                               hostname = base::Sys.info()[["nodename"]])
[10:33:37.633]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:37.633]                               info)
[10:33:37.633]                             info <- base::paste(info, collapse = "; ")
[10:33:37.633]                             if (!has_future) {
[10:33:37.633]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:37.633]                                 info)
[10:33:37.633]                             }
[10:33:37.633]                             else {
[10:33:37.633]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:37.633]                                 info, version)
[10:33:37.633]                             }
[10:33:37.633]                             base::stop(msg)
[10:33:37.633]                           }
[10:33:37.633]                         })
[10:33:37.633]                       }
[10:33:37.633]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:37.633]                       base::options(mc.cores = 1L)
[10:33:37.633]                     }
[10:33:37.633]                     base::local({
[10:33:37.633]                       for (pkg in "future") {
[10:33:37.633]                         base::loadNamespace(pkg)
[10:33:37.633]                         base::library(pkg, character.only = TRUE)
[10:33:37.633]                       }
[10:33:37.633]                     })
[10:33:37.633]                   }
[10:33:37.633]                   ...future.strategy.old <- future::plan("list")
[10:33:37.633]                   options(future.plan = NULL)
[10:33:37.633]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.633]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:33:37.633]                     envir = parent.frame()) 
[10:33:37.633]                   {
[10:33:37.633]                     default_workers <- missing(workers)
[10:33:37.633]                     if (is.function(workers)) 
[10:33:37.633]                       workers <- workers()
[10:33:37.633]                     workers <- structure(as.integer(workers), 
[10:33:37.633]                       class = class(workers))
[10:33:37.633]                     stop_if_not(is.finite(workers), workers >= 
[10:33:37.633]                       1L)
[10:33:37.633]                     if ((workers == 1L && !inherits(workers, 
[10:33:37.633]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:33:37.633]                       if (default_workers) 
[10:33:37.633]                         supportsMulticore(warn = TRUE)
[10:33:37.633]                       return(sequential(..., envir = envir))
[10:33:37.633]                     }
[10:33:37.633]                     oopts <- options(mc.cores = workers)
[10:33:37.633]                     on.exit(options(oopts))
[10:33:37.633]                     future <- MulticoreFuture(..., workers = workers, 
[10:33:37.633]                       envir = envir)
[10:33:37.633]                     if (!future$lazy) 
[10:33:37.633]                       future <- run(future)
[10:33:37.633]                     invisible(future)
[10:33:37.633]                   }), .cleanup = FALSE, .init = FALSE)
[10:33:37.633]                 }
[10:33:37.633]                 ...future.workdir <- getwd()
[10:33:37.633]             }
[10:33:37.633]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:37.633]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:37.633]         }
[10:33:37.633]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:37.633]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:37.633]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:37.633]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:37.633]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:37.633]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:37.633]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:37.633]             base::names(...future.oldOptions))
[10:33:37.633]     }
[10:33:37.633]     if (FALSE) {
[10:33:37.633]     }
[10:33:37.633]     else {
[10:33:37.633]         if (TRUE) {
[10:33:37.633]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:37.633]                 open = "w")
[10:33:37.633]         }
[10:33:37.633]         else {
[10:33:37.633]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:37.633]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:37.633]         }
[10:33:37.633]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:37.633]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:37.633]             base::sink(type = "output", split = FALSE)
[10:33:37.633]             base::close(...future.stdout)
[10:33:37.633]         }, add = TRUE)
[10:33:37.633]     }
[10:33:37.633]     ...future.frame <- base::sys.nframe()
[10:33:37.633]     ...future.conditions <- base::list()
[10:33:37.633]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:37.633]     if (FALSE) {
[10:33:37.633]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:37.633]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:37.633]     }
[10:33:37.633]     ...future.result <- base::tryCatch({
[10:33:37.633]         base::withCallingHandlers({
[10:33:37.633]             ...future.value <- base::withVisible(base::local({
[10:33:37.633]                 withCallingHandlers({
[10:33:37.633]                   {
[10:33:37.633]                     a <- 1L
[10:33:37.633]                     plan_a <- unclass(future::plan("list"))
[10:33:37.633]                     nested_a <- nested[-1]
[10:33:37.633]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:33:37.633]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:33:37.633]                       strategy2))
[10:33:37.633]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:33:37.633]                       "init") <- NULL
[10:33:37.633]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:33:37.633]                       "init") <- NULL
[10:33:37.633]                     stopifnot(all.equal(plan_a, nested_a))
[10:33:37.633]                     y %<-% {
[10:33:37.633]                       b <- 2L
[10:33:37.633]                       plan_b <- future::plan("list")
[10:33:37.633]                       nested_b <- nested_a[-1]
[10:33:37.633]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:33:37.633]                         1L, inherits(plan_b[[1]], "future"), 
[10:33:37.633]                         inherits(future::plan("next"), "sequential"))
[10:33:37.633]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:33:37.633]                         b = b, nested_b = nested_b, plan_b = plan_b)
[10:33:37.633]                     }
[10:33:37.633]                     y
[10:33:37.633]                   }
[10:33:37.633]                 }, immediateCondition = function(cond) {
[10:33:37.633]                   save_rds <- function (object, pathname, ...) 
[10:33:37.633]                   {
[10:33:37.633]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:37.633]                     if (file_test("-f", pathname_tmp)) {
[10:33:37.633]                       fi_tmp <- file.info(pathname_tmp)
[10:33:37.633]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:37.633]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:37.633]                         fi_tmp[["mtime"]])
[10:33:37.633]                     }
[10:33:37.633]                     tryCatch({
[10:33:37.633]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:37.633]                     }, error = function(ex) {
[10:33:37.633]                       msg <- conditionMessage(ex)
[10:33:37.633]                       fi_tmp <- file.info(pathname_tmp)
[10:33:37.633]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:37.633]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:37.633]                         fi_tmp[["mtime"]], msg)
[10:33:37.633]                       ex$message <- msg
[10:33:37.633]                       stop(ex)
[10:33:37.633]                     })
[10:33:37.633]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:37.633]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:37.633]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:37.633]                       fi_tmp <- file.info(pathname_tmp)
[10:33:37.633]                       fi <- file.info(pathname)
[10:33:37.633]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:37.633]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:37.633]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:37.633]                         fi[["size"]], fi[["mtime"]])
[10:33:37.633]                       stop(msg)
[10:33:37.633]                     }
[10:33:37.633]                     invisible(pathname)
[10:33:37.633]                   }
[10:33:37.633]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:37.633]                     rootPath = tempdir()) 
[10:33:37.633]                   {
[10:33:37.633]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:37.633]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:37.633]                       tmpdir = path, fileext = ".rds")
[10:33:37.633]                     save_rds(obj, file)
[10:33:37.633]                   }
[10:33:37.633]                   saveImmediateCondition(cond, path = "/tmp/RtmpTlTEh1/.future/immediateConditions")
[10:33:37.633]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.633]                   {
[10:33:37.633]                     inherits <- base::inherits
[10:33:37.633]                     invokeRestart <- base::invokeRestart
[10:33:37.633]                     is.null <- base::is.null
[10:33:37.633]                     muffled <- FALSE
[10:33:37.633]                     if (inherits(cond, "message")) {
[10:33:37.633]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:37.633]                       if (muffled) 
[10:33:37.633]                         invokeRestart("muffleMessage")
[10:33:37.633]                     }
[10:33:37.633]                     else if (inherits(cond, "warning")) {
[10:33:37.633]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:37.633]                       if (muffled) 
[10:33:37.633]                         invokeRestart("muffleWarning")
[10:33:37.633]                     }
[10:33:37.633]                     else if (inherits(cond, "condition")) {
[10:33:37.633]                       if (!is.null(pattern)) {
[10:33:37.633]                         computeRestarts <- base::computeRestarts
[10:33:37.633]                         grepl <- base::grepl
[10:33:37.633]                         restarts <- computeRestarts(cond)
[10:33:37.633]                         for (restart in restarts) {
[10:33:37.633]                           name <- restart$name
[10:33:37.633]                           if (is.null(name)) 
[10:33:37.633]                             next
[10:33:37.633]                           if (!grepl(pattern, name)) 
[10:33:37.633]                             next
[10:33:37.633]                           invokeRestart(restart)
[10:33:37.633]                           muffled <- TRUE
[10:33:37.633]                           break
[10:33:37.633]                         }
[10:33:37.633]                       }
[10:33:37.633]                     }
[10:33:37.633]                     invisible(muffled)
[10:33:37.633]                   }
[10:33:37.633]                   muffleCondition(cond)
[10:33:37.633]                 })
[10:33:37.633]             }))
[10:33:37.633]             future::FutureResult(value = ...future.value$value, 
[10:33:37.633]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.633]                   ...future.rng), globalenv = if (FALSE) 
[10:33:37.633]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:37.633]                     ...future.globalenv.names))
[10:33:37.633]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:37.633]         }, condition = base::local({
[10:33:37.633]             c <- base::c
[10:33:37.633]             inherits <- base::inherits
[10:33:37.633]             invokeRestart <- base::invokeRestart
[10:33:37.633]             length <- base::length
[10:33:37.633]             list <- base::list
[10:33:37.633]             seq.int <- base::seq.int
[10:33:37.633]             signalCondition <- base::signalCondition
[10:33:37.633]             sys.calls <- base::sys.calls
[10:33:37.633]             `[[` <- base::`[[`
[10:33:37.633]             `+` <- base::`+`
[10:33:37.633]             `<<-` <- base::`<<-`
[10:33:37.633]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:37.633]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:37.633]                   3L)]
[10:33:37.633]             }
[10:33:37.633]             function(cond) {
[10:33:37.633]                 is_error <- inherits(cond, "error")
[10:33:37.633]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:37.633]                   NULL)
[10:33:37.633]                 if (is_error) {
[10:33:37.633]                   sessionInformation <- function() {
[10:33:37.633]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:37.633]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:37.633]                       search = base::search(), system = base::Sys.info())
[10:33:37.633]                   }
[10:33:37.633]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.633]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:37.633]                     cond$call), session = sessionInformation(), 
[10:33:37.633]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:37.633]                   signalCondition(cond)
[10:33:37.633]                 }
[10:33:37.633]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:37.633]                 "immediateCondition"))) {
[10:33:37.633]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:37.633]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.633]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:37.633]                   if (TRUE && !signal) {
[10:33:37.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.633]                     {
[10:33:37.633]                       inherits <- base::inherits
[10:33:37.633]                       invokeRestart <- base::invokeRestart
[10:33:37.633]                       is.null <- base::is.null
[10:33:37.633]                       muffled <- FALSE
[10:33:37.633]                       if (inherits(cond, "message")) {
[10:33:37.633]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.633]                         if (muffled) 
[10:33:37.633]                           invokeRestart("muffleMessage")
[10:33:37.633]                       }
[10:33:37.633]                       else if (inherits(cond, "warning")) {
[10:33:37.633]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.633]                         if (muffled) 
[10:33:37.633]                           invokeRestart("muffleWarning")
[10:33:37.633]                       }
[10:33:37.633]                       else if (inherits(cond, "condition")) {
[10:33:37.633]                         if (!is.null(pattern)) {
[10:33:37.633]                           computeRestarts <- base::computeRestarts
[10:33:37.633]                           grepl <- base::grepl
[10:33:37.633]                           restarts <- computeRestarts(cond)
[10:33:37.633]                           for (restart in restarts) {
[10:33:37.633]                             name <- restart$name
[10:33:37.633]                             if (is.null(name)) 
[10:33:37.633]                               next
[10:33:37.633]                             if (!grepl(pattern, name)) 
[10:33:37.633]                               next
[10:33:37.633]                             invokeRestart(restart)
[10:33:37.633]                             muffled <- TRUE
[10:33:37.633]                             break
[10:33:37.633]                           }
[10:33:37.633]                         }
[10:33:37.633]                       }
[10:33:37.633]                       invisible(muffled)
[10:33:37.633]                     }
[10:33:37.633]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.633]                   }
[10:33:37.633]                 }
[10:33:37.633]                 else {
[10:33:37.633]                   if (TRUE) {
[10:33:37.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.633]                     {
[10:33:37.633]                       inherits <- base::inherits
[10:33:37.633]                       invokeRestart <- base::invokeRestart
[10:33:37.633]                       is.null <- base::is.null
[10:33:37.633]                       muffled <- FALSE
[10:33:37.633]                       if (inherits(cond, "message")) {
[10:33:37.633]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.633]                         if (muffled) 
[10:33:37.633]                           invokeRestart("muffleMessage")
[10:33:37.633]                       }
[10:33:37.633]                       else if (inherits(cond, "warning")) {
[10:33:37.633]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.633]                         if (muffled) 
[10:33:37.633]                           invokeRestart("muffleWarning")
[10:33:37.633]                       }
[10:33:37.633]                       else if (inherits(cond, "condition")) {
[10:33:37.633]                         if (!is.null(pattern)) {
[10:33:37.633]                           computeRestarts <- base::computeRestarts
[10:33:37.633]                           grepl <- base::grepl
[10:33:37.633]                           restarts <- computeRestarts(cond)
[10:33:37.633]                           for (restart in restarts) {
[10:33:37.633]                             name <- restart$name
[10:33:37.633]                             if (is.null(name)) 
[10:33:37.633]                               next
[10:33:37.633]                             if (!grepl(pattern, name)) 
[10:33:37.633]                               next
[10:33:37.633]                             invokeRestart(restart)
[10:33:37.633]                             muffled <- TRUE
[10:33:37.633]                             break
[10:33:37.633]                           }
[10:33:37.633]                         }
[10:33:37.633]                       }
[10:33:37.633]                       invisible(muffled)
[10:33:37.633]                     }
[10:33:37.633]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.633]                   }
[10:33:37.633]                 }
[10:33:37.633]             }
[10:33:37.633]         }))
[10:33:37.633]     }, error = function(ex) {
[10:33:37.633]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:37.633]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.633]                 ...future.rng), started = ...future.startTime, 
[10:33:37.633]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:37.633]             version = "1.8"), class = "FutureResult")
[10:33:37.633]     }, finally = {
[10:33:37.633]         if (!identical(...future.workdir, getwd())) 
[10:33:37.633]             setwd(...future.workdir)
[10:33:37.633]         {
[10:33:37.633]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:37.633]                 ...future.oldOptions$nwarnings <- NULL
[10:33:37.633]             }
[10:33:37.633]             base::options(...future.oldOptions)
[10:33:37.633]             if (.Platform$OS.type == "windows") {
[10:33:37.633]                 old_names <- names(...future.oldEnvVars)
[10:33:37.633]                 envs <- base::Sys.getenv()
[10:33:37.633]                 names <- names(envs)
[10:33:37.633]                 common <- intersect(names, old_names)
[10:33:37.633]                 added <- setdiff(names, old_names)
[10:33:37.633]                 removed <- setdiff(old_names, names)
[10:33:37.633]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:37.633]                   envs[common]]
[10:33:37.633]                 NAMES <- toupper(changed)
[10:33:37.633]                 args <- list()
[10:33:37.633]                 for (kk in seq_along(NAMES)) {
[10:33:37.633]                   name <- changed[[kk]]
[10:33:37.633]                   NAME <- NAMES[[kk]]
[10:33:37.633]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.633]                     next
[10:33:37.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.633]                 }
[10:33:37.633]                 NAMES <- toupper(added)
[10:33:37.633]                 for (kk in seq_along(NAMES)) {
[10:33:37.633]                   name <- added[[kk]]
[10:33:37.633]                   NAME <- NAMES[[kk]]
[10:33:37.633]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.633]                     next
[10:33:37.633]                   args[[name]] <- ""
[10:33:37.633]                 }
[10:33:37.633]                 NAMES <- toupper(removed)
[10:33:37.633]                 for (kk in seq_along(NAMES)) {
[10:33:37.633]                   name <- removed[[kk]]
[10:33:37.633]                   NAME <- NAMES[[kk]]
[10:33:37.633]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.633]                     next
[10:33:37.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.633]                 }
[10:33:37.633]                 if (length(args) > 0) 
[10:33:37.633]                   base::do.call(base::Sys.setenv, args = args)
[10:33:37.633]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:37.633]             }
[10:33:37.633]             else {
[10:33:37.633]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:37.633]             }
[10:33:37.633]             {
[10:33:37.633]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:37.633]                   0L) {
[10:33:37.633]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:37.633]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:37.633]                   base::options(opts)
[10:33:37.633]                 }
[10:33:37.633]                 {
[10:33:37.633]                   {
[10:33:37.633]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:37.633]                     NULL
[10:33:37.633]                   }
[10:33:37.633]                   options(future.plan = NULL)
[10:33:37.633]                   if (is.na(NA_character_)) 
[10:33:37.633]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.633]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:37.633]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:37.633]                     .init = FALSE)
[10:33:37.633]                 }
[10:33:37.633]             }
[10:33:37.633]         }
[10:33:37.633]     })
[10:33:37.633]     if (TRUE) {
[10:33:37.633]         base::sink(type = "output", split = FALSE)
[10:33:37.633]         if (TRUE) {
[10:33:37.633]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:37.633]         }
[10:33:37.633]         else {
[10:33:37.633]             ...future.result["stdout"] <- base::list(NULL)
[10:33:37.633]         }
[10:33:37.633]         base::close(...future.stdout)
[10:33:37.633]         ...future.stdout <- NULL
[10:33:37.633]     }
[10:33:37.633]     ...future.result$conditions <- ...future.conditions
[10:33:37.633]     ...future.result$finished <- base::Sys.time()
[10:33:37.633]     ...future.result
[10:33:37.633] }
[10:33:37.636] assign_globals() ...
[10:33:37.636] List of 2
[10:33:37.636]  $ nested   :List of 2
[10:33:37.636]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:33:37.636]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:33:37.636]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:33:37.636]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:33:37.636]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:33:37.636]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:33:37.636]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:33:37.636]  $ strategy2: chr "multicore"
[10:33:37.636]  - attr(*, "where")=List of 2
[10:33:37.636]   ..$ nested   :<environment: R_EmptyEnv> 
[10:33:37.636]   ..$ strategy2:<environment: R_EmptyEnv> 
[10:33:37.636]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:37.636]  - attr(*, "resolved")= logi FALSE
[10:33:37.636]  - attr(*, "total_size")= num 95304
[10:33:37.636]  - attr(*, "already-done")= logi TRUE
[10:33:37.642] - copied ‘nested’ to environment
[10:33:37.642] - copied ‘strategy2’ to environment
[10:33:37.642] assign_globals() ... done
[10:33:37.642] requestCore(): workers = 2
[10:33:37.645] MulticoreFuture started
[10:33:37.645] - Launch lazy future ... done
[10:33:37.645] run() for ‘MulticoreFuture’ ... done
[10:33:37.646] result() for MulticoreFuture ...
[10:33:37.646] plan(): Setting new future strategy stack:
[10:33:37.647] List of future strategies:
[10:33:37.647] 1. multicore:
[10:33:37.647]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:37.647]    - tweaked: FALSE
[10:33:37.647]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.653] plan(): nbrOfWorkers() = 1
[10:33:37.693] plan(): Setting new future strategy stack:
[10:33:37.693] List of future strategies:
[10:33:37.693] 1. multicore:
[10:33:37.693]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:37.693]    - tweaked: FALSE
[10:33:37.693]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.693] 2. multicore:
[10:33:37.693]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:37.693]    - tweaked: FALSE
[10:33:37.693]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.697] plan(): nbrOfWorkers() = 2
[10:33:37.699] result() for MulticoreFuture ...
[10:33:37.699] result() for MulticoreFuture ... done
[10:33:37.699] signalConditions() ...
[10:33:37.699]  - include = ‘immediateCondition’
[10:33:37.700]  - exclude = 
[10:33:37.700]  - resignal = FALSE
[10:33:37.700]  - Number of conditions: 54
[10:33:37.700] signalConditions() ... done
[10:33:37.700] result() for MulticoreFuture ... done
[10:33:37.700] result() for MulticoreFuture ...
[10:33:37.700] result() for MulticoreFuture ... done
[10:33:37.701] signalConditions() ...
[10:33:37.701]  - include = ‘immediateCondition’
[10:33:37.701]  - exclude = 
[10:33:37.701]  - resignal = FALSE
[10:33:37.701]  - Number of conditions: 54
[10:33:37.701] signalConditions() ... done
[10:33:37.701] Future state: ‘finished’
[10:33:37.702] result() for MulticoreFuture ...
[10:33:37.702] result() for MulticoreFuture ... done
[10:33:37.702] signalConditions() ...
[10:33:37.702]  - include = ‘condition’
[10:33:37.702]  - exclude = ‘immediateCondition’
[10:33:37.702]  - resignal = TRUE
[10:33:37.702]  - Number of conditions: 54
[10:33:37.702]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.655] getGlobalsAndPackages() ...
[10:33:37.702]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.655] Searching for globals...
[10:33:37.703]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.663] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[10:33:37.703]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.663] Searching for globals ... DONE
[10:33:37.703]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.663] Resolving globals: FALSE
[10:33:37.703]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.664] The total size of the 3 globals is 93.01 KiB (95240 bytes)
[10:33:37.703]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.665] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 93.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (46.48 KiB of class ‘list’), ‘plan_a’ (46.48 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[10:33:37.703]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.665] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[10:33:37.704]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.665] 
[10:33:37.704]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.666] getGlobalsAndPackages() ... DONE
[10:33:37.704]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.666] run() for ‘Future’ ...
[10:33:37.704]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.666] - state: ‘created’
[10:33:37.704]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.667] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:37.704]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.671] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:37.705]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.671] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:37.705]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.671]   - Field: ‘label’
[10:33:37.705]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.671]   - Field: ‘local’
[10:33:37.705]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.672]   - Field: ‘owner’
[10:33:37.705]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.672]   - Field: ‘envir’
[10:33:37.705]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.672]   - Field: ‘packages’
[10:33:37.706]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.672]   - Field: ‘gc’
[10:33:37.706]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.672]   - Field: ‘conditions’
[10:33:37.706]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.672]   - Field: ‘expr’
[10:33:37.706]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.672]   - Field: ‘uuid’
[10:33:37.706]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.673]   - Field: ‘seed’
[10:33:37.706]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.673]   - Field: ‘version’
[10:33:37.706]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.673]   - Field: ‘result’
[10:33:37.707]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.673]   - Field: ‘asynchronous’
[10:33:37.707]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.673]   - Field: ‘calls’
[10:33:37.707]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.673]   - Field: ‘globals’
[10:33:37.707]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.674]   - Field: ‘stdout’
[10:33:37.707]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.674]   - Field: ‘earlySignal’
[10:33:37.707]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.674]   - Field: ‘lazy’
[10:33:37.708]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.674]   - Field: ‘state’
[10:33:37.708]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.674] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:37.708]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.674] - Launch lazy future ...
[10:33:37.708]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.675] Packages needed by the future expression (n = 0): <none>
[10:33:37.708]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.675] Packages needed by future strategies (n = 0): <none>
[10:33:37.708]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.676] {
[10:33:37.676]     {
[10:33:37.676]         {
[10:33:37.676]             ...future.startTime <- base::Sys.time()
[10:33:37.676]             {
[10:33:37.676]                 {
[10:33:37.676]                   {
[10:33:37.676]                     base::local({
[10:33:37.676]                       has_future <- base::requireNamespace("future", 
[10:33:37.676]                         quietly = TRUE)
[10:33:37.676]                       if (has_future) {
[10:33:37.676]                         ns <- base::getNamespace("future")
[10:33:37.676]                         version <- ns[[".package"]][["version"]]
[10:33:37.676]                         if (is.null(version)) 
[10:33:37.676]                           version <- utils::packageVersion("future")
[10:33:37.676]                       }
[10:33:37.676]                       else {
[10:33:37.676]                         version <- NULL
[10:33:37.676]                       }
[10:33:37.676]                       if (!has_future || version < "1.8.0") {
[10:33:37.676]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:37.676]                           "", base::R.version$version.string), 
[10:33:37.676]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:37.676]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:37.676]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:37.676]                             "release", "version")], collapse = " "), 
[10:33:37.676]                           hostname = base::Sys.info()[["nodename"]])
[10:33:37.676]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:37.676]                           info)
[10:33:37.676]                         info <- base::paste(info, collapse = "; ")
[10:33:37.676]                         if (!has_future) {
[10:33:37.676]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:37.676]                             info)
[10:33:37.676]                         }
[10:33:37.676]                         else {
[10:33:37.676]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:37.676]                             info, version)
[10:33:37.676]                         }
[10:33:37.676]                         base::stop(msg)
[10:33:37.676]                       }
[10:33:37.676]                     })
[10:33:37.676]                   }
[10:33:37.676]                   ...future.strategy.old <- future::plan("list")
[10:33:37.676]                   options(future.plan = NULL)
[10:33:37.676]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.676]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:37.676]                 }
[10:33:37.676]                 ...future.workdir <- getwd()
[10:33:37.676]             }
[10:33:37.676]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:37.676]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:37.676]         }
[10:33:37.676]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:37.676]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:37.676]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:37.676]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:37.676]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:37.676]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:37.676]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:37.676]             base::names(...future.oldOptions))
[10:33:37.676]     }
[10:33:37.676]     if (FALSE) {
[10:33:37.676]     }
[10:33:37.676]     else {
[10:33:37.676]         if (TRUE) {
[10:33:37.676]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:37.676]                 open = "w")
[10:33:37.676]         }
[10:33:37.676]         else {
[10:33:37.676]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:37.676]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:37.676]         }
[10:33:37.676]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:37.676]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:37.676]             base::sink(type = "output", split = FALSE)
[10:33:37.676]             base::close(...future.stdout)
[10:33:37.676]         }, add = TRUE)
[10:33:37.676]     }
[10:33:37.676]     ...future.frame <- base::sys.nframe()
[10:33:37.676]     ...future.conditions <- base::list()
[10:33:37.676]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:37.676]     if (FALSE) {
[10:33:37.676]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:37.676]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:37.676]     }
[10:33:37.676]     ...future.result <- base::tryCatch({
[10:33:37.676]         base::withCallingHandlers({
[10:33:37.676]             ...future.value <- base::withVisible(base::local({
[10:33:37.676]                 b <- 2L
[10:33:37.676]                 plan_b <- future::plan("list")
[10:33:37.676]                 nested_b <- nested_a[-1]
[10:33:37.676]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:33:37.676]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:33:37.676]                   "sequential"))
[10:33:37.676]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:33:37.676]                   b = b, nested_b = nested_b, plan_b = plan_b)
[10:33:37.676]             }))
[10:33:37.676]             future::FutureResult(value = ...future.value$value, 
[10:33:37.676]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.676]                   ...future.rng), globalenv = if (FALSE) 
[10:33:37.676]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:37.676]                     ...future.globalenv.names))
[10:33:37.676]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:37.676]         }, condition = base::local({
[10:33:37.676]             c <- base::c
[10:33:37.676]             inherits <- base::inherits
[10:33:37.676]             invokeRestart <- base::invokeRestart
[10:33:37.676]             length <- base::length
[10:33:37.676]             list <- base::list
[10:33:37.676]             seq.int <- base::seq.int
[10:33:37.676]             signalCondition <- base::signalCondition
[10:33:37.676]             sys.calls <- base::sys.calls
[10:33:37.676]             `[[` <- base::`[[`
[10:33:37.676]             `+` <- base::`+`
[10:33:37.676]             `<<-` <- base::`<<-`
[10:33:37.676]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:37.676]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:37.676]                   3L)]
[10:33:37.676]             }
[10:33:37.676]             function(cond) {
[10:33:37.676]                 is_error <- inherits(cond, "error")
[10:33:37.676]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:37.676]                   NULL)
[10:33:37.676]                 if (is_error) {
[10:33:37.676]                   sessionInformation <- function() {
[10:33:37.676]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:37.676]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:37.676]                       search = base::search(), system = base::Sys.info())
[10:33:37.676]                   }
[10:33:37.676]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.676]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:37.676]                     cond$call), session = sessionInformation(), 
[10:33:37.676]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:37.676]                   signalCondition(cond)
[10:33:37.676]                 }
[10:33:37.676]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:37.676]                 "immediateCondition"))) {
[10:33:37.676]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:37.676]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.676]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:37.676]                   if (TRUE && !signal) {
[10:33:37.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.676]                     {
[10:33:37.676]                       inherits <- base::inherits
[10:33:37.676]                       invokeRestart <- base::invokeRestart
[10:33:37.676]                       is.null <- base::is.null
[10:33:37.676]                       muffled <- FALSE
[10:33:37.676]                       if (inherits(cond, "message")) {
[10:33:37.676]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.676]                         if (muffled) 
[10:33:37.676]                           invokeRestart("muffleMessage")
[10:33:37.676]                       }
[10:33:37.676]                       else if (inherits(cond, "warning")) {
[10:33:37.676]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.676]                         if (muffled) 
[10:33:37.676]                           invokeRestart("muffleWarning")
[10:33:37.676]                       }
[10:33:37.676]                       else if (inherits(cond, "condition")) {
[10:33:37.676]                         if (!is.null(pattern)) {
[10:33:37.676]                           computeRestarts <- base::computeRestarts
[10:33:37.676]                           grepl <- base::grepl
[10:33:37.676]                           restarts <- computeRestarts(cond)
[10:33:37.676]                           for (restart in restarts) {
[10:33:37.676]                             name <- restart$name
[10:33:37.676]                             if (is.null(name)) 
[10:33:37.676]                               next
[10:33:37.676]                             if (!grepl(pattern, name)) 
[10:33:37.676]                               next
[10:33:37.676]                             invokeRestart(restart)
[10:33:37.676]                             muffled <- TRUE
[10:33:37.676]                             break
[10:33:37.676]                           }
[10:33:37.676]                         }
[10:33:37.676]                       }
[10:33:37.676]                       invisible(muffled)
[10:33:37.676]                     }
[10:33:37.676]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.676]                   }
[10:33:37.676]                 }
[10:33:37.676]                 else {
[10:33:37.676]                   if (TRUE) {
[10:33:37.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.676]                     {
[10:33:37.676]                       inherits <- base::inherits
[10:33:37.676]                       invokeRestart <- base::invokeRestart
[10:33:37.676]                       is.null <- base::is.null
[10:33:37.676]                       muffled <- FALSE
[10:33:37.676]                       if (inherits(cond, "message")) {
[10:33:37.676]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.676]                         if (muffled) 
[10:33:37.676]                           invokeRestart("muffleMessage")
[10:33:37.676]                       }
[10:33:37.676]                       else if (inherits(cond, "warning")) {
[10:33:37.676]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.676]                         if (muffled) 
[10:33:37.676]                           invokeRestart("muffleWarning")
[10:33:37.676]                       }
[10:33:37.676]                       else if (inherits(cond, "condition")) {
[10:33:37.676]                         if (!is.null(pattern)) {
[10:33:37.676]                           computeRestarts <- base::computeRestarts
[10:33:37.676]                           grepl <- base::grepl
[10:33:37.676]                           restarts <- computeRestarts(cond)
[10:33:37.676]                           for (restart in restarts) {
[10:33:37.676]                             name <- restart$name
[10:33:37.676]                             if (is.null(name)) 
[10:33:37.676]                               next
[10:33:37.676]                             if (!grepl(pattern, name)) 
[10:33:37.676]                               next
[10:33:37.676]                             invokeRestart(restart)
[10:33:37.676]                             muffled <- TRUE
[10:33:37.676]                             break
[10:33:37.676]                           }
[10:33:37.676]                         }
[10:33:37.676]                       }
[10:33:37.676]                       invisible(muffled)
[10:33:37.676]                     }
[10:33:37.676]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.676]                   }
[10:33:37.676]                 }
[10:33:37.676]             }
[10:33:37.676]         }))
[10:33:37.676]     }, error = function(ex) {
[10:33:37.676]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:37.676]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.676]                 ...future.rng), started = ...future.startTime, 
[10:33:37.676]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:37.676]             version = "1.8"), class = "FutureResult")
[10:33:37.676]     }, finally = {
[10:33:37.676]         if (!identical(...future.workdir, getwd())) 
[10:33:37.676]             setwd(...future.workdir)
[10:33:37.676]         {
[10:33:37.676]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:37.676]                 ...future.oldOptions$nwarnings <- NULL
[10:33:37.676]             }
[10:33:37.676]             base::options(...future.oldOptions)
[10:33:37.676]             if (.Platform$OS.type == "windows") {
[10:33:37.676]                 old_names <- names(...future.oldEnvVars)
[10:33:37.676]                 envs <- base::Sys.getenv()
[10:33:37.676]                 names <- names(envs)
[10:33:37.676]                 common <- intersect(names, old_names)
[10:33:37.676]                 added <- setdiff(names, old_names)
[10:33:37.676]                 removed <- setdiff(old_names, names)
[10:33:37.676]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:37.676]                   envs[common]]
[10:33:37.676]                 NAMES <- toupper(changed)
[10:33:37.676]                 args <- list()
[10:33:37.676]                 for (kk in seq_along(NAMES)) {
[10:33:37.676]                   name <- changed[[kk]]
[10:33:37.676]                   NAME <- NAMES[[kk]]
[10:33:37.676]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.676]                     next
[10:33:37.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.676]                 }
[10:33:37.676]                 NAMES <- toupper(added)
[10:33:37.676]                 for (kk in seq_along(NAMES)) {
[10:33:37.676]                   name <- added[[kk]]
[10:33:37.676]                   NAME <- NAMES[[kk]]
[10:33:37.676]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.676]                     next
[10:33:37.676]                   args[[name]] <- ""
[10:33:37.676]                 }
[10:33:37.676]                 NAMES <- toupper(removed)
[10:33:37.676]                 for (kk in seq_along(NAMES)) {
[10:33:37.676]                   name <- removed[[kk]]
[10:33:37.676]                   NAME <- NAMES[[kk]]
[10:33:37.676]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.676]                     next
[10:33:37.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.676]                 }
[10:33:37.676]                 if (length(args) > 0) 
[10:33:37.676]                   base::do.call(base::Sys.setenv, args = args)
[10:33:37.676]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:37.676]             }
[10:33:37.676]             else {
[10:33:37.676]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:37.676]             }
[10:33:37.676]             {
[10:33:37.676]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:37.676]                   0L) {
[10:33:37.676]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:37.676]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:37.676]                   base::options(opts)
[10:33:37.676]                 }
[10:33:37.676]                 {
[10:33:37.676]                   {
[10:33:37.676]                     NULL
[10:33:37.676]                     RNGkind("Mersenne-Twister")
[10:33:37.676]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:37.676]                       inherits = FALSE)
[10:33:37.676]                   }
[10:33:37.676]                   options(future.plan = NULL)
[10:33:37.676]                   if (is.na(NA_character_)) 
[10:33:37.676]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.676]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:37.676]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:37.676]                     .init = FALSE)
[10:33:37.676]                 }
[10:33:37.676]             }
[10:33:37.676]         }
[10:33:37.676]     })
[10:33:37.676]     if (TRUE) {
[10:33:37.676]         base::sink(type = "output", split = FALSE)
[10:33:37.676]         if (TRUE) {
[10:33:37.676]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:37.676]         }
[10:33:37.676]         else {
[10:33:37.676]             ...future.result["stdout"] <- base::list(NULL)
[10:33:37.676]         }
[10:33:37.676]         base::close(...future.stdout)
[10:33:37.676]         ...future.stdout <- NULL
[10:33:37.676]     }
[10:33:37.676]     ...future.result$conditions <- ...future.conditions
[10:33:37.676]     ...future.result$finished <- base::Sys.time()
[10:33:37.676]     ...future.result
[10:33:37.676] }
[10:33:37.709]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.678] assign_globals() ...
[10:33:37.709]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.678] List of 3
[10:33:37.678]  $ nested_a:List of 1
[10:33:37.678]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:33:37.678]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:33:37.678]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:33:37.678]  $ a       : int 1
[10:33:37.678]  $ plan_a  :List of 1
[10:33:37.678]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:33:37.678]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:33:37.678]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:33:37.678]  - attr(*, "where")=List of 3
[10:33:37.678]   ..$ nested_a:<environment: R_EmptyEnv> 
[10:33:37.678]   ..$ a       :<environment: R_EmptyEnv> 
[10:33:37.678]   ..$ plan_a  :<environment: R_EmptyEnv> 
[10:33:37.678]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:37.678]  - attr(*, "resolved")= logi FALSE
[10:33:37.678]  - attr(*, "total_size")= num 95240
[10:33:37.678]  - attr(*, "already-done")= logi TRUE
[10:33:37.709]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.685] - copied ‘nested_a’ to environment
[10:33:37.709]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.686] - copied ‘a’ to environment
[10:33:37.709]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.686] - copied ‘plan_a’ to environment
[10:33:37.709]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.686] assign_globals() ... done
[10:33:37.710]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.686] plan(): Setting new future strategy stack:
[10:33:37.710]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.686] List of future strategies:
[10:33:37.686] 1. sequential:
[10:33:37.686]    - args: function (..., envir = parent.frame())
[10:33:37.686]    - tweaked: FALSE
[10:33:37.686]    - call: NULL
[10:33:37.710]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.687] plan(): nbrOfWorkers() = 1
[10:33:37.710]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.688] plan(): Setting new future strategy stack:
[10:33:37.710]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.688] List of future strategies:
[10:33:37.688] 1. multicore:
[10:33:37.688]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:37.688]    - tweaked: FALSE
[10:33:37.688]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.710]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.692] plan(): nbrOfWorkers() = 1
[10:33:37.711]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.692] SequentialFuture started (and completed)
[10:33:37.711]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.692] - Launch lazy future ... done
[10:33:37.711]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.693] run() for ‘SequentialFuture’ ... done
[10:33:37.711] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:33:37.717] getGlobalsAndPackages() ...
[10:33:37.717] Searching for globals...
[10:33:37.719] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:33:37.719] Searching for globals ... DONE
[10:33:37.719] Resolving globals: FALSE
[10:33:37.720] The total size of the 1 globals is 128 bytes (128 bytes)
[10:33:37.721] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:33:37.721] - globals: [1] ‘data’
[10:33:37.721] - packages: [1] ‘future’
[10:33:37.721] getGlobalsAndPackages() ... DONE
[10:33:37.721] run() for ‘Future’ ...
[10:33:37.722] - state: ‘created’
[10:33:37.722] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:37.726] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:37.726] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:37.726]   - Field: ‘label’
[10:33:37.726]   - Field: ‘local’
[10:33:37.727]   - Field: ‘owner’
[10:33:37.727]   - Field: ‘envir’
[10:33:37.727]   - Field: ‘workers’
[10:33:37.727]   - Field: ‘packages’
[10:33:37.727]   - Field: ‘gc’
[10:33:37.727]   - Field: ‘job’
[10:33:37.727]   - Field: ‘conditions’
[10:33:37.727]   - Field: ‘expr’
[10:33:37.727]   - Field: ‘uuid’
[10:33:37.728]   - Field: ‘seed’
[10:33:37.728]   - Field: ‘version’
[10:33:37.728]   - Field: ‘result’
[10:33:37.728]   - Field: ‘asynchronous’
[10:33:37.728]   - Field: ‘calls’
[10:33:37.728]   - Field: ‘globals’
[10:33:37.728]   - Field: ‘stdout’
[10:33:37.728]   - Field: ‘earlySignal’
[10:33:37.728]   - Field: ‘lazy’
[10:33:37.729]   - Field: ‘state’
[10:33:37.729] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:37.729] - Launch lazy future ...
[10:33:37.729] Packages needed by the future expression (n = 1): ‘future’
[10:33:37.729] Packages needed by future strategies (n = 1): ‘future’
[10:33:37.730] {
[10:33:37.730]     {
[10:33:37.730]         {
[10:33:37.730]             ...future.startTime <- base::Sys.time()
[10:33:37.730]             {
[10:33:37.730]                 {
[10:33:37.730]                   {
[10:33:37.730]                     {
[10:33:37.730]                       {
[10:33:37.730]                         base::local({
[10:33:37.730]                           has_future <- base::requireNamespace("future", 
[10:33:37.730]                             quietly = TRUE)
[10:33:37.730]                           if (has_future) {
[10:33:37.730]                             ns <- base::getNamespace("future")
[10:33:37.730]                             version <- ns[[".package"]][["version"]]
[10:33:37.730]                             if (is.null(version)) 
[10:33:37.730]                               version <- utils::packageVersion("future")
[10:33:37.730]                           }
[10:33:37.730]                           else {
[10:33:37.730]                             version <- NULL
[10:33:37.730]                           }
[10:33:37.730]                           if (!has_future || version < "1.8.0") {
[10:33:37.730]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:37.730]                               "", base::R.version$version.string), 
[10:33:37.730]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:37.730]                                 base::R.version$platform, 8 * 
[10:33:37.730]                                   base::.Machine$sizeof.pointer), 
[10:33:37.730]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:37.730]                                 "release", "version")], collapse = " "), 
[10:33:37.730]                               hostname = base::Sys.info()[["nodename"]])
[10:33:37.730]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:37.730]                               info)
[10:33:37.730]                             info <- base::paste(info, collapse = "; ")
[10:33:37.730]                             if (!has_future) {
[10:33:37.730]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:37.730]                                 info)
[10:33:37.730]                             }
[10:33:37.730]                             else {
[10:33:37.730]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:37.730]                                 info, version)
[10:33:37.730]                             }
[10:33:37.730]                             base::stop(msg)
[10:33:37.730]                           }
[10:33:37.730]                         })
[10:33:37.730]                       }
[10:33:37.730]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:37.730]                       base::options(mc.cores = 1L)
[10:33:37.730]                     }
[10:33:37.730]                     base::local({
[10:33:37.730]                       for (pkg in "future") {
[10:33:37.730]                         base::loadNamespace(pkg)
[10:33:37.730]                         base::library(pkg, character.only = TRUE)
[10:33:37.730]                       }
[10:33:37.730]                     })
[10:33:37.730]                   }
[10:33:37.730]                   ...future.strategy.old <- future::plan("list")
[10:33:37.730]                   options(future.plan = NULL)
[10:33:37.730]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.730]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:33:37.730]                     envir = parent.frame()) 
[10:33:37.730]                   {
[10:33:37.730]                     default_workers <- missing(workers)
[10:33:37.730]                     if (is.function(workers)) 
[10:33:37.730]                       workers <- workers()
[10:33:37.730]                     workers <- structure(as.integer(workers), 
[10:33:37.730]                       class = class(workers))
[10:33:37.730]                     stop_if_not(is.finite(workers), workers >= 
[10:33:37.730]                       1L)
[10:33:37.730]                     if ((workers == 1L && !inherits(workers, 
[10:33:37.730]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:33:37.730]                       if (default_workers) 
[10:33:37.730]                         supportsMulticore(warn = TRUE)
[10:33:37.730]                       return(sequential(..., envir = envir))
[10:33:37.730]                     }
[10:33:37.730]                     oopts <- options(mc.cores = workers)
[10:33:37.730]                     on.exit(options(oopts))
[10:33:37.730]                     future <- MulticoreFuture(..., workers = workers, 
[10:33:37.730]                       envir = envir)
[10:33:37.730]                     if (!future$lazy) 
[10:33:37.730]                       future <- run(future)
[10:33:37.730]                     invisible(future)
[10:33:37.730]                   }), .cleanup = FALSE, .init = FALSE)
[10:33:37.730]                 }
[10:33:37.730]                 ...future.workdir <- getwd()
[10:33:37.730]             }
[10:33:37.730]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:37.730]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:37.730]         }
[10:33:37.730]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:37.730]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:37.730]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:37.730]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:37.730]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:37.730]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:37.730]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:37.730]             base::names(...future.oldOptions))
[10:33:37.730]     }
[10:33:37.730]     if (FALSE) {
[10:33:37.730]     }
[10:33:37.730]     else {
[10:33:37.730]         if (TRUE) {
[10:33:37.730]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:37.730]                 open = "w")
[10:33:37.730]         }
[10:33:37.730]         else {
[10:33:37.730]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:37.730]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:37.730]         }
[10:33:37.730]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:37.730]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:37.730]             base::sink(type = "output", split = FALSE)
[10:33:37.730]             base::close(...future.stdout)
[10:33:37.730]         }, add = TRUE)
[10:33:37.730]     }
[10:33:37.730]     ...future.frame <- base::sys.nframe()
[10:33:37.730]     ...future.conditions <- base::list()
[10:33:37.730]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:37.730]     if (FALSE) {
[10:33:37.730]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:37.730]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:37.730]     }
[10:33:37.730]     ...future.result <- base::tryCatch({
[10:33:37.730]         base::withCallingHandlers({
[10:33:37.730]             ...future.value <- base::withVisible(base::local({
[10:33:37.730]                 withCallingHandlers({
[10:33:37.730]                   {
[10:33:37.730]                     value(future(subset(data, a == 2)))
[10:33:37.730]                   }
[10:33:37.730]                 }, immediateCondition = function(cond) {
[10:33:37.730]                   save_rds <- function (object, pathname, ...) 
[10:33:37.730]                   {
[10:33:37.730]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:37.730]                     if (file_test("-f", pathname_tmp)) {
[10:33:37.730]                       fi_tmp <- file.info(pathname_tmp)
[10:33:37.730]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:37.730]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:37.730]                         fi_tmp[["mtime"]])
[10:33:37.730]                     }
[10:33:37.730]                     tryCatch({
[10:33:37.730]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:37.730]                     }, error = function(ex) {
[10:33:37.730]                       msg <- conditionMessage(ex)
[10:33:37.730]                       fi_tmp <- file.info(pathname_tmp)
[10:33:37.730]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:37.730]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:37.730]                         fi_tmp[["mtime"]], msg)
[10:33:37.730]                       ex$message <- msg
[10:33:37.730]                       stop(ex)
[10:33:37.730]                     })
[10:33:37.730]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:37.730]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:37.730]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:37.730]                       fi_tmp <- file.info(pathname_tmp)
[10:33:37.730]                       fi <- file.info(pathname)
[10:33:37.730]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:37.730]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:37.730]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:37.730]                         fi[["size"]], fi[["mtime"]])
[10:33:37.730]                       stop(msg)
[10:33:37.730]                     }
[10:33:37.730]                     invisible(pathname)
[10:33:37.730]                   }
[10:33:37.730]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:37.730]                     rootPath = tempdir()) 
[10:33:37.730]                   {
[10:33:37.730]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:37.730]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:37.730]                       tmpdir = path, fileext = ".rds")
[10:33:37.730]                     save_rds(obj, file)
[10:33:37.730]                   }
[10:33:37.730]                   saveImmediateCondition(cond, path = "/tmp/RtmpTlTEh1/.future/immediateConditions")
[10:33:37.730]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.730]                   {
[10:33:37.730]                     inherits <- base::inherits
[10:33:37.730]                     invokeRestart <- base::invokeRestart
[10:33:37.730]                     is.null <- base::is.null
[10:33:37.730]                     muffled <- FALSE
[10:33:37.730]                     if (inherits(cond, "message")) {
[10:33:37.730]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:37.730]                       if (muffled) 
[10:33:37.730]                         invokeRestart("muffleMessage")
[10:33:37.730]                     }
[10:33:37.730]                     else if (inherits(cond, "warning")) {
[10:33:37.730]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:37.730]                       if (muffled) 
[10:33:37.730]                         invokeRestart("muffleWarning")
[10:33:37.730]                     }
[10:33:37.730]                     else if (inherits(cond, "condition")) {
[10:33:37.730]                       if (!is.null(pattern)) {
[10:33:37.730]                         computeRestarts <- base::computeRestarts
[10:33:37.730]                         grepl <- base::grepl
[10:33:37.730]                         restarts <- computeRestarts(cond)
[10:33:37.730]                         for (restart in restarts) {
[10:33:37.730]                           name <- restart$name
[10:33:37.730]                           if (is.null(name)) 
[10:33:37.730]                             next
[10:33:37.730]                           if (!grepl(pattern, name)) 
[10:33:37.730]                             next
[10:33:37.730]                           invokeRestart(restart)
[10:33:37.730]                           muffled <- TRUE
[10:33:37.730]                           break
[10:33:37.730]                         }
[10:33:37.730]                       }
[10:33:37.730]                     }
[10:33:37.730]                     invisible(muffled)
[10:33:37.730]                   }
[10:33:37.730]                   muffleCondition(cond)
[10:33:37.730]                 })
[10:33:37.730]             }))
[10:33:37.730]             future::FutureResult(value = ...future.value$value, 
[10:33:37.730]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.730]                   ...future.rng), globalenv = if (FALSE) 
[10:33:37.730]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:37.730]                     ...future.globalenv.names))
[10:33:37.730]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:37.730]         }, condition = base::local({
[10:33:37.730]             c <- base::c
[10:33:37.730]             inherits <- base::inherits
[10:33:37.730]             invokeRestart <- base::invokeRestart
[10:33:37.730]             length <- base::length
[10:33:37.730]             list <- base::list
[10:33:37.730]             seq.int <- base::seq.int
[10:33:37.730]             signalCondition <- base::signalCondition
[10:33:37.730]             sys.calls <- base::sys.calls
[10:33:37.730]             `[[` <- base::`[[`
[10:33:37.730]             `+` <- base::`+`
[10:33:37.730]             `<<-` <- base::`<<-`
[10:33:37.730]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:37.730]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:37.730]                   3L)]
[10:33:37.730]             }
[10:33:37.730]             function(cond) {
[10:33:37.730]                 is_error <- inherits(cond, "error")
[10:33:37.730]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:37.730]                   NULL)
[10:33:37.730]                 if (is_error) {
[10:33:37.730]                   sessionInformation <- function() {
[10:33:37.730]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:37.730]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:37.730]                       search = base::search(), system = base::Sys.info())
[10:33:37.730]                   }
[10:33:37.730]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.730]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:37.730]                     cond$call), session = sessionInformation(), 
[10:33:37.730]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:37.730]                   signalCondition(cond)
[10:33:37.730]                 }
[10:33:37.730]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:37.730]                 "immediateCondition"))) {
[10:33:37.730]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:37.730]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.730]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:37.730]                   if (TRUE && !signal) {
[10:33:37.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.730]                     {
[10:33:37.730]                       inherits <- base::inherits
[10:33:37.730]                       invokeRestart <- base::invokeRestart
[10:33:37.730]                       is.null <- base::is.null
[10:33:37.730]                       muffled <- FALSE
[10:33:37.730]                       if (inherits(cond, "message")) {
[10:33:37.730]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.730]                         if (muffled) 
[10:33:37.730]                           invokeRestart("muffleMessage")
[10:33:37.730]                       }
[10:33:37.730]                       else if (inherits(cond, "warning")) {
[10:33:37.730]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.730]                         if (muffled) 
[10:33:37.730]                           invokeRestart("muffleWarning")
[10:33:37.730]                       }
[10:33:37.730]                       else if (inherits(cond, "condition")) {
[10:33:37.730]                         if (!is.null(pattern)) {
[10:33:37.730]                           computeRestarts <- base::computeRestarts
[10:33:37.730]                           grepl <- base::grepl
[10:33:37.730]                           restarts <- computeRestarts(cond)
[10:33:37.730]                           for (restart in restarts) {
[10:33:37.730]                             name <- restart$name
[10:33:37.730]                             if (is.null(name)) 
[10:33:37.730]                               next
[10:33:37.730]                             if (!grepl(pattern, name)) 
[10:33:37.730]                               next
[10:33:37.730]                             invokeRestart(restart)
[10:33:37.730]                             muffled <- TRUE
[10:33:37.730]                             break
[10:33:37.730]                           }
[10:33:37.730]                         }
[10:33:37.730]                       }
[10:33:37.730]                       invisible(muffled)
[10:33:37.730]                     }
[10:33:37.730]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.730]                   }
[10:33:37.730]                 }
[10:33:37.730]                 else {
[10:33:37.730]                   if (TRUE) {
[10:33:37.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.730]                     {
[10:33:37.730]                       inherits <- base::inherits
[10:33:37.730]                       invokeRestart <- base::invokeRestart
[10:33:37.730]                       is.null <- base::is.null
[10:33:37.730]                       muffled <- FALSE
[10:33:37.730]                       if (inherits(cond, "message")) {
[10:33:37.730]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.730]                         if (muffled) 
[10:33:37.730]                           invokeRestart("muffleMessage")
[10:33:37.730]                       }
[10:33:37.730]                       else if (inherits(cond, "warning")) {
[10:33:37.730]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.730]                         if (muffled) 
[10:33:37.730]                           invokeRestart("muffleWarning")
[10:33:37.730]                       }
[10:33:37.730]                       else if (inherits(cond, "condition")) {
[10:33:37.730]                         if (!is.null(pattern)) {
[10:33:37.730]                           computeRestarts <- base::computeRestarts
[10:33:37.730]                           grepl <- base::grepl
[10:33:37.730]                           restarts <- computeRestarts(cond)
[10:33:37.730]                           for (restart in restarts) {
[10:33:37.730]                             name <- restart$name
[10:33:37.730]                             if (is.null(name)) 
[10:33:37.730]                               next
[10:33:37.730]                             if (!grepl(pattern, name)) 
[10:33:37.730]                               next
[10:33:37.730]                             invokeRestart(restart)
[10:33:37.730]                             muffled <- TRUE
[10:33:37.730]                             break
[10:33:37.730]                           }
[10:33:37.730]                         }
[10:33:37.730]                       }
[10:33:37.730]                       invisible(muffled)
[10:33:37.730]                     }
[10:33:37.730]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.730]                   }
[10:33:37.730]                 }
[10:33:37.730]             }
[10:33:37.730]         }))
[10:33:37.730]     }, error = function(ex) {
[10:33:37.730]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:37.730]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.730]                 ...future.rng), started = ...future.startTime, 
[10:33:37.730]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:37.730]             version = "1.8"), class = "FutureResult")
[10:33:37.730]     }, finally = {
[10:33:37.730]         if (!identical(...future.workdir, getwd())) 
[10:33:37.730]             setwd(...future.workdir)
[10:33:37.730]         {
[10:33:37.730]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:37.730]                 ...future.oldOptions$nwarnings <- NULL
[10:33:37.730]             }
[10:33:37.730]             base::options(...future.oldOptions)
[10:33:37.730]             if (.Platform$OS.type == "windows") {
[10:33:37.730]                 old_names <- names(...future.oldEnvVars)
[10:33:37.730]                 envs <- base::Sys.getenv()
[10:33:37.730]                 names <- names(envs)
[10:33:37.730]                 common <- intersect(names, old_names)
[10:33:37.730]                 added <- setdiff(names, old_names)
[10:33:37.730]                 removed <- setdiff(old_names, names)
[10:33:37.730]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:37.730]                   envs[common]]
[10:33:37.730]                 NAMES <- toupper(changed)
[10:33:37.730]                 args <- list()
[10:33:37.730]                 for (kk in seq_along(NAMES)) {
[10:33:37.730]                   name <- changed[[kk]]
[10:33:37.730]                   NAME <- NAMES[[kk]]
[10:33:37.730]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.730]                     next
[10:33:37.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.730]                 }
[10:33:37.730]                 NAMES <- toupper(added)
[10:33:37.730]                 for (kk in seq_along(NAMES)) {
[10:33:37.730]                   name <- added[[kk]]
[10:33:37.730]                   NAME <- NAMES[[kk]]
[10:33:37.730]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.730]                     next
[10:33:37.730]                   args[[name]] <- ""
[10:33:37.730]                 }
[10:33:37.730]                 NAMES <- toupper(removed)
[10:33:37.730]                 for (kk in seq_along(NAMES)) {
[10:33:37.730]                   name <- removed[[kk]]
[10:33:37.730]                   NAME <- NAMES[[kk]]
[10:33:37.730]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.730]                     next
[10:33:37.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.730]                 }
[10:33:37.730]                 if (length(args) > 0) 
[10:33:37.730]                   base::do.call(base::Sys.setenv, args = args)
[10:33:37.730]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:37.730]             }
[10:33:37.730]             else {
[10:33:37.730]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:37.730]             }
[10:33:37.730]             {
[10:33:37.730]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:37.730]                   0L) {
[10:33:37.730]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:37.730]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:37.730]                   base::options(opts)
[10:33:37.730]                 }
[10:33:37.730]                 {
[10:33:37.730]                   {
[10:33:37.730]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:37.730]                     NULL
[10:33:37.730]                   }
[10:33:37.730]                   options(future.plan = NULL)
[10:33:37.730]                   if (is.na(NA_character_)) 
[10:33:37.730]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.730]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:37.730]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:37.730]                     .init = FALSE)
[10:33:37.730]                 }
[10:33:37.730]             }
[10:33:37.730]         }
[10:33:37.730]     })
[10:33:37.730]     if (TRUE) {
[10:33:37.730]         base::sink(type = "output", split = FALSE)
[10:33:37.730]         if (TRUE) {
[10:33:37.730]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:37.730]         }
[10:33:37.730]         else {
[10:33:37.730]             ...future.result["stdout"] <- base::list(NULL)
[10:33:37.730]         }
[10:33:37.730]         base::close(...future.stdout)
[10:33:37.730]         ...future.stdout <- NULL
[10:33:37.730]     }
[10:33:37.730]     ...future.result$conditions <- ...future.conditions
[10:33:37.730]     ...future.result$finished <- base::Sys.time()
[10:33:37.730]     ...future.result
[10:33:37.730] }
[10:33:37.733] assign_globals() ...
[10:33:37.733] List of 1
[10:33:37.733]  $ data:'data.frame':	3 obs. of  2 variables:
[10:33:37.733]   ..$ a: int [1:3] 1 2 3
[10:33:37.733]   ..$ b: int [1:3] 3 2 1
[10:33:37.733]  - attr(*, "where")=List of 1
[10:33:37.733]   ..$ data:<environment: R_EmptyEnv> 
[10:33:37.733]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:37.733]  - attr(*, "resolved")= logi FALSE
[10:33:37.733]  - attr(*, "total_size")= num 128
[10:33:37.733]  - attr(*, "already-done")= logi TRUE
[10:33:37.736] - copied ‘data’ to environment
[10:33:37.736] assign_globals() ... done
[10:33:37.737] requestCore(): workers = 2
[10:33:37.739] MulticoreFuture started
[10:33:37.739] - Launch lazy future ... done
[10:33:37.740] run() for ‘MulticoreFuture’ ... done
[10:33:37.740] result() for MulticoreFuture ...
[10:33:37.740] plan(): Setting new future strategy stack:
[10:33:37.741] List of future strategies:
[10:33:37.741] 1. multicore:
[10:33:37.741]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:37.741]    - tweaked: FALSE
[10:33:37.741]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.747] plan(): nbrOfWorkers() = 1
[10:33:37.782] plan(): Setting new future strategy stack:
[10:33:37.782] List of future strategies:
[10:33:37.782] 1. multicore:
[10:33:37.782]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:37.782]    - tweaked: FALSE
[10:33:37.782]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.782] 2. multicore:
[10:33:37.782]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:37.782]    - tweaked: FALSE
[10:33:37.782]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.786] plan(): nbrOfWorkers() = 2
[10:33:37.787] result() for MulticoreFuture ...
[10:33:37.787] result() for MulticoreFuture ... done
[10:33:37.788] signalConditions() ...
[10:33:37.788]  - include = ‘immediateCondition’
[10:33:37.788]  - exclude = 
[10:33:37.788]  - resignal = FALSE
[10:33:37.788]  - Number of conditions: 52
[10:33:37.788] signalConditions() ... done
[10:33:37.788] result() for MulticoreFuture ... done
[10:33:37.788] result() for MulticoreFuture ...
[10:33:37.789] result() for MulticoreFuture ... done
[10:33:37.789] signalConditions() ...
[10:33:37.789]  - include = ‘immediateCondition’
[10:33:37.789]  - exclude = 
[10:33:37.789]  - resignal = FALSE
[10:33:37.789]  - Number of conditions: 52
[10:33:37.789] signalConditions() ... done
[10:33:37.789] Future state: ‘finished’
[10:33:37.790] result() for MulticoreFuture ...
[10:33:37.790] result() for MulticoreFuture ... done
[10:33:37.790] signalConditions() ...
[10:33:37.790]  - include = ‘condition’
[10:33:37.790]  - exclude = ‘immediateCondition’
[10:33:37.790]  - resignal = TRUE
[10:33:37.790]  - Number of conditions: 52
[10:33:37.790]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.748] getGlobalsAndPackages() ...
[10:33:37.790]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.748] Searching for globals...
[10:33:37.791]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.750] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[10:33:37.791]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.750] Searching for globals ... DONE
[10:33:37.791]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.750] Resolving globals: FALSE
[10:33:37.791]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.751] The total size of the 1 globals is 128 bytes (128 bytes)
[10:33:37.791]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.751] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:33:37.791]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.752] - globals: [1] ‘data’
[10:33:37.792]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.752] 
[10:33:37.792]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.752] getGlobalsAndPackages() ... DONE
[10:33:37.792]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.753] run() for ‘Future’ ...
[10:33:37.792]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.753] - state: ‘created’
[10:33:37.792]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.753] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:37.792]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.757] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:37.793]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.757] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:37.793]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.758]   - Field: ‘label’
[10:33:37.793]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.758]   - Field: ‘local’
[10:33:37.793]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.758]   - Field: ‘owner’
[10:33:37.793]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.758]   - Field: ‘envir’
[10:33:37.793]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.758]   - Field: ‘packages’
[10:33:37.794]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.758]   - Field: ‘gc’
[10:33:37.794]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.759]   - Field: ‘conditions’
[10:33:37.794]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.759]   - Field: ‘expr’
[10:33:37.794]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.759]   - Field: ‘uuid’
[10:33:37.794]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.759]   - Field: ‘seed’
[10:33:37.794]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.759]   - Field: ‘version’
[10:33:37.794]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.759]   - Field: ‘result’
[10:33:37.795]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.760]   - Field: ‘asynchronous’
[10:33:37.795]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.760]   - Field: ‘calls’
[10:33:37.795]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.760]   - Field: ‘globals’
[10:33:37.795]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.760]   - Field: ‘stdout’
[10:33:37.795]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.760]   - Field: ‘earlySignal’
[10:33:37.795]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.760]   - Field: ‘lazy’
[10:33:37.796]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.760]   - Field: ‘state’
[10:33:37.796]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.761] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:37.796]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.761] - Launch lazy future ...
[10:33:37.796]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.761] Packages needed by the future expression (n = 0): <none>
[10:33:37.796]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.761] Packages needed by future strategies (n = 0): <none>
[10:33:37.796]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.762] {
[10:33:37.762]     {
[10:33:37.762]         {
[10:33:37.762]             ...future.startTime <- base::Sys.time()
[10:33:37.762]             {
[10:33:37.762]                 {
[10:33:37.762]                   {
[10:33:37.762]                     base::local({
[10:33:37.762]                       has_future <- base::requireNamespace("future", 
[10:33:37.762]                         quietly = TRUE)
[10:33:37.762]                       if (has_future) {
[10:33:37.762]                         ns <- base::getNamespace("future")
[10:33:37.762]                         version <- ns[[".package"]][["version"]]
[10:33:37.762]                         if (is.null(version)) 
[10:33:37.762]                           version <- utils::packageVersion("future")
[10:33:37.762]                       }
[10:33:37.762]                       else {
[10:33:37.762]                         version <- NULL
[10:33:37.762]                       }
[10:33:37.762]                       if (!has_future || version < "1.8.0") {
[10:33:37.762]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:37.762]                           "", base::R.version$version.string), 
[10:33:37.762]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:37.762]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:37.762]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:37.762]                             "release", "version")], collapse = " "), 
[10:33:37.762]                           hostname = base::Sys.info()[["nodename"]])
[10:33:37.762]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:37.762]                           info)
[10:33:37.762]                         info <- base::paste(info, collapse = "; ")
[10:33:37.762]                         if (!has_future) {
[10:33:37.762]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:37.762]                             info)
[10:33:37.762]                         }
[10:33:37.762]                         else {
[10:33:37.762]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:37.762]                             info, version)
[10:33:37.762]                         }
[10:33:37.762]                         base::stop(msg)
[10:33:37.762]                       }
[10:33:37.762]                     })
[10:33:37.762]                   }
[10:33:37.762]                   ...future.strategy.old <- future::plan("list")
[10:33:37.762]                   options(future.plan = NULL)
[10:33:37.762]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.762]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:37.762]                 }
[10:33:37.762]                 ...future.workdir <- getwd()
[10:33:37.762]             }
[10:33:37.762]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:37.762]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:37.762]         }
[10:33:37.762]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:37.762]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:37.762]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:37.762]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:37.762]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:37.762]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:37.762]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:37.762]             base::names(...future.oldOptions))
[10:33:37.762]     }
[10:33:37.762]     if (FALSE) {
[10:33:37.762]     }
[10:33:37.762]     else {
[10:33:37.762]         if (TRUE) {
[10:33:37.762]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:37.762]                 open = "w")
[10:33:37.762]         }
[10:33:37.762]         else {
[10:33:37.762]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:37.762]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:37.762]         }
[10:33:37.762]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:37.762]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:37.762]             base::sink(type = "output", split = FALSE)
[10:33:37.762]             base::close(...future.stdout)
[10:33:37.762]         }, add = TRUE)
[10:33:37.762]     }
[10:33:37.762]     ...future.frame <- base::sys.nframe()
[10:33:37.762]     ...future.conditions <- base::list()
[10:33:37.762]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:37.762]     if (FALSE) {
[10:33:37.762]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:37.762]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:37.762]     }
[10:33:37.762]     ...future.result <- base::tryCatch({
[10:33:37.762]         base::withCallingHandlers({
[10:33:37.762]             ...future.value <- base::withVisible(base::local(subset(data, 
[10:33:37.762]                 a == 2)))
[10:33:37.762]             future::FutureResult(value = ...future.value$value, 
[10:33:37.762]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.762]                   ...future.rng), globalenv = if (FALSE) 
[10:33:37.762]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:37.762]                     ...future.globalenv.names))
[10:33:37.762]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:37.762]         }, condition = base::local({
[10:33:37.762]             c <- base::c
[10:33:37.762]             inherits <- base::inherits
[10:33:37.762]             invokeRestart <- base::invokeRestart
[10:33:37.762]             length <- base::length
[10:33:37.762]             list <- base::list
[10:33:37.762]             seq.int <- base::seq.int
[10:33:37.762]             signalCondition <- base::signalCondition
[10:33:37.762]             sys.calls <- base::sys.calls
[10:33:37.762]             `[[` <- base::`[[`
[10:33:37.762]             `+` <- base::`+`
[10:33:37.762]             `<<-` <- base::`<<-`
[10:33:37.762]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:37.762]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:37.762]                   3L)]
[10:33:37.762]             }
[10:33:37.762]             function(cond) {
[10:33:37.762]                 is_error <- inherits(cond, "error")
[10:33:37.762]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:37.762]                   NULL)
[10:33:37.762]                 if (is_error) {
[10:33:37.762]                   sessionInformation <- function() {
[10:33:37.762]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:37.762]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:37.762]                       search = base::search(), system = base::Sys.info())
[10:33:37.762]                   }
[10:33:37.762]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.762]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:37.762]                     cond$call), session = sessionInformation(), 
[10:33:37.762]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:37.762]                   signalCondition(cond)
[10:33:37.762]                 }
[10:33:37.762]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:37.762]                 "immediateCondition"))) {
[10:33:37.762]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:37.762]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.762]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:37.762]                   if (TRUE && !signal) {
[10:33:37.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.762]                     {
[10:33:37.762]                       inherits <- base::inherits
[10:33:37.762]                       invokeRestart <- base::invokeRestart
[10:33:37.762]                       is.null <- base::is.null
[10:33:37.762]                       muffled <- FALSE
[10:33:37.762]                       if (inherits(cond, "message")) {
[10:33:37.762]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.762]                         if (muffled) 
[10:33:37.762]                           invokeRestart("muffleMessage")
[10:33:37.762]                       }
[10:33:37.762]                       else if (inherits(cond, "warning")) {
[10:33:37.762]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.762]                         if (muffled) 
[10:33:37.762]                           invokeRestart("muffleWarning")
[10:33:37.762]                       }
[10:33:37.762]                       else if (inherits(cond, "condition")) {
[10:33:37.762]                         if (!is.null(pattern)) {
[10:33:37.762]                           computeRestarts <- base::computeRestarts
[10:33:37.762]                           grepl <- base::grepl
[10:33:37.762]                           restarts <- computeRestarts(cond)
[10:33:37.762]                           for (restart in restarts) {
[10:33:37.762]                             name <- restart$name
[10:33:37.762]                             if (is.null(name)) 
[10:33:37.762]                               next
[10:33:37.762]                             if (!grepl(pattern, name)) 
[10:33:37.762]                               next
[10:33:37.762]                             invokeRestart(restart)
[10:33:37.762]                             muffled <- TRUE
[10:33:37.762]                             break
[10:33:37.762]                           }
[10:33:37.762]                         }
[10:33:37.762]                       }
[10:33:37.762]                       invisible(muffled)
[10:33:37.762]                     }
[10:33:37.762]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.762]                   }
[10:33:37.762]                 }
[10:33:37.762]                 else {
[10:33:37.762]                   if (TRUE) {
[10:33:37.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.762]                     {
[10:33:37.762]                       inherits <- base::inherits
[10:33:37.762]                       invokeRestart <- base::invokeRestart
[10:33:37.762]                       is.null <- base::is.null
[10:33:37.762]                       muffled <- FALSE
[10:33:37.762]                       if (inherits(cond, "message")) {
[10:33:37.762]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.762]                         if (muffled) 
[10:33:37.762]                           invokeRestart("muffleMessage")
[10:33:37.762]                       }
[10:33:37.762]                       else if (inherits(cond, "warning")) {
[10:33:37.762]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.762]                         if (muffled) 
[10:33:37.762]                           invokeRestart("muffleWarning")
[10:33:37.762]                       }
[10:33:37.762]                       else if (inherits(cond, "condition")) {
[10:33:37.762]                         if (!is.null(pattern)) {
[10:33:37.762]                           computeRestarts <- base::computeRestarts
[10:33:37.762]                           grepl <- base::grepl
[10:33:37.762]                           restarts <- computeRestarts(cond)
[10:33:37.762]                           for (restart in restarts) {
[10:33:37.762]                             name <- restart$name
[10:33:37.762]                             if (is.null(name)) 
[10:33:37.762]                               next
[10:33:37.762]                             if (!grepl(pattern, name)) 
[10:33:37.762]                               next
[10:33:37.762]                             invokeRestart(restart)
[10:33:37.762]                             muffled <- TRUE
[10:33:37.762]                             break
[10:33:37.762]                           }
[10:33:37.762]                         }
[10:33:37.762]                       }
[10:33:37.762]                       invisible(muffled)
[10:33:37.762]                     }
[10:33:37.762]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.762]                   }
[10:33:37.762]                 }
[10:33:37.762]             }
[10:33:37.762]         }))
[10:33:37.762]     }, error = function(ex) {
[10:33:37.762]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:37.762]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.762]                 ...future.rng), started = ...future.startTime, 
[10:33:37.762]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:37.762]             version = "1.8"), class = "FutureResult")
[10:33:37.762]     }, finally = {
[10:33:37.762]         if (!identical(...future.workdir, getwd())) 
[10:33:37.762]             setwd(...future.workdir)
[10:33:37.762]         {
[10:33:37.762]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:37.762]                 ...future.oldOptions$nwarnings <- NULL
[10:33:37.762]             }
[10:33:37.762]             base::options(...future.oldOptions)
[10:33:37.762]             if (.Platform$OS.type == "windows") {
[10:33:37.762]                 old_names <- names(...future.oldEnvVars)
[10:33:37.762]                 envs <- base::Sys.getenv()
[10:33:37.762]                 names <- names(envs)
[10:33:37.762]                 common <- intersect(names, old_names)
[10:33:37.762]                 added <- setdiff(names, old_names)
[10:33:37.762]                 removed <- setdiff(old_names, names)
[10:33:37.762]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:37.762]                   envs[common]]
[10:33:37.762]                 NAMES <- toupper(changed)
[10:33:37.762]                 args <- list()
[10:33:37.762]                 for (kk in seq_along(NAMES)) {
[10:33:37.762]                   name <- changed[[kk]]
[10:33:37.762]                   NAME <- NAMES[[kk]]
[10:33:37.762]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.762]                     next
[10:33:37.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.762]                 }
[10:33:37.762]                 NAMES <- toupper(added)
[10:33:37.762]                 for (kk in seq_along(NAMES)) {
[10:33:37.762]                   name <- added[[kk]]
[10:33:37.762]                   NAME <- NAMES[[kk]]
[10:33:37.762]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.762]                     next
[10:33:37.762]                   args[[name]] <- ""
[10:33:37.762]                 }
[10:33:37.762]                 NAMES <- toupper(removed)
[10:33:37.762]                 for (kk in seq_along(NAMES)) {
[10:33:37.762]                   name <- removed[[kk]]
[10:33:37.762]                   NAME <- NAMES[[kk]]
[10:33:37.762]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.762]                     next
[10:33:37.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.762]                 }
[10:33:37.762]                 if (length(args) > 0) 
[10:33:37.762]                   base::do.call(base::Sys.setenv, args = args)
[10:33:37.762]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:37.762]             }
[10:33:37.762]             else {
[10:33:37.762]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:37.762]             }
[10:33:37.762]             {
[10:33:37.762]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:37.762]                   0L) {
[10:33:37.762]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:37.762]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:37.762]                   base::options(opts)
[10:33:37.762]                 }
[10:33:37.762]                 {
[10:33:37.762]                   {
[10:33:37.762]                     NULL
[10:33:37.762]                     RNGkind("Mersenne-Twister")
[10:33:37.762]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:37.762]                       inherits = FALSE)
[10:33:37.762]                   }
[10:33:37.762]                   options(future.plan = NULL)
[10:33:37.762]                   if (is.na(NA_character_)) 
[10:33:37.762]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.762]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:37.762]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:37.762]                     .init = FALSE)
[10:33:37.762]                 }
[10:33:37.762]             }
[10:33:37.762]         }
[10:33:37.762]     })
[10:33:37.762]     if (TRUE) {
[10:33:37.762]         base::sink(type = "output", split = FALSE)
[10:33:37.762]         if (TRUE) {
[10:33:37.762]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:37.762]         }
[10:33:37.762]         else {
[10:33:37.762]             ...future.result["stdout"] <- base::list(NULL)
[10:33:37.762]         }
[10:33:37.762]         base::close(...future.stdout)
[10:33:37.762]         ...future.stdout <- NULL
[10:33:37.762]     }
[10:33:37.762]     ...future.result$conditions <- ...future.conditions
[10:33:37.762]     ...future.result$finished <- base::Sys.time()
[10:33:37.762]     ...future.result
[10:33:37.762] }
[10:33:37.796]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.764] assign_globals() ...
[10:33:37.797]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.764] List of 1
[10:33:37.764]  $ data:'data.frame':	3 obs. of  2 variables:
[10:33:37.764]   ..$ a: int [1:3] 1 2 3
[10:33:37.764]   ..$ b: int [1:3] 3 2 1
[10:33:37.764]  - attr(*, "where")=List of 1
[10:33:37.764]   ..$ data:<environment: R_EmptyEnv> 
[10:33:37.764]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:37.764]  - attr(*, "resolved")= logi FALSE
[10:33:37.764]  - attr(*, "total_size")= num 128
[10:33:37.764]  - attr(*, "already-done")= logi TRUE
[10:33:37.797]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.774] - copied ‘data’ to environment
[10:33:37.797]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.774] assign_globals() ... done
[10:33:37.797]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.775] plan(): Setting new future strategy stack:
[10:33:37.797]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.775] List of future strategies:
[10:33:37.775] 1. sequential:
[10:33:37.775]    - args: function (..., envir = parent.frame())
[10:33:37.775]    - tweaked: FALSE
[10:33:37.775]    - call: NULL
[10:33:37.798]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.775] plan(): nbrOfWorkers() = 1
[10:33:37.798]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.776] plan(): Setting new future strategy stack:
[10:33:37.798]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.777] List of future strategies:
[10:33:37.777] 1. multicore:
[10:33:37.777]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:37.777]    - tweaked: FALSE
[10:33:37.777]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.798]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.780] plan(): nbrOfWorkers() = 1
[10:33:37.798]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.781] SequentialFuture started (and completed)
[10:33:37.798]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.781] - Launch lazy future ... done
[10:33:37.798]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.781] run() for ‘SequentialFuture’ ... done
[10:33:37.799] signalConditions() ... done
- plan(list('multicore', 'multicore')) ... DONE
- plan(list('multicore', 'multisession')) ...
[10:33:37.799] plan(): Setting new future strategy stack:
[10:33:37.799] List of future strategies:
[10:33:37.799] 1. multicore:
[10:33:37.799]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:37.799]    - tweaked: FALSE
[10:33:37.799]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.799] 2. multisession:
[10:33:37.799]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:37.799]    - tweaked: FALSE
[10:33:37.799]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.804] plan(): nbrOfWorkers() = 2
[10:33:37.804] getGlobalsAndPackages() ...
[10:33:37.804] Searching for globals...
[10:33:37.827] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:33:37.827] Searching for globals ... DONE
[10:33:37.827] Resolving globals: FALSE
[10:33:37.828] The total size of the 2 globals is 90.64 KiB (92816 bytes)
[10:33:37.829] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 90.64 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (90.52 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[10:33:37.829] - globals: [2] ‘nested’, ‘strategy2’
[10:33:37.829] - packages: [1] ‘future’
[10:33:37.829] getGlobalsAndPackages() ... DONE
[10:33:37.830] run() for ‘Future’ ...
[10:33:37.830] - state: ‘created’
[10:33:37.830] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:37.834] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:37.834] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:37.835]   - Field: ‘label’
[10:33:37.835]   - Field: ‘local’
[10:33:37.835]   - Field: ‘owner’
[10:33:37.835]   - Field: ‘envir’
[10:33:37.835]   - Field: ‘workers’
[10:33:37.835]   - Field: ‘packages’
[10:33:37.835]   - Field: ‘gc’
[10:33:37.836]   - Field: ‘job’
[10:33:37.836]   - Field: ‘conditions’
[10:33:37.836]   - Field: ‘expr’
[10:33:37.836]   - Field: ‘uuid’
[10:33:37.836]   - Field: ‘seed’
[10:33:37.836]   - Field: ‘version’
[10:33:37.836]   - Field: ‘result’
[10:33:37.836]   - Field: ‘asynchronous’
[10:33:37.837]   - Field: ‘calls’
[10:33:37.837]   - Field: ‘globals’
[10:33:37.837]   - Field: ‘stdout’
[10:33:37.837]   - Field: ‘earlySignal’
[10:33:37.837]   - Field: ‘lazy’
[10:33:37.837]   - Field: ‘state’
[10:33:37.837] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:37.837] - Launch lazy future ...
[10:33:37.838] Packages needed by the future expression (n = 1): ‘future’
[10:33:37.838] Packages needed by future strategies (n = 1): ‘future’
[10:33:37.838] {
[10:33:37.838]     {
[10:33:37.838]         {
[10:33:37.838]             ...future.startTime <- base::Sys.time()
[10:33:37.838]             {
[10:33:37.838]                 {
[10:33:37.838]                   {
[10:33:37.838]                     {
[10:33:37.838]                       {
[10:33:37.838]                         base::local({
[10:33:37.838]                           has_future <- base::requireNamespace("future", 
[10:33:37.838]                             quietly = TRUE)
[10:33:37.838]                           if (has_future) {
[10:33:37.838]                             ns <- base::getNamespace("future")
[10:33:37.838]                             version <- ns[[".package"]][["version"]]
[10:33:37.838]                             if (is.null(version)) 
[10:33:37.838]                               version <- utils::packageVersion("future")
[10:33:37.838]                           }
[10:33:37.838]                           else {
[10:33:37.838]                             version <- NULL
[10:33:37.838]                           }
[10:33:37.838]                           if (!has_future || version < "1.8.0") {
[10:33:37.838]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:37.838]                               "", base::R.version$version.string), 
[10:33:37.838]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:37.838]                                 base::R.version$platform, 8 * 
[10:33:37.838]                                   base::.Machine$sizeof.pointer), 
[10:33:37.838]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:37.838]                                 "release", "version")], collapse = " "), 
[10:33:37.838]                               hostname = base::Sys.info()[["nodename"]])
[10:33:37.838]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:37.838]                               info)
[10:33:37.838]                             info <- base::paste(info, collapse = "; ")
[10:33:37.838]                             if (!has_future) {
[10:33:37.838]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:37.838]                                 info)
[10:33:37.838]                             }
[10:33:37.838]                             else {
[10:33:37.838]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:37.838]                                 info, version)
[10:33:37.838]                             }
[10:33:37.838]                             base::stop(msg)
[10:33:37.838]                           }
[10:33:37.838]                         })
[10:33:37.838]                       }
[10:33:37.838]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:37.838]                       base::options(mc.cores = 1L)
[10:33:37.838]                     }
[10:33:37.838]                     base::local({
[10:33:37.838]                       for (pkg in "future") {
[10:33:37.838]                         base::loadNamespace(pkg)
[10:33:37.838]                         base::library(pkg, character.only = TRUE)
[10:33:37.838]                       }
[10:33:37.838]                     })
[10:33:37.838]                   }
[10:33:37.838]                   ...future.strategy.old <- future::plan("list")
[10:33:37.838]                   options(future.plan = NULL)
[10:33:37.838]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.838]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:33:37.838]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:33:37.838]                     envir = parent.frame()) 
[10:33:37.838]                   {
[10:33:37.838]                     if (is.function(workers)) 
[10:33:37.838]                       workers <- workers()
[10:33:37.838]                     workers <- structure(as.integer(workers), 
[10:33:37.838]                       class = class(workers))
[10:33:37.838]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:33:37.838]                       workers >= 1)
[10:33:37.838]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:33:37.838]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:33:37.838]                     }
[10:33:37.838]                     future <- MultisessionFuture(..., workers = workers, 
[10:33:37.838]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:33:37.838]                       envir = envir)
[10:33:37.838]                     if (!future$lazy) 
[10:33:37.838]                       future <- run(future)
[10:33:37.838]                     invisible(future)
[10:33:37.838]                   }), .cleanup = FALSE, .init = FALSE)
[10:33:37.838]                 }
[10:33:37.838]                 ...future.workdir <- getwd()
[10:33:37.838]             }
[10:33:37.838]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:37.838]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:37.838]         }
[10:33:37.838]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:37.838]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:37.838]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:37.838]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:37.838]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:37.838]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:37.838]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:37.838]             base::names(...future.oldOptions))
[10:33:37.838]     }
[10:33:37.838]     if (FALSE) {
[10:33:37.838]     }
[10:33:37.838]     else {
[10:33:37.838]         if (TRUE) {
[10:33:37.838]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:37.838]                 open = "w")
[10:33:37.838]         }
[10:33:37.838]         else {
[10:33:37.838]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:37.838]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:37.838]         }
[10:33:37.838]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:37.838]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:37.838]             base::sink(type = "output", split = FALSE)
[10:33:37.838]             base::close(...future.stdout)
[10:33:37.838]         }, add = TRUE)
[10:33:37.838]     }
[10:33:37.838]     ...future.frame <- base::sys.nframe()
[10:33:37.838]     ...future.conditions <- base::list()
[10:33:37.838]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:37.838]     if (FALSE) {
[10:33:37.838]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:37.838]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:37.838]     }
[10:33:37.838]     ...future.result <- base::tryCatch({
[10:33:37.838]         base::withCallingHandlers({
[10:33:37.838]             ...future.value <- base::withVisible(base::local({
[10:33:37.838]                 withCallingHandlers({
[10:33:37.838]                   {
[10:33:37.838]                     a <- 1L
[10:33:37.838]                     plan_a <- unclass(future::plan("list"))
[10:33:37.838]                     nested_a <- nested[-1]
[10:33:37.838]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:33:37.838]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:33:37.838]                       strategy2))
[10:33:37.838]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:33:37.838]                       "init") <- NULL
[10:33:37.838]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:33:37.838]                       "init") <- NULL
[10:33:37.838]                     stopifnot(all.equal(plan_a, nested_a))
[10:33:37.838]                     y %<-% {
[10:33:37.838]                       b <- 2L
[10:33:37.838]                       plan_b <- future::plan("list")
[10:33:37.838]                       nested_b <- nested_a[-1]
[10:33:37.838]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:33:37.838]                         1L, inherits(plan_b[[1]], "future"), 
[10:33:37.838]                         inherits(future::plan("next"), "sequential"))
[10:33:37.838]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:33:37.838]                         b = b, nested_b = nested_b, plan_b = plan_b)
[10:33:37.838]                     }
[10:33:37.838]                     y
[10:33:37.838]                   }
[10:33:37.838]                 }, immediateCondition = function(cond) {
[10:33:37.838]                   save_rds <- function (object, pathname, ...) 
[10:33:37.838]                   {
[10:33:37.838]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:37.838]                     if (file_test("-f", pathname_tmp)) {
[10:33:37.838]                       fi_tmp <- file.info(pathname_tmp)
[10:33:37.838]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:37.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:37.838]                         fi_tmp[["mtime"]])
[10:33:37.838]                     }
[10:33:37.838]                     tryCatch({
[10:33:37.838]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:37.838]                     }, error = function(ex) {
[10:33:37.838]                       msg <- conditionMessage(ex)
[10:33:37.838]                       fi_tmp <- file.info(pathname_tmp)
[10:33:37.838]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:37.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:37.838]                         fi_tmp[["mtime"]], msg)
[10:33:37.838]                       ex$message <- msg
[10:33:37.838]                       stop(ex)
[10:33:37.838]                     })
[10:33:37.838]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:37.838]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:37.838]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:37.838]                       fi_tmp <- file.info(pathname_tmp)
[10:33:37.838]                       fi <- file.info(pathname)
[10:33:37.838]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:37.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:37.838]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:37.838]                         fi[["size"]], fi[["mtime"]])
[10:33:37.838]                       stop(msg)
[10:33:37.838]                     }
[10:33:37.838]                     invisible(pathname)
[10:33:37.838]                   }
[10:33:37.838]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:37.838]                     rootPath = tempdir()) 
[10:33:37.838]                   {
[10:33:37.838]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:37.838]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:37.838]                       tmpdir = path, fileext = ".rds")
[10:33:37.838]                     save_rds(obj, file)
[10:33:37.838]                   }
[10:33:37.838]                   saveImmediateCondition(cond, path = "/tmp/RtmpTlTEh1/.future/immediateConditions")
[10:33:37.838]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.838]                   {
[10:33:37.838]                     inherits <- base::inherits
[10:33:37.838]                     invokeRestart <- base::invokeRestart
[10:33:37.838]                     is.null <- base::is.null
[10:33:37.838]                     muffled <- FALSE
[10:33:37.838]                     if (inherits(cond, "message")) {
[10:33:37.838]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:37.838]                       if (muffled) 
[10:33:37.838]                         invokeRestart("muffleMessage")
[10:33:37.838]                     }
[10:33:37.838]                     else if (inherits(cond, "warning")) {
[10:33:37.838]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:37.838]                       if (muffled) 
[10:33:37.838]                         invokeRestart("muffleWarning")
[10:33:37.838]                     }
[10:33:37.838]                     else if (inherits(cond, "condition")) {
[10:33:37.838]                       if (!is.null(pattern)) {
[10:33:37.838]                         computeRestarts <- base::computeRestarts
[10:33:37.838]                         grepl <- base::grepl
[10:33:37.838]                         restarts <- computeRestarts(cond)
[10:33:37.838]                         for (restart in restarts) {
[10:33:37.838]                           name <- restart$name
[10:33:37.838]                           if (is.null(name)) 
[10:33:37.838]                             next
[10:33:37.838]                           if (!grepl(pattern, name)) 
[10:33:37.838]                             next
[10:33:37.838]                           invokeRestart(restart)
[10:33:37.838]                           muffled <- TRUE
[10:33:37.838]                           break
[10:33:37.838]                         }
[10:33:37.838]                       }
[10:33:37.838]                     }
[10:33:37.838]                     invisible(muffled)
[10:33:37.838]                   }
[10:33:37.838]                   muffleCondition(cond)
[10:33:37.838]                 })
[10:33:37.838]             }))
[10:33:37.838]             future::FutureResult(value = ...future.value$value, 
[10:33:37.838]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.838]                   ...future.rng), globalenv = if (FALSE) 
[10:33:37.838]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:37.838]                     ...future.globalenv.names))
[10:33:37.838]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:37.838]         }, condition = base::local({
[10:33:37.838]             c <- base::c
[10:33:37.838]             inherits <- base::inherits
[10:33:37.838]             invokeRestart <- base::invokeRestart
[10:33:37.838]             length <- base::length
[10:33:37.838]             list <- base::list
[10:33:37.838]             seq.int <- base::seq.int
[10:33:37.838]             signalCondition <- base::signalCondition
[10:33:37.838]             sys.calls <- base::sys.calls
[10:33:37.838]             `[[` <- base::`[[`
[10:33:37.838]             `+` <- base::`+`
[10:33:37.838]             `<<-` <- base::`<<-`
[10:33:37.838]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:37.838]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:37.838]                   3L)]
[10:33:37.838]             }
[10:33:37.838]             function(cond) {
[10:33:37.838]                 is_error <- inherits(cond, "error")
[10:33:37.838]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:37.838]                   NULL)
[10:33:37.838]                 if (is_error) {
[10:33:37.838]                   sessionInformation <- function() {
[10:33:37.838]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:37.838]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:37.838]                       search = base::search(), system = base::Sys.info())
[10:33:37.838]                   }
[10:33:37.838]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.838]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:37.838]                     cond$call), session = sessionInformation(), 
[10:33:37.838]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:37.838]                   signalCondition(cond)
[10:33:37.838]                 }
[10:33:37.838]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:37.838]                 "immediateCondition"))) {
[10:33:37.838]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:37.838]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.838]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:37.838]                   if (TRUE && !signal) {
[10:33:37.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.838]                     {
[10:33:37.838]                       inherits <- base::inherits
[10:33:37.838]                       invokeRestart <- base::invokeRestart
[10:33:37.838]                       is.null <- base::is.null
[10:33:37.838]                       muffled <- FALSE
[10:33:37.838]                       if (inherits(cond, "message")) {
[10:33:37.838]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.838]                         if (muffled) 
[10:33:37.838]                           invokeRestart("muffleMessage")
[10:33:37.838]                       }
[10:33:37.838]                       else if (inherits(cond, "warning")) {
[10:33:37.838]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.838]                         if (muffled) 
[10:33:37.838]                           invokeRestart("muffleWarning")
[10:33:37.838]                       }
[10:33:37.838]                       else if (inherits(cond, "condition")) {
[10:33:37.838]                         if (!is.null(pattern)) {
[10:33:37.838]                           computeRestarts <- base::computeRestarts
[10:33:37.838]                           grepl <- base::grepl
[10:33:37.838]                           restarts <- computeRestarts(cond)
[10:33:37.838]                           for (restart in restarts) {
[10:33:37.838]                             name <- restart$name
[10:33:37.838]                             if (is.null(name)) 
[10:33:37.838]                               next
[10:33:37.838]                             if (!grepl(pattern, name)) 
[10:33:37.838]                               next
[10:33:37.838]                             invokeRestart(restart)
[10:33:37.838]                             muffled <- TRUE
[10:33:37.838]                             break
[10:33:37.838]                           }
[10:33:37.838]                         }
[10:33:37.838]                       }
[10:33:37.838]                       invisible(muffled)
[10:33:37.838]                     }
[10:33:37.838]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.838]                   }
[10:33:37.838]                 }
[10:33:37.838]                 else {
[10:33:37.838]                   if (TRUE) {
[10:33:37.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.838]                     {
[10:33:37.838]                       inherits <- base::inherits
[10:33:37.838]                       invokeRestart <- base::invokeRestart
[10:33:37.838]                       is.null <- base::is.null
[10:33:37.838]                       muffled <- FALSE
[10:33:37.838]                       if (inherits(cond, "message")) {
[10:33:37.838]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.838]                         if (muffled) 
[10:33:37.838]                           invokeRestart("muffleMessage")
[10:33:37.838]                       }
[10:33:37.838]                       else if (inherits(cond, "warning")) {
[10:33:37.838]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.838]                         if (muffled) 
[10:33:37.838]                           invokeRestart("muffleWarning")
[10:33:37.838]                       }
[10:33:37.838]                       else if (inherits(cond, "condition")) {
[10:33:37.838]                         if (!is.null(pattern)) {
[10:33:37.838]                           computeRestarts <- base::computeRestarts
[10:33:37.838]                           grepl <- base::grepl
[10:33:37.838]                           restarts <- computeRestarts(cond)
[10:33:37.838]                           for (restart in restarts) {
[10:33:37.838]                             name <- restart$name
[10:33:37.838]                             if (is.null(name)) 
[10:33:37.838]                               next
[10:33:37.838]                             if (!grepl(pattern, name)) 
[10:33:37.838]                               next
[10:33:37.838]                             invokeRestart(restart)
[10:33:37.838]                             muffled <- TRUE
[10:33:37.838]                             break
[10:33:37.838]                           }
[10:33:37.838]                         }
[10:33:37.838]                       }
[10:33:37.838]                       invisible(muffled)
[10:33:37.838]                     }
[10:33:37.838]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.838]                   }
[10:33:37.838]                 }
[10:33:37.838]             }
[10:33:37.838]         }))
[10:33:37.838]     }, error = function(ex) {
[10:33:37.838]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:37.838]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.838]                 ...future.rng), started = ...future.startTime, 
[10:33:37.838]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:37.838]             version = "1.8"), class = "FutureResult")
[10:33:37.838]     }, finally = {
[10:33:37.838]         if (!identical(...future.workdir, getwd())) 
[10:33:37.838]             setwd(...future.workdir)
[10:33:37.838]         {
[10:33:37.838]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:37.838]                 ...future.oldOptions$nwarnings <- NULL
[10:33:37.838]             }
[10:33:37.838]             base::options(...future.oldOptions)
[10:33:37.838]             if (.Platform$OS.type == "windows") {
[10:33:37.838]                 old_names <- names(...future.oldEnvVars)
[10:33:37.838]                 envs <- base::Sys.getenv()
[10:33:37.838]                 names <- names(envs)
[10:33:37.838]                 common <- intersect(names, old_names)
[10:33:37.838]                 added <- setdiff(names, old_names)
[10:33:37.838]                 removed <- setdiff(old_names, names)
[10:33:37.838]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:37.838]                   envs[common]]
[10:33:37.838]                 NAMES <- toupper(changed)
[10:33:37.838]                 args <- list()
[10:33:37.838]                 for (kk in seq_along(NAMES)) {
[10:33:37.838]                   name <- changed[[kk]]
[10:33:37.838]                   NAME <- NAMES[[kk]]
[10:33:37.838]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.838]                     next
[10:33:37.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.838]                 }
[10:33:37.838]                 NAMES <- toupper(added)
[10:33:37.838]                 for (kk in seq_along(NAMES)) {
[10:33:37.838]                   name <- added[[kk]]
[10:33:37.838]                   NAME <- NAMES[[kk]]
[10:33:37.838]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.838]                     next
[10:33:37.838]                   args[[name]] <- ""
[10:33:37.838]                 }
[10:33:37.838]                 NAMES <- toupper(removed)
[10:33:37.838]                 for (kk in seq_along(NAMES)) {
[10:33:37.838]                   name <- removed[[kk]]
[10:33:37.838]                   NAME <- NAMES[[kk]]
[10:33:37.838]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.838]                     next
[10:33:37.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.838]                 }
[10:33:37.838]                 if (length(args) > 0) 
[10:33:37.838]                   base::do.call(base::Sys.setenv, args = args)
[10:33:37.838]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:37.838]             }
[10:33:37.838]             else {
[10:33:37.838]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:37.838]             }
[10:33:37.838]             {
[10:33:37.838]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:37.838]                   0L) {
[10:33:37.838]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:37.838]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:37.838]                   base::options(opts)
[10:33:37.838]                 }
[10:33:37.838]                 {
[10:33:37.838]                   {
[10:33:37.838]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:37.838]                     NULL
[10:33:37.838]                   }
[10:33:37.838]                   options(future.plan = NULL)
[10:33:37.838]                   if (is.na(NA_character_)) 
[10:33:37.838]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.838]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:37.838]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:37.838]                     .init = FALSE)
[10:33:37.838]                 }
[10:33:37.838]             }
[10:33:37.838]         }
[10:33:37.838]     })
[10:33:37.838]     if (TRUE) {
[10:33:37.838]         base::sink(type = "output", split = FALSE)
[10:33:37.838]         if (TRUE) {
[10:33:37.838]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:37.838]         }
[10:33:37.838]         else {
[10:33:37.838]             ...future.result["stdout"] <- base::list(NULL)
[10:33:37.838]         }
[10:33:37.838]         base::close(...future.stdout)
[10:33:37.838]         ...future.stdout <- NULL
[10:33:37.838]     }
[10:33:37.838]     ...future.result$conditions <- ...future.conditions
[10:33:37.838]     ...future.result$finished <- base::Sys.time()
[10:33:37.838]     ...future.result
[10:33:37.838] }
[10:33:37.841] assign_globals() ...
[10:33:37.841] List of 2
[10:33:37.841]  $ nested   :List of 2
[10:33:37.841]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:33:37.841]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:33:37.841]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:33:37.841]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[10:33:37.841]     envir = parent.frame())  
[10:33:37.841]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[10:33:37.841]   .. ..- attr(*, "init")= logi TRUE
[10:33:37.841]   .. ..- attr(*, "untweakable")= chr "persistent"
[10:33:37.841]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:33:37.841]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:33:37.841]  $ strategy2: chr "multisession"
[10:33:37.841]  - attr(*, "where")=List of 2
[10:33:37.841]   ..$ nested   :<environment: R_EmptyEnv> 
[10:33:37.841]   ..$ strategy2:<environment: R_EmptyEnv> 
[10:33:37.841]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:37.841]  - attr(*, "resolved")= logi FALSE
[10:33:37.841]  - attr(*, "total_size")= num 92816
[10:33:37.841]  - attr(*, "already-done")= logi TRUE
[10:33:37.847] - copied ‘nested’ to environment
[10:33:37.847] - copied ‘strategy2’ to environment
[10:33:37.847] assign_globals() ... done
[10:33:37.848] requestCore(): workers = 2
[10:33:37.850] MulticoreFuture started
[10:33:37.851] - Launch lazy future ... done
[10:33:37.851] run() for ‘MulticoreFuture’ ... done
[10:33:37.851] result() for MulticoreFuture ...
[10:33:37.852] plan(): Setting new future strategy stack:
[10:33:37.852] List of future strategies:
[10:33:37.852] 1. multisession:
[10:33:37.852]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:37.852]    - tweaked: FALSE
[10:33:37.852]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.857] plan(): nbrOfWorkers() = 1
[10:33:37.897] plan(): Setting new future strategy stack:
[10:33:37.897] List of future strategies:
[10:33:37.897] 1. multicore:
[10:33:37.897]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:37.897]    - tweaked: FALSE
[10:33:37.897]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.897] 2. multisession:
[10:33:37.897]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:37.897]    - tweaked: FALSE
[10:33:37.897]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.901] plan(): nbrOfWorkers() = 2
[10:33:37.903] result() for MulticoreFuture ...
[10:33:37.903] result() for MulticoreFuture ... done
[10:33:37.903] signalConditions() ...
[10:33:37.903]  - include = ‘immediateCondition’
[10:33:37.904]  - exclude = 
[10:33:37.904]  - resignal = FALSE
[10:33:37.904]  - Number of conditions: 54
[10:33:37.904] signalConditions() ... done
[10:33:37.904] result() for MulticoreFuture ... done
[10:33:37.905] result() for MulticoreFuture ...
[10:33:37.905] result() for MulticoreFuture ... done
[10:33:37.905] signalConditions() ...
[10:33:37.905]  - include = ‘immediateCondition’
[10:33:37.905]  - exclude = 
[10:33:37.905]  - resignal = FALSE
[10:33:37.905]  - Number of conditions: 54
[10:33:37.906] signalConditions() ... done
[10:33:37.906] Future state: ‘finished’
[10:33:37.906] result() for MulticoreFuture ...
[10:33:37.906] result() for MulticoreFuture ... done
[10:33:37.906] signalConditions() ...
[10:33:37.907]  - include = ‘condition’
[10:33:37.907]  - exclude = ‘immediateCondition’
[10:33:37.907]  - resignal = TRUE
[10:33:37.907]  - Number of conditions: 54
[10:33:37.907]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.859] getGlobalsAndPackages() ...
[10:33:37.907]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.859] Searching for globals...
[10:33:37.908]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.867] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[10:33:37.908]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.867] Searching for globals ... DONE
[10:33:37.908]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.867] Resolving globals: FALSE
[10:33:37.908]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.868] The total size of the 3 globals is 87.82 KiB (89928 bytes)
[10:33:37.908]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.869] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 87.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (43.88 KiB of class ‘list’), ‘plan_a’ (43.88 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[10:33:37.908]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.869] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[10:33:37.909]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.869] 
[10:33:37.909]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.870] getGlobalsAndPackages() ... DONE
[10:33:37.909]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.870] run() for ‘Future’ ...
[10:33:37.909]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.871] - state: ‘created’
[10:33:37.909]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.871] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:37.909]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.875] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:37.910]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.875] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:37.910]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.875]   - Field: ‘label’
[10:33:37.910]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.875]   - Field: ‘local’
[10:33:37.910]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.875]   - Field: ‘owner’
[10:33:37.910]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.875]   - Field: ‘envir’
[10:33:37.910]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.876]   - Field: ‘packages’
[10:33:37.911]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.876]   - Field: ‘gc’
[10:33:37.911]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.876]   - Field: ‘conditions’
[10:33:37.911]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.876]   - Field: ‘expr’
[10:33:37.911]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.876]   - Field: ‘uuid’
[10:33:37.911]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.876]   - Field: ‘seed’
[10:33:37.911]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.877]   - Field: ‘version’
[10:33:37.911]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.877]   - Field: ‘result’
[10:33:37.912]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.877]   - Field: ‘asynchronous’
[10:33:37.912]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.877]   - Field: ‘calls’
[10:33:37.912]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.877]   - Field: ‘globals’
[10:33:37.912]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.877]   - Field: ‘stdout’
[10:33:37.912]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.878]   - Field: ‘earlySignal’
[10:33:37.912]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.878]   - Field: ‘lazy’
[10:33:37.913]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.878]   - Field: ‘state’
[10:33:37.913]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.878] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:37.913]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.878] - Launch lazy future ...
[10:33:37.913]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.878] Packages needed by the future expression (n = 0): <none>
[10:33:37.913]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.879] Packages needed by future strategies (n = 0): <none>
[10:33:37.913]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.879] {
[10:33:37.879]     {
[10:33:37.879]         {
[10:33:37.879]             ...future.startTime <- base::Sys.time()
[10:33:37.879]             {
[10:33:37.879]                 {
[10:33:37.879]                   {
[10:33:37.879]                     base::local({
[10:33:37.879]                       has_future <- base::requireNamespace("future", 
[10:33:37.879]                         quietly = TRUE)
[10:33:37.879]                       if (has_future) {
[10:33:37.879]                         ns <- base::getNamespace("future")
[10:33:37.879]                         version <- ns[[".package"]][["version"]]
[10:33:37.879]                         if (is.null(version)) 
[10:33:37.879]                           version <- utils::packageVersion("future")
[10:33:37.879]                       }
[10:33:37.879]                       else {
[10:33:37.879]                         version <- NULL
[10:33:37.879]                       }
[10:33:37.879]                       if (!has_future || version < "1.8.0") {
[10:33:37.879]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:37.879]                           "", base::R.version$version.string), 
[10:33:37.879]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:37.879]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:37.879]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:37.879]                             "release", "version")], collapse = " "), 
[10:33:37.879]                           hostname = base::Sys.info()[["nodename"]])
[10:33:37.879]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:37.879]                           info)
[10:33:37.879]                         info <- base::paste(info, collapse = "; ")
[10:33:37.879]                         if (!has_future) {
[10:33:37.879]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:37.879]                             info)
[10:33:37.879]                         }
[10:33:37.879]                         else {
[10:33:37.879]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:37.879]                             info, version)
[10:33:37.879]                         }
[10:33:37.879]                         base::stop(msg)
[10:33:37.879]                       }
[10:33:37.879]                     })
[10:33:37.879]                   }
[10:33:37.879]                   ...future.strategy.old <- future::plan("list")
[10:33:37.879]                   options(future.plan = NULL)
[10:33:37.879]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.879]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:37.879]                 }
[10:33:37.879]                 ...future.workdir <- getwd()
[10:33:37.879]             }
[10:33:37.879]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:37.879]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:37.879]         }
[10:33:37.879]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:37.879]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:37.879]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:37.879]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:37.879]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:37.879]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:37.879]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:37.879]             base::names(...future.oldOptions))
[10:33:37.879]     }
[10:33:37.879]     if (FALSE) {
[10:33:37.879]     }
[10:33:37.879]     else {
[10:33:37.879]         if (TRUE) {
[10:33:37.879]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:37.879]                 open = "w")
[10:33:37.879]         }
[10:33:37.879]         else {
[10:33:37.879]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:37.879]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:37.879]         }
[10:33:37.879]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:37.879]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:37.879]             base::sink(type = "output", split = FALSE)
[10:33:37.879]             base::close(...future.stdout)
[10:33:37.879]         }, add = TRUE)
[10:33:37.879]     }
[10:33:37.879]     ...future.frame <- base::sys.nframe()
[10:33:37.879]     ...future.conditions <- base::list()
[10:33:37.879]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:37.879]     if (FALSE) {
[10:33:37.879]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:37.879]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:37.879]     }
[10:33:37.879]     ...future.result <- base::tryCatch({
[10:33:37.879]         base::withCallingHandlers({
[10:33:37.879]             ...future.value <- base::withVisible(base::local({
[10:33:37.879]                 b <- 2L
[10:33:37.879]                 plan_b <- future::plan("list")
[10:33:37.879]                 nested_b <- nested_a[-1]
[10:33:37.879]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:33:37.879]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:33:37.879]                   "sequential"))
[10:33:37.879]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:33:37.879]                   b = b, nested_b = nested_b, plan_b = plan_b)
[10:33:37.879]             }))
[10:33:37.879]             future::FutureResult(value = ...future.value$value, 
[10:33:37.879]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.879]                   ...future.rng), globalenv = if (FALSE) 
[10:33:37.879]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:37.879]                     ...future.globalenv.names))
[10:33:37.879]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:37.879]         }, condition = base::local({
[10:33:37.879]             c <- base::c
[10:33:37.879]             inherits <- base::inherits
[10:33:37.879]             invokeRestart <- base::invokeRestart
[10:33:37.879]             length <- base::length
[10:33:37.879]             list <- base::list
[10:33:37.879]             seq.int <- base::seq.int
[10:33:37.879]             signalCondition <- base::signalCondition
[10:33:37.879]             sys.calls <- base::sys.calls
[10:33:37.879]             `[[` <- base::`[[`
[10:33:37.879]             `+` <- base::`+`
[10:33:37.879]             `<<-` <- base::`<<-`
[10:33:37.879]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:37.879]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:37.879]                   3L)]
[10:33:37.879]             }
[10:33:37.879]             function(cond) {
[10:33:37.879]                 is_error <- inherits(cond, "error")
[10:33:37.879]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:37.879]                   NULL)
[10:33:37.879]                 if (is_error) {
[10:33:37.879]                   sessionInformation <- function() {
[10:33:37.879]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:37.879]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:37.879]                       search = base::search(), system = base::Sys.info())
[10:33:37.879]                   }
[10:33:37.879]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.879]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:37.879]                     cond$call), session = sessionInformation(), 
[10:33:37.879]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:37.879]                   signalCondition(cond)
[10:33:37.879]                 }
[10:33:37.879]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:37.879]                 "immediateCondition"))) {
[10:33:37.879]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:37.879]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.879]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:37.879]                   if (TRUE && !signal) {
[10:33:37.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.879]                     {
[10:33:37.879]                       inherits <- base::inherits
[10:33:37.879]                       invokeRestart <- base::invokeRestart
[10:33:37.879]                       is.null <- base::is.null
[10:33:37.879]                       muffled <- FALSE
[10:33:37.879]                       if (inherits(cond, "message")) {
[10:33:37.879]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.879]                         if (muffled) 
[10:33:37.879]                           invokeRestart("muffleMessage")
[10:33:37.879]                       }
[10:33:37.879]                       else if (inherits(cond, "warning")) {
[10:33:37.879]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.879]                         if (muffled) 
[10:33:37.879]                           invokeRestart("muffleWarning")
[10:33:37.879]                       }
[10:33:37.879]                       else if (inherits(cond, "condition")) {
[10:33:37.879]                         if (!is.null(pattern)) {
[10:33:37.879]                           computeRestarts <- base::computeRestarts
[10:33:37.879]                           grepl <- base::grepl
[10:33:37.879]                           restarts <- computeRestarts(cond)
[10:33:37.879]                           for (restart in restarts) {
[10:33:37.879]                             name <- restart$name
[10:33:37.879]                             if (is.null(name)) 
[10:33:37.879]                               next
[10:33:37.879]                             if (!grepl(pattern, name)) 
[10:33:37.879]                               next
[10:33:37.879]                             invokeRestart(restart)
[10:33:37.879]                             muffled <- TRUE
[10:33:37.879]                             break
[10:33:37.879]                           }
[10:33:37.879]                         }
[10:33:37.879]                       }
[10:33:37.879]                       invisible(muffled)
[10:33:37.879]                     }
[10:33:37.879]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.879]                   }
[10:33:37.879]                 }
[10:33:37.879]                 else {
[10:33:37.879]                   if (TRUE) {
[10:33:37.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.879]                     {
[10:33:37.879]                       inherits <- base::inherits
[10:33:37.879]                       invokeRestart <- base::invokeRestart
[10:33:37.879]                       is.null <- base::is.null
[10:33:37.879]                       muffled <- FALSE
[10:33:37.879]                       if (inherits(cond, "message")) {
[10:33:37.879]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.879]                         if (muffled) 
[10:33:37.879]                           invokeRestart("muffleMessage")
[10:33:37.879]                       }
[10:33:37.879]                       else if (inherits(cond, "warning")) {
[10:33:37.879]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.879]                         if (muffled) 
[10:33:37.879]                           invokeRestart("muffleWarning")
[10:33:37.879]                       }
[10:33:37.879]                       else if (inherits(cond, "condition")) {
[10:33:37.879]                         if (!is.null(pattern)) {
[10:33:37.879]                           computeRestarts <- base::computeRestarts
[10:33:37.879]                           grepl <- base::grepl
[10:33:37.879]                           restarts <- computeRestarts(cond)
[10:33:37.879]                           for (restart in restarts) {
[10:33:37.879]                             name <- restart$name
[10:33:37.879]                             if (is.null(name)) 
[10:33:37.879]                               next
[10:33:37.879]                             if (!grepl(pattern, name)) 
[10:33:37.879]                               next
[10:33:37.879]                             invokeRestart(restart)
[10:33:37.879]                             muffled <- TRUE
[10:33:37.879]                             break
[10:33:37.879]                           }
[10:33:37.879]                         }
[10:33:37.879]                       }
[10:33:37.879]                       invisible(muffled)
[10:33:37.879]                     }
[10:33:37.879]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.879]                   }
[10:33:37.879]                 }
[10:33:37.879]             }
[10:33:37.879]         }))
[10:33:37.879]     }, error = function(ex) {
[10:33:37.879]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:37.879]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.879]                 ...future.rng), started = ...future.startTime, 
[10:33:37.879]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:37.879]             version = "1.8"), class = "FutureResult")
[10:33:37.879]     }, finally = {
[10:33:37.879]         if (!identical(...future.workdir, getwd())) 
[10:33:37.879]             setwd(...future.workdir)
[10:33:37.879]         {
[10:33:37.879]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:37.879]                 ...future.oldOptions$nwarnings <- NULL
[10:33:37.879]             }
[10:33:37.879]             base::options(...future.oldOptions)
[10:33:37.879]             if (.Platform$OS.type == "windows") {
[10:33:37.879]                 old_names <- names(...future.oldEnvVars)
[10:33:37.879]                 envs <- base::Sys.getenv()
[10:33:37.879]                 names <- names(envs)
[10:33:37.879]                 common <- intersect(names, old_names)
[10:33:37.879]                 added <- setdiff(names, old_names)
[10:33:37.879]                 removed <- setdiff(old_names, names)
[10:33:37.879]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:37.879]                   envs[common]]
[10:33:37.879]                 NAMES <- toupper(changed)
[10:33:37.879]                 args <- list()
[10:33:37.879]                 for (kk in seq_along(NAMES)) {
[10:33:37.879]                   name <- changed[[kk]]
[10:33:37.879]                   NAME <- NAMES[[kk]]
[10:33:37.879]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.879]                     next
[10:33:37.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.879]                 }
[10:33:37.879]                 NAMES <- toupper(added)
[10:33:37.879]                 for (kk in seq_along(NAMES)) {
[10:33:37.879]                   name <- added[[kk]]
[10:33:37.879]                   NAME <- NAMES[[kk]]
[10:33:37.879]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.879]                     next
[10:33:37.879]                   args[[name]] <- ""
[10:33:37.879]                 }
[10:33:37.879]                 NAMES <- toupper(removed)
[10:33:37.879]                 for (kk in seq_along(NAMES)) {
[10:33:37.879]                   name <- removed[[kk]]
[10:33:37.879]                   NAME <- NAMES[[kk]]
[10:33:37.879]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.879]                     next
[10:33:37.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.879]                 }
[10:33:37.879]                 if (length(args) > 0) 
[10:33:37.879]                   base::do.call(base::Sys.setenv, args = args)
[10:33:37.879]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:37.879]             }
[10:33:37.879]             else {
[10:33:37.879]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:37.879]             }
[10:33:37.879]             {
[10:33:37.879]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:37.879]                   0L) {
[10:33:37.879]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:37.879]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:37.879]                   base::options(opts)
[10:33:37.879]                 }
[10:33:37.879]                 {
[10:33:37.879]                   {
[10:33:37.879]                     NULL
[10:33:37.879]                     RNGkind("Mersenne-Twister")
[10:33:37.879]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:37.879]                       inherits = FALSE)
[10:33:37.879]                   }
[10:33:37.879]                   options(future.plan = NULL)
[10:33:37.879]                   if (is.na(NA_character_)) 
[10:33:37.879]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.879]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:37.879]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:37.879]                     .init = FALSE)
[10:33:37.879]                 }
[10:33:37.879]             }
[10:33:37.879]         }
[10:33:37.879]     })
[10:33:37.879]     if (TRUE) {
[10:33:37.879]         base::sink(type = "output", split = FALSE)
[10:33:37.879]         if (TRUE) {
[10:33:37.879]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:37.879]         }
[10:33:37.879]         else {
[10:33:37.879]             ...future.result["stdout"] <- base::list(NULL)
[10:33:37.879]         }
[10:33:37.879]         base::close(...future.stdout)
[10:33:37.879]         ...future.stdout <- NULL
[10:33:37.879]     }
[10:33:37.879]     ...future.result$conditions <- ...future.conditions
[10:33:37.879]     ...future.result$finished <- base::Sys.time()
[10:33:37.879]     ...future.result
[10:33:37.879] }
[10:33:37.914]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.882] assign_globals() ...
[10:33:37.914]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.882] List of 3
[10:33:37.882]  $ nested_a:List of 1
[10:33:37.882]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[10:33:37.882]     envir = parent.frame())  
[10:33:37.882]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[10:33:37.882]   .. ..- attr(*, "untweakable")= chr "persistent"
[10:33:37.882]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:33:37.882]  $ a       : int 1
[10:33:37.882]  $ plan_a  :List of 1
[10:33:37.882]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[10:33:37.882]     envir = parent.frame())  
[10:33:37.882]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[10:33:37.882]   .. ..- attr(*, "untweakable")= chr "persistent"
[10:33:37.882]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:33:37.882]  - attr(*, "where")=List of 3
[10:33:37.882]   ..$ nested_a:<environment: R_EmptyEnv> 
[10:33:37.882]   ..$ a       :<environment: R_EmptyEnv> 
[10:33:37.882]   ..$ plan_a  :<environment: R_EmptyEnv> 
[10:33:37.882]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:37.882]  - attr(*, "resolved")= logi FALSE
[10:33:37.882]  - attr(*, "total_size")= num 89928
[10:33:37.882]  - attr(*, "already-done")= logi TRUE
[10:33:37.914]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.889] - copied ‘nested_a’ to environment
[10:33:37.914]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.890] - copied ‘a’ to environment
[10:33:37.914]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.890] - copied ‘plan_a’ to environment
[10:33:37.914]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.890] assign_globals() ... done
[10:33:37.915]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.890] plan(): Setting new future strategy stack:
[10:33:37.915]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.890] List of future strategies:
[10:33:37.890] 1. sequential:
[10:33:37.890]    - args: function (..., envir = parent.frame())
[10:33:37.890]    - tweaked: FALSE
[10:33:37.890]    - call: NULL
[10:33:37.915]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.891] plan(): nbrOfWorkers() = 1
[10:33:37.915]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.892] plan(): Setting new future strategy stack:
[10:33:37.915]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.892] List of future strategies:
[10:33:37.892] 1. multisession:
[10:33:37.892]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:37.892]    - tweaked: FALSE
[10:33:37.892]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.915]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.896] plan(): nbrOfWorkers() = 1
[10:33:37.915]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.896] SequentialFuture started (and completed)
[10:33:37.916]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.896] - Launch lazy future ... done
[10:33:37.916]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.897] run() for ‘SequentialFuture’ ... done
[10:33:37.916] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:33:37.923] getGlobalsAndPackages() ...
[10:33:37.923] Searching for globals...
[10:33:37.924] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:33:37.925] Searching for globals ... DONE
[10:33:37.925] Resolving globals: FALSE
[10:33:37.925] The total size of the 1 globals is 128 bytes (128 bytes)
[10:33:37.926] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:33:37.926] - globals: [1] ‘data’
[10:33:37.926] - packages: [1] ‘future’
[10:33:37.926] getGlobalsAndPackages() ... DONE
[10:33:37.927] run() for ‘Future’ ...
[10:33:37.927] - state: ‘created’
[10:33:37.927] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:37.931] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:37.931] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:37.931]   - Field: ‘label’
[10:33:37.932]   - Field: ‘local’
[10:33:37.932]   - Field: ‘owner’
[10:33:37.932]   - Field: ‘envir’
[10:33:37.932]   - Field: ‘workers’
[10:33:37.932]   - Field: ‘packages’
[10:33:37.932]   - Field: ‘gc’
[10:33:37.932]   - Field: ‘job’
[10:33:37.932]   - Field: ‘conditions’
[10:33:37.932]   - Field: ‘expr’
[10:33:37.933]   - Field: ‘uuid’
[10:33:37.933]   - Field: ‘seed’
[10:33:37.933]   - Field: ‘version’
[10:33:37.933]   - Field: ‘result’
[10:33:37.933]   - Field: ‘asynchronous’
[10:33:37.933]   - Field: ‘calls’
[10:33:37.933]   - Field: ‘globals’
[10:33:37.933]   - Field: ‘stdout’
[10:33:37.933]   - Field: ‘earlySignal’
[10:33:37.934]   - Field: ‘lazy’
[10:33:37.934]   - Field: ‘state’
[10:33:37.934] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:37.934] - Launch lazy future ...
[10:33:37.934] Packages needed by the future expression (n = 1): ‘future’
[10:33:37.934] Packages needed by future strategies (n = 1): ‘future’
[10:33:37.935] {
[10:33:37.935]     {
[10:33:37.935]         {
[10:33:37.935]             ...future.startTime <- base::Sys.time()
[10:33:37.935]             {
[10:33:37.935]                 {
[10:33:37.935]                   {
[10:33:37.935]                     {
[10:33:37.935]                       {
[10:33:37.935]                         base::local({
[10:33:37.935]                           has_future <- base::requireNamespace("future", 
[10:33:37.935]                             quietly = TRUE)
[10:33:37.935]                           if (has_future) {
[10:33:37.935]                             ns <- base::getNamespace("future")
[10:33:37.935]                             version <- ns[[".package"]][["version"]]
[10:33:37.935]                             if (is.null(version)) 
[10:33:37.935]                               version <- utils::packageVersion("future")
[10:33:37.935]                           }
[10:33:37.935]                           else {
[10:33:37.935]                             version <- NULL
[10:33:37.935]                           }
[10:33:37.935]                           if (!has_future || version < "1.8.0") {
[10:33:37.935]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:37.935]                               "", base::R.version$version.string), 
[10:33:37.935]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:37.935]                                 base::R.version$platform, 8 * 
[10:33:37.935]                                   base::.Machine$sizeof.pointer), 
[10:33:37.935]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:37.935]                                 "release", "version")], collapse = " "), 
[10:33:37.935]                               hostname = base::Sys.info()[["nodename"]])
[10:33:37.935]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:37.935]                               info)
[10:33:37.935]                             info <- base::paste(info, collapse = "; ")
[10:33:37.935]                             if (!has_future) {
[10:33:37.935]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:37.935]                                 info)
[10:33:37.935]                             }
[10:33:37.935]                             else {
[10:33:37.935]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:37.935]                                 info, version)
[10:33:37.935]                             }
[10:33:37.935]                             base::stop(msg)
[10:33:37.935]                           }
[10:33:37.935]                         })
[10:33:37.935]                       }
[10:33:37.935]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:37.935]                       base::options(mc.cores = 1L)
[10:33:37.935]                     }
[10:33:37.935]                     base::local({
[10:33:37.935]                       for (pkg in "future") {
[10:33:37.935]                         base::loadNamespace(pkg)
[10:33:37.935]                         base::library(pkg, character.only = TRUE)
[10:33:37.935]                       }
[10:33:37.935]                     })
[10:33:37.935]                   }
[10:33:37.935]                   ...future.strategy.old <- future::plan("list")
[10:33:37.935]                   options(future.plan = NULL)
[10:33:37.935]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.935]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:33:37.935]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:33:37.935]                     envir = parent.frame()) 
[10:33:37.935]                   {
[10:33:37.935]                     if (is.function(workers)) 
[10:33:37.935]                       workers <- workers()
[10:33:37.935]                     workers <- structure(as.integer(workers), 
[10:33:37.935]                       class = class(workers))
[10:33:37.935]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:33:37.935]                       workers >= 1)
[10:33:37.935]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:33:37.935]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:33:37.935]                     }
[10:33:37.935]                     future <- MultisessionFuture(..., workers = workers, 
[10:33:37.935]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:33:37.935]                       envir = envir)
[10:33:37.935]                     if (!future$lazy) 
[10:33:37.935]                       future <- run(future)
[10:33:37.935]                     invisible(future)
[10:33:37.935]                   }), .cleanup = FALSE, .init = FALSE)
[10:33:37.935]                 }
[10:33:37.935]                 ...future.workdir <- getwd()
[10:33:37.935]             }
[10:33:37.935]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:37.935]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:37.935]         }
[10:33:37.935]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:37.935]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:37.935]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:37.935]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:37.935]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:37.935]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:37.935]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:37.935]             base::names(...future.oldOptions))
[10:33:37.935]     }
[10:33:37.935]     if (FALSE) {
[10:33:37.935]     }
[10:33:37.935]     else {
[10:33:37.935]         if (TRUE) {
[10:33:37.935]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:37.935]                 open = "w")
[10:33:37.935]         }
[10:33:37.935]         else {
[10:33:37.935]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:37.935]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:37.935]         }
[10:33:37.935]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:37.935]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:37.935]             base::sink(type = "output", split = FALSE)
[10:33:37.935]             base::close(...future.stdout)
[10:33:37.935]         }, add = TRUE)
[10:33:37.935]     }
[10:33:37.935]     ...future.frame <- base::sys.nframe()
[10:33:37.935]     ...future.conditions <- base::list()
[10:33:37.935]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:37.935]     if (FALSE) {
[10:33:37.935]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:37.935]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:37.935]     }
[10:33:37.935]     ...future.result <- base::tryCatch({
[10:33:37.935]         base::withCallingHandlers({
[10:33:37.935]             ...future.value <- base::withVisible(base::local({
[10:33:37.935]                 withCallingHandlers({
[10:33:37.935]                   {
[10:33:37.935]                     value(future(subset(data, a == 2)))
[10:33:37.935]                   }
[10:33:37.935]                 }, immediateCondition = function(cond) {
[10:33:37.935]                   save_rds <- function (object, pathname, ...) 
[10:33:37.935]                   {
[10:33:37.935]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:37.935]                     if (file_test("-f", pathname_tmp)) {
[10:33:37.935]                       fi_tmp <- file.info(pathname_tmp)
[10:33:37.935]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:37.935]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:37.935]                         fi_tmp[["mtime"]])
[10:33:37.935]                     }
[10:33:37.935]                     tryCatch({
[10:33:37.935]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:37.935]                     }, error = function(ex) {
[10:33:37.935]                       msg <- conditionMessage(ex)
[10:33:37.935]                       fi_tmp <- file.info(pathname_tmp)
[10:33:37.935]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:37.935]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:37.935]                         fi_tmp[["mtime"]], msg)
[10:33:37.935]                       ex$message <- msg
[10:33:37.935]                       stop(ex)
[10:33:37.935]                     })
[10:33:37.935]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:37.935]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:37.935]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:37.935]                       fi_tmp <- file.info(pathname_tmp)
[10:33:37.935]                       fi <- file.info(pathname)
[10:33:37.935]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:37.935]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:37.935]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:37.935]                         fi[["size"]], fi[["mtime"]])
[10:33:37.935]                       stop(msg)
[10:33:37.935]                     }
[10:33:37.935]                     invisible(pathname)
[10:33:37.935]                   }
[10:33:37.935]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:37.935]                     rootPath = tempdir()) 
[10:33:37.935]                   {
[10:33:37.935]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:37.935]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:37.935]                       tmpdir = path, fileext = ".rds")
[10:33:37.935]                     save_rds(obj, file)
[10:33:37.935]                   }
[10:33:37.935]                   saveImmediateCondition(cond, path = "/tmp/RtmpTlTEh1/.future/immediateConditions")
[10:33:37.935]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.935]                   {
[10:33:37.935]                     inherits <- base::inherits
[10:33:37.935]                     invokeRestart <- base::invokeRestart
[10:33:37.935]                     is.null <- base::is.null
[10:33:37.935]                     muffled <- FALSE
[10:33:37.935]                     if (inherits(cond, "message")) {
[10:33:37.935]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:37.935]                       if (muffled) 
[10:33:37.935]                         invokeRestart("muffleMessage")
[10:33:37.935]                     }
[10:33:37.935]                     else if (inherits(cond, "warning")) {
[10:33:37.935]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:37.935]                       if (muffled) 
[10:33:37.935]                         invokeRestart("muffleWarning")
[10:33:37.935]                     }
[10:33:37.935]                     else if (inherits(cond, "condition")) {
[10:33:37.935]                       if (!is.null(pattern)) {
[10:33:37.935]                         computeRestarts <- base::computeRestarts
[10:33:37.935]                         grepl <- base::grepl
[10:33:37.935]                         restarts <- computeRestarts(cond)
[10:33:37.935]                         for (restart in restarts) {
[10:33:37.935]                           name <- restart$name
[10:33:37.935]                           if (is.null(name)) 
[10:33:37.935]                             next
[10:33:37.935]                           if (!grepl(pattern, name)) 
[10:33:37.935]                             next
[10:33:37.935]                           invokeRestart(restart)
[10:33:37.935]                           muffled <- TRUE
[10:33:37.935]                           break
[10:33:37.935]                         }
[10:33:37.935]                       }
[10:33:37.935]                     }
[10:33:37.935]                     invisible(muffled)
[10:33:37.935]                   }
[10:33:37.935]                   muffleCondition(cond)
[10:33:37.935]                 })
[10:33:37.935]             }))
[10:33:37.935]             future::FutureResult(value = ...future.value$value, 
[10:33:37.935]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.935]                   ...future.rng), globalenv = if (FALSE) 
[10:33:37.935]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:37.935]                     ...future.globalenv.names))
[10:33:37.935]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:37.935]         }, condition = base::local({
[10:33:37.935]             c <- base::c
[10:33:37.935]             inherits <- base::inherits
[10:33:37.935]             invokeRestart <- base::invokeRestart
[10:33:37.935]             length <- base::length
[10:33:37.935]             list <- base::list
[10:33:37.935]             seq.int <- base::seq.int
[10:33:37.935]             signalCondition <- base::signalCondition
[10:33:37.935]             sys.calls <- base::sys.calls
[10:33:37.935]             `[[` <- base::`[[`
[10:33:37.935]             `+` <- base::`+`
[10:33:37.935]             `<<-` <- base::`<<-`
[10:33:37.935]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:37.935]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:37.935]                   3L)]
[10:33:37.935]             }
[10:33:37.935]             function(cond) {
[10:33:37.935]                 is_error <- inherits(cond, "error")
[10:33:37.935]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:37.935]                   NULL)
[10:33:37.935]                 if (is_error) {
[10:33:37.935]                   sessionInformation <- function() {
[10:33:37.935]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:37.935]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:37.935]                       search = base::search(), system = base::Sys.info())
[10:33:37.935]                   }
[10:33:37.935]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.935]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:37.935]                     cond$call), session = sessionInformation(), 
[10:33:37.935]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:37.935]                   signalCondition(cond)
[10:33:37.935]                 }
[10:33:37.935]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:37.935]                 "immediateCondition"))) {
[10:33:37.935]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:37.935]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.935]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:37.935]                   if (TRUE && !signal) {
[10:33:37.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.935]                     {
[10:33:37.935]                       inherits <- base::inherits
[10:33:37.935]                       invokeRestart <- base::invokeRestart
[10:33:37.935]                       is.null <- base::is.null
[10:33:37.935]                       muffled <- FALSE
[10:33:37.935]                       if (inherits(cond, "message")) {
[10:33:37.935]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.935]                         if (muffled) 
[10:33:37.935]                           invokeRestart("muffleMessage")
[10:33:37.935]                       }
[10:33:37.935]                       else if (inherits(cond, "warning")) {
[10:33:37.935]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.935]                         if (muffled) 
[10:33:37.935]                           invokeRestart("muffleWarning")
[10:33:37.935]                       }
[10:33:37.935]                       else if (inherits(cond, "condition")) {
[10:33:37.935]                         if (!is.null(pattern)) {
[10:33:37.935]                           computeRestarts <- base::computeRestarts
[10:33:37.935]                           grepl <- base::grepl
[10:33:37.935]                           restarts <- computeRestarts(cond)
[10:33:37.935]                           for (restart in restarts) {
[10:33:37.935]                             name <- restart$name
[10:33:37.935]                             if (is.null(name)) 
[10:33:37.935]                               next
[10:33:37.935]                             if (!grepl(pattern, name)) 
[10:33:37.935]                               next
[10:33:37.935]                             invokeRestart(restart)
[10:33:37.935]                             muffled <- TRUE
[10:33:37.935]                             break
[10:33:37.935]                           }
[10:33:37.935]                         }
[10:33:37.935]                       }
[10:33:37.935]                       invisible(muffled)
[10:33:37.935]                     }
[10:33:37.935]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.935]                   }
[10:33:37.935]                 }
[10:33:37.935]                 else {
[10:33:37.935]                   if (TRUE) {
[10:33:37.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.935]                     {
[10:33:37.935]                       inherits <- base::inherits
[10:33:37.935]                       invokeRestart <- base::invokeRestart
[10:33:37.935]                       is.null <- base::is.null
[10:33:37.935]                       muffled <- FALSE
[10:33:37.935]                       if (inherits(cond, "message")) {
[10:33:37.935]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.935]                         if (muffled) 
[10:33:37.935]                           invokeRestart("muffleMessage")
[10:33:37.935]                       }
[10:33:37.935]                       else if (inherits(cond, "warning")) {
[10:33:37.935]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.935]                         if (muffled) 
[10:33:37.935]                           invokeRestart("muffleWarning")
[10:33:37.935]                       }
[10:33:37.935]                       else if (inherits(cond, "condition")) {
[10:33:37.935]                         if (!is.null(pattern)) {
[10:33:37.935]                           computeRestarts <- base::computeRestarts
[10:33:37.935]                           grepl <- base::grepl
[10:33:37.935]                           restarts <- computeRestarts(cond)
[10:33:37.935]                           for (restart in restarts) {
[10:33:37.935]                             name <- restart$name
[10:33:37.935]                             if (is.null(name)) 
[10:33:37.935]                               next
[10:33:37.935]                             if (!grepl(pattern, name)) 
[10:33:37.935]                               next
[10:33:37.935]                             invokeRestart(restart)
[10:33:37.935]                             muffled <- TRUE
[10:33:37.935]                             break
[10:33:37.935]                           }
[10:33:37.935]                         }
[10:33:37.935]                       }
[10:33:37.935]                       invisible(muffled)
[10:33:37.935]                     }
[10:33:37.935]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.935]                   }
[10:33:37.935]                 }
[10:33:37.935]             }
[10:33:37.935]         }))
[10:33:37.935]     }, error = function(ex) {
[10:33:37.935]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:37.935]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.935]                 ...future.rng), started = ...future.startTime, 
[10:33:37.935]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:37.935]             version = "1.8"), class = "FutureResult")
[10:33:37.935]     }, finally = {
[10:33:37.935]         if (!identical(...future.workdir, getwd())) 
[10:33:37.935]             setwd(...future.workdir)
[10:33:37.935]         {
[10:33:37.935]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:37.935]                 ...future.oldOptions$nwarnings <- NULL
[10:33:37.935]             }
[10:33:37.935]             base::options(...future.oldOptions)
[10:33:37.935]             if (.Platform$OS.type == "windows") {
[10:33:37.935]                 old_names <- names(...future.oldEnvVars)
[10:33:37.935]                 envs <- base::Sys.getenv()
[10:33:37.935]                 names <- names(envs)
[10:33:37.935]                 common <- intersect(names, old_names)
[10:33:37.935]                 added <- setdiff(names, old_names)
[10:33:37.935]                 removed <- setdiff(old_names, names)
[10:33:37.935]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:37.935]                   envs[common]]
[10:33:37.935]                 NAMES <- toupper(changed)
[10:33:37.935]                 args <- list()
[10:33:37.935]                 for (kk in seq_along(NAMES)) {
[10:33:37.935]                   name <- changed[[kk]]
[10:33:37.935]                   NAME <- NAMES[[kk]]
[10:33:37.935]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.935]                     next
[10:33:37.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.935]                 }
[10:33:37.935]                 NAMES <- toupper(added)
[10:33:37.935]                 for (kk in seq_along(NAMES)) {
[10:33:37.935]                   name <- added[[kk]]
[10:33:37.935]                   NAME <- NAMES[[kk]]
[10:33:37.935]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.935]                     next
[10:33:37.935]                   args[[name]] <- ""
[10:33:37.935]                 }
[10:33:37.935]                 NAMES <- toupper(removed)
[10:33:37.935]                 for (kk in seq_along(NAMES)) {
[10:33:37.935]                   name <- removed[[kk]]
[10:33:37.935]                   NAME <- NAMES[[kk]]
[10:33:37.935]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.935]                     next
[10:33:37.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.935]                 }
[10:33:37.935]                 if (length(args) > 0) 
[10:33:37.935]                   base::do.call(base::Sys.setenv, args = args)
[10:33:37.935]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:37.935]             }
[10:33:37.935]             else {
[10:33:37.935]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:37.935]             }
[10:33:37.935]             {
[10:33:37.935]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:37.935]                   0L) {
[10:33:37.935]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:37.935]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:37.935]                   base::options(opts)
[10:33:37.935]                 }
[10:33:37.935]                 {
[10:33:37.935]                   {
[10:33:37.935]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:37.935]                     NULL
[10:33:37.935]                   }
[10:33:37.935]                   options(future.plan = NULL)
[10:33:37.935]                   if (is.na(NA_character_)) 
[10:33:37.935]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.935]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:37.935]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:37.935]                     .init = FALSE)
[10:33:37.935]                 }
[10:33:37.935]             }
[10:33:37.935]         }
[10:33:37.935]     })
[10:33:37.935]     if (TRUE) {
[10:33:37.935]         base::sink(type = "output", split = FALSE)
[10:33:37.935]         if (TRUE) {
[10:33:37.935]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:37.935]         }
[10:33:37.935]         else {
[10:33:37.935]             ...future.result["stdout"] <- base::list(NULL)
[10:33:37.935]         }
[10:33:37.935]         base::close(...future.stdout)
[10:33:37.935]         ...future.stdout <- NULL
[10:33:37.935]     }
[10:33:37.935]     ...future.result$conditions <- ...future.conditions
[10:33:37.935]     ...future.result$finished <- base::Sys.time()
[10:33:37.935]     ...future.result
[10:33:37.935] }
[10:33:37.938] assign_globals() ...
[10:33:37.938] List of 1
[10:33:37.938]  $ data:'data.frame':	3 obs. of  2 variables:
[10:33:37.938]   ..$ a: int [1:3] 1 2 3
[10:33:37.938]   ..$ b: int [1:3] 3 2 1
[10:33:37.938]  - attr(*, "where")=List of 1
[10:33:37.938]   ..$ data:<environment: R_EmptyEnv> 
[10:33:37.938]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:37.938]  - attr(*, "resolved")= logi FALSE
[10:33:37.938]  - attr(*, "total_size")= num 128
[10:33:37.938]  - attr(*, "already-done")= logi TRUE
[10:33:37.941] - copied ‘data’ to environment
[10:33:37.942] assign_globals() ... done
[10:33:37.942] requestCore(): workers = 2
[10:33:37.944] MulticoreFuture started
[10:33:37.944] - Launch lazy future ... done
[10:33:37.944] run() for ‘MulticoreFuture’ ... done
[10:33:37.945] result() for MulticoreFuture ...
[10:33:37.945] plan(): Setting new future strategy stack:
[10:33:37.946] List of future strategies:
[10:33:37.946] 1. multisession:
[10:33:37.946]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:37.946]    - tweaked: FALSE
[10:33:37.946]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.956] plan(): nbrOfWorkers() = 1
[10:33:37.986] plan(): Setting new future strategy stack:
[10:33:37.986] List of future strategies:
[10:33:37.986] 1. multicore:
[10:33:37.986]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:37.986]    - tweaked: FALSE
[10:33:37.986]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.986] 2. multisession:
[10:33:37.986]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:37.986]    - tweaked: FALSE
[10:33:37.986]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:37.990] plan(): nbrOfWorkers() = 2
[10:33:37.991] result() for MulticoreFuture ...
[10:33:37.995] result() for MulticoreFuture ... done
[10:33:37.995] signalConditions() ...
[10:33:37.995]  - include = ‘immediateCondition’
[10:33:37.995]  - exclude = 
[10:33:37.995]  - resignal = FALSE
[10:33:37.995]  - Number of conditions: 52
[10:33:37.996] signalConditions() ... done
[10:33:37.996] result() for MulticoreFuture ... done
[10:33:37.996] result() for MulticoreFuture ...
[10:33:37.996] result() for MulticoreFuture ... done
[10:33:37.996] signalConditions() ...
[10:33:37.996]  - include = ‘immediateCondition’
[10:33:37.996]  - exclude = 
[10:33:37.996]  - resignal = FALSE
[10:33:37.996]  - Number of conditions: 52
[10:33:37.997] signalConditions() ... done
[10:33:37.997] Future state: ‘finished’
[10:33:37.997] result() for MulticoreFuture ...
[10:33:37.997] result() for MulticoreFuture ... done
[10:33:37.997] signalConditions() ...
[10:33:37.997]  - include = ‘condition’
[10:33:37.997]  - exclude = ‘immediateCondition’
[10:33:37.998]  - resignal = TRUE
[10:33:37.998]  - Number of conditions: 52
[10:33:37.998]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.957] getGlobalsAndPackages() ...
[10:33:37.998]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.957] Searching for globals...
[10:33:37.998]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.959] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[10:33:37.998]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.959] Searching for globals ... DONE
[10:33:37.998]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.959] Resolving globals: FALSE
[10:33:37.999]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.960] The total size of the 1 globals is 128 bytes (128 bytes)
[10:33:37.999]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.961] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:33:37.999]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.961] - globals: [1] ‘data’
[10:33:37.999]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.961] 
[10:33:37.999]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.962] getGlobalsAndPackages() ... DONE
[10:33:37.999]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.962] run() for ‘Future’ ...
[10:33:38.000]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.962] - state: ‘created’
[10:33:38.000]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.963] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:38.000]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.966] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:38.000]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.967] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:38.000]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.967]   - Field: ‘label’
[10:33:38.000]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.967]   - Field: ‘local’
[10:33:38.000]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.967]   - Field: ‘owner’
[10:33:38.001]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.967]   - Field: ‘envir’
[10:33:38.001]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.968]   - Field: ‘packages’
[10:33:38.001]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.968]   - Field: ‘gc’
[10:33:38.001]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.968]   - Field: ‘conditions’
[10:33:38.001]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.968]   - Field: ‘expr’
[10:33:38.001]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.968]   - Field: ‘uuid’
[10:33:38.002]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.968]   - Field: ‘seed’
[10:33:38.002]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.969]   - Field: ‘version’
[10:33:38.002]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.969]   - Field: ‘result’
[10:33:38.002]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.969]   - Field: ‘asynchronous’
[10:33:38.002]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.969]   - Field: ‘calls’
[10:33:38.002]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.969]   - Field: ‘globals’
[10:33:38.003]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.969]   - Field: ‘stdout’
[10:33:38.003]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.970]   - Field: ‘earlySignal’
[10:33:38.003]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.970]   - Field: ‘lazy’
[10:33:38.003]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.970]   - Field: ‘state’
[10:33:38.003]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.970] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:38.003]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.970] - Launch lazy future ...
[10:33:38.004]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.971] Packages needed by the future expression (n = 0): <none>
[10:33:38.004]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.971] Packages needed by future strategies (n = 0): <none>
[10:33:38.004]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.972] {
[10:33:37.972]     {
[10:33:37.972]         {
[10:33:37.972]             ...future.startTime <- base::Sys.time()
[10:33:37.972]             {
[10:33:37.972]                 {
[10:33:37.972]                   {
[10:33:37.972]                     base::local({
[10:33:37.972]                       has_future <- base::requireNamespace("future", 
[10:33:37.972]                         quietly = TRUE)
[10:33:37.972]                       if (has_future) {
[10:33:37.972]                         ns <- base::getNamespace("future")
[10:33:37.972]                         version <- ns[[".package"]][["version"]]
[10:33:37.972]                         if (is.null(version)) 
[10:33:37.972]                           version <- utils::packageVersion("future")
[10:33:37.972]                       }
[10:33:37.972]                       else {
[10:33:37.972]                         version <- NULL
[10:33:37.972]                       }
[10:33:37.972]                       if (!has_future || version < "1.8.0") {
[10:33:37.972]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:37.972]                           "", base::R.version$version.string), 
[10:33:37.972]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:37.972]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:37.972]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:37.972]                             "release", "version")], collapse = " "), 
[10:33:37.972]                           hostname = base::Sys.info()[["nodename"]])
[10:33:37.972]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:37.972]                           info)
[10:33:37.972]                         info <- base::paste(info, collapse = "; ")
[10:33:37.972]                         if (!has_future) {
[10:33:37.972]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:37.972]                             info)
[10:33:37.972]                         }
[10:33:37.972]                         else {
[10:33:37.972]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:37.972]                             info, version)
[10:33:37.972]                         }
[10:33:37.972]                         base::stop(msg)
[10:33:37.972]                       }
[10:33:37.972]                     })
[10:33:37.972]                   }
[10:33:37.972]                   ...future.strategy.old <- future::plan("list")
[10:33:37.972]                   options(future.plan = NULL)
[10:33:37.972]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.972]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:37.972]                 }
[10:33:37.972]                 ...future.workdir <- getwd()
[10:33:37.972]             }
[10:33:37.972]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:37.972]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:37.972]         }
[10:33:37.972]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:37.972]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:37.972]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:37.972]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:37.972]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:37.972]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:37.972]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:37.972]             base::names(...future.oldOptions))
[10:33:37.972]     }
[10:33:37.972]     if (FALSE) {
[10:33:37.972]     }
[10:33:37.972]     else {
[10:33:37.972]         if (TRUE) {
[10:33:37.972]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:37.972]                 open = "w")
[10:33:37.972]         }
[10:33:37.972]         else {
[10:33:37.972]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:37.972]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:37.972]         }
[10:33:37.972]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:37.972]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:37.972]             base::sink(type = "output", split = FALSE)
[10:33:37.972]             base::close(...future.stdout)
[10:33:37.972]         }, add = TRUE)
[10:33:37.972]     }
[10:33:37.972]     ...future.frame <- base::sys.nframe()
[10:33:37.972]     ...future.conditions <- base::list()
[10:33:37.972]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:37.972]     if (FALSE) {
[10:33:37.972]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:37.972]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:37.972]     }
[10:33:37.972]     ...future.result <- base::tryCatch({
[10:33:37.972]         base::withCallingHandlers({
[10:33:37.972]             ...future.value <- base::withVisible(base::local(subset(data, 
[10:33:37.972]                 a == 2)))
[10:33:37.972]             future::FutureResult(value = ...future.value$value, 
[10:33:37.972]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.972]                   ...future.rng), globalenv = if (FALSE) 
[10:33:37.972]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:37.972]                     ...future.globalenv.names))
[10:33:37.972]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:37.972]         }, condition = base::local({
[10:33:37.972]             c <- base::c
[10:33:37.972]             inherits <- base::inherits
[10:33:37.972]             invokeRestart <- base::invokeRestart
[10:33:37.972]             length <- base::length
[10:33:37.972]             list <- base::list
[10:33:37.972]             seq.int <- base::seq.int
[10:33:37.972]             signalCondition <- base::signalCondition
[10:33:37.972]             sys.calls <- base::sys.calls
[10:33:37.972]             `[[` <- base::`[[`
[10:33:37.972]             `+` <- base::`+`
[10:33:37.972]             `<<-` <- base::`<<-`
[10:33:37.972]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:37.972]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:37.972]                   3L)]
[10:33:37.972]             }
[10:33:37.972]             function(cond) {
[10:33:37.972]                 is_error <- inherits(cond, "error")
[10:33:37.972]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:37.972]                   NULL)
[10:33:37.972]                 if (is_error) {
[10:33:37.972]                   sessionInformation <- function() {
[10:33:37.972]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:37.972]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:37.972]                       search = base::search(), system = base::Sys.info())
[10:33:37.972]                   }
[10:33:37.972]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.972]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:37.972]                     cond$call), session = sessionInformation(), 
[10:33:37.972]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:37.972]                   signalCondition(cond)
[10:33:37.972]                 }
[10:33:37.972]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:37.972]                 "immediateCondition"))) {
[10:33:37.972]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:37.972]                   ...future.conditions[[length(...future.conditions) + 
[10:33:37.972]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:37.972]                   if (TRUE && !signal) {
[10:33:37.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.972]                     {
[10:33:37.972]                       inherits <- base::inherits
[10:33:37.972]                       invokeRestart <- base::invokeRestart
[10:33:37.972]                       is.null <- base::is.null
[10:33:37.972]                       muffled <- FALSE
[10:33:37.972]                       if (inherits(cond, "message")) {
[10:33:37.972]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.972]                         if (muffled) 
[10:33:37.972]                           invokeRestart("muffleMessage")
[10:33:37.972]                       }
[10:33:37.972]                       else if (inherits(cond, "warning")) {
[10:33:37.972]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.972]                         if (muffled) 
[10:33:37.972]                           invokeRestart("muffleWarning")
[10:33:37.972]                       }
[10:33:37.972]                       else if (inherits(cond, "condition")) {
[10:33:37.972]                         if (!is.null(pattern)) {
[10:33:37.972]                           computeRestarts <- base::computeRestarts
[10:33:37.972]                           grepl <- base::grepl
[10:33:37.972]                           restarts <- computeRestarts(cond)
[10:33:37.972]                           for (restart in restarts) {
[10:33:37.972]                             name <- restart$name
[10:33:37.972]                             if (is.null(name)) 
[10:33:37.972]                               next
[10:33:37.972]                             if (!grepl(pattern, name)) 
[10:33:37.972]                               next
[10:33:37.972]                             invokeRestart(restart)
[10:33:37.972]                             muffled <- TRUE
[10:33:37.972]                             break
[10:33:37.972]                           }
[10:33:37.972]                         }
[10:33:37.972]                       }
[10:33:37.972]                       invisible(muffled)
[10:33:37.972]                     }
[10:33:37.972]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.972]                   }
[10:33:37.972]                 }
[10:33:37.972]                 else {
[10:33:37.972]                   if (TRUE) {
[10:33:37.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:37.972]                     {
[10:33:37.972]                       inherits <- base::inherits
[10:33:37.972]                       invokeRestart <- base::invokeRestart
[10:33:37.972]                       is.null <- base::is.null
[10:33:37.972]                       muffled <- FALSE
[10:33:37.972]                       if (inherits(cond, "message")) {
[10:33:37.972]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:37.972]                         if (muffled) 
[10:33:37.972]                           invokeRestart("muffleMessage")
[10:33:37.972]                       }
[10:33:37.972]                       else if (inherits(cond, "warning")) {
[10:33:37.972]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:37.972]                         if (muffled) 
[10:33:37.972]                           invokeRestart("muffleWarning")
[10:33:37.972]                       }
[10:33:37.972]                       else if (inherits(cond, "condition")) {
[10:33:37.972]                         if (!is.null(pattern)) {
[10:33:37.972]                           computeRestarts <- base::computeRestarts
[10:33:37.972]                           grepl <- base::grepl
[10:33:37.972]                           restarts <- computeRestarts(cond)
[10:33:37.972]                           for (restart in restarts) {
[10:33:37.972]                             name <- restart$name
[10:33:37.972]                             if (is.null(name)) 
[10:33:37.972]                               next
[10:33:37.972]                             if (!grepl(pattern, name)) 
[10:33:37.972]                               next
[10:33:37.972]                             invokeRestart(restart)
[10:33:37.972]                             muffled <- TRUE
[10:33:37.972]                             break
[10:33:37.972]                           }
[10:33:37.972]                         }
[10:33:37.972]                       }
[10:33:37.972]                       invisible(muffled)
[10:33:37.972]                     }
[10:33:37.972]                     muffleCondition(cond, pattern = "^muffle")
[10:33:37.972]                   }
[10:33:37.972]                 }
[10:33:37.972]             }
[10:33:37.972]         }))
[10:33:37.972]     }, error = function(ex) {
[10:33:37.972]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:37.972]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:37.972]                 ...future.rng), started = ...future.startTime, 
[10:33:37.972]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:37.972]             version = "1.8"), class = "FutureResult")
[10:33:37.972]     }, finally = {
[10:33:37.972]         if (!identical(...future.workdir, getwd())) 
[10:33:37.972]             setwd(...future.workdir)
[10:33:37.972]         {
[10:33:37.972]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:37.972]                 ...future.oldOptions$nwarnings <- NULL
[10:33:37.972]             }
[10:33:37.972]             base::options(...future.oldOptions)
[10:33:37.972]             if (.Platform$OS.type == "windows") {
[10:33:37.972]                 old_names <- names(...future.oldEnvVars)
[10:33:37.972]                 envs <- base::Sys.getenv()
[10:33:37.972]                 names <- names(envs)
[10:33:37.972]                 common <- intersect(names, old_names)
[10:33:37.972]                 added <- setdiff(names, old_names)
[10:33:37.972]                 removed <- setdiff(old_names, names)
[10:33:37.972]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:37.972]                   envs[common]]
[10:33:37.972]                 NAMES <- toupper(changed)
[10:33:37.972]                 args <- list()
[10:33:37.972]                 for (kk in seq_along(NAMES)) {
[10:33:37.972]                   name <- changed[[kk]]
[10:33:37.972]                   NAME <- NAMES[[kk]]
[10:33:37.972]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.972]                     next
[10:33:37.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.972]                 }
[10:33:37.972]                 NAMES <- toupper(added)
[10:33:37.972]                 for (kk in seq_along(NAMES)) {
[10:33:37.972]                   name <- added[[kk]]
[10:33:37.972]                   NAME <- NAMES[[kk]]
[10:33:37.972]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.972]                     next
[10:33:37.972]                   args[[name]] <- ""
[10:33:37.972]                 }
[10:33:37.972]                 NAMES <- toupper(removed)
[10:33:37.972]                 for (kk in seq_along(NAMES)) {
[10:33:37.972]                   name <- removed[[kk]]
[10:33:37.972]                   NAME <- NAMES[[kk]]
[10:33:37.972]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:37.972]                     next
[10:33:37.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:37.972]                 }
[10:33:37.972]                 if (length(args) > 0) 
[10:33:37.972]                   base::do.call(base::Sys.setenv, args = args)
[10:33:37.972]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:37.972]             }
[10:33:37.972]             else {
[10:33:37.972]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:37.972]             }
[10:33:37.972]             {
[10:33:37.972]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:37.972]                   0L) {
[10:33:37.972]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:37.972]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:37.972]                   base::options(opts)
[10:33:37.972]                 }
[10:33:37.972]                 {
[10:33:37.972]                   {
[10:33:37.972]                     NULL
[10:33:37.972]                     RNGkind("Mersenne-Twister")
[10:33:37.972]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:37.972]                       inherits = FALSE)
[10:33:37.972]                   }
[10:33:37.972]                   options(future.plan = NULL)
[10:33:37.972]                   if (is.na(NA_character_)) 
[10:33:37.972]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:37.972]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:37.972]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:37.972]                     .init = FALSE)
[10:33:37.972]                 }
[10:33:37.972]             }
[10:33:37.972]         }
[10:33:37.972]     })
[10:33:37.972]     if (TRUE) {
[10:33:37.972]         base::sink(type = "output", split = FALSE)
[10:33:37.972]         if (TRUE) {
[10:33:37.972]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:37.972]         }
[10:33:37.972]         else {
[10:33:37.972]             ...future.result["stdout"] <- base::list(NULL)
[10:33:37.972]         }
[10:33:37.972]         base::close(...future.stdout)
[10:33:37.972]         ...future.stdout <- NULL
[10:33:37.972]     }
[10:33:37.972]     ...future.result$conditions <- ...future.conditions
[10:33:37.972]     ...future.result$finished <- base::Sys.time()
[10:33:37.972]     ...future.result
[10:33:37.972] }
[10:33:38.004]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.974] assign_globals() ...
[10:33:38.004]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.974] List of 1
[10:33:37.974]  $ data:'data.frame':	3 obs. of  2 variables:
[10:33:37.974]   ..$ a: int [1:3] 1 2 3
[10:33:37.974]   ..$ b: int [1:3] 3 2 1
[10:33:37.974]  - attr(*, "where")=List of 1
[10:33:37.974]   ..$ data:<environment: R_EmptyEnv> 
[10:33:37.974]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:37.974]  - attr(*, "resolved")= logi FALSE
[10:33:37.974]  - attr(*, "total_size")= num 128
[10:33:37.974]  - attr(*, "already-done")= logi TRUE
[10:33:38.004]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.978] - copied ‘data’ to environment
[10:33:38.005]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.979] assign_globals() ... done
[10:33:38.005]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.979] plan(): Setting new future strategy stack:
[10:33:38.005]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.979] List of future strategies:
[10:33:37.979] 1. sequential:
[10:33:37.979]    - args: function (..., envir = parent.frame())
[10:33:37.979]    - tweaked: FALSE
[10:33:37.979]    - call: NULL
[10:33:38.005]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.980] plan(): nbrOfWorkers() = 1
[10:33:38.005]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.981] plan(): Setting new future strategy stack:
[10:33:38.005]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.981] List of future strategies:
[10:33:37.981] 1. multisession:
[10:33:37.981]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:37.981]    - tweaked: FALSE
[10:33:37.981]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:38.006]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.985] plan(): nbrOfWorkers() = 1
[10:33:38.006]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.985] SequentialFuture started (and completed)
[10:33:38.006]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.985] - Launch lazy future ... done
[10:33:38.006]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:33:37.985] run() for ‘SequentialFuture’ ... done
[10:33:38.006] signalConditions() ... done
- plan(list('multicore', 'multisession')) ... DONE
- plan(list('multisession', 'sequential')) ...
[10:33:38.007] plan(): Setting new future strategy stack:
[10:33:38.007] List of future strategies:
[10:33:38.007] 1. multisession:
[10:33:38.007]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:38.007]    - tweaked: FALSE
[10:33:38.007]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:38.007] 2. sequential:
[10:33:38.007]    - args: function (..., envir = parent.frame())
[10:33:38.007]    - tweaked: FALSE
[10:33:38.007]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:38.007] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:33:38.008] multisession:
[10:33:38.008] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:38.008] - tweaked: FALSE
[10:33:38.008] - call: plan(list(a = strategy1, b = strategy2))
[10:33:38.012] getGlobalsAndPackages() ...
[10:33:38.012] Not searching for globals
[10:33:38.012] - globals: [0] <none>
[10:33:38.012] getGlobalsAndPackages() ... DONE
[10:33:38.013] [local output] makeClusterPSOCK() ...
[10:33:38.016] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:33:38.017] [local output] Base port: 11652
[10:33:38.017] [local output] Getting setup options for 2 cluster nodes ...
[10:33:38.017] [local output]  - Node 1 of 2 ...
[10:33:38.017] [local output] localMachine=TRUE => revtunnel=FALSE

[10:33:38.018] [local output] Rscript port: 11652

[10:33:38.018] [local output]  - Node 2 of 2 ...
[10:33:38.019] [local output] localMachine=TRUE => revtunnel=FALSE

[10:33:38.019] [local output] Rscript port: 11652

[10:33:38.020] [local output] Getting setup options for 2 cluster nodes ... done
[10:33:38.020] [local output]  - Parallel setup requested for some PSOCK nodes
[10:33:38.020] [local output] Setting up PSOCK nodes in parallel
[10:33:38.020] List of 36
[10:33:38.020]  $ worker          : chr "localhost"
[10:33:38.020]   ..- attr(*, "localhost")= logi TRUE
[10:33:38.020]  $ master          : chr "localhost"
[10:33:38.020]  $ port            : int 11652
[10:33:38.020]  $ connectTimeout  : num 120
[10:33:38.020]  $ timeout         : num 2592000
[10:33:38.020]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:33:38.020]  $ homogeneous     : logi TRUE
[10:33:38.020]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:33:38.020]  $ rscript_envs    : NULL
[10:33:38.020]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:33:38.020]  $ rscript_startup : NULL
[10:33:38.020]  $ rscript_sh      : chr "sh"
[10:33:38.020]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:33:38.020]  $ methods         : logi TRUE
[10:33:38.020]  $ socketOptions   : chr "no-delay"
[10:33:38.020]  $ useXDR          : logi FALSE
[10:33:38.020]  $ outfile         : chr "/dev/null"
[10:33:38.020]  $ renice          : int NA
[10:33:38.020]  $ rshcmd          : NULL
[10:33:38.020]  $ user            : chr(0) 
[10:33:38.020]  $ revtunnel       : logi FALSE
[10:33:38.020]  $ rshlogfile      : NULL
[10:33:38.020]  $ rshopts         : chr(0) 
[10:33:38.020]  $ rank            : int 1
[10:33:38.020]  $ manual          : logi FALSE
[10:33:38.020]  $ dryrun          : logi FALSE
[10:33:38.020]  $ quiet           : logi FALSE
[10:33:38.020]  $ setup_strategy  : chr "parallel"
[10:33:38.020]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:33:38.020]  $ pidfile         : chr "/tmp/RtmpTlTEh1/worker.rank=1.parallelly.parent=87069.1541d6c382eaf.pid"
[10:33:38.020]  $ rshcmd_label    : NULL
[10:33:38.020]  $ rsh_call        : NULL
[10:33:38.020]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:33:38.020]  $ localMachine    : logi TRUE
[10:33:38.020]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:33:38.020]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:33:38.020]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:33:38.020]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:33:38.020]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:33:38.020]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:33:38.020]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:33:38.020]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:33:38.020]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:33:38.020]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:33:38.020]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:33:38.020]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:33:38.020]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:33:38.020]  $ arguments       :List of 28
[10:33:38.020]   ..$ worker          : chr "localhost"
[10:33:38.020]   ..$ master          : NULL
[10:33:38.020]   ..$ port            : int 11652
[10:33:38.020]   ..$ connectTimeout  : num 120
[10:33:38.020]   ..$ timeout         : num 2592000
[10:33:38.020]   ..$ rscript         : NULL
[10:33:38.020]   ..$ homogeneous     : NULL
[10:33:38.020]   ..$ rscript_args    : NULL
[10:33:38.020]   ..$ rscript_envs    : NULL
[10:33:38.020]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:33:38.020]   ..$ rscript_startup : NULL
[10:33:38.020]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:33:38.020]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:33:38.020]   ..$ methods         : logi TRUE
[10:33:38.020]   ..$ socketOptions   : chr "no-delay"
[10:33:38.020]   ..$ useXDR          : logi FALSE
[10:33:38.020]   ..$ outfile         : chr "/dev/null"
[10:33:38.020]   ..$ renice          : int NA
[10:33:38.020]   ..$ rshcmd          : NULL
[10:33:38.020]   ..$ user            : NULL
[10:33:38.020]   ..$ revtunnel       : logi NA
[10:33:38.020]   ..$ rshlogfile      : NULL
[10:33:38.020]   ..$ rshopts         : NULL
[10:33:38.020]   ..$ rank            : int 1
[10:33:38.020]   ..$ manual          : logi FALSE
[10:33:38.020]   ..$ dryrun          : logi FALSE
[10:33:38.020]   ..$ quiet           : logi FALSE
[10:33:38.020]   ..$ setup_strategy  : chr "parallel"
[10:33:38.020]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:33:38.041] [local output] System call to launch all workers:
[10:33:38.041] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpTlTEh1/worker.rank=1.parallelly.parent=87069.1541d6c382eaf.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11652 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:33:38.041] [local output] Starting PSOCK main server
[10:33:38.042] [local output] Workers launched
[10:33:38.043] [local output] Waiting for workers to connect back
[10:33:38.043]  - [local output] 0 workers out of 2 ready
[10:33:38.285]  - [local output] 0 workers out of 2 ready
[10:33:38.286]  - [local output] 1 workers out of 2 ready
[10:33:38.286]  - [local output] 2 workers out of 2 ready
[10:33:38.286] [local output] Launching of workers completed
[10:33:38.287] [local output] Collecting session information from workers
[10:33:38.287] [local output]  - Worker #1 of 2
[10:33:38.288] [local output]  - Worker #2 of 2
[10:33:38.288] [local output] makeClusterPSOCK() ... done
[10:33:38.299] Packages needed by the future expression (n = 0): <none>
[10:33:38.299] Packages needed by future strategies (n = 1): ‘future’
[10:33:38.300] {
[10:33:38.300]     {
[10:33:38.300]         {
[10:33:38.300]             ...future.startTime <- base::Sys.time()
[10:33:38.300]             {
[10:33:38.300]                 {
[10:33:38.300]                   {
[10:33:38.300]                     {
[10:33:38.300]                       {
[10:33:38.300]                         base::local({
[10:33:38.300]                           has_future <- base::requireNamespace("future", 
[10:33:38.300]                             quietly = TRUE)
[10:33:38.300]                           if (has_future) {
[10:33:38.300]                             ns <- base::getNamespace("future")
[10:33:38.300]                             version <- ns[[".package"]][["version"]]
[10:33:38.300]                             if (is.null(version)) 
[10:33:38.300]                               version <- utils::packageVersion("future")
[10:33:38.300]                           }
[10:33:38.300]                           else {
[10:33:38.300]                             version <- NULL
[10:33:38.300]                           }
[10:33:38.300]                           if (!has_future || version < "1.8.0") {
[10:33:38.300]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:38.300]                               "", base::R.version$version.string), 
[10:33:38.300]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:38.300]                                 base::R.version$platform, 8 * 
[10:33:38.300]                                   base::.Machine$sizeof.pointer), 
[10:33:38.300]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:38.300]                                 "release", "version")], collapse = " "), 
[10:33:38.300]                               hostname = base::Sys.info()[["nodename"]])
[10:33:38.300]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:38.300]                               info)
[10:33:38.300]                             info <- base::paste(info, collapse = "; ")
[10:33:38.300]                             if (!has_future) {
[10:33:38.300]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:38.300]                                 info)
[10:33:38.300]                             }
[10:33:38.300]                             else {
[10:33:38.300]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:38.300]                                 info, version)
[10:33:38.300]                             }
[10:33:38.300]                             base::stop(msg)
[10:33:38.300]                           }
[10:33:38.300]                         })
[10:33:38.300]                       }
[10:33:38.300]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:38.300]                       base::options(mc.cores = 1L)
[10:33:38.300]                     }
[10:33:38.300]                     base::local({
[10:33:38.300]                       for (pkg in "future") {
[10:33:38.300]                         base::loadNamespace(pkg)
[10:33:38.300]                         base::library(pkg, character.only = TRUE)
[10:33:38.300]                       }
[10:33:38.300]                     })
[10:33:38.300]                   }
[10:33:38.300]                   ...future.strategy.old <- future::plan("list")
[10:33:38.300]                   options(future.plan = NULL)
[10:33:38.300]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:38.300]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:33:38.300]                   {
[10:33:38.300]                     future <- SequentialFuture(..., envir = envir)
[10:33:38.300]                     if (!future$lazy) 
[10:33:38.300]                       future <- run(future)
[10:33:38.300]                     invisible(future)
[10:33:38.300]                   }), .cleanup = FALSE, .init = FALSE)
[10:33:38.300]                 }
[10:33:38.300]                 ...future.workdir <- getwd()
[10:33:38.300]             }
[10:33:38.300]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:38.300]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:38.300]         }
[10:33:38.300]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:38.300]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:38.300]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:38.300]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:38.300]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:38.300]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:38.300]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:38.300]             base::names(...future.oldOptions))
[10:33:38.300]     }
[10:33:38.300]     if (FALSE) {
[10:33:38.300]     }
[10:33:38.300]     else {
[10:33:38.300]         if (TRUE) {
[10:33:38.300]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:38.300]                 open = "w")
[10:33:38.300]         }
[10:33:38.300]         else {
[10:33:38.300]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:38.300]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:38.300]         }
[10:33:38.300]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:38.300]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:38.300]             base::sink(type = "output", split = FALSE)
[10:33:38.300]             base::close(...future.stdout)
[10:33:38.300]         }, add = TRUE)
[10:33:38.300]     }
[10:33:38.300]     ...future.frame <- base::sys.nframe()
[10:33:38.300]     ...future.conditions <- base::list()
[10:33:38.300]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:38.300]     if (FALSE) {
[10:33:38.300]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:38.300]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:38.300]     }
[10:33:38.300]     ...future.result <- base::tryCatch({
[10:33:38.300]         base::withCallingHandlers({
[10:33:38.300]             ...future.value <- base::withVisible(base::local({
[10:33:38.300]                 ...future.makeSendCondition <- base::local({
[10:33:38.300]                   sendCondition <- NULL
[10:33:38.300]                   function(frame = 1L) {
[10:33:38.300]                     if (is.function(sendCondition)) 
[10:33:38.300]                       return(sendCondition)
[10:33:38.300]                     ns <- getNamespace("parallel")
[10:33:38.300]                     if (exists("sendData", mode = "function", 
[10:33:38.300]                       envir = ns)) {
[10:33:38.300]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:38.300]                         envir = ns)
[10:33:38.300]                       envir <- sys.frame(frame)
[10:33:38.300]                       master <- NULL
[10:33:38.300]                       while (!identical(envir, .GlobalEnv) && 
[10:33:38.300]                         !identical(envir, emptyenv())) {
[10:33:38.300]                         if (exists("master", mode = "list", envir = envir, 
[10:33:38.300]                           inherits = FALSE)) {
[10:33:38.300]                           master <- get("master", mode = "list", 
[10:33:38.300]                             envir = envir, inherits = FALSE)
[10:33:38.300]                           if (inherits(master, c("SOCKnode", 
[10:33:38.300]                             "SOCK0node"))) {
[10:33:38.300]                             sendCondition <<- function(cond) {
[10:33:38.300]                               data <- list(type = "VALUE", value = cond, 
[10:33:38.300]                                 success = TRUE)
[10:33:38.300]                               parallel_sendData(master, data)
[10:33:38.300]                             }
[10:33:38.300]                             return(sendCondition)
[10:33:38.300]                           }
[10:33:38.300]                         }
[10:33:38.300]                         frame <- frame + 1L
[10:33:38.300]                         envir <- sys.frame(frame)
[10:33:38.300]                       }
[10:33:38.300]                     }
[10:33:38.300]                     sendCondition <<- function(cond) NULL
[10:33:38.300]                   }
[10:33:38.300]                 })
[10:33:38.300]                 withCallingHandlers({
[10:33:38.300]                   NA
[10:33:38.300]                 }, immediateCondition = function(cond) {
[10:33:38.300]                   sendCondition <- ...future.makeSendCondition()
[10:33:38.300]                   sendCondition(cond)
[10:33:38.300]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:38.300]                   {
[10:33:38.300]                     inherits <- base::inherits
[10:33:38.300]                     invokeRestart <- base::invokeRestart
[10:33:38.300]                     is.null <- base::is.null
[10:33:38.300]                     muffled <- FALSE
[10:33:38.300]                     if (inherits(cond, "message")) {
[10:33:38.300]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:38.300]                       if (muffled) 
[10:33:38.300]                         invokeRestart("muffleMessage")
[10:33:38.300]                     }
[10:33:38.300]                     else if (inherits(cond, "warning")) {
[10:33:38.300]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:38.300]                       if (muffled) 
[10:33:38.300]                         invokeRestart("muffleWarning")
[10:33:38.300]                     }
[10:33:38.300]                     else if (inherits(cond, "condition")) {
[10:33:38.300]                       if (!is.null(pattern)) {
[10:33:38.300]                         computeRestarts <- base::computeRestarts
[10:33:38.300]                         grepl <- base::grepl
[10:33:38.300]                         restarts <- computeRestarts(cond)
[10:33:38.300]                         for (restart in restarts) {
[10:33:38.300]                           name <- restart$name
[10:33:38.300]                           if (is.null(name)) 
[10:33:38.300]                             next
[10:33:38.300]                           if (!grepl(pattern, name)) 
[10:33:38.300]                             next
[10:33:38.300]                           invokeRestart(restart)
[10:33:38.300]                           muffled <- TRUE
[10:33:38.300]                           break
[10:33:38.300]                         }
[10:33:38.300]                       }
[10:33:38.300]                     }
[10:33:38.300]                     invisible(muffled)
[10:33:38.300]                   }
[10:33:38.300]                   muffleCondition(cond)
[10:33:38.300]                 })
[10:33:38.300]             }))
[10:33:38.300]             future::FutureResult(value = ...future.value$value, 
[10:33:38.300]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:38.300]                   ...future.rng), globalenv = if (FALSE) 
[10:33:38.300]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:38.300]                     ...future.globalenv.names))
[10:33:38.300]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:38.300]         }, condition = base::local({
[10:33:38.300]             c <- base::c
[10:33:38.300]             inherits <- base::inherits
[10:33:38.300]             invokeRestart <- base::invokeRestart
[10:33:38.300]             length <- base::length
[10:33:38.300]             list <- base::list
[10:33:38.300]             seq.int <- base::seq.int
[10:33:38.300]             signalCondition <- base::signalCondition
[10:33:38.300]             sys.calls <- base::sys.calls
[10:33:38.300]             `[[` <- base::`[[`
[10:33:38.300]             `+` <- base::`+`
[10:33:38.300]             `<<-` <- base::`<<-`
[10:33:38.300]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:38.300]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:38.300]                   3L)]
[10:33:38.300]             }
[10:33:38.300]             function(cond) {
[10:33:38.300]                 is_error <- inherits(cond, "error")
[10:33:38.300]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:38.300]                   NULL)
[10:33:38.300]                 if (is_error) {
[10:33:38.300]                   sessionInformation <- function() {
[10:33:38.300]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:38.300]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:38.300]                       search = base::search(), system = base::Sys.info())
[10:33:38.300]                   }
[10:33:38.300]                   ...future.conditions[[length(...future.conditions) + 
[10:33:38.300]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:38.300]                     cond$call), session = sessionInformation(), 
[10:33:38.300]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:38.300]                   signalCondition(cond)
[10:33:38.300]                 }
[10:33:38.300]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:38.300]                 "immediateCondition"))) {
[10:33:38.300]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:38.300]                   ...future.conditions[[length(...future.conditions) + 
[10:33:38.300]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:38.300]                   if (TRUE && !signal) {
[10:33:38.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:38.300]                     {
[10:33:38.300]                       inherits <- base::inherits
[10:33:38.300]                       invokeRestart <- base::invokeRestart
[10:33:38.300]                       is.null <- base::is.null
[10:33:38.300]                       muffled <- FALSE
[10:33:38.300]                       if (inherits(cond, "message")) {
[10:33:38.300]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:38.300]                         if (muffled) 
[10:33:38.300]                           invokeRestart("muffleMessage")
[10:33:38.300]                       }
[10:33:38.300]                       else if (inherits(cond, "warning")) {
[10:33:38.300]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:38.300]                         if (muffled) 
[10:33:38.300]                           invokeRestart("muffleWarning")
[10:33:38.300]                       }
[10:33:38.300]                       else if (inherits(cond, "condition")) {
[10:33:38.300]                         if (!is.null(pattern)) {
[10:33:38.300]                           computeRestarts <- base::computeRestarts
[10:33:38.300]                           grepl <- base::grepl
[10:33:38.300]                           restarts <- computeRestarts(cond)
[10:33:38.300]                           for (restart in restarts) {
[10:33:38.300]                             name <- restart$name
[10:33:38.300]                             if (is.null(name)) 
[10:33:38.300]                               next
[10:33:38.300]                             if (!grepl(pattern, name)) 
[10:33:38.300]                               next
[10:33:38.300]                             invokeRestart(restart)
[10:33:38.300]                             muffled <- TRUE
[10:33:38.300]                             break
[10:33:38.300]                           }
[10:33:38.300]                         }
[10:33:38.300]                       }
[10:33:38.300]                       invisible(muffled)
[10:33:38.300]                     }
[10:33:38.300]                     muffleCondition(cond, pattern = "^muffle")
[10:33:38.300]                   }
[10:33:38.300]                 }
[10:33:38.300]                 else {
[10:33:38.300]                   if (TRUE) {
[10:33:38.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:38.300]                     {
[10:33:38.300]                       inherits <- base::inherits
[10:33:38.300]                       invokeRestart <- base::invokeRestart
[10:33:38.300]                       is.null <- base::is.null
[10:33:38.300]                       muffled <- FALSE
[10:33:38.300]                       if (inherits(cond, "message")) {
[10:33:38.300]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:38.300]                         if (muffled) 
[10:33:38.300]                           invokeRestart("muffleMessage")
[10:33:38.300]                       }
[10:33:38.300]                       else if (inherits(cond, "warning")) {
[10:33:38.300]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:38.300]                         if (muffled) 
[10:33:38.300]                           invokeRestart("muffleWarning")
[10:33:38.300]                       }
[10:33:38.300]                       else if (inherits(cond, "condition")) {
[10:33:38.300]                         if (!is.null(pattern)) {
[10:33:38.300]                           computeRestarts <- base::computeRestarts
[10:33:38.300]                           grepl <- base::grepl
[10:33:38.300]                           restarts <- computeRestarts(cond)
[10:33:38.300]                           for (restart in restarts) {
[10:33:38.300]                             name <- restart$name
[10:33:38.300]                             if (is.null(name)) 
[10:33:38.300]                               next
[10:33:38.300]                             if (!grepl(pattern, name)) 
[10:33:38.300]                               next
[10:33:38.300]                             invokeRestart(restart)
[10:33:38.300]                             muffled <- TRUE
[10:33:38.300]                             break
[10:33:38.300]                           }
[10:33:38.300]                         }
[10:33:38.300]                       }
[10:33:38.300]                       invisible(muffled)
[10:33:38.300]                     }
[10:33:38.300]                     muffleCondition(cond, pattern = "^muffle")
[10:33:38.300]                   }
[10:33:38.300]                 }
[10:33:38.300]             }
[10:33:38.300]         }))
[10:33:38.300]     }, error = function(ex) {
[10:33:38.300]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:38.300]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:38.300]                 ...future.rng), started = ...future.startTime, 
[10:33:38.300]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:38.300]             version = "1.8"), class = "FutureResult")
[10:33:38.300]     }, finally = {
[10:33:38.300]         if (!identical(...future.workdir, getwd())) 
[10:33:38.300]             setwd(...future.workdir)
[10:33:38.300]         {
[10:33:38.300]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:38.300]                 ...future.oldOptions$nwarnings <- NULL
[10:33:38.300]             }
[10:33:38.300]             base::options(...future.oldOptions)
[10:33:38.300]             if (.Platform$OS.type == "windows") {
[10:33:38.300]                 old_names <- names(...future.oldEnvVars)
[10:33:38.300]                 envs <- base::Sys.getenv()
[10:33:38.300]                 names <- names(envs)
[10:33:38.300]                 common <- intersect(names, old_names)
[10:33:38.300]                 added <- setdiff(names, old_names)
[10:33:38.300]                 removed <- setdiff(old_names, names)
[10:33:38.300]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:38.300]                   envs[common]]
[10:33:38.300]                 NAMES <- toupper(changed)
[10:33:38.300]                 args <- list()
[10:33:38.300]                 for (kk in seq_along(NAMES)) {
[10:33:38.300]                   name <- changed[[kk]]
[10:33:38.300]                   NAME <- NAMES[[kk]]
[10:33:38.300]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:38.300]                     next
[10:33:38.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:38.300]                 }
[10:33:38.300]                 NAMES <- toupper(added)
[10:33:38.300]                 for (kk in seq_along(NAMES)) {
[10:33:38.300]                   name <- added[[kk]]
[10:33:38.300]                   NAME <- NAMES[[kk]]
[10:33:38.300]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:38.300]                     next
[10:33:38.300]                   args[[name]] <- ""
[10:33:38.300]                 }
[10:33:38.300]                 NAMES <- toupper(removed)
[10:33:38.300]                 for (kk in seq_along(NAMES)) {
[10:33:38.300]                   name <- removed[[kk]]
[10:33:38.300]                   NAME <- NAMES[[kk]]
[10:33:38.300]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:38.300]                     next
[10:33:38.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:38.300]                 }
[10:33:38.300]                 if (length(args) > 0) 
[10:33:38.300]                   base::do.call(base::Sys.setenv, args = args)
[10:33:38.300]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:38.300]             }
[10:33:38.300]             else {
[10:33:38.300]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:38.300]             }
[10:33:38.300]             {
[10:33:38.300]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:38.300]                   0L) {
[10:33:38.300]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:38.300]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:38.300]                   base::options(opts)
[10:33:38.300]                 }
[10:33:38.300]                 {
[10:33:38.300]                   {
[10:33:38.300]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:38.300]                     NULL
[10:33:38.300]                   }
[10:33:38.300]                   options(future.plan = NULL)
[10:33:38.300]                   if (is.na(NA_character_)) 
[10:33:38.300]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:38.300]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:38.300]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:38.300]                     .init = FALSE)
[10:33:38.300]                 }
[10:33:38.300]             }
[10:33:38.300]         }
[10:33:38.300]     })
[10:33:38.300]     if (TRUE) {
[10:33:38.300]         base::sink(type = "output", split = FALSE)
[10:33:38.300]         if (TRUE) {
[10:33:38.300]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:38.300]         }
[10:33:38.300]         else {
[10:33:38.300]             ...future.result["stdout"] <- base::list(NULL)
[10:33:38.300]         }
[10:33:38.300]         base::close(...future.stdout)
[10:33:38.300]         ...future.stdout <- NULL
[10:33:38.300]     }
[10:33:38.300]     ...future.result$conditions <- ...future.conditions
[10:33:38.300]     ...future.result$finished <- base::Sys.time()
[10:33:38.300]     ...future.result
[10:33:38.300] }
[10:33:38.353] MultisessionFuture started
[10:33:38.353] result() for ClusterFuture ...
[10:33:38.353] receiveMessageFromWorker() for ClusterFuture ...
[10:33:38.353] - Validating connection of MultisessionFuture
[10:33:38.392] - received message: FutureResult
[10:33:38.392] - Received FutureResult
[10:33:38.392] - Erased future from FutureRegistry
[10:33:38.392] result() for ClusterFuture ...
[10:33:38.392] - result already collected: FutureResult
[10:33:38.393] result() for ClusterFuture ... done
[10:33:38.393] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:38.393] result() for ClusterFuture ... done
[10:33:38.393] result() for ClusterFuture ...
[10:33:38.393] - result already collected: FutureResult
[10:33:38.393] result() for ClusterFuture ... done
[10:33:38.393] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:33:38.397] plan(): nbrOfWorkers() = 2
[10:33:38.397] getGlobalsAndPackages() ...
[10:33:38.397] Searching for globals...
[10:33:38.418] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:33:38.418] Searching for globals ... DONE
[10:33:38.418] Resolving globals: FALSE
[10:33:38.419] The total size of the 2 globals is 55.46 KiB (56792 bytes)
[10:33:38.420] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 55.46 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (55.34 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[10:33:38.420] - globals: [2] ‘nested’, ‘strategy2’
[10:33:38.420] - packages: [1] ‘future’
[10:33:38.420] getGlobalsAndPackages() ... DONE
[10:33:38.421] run() for ‘Future’ ...
[10:33:38.421] - state: ‘created’
[10:33:38.421] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:38.435] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:38.435] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:38.435]   - Field: ‘node’
[10:33:38.435]   - Field: ‘label’
[10:33:38.435]   - Field: ‘local’
[10:33:38.435]   - Field: ‘owner’
[10:33:38.435]   - Field: ‘envir’
[10:33:38.436]   - Field: ‘workers’
[10:33:38.436]   - Field: ‘packages’
[10:33:38.436]   - Field: ‘gc’
[10:33:38.436]   - Field: ‘conditions’
[10:33:38.436]   - Field: ‘persistent’
[10:33:38.436]   - Field: ‘expr’
[10:33:38.436]   - Field: ‘uuid’
[10:33:38.436]   - Field: ‘seed’
[10:33:38.436]   - Field: ‘version’
[10:33:38.436]   - Field: ‘result’
[10:33:38.436]   - Field: ‘asynchronous’
[10:33:38.437]   - Field: ‘calls’
[10:33:38.437]   - Field: ‘globals’
[10:33:38.437]   - Field: ‘stdout’
[10:33:38.437]   - Field: ‘earlySignal’
[10:33:38.437]   - Field: ‘lazy’
[10:33:38.437]   - Field: ‘state’
[10:33:38.437] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:38.437] - Launch lazy future ...
[10:33:38.437] Packages needed by the future expression (n = 1): ‘future’
[10:33:38.438] Packages needed by future strategies (n = 1): ‘future’
[10:33:38.438] {
[10:33:38.438]     {
[10:33:38.438]         {
[10:33:38.438]             ...future.startTime <- base::Sys.time()
[10:33:38.438]             {
[10:33:38.438]                 {
[10:33:38.438]                   {
[10:33:38.438]                     {
[10:33:38.438]                       {
[10:33:38.438]                         base::local({
[10:33:38.438]                           has_future <- base::requireNamespace("future", 
[10:33:38.438]                             quietly = TRUE)
[10:33:38.438]                           if (has_future) {
[10:33:38.438]                             ns <- base::getNamespace("future")
[10:33:38.438]                             version <- ns[[".package"]][["version"]]
[10:33:38.438]                             if (is.null(version)) 
[10:33:38.438]                               version <- utils::packageVersion("future")
[10:33:38.438]                           }
[10:33:38.438]                           else {
[10:33:38.438]                             version <- NULL
[10:33:38.438]                           }
[10:33:38.438]                           if (!has_future || version < "1.8.0") {
[10:33:38.438]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:38.438]                               "", base::R.version$version.string), 
[10:33:38.438]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:38.438]                                 base::R.version$platform, 8 * 
[10:33:38.438]                                   base::.Machine$sizeof.pointer), 
[10:33:38.438]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:38.438]                                 "release", "version")], collapse = " "), 
[10:33:38.438]                               hostname = base::Sys.info()[["nodename"]])
[10:33:38.438]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:38.438]                               info)
[10:33:38.438]                             info <- base::paste(info, collapse = "; ")
[10:33:38.438]                             if (!has_future) {
[10:33:38.438]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:38.438]                                 info)
[10:33:38.438]                             }
[10:33:38.438]                             else {
[10:33:38.438]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:38.438]                                 info, version)
[10:33:38.438]                             }
[10:33:38.438]                             base::stop(msg)
[10:33:38.438]                           }
[10:33:38.438]                         })
[10:33:38.438]                       }
[10:33:38.438]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:38.438]                       base::options(mc.cores = 1L)
[10:33:38.438]                     }
[10:33:38.438]                     base::local({
[10:33:38.438]                       for (pkg in "future") {
[10:33:38.438]                         base::loadNamespace(pkg)
[10:33:38.438]                         base::library(pkg, character.only = TRUE)
[10:33:38.438]                       }
[10:33:38.438]                     })
[10:33:38.438]                   }
[10:33:38.438]                   ...future.strategy.old <- future::plan("list")
[10:33:38.438]                   options(future.plan = NULL)
[10:33:38.438]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:38.438]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:33:38.438]                   {
[10:33:38.438]                     future <- SequentialFuture(..., envir = envir)
[10:33:38.438]                     if (!future$lazy) 
[10:33:38.438]                       future <- run(future)
[10:33:38.438]                     invisible(future)
[10:33:38.438]                   }), .cleanup = FALSE, .init = FALSE)
[10:33:38.438]                 }
[10:33:38.438]                 ...future.workdir <- getwd()
[10:33:38.438]             }
[10:33:38.438]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:38.438]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:38.438]         }
[10:33:38.438]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:38.438]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:38.438]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:38.438]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:38.438]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:38.438]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:38.438]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:38.438]             base::names(...future.oldOptions))
[10:33:38.438]     }
[10:33:38.438]     if (FALSE) {
[10:33:38.438]     }
[10:33:38.438]     else {
[10:33:38.438]         if (TRUE) {
[10:33:38.438]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:38.438]                 open = "w")
[10:33:38.438]         }
[10:33:38.438]         else {
[10:33:38.438]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:38.438]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:38.438]         }
[10:33:38.438]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:38.438]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:38.438]             base::sink(type = "output", split = FALSE)
[10:33:38.438]             base::close(...future.stdout)
[10:33:38.438]         }, add = TRUE)
[10:33:38.438]     }
[10:33:38.438]     ...future.frame <- base::sys.nframe()
[10:33:38.438]     ...future.conditions <- base::list()
[10:33:38.438]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:38.438]     if (FALSE) {
[10:33:38.438]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:38.438]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:38.438]     }
[10:33:38.438]     ...future.result <- base::tryCatch({
[10:33:38.438]         base::withCallingHandlers({
[10:33:38.438]             ...future.value <- base::withVisible(base::local({
[10:33:38.438]                 ...future.makeSendCondition <- base::local({
[10:33:38.438]                   sendCondition <- NULL
[10:33:38.438]                   function(frame = 1L) {
[10:33:38.438]                     if (is.function(sendCondition)) 
[10:33:38.438]                       return(sendCondition)
[10:33:38.438]                     ns <- getNamespace("parallel")
[10:33:38.438]                     if (exists("sendData", mode = "function", 
[10:33:38.438]                       envir = ns)) {
[10:33:38.438]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:38.438]                         envir = ns)
[10:33:38.438]                       envir <- sys.frame(frame)
[10:33:38.438]                       master <- NULL
[10:33:38.438]                       while (!identical(envir, .GlobalEnv) && 
[10:33:38.438]                         !identical(envir, emptyenv())) {
[10:33:38.438]                         if (exists("master", mode = "list", envir = envir, 
[10:33:38.438]                           inherits = FALSE)) {
[10:33:38.438]                           master <- get("master", mode = "list", 
[10:33:38.438]                             envir = envir, inherits = FALSE)
[10:33:38.438]                           if (inherits(master, c("SOCKnode", 
[10:33:38.438]                             "SOCK0node"))) {
[10:33:38.438]                             sendCondition <<- function(cond) {
[10:33:38.438]                               data <- list(type = "VALUE", value = cond, 
[10:33:38.438]                                 success = TRUE)
[10:33:38.438]                               parallel_sendData(master, data)
[10:33:38.438]                             }
[10:33:38.438]                             return(sendCondition)
[10:33:38.438]                           }
[10:33:38.438]                         }
[10:33:38.438]                         frame <- frame + 1L
[10:33:38.438]                         envir <- sys.frame(frame)
[10:33:38.438]                       }
[10:33:38.438]                     }
[10:33:38.438]                     sendCondition <<- function(cond) NULL
[10:33:38.438]                   }
[10:33:38.438]                 })
[10:33:38.438]                 withCallingHandlers({
[10:33:38.438]                   {
[10:33:38.438]                     a <- 1L
[10:33:38.438]                     plan_a <- unclass(future::plan("list"))
[10:33:38.438]                     nested_a <- nested[-1]
[10:33:38.438]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:33:38.438]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:33:38.438]                       strategy2))
[10:33:38.438]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:33:38.438]                       "init") <- NULL
[10:33:38.438]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:33:38.438]                       "init") <- NULL
[10:33:38.438]                     stopifnot(all.equal(plan_a, nested_a))
[10:33:38.438]                     y %<-% {
[10:33:38.438]                       b <- 2L
[10:33:38.438]                       plan_b <- future::plan("list")
[10:33:38.438]                       nested_b <- nested_a[-1]
[10:33:38.438]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:33:38.438]                         1L, inherits(plan_b[[1]], "future"), 
[10:33:38.438]                         inherits(future::plan("next"), "sequential"))
[10:33:38.438]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:33:38.438]                         b = b, nested_b = nested_b, plan_b = plan_b)
[10:33:38.438]                     }
[10:33:38.438]                     y
[10:33:38.438]                   }
[10:33:38.438]                 }, immediateCondition = function(cond) {
[10:33:38.438]                   sendCondition <- ...future.makeSendCondition()
[10:33:38.438]                   sendCondition(cond)
[10:33:38.438]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:38.438]                   {
[10:33:38.438]                     inherits <- base::inherits
[10:33:38.438]                     invokeRestart <- base::invokeRestart
[10:33:38.438]                     is.null <- base::is.null
[10:33:38.438]                     muffled <- FALSE
[10:33:38.438]                     if (inherits(cond, "message")) {
[10:33:38.438]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:38.438]                       if (muffled) 
[10:33:38.438]                         invokeRestart("muffleMessage")
[10:33:38.438]                     }
[10:33:38.438]                     else if (inherits(cond, "warning")) {
[10:33:38.438]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:38.438]                       if (muffled) 
[10:33:38.438]                         invokeRestart("muffleWarning")
[10:33:38.438]                     }
[10:33:38.438]                     else if (inherits(cond, "condition")) {
[10:33:38.438]                       if (!is.null(pattern)) {
[10:33:38.438]                         computeRestarts <- base::computeRestarts
[10:33:38.438]                         grepl <- base::grepl
[10:33:38.438]                         restarts <- computeRestarts(cond)
[10:33:38.438]                         for (restart in restarts) {
[10:33:38.438]                           name <- restart$name
[10:33:38.438]                           if (is.null(name)) 
[10:33:38.438]                             next
[10:33:38.438]                           if (!grepl(pattern, name)) 
[10:33:38.438]                             next
[10:33:38.438]                           invokeRestart(restart)
[10:33:38.438]                           muffled <- TRUE
[10:33:38.438]                           break
[10:33:38.438]                         }
[10:33:38.438]                       }
[10:33:38.438]                     }
[10:33:38.438]                     invisible(muffled)
[10:33:38.438]                   }
[10:33:38.438]                   muffleCondition(cond)
[10:33:38.438]                 })
[10:33:38.438]             }))
[10:33:38.438]             future::FutureResult(value = ...future.value$value, 
[10:33:38.438]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:38.438]                   ...future.rng), globalenv = if (FALSE) 
[10:33:38.438]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:38.438]                     ...future.globalenv.names))
[10:33:38.438]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:38.438]         }, condition = base::local({
[10:33:38.438]             c <- base::c
[10:33:38.438]             inherits <- base::inherits
[10:33:38.438]             invokeRestart <- base::invokeRestart
[10:33:38.438]             length <- base::length
[10:33:38.438]             list <- base::list
[10:33:38.438]             seq.int <- base::seq.int
[10:33:38.438]             signalCondition <- base::signalCondition
[10:33:38.438]             sys.calls <- base::sys.calls
[10:33:38.438]             `[[` <- base::`[[`
[10:33:38.438]             `+` <- base::`+`
[10:33:38.438]             `<<-` <- base::`<<-`
[10:33:38.438]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:38.438]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:38.438]                   3L)]
[10:33:38.438]             }
[10:33:38.438]             function(cond) {
[10:33:38.438]                 is_error <- inherits(cond, "error")
[10:33:38.438]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:38.438]                   NULL)
[10:33:38.438]                 if (is_error) {
[10:33:38.438]                   sessionInformation <- function() {
[10:33:38.438]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:38.438]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:38.438]                       search = base::search(), system = base::Sys.info())
[10:33:38.438]                   }
[10:33:38.438]                   ...future.conditions[[length(...future.conditions) + 
[10:33:38.438]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:38.438]                     cond$call), session = sessionInformation(), 
[10:33:38.438]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:38.438]                   signalCondition(cond)
[10:33:38.438]                 }
[10:33:38.438]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:38.438]                 "immediateCondition"))) {
[10:33:38.438]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:38.438]                   ...future.conditions[[length(...future.conditions) + 
[10:33:38.438]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:38.438]                   if (TRUE && !signal) {
[10:33:38.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:38.438]                     {
[10:33:38.438]                       inherits <- base::inherits
[10:33:38.438]                       invokeRestart <- base::invokeRestart
[10:33:38.438]                       is.null <- base::is.null
[10:33:38.438]                       muffled <- FALSE
[10:33:38.438]                       if (inherits(cond, "message")) {
[10:33:38.438]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:38.438]                         if (muffled) 
[10:33:38.438]                           invokeRestart("muffleMessage")
[10:33:38.438]                       }
[10:33:38.438]                       else if (inherits(cond, "warning")) {
[10:33:38.438]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:38.438]                         if (muffled) 
[10:33:38.438]                           invokeRestart("muffleWarning")
[10:33:38.438]                       }
[10:33:38.438]                       else if (inherits(cond, "condition")) {
[10:33:38.438]                         if (!is.null(pattern)) {
[10:33:38.438]                           computeRestarts <- base::computeRestarts
[10:33:38.438]                           grepl <- base::grepl
[10:33:38.438]                           restarts <- computeRestarts(cond)
[10:33:38.438]                           for (restart in restarts) {
[10:33:38.438]                             name <- restart$name
[10:33:38.438]                             if (is.null(name)) 
[10:33:38.438]                               next
[10:33:38.438]                             if (!grepl(pattern, name)) 
[10:33:38.438]                               next
[10:33:38.438]                             invokeRestart(restart)
[10:33:38.438]                             muffled <- TRUE
[10:33:38.438]                             break
[10:33:38.438]                           }
[10:33:38.438]                         }
[10:33:38.438]                       }
[10:33:38.438]                       invisible(muffled)
[10:33:38.438]                     }
[10:33:38.438]                     muffleCondition(cond, pattern = "^muffle")
[10:33:38.438]                   }
[10:33:38.438]                 }
[10:33:38.438]                 else {
[10:33:38.438]                   if (TRUE) {
[10:33:38.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:38.438]                     {
[10:33:38.438]                       inherits <- base::inherits
[10:33:38.438]                       invokeRestart <- base::invokeRestart
[10:33:38.438]                       is.null <- base::is.null
[10:33:38.438]                       muffled <- FALSE
[10:33:38.438]                       if (inherits(cond, "message")) {
[10:33:38.438]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:38.438]                         if (muffled) 
[10:33:38.438]                           invokeRestart("muffleMessage")
[10:33:38.438]                       }
[10:33:38.438]                       else if (inherits(cond, "warning")) {
[10:33:38.438]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:38.438]                         if (muffled) 
[10:33:38.438]                           invokeRestart("muffleWarning")
[10:33:38.438]                       }
[10:33:38.438]                       else if (inherits(cond, "condition")) {
[10:33:38.438]                         if (!is.null(pattern)) {
[10:33:38.438]                           computeRestarts <- base::computeRestarts
[10:33:38.438]                           grepl <- base::grepl
[10:33:38.438]                           restarts <- computeRestarts(cond)
[10:33:38.438]                           for (restart in restarts) {
[10:33:38.438]                             name <- restart$name
[10:33:38.438]                             if (is.null(name)) 
[10:33:38.438]                               next
[10:33:38.438]                             if (!grepl(pattern, name)) 
[10:33:38.438]                               next
[10:33:38.438]                             invokeRestart(restart)
[10:33:38.438]                             muffled <- TRUE
[10:33:38.438]                             break
[10:33:38.438]                           }
[10:33:38.438]                         }
[10:33:38.438]                       }
[10:33:38.438]                       invisible(muffled)
[10:33:38.438]                     }
[10:33:38.438]                     muffleCondition(cond, pattern = "^muffle")
[10:33:38.438]                   }
[10:33:38.438]                 }
[10:33:38.438]             }
[10:33:38.438]         }))
[10:33:38.438]     }, error = function(ex) {
[10:33:38.438]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:38.438]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:38.438]                 ...future.rng), started = ...future.startTime, 
[10:33:38.438]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:38.438]             version = "1.8"), class = "FutureResult")
[10:33:38.438]     }, finally = {
[10:33:38.438]         if (!identical(...future.workdir, getwd())) 
[10:33:38.438]             setwd(...future.workdir)
[10:33:38.438]         {
[10:33:38.438]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:38.438]                 ...future.oldOptions$nwarnings <- NULL
[10:33:38.438]             }
[10:33:38.438]             base::options(...future.oldOptions)
[10:33:38.438]             if (.Platform$OS.type == "windows") {
[10:33:38.438]                 old_names <- names(...future.oldEnvVars)
[10:33:38.438]                 envs <- base::Sys.getenv()
[10:33:38.438]                 names <- names(envs)
[10:33:38.438]                 common <- intersect(names, old_names)
[10:33:38.438]                 added <- setdiff(names, old_names)
[10:33:38.438]                 removed <- setdiff(old_names, names)
[10:33:38.438]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:38.438]                   envs[common]]
[10:33:38.438]                 NAMES <- toupper(changed)
[10:33:38.438]                 args <- list()
[10:33:38.438]                 for (kk in seq_along(NAMES)) {
[10:33:38.438]                   name <- changed[[kk]]
[10:33:38.438]                   NAME <- NAMES[[kk]]
[10:33:38.438]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:38.438]                     next
[10:33:38.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:38.438]                 }
[10:33:38.438]                 NAMES <- toupper(added)
[10:33:38.438]                 for (kk in seq_along(NAMES)) {
[10:33:38.438]                   name <- added[[kk]]
[10:33:38.438]                   NAME <- NAMES[[kk]]
[10:33:38.438]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:38.438]                     next
[10:33:38.438]                   args[[name]] <- ""
[10:33:38.438]                 }
[10:33:38.438]                 NAMES <- toupper(removed)
[10:33:38.438]                 for (kk in seq_along(NAMES)) {
[10:33:38.438]                   name <- removed[[kk]]
[10:33:38.438]                   NAME <- NAMES[[kk]]
[10:33:38.438]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:38.438]                     next
[10:33:38.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:38.438]                 }
[10:33:38.438]                 if (length(args) > 0) 
[10:33:38.438]                   base::do.call(base::Sys.setenv, args = args)
[10:33:38.438]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:38.438]             }
[10:33:38.438]             else {
[10:33:38.438]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:38.438]             }
[10:33:38.438]             {
[10:33:38.438]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:38.438]                   0L) {
[10:33:38.438]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:38.438]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:38.438]                   base::options(opts)
[10:33:38.438]                 }
[10:33:38.438]                 {
[10:33:38.438]                   {
[10:33:38.438]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:38.438]                     NULL
[10:33:38.438]                   }
[10:33:38.438]                   options(future.plan = NULL)
[10:33:38.438]                   if (is.na(NA_character_)) 
[10:33:38.438]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:38.438]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:38.438]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:38.438]                     .init = FALSE)
[10:33:38.438]                 }
[10:33:38.438]             }
[10:33:38.438]         }
[10:33:38.438]     })
[10:33:38.438]     if (TRUE) {
[10:33:38.438]         base::sink(type = "output", split = FALSE)
[10:33:38.438]         if (TRUE) {
[10:33:38.438]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:38.438]         }
[10:33:38.438]         else {
[10:33:38.438]             ...future.result["stdout"] <- base::list(NULL)
[10:33:38.438]         }
[10:33:38.438]         base::close(...future.stdout)
[10:33:38.438]         ...future.stdout <- NULL
[10:33:38.438]     }
[10:33:38.438]     ...future.result$conditions <- ...future.conditions
[10:33:38.438]     ...future.result$finished <- base::Sys.time()
[10:33:38.438]     ...future.result
[10:33:38.438] }
[10:33:38.441] Exporting 2 global objects (55.46 KiB) to cluster node #1 ...
[10:33:38.441] Exporting ‘nested’ (55.34 KiB) to cluster node #1 ...
[10:33:38.485] Exporting ‘nested’ (55.34 KiB) to cluster node #1 ... DONE
[10:33:38.485] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[10:33:38.486] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[10:33:38.486] Exporting 2 global objects (55.46 KiB) to cluster node #1 ... DONE
[10:33:38.487] MultisessionFuture started
[10:33:38.487] - Launch lazy future ... done
[10:33:38.487] run() for ‘MultisessionFuture’ ... done
[10:33:38.487] result() for ClusterFuture ...
[10:33:38.487] receiveMessageFromWorker() for ClusterFuture ...
[10:33:38.487] - Validating connection of MultisessionFuture
[10:33:38.550] - received message: FutureResult
[10:33:38.550] - Received FutureResult
[10:33:38.551] - Erased future from FutureRegistry
[10:33:38.551] result() for ClusterFuture ...
[10:33:38.551] - result already collected: FutureResult
[10:33:38.551] result() for ClusterFuture ... done
[10:33:38.551] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:38.551] result() for ClusterFuture ... done
[10:33:38.551] result() for ClusterFuture ...
[10:33:38.551] - result already collected: FutureResult
[10:33:38.551] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:33:38.556] getGlobalsAndPackages() ...
[10:33:38.556] Searching for globals...
[10:33:38.558] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:33:38.558] Searching for globals ... DONE
[10:33:38.558] Resolving globals: FALSE
[10:33:38.559] The total size of the 1 globals is 128 bytes (128 bytes)
[10:33:38.559] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:33:38.559] - globals: [1] ‘data’
[10:33:38.559] - packages: [1] ‘future’
[10:33:38.559] getGlobalsAndPackages() ... DONE
[10:33:38.560] run() for ‘Future’ ...
[10:33:38.560] - state: ‘created’
[10:33:38.560] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:38.575] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:38.575] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:38.575]   - Field: ‘node’
[10:33:38.575]   - Field: ‘label’
[10:33:38.575]   - Field: ‘local’
[10:33:38.575]   - Field: ‘owner’
[10:33:38.575]   - Field: ‘envir’
[10:33:38.575]   - Field: ‘workers’
[10:33:38.575]   - Field: ‘packages’
[10:33:38.575]   - Field: ‘gc’
[10:33:38.576]   - Field: ‘conditions’
[10:33:38.576]   - Field: ‘persistent’
[10:33:38.576]   - Field: ‘expr’
[10:33:38.576]   - Field: ‘uuid’
[10:33:38.576]   - Field: ‘seed’
[10:33:38.576]   - Field: ‘version’
[10:33:38.576]   - Field: ‘result’
[10:33:38.576]   - Field: ‘asynchronous’
[10:33:38.576]   - Field: ‘calls’
[10:33:38.576]   - Field: ‘globals’
[10:33:38.577]   - Field: ‘stdout’
[10:33:38.577]   - Field: ‘earlySignal’
[10:33:38.577]   - Field: ‘lazy’
[10:33:38.577]   - Field: ‘state’
[10:33:38.577] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:38.577] - Launch lazy future ...
[10:33:38.577] Packages needed by the future expression (n = 1): ‘future’
[10:33:38.577] Packages needed by future strategies (n = 1): ‘future’
[10:33:38.578] {
[10:33:38.578]     {
[10:33:38.578]         {
[10:33:38.578]             ...future.startTime <- base::Sys.time()
[10:33:38.578]             {
[10:33:38.578]                 {
[10:33:38.578]                   {
[10:33:38.578]                     {
[10:33:38.578]                       {
[10:33:38.578]                         base::local({
[10:33:38.578]                           has_future <- base::requireNamespace("future", 
[10:33:38.578]                             quietly = TRUE)
[10:33:38.578]                           if (has_future) {
[10:33:38.578]                             ns <- base::getNamespace("future")
[10:33:38.578]                             version <- ns[[".package"]][["version"]]
[10:33:38.578]                             if (is.null(version)) 
[10:33:38.578]                               version <- utils::packageVersion("future")
[10:33:38.578]                           }
[10:33:38.578]                           else {
[10:33:38.578]                             version <- NULL
[10:33:38.578]                           }
[10:33:38.578]                           if (!has_future || version < "1.8.0") {
[10:33:38.578]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:38.578]                               "", base::R.version$version.string), 
[10:33:38.578]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:38.578]                                 base::R.version$platform, 8 * 
[10:33:38.578]                                   base::.Machine$sizeof.pointer), 
[10:33:38.578]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:38.578]                                 "release", "version")], collapse = " "), 
[10:33:38.578]                               hostname = base::Sys.info()[["nodename"]])
[10:33:38.578]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:38.578]                               info)
[10:33:38.578]                             info <- base::paste(info, collapse = "; ")
[10:33:38.578]                             if (!has_future) {
[10:33:38.578]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:38.578]                                 info)
[10:33:38.578]                             }
[10:33:38.578]                             else {
[10:33:38.578]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:38.578]                                 info, version)
[10:33:38.578]                             }
[10:33:38.578]                             base::stop(msg)
[10:33:38.578]                           }
[10:33:38.578]                         })
[10:33:38.578]                       }
[10:33:38.578]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:38.578]                       base::options(mc.cores = 1L)
[10:33:38.578]                     }
[10:33:38.578]                     base::local({
[10:33:38.578]                       for (pkg in "future") {
[10:33:38.578]                         base::loadNamespace(pkg)
[10:33:38.578]                         base::library(pkg, character.only = TRUE)
[10:33:38.578]                       }
[10:33:38.578]                     })
[10:33:38.578]                   }
[10:33:38.578]                   ...future.strategy.old <- future::plan("list")
[10:33:38.578]                   options(future.plan = NULL)
[10:33:38.578]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:38.578]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:33:38.578]                   {
[10:33:38.578]                     future <- SequentialFuture(..., envir = envir)
[10:33:38.578]                     if (!future$lazy) 
[10:33:38.578]                       future <- run(future)
[10:33:38.578]                     invisible(future)
[10:33:38.578]                   }), .cleanup = FALSE, .init = FALSE)
[10:33:38.578]                 }
[10:33:38.578]                 ...future.workdir <- getwd()
[10:33:38.578]             }
[10:33:38.578]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:38.578]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:38.578]         }
[10:33:38.578]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:38.578]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:38.578]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:38.578]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:38.578]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:38.578]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:38.578]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:38.578]             base::names(...future.oldOptions))
[10:33:38.578]     }
[10:33:38.578]     if (FALSE) {
[10:33:38.578]     }
[10:33:38.578]     else {
[10:33:38.578]         if (TRUE) {
[10:33:38.578]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:38.578]                 open = "w")
[10:33:38.578]         }
[10:33:38.578]         else {
[10:33:38.578]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:38.578]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:38.578]         }
[10:33:38.578]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:38.578]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:38.578]             base::sink(type = "output", split = FALSE)
[10:33:38.578]             base::close(...future.stdout)
[10:33:38.578]         }, add = TRUE)
[10:33:38.578]     }
[10:33:38.578]     ...future.frame <- base::sys.nframe()
[10:33:38.578]     ...future.conditions <- base::list()
[10:33:38.578]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:38.578]     if (FALSE) {
[10:33:38.578]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:38.578]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:38.578]     }
[10:33:38.578]     ...future.result <- base::tryCatch({
[10:33:38.578]         base::withCallingHandlers({
[10:33:38.578]             ...future.value <- base::withVisible(base::local({
[10:33:38.578]                 ...future.makeSendCondition <- base::local({
[10:33:38.578]                   sendCondition <- NULL
[10:33:38.578]                   function(frame = 1L) {
[10:33:38.578]                     if (is.function(sendCondition)) 
[10:33:38.578]                       return(sendCondition)
[10:33:38.578]                     ns <- getNamespace("parallel")
[10:33:38.578]                     if (exists("sendData", mode = "function", 
[10:33:38.578]                       envir = ns)) {
[10:33:38.578]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:38.578]                         envir = ns)
[10:33:38.578]                       envir <- sys.frame(frame)
[10:33:38.578]                       master <- NULL
[10:33:38.578]                       while (!identical(envir, .GlobalEnv) && 
[10:33:38.578]                         !identical(envir, emptyenv())) {
[10:33:38.578]                         if (exists("master", mode = "list", envir = envir, 
[10:33:38.578]                           inherits = FALSE)) {
[10:33:38.578]                           master <- get("master", mode = "list", 
[10:33:38.578]                             envir = envir, inherits = FALSE)
[10:33:38.578]                           if (inherits(master, c("SOCKnode", 
[10:33:38.578]                             "SOCK0node"))) {
[10:33:38.578]                             sendCondition <<- function(cond) {
[10:33:38.578]                               data <- list(type = "VALUE", value = cond, 
[10:33:38.578]                                 success = TRUE)
[10:33:38.578]                               parallel_sendData(master, data)
[10:33:38.578]                             }
[10:33:38.578]                             return(sendCondition)
[10:33:38.578]                           }
[10:33:38.578]                         }
[10:33:38.578]                         frame <- frame + 1L
[10:33:38.578]                         envir <- sys.frame(frame)
[10:33:38.578]                       }
[10:33:38.578]                     }
[10:33:38.578]                     sendCondition <<- function(cond) NULL
[10:33:38.578]                   }
[10:33:38.578]                 })
[10:33:38.578]                 withCallingHandlers({
[10:33:38.578]                   {
[10:33:38.578]                     value(future(subset(data, a == 2)))
[10:33:38.578]                   }
[10:33:38.578]                 }, immediateCondition = function(cond) {
[10:33:38.578]                   sendCondition <- ...future.makeSendCondition()
[10:33:38.578]                   sendCondition(cond)
[10:33:38.578]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:38.578]                   {
[10:33:38.578]                     inherits <- base::inherits
[10:33:38.578]                     invokeRestart <- base::invokeRestart
[10:33:38.578]                     is.null <- base::is.null
[10:33:38.578]                     muffled <- FALSE
[10:33:38.578]                     if (inherits(cond, "message")) {
[10:33:38.578]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:38.578]                       if (muffled) 
[10:33:38.578]                         invokeRestart("muffleMessage")
[10:33:38.578]                     }
[10:33:38.578]                     else if (inherits(cond, "warning")) {
[10:33:38.578]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:38.578]                       if (muffled) 
[10:33:38.578]                         invokeRestart("muffleWarning")
[10:33:38.578]                     }
[10:33:38.578]                     else if (inherits(cond, "condition")) {
[10:33:38.578]                       if (!is.null(pattern)) {
[10:33:38.578]                         computeRestarts <- base::computeRestarts
[10:33:38.578]                         grepl <- base::grepl
[10:33:38.578]                         restarts <- computeRestarts(cond)
[10:33:38.578]                         for (restart in restarts) {
[10:33:38.578]                           name <- restart$name
[10:33:38.578]                           if (is.null(name)) 
[10:33:38.578]                             next
[10:33:38.578]                           if (!grepl(pattern, name)) 
[10:33:38.578]                             next
[10:33:38.578]                           invokeRestart(restart)
[10:33:38.578]                           muffled <- TRUE
[10:33:38.578]                           break
[10:33:38.578]                         }
[10:33:38.578]                       }
[10:33:38.578]                     }
[10:33:38.578]                     invisible(muffled)
[10:33:38.578]                   }
[10:33:38.578]                   muffleCondition(cond)
[10:33:38.578]                 })
[10:33:38.578]             }))
[10:33:38.578]             future::FutureResult(value = ...future.value$value, 
[10:33:38.578]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:38.578]                   ...future.rng), globalenv = if (FALSE) 
[10:33:38.578]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:38.578]                     ...future.globalenv.names))
[10:33:38.578]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:38.578]         }, condition = base::local({
[10:33:38.578]             c <- base::c
[10:33:38.578]             inherits <- base::inherits
[10:33:38.578]             invokeRestart <- base::invokeRestart
[10:33:38.578]             length <- base::length
[10:33:38.578]             list <- base::list
[10:33:38.578]             seq.int <- base::seq.int
[10:33:38.578]             signalCondition <- base::signalCondition
[10:33:38.578]             sys.calls <- base::sys.calls
[10:33:38.578]             `[[` <- base::`[[`
[10:33:38.578]             `+` <- base::`+`
[10:33:38.578]             `<<-` <- base::`<<-`
[10:33:38.578]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:38.578]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:38.578]                   3L)]
[10:33:38.578]             }
[10:33:38.578]             function(cond) {
[10:33:38.578]                 is_error <- inherits(cond, "error")
[10:33:38.578]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:38.578]                   NULL)
[10:33:38.578]                 if (is_error) {
[10:33:38.578]                   sessionInformation <- function() {
[10:33:38.578]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:38.578]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:38.578]                       search = base::search(), system = base::Sys.info())
[10:33:38.578]                   }
[10:33:38.578]                   ...future.conditions[[length(...future.conditions) + 
[10:33:38.578]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:38.578]                     cond$call), session = sessionInformation(), 
[10:33:38.578]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:38.578]                   signalCondition(cond)
[10:33:38.578]                 }
[10:33:38.578]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:38.578]                 "immediateCondition"))) {
[10:33:38.578]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:38.578]                   ...future.conditions[[length(...future.conditions) + 
[10:33:38.578]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:38.578]                   if (TRUE && !signal) {
[10:33:38.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:38.578]                     {
[10:33:38.578]                       inherits <- base::inherits
[10:33:38.578]                       invokeRestart <- base::invokeRestart
[10:33:38.578]                       is.null <- base::is.null
[10:33:38.578]                       muffled <- FALSE
[10:33:38.578]                       if (inherits(cond, "message")) {
[10:33:38.578]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:38.578]                         if (muffled) 
[10:33:38.578]                           invokeRestart("muffleMessage")
[10:33:38.578]                       }
[10:33:38.578]                       else if (inherits(cond, "warning")) {
[10:33:38.578]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:38.578]                         if (muffled) 
[10:33:38.578]                           invokeRestart("muffleWarning")
[10:33:38.578]                       }
[10:33:38.578]                       else if (inherits(cond, "condition")) {
[10:33:38.578]                         if (!is.null(pattern)) {
[10:33:38.578]                           computeRestarts <- base::computeRestarts
[10:33:38.578]                           grepl <- base::grepl
[10:33:38.578]                           restarts <- computeRestarts(cond)
[10:33:38.578]                           for (restart in restarts) {
[10:33:38.578]                             name <- restart$name
[10:33:38.578]                             if (is.null(name)) 
[10:33:38.578]                               next
[10:33:38.578]                             if (!grepl(pattern, name)) 
[10:33:38.578]                               next
[10:33:38.578]                             invokeRestart(restart)
[10:33:38.578]                             muffled <- TRUE
[10:33:38.578]                             break
[10:33:38.578]                           }
[10:33:38.578]                         }
[10:33:38.578]                       }
[10:33:38.578]                       invisible(muffled)
[10:33:38.578]                     }
[10:33:38.578]                     muffleCondition(cond, pattern = "^muffle")
[10:33:38.578]                   }
[10:33:38.578]                 }
[10:33:38.578]                 else {
[10:33:38.578]                   if (TRUE) {
[10:33:38.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:38.578]                     {
[10:33:38.578]                       inherits <- base::inherits
[10:33:38.578]                       invokeRestart <- base::invokeRestart
[10:33:38.578]                       is.null <- base::is.null
[10:33:38.578]                       muffled <- FALSE
[10:33:38.578]                       if (inherits(cond, "message")) {
[10:33:38.578]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:38.578]                         if (muffled) 
[10:33:38.578]                           invokeRestart("muffleMessage")
[10:33:38.578]                       }
[10:33:38.578]                       else if (inherits(cond, "warning")) {
[10:33:38.578]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:38.578]                         if (muffled) 
[10:33:38.578]                           invokeRestart("muffleWarning")
[10:33:38.578]                       }
[10:33:38.578]                       else if (inherits(cond, "condition")) {
[10:33:38.578]                         if (!is.null(pattern)) {
[10:33:38.578]                           computeRestarts <- base::computeRestarts
[10:33:38.578]                           grepl <- base::grepl
[10:33:38.578]                           restarts <- computeRestarts(cond)
[10:33:38.578]                           for (restart in restarts) {
[10:33:38.578]                             name <- restart$name
[10:33:38.578]                             if (is.null(name)) 
[10:33:38.578]                               next
[10:33:38.578]                             if (!grepl(pattern, name)) 
[10:33:38.578]                               next
[10:33:38.578]                             invokeRestart(restart)
[10:33:38.578]                             muffled <- TRUE
[10:33:38.578]                             break
[10:33:38.578]                           }
[10:33:38.578]                         }
[10:33:38.578]                       }
[10:33:38.578]                       invisible(muffled)
[10:33:38.578]                     }
[10:33:38.578]                     muffleCondition(cond, pattern = "^muffle")
[10:33:38.578]                   }
[10:33:38.578]                 }
[10:33:38.578]             }
[10:33:38.578]         }))
[10:33:38.578]     }, error = function(ex) {
[10:33:38.578]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:38.578]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:38.578]                 ...future.rng), started = ...future.startTime, 
[10:33:38.578]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:38.578]             version = "1.8"), class = "FutureResult")
[10:33:38.578]     }, finally = {
[10:33:38.578]         if (!identical(...future.workdir, getwd())) 
[10:33:38.578]             setwd(...future.workdir)
[10:33:38.578]         {
[10:33:38.578]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:38.578]                 ...future.oldOptions$nwarnings <- NULL
[10:33:38.578]             }
[10:33:38.578]             base::options(...future.oldOptions)
[10:33:38.578]             if (.Platform$OS.type == "windows") {
[10:33:38.578]                 old_names <- names(...future.oldEnvVars)
[10:33:38.578]                 envs <- base::Sys.getenv()
[10:33:38.578]                 names <- names(envs)
[10:33:38.578]                 common <- intersect(names, old_names)
[10:33:38.578]                 added <- setdiff(names, old_names)
[10:33:38.578]                 removed <- setdiff(old_names, names)
[10:33:38.578]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:38.578]                   envs[common]]
[10:33:38.578]                 NAMES <- toupper(changed)
[10:33:38.578]                 args <- list()
[10:33:38.578]                 for (kk in seq_along(NAMES)) {
[10:33:38.578]                   name <- changed[[kk]]
[10:33:38.578]                   NAME <- NAMES[[kk]]
[10:33:38.578]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:38.578]                     next
[10:33:38.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:38.578]                 }
[10:33:38.578]                 NAMES <- toupper(added)
[10:33:38.578]                 for (kk in seq_along(NAMES)) {
[10:33:38.578]                   name <- added[[kk]]
[10:33:38.578]                   NAME <- NAMES[[kk]]
[10:33:38.578]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:38.578]                     next
[10:33:38.578]                   args[[name]] <- ""
[10:33:38.578]                 }
[10:33:38.578]                 NAMES <- toupper(removed)
[10:33:38.578]                 for (kk in seq_along(NAMES)) {
[10:33:38.578]                   name <- removed[[kk]]
[10:33:38.578]                   NAME <- NAMES[[kk]]
[10:33:38.578]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:38.578]                     next
[10:33:38.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:38.578]                 }
[10:33:38.578]                 if (length(args) > 0) 
[10:33:38.578]                   base::do.call(base::Sys.setenv, args = args)
[10:33:38.578]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:38.578]             }
[10:33:38.578]             else {
[10:33:38.578]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:38.578]             }
[10:33:38.578]             {
[10:33:38.578]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:38.578]                   0L) {
[10:33:38.578]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:38.578]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:38.578]                   base::options(opts)
[10:33:38.578]                 }
[10:33:38.578]                 {
[10:33:38.578]                   {
[10:33:38.578]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:38.578]                     NULL
[10:33:38.578]                   }
[10:33:38.578]                   options(future.plan = NULL)
[10:33:38.578]                   if (is.na(NA_character_)) 
[10:33:38.578]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:38.578]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:38.578]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:38.578]                     .init = FALSE)
[10:33:38.578]                 }
[10:33:38.578]             }
[10:33:38.578]         }
[10:33:38.578]     })
[10:33:38.578]     if (TRUE) {
[10:33:38.578]         base::sink(type = "output", split = FALSE)
[10:33:38.578]         if (TRUE) {
[10:33:38.578]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:38.578]         }
[10:33:38.578]         else {
[10:33:38.578]             ...future.result["stdout"] <- base::list(NULL)
[10:33:38.578]         }
[10:33:38.578]         base::close(...future.stdout)
[10:33:38.578]         ...future.stdout <- NULL
[10:33:38.578]     }
[10:33:38.578]     ...future.result$conditions <- ...future.conditions
[10:33:38.578]     ...future.result$finished <- base::Sys.time()
[10:33:38.578]     ...future.result
[10:33:38.578] }
[10:33:38.581] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[10:33:38.581] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[10:33:38.581] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[10:33:38.581] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[10:33:38.582] MultisessionFuture started
[10:33:38.582] - Launch lazy future ... done
[10:33:38.582] run() for ‘MultisessionFuture’ ... done
[10:33:38.583] result() for ClusterFuture ...
[10:33:38.583] receiveMessageFromWorker() for ClusterFuture ...
[10:33:38.583] - Validating connection of MultisessionFuture
[10:33:38.630] - received message: FutureResult
[10:33:38.630] - Received FutureResult
[10:33:38.630] - Erased future from FutureRegistry
[10:33:38.631] result() for ClusterFuture ...
[10:33:38.631] - result already collected: FutureResult
[10:33:38.631] result() for ClusterFuture ... done
[10:33:38.631] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:38.631] result() for ClusterFuture ... done
[10:33:38.631] result() for ClusterFuture ...
[10:33:38.631] - result already collected: FutureResult
[10:33:38.631] result() for ClusterFuture ... done
- plan(list('multisession', 'sequential')) ... DONE
- plan(list('multisession', 'multicore')) ...
[10:33:38.631] plan(): Setting new future strategy stack:
[10:33:38.632] List of future strategies:
[10:33:38.632] 1. multisession:
[10:33:38.632]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:38.632]    - tweaked: FALSE
[10:33:38.632]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:38.632] 2. multicore:
[10:33:38.632]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:38.632]    - tweaked: FALSE
[10:33:38.632]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:38.632] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:33:38.633] multisession:
[10:33:38.633] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:38.633] - tweaked: FALSE
[10:33:38.633] - call: plan(list(a = strategy1, b = strategy2))
[10:33:38.637] getGlobalsAndPackages() ...
[10:33:38.637] Not searching for globals
[10:33:38.637] - globals: [0] <none>
[10:33:38.638] getGlobalsAndPackages() ... DONE
[10:33:38.638] [local output] makeClusterPSOCK() ...
[10:33:38.643] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:33:38.644] [local output] Base port: 11605
[10:33:38.644] [local output] Getting setup options for 2 cluster nodes ...
[10:33:38.644] [local output]  - Node 1 of 2 ...
[10:33:38.644] [local output] localMachine=TRUE => revtunnel=FALSE

[10:33:38.645] [local output] Rscript port: 11605

[10:33:38.646] [local output]  - Node 2 of 2 ...
[10:33:38.647] [local output] localMachine=TRUE => revtunnel=FALSE

[10:33:38.647] [local output] Rscript port: 11605

[10:33:38.648] [local output] Getting setup options for 2 cluster nodes ... done
[10:33:38.648] [local output]  - Parallel setup requested for some PSOCK nodes
[10:33:38.648] [local output] Setting up PSOCK nodes in parallel
[10:33:38.648] List of 36
[10:33:38.648]  $ worker          : chr "localhost"
[10:33:38.648]   ..- attr(*, "localhost")= logi TRUE
[10:33:38.648]  $ master          : chr "localhost"
[10:33:38.648]  $ port            : int 11605
[10:33:38.648]  $ connectTimeout  : num 120
[10:33:38.648]  $ timeout         : num 2592000
[10:33:38.648]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:33:38.648]  $ homogeneous     : logi TRUE
[10:33:38.648]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:33:38.648]  $ rscript_envs    : NULL
[10:33:38.648]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:33:38.648]  $ rscript_startup : NULL
[10:33:38.648]  $ rscript_sh      : chr "sh"
[10:33:38.648]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:33:38.648]  $ methods         : logi TRUE
[10:33:38.648]  $ socketOptions   : chr "no-delay"
[10:33:38.648]  $ useXDR          : logi FALSE
[10:33:38.648]  $ outfile         : chr "/dev/null"
[10:33:38.648]  $ renice          : int NA
[10:33:38.648]  $ rshcmd          : NULL
[10:33:38.648]  $ user            : chr(0) 
[10:33:38.648]  $ revtunnel       : logi FALSE
[10:33:38.648]  $ rshlogfile      : NULL
[10:33:38.648]  $ rshopts         : chr(0) 
[10:33:38.648]  $ rank            : int 1
[10:33:38.648]  $ manual          : logi FALSE
[10:33:38.648]  $ dryrun          : logi FALSE
[10:33:38.648]  $ quiet           : logi FALSE
[10:33:38.648]  $ setup_strategy  : chr "parallel"
[10:33:38.648]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:33:38.648]  $ pidfile         : chr "/tmp/RtmpTlTEh1/worker.rank=1.parallelly.parent=87069.1541d32dbc488.pid"
[10:33:38.648]  $ rshcmd_label    : NULL
[10:33:38.648]  $ rsh_call        : NULL
[10:33:38.648]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:33:38.648]  $ localMachine    : logi TRUE
[10:33:38.648]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:33:38.648]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:33:38.648]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:33:38.648]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:33:38.648]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:33:38.648]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:33:38.648]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:33:38.648]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:33:38.648]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:33:38.648]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:33:38.648]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:33:38.648]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:33:38.648]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:33:38.648]  $ arguments       :List of 28
[10:33:38.648]   ..$ worker          : chr "localhost"
[10:33:38.648]   ..$ master          : NULL
[10:33:38.648]   ..$ port            : int 11605
[10:33:38.648]   ..$ connectTimeout  : num 120
[10:33:38.648]   ..$ timeout         : num 2592000
[10:33:38.648]   ..$ rscript         : NULL
[10:33:38.648]   ..$ homogeneous     : NULL
[10:33:38.648]   ..$ rscript_args    : NULL
[10:33:38.648]   ..$ rscript_envs    : NULL
[10:33:38.648]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:33:38.648]   ..$ rscript_startup : NULL
[10:33:38.648]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:33:38.648]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:33:38.648]   ..$ methods         : logi TRUE
[10:33:38.648]   ..$ socketOptions   : chr "no-delay"
[10:33:38.648]   ..$ useXDR          : logi FALSE
[10:33:38.648]   ..$ outfile         : chr "/dev/null"
[10:33:38.648]   ..$ renice          : int NA
[10:33:38.648]   ..$ rshcmd          : NULL
[10:33:38.648]   ..$ user            : NULL
[10:33:38.648]   ..$ revtunnel       : logi NA
[10:33:38.648]   ..$ rshlogfile      : NULL
[10:33:38.648]   ..$ rshopts         : NULL
[10:33:38.648]   ..$ rank            : int 1
[10:33:38.648]   ..$ manual          : logi FALSE
[10:33:38.648]   ..$ dryrun          : logi FALSE
[10:33:38.648]   ..$ quiet           : logi FALSE
[10:33:38.648]   ..$ setup_strategy  : chr "parallel"
[10:33:38.648]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:33:38.666] [local output] System call to launch all workers:
[10:33:38.666] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpTlTEh1/worker.rank=1.parallelly.parent=87069.1541d32dbc488.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11605 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:33:38.666] [local output] Starting PSOCK main server
[10:33:38.668] [local output] Workers launched
[10:33:38.668] [local output] Waiting for workers to connect back
[10:33:38.668]  - [local output] 0 workers out of 2 ready
[10:33:38.906]  - [local output] 0 workers out of 2 ready
[10:33:38.907]  - [local output] 1 workers out of 2 ready
[10:33:38.907]  - [local output] 2 workers out of 2 ready
[10:33:38.907] [local output] Launching of workers completed
[10:33:38.907] [local output] Collecting session information from workers
[10:33:38.908] [local output]  - Worker #1 of 2
[10:33:38.908] [local output]  - Worker #2 of 2
[10:33:38.908] [local output] makeClusterPSOCK() ... done
[10:33:38.919] Packages needed by the future expression (n = 0): <none>
[10:33:38.919] Packages needed by future strategies (n = 1): ‘future’
[10:33:38.920] {
[10:33:38.920]     {
[10:33:38.920]         {
[10:33:38.920]             ...future.startTime <- base::Sys.time()
[10:33:38.920]             {
[10:33:38.920]                 {
[10:33:38.920]                   {
[10:33:38.920]                     {
[10:33:38.920]                       {
[10:33:38.920]                         base::local({
[10:33:38.920]                           has_future <- base::requireNamespace("future", 
[10:33:38.920]                             quietly = TRUE)
[10:33:38.920]                           if (has_future) {
[10:33:38.920]                             ns <- base::getNamespace("future")
[10:33:38.920]                             version <- ns[[".package"]][["version"]]
[10:33:38.920]                             if (is.null(version)) 
[10:33:38.920]                               version <- utils::packageVersion("future")
[10:33:38.920]                           }
[10:33:38.920]                           else {
[10:33:38.920]                             version <- NULL
[10:33:38.920]                           }
[10:33:38.920]                           if (!has_future || version < "1.8.0") {
[10:33:38.920]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:38.920]                               "", base::R.version$version.string), 
[10:33:38.920]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:38.920]                                 base::R.version$platform, 8 * 
[10:33:38.920]                                   base::.Machine$sizeof.pointer), 
[10:33:38.920]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:38.920]                                 "release", "version")], collapse = " "), 
[10:33:38.920]                               hostname = base::Sys.info()[["nodename"]])
[10:33:38.920]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:38.920]                               info)
[10:33:38.920]                             info <- base::paste(info, collapse = "; ")
[10:33:38.920]                             if (!has_future) {
[10:33:38.920]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:38.920]                                 info)
[10:33:38.920]                             }
[10:33:38.920]                             else {
[10:33:38.920]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:38.920]                                 info, version)
[10:33:38.920]                             }
[10:33:38.920]                             base::stop(msg)
[10:33:38.920]                           }
[10:33:38.920]                         })
[10:33:38.920]                       }
[10:33:38.920]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:38.920]                       base::options(mc.cores = 1L)
[10:33:38.920]                     }
[10:33:38.920]                     base::local({
[10:33:38.920]                       for (pkg in "future") {
[10:33:38.920]                         base::loadNamespace(pkg)
[10:33:38.920]                         base::library(pkg, character.only = TRUE)
[10:33:38.920]                       }
[10:33:38.920]                     })
[10:33:38.920]                   }
[10:33:38.920]                   ...future.strategy.old <- future::plan("list")
[10:33:38.920]                   options(future.plan = NULL)
[10:33:38.920]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:38.920]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:33:38.920]                     envir = parent.frame()) 
[10:33:38.920]                   {
[10:33:38.920]                     default_workers <- missing(workers)
[10:33:38.920]                     if (is.function(workers)) 
[10:33:38.920]                       workers <- workers()
[10:33:38.920]                     workers <- structure(as.integer(workers), 
[10:33:38.920]                       class = class(workers))
[10:33:38.920]                     stop_if_not(is.finite(workers), workers >= 
[10:33:38.920]                       1L)
[10:33:38.920]                     if ((workers == 1L && !inherits(workers, 
[10:33:38.920]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:33:38.920]                       if (default_workers) 
[10:33:38.920]                         supportsMulticore(warn = TRUE)
[10:33:38.920]                       return(sequential(..., envir = envir))
[10:33:38.920]                     }
[10:33:38.920]                     oopts <- options(mc.cores = workers)
[10:33:38.920]                     on.exit(options(oopts))
[10:33:38.920]                     future <- MulticoreFuture(..., workers = workers, 
[10:33:38.920]                       envir = envir)
[10:33:38.920]                     if (!future$lazy) 
[10:33:38.920]                       future <- run(future)
[10:33:38.920]                     invisible(future)
[10:33:38.920]                   }), .cleanup = FALSE, .init = FALSE)
[10:33:38.920]                 }
[10:33:38.920]                 ...future.workdir <- getwd()
[10:33:38.920]             }
[10:33:38.920]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:38.920]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:38.920]         }
[10:33:38.920]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:38.920]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:38.920]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:38.920]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:38.920]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:38.920]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:38.920]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:38.920]             base::names(...future.oldOptions))
[10:33:38.920]     }
[10:33:38.920]     if (FALSE) {
[10:33:38.920]     }
[10:33:38.920]     else {
[10:33:38.920]         if (TRUE) {
[10:33:38.920]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:38.920]                 open = "w")
[10:33:38.920]         }
[10:33:38.920]         else {
[10:33:38.920]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:38.920]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:38.920]         }
[10:33:38.920]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:38.920]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:38.920]             base::sink(type = "output", split = FALSE)
[10:33:38.920]             base::close(...future.stdout)
[10:33:38.920]         }, add = TRUE)
[10:33:38.920]     }
[10:33:38.920]     ...future.frame <- base::sys.nframe()
[10:33:38.920]     ...future.conditions <- base::list()
[10:33:38.920]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:38.920]     if (FALSE) {
[10:33:38.920]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:38.920]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:38.920]     }
[10:33:38.920]     ...future.result <- base::tryCatch({
[10:33:38.920]         base::withCallingHandlers({
[10:33:38.920]             ...future.value <- base::withVisible(base::local({
[10:33:38.920]                 ...future.makeSendCondition <- base::local({
[10:33:38.920]                   sendCondition <- NULL
[10:33:38.920]                   function(frame = 1L) {
[10:33:38.920]                     if (is.function(sendCondition)) 
[10:33:38.920]                       return(sendCondition)
[10:33:38.920]                     ns <- getNamespace("parallel")
[10:33:38.920]                     if (exists("sendData", mode = "function", 
[10:33:38.920]                       envir = ns)) {
[10:33:38.920]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:38.920]                         envir = ns)
[10:33:38.920]                       envir <- sys.frame(frame)
[10:33:38.920]                       master <- NULL
[10:33:38.920]                       while (!identical(envir, .GlobalEnv) && 
[10:33:38.920]                         !identical(envir, emptyenv())) {
[10:33:38.920]                         if (exists("master", mode = "list", envir = envir, 
[10:33:38.920]                           inherits = FALSE)) {
[10:33:38.920]                           master <- get("master", mode = "list", 
[10:33:38.920]                             envir = envir, inherits = FALSE)
[10:33:38.920]                           if (inherits(master, c("SOCKnode", 
[10:33:38.920]                             "SOCK0node"))) {
[10:33:38.920]                             sendCondition <<- function(cond) {
[10:33:38.920]                               data <- list(type = "VALUE", value = cond, 
[10:33:38.920]                                 success = TRUE)
[10:33:38.920]                               parallel_sendData(master, data)
[10:33:38.920]                             }
[10:33:38.920]                             return(sendCondition)
[10:33:38.920]                           }
[10:33:38.920]                         }
[10:33:38.920]                         frame <- frame + 1L
[10:33:38.920]                         envir <- sys.frame(frame)
[10:33:38.920]                       }
[10:33:38.920]                     }
[10:33:38.920]                     sendCondition <<- function(cond) NULL
[10:33:38.920]                   }
[10:33:38.920]                 })
[10:33:38.920]                 withCallingHandlers({
[10:33:38.920]                   NA
[10:33:38.920]                 }, immediateCondition = function(cond) {
[10:33:38.920]                   sendCondition <- ...future.makeSendCondition()
[10:33:38.920]                   sendCondition(cond)
[10:33:38.920]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:38.920]                   {
[10:33:38.920]                     inherits <- base::inherits
[10:33:38.920]                     invokeRestart <- base::invokeRestart
[10:33:38.920]                     is.null <- base::is.null
[10:33:38.920]                     muffled <- FALSE
[10:33:38.920]                     if (inherits(cond, "message")) {
[10:33:38.920]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:38.920]                       if (muffled) 
[10:33:38.920]                         invokeRestart("muffleMessage")
[10:33:38.920]                     }
[10:33:38.920]                     else if (inherits(cond, "warning")) {
[10:33:38.920]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:38.920]                       if (muffled) 
[10:33:38.920]                         invokeRestart("muffleWarning")
[10:33:38.920]                     }
[10:33:38.920]                     else if (inherits(cond, "condition")) {
[10:33:38.920]                       if (!is.null(pattern)) {
[10:33:38.920]                         computeRestarts <- base::computeRestarts
[10:33:38.920]                         grepl <- base::grepl
[10:33:38.920]                         restarts <- computeRestarts(cond)
[10:33:38.920]                         for (restart in restarts) {
[10:33:38.920]                           name <- restart$name
[10:33:38.920]                           if (is.null(name)) 
[10:33:38.920]                             next
[10:33:38.920]                           if (!grepl(pattern, name)) 
[10:33:38.920]                             next
[10:33:38.920]                           invokeRestart(restart)
[10:33:38.920]                           muffled <- TRUE
[10:33:38.920]                           break
[10:33:38.920]                         }
[10:33:38.920]                       }
[10:33:38.920]                     }
[10:33:38.920]                     invisible(muffled)
[10:33:38.920]                   }
[10:33:38.920]                   muffleCondition(cond)
[10:33:38.920]                 })
[10:33:38.920]             }))
[10:33:38.920]             future::FutureResult(value = ...future.value$value, 
[10:33:38.920]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:38.920]                   ...future.rng), globalenv = if (FALSE) 
[10:33:38.920]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:38.920]                     ...future.globalenv.names))
[10:33:38.920]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:38.920]         }, condition = base::local({
[10:33:38.920]             c <- base::c
[10:33:38.920]             inherits <- base::inherits
[10:33:38.920]             invokeRestart <- base::invokeRestart
[10:33:38.920]             length <- base::length
[10:33:38.920]             list <- base::list
[10:33:38.920]             seq.int <- base::seq.int
[10:33:38.920]             signalCondition <- base::signalCondition
[10:33:38.920]             sys.calls <- base::sys.calls
[10:33:38.920]             `[[` <- base::`[[`
[10:33:38.920]             `+` <- base::`+`
[10:33:38.920]             `<<-` <- base::`<<-`
[10:33:38.920]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:38.920]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:38.920]                   3L)]
[10:33:38.920]             }
[10:33:38.920]             function(cond) {
[10:33:38.920]                 is_error <- inherits(cond, "error")
[10:33:38.920]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:38.920]                   NULL)
[10:33:38.920]                 if (is_error) {
[10:33:38.920]                   sessionInformation <- function() {
[10:33:38.920]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:38.920]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:38.920]                       search = base::search(), system = base::Sys.info())
[10:33:38.920]                   }
[10:33:38.920]                   ...future.conditions[[length(...future.conditions) + 
[10:33:38.920]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:38.920]                     cond$call), session = sessionInformation(), 
[10:33:38.920]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:38.920]                   signalCondition(cond)
[10:33:38.920]                 }
[10:33:38.920]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:38.920]                 "immediateCondition"))) {
[10:33:38.920]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:38.920]                   ...future.conditions[[length(...future.conditions) + 
[10:33:38.920]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:38.920]                   if (TRUE && !signal) {
[10:33:38.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:38.920]                     {
[10:33:38.920]                       inherits <- base::inherits
[10:33:38.920]                       invokeRestart <- base::invokeRestart
[10:33:38.920]                       is.null <- base::is.null
[10:33:38.920]                       muffled <- FALSE
[10:33:38.920]                       if (inherits(cond, "message")) {
[10:33:38.920]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:38.920]                         if (muffled) 
[10:33:38.920]                           invokeRestart("muffleMessage")
[10:33:38.920]                       }
[10:33:38.920]                       else if (inherits(cond, "warning")) {
[10:33:38.920]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:38.920]                         if (muffled) 
[10:33:38.920]                           invokeRestart("muffleWarning")
[10:33:38.920]                       }
[10:33:38.920]                       else if (inherits(cond, "condition")) {
[10:33:38.920]                         if (!is.null(pattern)) {
[10:33:38.920]                           computeRestarts <- base::computeRestarts
[10:33:38.920]                           grepl <- base::grepl
[10:33:38.920]                           restarts <- computeRestarts(cond)
[10:33:38.920]                           for (restart in restarts) {
[10:33:38.920]                             name <- restart$name
[10:33:38.920]                             if (is.null(name)) 
[10:33:38.920]                               next
[10:33:38.920]                             if (!grepl(pattern, name)) 
[10:33:38.920]                               next
[10:33:38.920]                             invokeRestart(restart)
[10:33:38.920]                             muffled <- TRUE
[10:33:38.920]                             break
[10:33:38.920]                           }
[10:33:38.920]                         }
[10:33:38.920]                       }
[10:33:38.920]                       invisible(muffled)
[10:33:38.920]                     }
[10:33:38.920]                     muffleCondition(cond, pattern = "^muffle")
[10:33:38.920]                   }
[10:33:38.920]                 }
[10:33:38.920]                 else {
[10:33:38.920]                   if (TRUE) {
[10:33:38.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:38.920]                     {
[10:33:38.920]                       inherits <- base::inherits
[10:33:38.920]                       invokeRestart <- base::invokeRestart
[10:33:38.920]                       is.null <- base::is.null
[10:33:38.920]                       muffled <- FALSE
[10:33:38.920]                       if (inherits(cond, "message")) {
[10:33:38.920]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:38.920]                         if (muffled) 
[10:33:38.920]                           invokeRestart("muffleMessage")
[10:33:38.920]                       }
[10:33:38.920]                       else if (inherits(cond, "warning")) {
[10:33:38.920]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:38.920]                         if (muffled) 
[10:33:38.920]                           invokeRestart("muffleWarning")
[10:33:38.920]                       }
[10:33:38.920]                       else if (inherits(cond, "condition")) {
[10:33:38.920]                         if (!is.null(pattern)) {
[10:33:38.920]                           computeRestarts <- base::computeRestarts
[10:33:38.920]                           grepl <- base::grepl
[10:33:38.920]                           restarts <- computeRestarts(cond)
[10:33:38.920]                           for (restart in restarts) {
[10:33:38.920]                             name <- restart$name
[10:33:38.920]                             if (is.null(name)) 
[10:33:38.920]                               next
[10:33:38.920]                             if (!grepl(pattern, name)) 
[10:33:38.920]                               next
[10:33:38.920]                             invokeRestart(restart)
[10:33:38.920]                             muffled <- TRUE
[10:33:38.920]                             break
[10:33:38.920]                           }
[10:33:38.920]                         }
[10:33:38.920]                       }
[10:33:38.920]                       invisible(muffled)
[10:33:38.920]                     }
[10:33:38.920]                     muffleCondition(cond, pattern = "^muffle")
[10:33:38.920]                   }
[10:33:38.920]                 }
[10:33:38.920]             }
[10:33:38.920]         }))
[10:33:38.920]     }, error = function(ex) {
[10:33:38.920]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:38.920]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:38.920]                 ...future.rng), started = ...future.startTime, 
[10:33:38.920]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:38.920]             version = "1.8"), class = "FutureResult")
[10:33:38.920]     }, finally = {
[10:33:38.920]         if (!identical(...future.workdir, getwd())) 
[10:33:38.920]             setwd(...future.workdir)
[10:33:38.920]         {
[10:33:38.920]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:38.920]                 ...future.oldOptions$nwarnings <- NULL
[10:33:38.920]             }
[10:33:38.920]             base::options(...future.oldOptions)
[10:33:38.920]             if (.Platform$OS.type == "windows") {
[10:33:38.920]                 old_names <- names(...future.oldEnvVars)
[10:33:38.920]                 envs <- base::Sys.getenv()
[10:33:38.920]                 names <- names(envs)
[10:33:38.920]                 common <- intersect(names, old_names)
[10:33:38.920]                 added <- setdiff(names, old_names)
[10:33:38.920]                 removed <- setdiff(old_names, names)
[10:33:38.920]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:38.920]                   envs[common]]
[10:33:38.920]                 NAMES <- toupper(changed)
[10:33:38.920]                 args <- list()
[10:33:38.920]                 for (kk in seq_along(NAMES)) {
[10:33:38.920]                   name <- changed[[kk]]
[10:33:38.920]                   NAME <- NAMES[[kk]]
[10:33:38.920]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:38.920]                     next
[10:33:38.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:38.920]                 }
[10:33:38.920]                 NAMES <- toupper(added)
[10:33:38.920]                 for (kk in seq_along(NAMES)) {
[10:33:38.920]                   name <- added[[kk]]
[10:33:38.920]                   NAME <- NAMES[[kk]]
[10:33:38.920]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:38.920]                     next
[10:33:38.920]                   args[[name]] <- ""
[10:33:38.920]                 }
[10:33:38.920]                 NAMES <- toupper(removed)
[10:33:38.920]                 for (kk in seq_along(NAMES)) {
[10:33:38.920]                   name <- removed[[kk]]
[10:33:38.920]                   NAME <- NAMES[[kk]]
[10:33:38.920]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:38.920]                     next
[10:33:38.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:38.920]                 }
[10:33:38.920]                 if (length(args) > 0) 
[10:33:38.920]                   base::do.call(base::Sys.setenv, args = args)
[10:33:38.920]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:38.920]             }
[10:33:38.920]             else {
[10:33:38.920]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:38.920]             }
[10:33:38.920]             {
[10:33:38.920]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:38.920]                   0L) {
[10:33:38.920]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:38.920]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:38.920]                   base::options(opts)
[10:33:38.920]                 }
[10:33:38.920]                 {
[10:33:38.920]                   {
[10:33:38.920]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:38.920]                     NULL
[10:33:38.920]                   }
[10:33:38.920]                   options(future.plan = NULL)
[10:33:38.920]                   if (is.na(NA_character_)) 
[10:33:38.920]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:38.920]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:38.920]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:38.920]                     .init = FALSE)
[10:33:38.920]                 }
[10:33:38.920]             }
[10:33:38.920]         }
[10:33:38.920]     })
[10:33:38.920]     if (TRUE) {
[10:33:38.920]         base::sink(type = "output", split = FALSE)
[10:33:38.920]         if (TRUE) {
[10:33:38.920]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:38.920]         }
[10:33:38.920]         else {
[10:33:38.920]             ...future.result["stdout"] <- base::list(NULL)
[10:33:38.920]         }
[10:33:38.920]         base::close(...future.stdout)
[10:33:38.920]         ...future.stdout <- NULL
[10:33:38.920]     }
[10:33:38.920]     ...future.result$conditions <- ...future.conditions
[10:33:38.920]     ...future.result$finished <- base::Sys.time()
[10:33:38.920]     ...future.result
[10:33:38.920] }
[10:33:38.973] MultisessionFuture started
[10:33:38.973] result() for ClusterFuture ...
[10:33:38.973] receiveMessageFromWorker() for ClusterFuture ...
[10:33:38.974] - Validating connection of MultisessionFuture
[10:33:39.021] - received message: FutureResult
[10:33:39.021] - Received FutureResult
[10:33:39.022] - Erased future from FutureRegistry
[10:33:39.022] result() for ClusterFuture ...
[10:33:39.022] - result already collected: FutureResult
[10:33:39.022] result() for ClusterFuture ... done
[10:33:39.022] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:39.022] result() for ClusterFuture ... done
[10:33:39.022] result() for ClusterFuture ...
[10:33:39.022] - result already collected: FutureResult
[10:33:39.022] result() for ClusterFuture ... done
[10:33:39.023] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:33:39.026] plan(): nbrOfWorkers() = 2
[10:33:39.026] getGlobalsAndPackages() ...
[10:33:39.027] Searching for globals...
[10:33:39.044] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:33:39.045] Searching for globals ... DONE
[10:33:39.045] Resolving globals: FALSE
[10:33:39.046] The total size of the 2 globals is 90.70 KiB (92872 bytes)
[10:33:39.046] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 90.70 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (90.58 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[10:33:39.046] - globals: [2] ‘nested’, ‘strategy2’
[10:33:39.046] - packages: [1] ‘future’
[10:33:39.047] getGlobalsAndPackages() ... DONE
[10:33:39.047] run() for ‘Future’ ...
[10:33:39.047] - state: ‘created’
[10:33:39.047] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:39.061] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:39.061] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:39.061]   - Field: ‘node’
[10:33:39.061]   - Field: ‘label’
[10:33:39.061]   - Field: ‘local’
[10:33:39.061]   - Field: ‘owner’
[10:33:39.062]   - Field: ‘envir’
[10:33:39.062]   - Field: ‘workers’
[10:33:39.062]   - Field: ‘packages’
[10:33:39.062]   - Field: ‘gc’
[10:33:39.062]   - Field: ‘conditions’
[10:33:39.062]   - Field: ‘persistent’
[10:33:39.062]   - Field: ‘expr’
[10:33:39.062]   - Field: ‘uuid’
[10:33:39.062]   - Field: ‘seed’
[10:33:39.062]   - Field: ‘version’
[10:33:39.062]   - Field: ‘result’
[10:33:39.063]   - Field: ‘asynchronous’
[10:33:39.063]   - Field: ‘calls’
[10:33:39.063]   - Field: ‘globals’
[10:33:39.063]   - Field: ‘stdout’
[10:33:39.063]   - Field: ‘earlySignal’
[10:33:39.063]   - Field: ‘lazy’
[10:33:39.063]   - Field: ‘state’
[10:33:39.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:39.063] - Launch lazy future ...
[10:33:39.064] Packages needed by the future expression (n = 1): ‘future’
[10:33:39.064] Packages needed by future strategies (n = 1): ‘future’
[10:33:39.064] {
[10:33:39.064]     {
[10:33:39.064]         {
[10:33:39.064]             ...future.startTime <- base::Sys.time()
[10:33:39.064]             {
[10:33:39.064]                 {
[10:33:39.064]                   {
[10:33:39.064]                     {
[10:33:39.064]                       {
[10:33:39.064]                         base::local({
[10:33:39.064]                           has_future <- base::requireNamespace("future", 
[10:33:39.064]                             quietly = TRUE)
[10:33:39.064]                           if (has_future) {
[10:33:39.064]                             ns <- base::getNamespace("future")
[10:33:39.064]                             version <- ns[[".package"]][["version"]]
[10:33:39.064]                             if (is.null(version)) 
[10:33:39.064]                               version <- utils::packageVersion("future")
[10:33:39.064]                           }
[10:33:39.064]                           else {
[10:33:39.064]                             version <- NULL
[10:33:39.064]                           }
[10:33:39.064]                           if (!has_future || version < "1.8.0") {
[10:33:39.064]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:39.064]                               "", base::R.version$version.string), 
[10:33:39.064]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:39.064]                                 base::R.version$platform, 8 * 
[10:33:39.064]                                   base::.Machine$sizeof.pointer), 
[10:33:39.064]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:39.064]                                 "release", "version")], collapse = " "), 
[10:33:39.064]                               hostname = base::Sys.info()[["nodename"]])
[10:33:39.064]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:39.064]                               info)
[10:33:39.064]                             info <- base::paste(info, collapse = "; ")
[10:33:39.064]                             if (!has_future) {
[10:33:39.064]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:39.064]                                 info)
[10:33:39.064]                             }
[10:33:39.064]                             else {
[10:33:39.064]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:39.064]                                 info, version)
[10:33:39.064]                             }
[10:33:39.064]                             base::stop(msg)
[10:33:39.064]                           }
[10:33:39.064]                         })
[10:33:39.064]                       }
[10:33:39.064]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:39.064]                       base::options(mc.cores = 1L)
[10:33:39.064]                     }
[10:33:39.064]                     base::local({
[10:33:39.064]                       for (pkg in "future") {
[10:33:39.064]                         base::loadNamespace(pkg)
[10:33:39.064]                         base::library(pkg, character.only = TRUE)
[10:33:39.064]                       }
[10:33:39.064]                     })
[10:33:39.064]                   }
[10:33:39.064]                   ...future.strategy.old <- future::plan("list")
[10:33:39.064]                   options(future.plan = NULL)
[10:33:39.064]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:39.064]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:33:39.064]                     envir = parent.frame()) 
[10:33:39.064]                   {
[10:33:39.064]                     default_workers <- missing(workers)
[10:33:39.064]                     if (is.function(workers)) 
[10:33:39.064]                       workers <- workers()
[10:33:39.064]                     workers <- structure(as.integer(workers), 
[10:33:39.064]                       class = class(workers))
[10:33:39.064]                     stop_if_not(is.finite(workers), workers >= 
[10:33:39.064]                       1L)
[10:33:39.064]                     if ((workers == 1L && !inherits(workers, 
[10:33:39.064]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:33:39.064]                       if (default_workers) 
[10:33:39.064]                         supportsMulticore(warn = TRUE)
[10:33:39.064]                       return(sequential(..., envir = envir))
[10:33:39.064]                     }
[10:33:39.064]                     oopts <- options(mc.cores = workers)
[10:33:39.064]                     on.exit(options(oopts))
[10:33:39.064]                     future <- MulticoreFuture(..., workers = workers, 
[10:33:39.064]                       envir = envir)
[10:33:39.064]                     if (!future$lazy) 
[10:33:39.064]                       future <- run(future)
[10:33:39.064]                     invisible(future)
[10:33:39.064]                   }), .cleanup = FALSE, .init = FALSE)
[10:33:39.064]                 }
[10:33:39.064]                 ...future.workdir <- getwd()
[10:33:39.064]             }
[10:33:39.064]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:39.064]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:39.064]         }
[10:33:39.064]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:39.064]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:39.064]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:39.064]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:39.064]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:39.064]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:39.064]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:39.064]             base::names(...future.oldOptions))
[10:33:39.064]     }
[10:33:39.064]     if (FALSE) {
[10:33:39.064]     }
[10:33:39.064]     else {
[10:33:39.064]         if (TRUE) {
[10:33:39.064]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:39.064]                 open = "w")
[10:33:39.064]         }
[10:33:39.064]         else {
[10:33:39.064]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:39.064]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:39.064]         }
[10:33:39.064]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:39.064]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:39.064]             base::sink(type = "output", split = FALSE)
[10:33:39.064]             base::close(...future.stdout)
[10:33:39.064]         }, add = TRUE)
[10:33:39.064]     }
[10:33:39.064]     ...future.frame <- base::sys.nframe()
[10:33:39.064]     ...future.conditions <- base::list()
[10:33:39.064]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:39.064]     if (FALSE) {
[10:33:39.064]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:39.064]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:39.064]     }
[10:33:39.064]     ...future.result <- base::tryCatch({
[10:33:39.064]         base::withCallingHandlers({
[10:33:39.064]             ...future.value <- base::withVisible(base::local({
[10:33:39.064]                 ...future.makeSendCondition <- base::local({
[10:33:39.064]                   sendCondition <- NULL
[10:33:39.064]                   function(frame = 1L) {
[10:33:39.064]                     if (is.function(sendCondition)) 
[10:33:39.064]                       return(sendCondition)
[10:33:39.064]                     ns <- getNamespace("parallel")
[10:33:39.064]                     if (exists("sendData", mode = "function", 
[10:33:39.064]                       envir = ns)) {
[10:33:39.064]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:39.064]                         envir = ns)
[10:33:39.064]                       envir <- sys.frame(frame)
[10:33:39.064]                       master <- NULL
[10:33:39.064]                       while (!identical(envir, .GlobalEnv) && 
[10:33:39.064]                         !identical(envir, emptyenv())) {
[10:33:39.064]                         if (exists("master", mode = "list", envir = envir, 
[10:33:39.064]                           inherits = FALSE)) {
[10:33:39.064]                           master <- get("master", mode = "list", 
[10:33:39.064]                             envir = envir, inherits = FALSE)
[10:33:39.064]                           if (inherits(master, c("SOCKnode", 
[10:33:39.064]                             "SOCK0node"))) {
[10:33:39.064]                             sendCondition <<- function(cond) {
[10:33:39.064]                               data <- list(type = "VALUE", value = cond, 
[10:33:39.064]                                 success = TRUE)
[10:33:39.064]                               parallel_sendData(master, data)
[10:33:39.064]                             }
[10:33:39.064]                             return(sendCondition)
[10:33:39.064]                           }
[10:33:39.064]                         }
[10:33:39.064]                         frame <- frame + 1L
[10:33:39.064]                         envir <- sys.frame(frame)
[10:33:39.064]                       }
[10:33:39.064]                     }
[10:33:39.064]                     sendCondition <<- function(cond) NULL
[10:33:39.064]                   }
[10:33:39.064]                 })
[10:33:39.064]                 withCallingHandlers({
[10:33:39.064]                   {
[10:33:39.064]                     a <- 1L
[10:33:39.064]                     plan_a <- unclass(future::plan("list"))
[10:33:39.064]                     nested_a <- nested[-1]
[10:33:39.064]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:33:39.064]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:33:39.064]                       strategy2))
[10:33:39.064]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:33:39.064]                       "init") <- NULL
[10:33:39.064]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:33:39.064]                       "init") <- NULL
[10:33:39.064]                     stopifnot(all.equal(plan_a, nested_a))
[10:33:39.064]                     y %<-% {
[10:33:39.064]                       b <- 2L
[10:33:39.064]                       plan_b <- future::plan("list")
[10:33:39.064]                       nested_b <- nested_a[-1]
[10:33:39.064]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:33:39.064]                         1L, inherits(plan_b[[1]], "future"), 
[10:33:39.064]                         inherits(future::plan("next"), "sequential"))
[10:33:39.064]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:33:39.064]                         b = b, nested_b = nested_b, plan_b = plan_b)
[10:33:39.064]                     }
[10:33:39.064]                     y
[10:33:39.064]                   }
[10:33:39.064]                 }, immediateCondition = function(cond) {
[10:33:39.064]                   sendCondition <- ...future.makeSendCondition()
[10:33:39.064]                   sendCondition(cond)
[10:33:39.064]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:39.064]                   {
[10:33:39.064]                     inherits <- base::inherits
[10:33:39.064]                     invokeRestart <- base::invokeRestart
[10:33:39.064]                     is.null <- base::is.null
[10:33:39.064]                     muffled <- FALSE
[10:33:39.064]                     if (inherits(cond, "message")) {
[10:33:39.064]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:39.064]                       if (muffled) 
[10:33:39.064]                         invokeRestart("muffleMessage")
[10:33:39.064]                     }
[10:33:39.064]                     else if (inherits(cond, "warning")) {
[10:33:39.064]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:39.064]                       if (muffled) 
[10:33:39.064]                         invokeRestart("muffleWarning")
[10:33:39.064]                     }
[10:33:39.064]                     else if (inherits(cond, "condition")) {
[10:33:39.064]                       if (!is.null(pattern)) {
[10:33:39.064]                         computeRestarts <- base::computeRestarts
[10:33:39.064]                         grepl <- base::grepl
[10:33:39.064]                         restarts <- computeRestarts(cond)
[10:33:39.064]                         for (restart in restarts) {
[10:33:39.064]                           name <- restart$name
[10:33:39.064]                           if (is.null(name)) 
[10:33:39.064]                             next
[10:33:39.064]                           if (!grepl(pattern, name)) 
[10:33:39.064]                             next
[10:33:39.064]                           invokeRestart(restart)
[10:33:39.064]                           muffled <- TRUE
[10:33:39.064]                           break
[10:33:39.064]                         }
[10:33:39.064]                       }
[10:33:39.064]                     }
[10:33:39.064]                     invisible(muffled)
[10:33:39.064]                   }
[10:33:39.064]                   muffleCondition(cond)
[10:33:39.064]                 })
[10:33:39.064]             }))
[10:33:39.064]             future::FutureResult(value = ...future.value$value, 
[10:33:39.064]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:39.064]                   ...future.rng), globalenv = if (FALSE) 
[10:33:39.064]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:39.064]                     ...future.globalenv.names))
[10:33:39.064]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:39.064]         }, condition = base::local({
[10:33:39.064]             c <- base::c
[10:33:39.064]             inherits <- base::inherits
[10:33:39.064]             invokeRestart <- base::invokeRestart
[10:33:39.064]             length <- base::length
[10:33:39.064]             list <- base::list
[10:33:39.064]             seq.int <- base::seq.int
[10:33:39.064]             signalCondition <- base::signalCondition
[10:33:39.064]             sys.calls <- base::sys.calls
[10:33:39.064]             `[[` <- base::`[[`
[10:33:39.064]             `+` <- base::`+`
[10:33:39.064]             `<<-` <- base::`<<-`
[10:33:39.064]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:39.064]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:39.064]                   3L)]
[10:33:39.064]             }
[10:33:39.064]             function(cond) {
[10:33:39.064]                 is_error <- inherits(cond, "error")
[10:33:39.064]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:39.064]                   NULL)
[10:33:39.064]                 if (is_error) {
[10:33:39.064]                   sessionInformation <- function() {
[10:33:39.064]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:39.064]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:39.064]                       search = base::search(), system = base::Sys.info())
[10:33:39.064]                   }
[10:33:39.064]                   ...future.conditions[[length(...future.conditions) + 
[10:33:39.064]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:39.064]                     cond$call), session = sessionInformation(), 
[10:33:39.064]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:39.064]                   signalCondition(cond)
[10:33:39.064]                 }
[10:33:39.064]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:39.064]                 "immediateCondition"))) {
[10:33:39.064]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:39.064]                   ...future.conditions[[length(...future.conditions) + 
[10:33:39.064]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:39.064]                   if (TRUE && !signal) {
[10:33:39.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:39.064]                     {
[10:33:39.064]                       inherits <- base::inherits
[10:33:39.064]                       invokeRestart <- base::invokeRestart
[10:33:39.064]                       is.null <- base::is.null
[10:33:39.064]                       muffled <- FALSE
[10:33:39.064]                       if (inherits(cond, "message")) {
[10:33:39.064]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:39.064]                         if (muffled) 
[10:33:39.064]                           invokeRestart("muffleMessage")
[10:33:39.064]                       }
[10:33:39.064]                       else if (inherits(cond, "warning")) {
[10:33:39.064]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:39.064]                         if (muffled) 
[10:33:39.064]                           invokeRestart("muffleWarning")
[10:33:39.064]                       }
[10:33:39.064]                       else if (inherits(cond, "condition")) {
[10:33:39.064]                         if (!is.null(pattern)) {
[10:33:39.064]                           computeRestarts <- base::computeRestarts
[10:33:39.064]                           grepl <- base::grepl
[10:33:39.064]                           restarts <- computeRestarts(cond)
[10:33:39.064]                           for (restart in restarts) {
[10:33:39.064]                             name <- restart$name
[10:33:39.064]                             if (is.null(name)) 
[10:33:39.064]                               next
[10:33:39.064]                             if (!grepl(pattern, name)) 
[10:33:39.064]                               next
[10:33:39.064]                             invokeRestart(restart)
[10:33:39.064]                             muffled <- TRUE
[10:33:39.064]                             break
[10:33:39.064]                           }
[10:33:39.064]                         }
[10:33:39.064]                       }
[10:33:39.064]                       invisible(muffled)
[10:33:39.064]                     }
[10:33:39.064]                     muffleCondition(cond, pattern = "^muffle")
[10:33:39.064]                   }
[10:33:39.064]                 }
[10:33:39.064]                 else {
[10:33:39.064]                   if (TRUE) {
[10:33:39.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:39.064]                     {
[10:33:39.064]                       inherits <- base::inherits
[10:33:39.064]                       invokeRestart <- base::invokeRestart
[10:33:39.064]                       is.null <- base::is.null
[10:33:39.064]                       muffled <- FALSE
[10:33:39.064]                       if (inherits(cond, "message")) {
[10:33:39.064]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:39.064]                         if (muffled) 
[10:33:39.064]                           invokeRestart("muffleMessage")
[10:33:39.064]                       }
[10:33:39.064]                       else if (inherits(cond, "warning")) {
[10:33:39.064]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:39.064]                         if (muffled) 
[10:33:39.064]                           invokeRestart("muffleWarning")
[10:33:39.064]                       }
[10:33:39.064]                       else if (inherits(cond, "condition")) {
[10:33:39.064]                         if (!is.null(pattern)) {
[10:33:39.064]                           computeRestarts <- base::computeRestarts
[10:33:39.064]                           grepl <- base::grepl
[10:33:39.064]                           restarts <- computeRestarts(cond)
[10:33:39.064]                           for (restart in restarts) {
[10:33:39.064]                             name <- restart$name
[10:33:39.064]                             if (is.null(name)) 
[10:33:39.064]                               next
[10:33:39.064]                             if (!grepl(pattern, name)) 
[10:33:39.064]                               next
[10:33:39.064]                             invokeRestart(restart)
[10:33:39.064]                             muffled <- TRUE
[10:33:39.064]                             break
[10:33:39.064]                           }
[10:33:39.064]                         }
[10:33:39.064]                       }
[10:33:39.064]                       invisible(muffled)
[10:33:39.064]                     }
[10:33:39.064]                     muffleCondition(cond, pattern = "^muffle")
[10:33:39.064]                   }
[10:33:39.064]                 }
[10:33:39.064]             }
[10:33:39.064]         }))
[10:33:39.064]     }, error = function(ex) {
[10:33:39.064]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:39.064]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:39.064]                 ...future.rng), started = ...future.startTime, 
[10:33:39.064]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:39.064]             version = "1.8"), class = "FutureResult")
[10:33:39.064]     }, finally = {
[10:33:39.064]         if (!identical(...future.workdir, getwd())) 
[10:33:39.064]             setwd(...future.workdir)
[10:33:39.064]         {
[10:33:39.064]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:39.064]                 ...future.oldOptions$nwarnings <- NULL
[10:33:39.064]             }
[10:33:39.064]             base::options(...future.oldOptions)
[10:33:39.064]             if (.Platform$OS.type == "windows") {
[10:33:39.064]                 old_names <- names(...future.oldEnvVars)
[10:33:39.064]                 envs <- base::Sys.getenv()
[10:33:39.064]                 names <- names(envs)
[10:33:39.064]                 common <- intersect(names, old_names)
[10:33:39.064]                 added <- setdiff(names, old_names)
[10:33:39.064]                 removed <- setdiff(old_names, names)
[10:33:39.064]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:39.064]                   envs[common]]
[10:33:39.064]                 NAMES <- toupper(changed)
[10:33:39.064]                 args <- list()
[10:33:39.064]                 for (kk in seq_along(NAMES)) {
[10:33:39.064]                   name <- changed[[kk]]
[10:33:39.064]                   NAME <- NAMES[[kk]]
[10:33:39.064]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:39.064]                     next
[10:33:39.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:39.064]                 }
[10:33:39.064]                 NAMES <- toupper(added)
[10:33:39.064]                 for (kk in seq_along(NAMES)) {
[10:33:39.064]                   name <- added[[kk]]
[10:33:39.064]                   NAME <- NAMES[[kk]]
[10:33:39.064]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:39.064]                     next
[10:33:39.064]                   args[[name]] <- ""
[10:33:39.064]                 }
[10:33:39.064]                 NAMES <- toupper(removed)
[10:33:39.064]                 for (kk in seq_along(NAMES)) {
[10:33:39.064]                   name <- removed[[kk]]
[10:33:39.064]                   NAME <- NAMES[[kk]]
[10:33:39.064]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:39.064]                     next
[10:33:39.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:39.064]                 }
[10:33:39.064]                 if (length(args) > 0) 
[10:33:39.064]                   base::do.call(base::Sys.setenv, args = args)
[10:33:39.064]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:39.064]             }
[10:33:39.064]             else {
[10:33:39.064]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:39.064]             }
[10:33:39.064]             {
[10:33:39.064]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:39.064]                   0L) {
[10:33:39.064]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:39.064]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:39.064]                   base::options(opts)
[10:33:39.064]                 }
[10:33:39.064]                 {
[10:33:39.064]                   {
[10:33:39.064]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:39.064]                     NULL
[10:33:39.064]                   }
[10:33:39.064]                   options(future.plan = NULL)
[10:33:39.064]                   if (is.na(NA_character_)) 
[10:33:39.064]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:39.064]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:39.064]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:39.064]                     .init = FALSE)
[10:33:39.064]                 }
[10:33:39.064]             }
[10:33:39.064]         }
[10:33:39.064]     })
[10:33:39.064]     if (TRUE) {
[10:33:39.064]         base::sink(type = "output", split = FALSE)
[10:33:39.064]         if (TRUE) {
[10:33:39.064]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:39.064]         }
[10:33:39.064]         else {
[10:33:39.064]             ...future.result["stdout"] <- base::list(NULL)
[10:33:39.064]         }
[10:33:39.064]         base::close(...future.stdout)
[10:33:39.064]         ...future.stdout <- NULL
[10:33:39.064]     }
[10:33:39.064]     ...future.result$conditions <- ...future.conditions
[10:33:39.064]     ...future.result$finished <- base::Sys.time()
[10:33:39.064]     ...future.result
[10:33:39.064] }
[10:33:39.067] Exporting 2 global objects (90.70 KiB) to cluster node #1 ...
[10:33:39.067] Exporting ‘nested’ (90.58 KiB) to cluster node #1 ...
[10:33:39.109] Exporting ‘nested’ (90.58 KiB) to cluster node #1 ... DONE
[10:33:39.109] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[10:33:39.110] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[10:33:39.110] Exporting 2 global objects (90.70 KiB) to cluster node #1 ... DONE
[10:33:39.110] MultisessionFuture started
[10:33:39.110] - Launch lazy future ... done
[10:33:39.111] run() for ‘MultisessionFuture’ ... done
[10:33:39.111] result() for ClusterFuture ...
[10:33:39.111] receiveMessageFromWorker() for ClusterFuture ...
[10:33:39.111] - Validating connection of MultisessionFuture
[10:33:39.185] - received message: FutureResult
[10:33:39.185] - Received FutureResult
[10:33:39.185] - Erased future from FutureRegistry
[10:33:39.185] result() for ClusterFuture ...
[10:33:39.185] - result already collected: FutureResult
[10:33:39.186] result() for ClusterFuture ... done
[10:33:39.186] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:39.186] result() for ClusterFuture ... done
[10:33:39.186] result() for ClusterFuture ...
[10:33:39.186] - result already collected: FutureResult
[10:33:39.186] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:33:39.191] getGlobalsAndPackages() ...
[10:33:39.191] Searching for globals...
[10:33:39.193] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:33:39.193] Searching for globals ... DONE
[10:33:39.193] Resolving globals: FALSE
[10:33:39.193] The total size of the 1 globals is 128 bytes (128 bytes)
[10:33:39.194] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:33:39.194] - globals: [1] ‘data’
[10:33:39.194] - packages: [1] ‘future’
[10:33:39.194] getGlobalsAndPackages() ... DONE
[10:33:39.194] run() for ‘Future’ ...
[10:33:39.195] - state: ‘created’
[10:33:39.195] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:39.208] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:39.209] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:39.209]   - Field: ‘node’
[10:33:39.209]   - Field: ‘label’
[10:33:39.209]   - Field: ‘local’
[10:33:39.209]   - Field: ‘owner’
[10:33:39.209]   - Field: ‘envir’
[10:33:39.209]   - Field: ‘workers’
[10:33:39.209]   - Field: ‘packages’
[10:33:39.209]   - Field: ‘gc’
[10:33:39.210]   - Field: ‘conditions’
[10:33:39.210]   - Field: ‘persistent’
[10:33:39.210]   - Field: ‘expr’
[10:33:39.210]   - Field: ‘uuid’
[10:33:39.210]   - Field: ‘seed’
[10:33:39.210]   - Field: ‘version’
[10:33:39.210]   - Field: ‘result’
[10:33:39.210]   - Field: ‘asynchronous’
[10:33:39.210]   - Field: ‘calls’
[10:33:39.210]   - Field: ‘globals’
[10:33:39.210]   - Field: ‘stdout’
[10:33:39.211]   - Field: ‘earlySignal’
[10:33:39.211]   - Field: ‘lazy’
[10:33:39.211]   - Field: ‘state’
[10:33:39.211] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:39.211] - Launch lazy future ...
[10:33:39.211] Packages needed by the future expression (n = 1): ‘future’
[10:33:39.211] Packages needed by future strategies (n = 1): ‘future’
[10:33:39.212] {
[10:33:39.212]     {
[10:33:39.212]         {
[10:33:39.212]             ...future.startTime <- base::Sys.time()
[10:33:39.212]             {
[10:33:39.212]                 {
[10:33:39.212]                   {
[10:33:39.212]                     {
[10:33:39.212]                       {
[10:33:39.212]                         base::local({
[10:33:39.212]                           has_future <- base::requireNamespace("future", 
[10:33:39.212]                             quietly = TRUE)
[10:33:39.212]                           if (has_future) {
[10:33:39.212]                             ns <- base::getNamespace("future")
[10:33:39.212]                             version <- ns[[".package"]][["version"]]
[10:33:39.212]                             if (is.null(version)) 
[10:33:39.212]                               version <- utils::packageVersion("future")
[10:33:39.212]                           }
[10:33:39.212]                           else {
[10:33:39.212]                             version <- NULL
[10:33:39.212]                           }
[10:33:39.212]                           if (!has_future || version < "1.8.0") {
[10:33:39.212]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:39.212]                               "", base::R.version$version.string), 
[10:33:39.212]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:39.212]                                 base::R.version$platform, 8 * 
[10:33:39.212]                                   base::.Machine$sizeof.pointer), 
[10:33:39.212]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:39.212]                                 "release", "version")], collapse = " "), 
[10:33:39.212]                               hostname = base::Sys.info()[["nodename"]])
[10:33:39.212]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:39.212]                               info)
[10:33:39.212]                             info <- base::paste(info, collapse = "; ")
[10:33:39.212]                             if (!has_future) {
[10:33:39.212]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:39.212]                                 info)
[10:33:39.212]                             }
[10:33:39.212]                             else {
[10:33:39.212]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:39.212]                                 info, version)
[10:33:39.212]                             }
[10:33:39.212]                             base::stop(msg)
[10:33:39.212]                           }
[10:33:39.212]                         })
[10:33:39.212]                       }
[10:33:39.212]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:39.212]                       base::options(mc.cores = 1L)
[10:33:39.212]                     }
[10:33:39.212]                     base::local({
[10:33:39.212]                       for (pkg in "future") {
[10:33:39.212]                         base::loadNamespace(pkg)
[10:33:39.212]                         base::library(pkg, character.only = TRUE)
[10:33:39.212]                       }
[10:33:39.212]                     })
[10:33:39.212]                   }
[10:33:39.212]                   ...future.strategy.old <- future::plan("list")
[10:33:39.212]                   options(future.plan = NULL)
[10:33:39.212]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:39.212]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:33:39.212]                     envir = parent.frame()) 
[10:33:39.212]                   {
[10:33:39.212]                     default_workers <- missing(workers)
[10:33:39.212]                     if (is.function(workers)) 
[10:33:39.212]                       workers <- workers()
[10:33:39.212]                     workers <- structure(as.integer(workers), 
[10:33:39.212]                       class = class(workers))
[10:33:39.212]                     stop_if_not(is.finite(workers), workers >= 
[10:33:39.212]                       1L)
[10:33:39.212]                     if ((workers == 1L && !inherits(workers, 
[10:33:39.212]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:33:39.212]                       if (default_workers) 
[10:33:39.212]                         supportsMulticore(warn = TRUE)
[10:33:39.212]                       return(sequential(..., envir = envir))
[10:33:39.212]                     }
[10:33:39.212]                     oopts <- options(mc.cores = workers)
[10:33:39.212]                     on.exit(options(oopts))
[10:33:39.212]                     future <- MulticoreFuture(..., workers = workers, 
[10:33:39.212]                       envir = envir)
[10:33:39.212]                     if (!future$lazy) 
[10:33:39.212]                       future <- run(future)
[10:33:39.212]                     invisible(future)
[10:33:39.212]                   }), .cleanup = FALSE, .init = FALSE)
[10:33:39.212]                 }
[10:33:39.212]                 ...future.workdir <- getwd()
[10:33:39.212]             }
[10:33:39.212]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:39.212]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:39.212]         }
[10:33:39.212]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:39.212]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:39.212]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:39.212]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:39.212]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:39.212]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:39.212]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:39.212]             base::names(...future.oldOptions))
[10:33:39.212]     }
[10:33:39.212]     if (FALSE) {
[10:33:39.212]     }
[10:33:39.212]     else {
[10:33:39.212]         if (TRUE) {
[10:33:39.212]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:39.212]                 open = "w")
[10:33:39.212]         }
[10:33:39.212]         else {
[10:33:39.212]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:39.212]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:39.212]         }
[10:33:39.212]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:39.212]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:39.212]             base::sink(type = "output", split = FALSE)
[10:33:39.212]             base::close(...future.stdout)
[10:33:39.212]         }, add = TRUE)
[10:33:39.212]     }
[10:33:39.212]     ...future.frame <- base::sys.nframe()
[10:33:39.212]     ...future.conditions <- base::list()
[10:33:39.212]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:39.212]     if (FALSE) {
[10:33:39.212]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:39.212]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:39.212]     }
[10:33:39.212]     ...future.result <- base::tryCatch({
[10:33:39.212]         base::withCallingHandlers({
[10:33:39.212]             ...future.value <- base::withVisible(base::local({
[10:33:39.212]                 ...future.makeSendCondition <- base::local({
[10:33:39.212]                   sendCondition <- NULL
[10:33:39.212]                   function(frame = 1L) {
[10:33:39.212]                     if (is.function(sendCondition)) 
[10:33:39.212]                       return(sendCondition)
[10:33:39.212]                     ns <- getNamespace("parallel")
[10:33:39.212]                     if (exists("sendData", mode = "function", 
[10:33:39.212]                       envir = ns)) {
[10:33:39.212]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:39.212]                         envir = ns)
[10:33:39.212]                       envir <- sys.frame(frame)
[10:33:39.212]                       master <- NULL
[10:33:39.212]                       while (!identical(envir, .GlobalEnv) && 
[10:33:39.212]                         !identical(envir, emptyenv())) {
[10:33:39.212]                         if (exists("master", mode = "list", envir = envir, 
[10:33:39.212]                           inherits = FALSE)) {
[10:33:39.212]                           master <- get("master", mode = "list", 
[10:33:39.212]                             envir = envir, inherits = FALSE)
[10:33:39.212]                           if (inherits(master, c("SOCKnode", 
[10:33:39.212]                             "SOCK0node"))) {
[10:33:39.212]                             sendCondition <<- function(cond) {
[10:33:39.212]                               data <- list(type = "VALUE", value = cond, 
[10:33:39.212]                                 success = TRUE)
[10:33:39.212]                               parallel_sendData(master, data)
[10:33:39.212]                             }
[10:33:39.212]                             return(sendCondition)
[10:33:39.212]                           }
[10:33:39.212]                         }
[10:33:39.212]                         frame <- frame + 1L
[10:33:39.212]                         envir <- sys.frame(frame)
[10:33:39.212]                       }
[10:33:39.212]                     }
[10:33:39.212]                     sendCondition <<- function(cond) NULL
[10:33:39.212]                   }
[10:33:39.212]                 })
[10:33:39.212]                 withCallingHandlers({
[10:33:39.212]                   {
[10:33:39.212]                     value(future(subset(data, a == 2)))
[10:33:39.212]                   }
[10:33:39.212]                 }, immediateCondition = function(cond) {
[10:33:39.212]                   sendCondition <- ...future.makeSendCondition()
[10:33:39.212]                   sendCondition(cond)
[10:33:39.212]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:39.212]                   {
[10:33:39.212]                     inherits <- base::inherits
[10:33:39.212]                     invokeRestart <- base::invokeRestart
[10:33:39.212]                     is.null <- base::is.null
[10:33:39.212]                     muffled <- FALSE
[10:33:39.212]                     if (inherits(cond, "message")) {
[10:33:39.212]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:39.212]                       if (muffled) 
[10:33:39.212]                         invokeRestart("muffleMessage")
[10:33:39.212]                     }
[10:33:39.212]                     else if (inherits(cond, "warning")) {
[10:33:39.212]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:39.212]                       if (muffled) 
[10:33:39.212]                         invokeRestart("muffleWarning")
[10:33:39.212]                     }
[10:33:39.212]                     else if (inherits(cond, "condition")) {
[10:33:39.212]                       if (!is.null(pattern)) {
[10:33:39.212]                         computeRestarts <- base::computeRestarts
[10:33:39.212]                         grepl <- base::grepl
[10:33:39.212]                         restarts <- computeRestarts(cond)
[10:33:39.212]                         for (restart in restarts) {
[10:33:39.212]                           name <- restart$name
[10:33:39.212]                           if (is.null(name)) 
[10:33:39.212]                             next
[10:33:39.212]                           if (!grepl(pattern, name)) 
[10:33:39.212]                             next
[10:33:39.212]                           invokeRestart(restart)
[10:33:39.212]                           muffled <- TRUE
[10:33:39.212]                           break
[10:33:39.212]                         }
[10:33:39.212]                       }
[10:33:39.212]                     }
[10:33:39.212]                     invisible(muffled)
[10:33:39.212]                   }
[10:33:39.212]                   muffleCondition(cond)
[10:33:39.212]                 })
[10:33:39.212]             }))
[10:33:39.212]             future::FutureResult(value = ...future.value$value, 
[10:33:39.212]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:39.212]                   ...future.rng), globalenv = if (FALSE) 
[10:33:39.212]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:39.212]                     ...future.globalenv.names))
[10:33:39.212]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:39.212]         }, condition = base::local({
[10:33:39.212]             c <- base::c
[10:33:39.212]             inherits <- base::inherits
[10:33:39.212]             invokeRestart <- base::invokeRestart
[10:33:39.212]             length <- base::length
[10:33:39.212]             list <- base::list
[10:33:39.212]             seq.int <- base::seq.int
[10:33:39.212]             signalCondition <- base::signalCondition
[10:33:39.212]             sys.calls <- base::sys.calls
[10:33:39.212]             `[[` <- base::`[[`
[10:33:39.212]             `+` <- base::`+`
[10:33:39.212]             `<<-` <- base::`<<-`
[10:33:39.212]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:39.212]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:39.212]                   3L)]
[10:33:39.212]             }
[10:33:39.212]             function(cond) {
[10:33:39.212]                 is_error <- inherits(cond, "error")
[10:33:39.212]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:39.212]                   NULL)
[10:33:39.212]                 if (is_error) {
[10:33:39.212]                   sessionInformation <- function() {
[10:33:39.212]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:39.212]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:39.212]                       search = base::search(), system = base::Sys.info())
[10:33:39.212]                   }
[10:33:39.212]                   ...future.conditions[[length(...future.conditions) + 
[10:33:39.212]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:39.212]                     cond$call), session = sessionInformation(), 
[10:33:39.212]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:39.212]                   signalCondition(cond)
[10:33:39.212]                 }
[10:33:39.212]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:39.212]                 "immediateCondition"))) {
[10:33:39.212]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:39.212]                   ...future.conditions[[length(...future.conditions) + 
[10:33:39.212]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:39.212]                   if (TRUE && !signal) {
[10:33:39.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:39.212]                     {
[10:33:39.212]                       inherits <- base::inherits
[10:33:39.212]                       invokeRestart <- base::invokeRestart
[10:33:39.212]                       is.null <- base::is.null
[10:33:39.212]                       muffled <- FALSE
[10:33:39.212]                       if (inherits(cond, "message")) {
[10:33:39.212]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:39.212]                         if (muffled) 
[10:33:39.212]                           invokeRestart("muffleMessage")
[10:33:39.212]                       }
[10:33:39.212]                       else if (inherits(cond, "warning")) {
[10:33:39.212]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:39.212]                         if (muffled) 
[10:33:39.212]                           invokeRestart("muffleWarning")
[10:33:39.212]                       }
[10:33:39.212]                       else if (inherits(cond, "condition")) {
[10:33:39.212]                         if (!is.null(pattern)) {
[10:33:39.212]                           computeRestarts <- base::computeRestarts
[10:33:39.212]                           grepl <- base::grepl
[10:33:39.212]                           restarts <- computeRestarts(cond)
[10:33:39.212]                           for (restart in restarts) {
[10:33:39.212]                             name <- restart$name
[10:33:39.212]                             if (is.null(name)) 
[10:33:39.212]                               next
[10:33:39.212]                             if (!grepl(pattern, name)) 
[10:33:39.212]                               next
[10:33:39.212]                             invokeRestart(restart)
[10:33:39.212]                             muffled <- TRUE
[10:33:39.212]                             break
[10:33:39.212]                           }
[10:33:39.212]                         }
[10:33:39.212]                       }
[10:33:39.212]                       invisible(muffled)
[10:33:39.212]                     }
[10:33:39.212]                     muffleCondition(cond, pattern = "^muffle")
[10:33:39.212]                   }
[10:33:39.212]                 }
[10:33:39.212]                 else {
[10:33:39.212]                   if (TRUE) {
[10:33:39.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:39.212]                     {
[10:33:39.212]                       inherits <- base::inherits
[10:33:39.212]                       invokeRestart <- base::invokeRestart
[10:33:39.212]                       is.null <- base::is.null
[10:33:39.212]                       muffled <- FALSE
[10:33:39.212]                       if (inherits(cond, "message")) {
[10:33:39.212]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:39.212]                         if (muffled) 
[10:33:39.212]                           invokeRestart("muffleMessage")
[10:33:39.212]                       }
[10:33:39.212]                       else if (inherits(cond, "warning")) {
[10:33:39.212]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:39.212]                         if (muffled) 
[10:33:39.212]                           invokeRestart("muffleWarning")
[10:33:39.212]                       }
[10:33:39.212]                       else if (inherits(cond, "condition")) {
[10:33:39.212]                         if (!is.null(pattern)) {
[10:33:39.212]                           computeRestarts <- base::computeRestarts
[10:33:39.212]                           grepl <- base::grepl
[10:33:39.212]                           restarts <- computeRestarts(cond)
[10:33:39.212]                           for (restart in restarts) {
[10:33:39.212]                             name <- restart$name
[10:33:39.212]                             if (is.null(name)) 
[10:33:39.212]                               next
[10:33:39.212]                             if (!grepl(pattern, name)) 
[10:33:39.212]                               next
[10:33:39.212]                             invokeRestart(restart)
[10:33:39.212]                             muffled <- TRUE
[10:33:39.212]                             break
[10:33:39.212]                           }
[10:33:39.212]                         }
[10:33:39.212]                       }
[10:33:39.212]                       invisible(muffled)
[10:33:39.212]                     }
[10:33:39.212]                     muffleCondition(cond, pattern = "^muffle")
[10:33:39.212]                   }
[10:33:39.212]                 }
[10:33:39.212]             }
[10:33:39.212]         }))
[10:33:39.212]     }, error = function(ex) {
[10:33:39.212]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:39.212]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:39.212]                 ...future.rng), started = ...future.startTime, 
[10:33:39.212]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:39.212]             version = "1.8"), class = "FutureResult")
[10:33:39.212]     }, finally = {
[10:33:39.212]         if (!identical(...future.workdir, getwd())) 
[10:33:39.212]             setwd(...future.workdir)
[10:33:39.212]         {
[10:33:39.212]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:39.212]                 ...future.oldOptions$nwarnings <- NULL
[10:33:39.212]             }
[10:33:39.212]             base::options(...future.oldOptions)
[10:33:39.212]             if (.Platform$OS.type == "windows") {
[10:33:39.212]                 old_names <- names(...future.oldEnvVars)
[10:33:39.212]                 envs <- base::Sys.getenv()
[10:33:39.212]                 names <- names(envs)
[10:33:39.212]                 common <- intersect(names, old_names)
[10:33:39.212]                 added <- setdiff(names, old_names)
[10:33:39.212]                 removed <- setdiff(old_names, names)
[10:33:39.212]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:39.212]                   envs[common]]
[10:33:39.212]                 NAMES <- toupper(changed)
[10:33:39.212]                 args <- list()
[10:33:39.212]                 for (kk in seq_along(NAMES)) {
[10:33:39.212]                   name <- changed[[kk]]
[10:33:39.212]                   NAME <- NAMES[[kk]]
[10:33:39.212]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:39.212]                     next
[10:33:39.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:39.212]                 }
[10:33:39.212]                 NAMES <- toupper(added)
[10:33:39.212]                 for (kk in seq_along(NAMES)) {
[10:33:39.212]                   name <- added[[kk]]
[10:33:39.212]                   NAME <- NAMES[[kk]]
[10:33:39.212]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:39.212]                     next
[10:33:39.212]                   args[[name]] <- ""
[10:33:39.212]                 }
[10:33:39.212]                 NAMES <- toupper(removed)
[10:33:39.212]                 for (kk in seq_along(NAMES)) {
[10:33:39.212]                   name <- removed[[kk]]
[10:33:39.212]                   NAME <- NAMES[[kk]]
[10:33:39.212]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:39.212]                     next
[10:33:39.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:39.212]                 }
[10:33:39.212]                 if (length(args) > 0) 
[10:33:39.212]                   base::do.call(base::Sys.setenv, args = args)
[10:33:39.212]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:39.212]             }
[10:33:39.212]             else {
[10:33:39.212]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:39.212]             }
[10:33:39.212]             {
[10:33:39.212]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:39.212]                   0L) {
[10:33:39.212]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:39.212]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:39.212]                   base::options(opts)
[10:33:39.212]                 }
[10:33:39.212]                 {
[10:33:39.212]                   {
[10:33:39.212]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:39.212]                     NULL
[10:33:39.212]                   }
[10:33:39.212]                   options(future.plan = NULL)
[10:33:39.212]                   if (is.na(NA_character_)) 
[10:33:39.212]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:39.212]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:39.212]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:39.212]                     .init = FALSE)
[10:33:39.212]                 }
[10:33:39.212]             }
[10:33:39.212]         }
[10:33:39.212]     })
[10:33:39.212]     if (TRUE) {
[10:33:39.212]         base::sink(type = "output", split = FALSE)
[10:33:39.212]         if (TRUE) {
[10:33:39.212]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:39.212]         }
[10:33:39.212]         else {
[10:33:39.212]             ...future.result["stdout"] <- base::list(NULL)
[10:33:39.212]         }
[10:33:39.212]         base::close(...future.stdout)
[10:33:39.212]         ...future.stdout <- NULL
[10:33:39.212]     }
[10:33:39.212]     ...future.result$conditions <- ...future.conditions
[10:33:39.212]     ...future.result$finished <- base::Sys.time()
[10:33:39.212]     ...future.result
[10:33:39.212] }
[10:33:39.215] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[10:33:39.215] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[10:33:39.215] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[10:33:39.215] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[10:33:39.216] MultisessionFuture started
[10:33:39.216] - Launch lazy future ... done
[10:33:39.216] run() for ‘MultisessionFuture’ ... done
[10:33:39.216] result() for ClusterFuture ...
[10:33:39.216] receiveMessageFromWorker() for ClusterFuture ...
[10:33:39.216] - Validating connection of MultisessionFuture
[10:33:39.271] - received message: FutureResult
[10:33:39.271] - Received FutureResult
[10:33:39.272] - Erased future from FutureRegistry
[10:33:39.272] result() for ClusterFuture ...
[10:33:39.272] - result already collected: FutureResult
[10:33:39.272] result() for ClusterFuture ... done
[10:33:39.272] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:39.272] result() for ClusterFuture ... done
[10:33:39.272] result() for ClusterFuture ...
[10:33:39.272] - result already collected: FutureResult
[10:33:39.272] result() for ClusterFuture ... done
- plan(list('multisession', 'multicore')) ... DONE
- plan(list('multisession', 'multisession')) ...
[10:33:39.273] plan(): Setting new future strategy stack:
[10:33:39.273] List of future strategies:
[10:33:39.273] 1. multisession:
[10:33:39.273]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:39.273]    - tweaked: FALSE
[10:33:39.273]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:39.273] 2. multisession:
[10:33:39.273]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:39.273]    - tweaked: FALSE
[10:33:39.273]    - call: plan(list(a = strategy1, b = strategy2))
[10:33:39.274] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:33:39.274] multisession:
[10:33:39.274] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:39.274] - tweaked: FALSE
[10:33:39.274] - call: plan(list(a = strategy1, b = strategy2))
[10:33:39.278] getGlobalsAndPackages() ...
[10:33:39.278] Not searching for globals
[10:33:39.278] - globals: [0] <none>
[10:33:39.278] getGlobalsAndPackages() ... DONE
[10:33:39.278] [local output] makeClusterPSOCK() ...
[10:33:39.282] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:33:39.282] [local output] Base port: 11609
[10:33:39.283] [local output] Getting setup options for 2 cluster nodes ...
[10:33:39.283] [local output]  - Node 1 of 2 ...
[10:33:39.283] [local output] localMachine=TRUE => revtunnel=FALSE

[10:33:39.284] [local output] Rscript port: 11609

[10:33:39.284] [local output]  - Node 2 of 2 ...
[10:33:39.284] [local output] localMachine=TRUE => revtunnel=FALSE

[10:33:39.285] [local output] Rscript port: 11609

[10:33:39.285] [local output] Getting setup options for 2 cluster nodes ... done
[10:33:39.285] [local output]  - Parallel setup requested for some PSOCK nodes
[10:33:39.285] [local output] Setting up PSOCK nodes in parallel
[10:33:39.286] List of 36
[10:33:39.286]  $ worker          : chr "localhost"
[10:33:39.286]   ..- attr(*, "localhost")= logi TRUE
[10:33:39.286]  $ master          : chr "localhost"
[10:33:39.286]  $ port            : int 11609
[10:33:39.286]  $ connectTimeout  : num 120
[10:33:39.286]  $ timeout         : num 2592000
[10:33:39.286]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:33:39.286]  $ homogeneous     : logi TRUE
[10:33:39.286]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:33:39.286]  $ rscript_envs    : NULL
[10:33:39.286]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:33:39.286]  $ rscript_startup : NULL
[10:33:39.286]  $ rscript_sh      : chr "sh"
[10:33:39.286]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:33:39.286]  $ methods         : logi TRUE
[10:33:39.286]  $ socketOptions   : chr "no-delay"
[10:33:39.286]  $ useXDR          : logi FALSE
[10:33:39.286]  $ outfile         : chr "/dev/null"
[10:33:39.286]  $ renice          : int NA
[10:33:39.286]  $ rshcmd          : NULL
[10:33:39.286]  $ user            : chr(0) 
[10:33:39.286]  $ revtunnel       : logi FALSE
[10:33:39.286]  $ rshlogfile      : NULL
[10:33:39.286]  $ rshopts         : chr(0) 
[10:33:39.286]  $ rank            : int 1
[10:33:39.286]  $ manual          : logi FALSE
[10:33:39.286]  $ dryrun          : logi FALSE
[10:33:39.286]  $ quiet           : logi FALSE
[10:33:39.286]  $ setup_strategy  : chr "parallel"
[10:33:39.286]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:33:39.286]  $ pidfile         : chr "/tmp/RtmpTlTEh1/worker.rank=1.parallelly.parent=87069.1541d570f8ef1.pid"
[10:33:39.286]  $ rshcmd_label    : NULL
[10:33:39.286]  $ rsh_call        : NULL
[10:33:39.286]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:33:39.286]  $ localMachine    : logi TRUE
[10:33:39.286]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:33:39.286]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:33:39.286]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:33:39.286]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:33:39.286]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:33:39.286]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:33:39.286]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:33:39.286]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:33:39.286]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:33:39.286]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:33:39.286]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:33:39.286]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:33:39.286]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:33:39.286]  $ arguments       :List of 28
[10:33:39.286]   ..$ worker          : chr "localhost"
[10:33:39.286]   ..$ master          : NULL
[10:33:39.286]   ..$ port            : int 11609
[10:33:39.286]   ..$ connectTimeout  : num 120
[10:33:39.286]   ..$ timeout         : num 2592000
[10:33:39.286]   ..$ rscript         : NULL
[10:33:39.286]   ..$ homogeneous     : NULL
[10:33:39.286]   ..$ rscript_args    : NULL
[10:33:39.286]   ..$ rscript_envs    : NULL
[10:33:39.286]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:33:39.286]   ..$ rscript_startup : NULL
[10:33:39.286]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:33:39.286]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:33:39.286]   ..$ methods         : logi TRUE
[10:33:39.286]   ..$ socketOptions   : chr "no-delay"
[10:33:39.286]   ..$ useXDR          : logi FALSE
[10:33:39.286]   ..$ outfile         : chr "/dev/null"
[10:33:39.286]   ..$ renice          : int NA
[10:33:39.286]   ..$ rshcmd          : NULL
[10:33:39.286]   ..$ user            : NULL
[10:33:39.286]   ..$ revtunnel       : logi NA
[10:33:39.286]   ..$ rshlogfile      : NULL
[10:33:39.286]   ..$ rshopts         : NULL
[10:33:39.286]   ..$ rank            : int 1
[10:33:39.286]   ..$ manual          : logi FALSE
[10:33:39.286]   ..$ dryrun          : logi FALSE
[10:33:39.286]   ..$ quiet           : logi FALSE
[10:33:39.286]   ..$ setup_strategy  : chr "parallel"
[10:33:39.286]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:33:39.305] [local output] System call to launch all workers:
[10:33:39.305] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpTlTEh1/worker.rank=1.parallelly.parent=87069.1541d570f8ef1.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11609 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:33:39.305] [local output] Starting PSOCK main server
[10:33:39.306] [local output] Workers launched
[10:33:39.306] [local output] Waiting for workers to connect back
[10:33:39.306]  - [local output] 0 workers out of 2 ready
[10:33:39.547]  - [local output] 0 workers out of 2 ready
[10:33:39.547]  - [local output] 1 workers out of 2 ready
[10:33:39.548]  - [local output] 1 workers out of 2 ready
[10:33:39.548]  - [local output] 2 workers out of 2 ready
[10:33:39.549] [local output] Launching of workers completed
[10:33:39.549] [local output] Collecting session information from workers
[10:33:39.549] [local output]  - Worker #1 of 2
[10:33:39.550] [local output]  - Worker #2 of 2
[10:33:39.550] [local output] makeClusterPSOCK() ... done
[10:33:39.561] Packages needed by the future expression (n = 0): <none>
[10:33:39.561] Packages needed by future strategies (n = 1): ‘future’
[10:33:39.561] {
[10:33:39.561]     {
[10:33:39.561]         {
[10:33:39.561]             ...future.startTime <- base::Sys.time()
[10:33:39.561]             {
[10:33:39.561]                 {
[10:33:39.561]                   {
[10:33:39.561]                     {
[10:33:39.561]                       {
[10:33:39.561]                         base::local({
[10:33:39.561]                           has_future <- base::requireNamespace("future", 
[10:33:39.561]                             quietly = TRUE)
[10:33:39.561]                           if (has_future) {
[10:33:39.561]                             ns <- base::getNamespace("future")
[10:33:39.561]                             version <- ns[[".package"]][["version"]]
[10:33:39.561]                             if (is.null(version)) 
[10:33:39.561]                               version <- utils::packageVersion("future")
[10:33:39.561]                           }
[10:33:39.561]                           else {
[10:33:39.561]                             version <- NULL
[10:33:39.561]                           }
[10:33:39.561]                           if (!has_future || version < "1.8.0") {
[10:33:39.561]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:39.561]                               "", base::R.version$version.string), 
[10:33:39.561]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:39.561]                                 base::R.version$platform, 8 * 
[10:33:39.561]                                   base::.Machine$sizeof.pointer), 
[10:33:39.561]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:39.561]                                 "release", "version")], collapse = " "), 
[10:33:39.561]                               hostname = base::Sys.info()[["nodename"]])
[10:33:39.561]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:39.561]                               info)
[10:33:39.561]                             info <- base::paste(info, collapse = "; ")
[10:33:39.561]                             if (!has_future) {
[10:33:39.561]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:39.561]                                 info)
[10:33:39.561]                             }
[10:33:39.561]                             else {
[10:33:39.561]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:39.561]                                 info, version)
[10:33:39.561]                             }
[10:33:39.561]                             base::stop(msg)
[10:33:39.561]                           }
[10:33:39.561]                         })
[10:33:39.561]                       }
[10:33:39.561]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:39.561]                       base::options(mc.cores = 1L)
[10:33:39.561]                     }
[10:33:39.561]                     base::local({
[10:33:39.561]                       for (pkg in "future") {
[10:33:39.561]                         base::loadNamespace(pkg)
[10:33:39.561]                         base::library(pkg, character.only = TRUE)
[10:33:39.561]                       }
[10:33:39.561]                     })
[10:33:39.561]                   }
[10:33:39.561]                   ...future.strategy.old <- future::plan("list")
[10:33:39.561]                   options(future.plan = NULL)
[10:33:39.561]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:39.561]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:33:39.561]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:33:39.561]                     envir = parent.frame()) 
[10:33:39.561]                   {
[10:33:39.561]                     if (is.function(workers)) 
[10:33:39.561]                       workers <- workers()
[10:33:39.561]                     workers <- structure(as.integer(workers), 
[10:33:39.561]                       class = class(workers))
[10:33:39.561]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:33:39.561]                       workers >= 1)
[10:33:39.561]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:33:39.561]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:33:39.561]                     }
[10:33:39.561]                     future <- MultisessionFuture(..., workers = workers, 
[10:33:39.561]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:33:39.561]                       envir = envir)
[10:33:39.561]                     if (!future$lazy) 
[10:33:39.561]                       future <- run(future)
[10:33:39.561]                     invisible(future)
[10:33:39.561]                   }), .cleanup = FALSE, .init = FALSE)
[10:33:39.561]                 }
[10:33:39.561]                 ...future.workdir <- getwd()
[10:33:39.561]             }
[10:33:39.561]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:39.561]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:39.561]         }
[10:33:39.561]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:39.561]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:39.561]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:39.561]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:39.561]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:39.561]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:39.561]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:39.561]             base::names(...future.oldOptions))
[10:33:39.561]     }
[10:33:39.561]     if (FALSE) {
[10:33:39.561]     }
[10:33:39.561]     else {
[10:33:39.561]         if (TRUE) {
[10:33:39.561]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:39.561]                 open = "w")
[10:33:39.561]         }
[10:33:39.561]         else {
[10:33:39.561]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:39.561]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:39.561]         }
[10:33:39.561]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:39.561]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:39.561]             base::sink(type = "output", split = FALSE)
[10:33:39.561]             base::close(...future.stdout)
[10:33:39.561]         }, add = TRUE)
[10:33:39.561]     }
[10:33:39.561]     ...future.frame <- base::sys.nframe()
[10:33:39.561]     ...future.conditions <- base::list()
[10:33:39.561]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:39.561]     if (FALSE) {
[10:33:39.561]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:39.561]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:39.561]     }
[10:33:39.561]     ...future.result <- base::tryCatch({
[10:33:39.561]         base::withCallingHandlers({
[10:33:39.561]             ...future.value <- base::withVisible(base::local({
[10:33:39.561]                 ...future.makeSendCondition <- base::local({
[10:33:39.561]                   sendCondition <- NULL
[10:33:39.561]                   function(frame = 1L) {
[10:33:39.561]                     if (is.function(sendCondition)) 
[10:33:39.561]                       return(sendCondition)
[10:33:39.561]                     ns <- getNamespace("parallel")
[10:33:39.561]                     if (exists("sendData", mode = "function", 
[10:33:39.561]                       envir = ns)) {
[10:33:39.561]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:39.561]                         envir = ns)
[10:33:39.561]                       envir <- sys.frame(frame)
[10:33:39.561]                       master <- NULL
[10:33:39.561]                       while (!identical(envir, .GlobalEnv) && 
[10:33:39.561]                         !identical(envir, emptyenv())) {
[10:33:39.561]                         if (exists("master", mode = "list", envir = envir, 
[10:33:39.561]                           inherits = FALSE)) {
[10:33:39.561]                           master <- get("master", mode = "list", 
[10:33:39.561]                             envir = envir, inherits = FALSE)
[10:33:39.561]                           if (inherits(master, c("SOCKnode", 
[10:33:39.561]                             "SOCK0node"))) {
[10:33:39.561]                             sendCondition <<- function(cond) {
[10:33:39.561]                               data <- list(type = "VALUE", value = cond, 
[10:33:39.561]                                 success = TRUE)
[10:33:39.561]                               parallel_sendData(master, data)
[10:33:39.561]                             }
[10:33:39.561]                             return(sendCondition)
[10:33:39.561]                           }
[10:33:39.561]                         }
[10:33:39.561]                         frame <- frame + 1L
[10:33:39.561]                         envir <- sys.frame(frame)
[10:33:39.561]                       }
[10:33:39.561]                     }
[10:33:39.561]                     sendCondition <<- function(cond) NULL
[10:33:39.561]                   }
[10:33:39.561]                 })
[10:33:39.561]                 withCallingHandlers({
[10:33:39.561]                   NA
[10:33:39.561]                 }, immediateCondition = function(cond) {
[10:33:39.561]                   sendCondition <- ...future.makeSendCondition()
[10:33:39.561]                   sendCondition(cond)
[10:33:39.561]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:39.561]                   {
[10:33:39.561]                     inherits <- base::inherits
[10:33:39.561]                     invokeRestart <- base::invokeRestart
[10:33:39.561]                     is.null <- base::is.null
[10:33:39.561]                     muffled <- FALSE
[10:33:39.561]                     if (inherits(cond, "message")) {
[10:33:39.561]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:39.561]                       if (muffled) 
[10:33:39.561]                         invokeRestart("muffleMessage")
[10:33:39.561]                     }
[10:33:39.561]                     else if (inherits(cond, "warning")) {
[10:33:39.561]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:39.561]                       if (muffled) 
[10:33:39.561]                         invokeRestart("muffleWarning")
[10:33:39.561]                     }
[10:33:39.561]                     else if (inherits(cond, "condition")) {
[10:33:39.561]                       if (!is.null(pattern)) {
[10:33:39.561]                         computeRestarts <- base::computeRestarts
[10:33:39.561]                         grepl <- base::grepl
[10:33:39.561]                         restarts <- computeRestarts(cond)
[10:33:39.561]                         for (restart in restarts) {
[10:33:39.561]                           name <- restart$name
[10:33:39.561]                           if (is.null(name)) 
[10:33:39.561]                             next
[10:33:39.561]                           if (!grepl(pattern, name)) 
[10:33:39.561]                             next
[10:33:39.561]                           invokeRestart(restart)
[10:33:39.561]                           muffled <- TRUE
[10:33:39.561]                           break
[10:33:39.561]                         }
[10:33:39.561]                       }
[10:33:39.561]                     }
[10:33:39.561]                     invisible(muffled)
[10:33:39.561]                   }
[10:33:39.561]                   muffleCondition(cond)
[10:33:39.561]                 })
[10:33:39.561]             }))
[10:33:39.561]             future::FutureResult(value = ...future.value$value, 
[10:33:39.561]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:39.561]                   ...future.rng), globalenv = if (FALSE) 
[10:33:39.561]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:39.561]                     ...future.globalenv.names))
[10:33:39.561]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:39.561]         }, condition = base::local({
[10:33:39.561]             c <- base::c
[10:33:39.561]             inherits <- base::inherits
[10:33:39.561]             invokeRestart <- base::invokeRestart
[10:33:39.561]             length <- base::length
[10:33:39.561]             list <- base::list
[10:33:39.561]             seq.int <- base::seq.int
[10:33:39.561]             signalCondition <- base::signalCondition
[10:33:39.561]             sys.calls <- base::sys.calls
[10:33:39.561]             `[[` <- base::`[[`
[10:33:39.561]             `+` <- base::`+`
[10:33:39.561]             `<<-` <- base::`<<-`
[10:33:39.561]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:39.561]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:39.561]                   3L)]
[10:33:39.561]             }
[10:33:39.561]             function(cond) {
[10:33:39.561]                 is_error <- inherits(cond, "error")
[10:33:39.561]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:39.561]                   NULL)
[10:33:39.561]                 if (is_error) {
[10:33:39.561]                   sessionInformation <- function() {
[10:33:39.561]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:39.561]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:39.561]                       search = base::search(), system = base::Sys.info())
[10:33:39.561]                   }
[10:33:39.561]                   ...future.conditions[[length(...future.conditions) + 
[10:33:39.561]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:39.561]                     cond$call), session = sessionInformation(), 
[10:33:39.561]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:39.561]                   signalCondition(cond)
[10:33:39.561]                 }
[10:33:39.561]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:39.561]                 "immediateCondition"))) {
[10:33:39.561]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:39.561]                   ...future.conditions[[length(...future.conditions) + 
[10:33:39.561]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:39.561]                   if (TRUE && !signal) {
[10:33:39.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:39.561]                     {
[10:33:39.561]                       inherits <- base::inherits
[10:33:39.561]                       invokeRestart <- base::invokeRestart
[10:33:39.561]                       is.null <- base::is.null
[10:33:39.561]                       muffled <- FALSE
[10:33:39.561]                       if (inherits(cond, "message")) {
[10:33:39.561]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:39.561]                         if (muffled) 
[10:33:39.561]                           invokeRestart("muffleMessage")
[10:33:39.561]                       }
[10:33:39.561]                       else if (inherits(cond, "warning")) {
[10:33:39.561]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:39.561]                         if (muffled) 
[10:33:39.561]                           invokeRestart("muffleWarning")
[10:33:39.561]                       }
[10:33:39.561]                       else if (inherits(cond, "condition")) {
[10:33:39.561]                         if (!is.null(pattern)) {
[10:33:39.561]                           computeRestarts <- base::computeRestarts
[10:33:39.561]                           grepl <- base::grepl
[10:33:39.561]                           restarts <- computeRestarts(cond)
[10:33:39.561]                           for (restart in restarts) {
[10:33:39.561]                             name <- restart$name
[10:33:39.561]                             if (is.null(name)) 
[10:33:39.561]                               next
[10:33:39.561]                             if (!grepl(pattern, name)) 
[10:33:39.561]                               next
[10:33:39.561]                             invokeRestart(restart)
[10:33:39.561]                             muffled <- TRUE
[10:33:39.561]                             break
[10:33:39.561]                           }
[10:33:39.561]                         }
[10:33:39.561]                       }
[10:33:39.561]                       invisible(muffled)
[10:33:39.561]                     }
[10:33:39.561]                     muffleCondition(cond, pattern = "^muffle")
[10:33:39.561]                   }
[10:33:39.561]                 }
[10:33:39.561]                 else {
[10:33:39.561]                   if (TRUE) {
[10:33:39.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:39.561]                     {
[10:33:39.561]                       inherits <- base::inherits
[10:33:39.561]                       invokeRestart <- base::invokeRestart
[10:33:39.561]                       is.null <- base::is.null
[10:33:39.561]                       muffled <- FALSE
[10:33:39.561]                       if (inherits(cond, "message")) {
[10:33:39.561]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:39.561]                         if (muffled) 
[10:33:39.561]                           invokeRestart("muffleMessage")
[10:33:39.561]                       }
[10:33:39.561]                       else if (inherits(cond, "warning")) {
[10:33:39.561]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:39.561]                         if (muffled) 
[10:33:39.561]                           invokeRestart("muffleWarning")
[10:33:39.561]                       }
[10:33:39.561]                       else if (inherits(cond, "condition")) {
[10:33:39.561]                         if (!is.null(pattern)) {
[10:33:39.561]                           computeRestarts <- base::computeRestarts
[10:33:39.561]                           grepl <- base::grepl
[10:33:39.561]                           restarts <- computeRestarts(cond)
[10:33:39.561]                           for (restart in restarts) {
[10:33:39.561]                             name <- restart$name
[10:33:39.561]                             if (is.null(name)) 
[10:33:39.561]                               next
[10:33:39.561]                             if (!grepl(pattern, name)) 
[10:33:39.561]                               next
[10:33:39.561]                             invokeRestart(restart)
[10:33:39.561]                             muffled <- TRUE
[10:33:39.561]                             break
[10:33:39.561]                           }
[10:33:39.561]                         }
[10:33:39.561]                       }
[10:33:39.561]                       invisible(muffled)
[10:33:39.561]                     }
[10:33:39.561]                     muffleCondition(cond, pattern = "^muffle")
[10:33:39.561]                   }
[10:33:39.561]                 }
[10:33:39.561]             }
[10:33:39.561]         }))
[10:33:39.561]     }, error = function(ex) {
[10:33:39.561]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:39.561]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:39.561]                 ...future.rng), started = ...future.startTime, 
[10:33:39.561]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:39.561]             version = "1.8"), class = "FutureResult")
[10:33:39.561]     }, finally = {
[10:33:39.561]         if (!identical(...future.workdir, getwd())) 
[10:33:39.561]             setwd(...future.workdir)
[10:33:39.561]         {
[10:33:39.561]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:39.561]                 ...future.oldOptions$nwarnings <- NULL
[10:33:39.561]             }
[10:33:39.561]             base::options(...future.oldOptions)
[10:33:39.561]             if (.Platform$OS.type == "windows") {
[10:33:39.561]                 old_names <- names(...future.oldEnvVars)
[10:33:39.561]                 envs <- base::Sys.getenv()
[10:33:39.561]                 names <- names(envs)
[10:33:39.561]                 common <- intersect(names, old_names)
[10:33:39.561]                 added <- setdiff(names, old_names)
[10:33:39.561]                 removed <- setdiff(old_names, names)
[10:33:39.561]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:39.561]                   envs[common]]
[10:33:39.561]                 NAMES <- toupper(changed)
[10:33:39.561]                 args <- list()
[10:33:39.561]                 for (kk in seq_along(NAMES)) {
[10:33:39.561]                   name <- changed[[kk]]
[10:33:39.561]                   NAME <- NAMES[[kk]]
[10:33:39.561]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:39.561]                     next
[10:33:39.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:39.561]                 }
[10:33:39.561]                 NAMES <- toupper(added)
[10:33:39.561]                 for (kk in seq_along(NAMES)) {
[10:33:39.561]                   name <- added[[kk]]
[10:33:39.561]                   NAME <- NAMES[[kk]]
[10:33:39.561]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:39.561]                     next
[10:33:39.561]                   args[[name]] <- ""
[10:33:39.561]                 }
[10:33:39.561]                 NAMES <- toupper(removed)
[10:33:39.561]                 for (kk in seq_along(NAMES)) {
[10:33:39.561]                   name <- removed[[kk]]
[10:33:39.561]                   NAME <- NAMES[[kk]]
[10:33:39.561]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:39.561]                     next
[10:33:39.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:39.561]                 }
[10:33:39.561]                 if (length(args) > 0) 
[10:33:39.561]                   base::do.call(base::Sys.setenv, args = args)
[10:33:39.561]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:39.561]             }
[10:33:39.561]             else {
[10:33:39.561]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:39.561]             }
[10:33:39.561]             {
[10:33:39.561]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:39.561]                   0L) {
[10:33:39.561]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:39.561]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:39.561]                   base::options(opts)
[10:33:39.561]                 }
[10:33:39.561]                 {
[10:33:39.561]                   {
[10:33:39.561]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:39.561]                     NULL
[10:33:39.561]                   }
[10:33:39.561]                   options(future.plan = NULL)
[10:33:39.561]                   if (is.na(NA_character_)) 
[10:33:39.561]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:39.561]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:39.561]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:39.561]                     .init = FALSE)
[10:33:39.561]                 }
[10:33:39.561]             }
[10:33:39.561]         }
[10:33:39.561]     })
[10:33:39.561]     if (TRUE) {
[10:33:39.561]         base::sink(type = "output", split = FALSE)
[10:33:39.561]         if (TRUE) {
[10:33:39.561]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:39.561]         }
[10:33:39.561]         else {
[10:33:39.561]             ...future.result["stdout"] <- base::list(NULL)
[10:33:39.561]         }
[10:33:39.561]         base::close(...future.stdout)
[10:33:39.561]         ...future.stdout <- NULL
[10:33:39.561]     }
[10:33:39.561]     ...future.result$conditions <- ...future.conditions
[10:33:39.561]     ...future.result$finished <- base::Sys.time()
[10:33:39.561]     ...future.result
[10:33:39.561] }
[10:33:39.615] MultisessionFuture started
[10:33:39.615] result() for ClusterFuture ...
[10:33:39.615] receiveMessageFromWorker() for ClusterFuture ...
[10:33:39.616] - Validating connection of MultisessionFuture
[10:33:39.662] - received message: FutureResult
[10:33:39.662] - Received FutureResult
[10:33:39.662] - Erased future from FutureRegistry
[10:33:39.662] result() for ClusterFuture ...
[10:33:39.662] - result already collected: FutureResult
[10:33:39.662] result() for ClusterFuture ... done
[10:33:39.663] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:39.663] result() for ClusterFuture ... done
[10:33:39.663] result() for ClusterFuture ...
[10:33:39.663] - result already collected: FutureResult
[10:33:39.663] result() for ClusterFuture ... done
[10:33:39.663] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:33:39.666] plan(): nbrOfWorkers() = 2
[10:33:39.667] getGlobalsAndPackages() ...
[10:33:39.667] Searching for globals...
[10:33:39.683] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:33:39.683] Searching for globals ... DONE
[10:33:39.683] Resolving globals: FALSE
[10:33:39.684] The total size of the 2 globals is 88.27 KiB (90384 bytes)
[10:33:39.684] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 88.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (88.15 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[10:33:39.685] - globals: [2] ‘nested’, ‘strategy2’
[10:33:39.685] - packages: [1] ‘future’
[10:33:39.685] getGlobalsAndPackages() ... DONE
[10:33:39.685] run() for ‘Future’ ...
[10:33:39.685] - state: ‘created’
[10:33:39.685] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:39.699] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:39.699] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:39.699]   - Field: ‘node’
[10:33:39.699]   - Field: ‘label’
[10:33:39.699]   - Field: ‘local’
[10:33:39.699]   - Field: ‘owner’
[10:33:39.700]   - Field: ‘envir’
[10:33:39.700]   - Field: ‘workers’
[10:33:39.700]   - Field: ‘packages’
[10:33:39.700]   - Field: ‘gc’
[10:33:39.700]   - Field: ‘conditions’
[10:33:39.700]   - Field: ‘persistent’
[10:33:39.700]   - Field: ‘expr’
[10:33:39.700]   - Field: ‘uuid’
[10:33:39.700]   - Field: ‘seed’
[10:33:39.700]   - Field: ‘version’
[10:33:39.700]   - Field: ‘result’
[10:33:39.701]   - Field: ‘asynchronous’
[10:33:39.701]   - Field: ‘calls’
[10:33:39.701]   - Field: ‘globals’
[10:33:39.701]   - Field: ‘stdout’
[10:33:39.701]   - Field: ‘earlySignal’
[10:33:39.701]   - Field: ‘lazy’
[10:33:39.701]   - Field: ‘state’
[10:33:39.701] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:39.701] - Launch lazy future ...
[10:33:39.702] Packages needed by the future expression (n = 1): ‘future’
[10:33:39.702] Packages needed by future strategies (n = 1): ‘future’
[10:33:39.702] {
[10:33:39.702]     {
[10:33:39.702]         {
[10:33:39.702]             ...future.startTime <- base::Sys.time()
[10:33:39.702]             {
[10:33:39.702]                 {
[10:33:39.702]                   {
[10:33:39.702]                     {
[10:33:39.702]                       {
[10:33:39.702]                         base::local({
[10:33:39.702]                           has_future <- base::requireNamespace("future", 
[10:33:39.702]                             quietly = TRUE)
[10:33:39.702]                           if (has_future) {
[10:33:39.702]                             ns <- base::getNamespace("future")
[10:33:39.702]                             version <- ns[[".package"]][["version"]]
[10:33:39.702]                             if (is.null(version)) 
[10:33:39.702]                               version <- utils::packageVersion("future")
[10:33:39.702]                           }
[10:33:39.702]                           else {
[10:33:39.702]                             version <- NULL
[10:33:39.702]                           }
[10:33:39.702]                           if (!has_future || version < "1.8.0") {
[10:33:39.702]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:39.702]                               "", base::R.version$version.string), 
[10:33:39.702]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:39.702]                                 base::R.version$platform, 8 * 
[10:33:39.702]                                   base::.Machine$sizeof.pointer), 
[10:33:39.702]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:39.702]                                 "release", "version")], collapse = " "), 
[10:33:39.702]                               hostname = base::Sys.info()[["nodename"]])
[10:33:39.702]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:39.702]                               info)
[10:33:39.702]                             info <- base::paste(info, collapse = "; ")
[10:33:39.702]                             if (!has_future) {
[10:33:39.702]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:39.702]                                 info)
[10:33:39.702]                             }
[10:33:39.702]                             else {
[10:33:39.702]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:39.702]                                 info, version)
[10:33:39.702]                             }
[10:33:39.702]                             base::stop(msg)
[10:33:39.702]                           }
[10:33:39.702]                         })
[10:33:39.702]                       }
[10:33:39.702]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:39.702]                       base::options(mc.cores = 1L)
[10:33:39.702]                     }
[10:33:39.702]                     base::local({
[10:33:39.702]                       for (pkg in "future") {
[10:33:39.702]                         base::loadNamespace(pkg)
[10:33:39.702]                         base::library(pkg, character.only = TRUE)
[10:33:39.702]                       }
[10:33:39.702]                     })
[10:33:39.702]                   }
[10:33:39.702]                   ...future.strategy.old <- future::plan("list")
[10:33:39.702]                   options(future.plan = NULL)
[10:33:39.702]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:39.702]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:33:39.702]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:33:39.702]                     envir = parent.frame()) 
[10:33:39.702]                   {
[10:33:39.702]                     if (is.function(workers)) 
[10:33:39.702]                       workers <- workers()
[10:33:39.702]                     workers <- structure(as.integer(workers), 
[10:33:39.702]                       class = class(workers))
[10:33:39.702]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:33:39.702]                       workers >= 1)
[10:33:39.702]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:33:39.702]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:33:39.702]                     }
[10:33:39.702]                     future <- MultisessionFuture(..., workers = workers, 
[10:33:39.702]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:33:39.702]                       envir = envir)
[10:33:39.702]                     if (!future$lazy) 
[10:33:39.702]                       future <- run(future)
[10:33:39.702]                     invisible(future)
[10:33:39.702]                   }), .cleanup = FALSE, .init = FALSE)
[10:33:39.702]                 }
[10:33:39.702]                 ...future.workdir <- getwd()
[10:33:39.702]             }
[10:33:39.702]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:39.702]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:39.702]         }
[10:33:39.702]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:39.702]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:39.702]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:39.702]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:39.702]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:39.702]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:39.702]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:39.702]             base::names(...future.oldOptions))
[10:33:39.702]     }
[10:33:39.702]     if (FALSE) {
[10:33:39.702]     }
[10:33:39.702]     else {
[10:33:39.702]         if (TRUE) {
[10:33:39.702]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:39.702]                 open = "w")
[10:33:39.702]         }
[10:33:39.702]         else {
[10:33:39.702]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:39.702]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:39.702]         }
[10:33:39.702]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:39.702]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:39.702]             base::sink(type = "output", split = FALSE)
[10:33:39.702]             base::close(...future.stdout)
[10:33:39.702]         }, add = TRUE)
[10:33:39.702]     }
[10:33:39.702]     ...future.frame <- base::sys.nframe()
[10:33:39.702]     ...future.conditions <- base::list()
[10:33:39.702]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:39.702]     if (FALSE) {
[10:33:39.702]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:39.702]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:39.702]     }
[10:33:39.702]     ...future.result <- base::tryCatch({
[10:33:39.702]         base::withCallingHandlers({
[10:33:39.702]             ...future.value <- base::withVisible(base::local({
[10:33:39.702]                 ...future.makeSendCondition <- base::local({
[10:33:39.702]                   sendCondition <- NULL
[10:33:39.702]                   function(frame = 1L) {
[10:33:39.702]                     if (is.function(sendCondition)) 
[10:33:39.702]                       return(sendCondition)
[10:33:39.702]                     ns <- getNamespace("parallel")
[10:33:39.702]                     if (exists("sendData", mode = "function", 
[10:33:39.702]                       envir = ns)) {
[10:33:39.702]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:39.702]                         envir = ns)
[10:33:39.702]                       envir <- sys.frame(frame)
[10:33:39.702]                       master <- NULL
[10:33:39.702]                       while (!identical(envir, .GlobalEnv) && 
[10:33:39.702]                         !identical(envir, emptyenv())) {
[10:33:39.702]                         if (exists("master", mode = "list", envir = envir, 
[10:33:39.702]                           inherits = FALSE)) {
[10:33:39.702]                           master <- get("master", mode = "list", 
[10:33:39.702]                             envir = envir, inherits = FALSE)
[10:33:39.702]                           if (inherits(master, c("SOCKnode", 
[10:33:39.702]                             "SOCK0node"))) {
[10:33:39.702]                             sendCondition <<- function(cond) {
[10:33:39.702]                               data <- list(type = "VALUE", value = cond, 
[10:33:39.702]                                 success = TRUE)
[10:33:39.702]                               parallel_sendData(master, data)
[10:33:39.702]                             }
[10:33:39.702]                             return(sendCondition)
[10:33:39.702]                           }
[10:33:39.702]                         }
[10:33:39.702]                         frame <- frame + 1L
[10:33:39.702]                         envir <- sys.frame(frame)
[10:33:39.702]                       }
[10:33:39.702]                     }
[10:33:39.702]                     sendCondition <<- function(cond) NULL
[10:33:39.702]                   }
[10:33:39.702]                 })
[10:33:39.702]                 withCallingHandlers({
[10:33:39.702]                   {
[10:33:39.702]                     a <- 1L
[10:33:39.702]                     plan_a <- unclass(future::plan("list"))
[10:33:39.702]                     nested_a <- nested[-1]
[10:33:39.702]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:33:39.702]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:33:39.702]                       strategy2))
[10:33:39.702]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:33:39.702]                       "init") <- NULL
[10:33:39.702]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:33:39.702]                       "init") <- NULL
[10:33:39.702]                     stopifnot(all.equal(plan_a, nested_a))
[10:33:39.702]                     y %<-% {
[10:33:39.702]                       b <- 2L
[10:33:39.702]                       plan_b <- future::plan("list")
[10:33:39.702]                       nested_b <- nested_a[-1]
[10:33:39.702]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:33:39.702]                         1L, inherits(plan_b[[1]], "future"), 
[10:33:39.702]                         inherits(future::plan("next"), "sequential"))
[10:33:39.702]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:33:39.702]                         b = b, nested_b = nested_b, plan_b = plan_b)
[10:33:39.702]                     }
[10:33:39.702]                     y
[10:33:39.702]                   }
[10:33:39.702]                 }, immediateCondition = function(cond) {
[10:33:39.702]                   sendCondition <- ...future.makeSendCondition()
[10:33:39.702]                   sendCondition(cond)
[10:33:39.702]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:39.702]                   {
[10:33:39.702]                     inherits <- base::inherits
[10:33:39.702]                     invokeRestart <- base::invokeRestart
[10:33:39.702]                     is.null <- base::is.null
[10:33:39.702]                     muffled <- FALSE
[10:33:39.702]                     if (inherits(cond, "message")) {
[10:33:39.702]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:39.702]                       if (muffled) 
[10:33:39.702]                         invokeRestart("muffleMessage")
[10:33:39.702]                     }
[10:33:39.702]                     else if (inherits(cond, "warning")) {
[10:33:39.702]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:39.702]                       if (muffled) 
[10:33:39.702]                         invokeRestart("muffleWarning")
[10:33:39.702]                     }
[10:33:39.702]                     else if (inherits(cond, "condition")) {
[10:33:39.702]                       if (!is.null(pattern)) {
[10:33:39.702]                         computeRestarts <- base::computeRestarts
[10:33:39.702]                         grepl <- base::grepl
[10:33:39.702]                         restarts <- computeRestarts(cond)
[10:33:39.702]                         for (restart in restarts) {
[10:33:39.702]                           name <- restart$name
[10:33:39.702]                           if (is.null(name)) 
[10:33:39.702]                             next
[10:33:39.702]                           if (!grepl(pattern, name)) 
[10:33:39.702]                             next
[10:33:39.702]                           invokeRestart(restart)
[10:33:39.702]                           muffled <- TRUE
[10:33:39.702]                           break
[10:33:39.702]                         }
[10:33:39.702]                       }
[10:33:39.702]                     }
[10:33:39.702]                     invisible(muffled)
[10:33:39.702]                   }
[10:33:39.702]                   muffleCondition(cond)
[10:33:39.702]                 })
[10:33:39.702]             }))
[10:33:39.702]             future::FutureResult(value = ...future.value$value, 
[10:33:39.702]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:39.702]                   ...future.rng), globalenv = if (FALSE) 
[10:33:39.702]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:39.702]                     ...future.globalenv.names))
[10:33:39.702]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:39.702]         }, condition = base::local({
[10:33:39.702]             c <- base::c
[10:33:39.702]             inherits <- base::inherits
[10:33:39.702]             invokeRestart <- base::invokeRestart
[10:33:39.702]             length <- base::length
[10:33:39.702]             list <- base::list
[10:33:39.702]             seq.int <- base::seq.int
[10:33:39.702]             signalCondition <- base::signalCondition
[10:33:39.702]             sys.calls <- base::sys.calls
[10:33:39.702]             `[[` <- base::`[[`
[10:33:39.702]             `+` <- base::`+`
[10:33:39.702]             `<<-` <- base::`<<-`
[10:33:39.702]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:39.702]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:39.702]                   3L)]
[10:33:39.702]             }
[10:33:39.702]             function(cond) {
[10:33:39.702]                 is_error <- inherits(cond, "error")
[10:33:39.702]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:39.702]                   NULL)
[10:33:39.702]                 if (is_error) {
[10:33:39.702]                   sessionInformation <- function() {
[10:33:39.702]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:39.702]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:39.702]                       search = base::search(), system = base::Sys.info())
[10:33:39.702]                   }
[10:33:39.702]                   ...future.conditions[[length(...future.conditions) + 
[10:33:39.702]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:39.702]                     cond$call), session = sessionInformation(), 
[10:33:39.702]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:39.702]                   signalCondition(cond)
[10:33:39.702]                 }
[10:33:39.702]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:39.702]                 "immediateCondition"))) {
[10:33:39.702]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:39.702]                   ...future.conditions[[length(...future.conditions) + 
[10:33:39.702]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:39.702]                   if (TRUE && !signal) {
[10:33:39.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:39.702]                     {
[10:33:39.702]                       inherits <- base::inherits
[10:33:39.702]                       invokeRestart <- base::invokeRestart
[10:33:39.702]                       is.null <- base::is.null
[10:33:39.702]                       muffled <- FALSE
[10:33:39.702]                       if (inherits(cond, "message")) {
[10:33:39.702]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:39.702]                         if (muffled) 
[10:33:39.702]                           invokeRestart("muffleMessage")
[10:33:39.702]                       }
[10:33:39.702]                       else if (inherits(cond, "warning")) {
[10:33:39.702]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:39.702]                         if (muffled) 
[10:33:39.702]                           invokeRestart("muffleWarning")
[10:33:39.702]                       }
[10:33:39.702]                       else if (inherits(cond, "condition")) {
[10:33:39.702]                         if (!is.null(pattern)) {
[10:33:39.702]                           computeRestarts <- base::computeRestarts
[10:33:39.702]                           grepl <- base::grepl
[10:33:39.702]                           restarts <- computeRestarts(cond)
[10:33:39.702]                           for (restart in restarts) {
[10:33:39.702]                             name <- restart$name
[10:33:39.702]                             if (is.null(name)) 
[10:33:39.702]                               next
[10:33:39.702]                             if (!grepl(pattern, name)) 
[10:33:39.702]                               next
[10:33:39.702]                             invokeRestart(restart)
[10:33:39.702]                             muffled <- TRUE
[10:33:39.702]                             break
[10:33:39.702]                           }
[10:33:39.702]                         }
[10:33:39.702]                       }
[10:33:39.702]                       invisible(muffled)
[10:33:39.702]                     }
[10:33:39.702]                     muffleCondition(cond, pattern = "^muffle")
[10:33:39.702]                   }
[10:33:39.702]                 }
[10:33:39.702]                 else {
[10:33:39.702]                   if (TRUE) {
[10:33:39.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:39.702]                     {
[10:33:39.702]                       inherits <- base::inherits
[10:33:39.702]                       invokeRestart <- base::invokeRestart
[10:33:39.702]                       is.null <- base::is.null
[10:33:39.702]                       muffled <- FALSE
[10:33:39.702]                       if (inherits(cond, "message")) {
[10:33:39.702]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:39.702]                         if (muffled) 
[10:33:39.702]                           invokeRestart("muffleMessage")
[10:33:39.702]                       }
[10:33:39.702]                       else if (inherits(cond, "warning")) {
[10:33:39.702]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:39.702]                         if (muffled) 
[10:33:39.702]                           invokeRestart("muffleWarning")
[10:33:39.702]                       }
[10:33:39.702]                       else if (inherits(cond, "condition")) {
[10:33:39.702]                         if (!is.null(pattern)) {
[10:33:39.702]                           computeRestarts <- base::computeRestarts
[10:33:39.702]                           grepl <- base::grepl
[10:33:39.702]                           restarts <- computeRestarts(cond)
[10:33:39.702]                           for (restart in restarts) {
[10:33:39.702]                             name <- restart$name
[10:33:39.702]                             if (is.null(name)) 
[10:33:39.702]                               next
[10:33:39.702]                             if (!grepl(pattern, name)) 
[10:33:39.702]                               next
[10:33:39.702]                             invokeRestart(restart)
[10:33:39.702]                             muffled <- TRUE
[10:33:39.702]                             break
[10:33:39.702]                           }
[10:33:39.702]                         }
[10:33:39.702]                       }
[10:33:39.702]                       invisible(muffled)
[10:33:39.702]                     }
[10:33:39.702]                     muffleCondition(cond, pattern = "^muffle")
[10:33:39.702]                   }
[10:33:39.702]                 }
[10:33:39.702]             }
[10:33:39.702]         }))
[10:33:39.702]     }, error = function(ex) {
[10:33:39.702]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:39.702]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:39.702]                 ...future.rng), started = ...future.startTime, 
[10:33:39.702]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:39.702]             version = "1.8"), class = "FutureResult")
[10:33:39.702]     }, finally = {
[10:33:39.702]         if (!identical(...future.workdir, getwd())) 
[10:33:39.702]             setwd(...future.workdir)
[10:33:39.702]         {
[10:33:39.702]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:39.702]                 ...future.oldOptions$nwarnings <- NULL
[10:33:39.702]             }
[10:33:39.702]             base::options(...future.oldOptions)
[10:33:39.702]             if (.Platform$OS.type == "windows") {
[10:33:39.702]                 old_names <- names(...future.oldEnvVars)
[10:33:39.702]                 envs <- base::Sys.getenv()
[10:33:39.702]                 names <- names(envs)
[10:33:39.702]                 common <- intersect(names, old_names)
[10:33:39.702]                 added <- setdiff(names, old_names)
[10:33:39.702]                 removed <- setdiff(old_names, names)
[10:33:39.702]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:39.702]                   envs[common]]
[10:33:39.702]                 NAMES <- toupper(changed)
[10:33:39.702]                 args <- list()
[10:33:39.702]                 for (kk in seq_along(NAMES)) {
[10:33:39.702]                   name <- changed[[kk]]
[10:33:39.702]                   NAME <- NAMES[[kk]]
[10:33:39.702]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:39.702]                     next
[10:33:39.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:39.702]                 }
[10:33:39.702]                 NAMES <- toupper(added)
[10:33:39.702]                 for (kk in seq_along(NAMES)) {
[10:33:39.702]                   name <- added[[kk]]
[10:33:39.702]                   NAME <- NAMES[[kk]]
[10:33:39.702]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:39.702]                     next
[10:33:39.702]                   args[[name]] <- ""
[10:33:39.702]                 }
[10:33:39.702]                 NAMES <- toupper(removed)
[10:33:39.702]                 for (kk in seq_along(NAMES)) {
[10:33:39.702]                   name <- removed[[kk]]
[10:33:39.702]                   NAME <- NAMES[[kk]]
[10:33:39.702]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:39.702]                     next
[10:33:39.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:39.702]                 }
[10:33:39.702]                 if (length(args) > 0) 
[10:33:39.702]                   base::do.call(base::Sys.setenv, args = args)
[10:33:39.702]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:39.702]             }
[10:33:39.702]             else {
[10:33:39.702]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:39.702]             }
[10:33:39.702]             {
[10:33:39.702]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:39.702]                   0L) {
[10:33:39.702]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:39.702]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:39.702]                   base::options(opts)
[10:33:39.702]                 }
[10:33:39.702]                 {
[10:33:39.702]                   {
[10:33:39.702]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:39.702]                     NULL
[10:33:39.702]                   }
[10:33:39.702]                   options(future.plan = NULL)
[10:33:39.702]                   if (is.na(NA_character_)) 
[10:33:39.702]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:39.702]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:39.702]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:39.702]                     .init = FALSE)
[10:33:39.702]                 }
[10:33:39.702]             }
[10:33:39.702]         }
[10:33:39.702]     })
[10:33:39.702]     if (TRUE) {
[10:33:39.702]         base::sink(type = "output", split = FALSE)
[10:33:39.702]         if (TRUE) {
[10:33:39.702]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:39.702]         }
[10:33:39.702]         else {
[10:33:39.702]             ...future.result["stdout"] <- base::list(NULL)
[10:33:39.702]         }
[10:33:39.702]         base::close(...future.stdout)
[10:33:39.702]         ...future.stdout <- NULL
[10:33:39.702]     }
[10:33:39.702]     ...future.result$conditions <- ...future.conditions
[10:33:39.702]     ...future.result$finished <- base::Sys.time()
[10:33:39.702]     ...future.result
[10:33:39.702] }
[10:33:39.705] Exporting 2 global objects (88.27 KiB) to cluster node #1 ...
[10:33:39.705] Exporting ‘nested’ (88.15 KiB) to cluster node #1 ...
[10:33:39.749] Exporting ‘nested’ (88.15 KiB) to cluster node #1 ... DONE
[10:33:39.749] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[10:33:39.750] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[10:33:39.750] Exporting 2 global objects (88.27 KiB) to cluster node #1 ... DONE
[10:33:39.751] MultisessionFuture started
[10:33:39.751] - Launch lazy future ... done
[10:33:39.751] run() for ‘MultisessionFuture’ ... done
[10:33:39.751] result() for ClusterFuture ...
[10:33:39.751] receiveMessageFromWorker() for ClusterFuture ...
[10:33:39.751] - Validating connection of MultisessionFuture
[10:33:39.824] - received message: FutureResult
[10:33:39.825] - Received FutureResult
[10:33:39.825] - Erased future from FutureRegistry
[10:33:39.825] result() for ClusterFuture ...
[10:33:39.825] - result already collected: FutureResult
[10:33:39.825] result() for ClusterFuture ... done
[10:33:39.825] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:39.825] result() for ClusterFuture ... done
[10:33:39.825] result() for ClusterFuture ...
[10:33:39.825] - result already collected: FutureResult
[10:33:39.825] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:33:39.831] getGlobalsAndPackages() ...
[10:33:39.831] Searching for globals...
[10:33:39.832] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:33:39.833] Searching for globals ... DONE
[10:33:39.833] Resolving globals: FALSE
[10:33:39.833] The total size of the 1 globals is 128 bytes (128 bytes)
[10:33:39.834] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:33:39.834] - globals: [1] ‘data’
[10:33:39.834] - packages: [1] ‘future’
[10:33:39.834] getGlobalsAndPackages() ... DONE
[10:33:39.834] run() for ‘Future’ ...
[10:33:39.834] - state: ‘created’
[10:33:39.835] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:39.848] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:39.848] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:39.849]   - Field: ‘node’
[10:33:39.849]   - Field: ‘label’
[10:33:39.849]   - Field: ‘local’
[10:33:39.849]   - Field: ‘owner’
[10:33:39.849]   - Field: ‘envir’
[10:33:39.849]   - Field: ‘workers’
[10:33:39.849]   - Field: ‘packages’
[10:33:39.849]   - Field: ‘gc’
[10:33:39.849]   - Field: ‘conditions’
[10:33:39.849]   - Field: ‘persistent’
[10:33:39.850]   - Field: ‘expr’
[10:33:39.850]   - Field: ‘uuid’
[10:33:39.850]   - Field: ‘seed’
[10:33:39.850]   - Field: ‘version’
[10:33:39.850]   - Field: ‘result’
[10:33:39.850]   - Field: ‘asynchronous’
[10:33:39.850]   - Field: ‘calls’
[10:33:39.850]   - Field: ‘globals’
[10:33:39.852]   - Field: ‘stdout’
[10:33:39.852]   - Field: ‘earlySignal’
[10:33:39.852]   - Field: ‘lazy’
[10:33:39.853]   - Field: ‘state’
[10:33:39.853] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:39.853] - Launch lazy future ...
[10:33:39.853] Packages needed by the future expression (n = 1): ‘future’
[10:33:39.853] Packages needed by future strategies (n = 1): ‘future’
[10:33:39.854] {
[10:33:39.854]     {
[10:33:39.854]         {
[10:33:39.854]             ...future.startTime <- base::Sys.time()
[10:33:39.854]             {
[10:33:39.854]                 {
[10:33:39.854]                   {
[10:33:39.854]                     {
[10:33:39.854]                       {
[10:33:39.854]                         base::local({
[10:33:39.854]                           has_future <- base::requireNamespace("future", 
[10:33:39.854]                             quietly = TRUE)
[10:33:39.854]                           if (has_future) {
[10:33:39.854]                             ns <- base::getNamespace("future")
[10:33:39.854]                             version <- ns[[".package"]][["version"]]
[10:33:39.854]                             if (is.null(version)) 
[10:33:39.854]                               version <- utils::packageVersion("future")
[10:33:39.854]                           }
[10:33:39.854]                           else {
[10:33:39.854]                             version <- NULL
[10:33:39.854]                           }
[10:33:39.854]                           if (!has_future || version < "1.8.0") {
[10:33:39.854]                             info <- base::c(r_version = base::gsub("R version ", 
[10:33:39.854]                               "", base::R.version$version.string), 
[10:33:39.854]                               platform = base::sprintf("%s (%s-bit)", 
[10:33:39.854]                                 base::R.version$platform, 8 * 
[10:33:39.854]                                   base::.Machine$sizeof.pointer), 
[10:33:39.854]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:39.854]                                 "release", "version")], collapse = " "), 
[10:33:39.854]                               hostname = base::Sys.info()[["nodename"]])
[10:33:39.854]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:33:39.854]                               info)
[10:33:39.854]                             info <- base::paste(info, collapse = "; ")
[10:33:39.854]                             if (!has_future) {
[10:33:39.854]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:39.854]                                 info)
[10:33:39.854]                             }
[10:33:39.854]                             else {
[10:33:39.854]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:39.854]                                 info, version)
[10:33:39.854]                             }
[10:33:39.854]                             base::stop(msg)
[10:33:39.854]                           }
[10:33:39.854]                         })
[10:33:39.854]                       }
[10:33:39.854]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:39.854]                       base::options(mc.cores = 1L)
[10:33:39.854]                     }
[10:33:39.854]                     base::local({
[10:33:39.854]                       for (pkg in "future") {
[10:33:39.854]                         base::loadNamespace(pkg)
[10:33:39.854]                         base::library(pkg, character.only = TRUE)
[10:33:39.854]                       }
[10:33:39.854]                     })
[10:33:39.854]                   }
[10:33:39.854]                   ...future.strategy.old <- future::plan("list")
[10:33:39.854]                   options(future.plan = NULL)
[10:33:39.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:39.854]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:33:39.854]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:33:39.854]                     envir = parent.frame()) 
[10:33:39.854]                   {
[10:33:39.854]                     if (is.function(workers)) 
[10:33:39.854]                       workers <- workers()
[10:33:39.854]                     workers <- structure(as.integer(workers), 
[10:33:39.854]                       class = class(workers))
[10:33:39.854]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:33:39.854]                       workers >= 1)
[10:33:39.854]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:33:39.854]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:33:39.854]                     }
[10:33:39.854]                     future <- MultisessionFuture(..., workers = workers, 
[10:33:39.854]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:33:39.854]                       envir = envir)
[10:33:39.854]                     if (!future$lazy) 
[10:33:39.854]                       future <- run(future)
[10:33:39.854]                     invisible(future)
[10:33:39.854]                   }), .cleanup = FALSE, .init = FALSE)
[10:33:39.854]                 }
[10:33:39.854]                 ...future.workdir <- getwd()
[10:33:39.854]             }
[10:33:39.854]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:39.854]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:39.854]         }
[10:33:39.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:39.854]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:39.854]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:39.854]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:39.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:39.854]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:39.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:39.854]             base::names(...future.oldOptions))
[10:33:39.854]     }
[10:33:39.854]     if (FALSE) {
[10:33:39.854]     }
[10:33:39.854]     else {
[10:33:39.854]         if (TRUE) {
[10:33:39.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:39.854]                 open = "w")
[10:33:39.854]         }
[10:33:39.854]         else {
[10:33:39.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:39.854]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:39.854]         }
[10:33:39.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:39.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:39.854]             base::sink(type = "output", split = FALSE)
[10:33:39.854]             base::close(...future.stdout)
[10:33:39.854]         }, add = TRUE)
[10:33:39.854]     }
[10:33:39.854]     ...future.frame <- base::sys.nframe()
[10:33:39.854]     ...future.conditions <- base::list()
[10:33:39.854]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:39.854]     if (FALSE) {
[10:33:39.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:39.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:39.854]     }
[10:33:39.854]     ...future.result <- base::tryCatch({
[10:33:39.854]         base::withCallingHandlers({
[10:33:39.854]             ...future.value <- base::withVisible(base::local({
[10:33:39.854]                 ...future.makeSendCondition <- base::local({
[10:33:39.854]                   sendCondition <- NULL
[10:33:39.854]                   function(frame = 1L) {
[10:33:39.854]                     if (is.function(sendCondition)) 
[10:33:39.854]                       return(sendCondition)
[10:33:39.854]                     ns <- getNamespace("parallel")
[10:33:39.854]                     if (exists("sendData", mode = "function", 
[10:33:39.854]                       envir = ns)) {
[10:33:39.854]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:39.854]                         envir = ns)
[10:33:39.854]                       envir <- sys.frame(frame)
[10:33:39.854]                       master <- NULL
[10:33:39.854]                       while (!identical(envir, .GlobalEnv) && 
[10:33:39.854]                         !identical(envir, emptyenv())) {
[10:33:39.854]                         if (exists("master", mode = "list", envir = envir, 
[10:33:39.854]                           inherits = FALSE)) {
[10:33:39.854]                           master <- get("master", mode = "list", 
[10:33:39.854]                             envir = envir, inherits = FALSE)
[10:33:39.854]                           if (inherits(master, c("SOCKnode", 
[10:33:39.854]                             "SOCK0node"))) {
[10:33:39.854]                             sendCondition <<- function(cond) {
[10:33:39.854]                               data <- list(type = "VALUE", value = cond, 
[10:33:39.854]                                 success = TRUE)
[10:33:39.854]                               parallel_sendData(master, data)
[10:33:39.854]                             }
[10:33:39.854]                             return(sendCondition)
[10:33:39.854]                           }
[10:33:39.854]                         }
[10:33:39.854]                         frame <- frame + 1L
[10:33:39.854]                         envir <- sys.frame(frame)
[10:33:39.854]                       }
[10:33:39.854]                     }
[10:33:39.854]                     sendCondition <<- function(cond) NULL
[10:33:39.854]                   }
[10:33:39.854]                 })
[10:33:39.854]                 withCallingHandlers({
[10:33:39.854]                   {
[10:33:39.854]                     value(future(subset(data, a == 2)))
[10:33:39.854]                   }
[10:33:39.854]                 }, immediateCondition = function(cond) {
[10:33:39.854]                   sendCondition <- ...future.makeSendCondition()
[10:33:39.854]                   sendCondition(cond)
[10:33:39.854]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:39.854]                   {
[10:33:39.854]                     inherits <- base::inherits
[10:33:39.854]                     invokeRestart <- base::invokeRestart
[10:33:39.854]                     is.null <- base::is.null
[10:33:39.854]                     muffled <- FALSE
[10:33:39.854]                     if (inherits(cond, "message")) {
[10:33:39.854]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:39.854]                       if (muffled) 
[10:33:39.854]                         invokeRestart("muffleMessage")
[10:33:39.854]                     }
[10:33:39.854]                     else if (inherits(cond, "warning")) {
[10:33:39.854]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:39.854]                       if (muffled) 
[10:33:39.854]                         invokeRestart("muffleWarning")
[10:33:39.854]                     }
[10:33:39.854]                     else if (inherits(cond, "condition")) {
[10:33:39.854]                       if (!is.null(pattern)) {
[10:33:39.854]                         computeRestarts <- base::computeRestarts
[10:33:39.854]                         grepl <- base::grepl
[10:33:39.854]                         restarts <- computeRestarts(cond)
[10:33:39.854]                         for (restart in restarts) {
[10:33:39.854]                           name <- restart$name
[10:33:39.854]                           if (is.null(name)) 
[10:33:39.854]                             next
[10:33:39.854]                           if (!grepl(pattern, name)) 
[10:33:39.854]                             next
[10:33:39.854]                           invokeRestart(restart)
[10:33:39.854]                           muffled <- TRUE
[10:33:39.854]                           break
[10:33:39.854]                         }
[10:33:39.854]                       }
[10:33:39.854]                     }
[10:33:39.854]                     invisible(muffled)
[10:33:39.854]                   }
[10:33:39.854]                   muffleCondition(cond)
[10:33:39.854]                 })
[10:33:39.854]             }))
[10:33:39.854]             future::FutureResult(value = ...future.value$value, 
[10:33:39.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:39.854]                   ...future.rng), globalenv = if (FALSE) 
[10:33:39.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:39.854]                     ...future.globalenv.names))
[10:33:39.854]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:39.854]         }, condition = base::local({
[10:33:39.854]             c <- base::c
[10:33:39.854]             inherits <- base::inherits
[10:33:39.854]             invokeRestart <- base::invokeRestart
[10:33:39.854]             length <- base::length
[10:33:39.854]             list <- base::list
[10:33:39.854]             seq.int <- base::seq.int
[10:33:39.854]             signalCondition <- base::signalCondition
[10:33:39.854]             sys.calls <- base::sys.calls
[10:33:39.854]             `[[` <- base::`[[`
[10:33:39.854]             `+` <- base::`+`
[10:33:39.854]             `<<-` <- base::`<<-`
[10:33:39.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:39.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:39.854]                   3L)]
[10:33:39.854]             }
[10:33:39.854]             function(cond) {
[10:33:39.854]                 is_error <- inherits(cond, "error")
[10:33:39.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:39.854]                   NULL)
[10:33:39.854]                 if (is_error) {
[10:33:39.854]                   sessionInformation <- function() {
[10:33:39.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:39.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:39.854]                       search = base::search(), system = base::Sys.info())
[10:33:39.854]                   }
[10:33:39.854]                   ...future.conditions[[length(...future.conditions) + 
[10:33:39.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:39.854]                     cond$call), session = sessionInformation(), 
[10:33:39.854]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:39.854]                   signalCondition(cond)
[10:33:39.854]                 }
[10:33:39.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:39.854]                 "immediateCondition"))) {
[10:33:39.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:39.854]                   ...future.conditions[[length(...future.conditions) + 
[10:33:39.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:39.854]                   if (TRUE && !signal) {
[10:33:39.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:39.854]                     {
[10:33:39.854]                       inherits <- base::inherits
[10:33:39.854]                       invokeRestart <- base::invokeRestart
[10:33:39.854]                       is.null <- base::is.null
[10:33:39.854]                       muffled <- FALSE
[10:33:39.854]                       if (inherits(cond, "message")) {
[10:33:39.854]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:39.854]                         if (muffled) 
[10:33:39.854]                           invokeRestart("muffleMessage")
[10:33:39.854]                       }
[10:33:39.854]                       else if (inherits(cond, "warning")) {
[10:33:39.854]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:39.854]                         if (muffled) 
[10:33:39.854]                           invokeRestart("muffleWarning")
[10:33:39.854]                       }
[10:33:39.854]                       else if (inherits(cond, "condition")) {
[10:33:39.854]                         if (!is.null(pattern)) {
[10:33:39.854]                           computeRestarts <- base::computeRestarts
[10:33:39.854]                           grepl <- base::grepl
[10:33:39.854]                           restarts <- computeRestarts(cond)
[10:33:39.854]                           for (restart in restarts) {
[10:33:39.854]                             name <- restart$name
[10:33:39.854]                             if (is.null(name)) 
[10:33:39.854]                               next
[10:33:39.854]                             if (!grepl(pattern, name)) 
[10:33:39.854]                               next
[10:33:39.854]                             invokeRestart(restart)
[10:33:39.854]                             muffled <- TRUE
[10:33:39.854]                             break
[10:33:39.854]                           }
[10:33:39.854]                         }
[10:33:39.854]                       }
[10:33:39.854]                       invisible(muffled)
[10:33:39.854]                     }
[10:33:39.854]                     muffleCondition(cond, pattern = "^muffle")
[10:33:39.854]                   }
[10:33:39.854]                 }
[10:33:39.854]                 else {
[10:33:39.854]                   if (TRUE) {
[10:33:39.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:39.854]                     {
[10:33:39.854]                       inherits <- base::inherits
[10:33:39.854]                       invokeRestart <- base::invokeRestart
[10:33:39.854]                       is.null <- base::is.null
[10:33:39.854]                       muffled <- FALSE
[10:33:39.854]                       if (inherits(cond, "message")) {
[10:33:39.854]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:39.854]                         if (muffled) 
[10:33:39.854]                           invokeRestart("muffleMessage")
[10:33:39.854]                       }
[10:33:39.854]                       else if (inherits(cond, "warning")) {
[10:33:39.854]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:39.854]                         if (muffled) 
[10:33:39.854]                           invokeRestart("muffleWarning")
[10:33:39.854]                       }
[10:33:39.854]                       else if (inherits(cond, "condition")) {
[10:33:39.854]                         if (!is.null(pattern)) {
[10:33:39.854]                           computeRestarts <- base::computeRestarts
[10:33:39.854]                           grepl <- base::grepl
[10:33:39.854]                           restarts <- computeRestarts(cond)
[10:33:39.854]                           for (restart in restarts) {
[10:33:39.854]                             name <- restart$name
[10:33:39.854]                             if (is.null(name)) 
[10:33:39.854]                               next
[10:33:39.854]                             if (!grepl(pattern, name)) 
[10:33:39.854]                               next
[10:33:39.854]                             invokeRestart(restart)
[10:33:39.854]                             muffled <- TRUE
[10:33:39.854]                             break
[10:33:39.854]                           }
[10:33:39.854]                         }
[10:33:39.854]                       }
[10:33:39.854]                       invisible(muffled)
[10:33:39.854]                     }
[10:33:39.854]                     muffleCondition(cond, pattern = "^muffle")
[10:33:39.854]                   }
[10:33:39.854]                 }
[10:33:39.854]             }
[10:33:39.854]         }))
[10:33:39.854]     }, error = function(ex) {
[10:33:39.854]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:39.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:39.854]                 ...future.rng), started = ...future.startTime, 
[10:33:39.854]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:39.854]             version = "1.8"), class = "FutureResult")
[10:33:39.854]     }, finally = {
[10:33:39.854]         if (!identical(...future.workdir, getwd())) 
[10:33:39.854]             setwd(...future.workdir)
[10:33:39.854]         {
[10:33:39.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:39.854]                 ...future.oldOptions$nwarnings <- NULL
[10:33:39.854]             }
[10:33:39.854]             base::options(...future.oldOptions)
[10:33:39.854]             if (.Platform$OS.type == "windows") {
[10:33:39.854]                 old_names <- names(...future.oldEnvVars)
[10:33:39.854]                 envs <- base::Sys.getenv()
[10:33:39.854]                 names <- names(envs)
[10:33:39.854]                 common <- intersect(names, old_names)
[10:33:39.854]                 added <- setdiff(names, old_names)
[10:33:39.854]                 removed <- setdiff(old_names, names)
[10:33:39.854]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:39.854]                   envs[common]]
[10:33:39.854]                 NAMES <- toupper(changed)
[10:33:39.854]                 args <- list()
[10:33:39.854]                 for (kk in seq_along(NAMES)) {
[10:33:39.854]                   name <- changed[[kk]]
[10:33:39.854]                   NAME <- NAMES[[kk]]
[10:33:39.854]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:39.854]                     next
[10:33:39.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:39.854]                 }
[10:33:39.854]                 NAMES <- toupper(added)
[10:33:39.854]                 for (kk in seq_along(NAMES)) {
[10:33:39.854]                   name <- added[[kk]]
[10:33:39.854]                   NAME <- NAMES[[kk]]
[10:33:39.854]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:39.854]                     next
[10:33:39.854]                   args[[name]] <- ""
[10:33:39.854]                 }
[10:33:39.854]                 NAMES <- toupper(removed)
[10:33:39.854]                 for (kk in seq_along(NAMES)) {
[10:33:39.854]                   name <- removed[[kk]]
[10:33:39.854]                   NAME <- NAMES[[kk]]
[10:33:39.854]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:39.854]                     next
[10:33:39.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:39.854]                 }
[10:33:39.854]                 if (length(args) > 0) 
[10:33:39.854]                   base::do.call(base::Sys.setenv, args = args)
[10:33:39.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:39.854]             }
[10:33:39.854]             else {
[10:33:39.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:39.854]             }
[10:33:39.854]             {
[10:33:39.854]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:39.854]                   0L) {
[10:33:39.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:39.854]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:39.854]                   base::options(opts)
[10:33:39.854]                 }
[10:33:39.854]                 {
[10:33:39.854]                   {
[10:33:39.854]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:39.854]                     NULL
[10:33:39.854]                   }
[10:33:39.854]                   options(future.plan = NULL)
[10:33:39.854]                   if (is.na(NA_character_)) 
[10:33:39.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:39.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:39.854]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:39.854]                     .init = FALSE)
[10:33:39.854]                 }
[10:33:39.854]             }
[10:33:39.854]         }
[10:33:39.854]     })
[10:33:39.854]     if (TRUE) {
[10:33:39.854]         base::sink(type = "output", split = FALSE)
[10:33:39.854]         if (TRUE) {
[10:33:39.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:39.854]         }
[10:33:39.854]         else {
[10:33:39.854]             ...future.result["stdout"] <- base::list(NULL)
[10:33:39.854]         }
[10:33:39.854]         base::close(...future.stdout)
[10:33:39.854]         ...future.stdout <- NULL
[10:33:39.854]     }
[10:33:39.854]     ...future.result$conditions <- ...future.conditions
[10:33:39.854]     ...future.result$finished <- base::Sys.time()
[10:33:39.854]     ...future.result
[10:33:39.854] }
[10:33:39.856] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[10:33:39.857] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[10:33:39.857] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[10:33:39.857] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[10:33:39.858] MultisessionFuture started
[10:33:39.858] - Launch lazy future ... done
[10:33:39.858] run() for ‘MultisessionFuture’ ... done
[10:33:39.858] result() for ClusterFuture ...
[10:33:39.858] receiveMessageFromWorker() for ClusterFuture ...
[10:33:39.858] - Validating connection of MultisessionFuture
[10:33:39.916] - received message: FutureResult
[10:33:39.916] - Received FutureResult
[10:33:39.916] - Erased future from FutureRegistry
[10:33:39.916] result() for ClusterFuture ...
[10:33:39.916] - result already collected: FutureResult
[10:33:39.916] result() for ClusterFuture ... done
[10:33:39.917] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:39.917] result() for ClusterFuture ... done
[10:33:39.917] result() for ClusterFuture ...
[10:33:39.917] - result already collected: FutureResult
[10:33:39.917] result() for ClusterFuture ... done
- plan(list('multisession', 'multisession')) ... DONE
> 
> message("*** Nested futures ... DONE")
*** Nested futures ... DONE
> 
> source("incl/end.R")
[10:33:39.918] plan(): Setting new future strategy stack:
[10:33:39.918] List of future strategies:
[10:33:39.918] 1. FutureStrategy:
[10:33:39.918]    - args: function (..., envir = parent.frame())
[10:33:39.918]    - tweaked: FALSE
[10:33:39.918]    - call: future::plan(oplan)
[10:33:39.919] plan(): nbrOfWorkers() = 1
> 
