
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:21:27.660] plan(): Setting new future strategy stack:
[16:21:27.660] List of future strategies:
[16:21:27.660] 1. sequential:
[16:21:27.660]    - args: function (..., envir = parent.frame())
[16:21:27.660]    - tweaked: FALSE
[16:21:27.660]    - call: future::plan("sequential")
[16:21:27.674] plan(): nbrOfWorkers() = 1
> 
> strategies <- supportedStrategies()
> 
> message("*** Nested futures ...")
*** Nested futures ...
> 
> for (strategy1 in strategies) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   for (strategy2 in strategies) {
+     message(sprintf("- plan(list('%s', '%s')) ...", strategy1, strategy2))
+     plan(list(a = strategy1, b = strategy2))
+     
+     nested <- plan("list")
+     stopifnot(
+       length(nested) == 2L,
+       all(names(nested) == c("a", "b")),
+       inherits(plan("next"), strategy1)
+     )
+ 
+     x %<-% {
+       a <- 1L
+ 
+       ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+       ## we're exporting the plan() function including its local stack!
+       plan_a <- unclass(future::plan("list"))
+       nested_a <- nested[-1]
+ 
+       stopifnot(
+         length(nested_a) == 1L,
+         length(plan_a) == 1L,
+         inherits(plan_a[[1]], "future"),
+         inherits(future::plan("next"), strategy2)
+       )
+ 
+       ## Attribute 'init' is modified at run time
+       for (kk in seq_along(plan_a)) attr(plan_a[[kk]], "init") <- NULL
+       for (kk in seq_along(nested_a)) attr(nested_a[[kk]], "init") <- NULL
+       stopifnot(all.equal(plan_a, nested_a))
+ 
+       y %<-% {
+         b <- 2L
+         
+         ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+         ## we're exporting the plan() function including its local stack!
+         plan_b <- future::plan("list")
+         nested_b <- nested_a[-1]
+ 
+         stopifnot(
+           length(nested_b) == 0L,
+           length(plan_b) == 1L,
+           inherits(plan_b[[1]], "future"),
+           inherits(future::plan("next"), "sequential")
+         )
+ 
+         list(a = a, nested_a = nested_a, plan_a = plan_a,
+              b = b, nested_b = nested_b, plan_b = plan_b)
+       }
+       y
+     }
+ 
+     str(x)
+ 
+     stopifnot(
+       length(x) == 3 * length(nested),
+       all(names(x) == c("a", "nested_a", "plan_a",
+                         "b", "nested_b", "plan_b")),
+ 
+       x$a == 1L,
+       length(x$nested_a) == 1L,
+       is.list(x$plan_a),
+       length(x$plan_a) == 1L,
+       inherits(x$plan_a[[1]], "future"),
+ 
+       x$b == 2L,
+       length(x$nested_b) == 0L,
+       is.list(x$plan_b),
+       length(x$plan_b) == 1L,
+       inherits(x$plan_b[[1]], "future"),
+       inherits(x$plan_b[[1]], "sequential")
+     )
+ 
+     ## Attribute 'init' is modified at run time
+     for (kk in seq_along(x$plan_a)) attr(x$plan_a[[kk]], "init") <- NULL
+     for (kk in seq_along(nested)) attr(nested[[kk]], "init") <- NULL
+     stopifnot(all.equal(x$plan_a, nested[-1L]))
+ 
+     rm(list = c("nested", "x"))
+ 
+ 
+     ## Nested futures and globals
+     ## In future (<= 1.7.0), the below would produce an error saying
+     ## "Failed to locate global object in the relevant environments: 'a'"
+     ## Related to https://github.com/HenrikBengtsson/globals/issues/35
+     data <- data.frame(a = 1:3, b = 3:1)
+     y_truth <- subset(data, a == 2)
+     f <- future({
+       value(future( subset(data, a == 2) ))
+     })
+     y <- value(f)
+     stopifnot(identical(y, y_truth))
+     
+     message(sprintf("- plan(list('%s', '%s')) ... DONE", strategy1, strategy2))
+   }
+ }
- plan(list('sequential', 'sequential')) ...
[16:21:27.724] plan(): Setting new future strategy stack:
[16:21:27.725] List of future strategies:
[16:21:27.725] 1. sequential:
[16:21:27.725]    - args: function (..., envir = parent.frame())
[16:21:27.725]    - tweaked: FALSE
[16:21:27.725]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:27.725] 2. sequential:
[16:21:27.725]    - args: function (..., envir = parent.frame())
[16:21:27.725]    - tweaked: FALSE
[16:21:27.725]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:27.736] plan(): nbrOfWorkers() = 1
[16:21:27.738] getGlobalsAndPackages() ...
[16:21:27.738] Searching for globals...
[16:21:27.761] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:21:27.761] Searching for globals ... DONE
[16:21:27.762] Resolving globals: FALSE
[16:21:27.763] The total size of the 2 globals is 22.60 KiB (23144 bytes)
[16:21:27.764] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 22.60 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (22.48 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:21:27.764] - globals: [2] ‘nested’, ‘strategy2’
[16:21:27.764] - packages: [1] ‘future’
[16:21:27.764] getGlobalsAndPackages() ... DONE
[16:21:27.765] run() for ‘Future’ ...
[16:21:27.765] - state: ‘created’
[16:21:27.765] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:27.766] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:27.766] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:27.766]   - Field: ‘label’
[16:21:27.766]   - Field: ‘local’
[16:21:27.766]   - Field: ‘owner’
[16:21:27.766]   - Field: ‘envir’
[16:21:27.766]   - Field: ‘packages’
[16:21:27.767]   - Field: ‘gc’
[16:21:27.767]   - Field: ‘conditions’
[16:21:27.767]   - Field: ‘expr’
[16:21:27.767]   - Field: ‘uuid’
[16:21:27.767]   - Field: ‘seed’
[16:21:27.767]   - Field: ‘version’
[16:21:27.767]   - Field: ‘result’
[16:21:27.767]   - Field: ‘asynchronous’
[16:21:27.767]   - Field: ‘calls’
[16:21:27.767]   - Field: ‘globals’
[16:21:27.767]   - Field: ‘stdout’
[16:21:27.768]   - Field: ‘earlySignal’
[16:21:27.768]   - Field: ‘lazy’
[16:21:27.768]   - Field: ‘state’
[16:21:27.768] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:27.768] - Launch lazy future ...
[16:21:27.769] Packages needed by the future expression (n = 1): ‘future’
[16:21:27.769] Packages needed by future strategies (n = 1): ‘future’
[16:21:27.770] {
[16:21:27.770]     {
[16:21:27.770]         {
[16:21:27.770]             ...future.startTime <- base::Sys.time()
[16:21:27.770]             {
[16:21:27.770]                 {
[16:21:27.770]                   {
[16:21:27.770]                     {
[16:21:27.770]                       base::local({
[16:21:27.770]                         has_future <- base::requireNamespace("future", 
[16:21:27.770]                           quietly = TRUE)
[16:21:27.770]                         if (has_future) {
[16:21:27.770]                           ns <- base::getNamespace("future")
[16:21:27.770]                           version <- ns[[".package"]][["version"]]
[16:21:27.770]                           if (is.null(version)) 
[16:21:27.770]                             version <- utils::packageVersion("future")
[16:21:27.770]                         }
[16:21:27.770]                         else {
[16:21:27.770]                           version <- NULL
[16:21:27.770]                         }
[16:21:27.770]                         if (!has_future || version < "1.8.0") {
[16:21:27.770]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:27.770]                             "", base::R.version$version.string), 
[16:21:27.770]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:27.770]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:27.770]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:27.770]                               "release", "version")], collapse = " "), 
[16:21:27.770]                             hostname = base::Sys.info()[["nodename"]])
[16:21:27.770]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:27.770]                             info)
[16:21:27.770]                           info <- base::paste(info, collapse = "; ")
[16:21:27.770]                           if (!has_future) {
[16:21:27.770]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:27.770]                               info)
[16:21:27.770]                           }
[16:21:27.770]                           else {
[16:21:27.770]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:27.770]                               info, version)
[16:21:27.770]                           }
[16:21:27.770]                           base::stop(msg)
[16:21:27.770]                         }
[16:21:27.770]                       })
[16:21:27.770]                     }
[16:21:27.770]                     base::local({
[16:21:27.770]                       for (pkg in "future") {
[16:21:27.770]                         base::loadNamespace(pkg)
[16:21:27.770]                         base::library(pkg, character.only = TRUE)
[16:21:27.770]                       }
[16:21:27.770]                     })
[16:21:27.770]                   }
[16:21:27.770]                   ...future.strategy.old <- future::plan("list")
[16:21:27.770]                   options(future.plan = NULL)
[16:21:27.770]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:27.770]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:21:27.770]                   {
[16:21:27.770]                     future <- SequentialFuture(..., envir = envir)
[16:21:27.770]                     if (!future$lazy) 
[16:21:27.770]                       future <- run(future)
[16:21:27.770]                     invisible(future)
[16:21:27.770]                   }), .cleanup = FALSE, .init = FALSE)
[16:21:27.770]                 }
[16:21:27.770]                 ...future.workdir <- getwd()
[16:21:27.770]             }
[16:21:27.770]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:27.770]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:27.770]         }
[16:21:27.770]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:27.770]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:27.770]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:27.770]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:27.770]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:27.770]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:27.770]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:27.770]             base::names(...future.oldOptions))
[16:21:27.770]     }
[16:21:27.770]     if (FALSE) {
[16:21:27.770]     }
[16:21:27.770]     else {
[16:21:27.770]         if (TRUE) {
[16:21:27.770]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:27.770]                 open = "w")
[16:21:27.770]         }
[16:21:27.770]         else {
[16:21:27.770]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:27.770]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:27.770]         }
[16:21:27.770]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:27.770]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:27.770]             base::sink(type = "output", split = FALSE)
[16:21:27.770]             base::close(...future.stdout)
[16:21:27.770]         }, add = TRUE)
[16:21:27.770]     }
[16:21:27.770]     ...future.frame <- base::sys.nframe()
[16:21:27.770]     ...future.conditions <- base::list()
[16:21:27.770]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:27.770]     if (FALSE) {
[16:21:27.770]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:27.770]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:27.770]     }
[16:21:27.770]     ...future.result <- base::tryCatch({
[16:21:27.770]         base::withCallingHandlers({
[16:21:27.770]             ...future.value <- base::withVisible(base::local({
[16:21:27.770]                 a <- 1L
[16:21:27.770]                 plan_a <- unclass(future::plan("list"))
[16:21:27.770]                 nested_a <- nested[-1]
[16:21:27.770]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:21:27.770]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:21:27.770]                   strategy2))
[16:21:27.770]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:21:27.770]                   "init") <- NULL
[16:21:27.770]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:21:27.770]                   "init") <- NULL
[16:21:27.770]                 stopifnot(all.equal(plan_a, nested_a))
[16:21:27.770]                 y %<-% {
[16:21:27.770]                   b <- 2L
[16:21:27.770]                   plan_b <- future::plan("list")
[16:21:27.770]                   nested_b <- nested_a[-1]
[16:21:27.770]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:21:27.770]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:21:27.770]                     "sequential"))
[16:21:27.770]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:21:27.770]                     b = b, nested_b = nested_b, plan_b = plan_b)
[16:21:27.770]                 }
[16:21:27.770]                 y
[16:21:27.770]             }))
[16:21:27.770]             future::FutureResult(value = ...future.value$value, 
[16:21:27.770]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:27.770]                   ...future.rng), globalenv = if (FALSE) 
[16:21:27.770]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:27.770]                     ...future.globalenv.names))
[16:21:27.770]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:27.770]         }, condition = base::local({
[16:21:27.770]             c <- base::c
[16:21:27.770]             inherits <- base::inherits
[16:21:27.770]             invokeRestart <- base::invokeRestart
[16:21:27.770]             length <- base::length
[16:21:27.770]             list <- base::list
[16:21:27.770]             seq.int <- base::seq.int
[16:21:27.770]             signalCondition <- base::signalCondition
[16:21:27.770]             sys.calls <- base::sys.calls
[16:21:27.770]             `[[` <- base::`[[`
[16:21:27.770]             `+` <- base::`+`
[16:21:27.770]             `<<-` <- base::`<<-`
[16:21:27.770]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:27.770]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:27.770]                   3L)]
[16:21:27.770]             }
[16:21:27.770]             function(cond) {
[16:21:27.770]                 is_error <- inherits(cond, "error")
[16:21:27.770]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:27.770]                   NULL)
[16:21:27.770]                 if (is_error) {
[16:21:27.770]                   sessionInformation <- function() {
[16:21:27.770]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:27.770]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:27.770]                       search = base::search(), system = base::Sys.info())
[16:21:27.770]                   }
[16:21:27.770]                   ...future.conditions[[length(...future.conditions) + 
[16:21:27.770]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:27.770]                     cond$call), session = sessionInformation(), 
[16:21:27.770]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:27.770]                   signalCondition(cond)
[16:21:27.770]                 }
[16:21:27.770]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:27.770]                 "immediateCondition"))) {
[16:21:27.770]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:27.770]                   ...future.conditions[[length(...future.conditions) + 
[16:21:27.770]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:27.770]                   if (TRUE && !signal) {
[16:21:27.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:27.770]                     {
[16:21:27.770]                       inherits <- base::inherits
[16:21:27.770]                       invokeRestart <- base::invokeRestart
[16:21:27.770]                       is.null <- base::is.null
[16:21:27.770]                       muffled <- FALSE
[16:21:27.770]                       if (inherits(cond, "message")) {
[16:21:27.770]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:27.770]                         if (muffled) 
[16:21:27.770]                           invokeRestart("muffleMessage")
[16:21:27.770]                       }
[16:21:27.770]                       else if (inherits(cond, "warning")) {
[16:21:27.770]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:27.770]                         if (muffled) 
[16:21:27.770]                           invokeRestart("muffleWarning")
[16:21:27.770]                       }
[16:21:27.770]                       else if (inherits(cond, "condition")) {
[16:21:27.770]                         if (!is.null(pattern)) {
[16:21:27.770]                           computeRestarts <- base::computeRestarts
[16:21:27.770]                           grepl <- base::grepl
[16:21:27.770]                           restarts <- computeRestarts(cond)
[16:21:27.770]                           for (restart in restarts) {
[16:21:27.770]                             name <- restart$name
[16:21:27.770]                             if (is.null(name)) 
[16:21:27.770]                               next
[16:21:27.770]                             if (!grepl(pattern, name)) 
[16:21:27.770]                               next
[16:21:27.770]                             invokeRestart(restart)
[16:21:27.770]                             muffled <- TRUE
[16:21:27.770]                             break
[16:21:27.770]                           }
[16:21:27.770]                         }
[16:21:27.770]                       }
[16:21:27.770]                       invisible(muffled)
[16:21:27.770]                     }
[16:21:27.770]                     muffleCondition(cond, pattern = "^muffle")
[16:21:27.770]                   }
[16:21:27.770]                 }
[16:21:27.770]                 else {
[16:21:27.770]                   if (TRUE) {
[16:21:27.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:27.770]                     {
[16:21:27.770]                       inherits <- base::inherits
[16:21:27.770]                       invokeRestart <- base::invokeRestart
[16:21:27.770]                       is.null <- base::is.null
[16:21:27.770]                       muffled <- FALSE
[16:21:27.770]                       if (inherits(cond, "message")) {
[16:21:27.770]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:27.770]                         if (muffled) 
[16:21:27.770]                           invokeRestart("muffleMessage")
[16:21:27.770]                       }
[16:21:27.770]                       else if (inherits(cond, "warning")) {
[16:21:27.770]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:27.770]                         if (muffled) 
[16:21:27.770]                           invokeRestart("muffleWarning")
[16:21:27.770]                       }
[16:21:27.770]                       else if (inherits(cond, "condition")) {
[16:21:27.770]                         if (!is.null(pattern)) {
[16:21:27.770]                           computeRestarts <- base::computeRestarts
[16:21:27.770]                           grepl <- base::grepl
[16:21:27.770]                           restarts <- computeRestarts(cond)
[16:21:27.770]                           for (restart in restarts) {
[16:21:27.770]                             name <- restart$name
[16:21:27.770]                             if (is.null(name)) 
[16:21:27.770]                               next
[16:21:27.770]                             if (!grepl(pattern, name)) 
[16:21:27.770]                               next
[16:21:27.770]                             invokeRestart(restart)
[16:21:27.770]                             muffled <- TRUE
[16:21:27.770]                             break
[16:21:27.770]                           }
[16:21:27.770]                         }
[16:21:27.770]                       }
[16:21:27.770]                       invisible(muffled)
[16:21:27.770]                     }
[16:21:27.770]                     muffleCondition(cond, pattern = "^muffle")
[16:21:27.770]                   }
[16:21:27.770]                 }
[16:21:27.770]             }
[16:21:27.770]         }))
[16:21:27.770]     }, error = function(ex) {
[16:21:27.770]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:27.770]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:27.770]                 ...future.rng), started = ...future.startTime, 
[16:21:27.770]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:27.770]             version = "1.8"), class = "FutureResult")
[16:21:27.770]     }, finally = {
[16:21:27.770]         if (!identical(...future.workdir, getwd())) 
[16:21:27.770]             setwd(...future.workdir)
[16:21:27.770]         {
[16:21:27.770]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:27.770]                 ...future.oldOptions$nwarnings <- NULL
[16:21:27.770]             }
[16:21:27.770]             base::options(...future.oldOptions)
[16:21:27.770]             if (.Platform$OS.type == "windows") {
[16:21:27.770]                 old_names <- names(...future.oldEnvVars)
[16:21:27.770]                 envs <- base::Sys.getenv()
[16:21:27.770]                 names <- names(envs)
[16:21:27.770]                 common <- intersect(names, old_names)
[16:21:27.770]                 added <- setdiff(names, old_names)
[16:21:27.770]                 removed <- setdiff(old_names, names)
[16:21:27.770]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:27.770]                   envs[common]]
[16:21:27.770]                 NAMES <- toupper(changed)
[16:21:27.770]                 args <- list()
[16:21:27.770]                 for (kk in seq_along(NAMES)) {
[16:21:27.770]                   name <- changed[[kk]]
[16:21:27.770]                   NAME <- NAMES[[kk]]
[16:21:27.770]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:27.770]                     next
[16:21:27.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:27.770]                 }
[16:21:27.770]                 NAMES <- toupper(added)
[16:21:27.770]                 for (kk in seq_along(NAMES)) {
[16:21:27.770]                   name <- added[[kk]]
[16:21:27.770]                   NAME <- NAMES[[kk]]
[16:21:27.770]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:27.770]                     next
[16:21:27.770]                   args[[name]] <- ""
[16:21:27.770]                 }
[16:21:27.770]                 NAMES <- toupper(removed)
[16:21:27.770]                 for (kk in seq_along(NAMES)) {
[16:21:27.770]                   name <- removed[[kk]]
[16:21:27.770]                   NAME <- NAMES[[kk]]
[16:21:27.770]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:27.770]                     next
[16:21:27.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:27.770]                 }
[16:21:27.770]                 if (length(args) > 0) 
[16:21:27.770]                   base::do.call(base::Sys.setenv, args = args)
[16:21:27.770]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:27.770]             }
[16:21:27.770]             else {
[16:21:27.770]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:27.770]             }
[16:21:27.770]             {
[16:21:27.770]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:27.770]                   0L) {
[16:21:27.770]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:27.770]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:27.770]                   base::options(opts)
[16:21:27.770]                 }
[16:21:27.770]                 {
[16:21:27.770]                   {
[16:21:27.770]                     NULL
[16:21:27.770]                     RNGkind("Mersenne-Twister")
[16:21:27.770]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:27.770]                       inherits = FALSE)
[16:21:27.770]                   }
[16:21:27.770]                   options(future.plan = NULL)
[16:21:27.770]                   if (is.na(NA_character_)) 
[16:21:27.770]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:27.770]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:27.770]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:27.770]                     .init = FALSE)
[16:21:27.770]                 }
[16:21:27.770]             }
[16:21:27.770]         }
[16:21:27.770]     })
[16:21:27.770]     if (TRUE) {
[16:21:27.770]         base::sink(type = "output", split = FALSE)
[16:21:27.770]         if (TRUE) {
[16:21:27.770]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:27.770]         }
[16:21:27.770]         else {
[16:21:27.770]             ...future.result["stdout"] <- base::list(NULL)
[16:21:27.770]         }
[16:21:27.770]         base::close(...future.stdout)
[16:21:27.770]         ...future.stdout <- NULL
[16:21:27.770]     }
[16:21:27.770]     ...future.result$conditions <- ...future.conditions
[16:21:27.770]     ...future.result$finished <- base::Sys.time()
[16:21:27.770]     ...future.result
[16:21:27.770] }
[16:21:27.772] assign_globals() ...
[16:21:27.772] List of 2
[16:21:27.772]  $ nested   :List of 2
[16:21:27.772]   ..$ a:function (..., envir = parent.frame())  
[16:21:27.772]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:21:27.772]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:21:27.772]   ..$ b:function (..., envir = parent.frame())  
[16:21:27.772]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:21:27.772]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:21:27.772]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:21:27.772]  $ strategy2: chr "sequential"
[16:21:27.772]  - attr(*, "where")=List of 2
[16:21:27.772]   ..$ nested   :<environment: R_EmptyEnv> 
[16:21:27.772]   ..$ strategy2:<environment: R_EmptyEnv> 
[16:21:27.772]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:27.772]  - attr(*, "resolved")= logi FALSE
[16:21:27.772]  - attr(*, "total_size")= num 23144
[16:21:27.772]  - attr(*, "already-done")= logi TRUE
[16:21:27.779] - copied ‘nested’ to environment
[16:21:27.779] - copied ‘strategy2’ to environment
[16:21:27.779] assign_globals() ... done
[16:21:27.779] plan(): Setting new future strategy stack:
[16:21:27.779] List of future strategies:
[16:21:27.779] 1. sequential:
[16:21:27.779]    - args: function (..., envir = parent.frame())
[16:21:27.779]    - tweaked: FALSE
[16:21:27.779]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:27.780] plan(): nbrOfWorkers() = 1
[16:21:27.817] plan(): Setting new future strategy stack:
[16:21:27.817] List of future strategies:
[16:21:27.817] 1. sequential:
[16:21:27.817]    - args: function (..., envir = parent.frame())
[16:21:27.817]    - tweaked: FALSE
[16:21:27.817]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:27.817] 2. sequential:
[16:21:27.817]    - args: function (..., envir = parent.frame())
[16:21:27.817]    - tweaked: FALSE
[16:21:27.817]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:27.818] plan(): nbrOfWorkers() = 1
[16:21:27.818] SequentialFuture started (and completed)
[16:21:27.818] signalConditions() ...
[16:21:27.818]  - include = ‘immediateCondition’
[16:21:27.818]  - exclude = 
[16:21:27.818]  - resignal = FALSE
[16:21:27.818]  - Number of conditions: 54
[16:21:27.818] signalConditions() ... done
[16:21:27.818] - Launch lazy future ... done
[16:21:27.818] run() for ‘SequentialFuture’ ... done
[16:21:27.819] signalConditions() ...
[16:21:27.819]  - include = ‘immediateCondition’
[16:21:27.819]  - exclude = 
[16:21:27.819]  - resignal = FALSE
[16:21:27.819]  - Number of conditions: 54
[16:21:27.819] signalConditions() ... done
[16:21:27.819] Future state: ‘finished’
[16:21:27.819] signalConditions() ...
[16:21:27.819]  - include = ‘condition’
[16:21:27.819]  - exclude = ‘immediateCondition’
[16:21:27.820]  - resignal = TRUE
[16:21:27.820]  - Number of conditions: 54
[16:21:27.820]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.781] getGlobalsAndPackages() ...
[16:21:27.820]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.781] Searching for globals...
[16:21:27.820]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.800] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[16:21:27.820]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.800] Searching for globals ... DONE
[16:21:27.820]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.800] Resolving globals: FALSE
[16:21:27.820]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.801] The total size of the 3 globals is 22.54 KiB (23080 bytes)
[16:21:27.821]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.801] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 22.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (11.24 KiB of class ‘list’), ‘plan_a’ (11.24 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[16:21:27.821]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.801] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[16:21:27.821]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.801] 
[16:21:27.821]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.802] getGlobalsAndPackages() ... DONE
[16:21:27.821]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.802] run() for ‘Future’ ...
[16:21:27.821]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.802] - state: ‘created’
[16:21:27.821]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.802] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:27.821]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.802] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:27.822]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.802] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:27.822]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.803]   - Field: ‘label’
[16:21:27.822]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.803]   - Field: ‘local’
[16:21:27.822]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.803]   - Field: ‘owner’
[16:21:27.822]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.803]   - Field: ‘envir’
[16:21:27.822]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.803]   - Field: ‘packages’
[16:21:27.822]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.803]   - Field: ‘gc’
[16:21:27.822]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.803]   - Field: ‘conditions’
[16:21:27.823]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.803]   - Field: ‘expr’
[16:21:27.823]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.803]   - Field: ‘uuid’
[16:21:27.823]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.803]   - Field: ‘seed’
[16:21:27.823]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.804]   - Field: ‘version’
[16:21:27.823]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.804]   - Field: ‘result’
[16:21:27.823]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.804]   - Field: ‘asynchronous’
[16:21:27.823]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.804]   - Field: ‘calls’
[16:21:27.823]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.804]   - Field: ‘globals’
[16:21:27.824]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.804]   - Field: ‘stdout’
[16:21:27.824]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.804]   - Field: ‘earlySignal’
[16:21:27.824]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.804]   - Field: ‘lazy’
[16:21:27.824]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.804]   - Field: ‘state’
[16:21:27.824]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.804] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:27.824]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.805] - Launch lazy future ...
[16:21:27.824]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.805] Packages needed by the future expression (n = 0): <none>
[16:21:27.824]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.805] Packages needed by future strategies (n = 0): <none>
[16:21:27.825]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.805] {
[16:21:27.805]     {
[16:21:27.805]         {
[16:21:27.805]             ...future.startTime <- base::Sys.time()
[16:21:27.805]             {
[16:21:27.805]                 {
[16:21:27.805]                   {
[16:21:27.805]                     base::local({
[16:21:27.805]                       has_future <- base::requireNamespace("future", 
[16:21:27.805]                         quietly = TRUE)
[16:21:27.805]                       if (has_future) {
[16:21:27.805]                         ns <- base::getNamespace("future")
[16:21:27.805]                         version <- ns[[".package"]][["version"]]
[16:21:27.805]                         if (is.null(version)) 
[16:21:27.805]                           version <- utils::packageVersion("future")
[16:21:27.805]                       }
[16:21:27.805]                       else {
[16:21:27.805]                         version <- NULL
[16:21:27.805]                       }
[16:21:27.805]                       if (!has_future || version < "1.8.0") {
[16:21:27.805]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:27.805]                           "", base::R.version$version.string), 
[16:21:27.805]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:27.805]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:27.805]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:27.805]                             "release", "version")], collapse = " "), 
[16:21:27.805]                           hostname = base::Sys.info()[["nodename"]])
[16:21:27.805]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:27.805]                           info)
[16:21:27.805]                         info <- base::paste(info, collapse = "; ")
[16:21:27.805]                         if (!has_future) {
[16:21:27.805]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:27.805]                             info)
[16:21:27.805]                         }
[16:21:27.805]                         else {
[16:21:27.805]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:27.805]                             info, version)
[16:21:27.805]                         }
[16:21:27.805]                         base::stop(msg)
[16:21:27.805]                       }
[16:21:27.805]                     })
[16:21:27.805]                   }
[16:21:27.805]                   ...future.strategy.old <- future::plan("list")
[16:21:27.805]                   options(future.plan = NULL)
[16:21:27.805]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:27.805]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:27.805]                 }
[16:21:27.805]                 ...future.workdir <- getwd()
[16:21:27.805]             }
[16:21:27.805]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:27.805]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:27.805]         }
[16:21:27.805]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:27.805]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:27.805]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:27.805]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:27.805]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:27.805]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:27.805]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:27.805]             base::names(...future.oldOptions))
[16:21:27.805]     }
[16:21:27.805]     if (FALSE) {
[16:21:27.805]     }
[16:21:27.805]     else {
[16:21:27.805]         if (TRUE) {
[16:21:27.805]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:27.805]                 open = "w")
[16:21:27.805]         }
[16:21:27.805]         else {
[16:21:27.805]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:27.805]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:27.805]         }
[16:21:27.805]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:27.805]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:27.805]             base::sink(type = "output", split = FALSE)
[16:21:27.805]             base::close(...future.stdout)
[16:21:27.805]         }, add = TRUE)
[16:21:27.805]     }
[16:21:27.805]     ...future.frame <- base::sys.nframe()
[16:21:27.805]     ...future.conditions <- base::list()
[16:21:27.805]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:27.805]     if (FALSE) {
[16:21:27.805]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:27.805]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:27.805]     }
[16:21:27.805]     ...future.result <- base::tryCatch({
[16:21:27.805]         base::withCallingHandlers({
[16:21:27.805]             ...future.value <- base::withVisible(base::local({
[16:21:27.805]                 b <- 2L
[16:21:27.805]                 plan_b <- future::plan("list")
[16:21:27.805]                 nested_b <- nested_a[-1]
[16:21:27.805]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:21:27.805]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:21:27.805]                   "sequential"))
[16:21:27.805]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:21:27.805]                   b = b, nested_b = nested_b, plan_b = plan_b)
[16:21:27.805]             }))
[16:21:27.805]             future::FutureResult(value = ...future.value$value, 
[16:21:27.805]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:27.805]                   ...future.rng), globalenv = if (FALSE) 
[16:21:27.805]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:27.805]                     ...future.globalenv.names))
[16:21:27.805]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:27.805]         }, condition = base::local({
[16:21:27.805]             c <- base::c
[16:21:27.805]             inherits <- base::inherits
[16:21:27.805]             invokeRestart <- base::invokeRestart
[16:21:27.805]             length <- base::length
[16:21:27.805]             list <- base::list
[16:21:27.805]             seq.int <- base::seq.int
[16:21:27.805]             signalCondition <- base::signalCondition
[16:21:27.805]             sys.calls <- base::sys.calls
[16:21:27.805]             `[[` <- base::`[[`
[16:21:27.805]             `+` <- base::`+`
[16:21:27.805]             `<<-` <- base::`<<-`
[16:21:27.805]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:27.805]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:27.805]                   3L)]
[16:21:27.805]             }
[16:21:27.805]             function(cond) {
[16:21:27.805]                 is_error <- inherits(cond, "error")
[16:21:27.805]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:27.805]                   NULL)
[16:21:27.805]                 if (is_error) {
[16:21:27.805]                   sessionInformation <- function() {
[16:21:27.805]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:27.805]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:27.805]                       search = base::search(), system = base::Sys.info())
[16:21:27.805]                   }
[16:21:27.805]                   ...future.conditions[[length(...future.conditions) + 
[16:21:27.805]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:27.805]                     cond$call), session = sessionInformation(), 
[16:21:27.805]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:27.805]                   signalCondition(cond)
[16:21:27.805]                 }
[16:21:27.805]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:27.805]                 "immediateCondition"))) {
[16:21:27.805]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:27.805]                   ...future.conditions[[length(...future.conditions) + 
[16:21:27.805]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:27.805]                   if (TRUE && !signal) {
[16:21:27.805]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:27.805]                     {
[16:21:27.805]                       inherits <- base::inherits
[16:21:27.805]                       invokeRestart <- base::invokeRestart
[16:21:27.805]                       is.null <- base::is.null
[16:21:27.805]                       muffled <- FALSE
[16:21:27.805]                       if (inherits(cond, "message")) {
[16:21:27.805]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:27.805]                         if (muffled) 
[16:21:27.805]                           invokeRestart("muffleMessage")
[16:21:27.805]                       }
[16:21:27.805]                       else if (inherits(cond, "warning")) {
[16:21:27.805]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:27.805]                         if (muffled) 
[16:21:27.805]                           invokeRestart("muffleWarning")
[16:21:27.805]                       }
[16:21:27.805]                       else if (inherits(cond, "condition")) {
[16:21:27.805]                         if (!is.null(pattern)) {
[16:21:27.805]                           computeRestarts <- base::computeRestarts
[16:21:27.805]                           grepl <- base::grepl
[16:21:27.805]                           restarts <- computeRestarts(cond)
[16:21:27.805]                           for (restart in restarts) {
[16:21:27.805]                             name <- restart$name
[16:21:27.805]                             if (is.null(name)) 
[16:21:27.805]                               next
[16:21:27.805]                             if (!grepl(pattern, name)) 
[16:21:27.805]                               next
[16:21:27.805]                             invokeRestart(restart)
[16:21:27.805]                             muffled <- TRUE
[16:21:27.805]                             break
[16:21:27.805]                           }
[16:21:27.805]                         }
[16:21:27.805]                       }
[16:21:27.805]                       invisible(muffled)
[16:21:27.805]                     }
[16:21:27.805]                     muffleCondition(cond, pattern = "^muffle")
[16:21:27.805]                   }
[16:21:27.805]                 }
[16:21:27.805]                 else {
[16:21:27.805]                   if (TRUE) {
[16:21:27.805]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:27.805]                     {
[16:21:27.805]                       inherits <- base::inherits
[16:21:27.805]                       invokeRestart <- base::invokeRestart
[16:21:27.805]                       is.null <- base::is.null
[16:21:27.805]                       muffled <- FALSE
[16:21:27.805]                       if (inherits(cond, "message")) {
[16:21:27.805]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:27.805]                         if (muffled) 
[16:21:27.805]                           invokeRestart("muffleMessage")
[16:21:27.805]                       }
[16:21:27.805]                       else if (inherits(cond, "warning")) {
[16:21:27.805]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:27.805]                         if (muffled) 
[16:21:27.805]                           invokeRestart("muffleWarning")
[16:21:27.805]                       }
[16:21:27.805]                       else if (inherits(cond, "condition")) {
[16:21:27.805]                         if (!is.null(pattern)) {
[16:21:27.805]                           computeRestarts <- base::computeRestarts
[16:21:27.805]                           grepl <- base::grepl
[16:21:27.805]                           restarts <- computeRestarts(cond)
[16:21:27.805]                           for (restart in restarts) {
[16:21:27.805]                             name <- restart$name
[16:21:27.805]                             if (is.null(name)) 
[16:21:27.805]                               next
[16:21:27.805]                             if (!grepl(pattern, name)) 
[16:21:27.805]                               next
[16:21:27.805]                             invokeRestart(restart)
[16:21:27.805]                             muffled <- TRUE
[16:21:27.805]                             break
[16:21:27.805]                           }
[16:21:27.805]                         }
[16:21:27.805]                       }
[16:21:27.805]                       invisible(muffled)
[16:21:27.805]                     }
[16:21:27.805]                     muffleCondition(cond, pattern = "^muffle")
[16:21:27.805]                   }
[16:21:27.805]                 }
[16:21:27.805]             }
[16:21:27.805]         }))
[16:21:27.805]     }, error = function(ex) {
[16:21:27.805]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:27.805]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:27.805]                 ...future.rng), started = ...future.startTime, 
[16:21:27.805]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:27.805]             version = "1.8"), class = "FutureResult")
[16:21:27.805]     }, finally = {
[16:21:27.805]         if (!identical(...future.workdir, getwd())) 
[16:21:27.805]             setwd(...future.workdir)
[16:21:27.805]         {
[16:21:27.805]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:27.805]                 ...future.oldOptions$nwarnings <- NULL
[16:21:27.805]             }
[16:21:27.805]             base::options(...future.oldOptions)
[16:21:27.805]             if (.Platform$OS.type == "windows") {
[16:21:27.805]                 old_names <- names(...future.oldEnvVars)
[16:21:27.805]                 envs <- base::Sys.getenv()
[16:21:27.805]                 names <- names(envs)
[16:21:27.805]                 common <- intersect(names, old_names)
[16:21:27.805]                 added <- setdiff(names, old_names)
[16:21:27.805]                 removed <- setdiff(old_names, names)
[16:21:27.805]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:27.805]                   envs[common]]
[16:21:27.805]                 NAMES <- toupper(changed)
[16:21:27.805]                 args <- list()
[16:21:27.805]                 for (kk in seq_along(NAMES)) {
[16:21:27.805]                   name <- changed[[kk]]
[16:21:27.805]                   NAME <- NAMES[[kk]]
[16:21:27.805]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:27.805]                     next
[16:21:27.805]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:27.805]                 }
[16:21:27.805]                 NAMES <- toupper(added)
[16:21:27.805]                 for (kk in seq_along(NAMES)) {
[16:21:27.805]                   name <- added[[kk]]
[16:21:27.805]                   NAME <- NAMES[[kk]]
[16:21:27.805]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:27.805]                     next
[16:21:27.805]                   args[[name]] <- ""
[16:21:27.805]                 }
[16:21:27.805]                 NAMES <- toupper(removed)
[16:21:27.805]                 for (kk in seq_along(NAMES)) {
[16:21:27.805]                   name <- removed[[kk]]
[16:21:27.805]                   NAME <- NAMES[[kk]]
[16:21:27.805]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:27.805]                     next
[16:21:27.805]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:27.805]                 }
[16:21:27.805]                 if (length(args) > 0) 
[16:21:27.805]                   base::do.call(base::Sys.setenv, args = args)
[16:21:27.805]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:27.805]             }
[16:21:27.805]             else {
[16:21:27.805]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:27.805]             }
[16:21:27.805]             {
[16:21:27.805]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:27.805]                   0L) {
[16:21:27.805]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:27.805]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:27.805]                   base::options(opts)
[16:21:27.805]                 }
[16:21:27.805]                 {
[16:21:27.805]                   {
[16:21:27.805]                     NULL
[16:21:27.805]                     RNGkind("Mersenne-Twister")
[16:21:27.805]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:27.805]                       inherits = FALSE)
[16:21:27.805]                   }
[16:21:27.805]                   options(future.plan = NULL)
[16:21:27.805]                   if (is.na(NA_character_)) 
[16:21:27.805]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:27.805]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:27.805]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:27.805]                     .init = FALSE)
[16:21:27.805]                 }
[16:21:27.805]             }
[16:21:27.805]         }
[16:21:27.805]     })
[16:21:27.805]     if (TRUE) {
[16:21:27.805]         base::sink(type = "output", split = FALSE)
[16:21:27.805]         if (TRUE) {
[16:21:27.805]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:27.805]         }
[16:21:27.805]         else {
[16:21:27.805]             ...future.result["stdout"] <- base::list(NULL)
[16:21:27.805]         }
[16:21:27.805]         base::close(...future.stdout)
[16:21:27.805]         ...future.stdout <- NULL
[16:21:27.805]     }
[16:21:27.805]     ...future.result$conditions <- ...future.conditions
[16:21:27.805]     ...future.result$finished <- base::Sys.time()
[16:21:27.805]     ...future.result
[16:21:27.805] }
[16:21:27.825]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.807] assign_globals() ...
[16:21:27.825]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.807] List of 3
[16:21:27.807]  $ nested_a:List of 1
[16:21:27.807]   ..$ b:function (..., envir = parent.frame())  
[16:21:27.807]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:21:27.807]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:21:27.807]  $ a       : int 1
[16:21:27.807]  $ plan_a  :List of 1
[16:21:27.807]   ..$ b:function (..., envir = parent.frame())  
[16:21:27.807]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:21:27.807]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:21:27.807]  - attr(*, "where")=List of 3
[16:21:27.807]   ..$ nested_a:<environment: R_EmptyEnv> 
[16:21:27.807]   ..$ a       :<environment: R_EmptyEnv> 
[16:21:27.807]   ..$ plan_a  :<environment: R_EmptyEnv> 
[16:21:27.807]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:27.807]  - attr(*, "resolved")= logi FALSE
[16:21:27.807]  - attr(*, "total_size")= num 23080
[16:21:27.807]  - attr(*, "already-done")= logi TRUE
[16:21:27.825]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.813] - copied ‘nested_a’ to environment
[16:21:27.825]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.813] - copied ‘a’ to environment
[16:21:27.825]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.813] - copied ‘plan_a’ to environment
[16:21:27.825]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.813] assign_globals() ... done
[16:21:27.826]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.813] plan(): Setting new future strategy stack:
[16:21:27.826]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.813] List of future strategies:
[16:21:27.813] 1. sequential:
[16:21:27.813]    - args: function (..., envir = parent.frame())
[16:21:27.813]    - tweaked: FALSE
[16:21:27.813]    - call: NULL
[16:21:27.826]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.814] plan(): nbrOfWorkers() = 1
[16:21:27.826]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.815] plan(): Setting new future strategy stack:
[16:21:27.826]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.815] List of future strategies:
[16:21:27.815] 1. sequential:
[16:21:27.815]    - args: function (..., envir = parent.frame())
[16:21:27.815]    - tweaked: FALSE
[16:21:27.815]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:27.826]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.815] plan(): nbrOfWorkers() = 1
[16:21:27.826]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.816] SequentialFuture started (and completed)
[16:21:27.826]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.816] - Launch lazy future ... done
[16:21:27.827]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.816] run() for ‘SequentialFuture’ ... done
[16:21:27.827] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:21:27.831] getGlobalsAndPackages() ...
[16:21:27.832] Searching for globals...
[16:21:27.834] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:21:27.834] Searching for globals ... DONE
[16:21:27.834] Resolving globals: FALSE
[16:21:27.835] The total size of the 1 globals is 128 bytes (128 bytes)
[16:21:27.835] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:21:27.835] - globals: [1] ‘data’
[16:21:27.835] - packages: [1] ‘future’
[16:21:27.835] getGlobalsAndPackages() ... DONE
[16:21:27.835] run() for ‘Future’ ...
[16:21:27.836] - state: ‘created’
[16:21:27.836] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:27.836] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:27.836] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:27.836]   - Field: ‘label’
[16:21:27.836]   - Field: ‘local’
[16:21:27.836]   - Field: ‘owner’
[16:21:27.836]   - Field: ‘envir’
[16:21:27.837]   - Field: ‘packages’
[16:21:27.837]   - Field: ‘gc’
[16:21:27.837]   - Field: ‘conditions’
[16:21:27.837]   - Field: ‘expr’
[16:21:27.837]   - Field: ‘uuid’
[16:21:27.837]   - Field: ‘seed’
[16:21:27.837]   - Field: ‘version’
[16:21:27.837]   - Field: ‘result’
[16:21:27.837]   - Field: ‘asynchronous’
[16:21:27.837]   - Field: ‘calls’
[16:21:27.837]   - Field: ‘globals’
[16:21:27.838]   - Field: ‘stdout’
[16:21:27.838]   - Field: ‘earlySignal’
[16:21:27.838]   - Field: ‘lazy’
[16:21:27.838]   - Field: ‘state’
[16:21:27.838] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:27.838] - Launch lazy future ...
[16:21:27.838] Packages needed by the future expression (n = 1): ‘future’
[16:21:27.838] Packages needed by future strategies (n = 1): ‘future’
[16:21:27.839] {
[16:21:27.839]     {
[16:21:27.839]         {
[16:21:27.839]             ...future.startTime <- base::Sys.time()
[16:21:27.839]             {
[16:21:27.839]                 {
[16:21:27.839]                   {
[16:21:27.839]                     {
[16:21:27.839]                       base::local({
[16:21:27.839]                         has_future <- base::requireNamespace("future", 
[16:21:27.839]                           quietly = TRUE)
[16:21:27.839]                         if (has_future) {
[16:21:27.839]                           ns <- base::getNamespace("future")
[16:21:27.839]                           version <- ns[[".package"]][["version"]]
[16:21:27.839]                           if (is.null(version)) 
[16:21:27.839]                             version <- utils::packageVersion("future")
[16:21:27.839]                         }
[16:21:27.839]                         else {
[16:21:27.839]                           version <- NULL
[16:21:27.839]                         }
[16:21:27.839]                         if (!has_future || version < "1.8.0") {
[16:21:27.839]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:27.839]                             "", base::R.version$version.string), 
[16:21:27.839]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:27.839]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:27.839]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:27.839]                               "release", "version")], collapse = " "), 
[16:21:27.839]                             hostname = base::Sys.info()[["nodename"]])
[16:21:27.839]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:27.839]                             info)
[16:21:27.839]                           info <- base::paste(info, collapse = "; ")
[16:21:27.839]                           if (!has_future) {
[16:21:27.839]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:27.839]                               info)
[16:21:27.839]                           }
[16:21:27.839]                           else {
[16:21:27.839]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:27.839]                               info, version)
[16:21:27.839]                           }
[16:21:27.839]                           base::stop(msg)
[16:21:27.839]                         }
[16:21:27.839]                       })
[16:21:27.839]                     }
[16:21:27.839]                     base::local({
[16:21:27.839]                       for (pkg in "future") {
[16:21:27.839]                         base::loadNamespace(pkg)
[16:21:27.839]                         base::library(pkg, character.only = TRUE)
[16:21:27.839]                       }
[16:21:27.839]                     })
[16:21:27.839]                   }
[16:21:27.839]                   ...future.strategy.old <- future::plan("list")
[16:21:27.839]                   options(future.plan = NULL)
[16:21:27.839]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:27.839]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:21:27.839]                   {
[16:21:27.839]                     future <- SequentialFuture(..., envir = envir)
[16:21:27.839]                     if (!future$lazy) 
[16:21:27.839]                       future <- run(future)
[16:21:27.839]                     invisible(future)
[16:21:27.839]                   }), .cleanup = FALSE, .init = FALSE)
[16:21:27.839]                 }
[16:21:27.839]                 ...future.workdir <- getwd()
[16:21:27.839]             }
[16:21:27.839]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:27.839]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:27.839]         }
[16:21:27.839]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:27.839]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:27.839]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:27.839]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:27.839]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:27.839]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:27.839]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:27.839]             base::names(...future.oldOptions))
[16:21:27.839]     }
[16:21:27.839]     if (FALSE) {
[16:21:27.839]     }
[16:21:27.839]     else {
[16:21:27.839]         if (TRUE) {
[16:21:27.839]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:27.839]                 open = "w")
[16:21:27.839]         }
[16:21:27.839]         else {
[16:21:27.839]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:27.839]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:27.839]         }
[16:21:27.839]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:27.839]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:27.839]             base::sink(type = "output", split = FALSE)
[16:21:27.839]             base::close(...future.stdout)
[16:21:27.839]         }, add = TRUE)
[16:21:27.839]     }
[16:21:27.839]     ...future.frame <- base::sys.nframe()
[16:21:27.839]     ...future.conditions <- base::list()
[16:21:27.839]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:27.839]     if (FALSE) {
[16:21:27.839]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:27.839]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:27.839]     }
[16:21:27.839]     ...future.result <- base::tryCatch({
[16:21:27.839]         base::withCallingHandlers({
[16:21:27.839]             ...future.value <- base::withVisible(base::local({
[16:21:27.839]                 value(future(subset(data, a == 2)))
[16:21:27.839]             }))
[16:21:27.839]             future::FutureResult(value = ...future.value$value, 
[16:21:27.839]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:27.839]                   ...future.rng), globalenv = if (FALSE) 
[16:21:27.839]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:27.839]                     ...future.globalenv.names))
[16:21:27.839]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:27.839]         }, condition = base::local({
[16:21:27.839]             c <- base::c
[16:21:27.839]             inherits <- base::inherits
[16:21:27.839]             invokeRestart <- base::invokeRestart
[16:21:27.839]             length <- base::length
[16:21:27.839]             list <- base::list
[16:21:27.839]             seq.int <- base::seq.int
[16:21:27.839]             signalCondition <- base::signalCondition
[16:21:27.839]             sys.calls <- base::sys.calls
[16:21:27.839]             `[[` <- base::`[[`
[16:21:27.839]             `+` <- base::`+`
[16:21:27.839]             `<<-` <- base::`<<-`
[16:21:27.839]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:27.839]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:27.839]                   3L)]
[16:21:27.839]             }
[16:21:27.839]             function(cond) {
[16:21:27.839]                 is_error <- inherits(cond, "error")
[16:21:27.839]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:27.839]                   NULL)
[16:21:27.839]                 if (is_error) {
[16:21:27.839]                   sessionInformation <- function() {
[16:21:27.839]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:27.839]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:27.839]                       search = base::search(), system = base::Sys.info())
[16:21:27.839]                   }
[16:21:27.839]                   ...future.conditions[[length(...future.conditions) + 
[16:21:27.839]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:27.839]                     cond$call), session = sessionInformation(), 
[16:21:27.839]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:27.839]                   signalCondition(cond)
[16:21:27.839]                 }
[16:21:27.839]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:27.839]                 "immediateCondition"))) {
[16:21:27.839]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:27.839]                   ...future.conditions[[length(...future.conditions) + 
[16:21:27.839]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:27.839]                   if (TRUE && !signal) {
[16:21:27.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:27.839]                     {
[16:21:27.839]                       inherits <- base::inherits
[16:21:27.839]                       invokeRestart <- base::invokeRestart
[16:21:27.839]                       is.null <- base::is.null
[16:21:27.839]                       muffled <- FALSE
[16:21:27.839]                       if (inherits(cond, "message")) {
[16:21:27.839]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:27.839]                         if (muffled) 
[16:21:27.839]                           invokeRestart("muffleMessage")
[16:21:27.839]                       }
[16:21:27.839]                       else if (inherits(cond, "warning")) {
[16:21:27.839]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:27.839]                         if (muffled) 
[16:21:27.839]                           invokeRestart("muffleWarning")
[16:21:27.839]                       }
[16:21:27.839]                       else if (inherits(cond, "condition")) {
[16:21:27.839]                         if (!is.null(pattern)) {
[16:21:27.839]                           computeRestarts <- base::computeRestarts
[16:21:27.839]                           grepl <- base::grepl
[16:21:27.839]                           restarts <- computeRestarts(cond)
[16:21:27.839]                           for (restart in restarts) {
[16:21:27.839]                             name <- restart$name
[16:21:27.839]                             if (is.null(name)) 
[16:21:27.839]                               next
[16:21:27.839]                             if (!grepl(pattern, name)) 
[16:21:27.839]                               next
[16:21:27.839]                             invokeRestart(restart)
[16:21:27.839]                             muffled <- TRUE
[16:21:27.839]                             break
[16:21:27.839]                           }
[16:21:27.839]                         }
[16:21:27.839]                       }
[16:21:27.839]                       invisible(muffled)
[16:21:27.839]                     }
[16:21:27.839]                     muffleCondition(cond, pattern = "^muffle")
[16:21:27.839]                   }
[16:21:27.839]                 }
[16:21:27.839]                 else {
[16:21:27.839]                   if (TRUE) {
[16:21:27.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:27.839]                     {
[16:21:27.839]                       inherits <- base::inherits
[16:21:27.839]                       invokeRestart <- base::invokeRestart
[16:21:27.839]                       is.null <- base::is.null
[16:21:27.839]                       muffled <- FALSE
[16:21:27.839]                       if (inherits(cond, "message")) {
[16:21:27.839]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:27.839]                         if (muffled) 
[16:21:27.839]                           invokeRestart("muffleMessage")
[16:21:27.839]                       }
[16:21:27.839]                       else if (inherits(cond, "warning")) {
[16:21:27.839]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:27.839]                         if (muffled) 
[16:21:27.839]                           invokeRestart("muffleWarning")
[16:21:27.839]                       }
[16:21:27.839]                       else if (inherits(cond, "condition")) {
[16:21:27.839]                         if (!is.null(pattern)) {
[16:21:27.839]                           computeRestarts <- base::computeRestarts
[16:21:27.839]                           grepl <- base::grepl
[16:21:27.839]                           restarts <- computeRestarts(cond)
[16:21:27.839]                           for (restart in restarts) {
[16:21:27.839]                             name <- restart$name
[16:21:27.839]                             if (is.null(name)) 
[16:21:27.839]                               next
[16:21:27.839]                             if (!grepl(pattern, name)) 
[16:21:27.839]                               next
[16:21:27.839]                             invokeRestart(restart)
[16:21:27.839]                             muffled <- TRUE
[16:21:27.839]                             break
[16:21:27.839]                           }
[16:21:27.839]                         }
[16:21:27.839]                       }
[16:21:27.839]                       invisible(muffled)
[16:21:27.839]                     }
[16:21:27.839]                     muffleCondition(cond, pattern = "^muffle")
[16:21:27.839]                   }
[16:21:27.839]                 }
[16:21:27.839]             }
[16:21:27.839]         }))
[16:21:27.839]     }, error = function(ex) {
[16:21:27.839]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:27.839]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:27.839]                 ...future.rng), started = ...future.startTime, 
[16:21:27.839]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:27.839]             version = "1.8"), class = "FutureResult")
[16:21:27.839]     }, finally = {
[16:21:27.839]         if (!identical(...future.workdir, getwd())) 
[16:21:27.839]             setwd(...future.workdir)
[16:21:27.839]         {
[16:21:27.839]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:27.839]                 ...future.oldOptions$nwarnings <- NULL
[16:21:27.839]             }
[16:21:27.839]             base::options(...future.oldOptions)
[16:21:27.839]             if (.Platform$OS.type == "windows") {
[16:21:27.839]                 old_names <- names(...future.oldEnvVars)
[16:21:27.839]                 envs <- base::Sys.getenv()
[16:21:27.839]                 names <- names(envs)
[16:21:27.839]                 common <- intersect(names, old_names)
[16:21:27.839]                 added <- setdiff(names, old_names)
[16:21:27.839]                 removed <- setdiff(old_names, names)
[16:21:27.839]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:27.839]                   envs[common]]
[16:21:27.839]                 NAMES <- toupper(changed)
[16:21:27.839]                 args <- list()
[16:21:27.839]                 for (kk in seq_along(NAMES)) {
[16:21:27.839]                   name <- changed[[kk]]
[16:21:27.839]                   NAME <- NAMES[[kk]]
[16:21:27.839]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:27.839]                     next
[16:21:27.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:27.839]                 }
[16:21:27.839]                 NAMES <- toupper(added)
[16:21:27.839]                 for (kk in seq_along(NAMES)) {
[16:21:27.839]                   name <- added[[kk]]
[16:21:27.839]                   NAME <- NAMES[[kk]]
[16:21:27.839]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:27.839]                     next
[16:21:27.839]                   args[[name]] <- ""
[16:21:27.839]                 }
[16:21:27.839]                 NAMES <- toupper(removed)
[16:21:27.839]                 for (kk in seq_along(NAMES)) {
[16:21:27.839]                   name <- removed[[kk]]
[16:21:27.839]                   NAME <- NAMES[[kk]]
[16:21:27.839]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:27.839]                     next
[16:21:27.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:27.839]                 }
[16:21:27.839]                 if (length(args) > 0) 
[16:21:27.839]                   base::do.call(base::Sys.setenv, args = args)
[16:21:27.839]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:27.839]             }
[16:21:27.839]             else {
[16:21:27.839]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:27.839]             }
[16:21:27.839]             {
[16:21:27.839]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:27.839]                   0L) {
[16:21:27.839]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:27.839]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:27.839]                   base::options(opts)
[16:21:27.839]                 }
[16:21:27.839]                 {
[16:21:27.839]                   {
[16:21:27.839]                     NULL
[16:21:27.839]                     RNGkind("Mersenne-Twister")
[16:21:27.839]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:27.839]                       inherits = FALSE)
[16:21:27.839]                   }
[16:21:27.839]                   options(future.plan = NULL)
[16:21:27.839]                   if (is.na(NA_character_)) 
[16:21:27.839]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:27.839]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:27.839]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:27.839]                     .init = FALSE)
[16:21:27.839]                 }
[16:21:27.839]             }
[16:21:27.839]         }
[16:21:27.839]     })
[16:21:27.839]     if (TRUE) {
[16:21:27.839]         base::sink(type = "output", split = FALSE)
[16:21:27.839]         if (TRUE) {
[16:21:27.839]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:27.839]         }
[16:21:27.839]         else {
[16:21:27.839]             ...future.result["stdout"] <- base::list(NULL)
[16:21:27.839]         }
[16:21:27.839]         base::close(...future.stdout)
[16:21:27.839]         ...future.stdout <- NULL
[16:21:27.839]     }
[16:21:27.839]     ...future.result$conditions <- ...future.conditions
[16:21:27.839]     ...future.result$finished <- base::Sys.time()
[16:21:27.839]     ...future.result
[16:21:27.839] }
[16:21:27.840] assign_globals() ...
[16:21:27.840] List of 1
[16:21:27.840]  $ data:'data.frame':	3 obs. of  2 variables:
[16:21:27.840]   ..$ a: int [1:3] 1 2 3
[16:21:27.840]   ..$ b: int [1:3] 3 2 1
[16:21:27.840]  - attr(*, "where")=List of 1
[16:21:27.840]   ..$ data:<environment: R_EmptyEnv> 
[16:21:27.840]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:27.840]  - attr(*, "resolved")= logi FALSE
[16:21:27.840]  - attr(*, "total_size")= num 128
[16:21:27.840]  - attr(*, "already-done")= logi TRUE
[16:21:27.843] - copied ‘data’ to environment
[16:21:27.844] assign_globals() ... done
[16:21:27.844] plan(): Setting new future strategy stack:
[16:21:27.844] List of future strategies:
[16:21:27.844] 1. sequential:
[16:21:27.844]    - args: function (..., envir = parent.frame())
[16:21:27.844]    - tweaked: FALSE
[16:21:27.844]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:27.844] plan(): nbrOfWorkers() = 1
[16:21:27.871] plan(): Setting new future strategy stack:
[16:21:27.871] List of future strategies:
[16:21:27.871] 1. sequential:
[16:21:27.871]    - args: function (..., envir = parent.frame())
[16:21:27.871]    - tweaked: FALSE
[16:21:27.871]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:27.871] 2. sequential:
[16:21:27.871]    - args: function (..., envir = parent.frame())
[16:21:27.871]    - tweaked: FALSE
[16:21:27.871]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:27.871] plan(): nbrOfWorkers() = 1
[16:21:27.871] SequentialFuture started (and completed)
[16:21:27.872] signalConditions() ...
[16:21:27.872]  - include = ‘immediateCondition’
[16:21:27.872]  - exclude = 
[16:21:27.872]  - resignal = FALSE
[16:21:27.872]  - Number of conditions: 52
[16:21:27.872] signalConditions() ... done
[16:21:27.872] - Launch lazy future ... done
[16:21:27.872] run() for ‘SequentialFuture’ ... done
[16:21:27.872] signalConditions() ...
[16:21:27.872]  - include = ‘immediateCondition’
[16:21:27.873]  - exclude = 
[16:21:27.873]  - resignal = FALSE
[16:21:27.873]  - Number of conditions: 52
[16:21:27.873] signalConditions() ... done
[16:21:27.873] Future state: ‘finished’
[16:21:27.873] signalConditions() ...
[16:21:27.873]  - include = ‘condition’
[16:21:27.873]  - exclude = ‘immediateCondition’
[16:21:27.873]  - resignal = TRUE
[16:21:27.873]  - Number of conditions: 52
[16:21:27.873]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.845] getGlobalsAndPackages() ...
[16:21:27.874]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.845] Searching for globals...
[16:21:27.874]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.858] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[16:21:27.874]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.858] Searching for globals ... DONE
[16:21:27.874]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.859] Resolving globals: FALSE
[16:21:27.874]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.859] The total size of the 1 globals is 128 bytes (128 bytes)
[16:21:27.874]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.859] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:21:27.875]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.859] - globals: [1] ‘data’
[16:21:27.875]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.860] 
[16:21:27.875]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.860] getGlobalsAndPackages() ... DONE
[16:21:27.876]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.860] run() for ‘Future’ ...
[16:21:27.876]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.860] - state: ‘created’
[16:21:27.876]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.860] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:27.876]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.860] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:27.876]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.861] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:27.876]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.861]   - Field: ‘label’
[16:21:27.876]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.861]   - Field: ‘local’
[16:21:27.877]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.861]   - Field: ‘owner’
[16:21:27.877]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.861]   - Field: ‘envir’
[16:21:27.877]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.861]   - Field: ‘packages’
[16:21:27.877]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.861]   - Field: ‘gc’
[16:21:27.877]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.861]   - Field: ‘conditions’
[16:21:27.877]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.861]   - Field: ‘expr’
[16:21:27.877]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.861]   - Field: ‘uuid’
[16:21:27.877]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.862]   - Field: ‘seed’
[16:21:27.878]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.862]   - Field: ‘version’
[16:21:27.878]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.862]   - Field: ‘result’
[16:21:27.878]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.862]   - Field: ‘asynchronous’
[16:21:27.878]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.862]   - Field: ‘calls’
[16:21:27.878]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.862]   - Field: ‘globals’
[16:21:27.878]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.862]   - Field: ‘stdout’
[16:21:27.878]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.862]   - Field: ‘earlySignal’
[16:21:27.878]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.862]   - Field: ‘lazy’
[16:21:27.879]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.862]   - Field: ‘state’
[16:21:27.879]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.863] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:27.879]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.863] - Launch lazy future ...
[16:21:27.879]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.863] Packages needed by the future expression (n = 0): <none>
[16:21:27.879]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.863] Packages needed by future strategies (n = 0): <none>
[16:21:27.879]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.863] {
[16:21:27.863]     {
[16:21:27.863]         {
[16:21:27.863]             ...future.startTime <- base::Sys.time()
[16:21:27.863]             {
[16:21:27.863]                 {
[16:21:27.863]                   {
[16:21:27.863]                     base::local({
[16:21:27.863]                       has_future <- base::requireNamespace("future", 
[16:21:27.863]                         quietly = TRUE)
[16:21:27.863]                       if (has_future) {
[16:21:27.863]                         ns <- base::getNamespace("future")
[16:21:27.863]                         version <- ns[[".package"]][["version"]]
[16:21:27.863]                         if (is.null(version)) 
[16:21:27.863]                           version <- utils::packageVersion("future")
[16:21:27.863]                       }
[16:21:27.863]                       else {
[16:21:27.863]                         version <- NULL
[16:21:27.863]                       }
[16:21:27.863]                       if (!has_future || version < "1.8.0") {
[16:21:27.863]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:27.863]                           "", base::R.version$version.string), 
[16:21:27.863]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:27.863]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:27.863]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:27.863]                             "release", "version")], collapse = " "), 
[16:21:27.863]                           hostname = base::Sys.info()[["nodename"]])
[16:21:27.863]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:27.863]                           info)
[16:21:27.863]                         info <- base::paste(info, collapse = "; ")
[16:21:27.863]                         if (!has_future) {
[16:21:27.863]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:27.863]                             info)
[16:21:27.863]                         }
[16:21:27.863]                         else {
[16:21:27.863]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:27.863]                             info, version)
[16:21:27.863]                         }
[16:21:27.863]                         base::stop(msg)
[16:21:27.863]                       }
[16:21:27.863]                     })
[16:21:27.863]                   }
[16:21:27.863]                   ...future.strategy.old <- future::plan("list")
[16:21:27.863]                   options(future.plan = NULL)
[16:21:27.863]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:27.863]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:27.863]                 }
[16:21:27.863]                 ...future.workdir <- getwd()
[16:21:27.863]             }
[16:21:27.863]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:27.863]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:27.863]         }
[16:21:27.863]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:27.863]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:27.863]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:27.863]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:27.863]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:27.863]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:27.863]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:27.863]             base::names(...future.oldOptions))
[16:21:27.863]     }
[16:21:27.863]     if (FALSE) {
[16:21:27.863]     }
[16:21:27.863]     else {
[16:21:27.863]         if (TRUE) {
[16:21:27.863]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:27.863]                 open = "w")
[16:21:27.863]         }
[16:21:27.863]         else {
[16:21:27.863]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:27.863]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:27.863]         }
[16:21:27.863]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:27.863]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:27.863]             base::sink(type = "output", split = FALSE)
[16:21:27.863]             base::close(...future.stdout)
[16:21:27.863]         }, add = TRUE)
[16:21:27.863]     }
[16:21:27.863]     ...future.frame <- base::sys.nframe()
[16:21:27.863]     ...future.conditions <- base::list()
[16:21:27.863]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:27.863]     if (FALSE) {
[16:21:27.863]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:27.863]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:27.863]     }
[16:21:27.863]     ...future.result <- base::tryCatch({
[16:21:27.863]         base::withCallingHandlers({
[16:21:27.863]             ...future.value <- base::withVisible(base::local(subset(data, 
[16:21:27.863]                 a == 2)))
[16:21:27.863]             future::FutureResult(value = ...future.value$value, 
[16:21:27.863]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:27.863]                   ...future.rng), globalenv = if (FALSE) 
[16:21:27.863]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:27.863]                     ...future.globalenv.names))
[16:21:27.863]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:27.863]         }, condition = base::local({
[16:21:27.863]             c <- base::c
[16:21:27.863]             inherits <- base::inherits
[16:21:27.863]             invokeRestart <- base::invokeRestart
[16:21:27.863]             length <- base::length
[16:21:27.863]             list <- base::list
[16:21:27.863]             seq.int <- base::seq.int
[16:21:27.863]             signalCondition <- base::signalCondition
[16:21:27.863]             sys.calls <- base::sys.calls
[16:21:27.863]             `[[` <- base::`[[`
[16:21:27.863]             `+` <- base::`+`
[16:21:27.863]             `<<-` <- base::`<<-`
[16:21:27.863]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:27.863]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:27.863]                   3L)]
[16:21:27.863]             }
[16:21:27.863]             function(cond) {
[16:21:27.863]                 is_error <- inherits(cond, "error")
[16:21:27.863]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:27.863]                   NULL)
[16:21:27.863]                 if (is_error) {
[16:21:27.863]                   sessionInformation <- function() {
[16:21:27.863]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:27.863]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:27.863]                       search = base::search(), system = base::Sys.info())
[16:21:27.863]                   }
[16:21:27.863]                   ...future.conditions[[length(...future.conditions) + 
[16:21:27.863]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:27.863]                     cond$call), session = sessionInformation(), 
[16:21:27.863]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:27.863]                   signalCondition(cond)
[16:21:27.863]                 }
[16:21:27.863]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:27.863]                 "immediateCondition"))) {
[16:21:27.863]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:27.863]                   ...future.conditions[[length(...future.conditions) + 
[16:21:27.863]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:27.863]                   if (TRUE && !signal) {
[16:21:27.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:27.863]                     {
[16:21:27.863]                       inherits <- base::inherits
[16:21:27.863]                       invokeRestart <- base::invokeRestart
[16:21:27.863]                       is.null <- base::is.null
[16:21:27.863]                       muffled <- FALSE
[16:21:27.863]                       if (inherits(cond, "message")) {
[16:21:27.863]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:27.863]                         if (muffled) 
[16:21:27.863]                           invokeRestart("muffleMessage")
[16:21:27.863]                       }
[16:21:27.863]                       else if (inherits(cond, "warning")) {
[16:21:27.863]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:27.863]                         if (muffled) 
[16:21:27.863]                           invokeRestart("muffleWarning")
[16:21:27.863]                       }
[16:21:27.863]                       else if (inherits(cond, "condition")) {
[16:21:27.863]                         if (!is.null(pattern)) {
[16:21:27.863]                           computeRestarts <- base::computeRestarts
[16:21:27.863]                           grepl <- base::grepl
[16:21:27.863]                           restarts <- computeRestarts(cond)
[16:21:27.863]                           for (restart in restarts) {
[16:21:27.863]                             name <- restart$name
[16:21:27.863]                             if (is.null(name)) 
[16:21:27.863]                               next
[16:21:27.863]                             if (!grepl(pattern, name)) 
[16:21:27.863]                               next
[16:21:27.863]                             invokeRestart(restart)
[16:21:27.863]                             muffled <- TRUE
[16:21:27.863]                             break
[16:21:27.863]                           }
[16:21:27.863]                         }
[16:21:27.863]                       }
[16:21:27.863]                       invisible(muffled)
[16:21:27.863]                     }
[16:21:27.863]                     muffleCondition(cond, pattern = "^muffle")
[16:21:27.863]                   }
[16:21:27.863]                 }
[16:21:27.863]                 else {
[16:21:27.863]                   if (TRUE) {
[16:21:27.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:27.863]                     {
[16:21:27.863]                       inherits <- base::inherits
[16:21:27.863]                       invokeRestart <- base::invokeRestart
[16:21:27.863]                       is.null <- base::is.null
[16:21:27.863]                       muffled <- FALSE
[16:21:27.863]                       if (inherits(cond, "message")) {
[16:21:27.863]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:27.863]                         if (muffled) 
[16:21:27.863]                           invokeRestart("muffleMessage")
[16:21:27.863]                       }
[16:21:27.863]                       else if (inherits(cond, "warning")) {
[16:21:27.863]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:27.863]                         if (muffled) 
[16:21:27.863]                           invokeRestart("muffleWarning")
[16:21:27.863]                       }
[16:21:27.863]                       else if (inherits(cond, "condition")) {
[16:21:27.863]                         if (!is.null(pattern)) {
[16:21:27.863]                           computeRestarts <- base::computeRestarts
[16:21:27.863]                           grepl <- base::grepl
[16:21:27.863]                           restarts <- computeRestarts(cond)
[16:21:27.863]                           for (restart in restarts) {
[16:21:27.863]                             name <- restart$name
[16:21:27.863]                             if (is.null(name)) 
[16:21:27.863]                               next
[16:21:27.863]                             if (!grepl(pattern, name)) 
[16:21:27.863]                               next
[16:21:27.863]                             invokeRestart(restart)
[16:21:27.863]                             muffled <- TRUE
[16:21:27.863]                             break
[16:21:27.863]                           }
[16:21:27.863]                         }
[16:21:27.863]                       }
[16:21:27.863]                       invisible(muffled)
[16:21:27.863]                     }
[16:21:27.863]                     muffleCondition(cond, pattern = "^muffle")
[16:21:27.863]                   }
[16:21:27.863]                 }
[16:21:27.863]             }
[16:21:27.863]         }))
[16:21:27.863]     }, error = function(ex) {
[16:21:27.863]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:27.863]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:27.863]                 ...future.rng), started = ...future.startTime, 
[16:21:27.863]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:27.863]             version = "1.8"), class = "FutureResult")
[16:21:27.863]     }, finally = {
[16:21:27.863]         if (!identical(...future.workdir, getwd())) 
[16:21:27.863]             setwd(...future.workdir)
[16:21:27.863]         {
[16:21:27.863]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:27.863]                 ...future.oldOptions$nwarnings <- NULL
[16:21:27.863]             }
[16:21:27.863]             base::options(...future.oldOptions)
[16:21:27.863]             if (.Platform$OS.type == "windows") {
[16:21:27.863]                 old_names <- names(...future.oldEnvVars)
[16:21:27.863]                 envs <- base::Sys.getenv()
[16:21:27.863]                 names <- names(envs)
[16:21:27.863]                 common <- intersect(names, old_names)
[16:21:27.863]                 added <- setdiff(names, old_names)
[16:21:27.863]                 removed <- setdiff(old_names, names)
[16:21:27.863]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:27.863]                   envs[common]]
[16:21:27.863]                 NAMES <- toupper(changed)
[16:21:27.863]                 args <- list()
[16:21:27.863]                 for (kk in seq_along(NAMES)) {
[16:21:27.863]                   name <- changed[[kk]]
[16:21:27.863]                   NAME <- NAMES[[kk]]
[16:21:27.863]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:27.863]                     next
[16:21:27.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:27.863]                 }
[16:21:27.863]                 NAMES <- toupper(added)
[16:21:27.863]                 for (kk in seq_along(NAMES)) {
[16:21:27.863]                   name <- added[[kk]]
[16:21:27.863]                   NAME <- NAMES[[kk]]
[16:21:27.863]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:27.863]                     next
[16:21:27.863]                   args[[name]] <- ""
[16:21:27.863]                 }
[16:21:27.863]                 NAMES <- toupper(removed)
[16:21:27.863]                 for (kk in seq_along(NAMES)) {
[16:21:27.863]                   name <- removed[[kk]]
[16:21:27.863]                   NAME <- NAMES[[kk]]
[16:21:27.863]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:27.863]                     next
[16:21:27.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:27.863]                 }
[16:21:27.863]                 if (length(args) > 0) 
[16:21:27.863]                   base::do.call(base::Sys.setenv, args = args)
[16:21:27.863]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:27.863]             }
[16:21:27.863]             else {
[16:21:27.863]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:27.863]             }
[16:21:27.863]             {
[16:21:27.863]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:27.863]                   0L) {
[16:21:27.863]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:27.863]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:27.863]                   base::options(opts)
[16:21:27.863]                 }
[16:21:27.863]                 {
[16:21:27.863]                   {
[16:21:27.863]                     NULL
[16:21:27.863]                     RNGkind("Mersenne-Twister")
[16:21:27.863]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:27.863]                       inherits = FALSE)
[16:21:27.863]                   }
[16:21:27.863]                   options(future.plan = NULL)
[16:21:27.863]                   if (is.na(NA_character_)) 
[16:21:27.863]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:27.863]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:27.863]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:27.863]                     .init = FALSE)
[16:21:27.863]                 }
[16:21:27.863]             }
[16:21:27.863]         }
[16:21:27.863]     })
[16:21:27.863]     if (TRUE) {
[16:21:27.863]         base::sink(type = "output", split = FALSE)
[16:21:27.863]         if (TRUE) {
[16:21:27.863]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:27.863]         }
[16:21:27.863]         else {
[16:21:27.863]             ...future.result["stdout"] <- base::list(NULL)
[16:21:27.863]         }
[16:21:27.863]         base::close(...future.stdout)
[16:21:27.863]         ...future.stdout <- NULL
[16:21:27.863]     }
[16:21:27.863]     ...future.result$conditions <- ...future.conditions
[16:21:27.863]     ...future.result$finished <- base::Sys.time()
[16:21:27.863]     ...future.result
[16:21:27.863] }
[16:21:27.879]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.865] assign_globals() ...
[16:21:27.879]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.865] List of 1
[16:21:27.865]  $ data:'data.frame':	3 obs. of  2 variables:
[16:21:27.865]   ..$ a: int [1:3] 1 2 3
[16:21:27.865]   ..$ b: int [1:3] 3 2 1
[16:21:27.865]  - attr(*, "where")=List of 1
[16:21:27.865]   ..$ data:<environment: R_EmptyEnv> 
[16:21:27.865]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:27.865]  - attr(*, "resolved")= logi FALSE
[16:21:27.865]  - attr(*, "total_size")= num 128
[16:21:27.865]  - attr(*, "already-done")= logi TRUE
[16:21:27.880]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.868] - copied ‘data’ to environment
[16:21:27.880]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.868] assign_globals() ... done
[16:21:27.880]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.868] plan(): Setting new future strategy stack:
[16:21:27.880]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.868] List of future strategies:
[16:21:27.868] 1. sequential:
[16:21:27.868]    - args: function (..., envir = parent.frame())
[16:21:27.868]    - tweaked: FALSE
[16:21:27.868]    - call: NULL
[16:21:27.880]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.869] plan(): nbrOfWorkers() = 1
[16:21:27.880]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.869] plan(): Setting new future strategy stack:
[16:21:27.880]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.870] List of future strategies:
[16:21:27.870] 1. sequential:
[16:21:27.870]    - args: function (..., envir = parent.frame())
[16:21:27.870]    - tweaked: FALSE
[16:21:27.870]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:27.881]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.870] plan(): nbrOfWorkers() = 1
[16:21:27.881]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.870] SequentialFuture started (and completed)
[16:21:27.881]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.870] - Launch lazy future ... done
[16:21:27.881]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.870] run() for ‘SequentialFuture’ ... done
[16:21:27.881] signalConditions() ... done
- plan(list('sequential', 'sequential')) ... DONE
- plan(list('sequential', 'multicore')) ...
[16:21:27.881] plan(): Setting new future strategy stack:
[16:21:27.882] List of future strategies:
[16:21:27.882] 1. sequential:
[16:21:27.882]    - args: function (..., envir = parent.frame())
[16:21:27.882]    - tweaked: FALSE
[16:21:27.882]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:27.882] 2. multicore:
[16:21:27.882]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:27.882]    - tweaked: FALSE
[16:21:27.882]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:27.882] plan(): nbrOfWorkers() = 1
[16:21:27.882] getGlobalsAndPackages() ...
[16:21:27.882] Searching for globals...
[16:21:27.898] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:21:27.898] Searching for globals ... DONE
[16:21:27.898] Resolving globals: FALSE
[16:21:27.899] The total size of the 2 globals is 57.84 KiB (59224 bytes)
[16:21:27.900] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 57.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (57.72 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:21:27.900] - globals: [2] ‘nested’, ‘strategy2’
[16:21:27.900] - packages: [1] ‘future’
[16:21:27.900] getGlobalsAndPackages() ... DONE
[16:21:27.900] run() for ‘Future’ ...
[16:21:27.901] - state: ‘created’
[16:21:27.901] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:27.901] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:27.901] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:27.901]   - Field: ‘label’
[16:21:27.901]   - Field: ‘local’
[16:21:27.901]   - Field: ‘owner’
[16:21:27.901]   - Field: ‘envir’
[16:21:27.901]   - Field: ‘packages’
[16:21:27.902]   - Field: ‘gc’
[16:21:27.902]   - Field: ‘conditions’
[16:21:27.902]   - Field: ‘expr’
[16:21:27.902]   - Field: ‘uuid’
[16:21:27.902]   - Field: ‘seed’
[16:21:27.902]   - Field: ‘version’
[16:21:27.902]   - Field: ‘result’
[16:21:27.902]   - Field: ‘asynchronous’
[16:21:27.902]   - Field: ‘calls’
[16:21:27.902]   - Field: ‘globals’
[16:21:27.902]   - Field: ‘stdout’
[16:21:27.903]   - Field: ‘earlySignal’
[16:21:27.903]   - Field: ‘lazy’
[16:21:27.903]   - Field: ‘state’
[16:21:27.903] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:27.903] - Launch lazy future ...
[16:21:27.903] Packages needed by the future expression (n = 1): ‘future’
[16:21:27.903] Packages needed by future strategies (n = 1): ‘future’
[16:21:27.904] {
[16:21:27.904]     {
[16:21:27.904]         {
[16:21:27.904]             ...future.startTime <- base::Sys.time()
[16:21:27.904]             {
[16:21:27.904]                 {
[16:21:27.904]                   {
[16:21:27.904]                     {
[16:21:27.904]                       base::local({
[16:21:27.904]                         has_future <- base::requireNamespace("future", 
[16:21:27.904]                           quietly = TRUE)
[16:21:27.904]                         if (has_future) {
[16:21:27.904]                           ns <- base::getNamespace("future")
[16:21:27.904]                           version <- ns[[".package"]][["version"]]
[16:21:27.904]                           if (is.null(version)) 
[16:21:27.904]                             version <- utils::packageVersion("future")
[16:21:27.904]                         }
[16:21:27.904]                         else {
[16:21:27.904]                           version <- NULL
[16:21:27.904]                         }
[16:21:27.904]                         if (!has_future || version < "1.8.0") {
[16:21:27.904]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:27.904]                             "", base::R.version$version.string), 
[16:21:27.904]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:27.904]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:27.904]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:27.904]                               "release", "version")], collapse = " "), 
[16:21:27.904]                             hostname = base::Sys.info()[["nodename"]])
[16:21:27.904]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:27.904]                             info)
[16:21:27.904]                           info <- base::paste(info, collapse = "; ")
[16:21:27.904]                           if (!has_future) {
[16:21:27.904]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:27.904]                               info)
[16:21:27.904]                           }
[16:21:27.904]                           else {
[16:21:27.904]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:27.904]                               info, version)
[16:21:27.904]                           }
[16:21:27.904]                           base::stop(msg)
[16:21:27.904]                         }
[16:21:27.904]                       })
[16:21:27.904]                     }
[16:21:27.904]                     base::local({
[16:21:27.904]                       for (pkg in "future") {
[16:21:27.904]                         base::loadNamespace(pkg)
[16:21:27.904]                         base::library(pkg, character.only = TRUE)
[16:21:27.904]                       }
[16:21:27.904]                     })
[16:21:27.904]                   }
[16:21:27.904]                   ...future.strategy.old <- future::plan("list")
[16:21:27.904]                   options(future.plan = NULL)
[16:21:27.904]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:27.904]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:21:27.904]                     envir = parent.frame()) 
[16:21:27.904]                   {
[16:21:27.904]                     default_workers <- missing(workers)
[16:21:27.904]                     if (is.function(workers)) 
[16:21:27.904]                       workers <- workers()
[16:21:27.904]                     workers <- structure(as.integer(workers), 
[16:21:27.904]                       class = class(workers))
[16:21:27.904]                     stop_if_not(is.finite(workers), workers >= 
[16:21:27.904]                       1L)
[16:21:27.904]                     if ((workers == 1L && !inherits(workers, 
[16:21:27.904]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:21:27.904]                       if (default_workers) 
[16:21:27.904]                         supportsMulticore(warn = TRUE)
[16:21:27.904]                       return(sequential(..., envir = envir))
[16:21:27.904]                     }
[16:21:27.904]                     oopts <- options(mc.cores = workers)
[16:21:27.904]                     on.exit(options(oopts))
[16:21:27.904]                     future <- MulticoreFuture(..., workers = workers, 
[16:21:27.904]                       envir = envir)
[16:21:27.904]                     if (!future$lazy) 
[16:21:27.904]                       future <- run(future)
[16:21:27.904]                     invisible(future)
[16:21:27.904]                   }), .cleanup = FALSE, .init = FALSE)
[16:21:27.904]                 }
[16:21:27.904]                 ...future.workdir <- getwd()
[16:21:27.904]             }
[16:21:27.904]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:27.904]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:27.904]         }
[16:21:27.904]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:27.904]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:27.904]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:27.904]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:27.904]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:27.904]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:27.904]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:27.904]             base::names(...future.oldOptions))
[16:21:27.904]     }
[16:21:27.904]     if (FALSE) {
[16:21:27.904]     }
[16:21:27.904]     else {
[16:21:27.904]         if (TRUE) {
[16:21:27.904]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:27.904]                 open = "w")
[16:21:27.904]         }
[16:21:27.904]         else {
[16:21:27.904]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:27.904]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:27.904]         }
[16:21:27.904]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:27.904]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:27.904]             base::sink(type = "output", split = FALSE)
[16:21:27.904]             base::close(...future.stdout)
[16:21:27.904]         }, add = TRUE)
[16:21:27.904]     }
[16:21:27.904]     ...future.frame <- base::sys.nframe()
[16:21:27.904]     ...future.conditions <- base::list()
[16:21:27.904]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:27.904]     if (FALSE) {
[16:21:27.904]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:27.904]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:27.904]     }
[16:21:27.904]     ...future.result <- base::tryCatch({
[16:21:27.904]         base::withCallingHandlers({
[16:21:27.904]             ...future.value <- base::withVisible(base::local({
[16:21:27.904]                 a <- 1L
[16:21:27.904]                 plan_a <- unclass(future::plan("list"))
[16:21:27.904]                 nested_a <- nested[-1]
[16:21:27.904]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:21:27.904]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:21:27.904]                   strategy2))
[16:21:27.904]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:21:27.904]                   "init") <- NULL
[16:21:27.904]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:21:27.904]                   "init") <- NULL
[16:21:27.904]                 stopifnot(all.equal(plan_a, nested_a))
[16:21:27.904]                 y %<-% {
[16:21:27.904]                   b <- 2L
[16:21:27.904]                   plan_b <- future::plan("list")
[16:21:27.904]                   nested_b <- nested_a[-1]
[16:21:27.904]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:21:27.904]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:21:27.904]                     "sequential"))
[16:21:27.904]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:21:27.904]                     b = b, nested_b = nested_b, plan_b = plan_b)
[16:21:27.904]                 }
[16:21:27.904]                 y
[16:21:27.904]             }))
[16:21:27.904]             future::FutureResult(value = ...future.value$value, 
[16:21:27.904]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:27.904]                   ...future.rng), globalenv = if (FALSE) 
[16:21:27.904]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:27.904]                     ...future.globalenv.names))
[16:21:27.904]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:27.904]         }, condition = base::local({
[16:21:27.904]             c <- base::c
[16:21:27.904]             inherits <- base::inherits
[16:21:27.904]             invokeRestart <- base::invokeRestart
[16:21:27.904]             length <- base::length
[16:21:27.904]             list <- base::list
[16:21:27.904]             seq.int <- base::seq.int
[16:21:27.904]             signalCondition <- base::signalCondition
[16:21:27.904]             sys.calls <- base::sys.calls
[16:21:27.904]             `[[` <- base::`[[`
[16:21:27.904]             `+` <- base::`+`
[16:21:27.904]             `<<-` <- base::`<<-`
[16:21:27.904]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:27.904]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:27.904]                   3L)]
[16:21:27.904]             }
[16:21:27.904]             function(cond) {
[16:21:27.904]                 is_error <- inherits(cond, "error")
[16:21:27.904]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:27.904]                   NULL)
[16:21:27.904]                 if (is_error) {
[16:21:27.904]                   sessionInformation <- function() {
[16:21:27.904]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:27.904]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:27.904]                       search = base::search(), system = base::Sys.info())
[16:21:27.904]                   }
[16:21:27.904]                   ...future.conditions[[length(...future.conditions) + 
[16:21:27.904]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:27.904]                     cond$call), session = sessionInformation(), 
[16:21:27.904]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:27.904]                   signalCondition(cond)
[16:21:27.904]                 }
[16:21:27.904]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:27.904]                 "immediateCondition"))) {
[16:21:27.904]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:27.904]                   ...future.conditions[[length(...future.conditions) + 
[16:21:27.904]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:27.904]                   if (TRUE && !signal) {
[16:21:27.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:27.904]                     {
[16:21:27.904]                       inherits <- base::inherits
[16:21:27.904]                       invokeRestart <- base::invokeRestart
[16:21:27.904]                       is.null <- base::is.null
[16:21:27.904]                       muffled <- FALSE
[16:21:27.904]                       if (inherits(cond, "message")) {
[16:21:27.904]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:27.904]                         if (muffled) 
[16:21:27.904]                           invokeRestart("muffleMessage")
[16:21:27.904]                       }
[16:21:27.904]                       else if (inherits(cond, "warning")) {
[16:21:27.904]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:27.904]                         if (muffled) 
[16:21:27.904]                           invokeRestart("muffleWarning")
[16:21:27.904]                       }
[16:21:27.904]                       else if (inherits(cond, "condition")) {
[16:21:27.904]                         if (!is.null(pattern)) {
[16:21:27.904]                           computeRestarts <- base::computeRestarts
[16:21:27.904]                           grepl <- base::grepl
[16:21:27.904]                           restarts <- computeRestarts(cond)
[16:21:27.904]                           for (restart in restarts) {
[16:21:27.904]                             name <- restart$name
[16:21:27.904]                             if (is.null(name)) 
[16:21:27.904]                               next
[16:21:27.904]                             if (!grepl(pattern, name)) 
[16:21:27.904]                               next
[16:21:27.904]                             invokeRestart(restart)
[16:21:27.904]                             muffled <- TRUE
[16:21:27.904]                             break
[16:21:27.904]                           }
[16:21:27.904]                         }
[16:21:27.904]                       }
[16:21:27.904]                       invisible(muffled)
[16:21:27.904]                     }
[16:21:27.904]                     muffleCondition(cond, pattern = "^muffle")
[16:21:27.904]                   }
[16:21:27.904]                 }
[16:21:27.904]                 else {
[16:21:27.904]                   if (TRUE) {
[16:21:27.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:27.904]                     {
[16:21:27.904]                       inherits <- base::inherits
[16:21:27.904]                       invokeRestart <- base::invokeRestart
[16:21:27.904]                       is.null <- base::is.null
[16:21:27.904]                       muffled <- FALSE
[16:21:27.904]                       if (inherits(cond, "message")) {
[16:21:27.904]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:27.904]                         if (muffled) 
[16:21:27.904]                           invokeRestart("muffleMessage")
[16:21:27.904]                       }
[16:21:27.904]                       else if (inherits(cond, "warning")) {
[16:21:27.904]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:27.904]                         if (muffled) 
[16:21:27.904]                           invokeRestart("muffleWarning")
[16:21:27.904]                       }
[16:21:27.904]                       else if (inherits(cond, "condition")) {
[16:21:27.904]                         if (!is.null(pattern)) {
[16:21:27.904]                           computeRestarts <- base::computeRestarts
[16:21:27.904]                           grepl <- base::grepl
[16:21:27.904]                           restarts <- computeRestarts(cond)
[16:21:27.904]                           for (restart in restarts) {
[16:21:27.904]                             name <- restart$name
[16:21:27.904]                             if (is.null(name)) 
[16:21:27.904]                               next
[16:21:27.904]                             if (!grepl(pattern, name)) 
[16:21:27.904]                               next
[16:21:27.904]                             invokeRestart(restart)
[16:21:27.904]                             muffled <- TRUE
[16:21:27.904]                             break
[16:21:27.904]                           }
[16:21:27.904]                         }
[16:21:27.904]                       }
[16:21:27.904]                       invisible(muffled)
[16:21:27.904]                     }
[16:21:27.904]                     muffleCondition(cond, pattern = "^muffle")
[16:21:27.904]                   }
[16:21:27.904]                 }
[16:21:27.904]             }
[16:21:27.904]         }))
[16:21:27.904]     }, error = function(ex) {
[16:21:27.904]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:27.904]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:27.904]                 ...future.rng), started = ...future.startTime, 
[16:21:27.904]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:27.904]             version = "1.8"), class = "FutureResult")
[16:21:27.904]     }, finally = {
[16:21:27.904]         if (!identical(...future.workdir, getwd())) 
[16:21:27.904]             setwd(...future.workdir)
[16:21:27.904]         {
[16:21:27.904]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:27.904]                 ...future.oldOptions$nwarnings <- NULL
[16:21:27.904]             }
[16:21:27.904]             base::options(...future.oldOptions)
[16:21:27.904]             if (.Platform$OS.type == "windows") {
[16:21:27.904]                 old_names <- names(...future.oldEnvVars)
[16:21:27.904]                 envs <- base::Sys.getenv()
[16:21:27.904]                 names <- names(envs)
[16:21:27.904]                 common <- intersect(names, old_names)
[16:21:27.904]                 added <- setdiff(names, old_names)
[16:21:27.904]                 removed <- setdiff(old_names, names)
[16:21:27.904]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:27.904]                   envs[common]]
[16:21:27.904]                 NAMES <- toupper(changed)
[16:21:27.904]                 args <- list()
[16:21:27.904]                 for (kk in seq_along(NAMES)) {
[16:21:27.904]                   name <- changed[[kk]]
[16:21:27.904]                   NAME <- NAMES[[kk]]
[16:21:27.904]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:27.904]                     next
[16:21:27.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:27.904]                 }
[16:21:27.904]                 NAMES <- toupper(added)
[16:21:27.904]                 for (kk in seq_along(NAMES)) {
[16:21:27.904]                   name <- added[[kk]]
[16:21:27.904]                   NAME <- NAMES[[kk]]
[16:21:27.904]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:27.904]                     next
[16:21:27.904]                   args[[name]] <- ""
[16:21:27.904]                 }
[16:21:27.904]                 NAMES <- toupper(removed)
[16:21:27.904]                 for (kk in seq_along(NAMES)) {
[16:21:27.904]                   name <- removed[[kk]]
[16:21:27.904]                   NAME <- NAMES[[kk]]
[16:21:27.904]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:27.904]                     next
[16:21:27.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:27.904]                 }
[16:21:27.904]                 if (length(args) > 0) 
[16:21:27.904]                   base::do.call(base::Sys.setenv, args = args)
[16:21:27.904]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:27.904]             }
[16:21:27.904]             else {
[16:21:27.904]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:27.904]             }
[16:21:27.904]             {
[16:21:27.904]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:27.904]                   0L) {
[16:21:27.904]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:27.904]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:27.904]                   base::options(opts)
[16:21:27.904]                 }
[16:21:27.904]                 {
[16:21:27.904]                   {
[16:21:27.904]                     NULL
[16:21:27.904]                     RNGkind("Mersenne-Twister")
[16:21:27.904]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:27.904]                       inherits = FALSE)
[16:21:27.904]                   }
[16:21:27.904]                   options(future.plan = NULL)
[16:21:27.904]                   if (is.na(NA_character_)) 
[16:21:27.904]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:27.904]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:27.904]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:27.904]                     .init = FALSE)
[16:21:27.904]                 }
[16:21:27.904]             }
[16:21:27.904]         }
[16:21:27.904]     })
[16:21:27.904]     if (TRUE) {
[16:21:27.904]         base::sink(type = "output", split = FALSE)
[16:21:27.904]         if (TRUE) {
[16:21:27.904]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:27.904]         }
[16:21:27.904]         else {
[16:21:27.904]             ...future.result["stdout"] <- base::list(NULL)
[16:21:27.904]         }
[16:21:27.904]         base::close(...future.stdout)
[16:21:27.904]         ...future.stdout <- NULL
[16:21:27.904]     }
[16:21:27.904]     ...future.result$conditions <- ...future.conditions
[16:21:27.904]     ...future.result$finished <- base::Sys.time()
[16:21:27.904]     ...future.result
[16:21:27.904] }
[16:21:27.906] assign_globals() ...
[16:21:27.906] List of 2
[16:21:27.906]  $ nested   :List of 2
[16:21:27.906]   ..$ a:function (..., envir = parent.frame())  
[16:21:27.906]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:21:27.906]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:21:27.906]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:21:27.906]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:21:27.906]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:21:27.906]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:21:27.906]  $ strategy2: chr "multicore"
[16:21:27.906]  - attr(*, "where")=List of 2
[16:21:27.906]   ..$ nested   :<environment: R_EmptyEnv> 
[16:21:27.906]   ..$ strategy2:<environment: R_EmptyEnv> 
[16:21:27.906]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:27.906]  - attr(*, "resolved")= logi FALSE
[16:21:27.906]  - attr(*, "total_size")= num 59224
[16:21:27.906]  - attr(*, "already-done")= logi TRUE
[16:21:27.910] - copied ‘nested’ to environment
[16:21:27.910] - copied ‘strategy2’ to environment
[16:21:27.910] assign_globals() ... done
[16:21:27.911] plan(): Setting new future strategy stack:
[16:21:27.911] List of future strategies:
[16:21:27.911] 1. multicore:
[16:21:27.911]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:27.911]    - tweaked: FALSE
[16:21:27.911]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:27.916] plan(): nbrOfWorkers() = 2
[16:21:27.974] plan(): Setting new future strategy stack:
[16:21:27.975] List of future strategies:
[16:21:27.975] 1. sequential:
[16:21:27.975]    - args: function (..., envir = parent.frame())
[16:21:27.975]    - tweaked: FALSE
[16:21:27.975]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:27.975] 2. multicore:
[16:21:27.975]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:27.975]    - tweaked: FALSE
[16:21:27.975]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:27.975] plan(): nbrOfWorkers() = 1
[16:21:27.976] SequentialFuture started (and completed)
[16:21:27.976] signalConditions() ...
[16:21:27.976]  - include = ‘immediateCondition’
[16:21:27.976]  - exclude = 
[16:21:27.976]  - resignal = FALSE
[16:21:27.976]  - Number of conditions: 57
[16:21:27.977] signalConditions() ... done
[16:21:27.977] - Launch lazy future ... done
[16:21:27.977] run() for ‘SequentialFuture’ ... done
[16:21:27.977] signalConditions() ...
[16:21:27.977]  - include = ‘immediateCondition’
[16:21:27.977]  - exclude = 
[16:21:27.977]  - resignal = FALSE
[16:21:27.978]  - Number of conditions: 57
[16:21:27.978] signalConditions() ... done
[16:21:27.978] Future state: ‘finished’
[16:21:27.978] signalConditions() ...
[16:21:27.978]  - include = ‘condition’
[16:21:27.978]  - exclude = ‘immediateCondition’
[16:21:27.978]  - resignal = TRUE
[16:21:27.978]  - Number of conditions: 57
[16:21:27.979]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.917] getGlobalsAndPackages() ...
[16:21:27.979]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.917] Searching for globals...
[16:21:27.979]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.936] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[16:21:27.979]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.936] Searching for globals ... DONE
[16:21:27.979]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.936] Resolving globals: FALSE
[16:21:27.979]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.937] The total size of the 3 globals is 93.01 KiB (95240 bytes)
[16:21:27.980]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.937] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 93.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (46.48 KiB of class ‘list’), ‘plan_a’ (46.48 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[16:21:27.980]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.938] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[16:21:27.980]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.938] 
[16:21:27.980]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.938] getGlobalsAndPackages() ... DONE
[16:21:27.980]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.938] run() for ‘Future’ ...
[16:21:27.980]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.938] - state: ‘created’
[16:21:27.981]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.938] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:27.981]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.942] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:27.981]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.942] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:27.981]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.942]   - Field: ‘label’
[16:21:27.981]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.942]   - Field: ‘local’
[16:21:27.981]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.943]   - Field: ‘owner’
[16:21:27.981]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.943]   - Field: ‘envir’
[16:21:27.982]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.943]   - Field: ‘workers’
[16:21:27.982]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.943]   - Field: ‘packages’
[16:21:27.982]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.943]   - Field: ‘gc’
[16:21:27.982]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.943]   - Field: ‘job’
[16:21:27.982]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.943]   - Field: ‘conditions’
[16:21:27.982]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.943]   - Field: ‘expr’
[16:21:27.983]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.943]   - Field: ‘uuid’
[16:21:27.983]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.943]   - Field: ‘seed’
[16:21:27.983]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.944]   - Field: ‘version’
[16:21:27.983]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.944]   - Field: ‘result’
[16:21:27.983]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.944]   - Field: ‘asynchronous’
[16:21:27.983]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.944]   - Field: ‘calls’
[16:21:27.983]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.944]   - Field: ‘globals’
[16:21:27.984]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.944]   - Field: ‘stdout’
[16:21:27.984]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.944]   - Field: ‘earlySignal’
[16:21:27.984]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.944]   - Field: ‘lazy’
[16:21:27.984]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.944]   - Field: ‘state’
[16:21:27.984]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.945] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:27.984]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.945] - Launch lazy future ...
[16:21:27.985]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.946] Packages needed by the future expression (n = 0): <none>
[16:21:27.985]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.946] Packages needed by future strategies (n = 0): <none>
[16:21:27.985]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.946] {
[16:21:27.946]     {
[16:21:27.946]         {
[16:21:27.946]             ...future.startTime <- base::Sys.time()
[16:21:27.946]             {
[16:21:27.946]                 {
[16:21:27.946]                   {
[16:21:27.946]                     {
[16:21:27.946]                       base::local({
[16:21:27.946]                         has_future <- base::requireNamespace("future", 
[16:21:27.946]                           quietly = TRUE)
[16:21:27.946]                         if (has_future) {
[16:21:27.946]                           ns <- base::getNamespace("future")
[16:21:27.946]                           version <- ns[[".package"]][["version"]]
[16:21:27.946]                           if (is.null(version)) 
[16:21:27.946]                             version <- utils::packageVersion("future")
[16:21:27.946]                         }
[16:21:27.946]                         else {
[16:21:27.946]                           version <- NULL
[16:21:27.946]                         }
[16:21:27.946]                         if (!has_future || version < "1.8.0") {
[16:21:27.946]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:27.946]                             "", base::R.version$version.string), 
[16:21:27.946]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:27.946]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:27.946]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:27.946]                               "release", "version")], collapse = " "), 
[16:21:27.946]                             hostname = base::Sys.info()[["nodename"]])
[16:21:27.946]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:27.946]                             info)
[16:21:27.946]                           info <- base::paste(info, collapse = "; ")
[16:21:27.946]                           if (!has_future) {
[16:21:27.946]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:27.946]                               info)
[16:21:27.946]                           }
[16:21:27.946]                           else {
[16:21:27.946]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:27.946]                               info, version)
[16:21:27.946]                           }
[16:21:27.946]                           base::stop(msg)
[16:21:27.946]                         }
[16:21:27.946]                       })
[16:21:27.946]                     }
[16:21:27.946]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:27.946]                     base::options(mc.cores = 1L)
[16:21:27.946]                   }
[16:21:27.946]                   ...future.strategy.old <- future::plan("list")
[16:21:27.946]                   options(future.plan = NULL)
[16:21:27.946]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:27.946]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:27.946]                 }
[16:21:27.946]                 ...future.workdir <- getwd()
[16:21:27.946]             }
[16:21:27.946]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:27.946]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:27.946]         }
[16:21:27.946]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:27.946]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:27.946]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:27.946]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:27.946]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:27.946]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:27.946]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:27.946]             base::names(...future.oldOptions))
[16:21:27.946]     }
[16:21:27.946]     if (FALSE) {
[16:21:27.946]     }
[16:21:27.946]     else {
[16:21:27.946]         if (TRUE) {
[16:21:27.946]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:27.946]                 open = "w")
[16:21:27.946]         }
[16:21:27.946]         else {
[16:21:27.946]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:27.946]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:27.946]         }
[16:21:27.946]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:27.946]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:27.946]             base::sink(type = "output", split = FALSE)
[16:21:27.946]             base::close(...future.stdout)
[16:21:27.946]         }, add = TRUE)
[16:21:27.946]     }
[16:21:27.946]     ...future.frame <- base::sys.nframe()
[16:21:27.946]     ...future.conditions <- base::list()
[16:21:27.946]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:27.946]     if (FALSE) {
[16:21:27.946]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:27.946]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:27.946]     }
[16:21:27.946]     ...future.result <- base::tryCatch({
[16:21:27.946]         base::withCallingHandlers({
[16:21:27.946]             ...future.value <- base::withVisible(base::local({
[16:21:27.946]                 withCallingHandlers({
[16:21:27.946]                   {
[16:21:27.946]                     b <- 2L
[16:21:27.946]                     plan_b <- future::plan("list")
[16:21:27.946]                     nested_b <- nested_a[-1]
[16:21:27.946]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:21:27.946]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:21:27.946]                       "sequential"))
[16:21:27.946]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:21:27.946]                       b = b, nested_b = nested_b, plan_b = plan_b)
[16:21:27.946]                   }
[16:21:27.946]                 }, immediateCondition = function(cond) {
[16:21:27.946]                   save_rds <- function (object, pathname, ...) 
[16:21:27.946]                   {
[16:21:27.946]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:27.946]                     if (file_test("-f", pathname_tmp)) {
[16:21:27.946]                       fi_tmp <- file.info(pathname_tmp)
[16:21:27.946]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:27.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:27.946]                         fi_tmp[["mtime"]])
[16:21:27.946]                     }
[16:21:27.946]                     tryCatch({
[16:21:27.946]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:27.946]                     }, error = function(ex) {
[16:21:27.946]                       msg <- conditionMessage(ex)
[16:21:27.946]                       fi_tmp <- file.info(pathname_tmp)
[16:21:27.946]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:27.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:27.946]                         fi_tmp[["mtime"]], msg)
[16:21:27.946]                       ex$message <- msg
[16:21:27.946]                       stop(ex)
[16:21:27.946]                     })
[16:21:27.946]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:27.946]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:27.946]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:27.946]                       fi_tmp <- file.info(pathname_tmp)
[16:21:27.946]                       fi <- file.info(pathname)
[16:21:27.946]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:27.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:27.946]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:27.946]                         fi[["size"]], fi[["mtime"]])
[16:21:27.946]                       stop(msg)
[16:21:27.946]                     }
[16:21:27.946]                     invisible(pathname)
[16:21:27.946]                   }
[16:21:27.946]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:27.946]                     rootPath = tempdir()) 
[16:21:27.946]                   {
[16:21:27.946]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:27.946]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:27.946]                       tmpdir = path, fileext = ".rds")
[16:21:27.946]                     save_rds(obj, file)
[16:21:27.946]                   }
[16:21:27.946]                   saveImmediateCondition(cond, path = "/tmp/RtmpnVB70K/.future/immediateConditions")
[16:21:27.946]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:27.946]                   {
[16:21:27.946]                     inherits <- base::inherits
[16:21:27.946]                     invokeRestart <- base::invokeRestart
[16:21:27.946]                     is.null <- base::is.null
[16:21:27.946]                     muffled <- FALSE
[16:21:27.946]                     if (inherits(cond, "message")) {
[16:21:27.946]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:27.946]                       if (muffled) 
[16:21:27.946]                         invokeRestart("muffleMessage")
[16:21:27.946]                     }
[16:21:27.946]                     else if (inherits(cond, "warning")) {
[16:21:27.946]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:27.946]                       if (muffled) 
[16:21:27.946]                         invokeRestart("muffleWarning")
[16:21:27.946]                     }
[16:21:27.946]                     else if (inherits(cond, "condition")) {
[16:21:27.946]                       if (!is.null(pattern)) {
[16:21:27.946]                         computeRestarts <- base::computeRestarts
[16:21:27.946]                         grepl <- base::grepl
[16:21:27.946]                         restarts <- computeRestarts(cond)
[16:21:27.946]                         for (restart in restarts) {
[16:21:27.946]                           name <- restart$name
[16:21:27.946]                           if (is.null(name)) 
[16:21:27.946]                             next
[16:21:27.946]                           if (!grepl(pattern, name)) 
[16:21:27.946]                             next
[16:21:27.946]                           invokeRestart(restart)
[16:21:27.946]                           muffled <- TRUE
[16:21:27.946]                           break
[16:21:27.946]                         }
[16:21:27.946]                       }
[16:21:27.946]                     }
[16:21:27.946]                     invisible(muffled)
[16:21:27.946]                   }
[16:21:27.946]                   muffleCondition(cond)
[16:21:27.946]                 })
[16:21:27.946]             }))
[16:21:27.946]             future::FutureResult(value = ...future.value$value, 
[16:21:27.946]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:27.946]                   ...future.rng), globalenv = if (FALSE) 
[16:21:27.946]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:27.946]                     ...future.globalenv.names))
[16:21:27.946]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:27.946]         }, condition = base::local({
[16:21:27.946]             c <- base::c
[16:21:27.946]             inherits <- base::inherits
[16:21:27.946]             invokeRestart <- base::invokeRestart
[16:21:27.946]             length <- base::length
[16:21:27.946]             list <- base::list
[16:21:27.946]             seq.int <- base::seq.int
[16:21:27.946]             signalCondition <- base::signalCondition
[16:21:27.946]             sys.calls <- base::sys.calls
[16:21:27.946]             `[[` <- base::`[[`
[16:21:27.946]             `+` <- base::`+`
[16:21:27.946]             `<<-` <- base::`<<-`
[16:21:27.946]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:27.946]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:27.946]                   3L)]
[16:21:27.946]             }
[16:21:27.946]             function(cond) {
[16:21:27.946]                 is_error <- inherits(cond, "error")
[16:21:27.946]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:27.946]                   NULL)
[16:21:27.946]                 if (is_error) {
[16:21:27.946]                   sessionInformation <- function() {
[16:21:27.946]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:27.946]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:27.946]                       search = base::search(), system = base::Sys.info())
[16:21:27.946]                   }
[16:21:27.946]                   ...future.conditions[[length(...future.conditions) + 
[16:21:27.946]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:27.946]                     cond$call), session = sessionInformation(), 
[16:21:27.946]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:27.946]                   signalCondition(cond)
[16:21:27.946]                 }
[16:21:27.946]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:27.946]                 "immediateCondition"))) {
[16:21:27.946]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:27.946]                   ...future.conditions[[length(...future.conditions) + 
[16:21:27.946]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:27.946]                   if (TRUE && !signal) {
[16:21:27.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:27.946]                     {
[16:21:27.946]                       inherits <- base::inherits
[16:21:27.946]                       invokeRestart <- base::invokeRestart
[16:21:27.946]                       is.null <- base::is.null
[16:21:27.946]                       muffled <- FALSE
[16:21:27.946]                       if (inherits(cond, "message")) {
[16:21:27.946]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:27.946]                         if (muffled) 
[16:21:27.946]                           invokeRestart("muffleMessage")
[16:21:27.946]                       }
[16:21:27.946]                       else if (inherits(cond, "warning")) {
[16:21:27.946]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:27.946]                         if (muffled) 
[16:21:27.946]                           invokeRestart("muffleWarning")
[16:21:27.946]                       }
[16:21:27.946]                       else if (inherits(cond, "condition")) {
[16:21:27.946]                         if (!is.null(pattern)) {
[16:21:27.946]                           computeRestarts <- base::computeRestarts
[16:21:27.946]                           grepl <- base::grepl
[16:21:27.946]                           restarts <- computeRestarts(cond)
[16:21:27.946]                           for (restart in restarts) {
[16:21:27.946]                             name <- restart$name
[16:21:27.946]                             if (is.null(name)) 
[16:21:27.946]                               next
[16:21:27.946]                             if (!grepl(pattern, name)) 
[16:21:27.946]                               next
[16:21:27.946]                             invokeRestart(restart)
[16:21:27.946]                             muffled <- TRUE
[16:21:27.946]                             break
[16:21:27.946]                           }
[16:21:27.946]                         }
[16:21:27.946]                       }
[16:21:27.946]                       invisible(muffled)
[16:21:27.946]                     }
[16:21:27.946]                     muffleCondition(cond, pattern = "^muffle")
[16:21:27.946]                   }
[16:21:27.946]                 }
[16:21:27.946]                 else {
[16:21:27.946]                   if (TRUE) {
[16:21:27.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:27.946]                     {
[16:21:27.946]                       inherits <- base::inherits
[16:21:27.946]                       invokeRestart <- base::invokeRestart
[16:21:27.946]                       is.null <- base::is.null
[16:21:27.946]                       muffled <- FALSE
[16:21:27.946]                       if (inherits(cond, "message")) {
[16:21:27.946]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:27.946]                         if (muffled) 
[16:21:27.946]                           invokeRestart("muffleMessage")
[16:21:27.946]                       }
[16:21:27.946]                       else if (inherits(cond, "warning")) {
[16:21:27.946]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:27.946]                         if (muffled) 
[16:21:27.946]                           invokeRestart("muffleWarning")
[16:21:27.946]                       }
[16:21:27.946]                       else if (inherits(cond, "condition")) {
[16:21:27.946]                         if (!is.null(pattern)) {
[16:21:27.946]                           computeRestarts <- base::computeRestarts
[16:21:27.946]                           grepl <- base::grepl
[16:21:27.946]                           restarts <- computeRestarts(cond)
[16:21:27.946]                           for (restart in restarts) {
[16:21:27.946]                             name <- restart$name
[16:21:27.946]                             if (is.null(name)) 
[16:21:27.946]                               next
[16:21:27.946]                             if (!grepl(pattern, name)) 
[16:21:27.946]                               next
[16:21:27.946]                             invokeRestart(restart)
[16:21:27.946]                             muffled <- TRUE
[16:21:27.946]                             break
[16:21:27.946]                           }
[16:21:27.946]                         }
[16:21:27.946]                       }
[16:21:27.946]                       invisible(muffled)
[16:21:27.946]                     }
[16:21:27.946]                     muffleCondition(cond, pattern = "^muffle")
[16:21:27.946]                   }
[16:21:27.946]                 }
[16:21:27.946]             }
[16:21:27.946]         }))
[16:21:27.946]     }, error = function(ex) {
[16:21:27.946]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:27.946]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:27.946]                 ...future.rng), started = ...future.startTime, 
[16:21:27.946]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:27.946]             version = "1.8"), class = "FutureResult")
[16:21:27.946]     }, finally = {
[16:21:27.946]         if (!identical(...future.workdir, getwd())) 
[16:21:27.946]             setwd(...future.workdir)
[16:21:27.946]         {
[16:21:27.946]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:27.946]                 ...future.oldOptions$nwarnings <- NULL
[16:21:27.946]             }
[16:21:27.946]             base::options(...future.oldOptions)
[16:21:27.946]             if (.Platform$OS.type == "windows") {
[16:21:27.946]                 old_names <- names(...future.oldEnvVars)
[16:21:27.946]                 envs <- base::Sys.getenv()
[16:21:27.946]                 names <- names(envs)
[16:21:27.946]                 common <- intersect(names, old_names)
[16:21:27.946]                 added <- setdiff(names, old_names)
[16:21:27.946]                 removed <- setdiff(old_names, names)
[16:21:27.946]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:27.946]                   envs[common]]
[16:21:27.946]                 NAMES <- toupper(changed)
[16:21:27.946]                 args <- list()
[16:21:27.946]                 for (kk in seq_along(NAMES)) {
[16:21:27.946]                   name <- changed[[kk]]
[16:21:27.946]                   NAME <- NAMES[[kk]]
[16:21:27.946]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:27.946]                     next
[16:21:27.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:27.946]                 }
[16:21:27.946]                 NAMES <- toupper(added)
[16:21:27.946]                 for (kk in seq_along(NAMES)) {
[16:21:27.946]                   name <- added[[kk]]
[16:21:27.946]                   NAME <- NAMES[[kk]]
[16:21:27.946]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:27.946]                     next
[16:21:27.946]                   args[[name]] <- ""
[16:21:27.946]                 }
[16:21:27.946]                 NAMES <- toupper(removed)
[16:21:27.946]                 for (kk in seq_along(NAMES)) {
[16:21:27.946]                   name <- removed[[kk]]
[16:21:27.946]                   NAME <- NAMES[[kk]]
[16:21:27.946]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:27.946]                     next
[16:21:27.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:27.946]                 }
[16:21:27.946]                 if (length(args) > 0) 
[16:21:27.946]                   base::do.call(base::Sys.setenv, args = args)
[16:21:27.946]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:27.946]             }
[16:21:27.946]             else {
[16:21:27.946]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:27.946]             }
[16:21:27.946]             {
[16:21:27.946]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:27.946]                   0L) {
[16:21:27.946]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:27.946]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:27.946]                   base::options(opts)
[16:21:27.946]                 }
[16:21:27.946]                 {
[16:21:27.946]                   {
[16:21:27.946]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:27.946]                     NULL
[16:21:27.946]                   }
[16:21:27.946]                   options(future.plan = NULL)
[16:21:27.946]                   if (is.na(NA_character_)) 
[16:21:27.946]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:27.946]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:27.946]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:27.946]                     .init = FALSE)
[16:21:27.946]                 }
[16:21:27.946]             }
[16:21:27.946]         }
[16:21:27.946]     })
[16:21:27.946]     if (TRUE) {
[16:21:27.946]         base::sink(type = "output", split = FALSE)
[16:21:27.946]         if (TRUE) {
[16:21:27.946]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:27.946]         }
[16:21:27.946]         else {
[16:21:27.946]             ...future.result["stdout"] <- base::list(NULL)
[16:21:27.946]         }
[16:21:27.946]         base::close(...future.stdout)
[16:21:27.946]         ...future.stdout <- NULL
[16:21:27.946]     }
[16:21:27.946]     ...future.result$conditions <- ...future.conditions
[16:21:27.946]     ...future.result$finished <- base::Sys.time()
[16:21:27.946]     ...future.result
[16:21:27.946] }
[16:21:27.985]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.948] assign_globals() ...
[16:21:27.985]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.948] List of 3
[16:21:27.948]  $ nested_a:List of 1
[16:21:27.948]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:21:27.948]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:21:27.948]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:21:27.948]  $ a       : int 1
[16:21:27.948]  $ plan_a  :List of 1
[16:21:27.948]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:21:27.948]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:21:27.948]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:21:27.948]  - attr(*, "where")=List of 3
[16:21:27.948]   ..$ nested_a:<environment: R_EmptyEnv> 
[16:21:27.948]   ..$ a       :<environment: R_EmptyEnv> 
[16:21:27.948]   ..$ plan_a  :<environment: R_EmptyEnv> 
[16:21:27.948]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:27.948]  - attr(*, "resolved")= logi FALSE
[16:21:27.948]  - attr(*, "total_size")= num 95240
[16:21:27.948]  - attr(*, "already-done")= logi TRUE
[16:21:27.985]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.953] - copied ‘nested_a’ to environment
[16:21:27.986]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.953] - copied ‘a’ to environment
[16:21:27.986]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.954] - copied ‘plan_a’ to environment
[16:21:27.986]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.954] assign_globals() ... done
[16:21:27.986]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.954] requestCore(): workers = 2
[16:21:27.986]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.957] MulticoreFuture started
[16:21:27.986]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.958] - Launch lazy future ... done
[16:21:27.986]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.958] run() for ‘MulticoreFuture’ ... done
[16:21:27.987]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.959] result() for MulticoreFuture ...
[16:21:27.987]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.970] result() for MulticoreFuture ...
[16:21:27.987]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.971] result() for MulticoreFuture ... done
[16:21:27.987]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.971] result() for MulticoreFuture ... done
[16:21:27.987]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.971] result() for MulticoreFuture ...
[16:21:27.987]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:27.974] result() for MulticoreFuture ... done
[16:21:27.988] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:21:27.993] getGlobalsAndPackages() ...
[16:21:27.993] Searching for globals...
[16:21:27.995] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:21:27.995] Searching for globals ... DONE
[16:21:27.995] Resolving globals: FALSE
[16:21:27.996] The total size of the 1 globals is 128 bytes (128 bytes)
[16:21:27.996] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:21:27.996] - globals: [1] ‘data’
[16:21:27.996] - packages: [1] ‘future’
[16:21:27.996] getGlobalsAndPackages() ... DONE
[16:21:27.997] run() for ‘Future’ ...
[16:21:27.997] - state: ‘created’
[16:21:27.997] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:27.997] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:27.997] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:27.997]   - Field: ‘label’
[16:21:27.997]   - Field: ‘local’
[16:21:27.998]   - Field: ‘owner’
[16:21:27.998]   - Field: ‘envir’
[16:21:27.998]   - Field: ‘packages’
[16:21:27.999]   - Field: ‘gc’
[16:21:27.999]   - Field: ‘conditions’
[16:21:27.999]   - Field: ‘expr’
[16:21:28.000]   - Field: ‘uuid’
[16:21:28.000]   - Field: ‘seed’
[16:21:28.000]   - Field: ‘version’
[16:21:28.000]   - Field: ‘result’
[16:21:28.000]   - Field: ‘asynchronous’
[16:21:28.000]   - Field: ‘calls’
[16:21:28.000]   - Field: ‘globals’
[16:21:28.000]   - Field: ‘stdout’
[16:21:28.000]   - Field: ‘earlySignal’
[16:21:28.000]   - Field: ‘lazy’
[16:21:28.001]   - Field: ‘state’
[16:21:28.001] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:28.001] - Launch lazy future ...
[16:21:28.001] Packages needed by the future expression (n = 1): ‘future’
[16:21:28.001] Packages needed by future strategies (n = 1): ‘future’
[16:21:28.002] {
[16:21:28.002]     {
[16:21:28.002]         {
[16:21:28.002]             ...future.startTime <- base::Sys.time()
[16:21:28.002]             {
[16:21:28.002]                 {
[16:21:28.002]                   {
[16:21:28.002]                     {
[16:21:28.002]                       base::local({
[16:21:28.002]                         has_future <- base::requireNamespace("future", 
[16:21:28.002]                           quietly = TRUE)
[16:21:28.002]                         if (has_future) {
[16:21:28.002]                           ns <- base::getNamespace("future")
[16:21:28.002]                           version <- ns[[".package"]][["version"]]
[16:21:28.002]                           if (is.null(version)) 
[16:21:28.002]                             version <- utils::packageVersion("future")
[16:21:28.002]                         }
[16:21:28.002]                         else {
[16:21:28.002]                           version <- NULL
[16:21:28.002]                         }
[16:21:28.002]                         if (!has_future || version < "1.8.0") {
[16:21:28.002]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:28.002]                             "", base::R.version$version.string), 
[16:21:28.002]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:28.002]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:28.002]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:28.002]                               "release", "version")], collapse = " "), 
[16:21:28.002]                             hostname = base::Sys.info()[["nodename"]])
[16:21:28.002]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:28.002]                             info)
[16:21:28.002]                           info <- base::paste(info, collapse = "; ")
[16:21:28.002]                           if (!has_future) {
[16:21:28.002]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:28.002]                               info)
[16:21:28.002]                           }
[16:21:28.002]                           else {
[16:21:28.002]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:28.002]                               info, version)
[16:21:28.002]                           }
[16:21:28.002]                           base::stop(msg)
[16:21:28.002]                         }
[16:21:28.002]                       })
[16:21:28.002]                     }
[16:21:28.002]                     base::local({
[16:21:28.002]                       for (pkg in "future") {
[16:21:28.002]                         base::loadNamespace(pkg)
[16:21:28.002]                         base::library(pkg, character.only = TRUE)
[16:21:28.002]                       }
[16:21:28.002]                     })
[16:21:28.002]                   }
[16:21:28.002]                   ...future.strategy.old <- future::plan("list")
[16:21:28.002]                   options(future.plan = NULL)
[16:21:28.002]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:28.002]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:21:28.002]                     envir = parent.frame()) 
[16:21:28.002]                   {
[16:21:28.002]                     default_workers <- missing(workers)
[16:21:28.002]                     if (is.function(workers)) 
[16:21:28.002]                       workers <- workers()
[16:21:28.002]                     workers <- structure(as.integer(workers), 
[16:21:28.002]                       class = class(workers))
[16:21:28.002]                     stop_if_not(is.finite(workers), workers >= 
[16:21:28.002]                       1L)
[16:21:28.002]                     if ((workers == 1L && !inherits(workers, 
[16:21:28.002]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:21:28.002]                       if (default_workers) 
[16:21:28.002]                         supportsMulticore(warn = TRUE)
[16:21:28.002]                       return(sequential(..., envir = envir))
[16:21:28.002]                     }
[16:21:28.002]                     oopts <- options(mc.cores = workers)
[16:21:28.002]                     on.exit(options(oopts))
[16:21:28.002]                     future <- MulticoreFuture(..., workers = workers, 
[16:21:28.002]                       envir = envir)
[16:21:28.002]                     if (!future$lazy) 
[16:21:28.002]                       future <- run(future)
[16:21:28.002]                     invisible(future)
[16:21:28.002]                   }), .cleanup = FALSE, .init = FALSE)
[16:21:28.002]                 }
[16:21:28.002]                 ...future.workdir <- getwd()
[16:21:28.002]             }
[16:21:28.002]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:28.002]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:28.002]         }
[16:21:28.002]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:28.002]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:28.002]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:28.002]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:28.002]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:28.002]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:28.002]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:28.002]             base::names(...future.oldOptions))
[16:21:28.002]     }
[16:21:28.002]     if (FALSE) {
[16:21:28.002]     }
[16:21:28.002]     else {
[16:21:28.002]         if (TRUE) {
[16:21:28.002]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:28.002]                 open = "w")
[16:21:28.002]         }
[16:21:28.002]         else {
[16:21:28.002]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:28.002]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:28.002]         }
[16:21:28.002]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:28.002]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:28.002]             base::sink(type = "output", split = FALSE)
[16:21:28.002]             base::close(...future.stdout)
[16:21:28.002]         }, add = TRUE)
[16:21:28.002]     }
[16:21:28.002]     ...future.frame <- base::sys.nframe()
[16:21:28.002]     ...future.conditions <- base::list()
[16:21:28.002]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:28.002]     if (FALSE) {
[16:21:28.002]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:28.002]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:28.002]     }
[16:21:28.002]     ...future.result <- base::tryCatch({
[16:21:28.002]         base::withCallingHandlers({
[16:21:28.002]             ...future.value <- base::withVisible(base::local({
[16:21:28.002]                 value(future(subset(data, a == 2)))
[16:21:28.002]             }))
[16:21:28.002]             future::FutureResult(value = ...future.value$value, 
[16:21:28.002]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:28.002]                   ...future.rng), globalenv = if (FALSE) 
[16:21:28.002]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:28.002]                     ...future.globalenv.names))
[16:21:28.002]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:28.002]         }, condition = base::local({
[16:21:28.002]             c <- base::c
[16:21:28.002]             inherits <- base::inherits
[16:21:28.002]             invokeRestart <- base::invokeRestart
[16:21:28.002]             length <- base::length
[16:21:28.002]             list <- base::list
[16:21:28.002]             seq.int <- base::seq.int
[16:21:28.002]             signalCondition <- base::signalCondition
[16:21:28.002]             sys.calls <- base::sys.calls
[16:21:28.002]             `[[` <- base::`[[`
[16:21:28.002]             `+` <- base::`+`
[16:21:28.002]             `<<-` <- base::`<<-`
[16:21:28.002]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:28.002]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:28.002]                   3L)]
[16:21:28.002]             }
[16:21:28.002]             function(cond) {
[16:21:28.002]                 is_error <- inherits(cond, "error")
[16:21:28.002]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:28.002]                   NULL)
[16:21:28.002]                 if (is_error) {
[16:21:28.002]                   sessionInformation <- function() {
[16:21:28.002]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:28.002]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:28.002]                       search = base::search(), system = base::Sys.info())
[16:21:28.002]                   }
[16:21:28.002]                   ...future.conditions[[length(...future.conditions) + 
[16:21:28.002]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:28.002]                     cond$call), session = sessionInformation(), 
[16:21:28.002]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:28.002]                   signalCondition(cond)
[16:21:28.002]                 }
[16:21:28.002]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:28.002]                 "immediateCondition"))) {
[16:21:28.002]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:28.002]                   ...future.conditions[[length(...future.conditions) + 
[16:21:28.002]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:28.002]                   if (TRUE && !signal) {
[16:21:28.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:28.002]                     {
[16:21:28.002]                       inherits <- base::inherits
[16:21:28.002]                       invokeRestart <- base::invokeRestart
[16:21:28.002]                       is.null <- base::is.null
[16:21:28.002]                       muffled <- FALSE
[16:21:28.002]                       if (inherits(cond, "message")) {
[16:21:28.002]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:28.002]                         if (muffled) 
[16:21:28.002]                           invokeRestart("muffleMessage")
[16:21:28.002]                       }
[16:21:28.002]                       else if (inherits(cond, "warning")) {
[16:21:28.002]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:28.002]                         if (muffled) 
[16:21:28.002]                           invokeRestart("muffleWarning")
[16:21:28.002]                       }
[16:21:28.002]                       else if (inherits(cond, "condition")) {
[16:21:28.002]                         if (!is.null(pattern)) {
[16:21:28.002]                           computeRestarts <- base::computeRestarts
[16:21:28.002]                           grepl <- base::grepl
[16:21:28.002]                           restarts <- computeRestarts(cond)
[16:21:28.002]                           for (restart in restarts) {
[16:21:28.002]                             name <- restart$name
[16:21:28.002]                             if (is.null(name)) 
[16:21:28.002]                               next
[16:21:28.002]                             if (!grepl(pattern, name)) 
[16:21:28.002]                               next
[16:21:28.002]                             invokeRestart(restart)
[16:21:28.002]                             muffled <- TRUE
[16:21:28.002]                             break
[16:21:28.002]                           }
[16:21:28.002]                         }
[16:21:28.002]                       }
[16:21:28.002]                       invisible(muffled)
[16:21:28.002]                     }
[16:21:28.002]                     muffleCondition(cond, pattern = "^muffle")
[16:21:28.002]                   }
[16:21:28.002]                 }
[16:21:28.002]                 else {
[16:21:28.002]                   if (TRUE) {
[16:21:28.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:28.002]                     {
[16:21:28.002]                       inherits <- base::inherits
[16:21:28.002]                       invokeRestart <- base::invokeRestart
[16:21:28.002]                       is.null <- base::is.null
[16:21:28.002]                       muffled <- FALSE
[16:21:28.002]                       if (inherits(cond, "message")) {
[16:21:28.002]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:28.002]                         if (muffled) 
[16:21:28.002]                           invokeRestart("muffleMessage")
[16:21:28.002]                       }
[16:21:28.002]                       else if (inherits(cond, "warning")) {
[16:21:28.002]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:28.002]                         if (muffled) 
[16:21:28.002]                           invokeRestart("muffleWarning")
[16:21:28.002]                       }
[16:21:28.002]                       else if (inherits(cond, "condition")) {
[16:21:28.002]                         if (!is.null(pattern)) {
[16:21:28.002]                           computeRestarts <- base::computeRestarts
[16:21:28.002]                           grepl <- base::grepl
[16:21:28.002]                           restarts <- computeRestarts(cond)
[16:21:28.002]                           for (restart in restarts) {
[16:21:28.002]                             name <- restart$name
[16:21:28.002]                             if (is.null(name)) 
[16:21:28.002]                               next
[16:21:28.002]                             if (!grepl(pattern, name)) 
[16:21:28.002]                               next
[16:21:28.002]                             invokeRestart(restart)
[16:21:28.002]                             muffled <- TRUE
[16:21:28.002]                             break
[16:21:28.002]                           }
[16:21:28.002]                         }
[16:21:28.002]                       }
[16:21:28.002]                       invisible(muffled)
[16:21:28.002]                     }
[16:21:28.002]                     muffleCondition(cond, pattern = "^muffle")
[16:21:28.002]                   }
[16:21:28.002]                 }
[16:21:28.002]             }
[16:21:28.002]         }))
[16:21:28.002]     }, error = function(ex) {
[16:21:28.002]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:28.002]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:28.002]                 ...future.rng), started = ...future.startTime, 
[16:21:28.002]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:28.002]             version = "1.8"), class = "FutureResult")
[16:21:28.002]     }, finally = {
[16:21:28.002]         if (!identical(...future.workdir, getwd())) 
[16:21:28.002]             setwd(...future.workdir)
[16:21:28.002]         {
[16:21:28.002]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:28.002]                 ...future.oldOptions$nwarnings <- NULL
[16:21:28.002]             }
[16:21:28.002]             base::options(...future.oldOptions)
[16:21:28.002]             if (.Platform$OS.type == "windows") {
[16:21:28.002]                 old_names <- names(...future.oldEnvVars)
[16:21:28.002]                 envs <- base::Sys.getenv()
[16:21:28.002]                 names <- names(envs)
[16:21:28.002]                 common <- intersect(names, old_names)
[16:21:28.002]                 added <- setdiff(names, old_names)
[16:21:28.002]                 removed <- setdiff(old_names, names)
[16:21:28.002]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:28.002]                   envs[common]]
[16:21:28.002]                 NAMES <- toupper(changed)
[16:21:28.002]                 args <- list()
[16:21:28.002]                 for (kk in seq_along(NAMES)) {
[16:21:28.002]                   name <- changed[[kk]]
[16:21:28.002]                   NAME <- NAMES[[kk]]
[16:21:28.002]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:28.002]                     next
[16:21:28.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:28.002]                 }
[16:21:28.002]                 NAMES <- toupper(added)
[16:21:28.002]                 for (kk in seq_along(NAMES)) {
[16:21:28.002]                   name <- added[[kk]]
[16:21:28.002]                   NAME <- NAMES[[kk]]
[16:21:28.002]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:28.002]                     next
[16:21:28.002]                   args[[name]] <- ""
[16:21:28.002]                 }
[16:21:28.002]                 NAMES <- toupper(removed)
[16:21:28.002]                 for (kk in seq_along(NAMES)) {
[16:21:28.002]                   name <- removed[[kk]]
[16:21:28.002]                   NAME <- NAMES[[kk]]
[16:21:28.002]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:28.002]                     next
[16:21:28.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:28.002]                 }
[16:21:28.002]                 if (length(args) > 0) 
[16:21:28.002]                   base::do.call(base::Sys.setenv, args = args)
[16:21:28.002]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:28.002]             }
[16:21:28.002]             else {
[16:21:28.002]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:28.002]             }
[16:21:28.002]             {
[16:21:28.002]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:28.002]                   0L) {
[16:21:28.002]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:28.002]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:28.002]                   base::options(opts)
[16:21:28.002]                 }
[16:21:28.002]                 {
[16:21:28.002]                   {
[16:21:28.002]                     NULL
[16:21:28.002]                     RNGkind("Mersenne-Twister")
[16:21:28.002]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:28.002]                       inherits = FALSE)
[16:21:28.002]                   }
[16:21:28.002]                   options(future.plan = NULL)
[16:21:28.002]                   if (is.na(NA_character_)) 
[16:21:28.002]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:28.002]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:28.002]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:28.002]                     .init = FALSE)
[16:21:28.002]                 }
[16:21:28.002]             }
[16:21:28.002]         }
[16:21:28.002]     })
[16:21:28.002]     if (TRUE) {
[16:21:28.002]         base::sink(type = "output", split = FALSE)
[16:21:28.002]         if (TRUE) {
[16:21:28.002]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:28.002]         }
[16:21:28.002]         else {
[16:21:28.002]             ...future.result["stdout"] <- base::list(NULL)
[16:21:28.002]         }
[16:21:28.002]         base::close(...future.stdout)
[16:21:28.002]         ...future.stdout <- NULL
[16:21:28.002]     }
[16:21:28.002]     ...future.result$conditions <- ...future.conditions
[16:21:28.002]     ...future.result$finished <- base::Sys.time()
[16:21:28.002]     ...future.result
[16:21:28.002] }
[16:21:28.003] assign_globals() ...
[16:21:28.003] List of 1
[16:21:28.003]  $ data:'data.frame':	3 obs. of  2 variables:
[16:21:28.003]   ..$ a: int [1:3] 1 2 3
[16:21:28.003]   ..$ b: int [1:3] 3 2 1
[16:21:28.003]  - attr(*, "where")=List of 1
[16:21:28.003]   ..$ data:<environment: R_EmptyEnv> 
[16:21:28.003]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:28.003]  - attr(*, "resolved")= logi FALSE
[16:21:28.003]  - attr(*, "total_size")= num 128
[16:21:28.003]  - attr(*, "already-done")= logi TRUE
[16:21:28.006] - copied ‘data’ to environment
[16:21:28.007] assign_globals() ... done
[16:21:28.007] plan(): Setting new future strategy stack:
[16:21:28.007] List of future strategies:
[16:21:28.007] 1. multicore:
[16:21:28.007]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:28.007]    - tweaked: FALSE
[16:21:28.007]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:28.011] plan(): nbrOfWorkers() = 2
[16:21:28.053] plan(): Setting new future strategy stack:
[16:21:28.054] List of future strategies:
[16:21:28.054] 1. sequential:
[16:21:28.054]    - args: function (..., envir = parent.frame())
[16:21:28.054]    - tweaked: FALSE
[16:21:28.054]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:28.054] 2. multicore:
[16:21:28.054]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:28.054]    - tweaked: FALSE
[16:21:28.054]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:28.054] plan(): nbrOfWorkers() = 1
[16:21:28.054] SequentialFuture started (and completed)
[16:21:28.055] signalConditions() ...
[16:21:28.055]  - include = ‘immediateCondition’
[16:21:28.055]  - exclude = 
[16:21:28.055]  - resignal = FALSE
[16:21:28.055]  - Number of conditions: 55
[16:21:28.055] signalConditions() ... done
[16:21:28.055] - Launch lazy future ... done
[16:21:28.056] run() for ‘SequentialFuture’ ... done
[16:21:28.056] signalConditions() ...
[16:21:28.056]  - include = ‘immediateCondition’
[16:21:28.056]  - exclude = 
[16:21:28.056]  - resignal = FALSE
[16:21:28.056]  - Number of conditions: 55
[16:21:28.059] signalConditions() ... done
[16:21:28.059] Future state: ‘finished’
[16:21:28.059] signalConditions() ...
[16:21:28.059]  - include = ‘condition’
[16:21:28.059]  - exclude = ‘immediateCondition’
[16:21:28.059]  - resignal = TRUE
[16:21:28.060]  - Number of conditions: 55
[16:21:28.060]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.011] getGlobalsAndPackages() ...
[16:21:28.060]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.011] Searching for globals...
[16:21:28.060]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.026] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[16:21:28.060]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.026] Searching for globals ... DONE
[16:21:28.061]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.026] Resolving globals: FALSE
[16:21:28.061]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.026] The total size of the 1 globals is 128 bytes (128 bytes)
[16:21:28.061]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.027] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:21:28.061]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.027] - globals: [1] ‘data’
[16:21:28.061]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.027] 
[16:21:28.062]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.027] getGlobalsAndPackages() ... DONE
[16:21:28.062]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.027] run() for ‘Future’ ...
[16:21:28.062]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.028] - state: ‘created’
[16:21:28.062]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.028] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:28.062]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.031] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:28.062]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.031] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:28.063]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.031]   - Field: ‘label’
[16:21:28.063]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.031]   - Field: ‘local’
[16:21:28.063]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.032]   - Field: ‘owner’
[16:21:28.063]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.032]   - Field: ‘envir’
[16:21:28.063]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.032]   - Field: ‘workers’
[16:21:28.064]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.032]   - Field: ‘packages’
[16:21:28.064]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.032]   - Field: ‘gc’
[16:21:28.064]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.032]   - Field: ‘job’
[16:21:28.064]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.032]   - Field: ‘conditions’
[16:21:28.064]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.032]   - Field: ‘expr’
[16:21:28.064]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.032]   - Field: ‘uuid’
[16:21:28.065]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.033]   - Field: ‘seed’
[16:21:28.065]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.033]   - Field: ‘version’
[16:21:28.065]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.033]   - Field: ‘result’
[16:21:28.065]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.033]   - Field: ‘asynchronous’
[16:21:28.065]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.033]   - Field: ‘calls’
[16:21:28.065]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.033]   - Field: ‘globals’
[16:21:28.066]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.033]   - Field: ‘stdout’
[16:21:28.066]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.033]   - Field: ‘earlySignal’
[16:21:28.066]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.033]   - Field: ‘lazy’
[16:21:28.066]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.033]   - Field: ‘state’
[16:21:28.066]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.034] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:28.066]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.034] - Launch lazy future ...
[16:21:28.067]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.034] Packages needed by the future expression (n = 0): <none>
[16:21:28.067]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.034] Packages needed by future strategies (n = 0): <none>
[16:21:28.067]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.034] {
[16:21:28.034]     {
[16:21:28.034]         {
[16:21:28.034]             ...future.startTime <- base::Sys.time()
[16:21:28.034]             {
[16:21:28.034]                 {
[16:21:28.034]                   {
[16:21:28.034]                     {
[16:21:28.034]                       base::local({
[16:21:28.034]                         has_future <- base::requireNamespace("future", 
[16:21:28.034]                           quietly = TRUE)
[16:21:28.034]                         if (has_future) {
[16:21:28.034]                           ns <- base::getNamespace("future")
[16:21:28.034]                           version <- ns[[".package"]][["version"]]
[16:21:28.034]                           if (is.null(version)) 
[16:21:28.034]                             version <- utils::packageVersion("future")
[16:21:28.034]                         }
[16:21:28.034]                         else {
[16:21:28.034]                           version <- NULL
[16:21:28.034]                         }
[16:21:28.034]                         if (!has_future || version < "1.8.0") {
[16:21:28.034]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:28.034]                             "", base::R.version$version.string), 
[16:21:28.034]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:28.034]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:28.034]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:28.034]                               "release", "version")], collapse = " "), 
[16:21:28.034]                             hostname = base::Sys.info()[["nodename"]])
[16:21:28.034]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:28.034]                             info)
[16:21:28.034]                           info <- base::paste(info, collapse = "; ")
[16:21:28.034]                           if (!has_future) {
[16:21:28.034]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:28.034]                               info)
[16:21:28.034]                           }
[16:21:28.034]                           else {
[16:21:28.034]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:28.034]                               info, version)
[16:21:28.034]                           }
[16:21:28.034]                           base::stop(msg)
[16:21:28.034]                         }
[16:21:28.034]                       })
[16:21:28.034]                     }
[16:21:28.034]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:28.034]                     base::options(mc.cores = 1L)
[16:21:28.034]                   }
[16:21:28.034]                   ...future.strategy.old <- future::plan("list")
[16:21:28.034]                   options(future.plan = NULL)
[16:21:28.034]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:28.034]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:28.034]                 }
[16:21:28.034]                 ...future.workdir <- getwd()
[16:21:28.034]             }
[16:21:28.034]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:28.034]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:28.034]         }
[16:21:28.034]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:28.034]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:28.034]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:28.034]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:28.034]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:28.034]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:28.034]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:28.034]             base::names(...future.oldOptions))
[16:21:28.034]     }
[16:21:28.034]     if (FALSE) {
[16:21:28.034]     }
[16:21:28.034]     else {
[16:21:28.034]         if (TRUE) {
[16:21:28.034]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:28.034]                 open = "w")
[16:21:28.034]         }
[16:21:28.034]         else {
[16:21:28.034]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:28.034]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:28.034]         }
[16:21:28.034]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:28.034]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:28.034]             base::sink(type = "output", split = FALSE)
[16:21:28.034]             base::close(...future.stdout)
[16:21:28.034]         }, add = TRUE)
[16:21:28.034]     }
[16:21:28.034]     ...future.frame <- base::sys.nframe()
[16:21:28.034]     ...future.conditions <- base::list()
[16:21:28.034]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:28.034]     if (FALSE) {
[16:21:28.034]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:28.034]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:28.034]     }
[16:21:28.034]     ...future.result <- base::tryCatch({
[16:21:28.034]         base::withCallingHandlers({
[16:21:28.034]             ...future.value <- base::withVisible(base::local({
[16:21:28.034]                 withCallingHandlers({
[16:21:28.034]                   subset(data, a == 2)
[16:21:28.034]                 }, immediateCondition = function(cond) {
[16:21:28.034]                   save_rds <- function (object, pathname, ...) 
[16:21:28.034]                   {
[16:21:28.034]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:28.034]                     if (file_test("-f", pathname_tmp)) {
[16:21:28.034]                       fi_tmp <- file.info(pathname_tmp)
[16:21:28.034]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:28.034]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:28.034]                         fi_tmp[["mtime"]])
[16:21:28.034]                     }
[16:21:28.034]                     tryCatch({
[16:21:28.034]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:28.034]                     }, error = function(ex) {
[16:21:28.034]                       msg <- conditionMessage(ex)
[16:21:28.034]                       fi_tmp <- file.info(pathname_tmp)
[16:21:28.034]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:28.034]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:28.034]                         fi_tmp[["mtime"]], msg)
[16:21:28.034]                       ex$message <- msg
[16:21:28.034]                       stop(ex)
[16:21:28.034]                     })
[16:21:28.034]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:28.034]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:28.034]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:28.034]                       fi_tmp <- file.info(pathname_tmp)
[16:21:28.034]                       fi <- file.info(pathname)
[16:21:28.034]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:28.034]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:28.034]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:28.034]                         fi[["size"]], fi[["mtime"]])
[16:21:28.034]                       stop(msg)
[16:21:28.034]                     }
[16:21:28.034]                     invisible(pathname)
[16:21:28.034]                   }
[16:21:28.034]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:28.034]                     rootPath = tempdir()) 
[16:21:28.034]                   {
[16:21:28.034]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:28.034]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:28.034]                       tmpdir = path, fileext = ".rds")
[16:21:28.034]                     save_rds(obj, file)
[16:21:28.034]                   }
[16:21:28.034]                   saveImmediateCondition(cond, path = "/tmp/RtmpnVB70K/.future/immediateConditions")
[16:21:28.034]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:28.034]                   {
[16:21:28.034]                     inherits <- base::inherits
[16:21:28.034]                     invokeRestart <- base::invokeRestart
[16:21:28.034]                     is.null <- base::is.null
[16:21:28.034]                     muffled <- FALSE
[16:21:28.034]                     if (inherits(cond, "message")) {
[16:21:28.034]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:28.034]                       if (muffled) 
[16:21:28.034]                         invokeRestart("muffleMessage")
[16:21:28.034]                     }
[16:21:28.034]                     else if (inherits(cond, "warning")) {
[16:21:28.034]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:28.034]                       if (muffled) 
[16:21:28.034]                         invokeRestart("muffleWarning")
[16:21:28.034]                     }
[16:21:28.034]                     else if (inherits(cond, "condition")) {
[16:21:28.034]                       if (!is.null(pattern)) {
[16:21:28.034]                         computeRestarts <- base::computeRestarts
[16:21:28.034]                         grepl <- base::grepl
[16:21:28.034]                         restarts <- computeRestarts(cond)
[16:21:28.034]                         for (restart in restarts) {
[16:21:28.034]                           name <- restart$name
[16:21:28.034]                           if (is.null(name)) 
[16:21:28.034]                             next
[16:21:28.034]                           if (!grepl(pattern, name)) 
[16:21:28.034]                             next
[16:21:28.034]                           invokeRestart(restart)
[16:21:28.034]                           muffled <- TRUE
[16:21:28.034]                           break
[16:21:28.034]                         }
[16:21:28.034]                       }
[16:21:28.034]                     }
[16:21:28.034]                     invisible(muffled)
[16:21:28.034]                   }
[16:21:28.034]                   muffleCondition(cond)
[16:21:28.034]                 })
[16:21:28.034]             }))
[16:21:28.034]             future::FutureResult(value = ...future.value$value, 
[16:21:28.034]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:28.034]                   ...future.rng), globalenv = if (FALSE) 
[16:21:28.034]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:28.034]                     ...future.globalenv.names))
[16:21:28.034]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:28.034]         }, condition = base::local({
[16:21:28.034]             c <- base::c
[16:21:28.034]             inherits <- base::inherits
[16:21:28.034]             invokeRestart <- base::invokeRestart
[16:21:28.034]             length <- base::length
[16:21:28.034]             list <- base::list
[16:21:28.034]             seq.int <- base::seq.int
[16:21:28.034]             signalCondition <- base::signalCondition
[16:21:28.034]             sys.calls <- base::sys.calls
[16:21:28.034]             `[[` <- base::`[[`
[16:21:28.034]             `+` <- base::`+`
[16:21:28.034]             `<<-` <- base::`<<-`
[16:21:28.034]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:28.034]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:28.034]                   3L)]
[16:21:28.034]             }
[16:21:28.034]             function(cond) {
[16:21:28.034]                 is_error <- inherits(cond, "error")
[16:21:28.034]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:28.034]                   NULL)
[16:21:28.034]                 if (is_error) {
[16:21:28.034]                   sessionInformation <- function() {
[16:21:28.034]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:28.034]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:28.034]                       search = base::search(), system = base::Sys.info())
[16:21:28.034]                   }
[16:21:28.034]                   ...future.conditions[[length(...future.conditions) + 
[16:21:28.034]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:28.034]                     cond$call), session = sessionInformation(), 
[16:21:28.034]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:28.034]                   signalCondition(cond)
[16:21:28.034]                 }
[16:21:28.034]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:28.034]                 "immediateCondition"))) {
[16:21:28.034]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:28.034]                   ...future.conditions[[length(...future.conditions) + 
[16:21:28.034]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:28.034]                   if (TRUE && !signal) {
[16:21:28.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:28.034]                     {
[16:21:28.034]                       inherits <- base::inherits
[16:21:28.034]                       invokeRestart <- base::invokeRestart
[16:21:28.034]                       is.null <- base::is.null
[16:21:28.034]                       muffled <- FALSE
[16:21:28.034]                       if (inherits(cond, "message")) {
[16:21:28.034]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:28.034]                         if (muffled) 
[16:21:28.034]                           invokeRestart("muffleMessage")
[16:21:28.034]                       }
[16:21:28.034]                       else if (inherits(cond, "warning")) {
[16:21:28.034]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:28.034]                         if (muffled) 
[16:21:28.034]                           invokeRestart("muffleWarning")
[16:21:28.034]                       }
[16:21:28.034]                       else if (inherits(cond, "condition")) {
[16:21:28.034]                         if (!is.null(pattern)) {
[16:21:28.034]                           computeRestarts <- base::computeRestarts
[16:21:28.034]                           grepl <- base::grepl
[16:21:28.034]                           restarts <- computeRestarts(cond)
[16:21:28.034]                           for (restart in restarts) {
[16:21:28.034]                             name <- restart$name
[16:21:28.034]                             if (is.null(name)) 
[16:21:28.034]                               next
[16:21:28.034]                             if (!grepl(pattern, name)) 
[16:21:28.034]                               next
[16:21:28.034]                             invokeRestart(restart)
[16:21:28.034]                             muffled <- TRUE
[16:21:28.034]                             break
[16:21:28.034]                           }
[16:21:28.034]                         }
[16:21:28.034]                       }
[16:21:28.034]                       invisible(muffled)
[16:21:28.034]                     }
[16:21:28.034]                     muffleCondition(cond, pattern = "^muffle")
[16:21:28.034]                   }
[16:21:28.034]                 }
[16:21:28.034]                 else {
[16:21:28.034]                   if (TRUE) {
[16:21:28.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:28.034]                     {
[16:21:28.034]                       inherits <- base::inherits
[16:21:28.034]                       invokeRestart <- base::invokeRestart
[16:21:28.034]                       is.null <- base::is.null
[16:21:28.034]                       muffled <- FALSE
[16:21:28.034]                       if (inherits(cond, "message")) {
[16:21:28.034]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:28.034]                         if (muffled) 
[16:21:28.034]                           invokeRestart("muffleMessage")
[16:21:28.034]                       }
[16:21:28.034]                       else if (inherits(cond, "warning")) {
[16:21:28.034]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:28.034]                         if (muffled) 
[16:21:28.034]                           invokeRestart("muffleWarning")
[16:21:28.034]                       }
[16:21:28.034]                       else if (inherits(cond, "condition")) {
[16:21:28.034]                         if (!is.null(pattern)) {
[16:21:28.034]                           computeRestarts <- base::computeRestarts
[16:21:28.034]                           grepl <- base::grepl
[16:21:28.034]                           restarts <- computeRestarts(cond)
[16:21:28.034]                           for (restart in restarts) {
[16:21:28.034]                             name <- restart$name
[16:21:28.034]                             if (is.null(name)) 
[16:21:28.034]                               next
[16:21:28.034]                             if (!grepl(pattern, name)) 
[16:21:28.034]                               next
[16:21:28.034]                             invokeRestart(restart)
[16:21:28.034]                             muffled <- TRUE
[16:21:28.034]                             break
[16:21:28.034]                           }
[16:21:28.034]                         }
[16:21:28.034]                       }
[16:21:28.034]                       invisible(muffled)
[16:21:28.034]                     }
[16:21:28.034]                     muffleCondition(cond, pattern = "^muffle")
[16:21:28.034]                   }
[16:21:28.034]                 }
[16:21:28.034]             }
[16:21:28.034]         }))
[16:21:28.034]     }, error = function(ex) {
[16:21:28.034]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:28.034]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:28.034]                 ...future.rng), started = ...future.startTime, 
[16:21:28.034]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:28.034]             version = "1.8"), class = "FutureResult")
[16:21:28.034]     }, finally = {
[16:21:28.034]         if (!identical(...future.workdir, getwd())) 
[16:21:28.034]             setwd(...future.workdir)
[16:21:28.034]         {
[16:21:28.034]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:28.034]                 ...future.oldOptions$nwarnings <- NULL
[16:21:28.034]             }
[16:21:28.034]             base::options(...future.oldOptions)
[16:21:28.034]             if (.Platform$OS.type == "windows") {
[16:21:28.034]                 old_names <- names(...future.oldEnvVars)
[16:21:28.034]                 envs <- base::Sys.getenv()
[16:21:28.034]                 names <- names(envs)
[16:21:28.034]                 common <- intersect(names, old_names)
[16:21:28.034]                 added <- setdiff(names, old_names)
[16:21:28.034]                 removed <- setdiff(old_names, names)
[16:21:28.034]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:28.034]                   envs[common]]
[16:21:28.034]                 NAMES <- toupper(changed)
[16:21:28.034]                 args <- list()
[16:21:28.034]                 for (kk in seq_along(NAMES)) {
[16:21:28.034]                   name <- changed[[kk]]
[16:21:28.034]                   NAME <- NAMES[[kk]]
[16:21:28.034]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:28.034]                     next
[16:21:28.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:28.034]                 }
[16:21:28.034]                 NAMES <- toupper(added)
[16:21:28.034]                 for (kk in seq_along(NAMES)) {
[16:21:28.034]                   name <- added[[kk]]
[16:21:28.034]                   NAME <- NAMES[[kk]]
[16:21:28.034]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:28.034]                     next
[16:21:28.034]                   args[[name]] <- ""
[16:21:28.034]                 }
[16:21:28.034]                 NAMES <- toupper(removed)
[16:21:28.034]                 for (kk in seq_along(NAMES)) {
[16:21:28.034]                   name <- removed[[kk]]
[16:21:28.034]                   NAME <- NAMES[[kk]]
[16:21:28.034]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:28.034]                     next
[16:21:28.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:28.034]                 }
[16:21:28.034]                 if (length(args) > 0) 
[16:21:28.034]                   base::do.call(base::Sys.setenv, args = args)
[16:21:28.034]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:28.034]             }
[16:21:28.034]             else {
[16:21:28.034]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:28.034]             }
[16:21:28.034]             {
[16:21:28.034]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:28.034]                   0L) {
[16:21:28.034]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:28.034]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:28.034]                   base::options(opts)
[16:21:28.034]                 }
[16:21:28.034]                 {
[16:21:28.034]                   {
[16:21:28.034]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:28.034]                     NULL
[16:21:28.034]                   }
[16:21:28.034]                   options(future.plan = NULL)
[16:21:28.034]                   if (is.na(NA_character_)) 
[16:21:28.034]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:28.034]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:28.034]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:28.034]                     .init = FALSE)
[16:21:28.034]                 }
[16:21:28.034]             }
[16:21:28.034]         }
[16:21:28.034]     })
[16:21:28.034]     if (TRUE) {
[16:21:28.034]         base::sink(type = "output", split = FALSE)
[16:21:28.034]         if (TRUE) {
[16:21:28.034]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:28.034]         }
[16:21:28.034]         else {
[16:21:28.034]             ...future.result["stdout"] <- base::list(NULL)
[16:21:28.034]         }
[16:21:28.034]         base::close(...future.stdout)
[16:21:28.034]         ...future.stdout <- NULL
[16:21:28.034]     }
[16:21:28.034]     ...future.result$conditions <- ...future.conditions
[16:21:28.034]     ...future.result$finished <- base::Sys.time()
[16:21:28.034]     ...future.result
[16:21:28.034] }
[16:21:28.067]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.037] assign_globals() ...
[16:21:28.067]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.037] List of 1
[16:21:28.037]  $ data:'data.frame':	3 obs. of  2 variables:
[16:21:28.037]   ..$ a: int [1:3] 1 2 3
[16:21:28.037]   ..$ b: int [1:3] 3 2 1
[16:21:28.037]  - attr(*, "where")=List of 1
[16:21:28.037]   ..$ data:<environment: R_EmptyEnv> 
[16:21:28.037]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:28.037]  - attr(*, "resolved")= logi FALSE
[16:21:28.037]  - attr(*, "total_size")= num 128
[16:21:28.037]  - attr(*, "already-done")= logi TRUE
[16:21:28.067]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.040] - copied ‘data’ to environment
[16:21:28.068]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.040] assign_globals() ... done
[16:21:28.068]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.040] requestCore(): workers = 2
[16:21:28.068]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.042] MulticoreFuture started
[16:21:28.068]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.042] - Launch lazy future ... done
[16:21:28.068]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.043] run() for ‘MulticoreFuture’ ... done
[16:21:28.068]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.043] result() for MulticoreFuture ...
[16:21:28.069]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.052] result() for MulticoreFuture ...
[16:21:28.069]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.052] result() for MulticoreFuture ... done
[16:21:28.069]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.052] result() for MulticoreFuture ... done
[16:21:28.069]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.052] result() for MulticoreFuture ...
[16:21:28.069]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.053] result() for MulticoreFuture ... done
[16:21:28.069] signalConditions() ... done
- plan(list('sequential', 'multicore')) ... DONE
- plan(list('sequential', 'multisession')) ...
[16:21:28.070] plan(): Setting new future strategy stack:
[16:21:28.070] List of future strategies:
[16:21:28.070] 1. sequential:
[16:21:28.070]    - args: function (..., envir = parent.frame())
[16:21:28.070]    - tweaked: FALSE
[16:21:28.070]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:28.070] 2. multisession:
[16:21:28.070]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:28.070]    - tweaked: FALSE
[16:21:28.070]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:28.071] plan(): nbrOfWorkers() = 1
[16:21:28.071] getGlobalsAndPackages() ...
[16:21:28.071] Searching for globals...
[16:21:28.089] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:21:28.089] Searching for globals ... DONE
[16:21:28.089] Resolving globals: FALSE
[16:21:28.090] The total size of the 2 globals is 55.41 KiB (56736 bytes)
[16:21:28.091] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 55.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (55.29 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:21:28.091] - globals: [2] ‘nested’, ‘strategy2’
[16:21:28.091] - packages: [1] ‘future’
[16:21:28.091] getGlobalsAndPackages() ... DONE
[16:21:28.091] run() for ‘Future’ ...
[16:21:28.091] - state: ‘created’
[16:21:28.092] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:28.092] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:28.092] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:28.092]   - Field: ‘label’
[16:21:28.092]   - Field: ‘local’
[16:21:28.092]   - Field: ‘owner’
[16:21:28.092]   - Field: ‘envir’
[16:21:28.092]   - Field: ‘packages’
[16:21:28.093]   - Field: ‘gc’
[16:21:28.093]   - Field: ‘conditions’
[16:21:28.093]   - Field: ‘expr’
[16:21:28.093]   - Field: ‘uuid’
[16:21:28.093]   - Field: ‘seed’
[16:21:28.093]   - Field: ‘version’
[16:21:28.093]   - Field: ‘result’
[16:21:28.093]   - Field: ‘asynchronous’
[16:21:28.093]   - Field: ‘calls’
[16:21:28.093]   - Field: ‘globals’
[16:21:28.093]   - Field: ‘stdout’
[16:21:28.094]   - Field: ‘earlySignal’
[16:21:28.094]   - Field: ‘lazy’
[16:21:28.094]   - Field: ‘state’
[16:21:28.094] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:28.094] - Launch lazy future ...
[16:21:28.094] Packages needed by the future expression (n = 1): ‘future’
[16:21:28.094] Packages needed by future strategies (n = 1): ‘future’
[16:21:28.095] {
[16:21:28.095]     {
[16:21:28.095]         {
[16:21:28.095]             ...future.startTime <- base::Sys.time()
[16:21:28.095]             {
[16:21:28.095]                 {
[16:21:28.095]                   {
[16:21:28.095]                     {
[16:21:28.095]                       base::local({
[16:21:28.095]                         has_future <- base::requireNamespace("future", 
[16:21:28.095]                           quietly = TRUE)
[16:21:28.095]                         if (has_future) {
[16:21:28.095]                           ns <- base::getNamespace("future")
[16:21:28.095]                           version <- ns[[".package"]][["version"]]
[16:21:28.095]                           if (is.null(version)) 
[16:21:28.095]                             version <- utils::packageVersion("future")
[16:21:28.095]                         }
[16:21:28.095]                         else {
[16:21:28.095]                           version <- NULL
[16:21:28.095]                         }
[16:21:28.095]                         if (!has_future || version < "1.8.0") {
[16:21:28.095]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:28.095]                             "", base::R.version$version.string), 
[16:21:28.095]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:28.095]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:28.095]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:28.095]                               "release", "version")], collapse = " "), 
[16:21:28.095]                             hostname = base::Sys.info()[["nodename"]])
[16:21:28.095]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:28.095]                             info)
[16:21:28.095]                           info <- base::paste(info, collapse = "; ")
[16:21:28.095]                           if (!has_future) {
[16:21:28.095]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:28.095]                               info)
[16:21:28.095]                           }
[16:21:28.095]                           else {
[16:21:28.095]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:28.095]                               info, version)
[16:21:28.095]                           }
[16:21:28.095]                           base::stop(msg)
[16:21:28.095]                         }
[16:21:28.095]                       })
[16:21:28.095]                     }
[16:21:28.095]                     base::local({
[16:21:28.095]                       for (pkg in "future") {
[16:21:28.095]                         base::loadNamespace(pkg)
[16:21:28.095]                         base::library(pkg, character.only = TRUE)
[16:21:28.095]                       }
[16:21:28.095]                     })
[16:21:28.095]                   }
[16:21:28.095]                   ...future.strategy.old <- future::plan("list")
[16:21:28.095]                   options(future.plan = NULL)
[16:21:28.095]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:28.095]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:21:28.095]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:21:28.095]                     envir = parent.frame()) 
[16:21:28.095]                   {
[16:21:28.095]                     if (is.function(workers)) 
[16:21:28.095]                       workers <- workers()
[16:21:28.095]                     workers <- structure(as.integer(workers), 
[16:21:28.095]                       class = class(workers))
[16:21:28.095]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:21:28.095]                       workers >= 1)
[16:21:28.095]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:21:28.095]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:21:28.095]                     }
[16:21:28.095]                     future <- MultisessionFuture(..., workers = workers, 
[16:21:28.095]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:21:28.095]                       envir = envir)
[16:21:28.095]                     if (!future$lazy) 
[16:21:28.095]                       future <- run(future)
[16:21:28.095]                     invisible(future)
[16:21:28.095]                   }), .cleanup = FALSE, .init = FALSE)
[16:21:28.095]                 }
[16:21:28.095]                 ...future.workdir <- getwd()
[16:21:28.095]             }
[16:21:28.095]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:28.095]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:28.095]         }
[16:21:28.095]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:28.095]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:28.095]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:28.095]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:28.095]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:28.095]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:28.095]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:28.095]             base::names(...future.oldOptions))
[16:21:28.095]     }
[16:21:28.095]     if (FALSE) {
[16:21:28.095]     }
[16:21:28.095]     else {
[16:21:28.095]         if (TRUE) {
[16:21:28.095]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:28.095]                 open = "w")
[16:21:28.095]         }
[16:21:28.095]         else {
[16:21:28.095]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:28.095]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:28.095]         }
[16:21:28.095]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:28.095]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:28.095]             base::sink(type = "output", split = FALSE)
[16:21:28.095]             base::close(...future.stdout)
[16:21:28.095]         }, add = TRUE)
[16:21:28.095]     }
[16:21:28.095]     ...future.frame <- base::sys.nframe()
[16:21:28.095]     ...future.conditions <- base::list()
[16:21:28.095]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:28.095]     if (FALSE) {
[16:21:28.095]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:28.095]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:28.095]     }
[16:21:28.095]     ...future.result <- base::tryCatch({
[16:21:28.095]         base::withCallingHandlers({
[16:21:28.095]             ...future.value <- base::withVisible(base::local({
[16:21:28.095]                 a <- 1L
[16:21:28.095]                 plan_a <- unclass(future::plan("list"))
[16:21:28.095]                 nested_a <- nested[-1]
[16:21:28.095]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:21:28.095]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:21:28.095]                   strategy2))
[16:21:28.095]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:21:28.095]                   "init") <- NULL
[16:21:28.095]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:21:28.095]                   "init") <- NULL
[16:21:28.095]                 stopifnot(all.equal(plan_a, nested_a))
[16:21:28.095]                 y %<-% {
[16:21:28.095]                   b <- 2L
[16:21:28.095]                   plan_b <- future::plan("list")
[16:21:28.095]                   nested_b <- nested_a[-1]
[16:21:28.095]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:21:28.095]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:21:28.095]                     "sequential"))
[16:21:28.095]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:21:28.095]                     b = b, nested_b = nested_b, plan_b = plan_b)
[16:21:28.095]                 }
[16:21:28.095]                 y
[16:21:28.095]             }))
[16:21:28.095]             future::FutureResult(value = ...future.value$value, 
[16:21:28.095]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:28.095]                   ...future.rng), globalenv = if (FALSE) 
[16:21:28.095]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:28.095]                     ...future.globalenv.names))
[16:21:28.095]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:28.095]         }, condition = base::local({
[16:21:28.095]             c <- base::c
[16:21:28.095]             inherits <- base::inherits
[16:21:28.095]             invokeRestart <- base::invokeRestart
[16:21:28.095]             length <- base::length
[16:21:28.095]             list <- base::list
[16:21:28.095]             seq.int <- base::seq.int
[16:21:28.095]             signalCondition <- base::signalCondition
[16:21:28.095]             sys.calls <- base::sys.calls
[16:21:28.095]             `[[` <- base::`[[`
[16:21:28.095]             `+` <- base::`+`
[16:21:28.095]             `<<-` <- base::`<<-`
[16:21:28.095]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:28.095]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:28.095]                   3L)]
[16:21:28.095]             }
[16:21:28.095]             function(cond) {
[16:21:28.095]                 is_error <- inherits(cond, "error")
[16:21:28.095]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:28.095]                   NULL)
[16:21:28.095]                 if (is_error) {
[16:21:28.095]                   sessionInformation <- function() {
[16:21:28.095]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:28.095]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:28.095]                       search = base::search(), system = base::Sys.info())
[16:21:28.095]                   }
[16:21:28.095]                   ...future.conditions[[length(...future.conditions) + 
[16:21:28.095]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:28.095]                     cond$call), session = sessionInformation(), 
[16:21:28.095]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:28.095]                   signalCondition(cond)
[16:21:28.095]                 }
[16:21:28.095]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:28.095]                 "immediateCondition"))) {
[16:21:28.095]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:28.095]                   ...future.conditions[[length(...future.conditions) + 
[16:21:28.095]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:28.095]                   if (TRUE && !signal) {
[16:21:28.095]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:28.095]                     {
[16:21:28.095]                       inherits <- base::inherits
[16:21:28.095]                       invokeRestart <- base::invokeRestart
[16:21:28.095]                       is.null <- base::is.null
[16:21:28.095]                       muffled <- FALSE
[16:21:28.095]                       if (inherits(cond, "message")) {
[16:21:28.095]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:28.095]                         if (muffled) 
[16:21:28.095]                           invokeRestart("muffleMessage")
[16:21:28.095]                       }
[16:21:28.095]                       else if (inherits(cond, "warning")) {
[16:21:28.095]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:28.095]                         if (muffled) 
[16:21:28.095]                           invokeRestart("muffleWarning")
[16:21:28.095]                       }
[16:21:28.095]                       else if (inherits(cond, "condition")) {
[16:21:28.095]                         if (!is.null(pattern)) {
[16:21:28.095]                           computeRestarts <- base::computeRestarts
[16:21:28.095]                           grepl <- base::grepl
[16:21:28.095]                           restarts <- computeRestarts(cond)
[16:21:28.095]                           for (restart in restarts) {
[16:21:28.095]                             name <- restart$name
[16:21:28.095]                             if (is.null(name)) 
[16:21:28.095]                               next
[16:21:28.095]                             if (!grepl(pattern, name)) 
[16:21:28.095]                               next
[16:21:28.095]                             invokeRestart(restart)
[16:21:28.095]                             muffled <- TRUE
[16:21:28.095]                             break
[16:21:28.095]                           }
[16:21:28.095]                         }
[16:21:28.095]                       }
[16:21:28.095]                       invisible(muffled)
[16:21:28.095]                     }
[16:21:28.095]                     muffleCondition(cond, pattern = "^muffle")
[16:21:28.095]                   }
[16:21:28.095]                 }
[16:21:28.095]                 else {
[16:21:28.095]                   if (TRUE) {
[16:21:28.095]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:28.095]                     {
[16:21:28.095]                       inherits <- base::inherits
[16:21:28.095]                       invokeRestart <- base::invokeRestart
[16:21:28.095]                       is.null <- base::is.null
[16:21:28.095]                       muffled <- FALSE
[16:21:28.095]                       if (inherits(cond, "message")) {
[16:21:28.095]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:28.095]                         if (muffled) 
[16:21:28.095]                           invokeRestart("muffleMessage")
[16:21:28.095]                       }
[16:21:28.095]                       else if (inherits(cond, "warning")) {
[16:21:28.095]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:28.095]                         if (muffled) 
[16:21:28.095]                           invokeRestart("muffleWarning")
[16:21:28.095]                       }
[16:21:28.095]                       else if (inherits(cond, "condition")) {
[16:21:28.095]                         if (!is.null(pattern)) {
[16:21:28.095]                           computeRestarts <- base::computeRestarts
[16:21:28.095]                           grepl <- base::grepl
[16:21:28.095]                           restarts <- computeRestarts(cond)
[16:21:28.095]                           for (restart in restarts) {
[16:21:28.095]                             name <- restart$name
[16:21:28.095]                             if (is.null(name)) 
[16:21:28.095]                               next
[16:21:28.095]                             if (!grepl(pattern, name)) 
[16:21:28.095]                               next
[16:21:28.095]                             invokeRestart(restart)
[16:21:28.095]                             muffled <- TRUE
[16:21:28.095]                             break
[16:21:28.095]                           }
[16:21:28.095]                         }
[16:21:28.095]                       }
[16:21:28.095]                       invisible(muffled)
[16:21:28.095]                     }
[16:21:28.095]                     muffleCondition(cond, pattern = "^muffle")
[16:21:28.095]                   }
[16:21:28.095]                 }
[16:21:28.095]             }
[16:21:28.095]         }))
[16:21:28.095]     }, error = function(ex) {
[16:21:28.095]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:28.095]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:28.095]                 ...future.rng), started = ...future.startTime, 
[16:21:28.095]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:28.095]             version = "1.8"), class = "FutureResult")
[16:21:28.095]     }, finally = {
[16:21:28.095]         if (!identical(...future.workdir, getwd())) 
[16:21:28.095]             setwd(...future.workdir)
[16:21:28.095]         {
[16:21:28.095]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:28.095]                 ...future.oldOptions$nwarnings <- NULL
[16:21:28.095]             }
[16:21:28.095]             base::options(...future.oldOptions)
[16:21:28.095]             if (.Platform$OS.type == "windows") {
[16:21:28.095]                 old_names <- names(...future.oldEnvVars)
[16:21:28.095]                 envs <- base::Sys.getenv()
[16:21:28.095]                 names <- names(envs)
[16:21:28.095]                 common <- intersect(names, old_names)
[16:21:28.095]                 added <- setdiff(names, old_names)
[16:21:28.095]                 removed <- setdiff(old_names, names)
[16:21:28.095]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:28.095]                   envs[common]]
[16:21:28.095]                 NAMES <- toupper(changed)
[16:21:28.095]                 args <- list()
[16:21:28.095]                 for (kk in seq_along(NAMES)) {
[16:21:28.095]                   name <- changed[[kk]]
[16:21:28.095]                   NAME <- NAMES[[kk]]
[16:21:28.095]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:28.095]                     next
[16:21:28.095]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:28.095]                 }
[16:21:28.095]                 NAMES <- toupper(added)
[16:21:28.095]                 for (kk in seq_along(NAMES)) {
[16:21:28.095]                   name <- added[[kk]]
[16:21:28.095]                   NAME <- NAMES[[kk]]
[16:21:28.095]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:28.095]                     next
[16:21:28.095]                   args[[name]] <- ""
[16:21:28.095]                 }
[16:21:28.095]                 NAMES <- toupper(removed)
[16:21:28.095]                 for (kk in seq_along(NAMES)) {
[16:21:28.095]                   name <- removed[[kk]]
[16:21:28.095]                   NAME <- NAMES[[kk]]
[16:21:28.095]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:28.095]                     next
[16:21:28.095]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:28.095]                 }
[16:21:28.095]                 if (length(args) > 0) 
[16:21:28.095]                   base::do.call(base::Sys.setenv, args = args)
[16:21:28.095]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:28.095]             }
[16:21:28.095]             else {
[16:21:28.095]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:28.095]             }
[16:21:28.095]             {
[16:21:28.095]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:28.095]                   0L) {
[16:21:28.095]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:28.095]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:28.095]                   base::options(opts)
[16:21:28.095]                 }
[16:21:28.095]                 {
[16:21:28.095]                   {
[16:21:28.095]                     NULL
[16:21:28.095]                     RNGkind("Mersenne-Twister")
[16:21:28.095]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:28.095]                       inherits = FALSE)
[16:21:28.095]                   }
[16:21:28.095]                   options(future.plan = NULL)
[16:21:28.095]                   if (is.na(NA_character_)) 
[16:21:28.095]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:28.095]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:28.095]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:28.095]                     .init = FALSE)
[16:21:28.095]                 }
[16:21:28.095]             }
[16:21:28.095]         }
[16:21:28.095]     })
[16:21:28.095]     if (TRUE) {
[16:21:28.095]         base::sink(type = "output", split = FALSE)
[16:21:28.095]         if (TRUE) {
[16:21:28.095]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:28.095]         }
[16:21:28.095]         else {
[16:21:28.095]             ...future.result["stdout"] <- base::list(NULL)
[16:21:28.095]         }
[16:21:28.095]         base::close(...future.stdout)
[16:21:28.095]         ...future.stdout <- NULL
[16:21:28.095]     }
[16:21:28.095]     ...future.result$conditions <- ...future.conditions
[16:21:28.095]     ...future.result$finished <- base::Sys.time()
[16:21:28.095]     ...future.result
[16:21:28.095] }
[16:21:28.097] assign_globals() ...
[16:21:28.097] List of 2
[16:21:28.097]  $ nested   :List of 2
[16:21:28.097]   ..$ a:function (..., envir = parent.frame())  
[16:21:28.097]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:21:28.097]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:21:28.097]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[16:21:28.097]     envir = parent.frame())  
[16:21:28.097]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[16:21:28.097]   .. ..- attr(*, "init")= logi TRUE
[16:21:28.097]   .. ..- attr(*, "untweakable")= chr "persistent"
[16:21:28.097]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:21:28.097]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:21:28.097]  $ strategy2: chr "multisession"
[16:21:28.097]  - attr(*, "where")=List of 2
[16:21:28.097]   ..$ nested   :<environment: R_EmptyEnv> 
[16:21:28.097]   ..$ strategy2:<environment: R_EmptyEnv> 
[16:21:28.097]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:28.097]  - attr(*, "resolved")= logi FALSE
[16:21:28.097]  - attr(*, "total_size")= num 56736
[16:21:28.097]  - attr(*, "already-done")= logi TRUE
[16:21:28.103] - copied ‘nested’ to environment
[16:21:28.103] - copied ‘strategy2’ to environment
[16:21:28.103] assign_globals() ... done
[16:21:28.104] plan(): Setting new future strategy stack:
[16:21:28.104] List of future strategies:
[16:21:28.104] 1. multisession:
[16:21:28.104]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:28.104]    - tweaked: FALSE
[16:21:28.104]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:28.107] plan(): nbrOfWorkers() = 2
[16:21:28.862] plan(): Setting new future strategy stack:
[16:21:28.862] List of future strategies:
[16:21:28.862] 1. sequential:
[16:21:28.862]    - args: function (..., envir = parent.frame())
[16:21:28.862]    - tweaked: FALSE
[16:21:28.862]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:28.862] 2. multisession:
[16:21:28.862]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:28.862]    - tweaked: FALSE
[16:21:28.862]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:28.862] plan(): nbrOfWorkers() = 1
[16:21:28.863] SequentialFuture started (and completed)
[16:21:28.863] signalConditions() ...
[16:21:28.863]  - include = ‘immediateCondition’
[16:21:28.863]  - exclude = 
[16:21:28.863]  - resignal = FALSE
[16:21:28.863]  - Number of conditions: 98
[16:21:28.864] signalConditions() ... done
[16:21:28.864] - Launch lazy future ... done
[16:21:28.864] run() for ‘SequentialFuture’ ... done
[16:21:28.864] signalConditions() ...
[16:21:28.864]  - include = ‘immediateCondition’
[16:21:28.864]  - exclude = 
[16:21:28.864]  - resignal = FALSE
[16:21:28.865]  - Number of conditions: 98
[16:21:28.865] signalConditions() ... done
[16:21:28.865] Future state: ‘finished’
[16:21:28.865] signalConditions() ...
[16:21:28.865]  - include = ‘condition’
[16:21:28.865]  - exclude = ‘immediateCondition’
[16:21:28.865]  - resignal = TRUE
[16:21:28.865]  - Number of conditions: 98
[16:21:28.866]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.108] getGlobalsAndPackages() ...
[16:21:28.866]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.109] Searching for globals...
[16:21:28.866]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.126] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[16:21:28.866]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.126] Searching for globals ... DONE
[16:21:28.866]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.126] Resolving globals: FALSE
[16:21:28.866]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.127] The total size of the 3 globals is 87.82 KiB (89928 bytes)
[16:21:28.867]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.127] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 87.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (43.88 KiB of class ‘list’), ‘plan_a’ (43.88 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[16:21:28.867]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.127] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[16:21:28.867]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.128] 
[16:21:28.867]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.128] getGlobalsAndPackages() ... DONE
[16:21:28.867]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.128] run() for ‘Future’ ...
[16:21:28.867]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.128] - state: ‘created’
[16:21:28.868]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.128] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:28.868]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.134] [local output] makeClusterPSOCK() ...
[16:21:28.868]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.191] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:21:28.868]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.192] [local output] Base port: 11925
[16:21:28.868]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.193] [local output] Getting setup options for 2 cluster nodes ...
[16:21:28.869]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.193] [local output]  - Node 1 of 2 ...
[16:21:28.869]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.193] [local output] localMachine=TRUE => revtunnel=FALSE

[16:21:28.869]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.194] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpnVB70K/worker.rank=1.parallelly.parent=86806.15316490a76.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpnVB70K/worker.rank=1.parallelly.parent=86806.15316490a76.pid")'’
[16:21:28.869]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.384] - Possible to infer worker's PID: TRUE
[16:21:28.869]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.385] [local output] Rscript port: 11925

[16:21:28.869]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.385] [local output]  - Node 2 of 2 ...
[16:21:28.870]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.386] [local output] localMachine=TRUE => revtunnel=FALSE

[16:21:28.870]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.386] [local output] Rscript port: 11925

[16:21:28.870]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.387] [local output] Getting setup options for 2 cluster nodes ... done
[16:21:28.870]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.387] [local output]  - Parallel setup requested for some PSOCK nodes
[16:21:28.870]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.387] [local output] Setting up PSOCK nodes in parallel
[16:21:28.870]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.387] List of 36
[16:21:28.387]  $ worker          : chr "localhost"
[16:21:28.387]   ..- attr(*, "localhost")= logi TRUE
[16:21:28.387]  $ master          : chr "localhost"
[16:21:28.387]  $ port            : int 11925
[16:21:28.387]  $ connectTimeout  : num 120
[16:21:28.387]  $ timeout         : num 2592000
[16:21:28.387]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:21:28.387]  $ homogeneous     : logi TRUE
[16:21:28.387]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:21:28.387]  $ rscript_envs    : NULL
[16:21:28.387]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:21:28.387]  $ rscript_startup : NULL
[16:21:28.387]  $ rscript_sh      : chr "sh"
[16:21:28.387]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:21:28.387]  $ methods         : logi TRUE
[16:21:28.387]  $ socketOptions   : chr "no-delay"
[16:21:28.387]  $ useXDR          : logi FALSE
[16:21:28.387]  $ outfile         : chr "/dev/null"
[16:21:28.387]  $ renice          : int NA
[16:21:28.387]  $ rshcmd          : NULL
[16:21:28.387]  $ user            : chr(0) 
[16:21:28.387]  $ revtunnel       : logi FALSE
[16:21:28.387]  $ rshlogfile      : NULL
[16:21:28.387]  $ rshopts         : chr(0) 
[16:21:28.387]  $ rank            : int 1
[16:21:28.387]  $ manual          : logi FALSE
[16:21:28.387]  $ dryrun          : logi FALSE
[16:21:28.387]  $ quiet           : logi FALSE
[16:21:28.387]  $ setup_strategy  : chr "parallel"
[16:21:28.387]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:21:28.387]  $ pidfile         : chr "/tmp/RtmpnVB70K/worker.rank=1.parallelly.parent=86806.15316490a76.pid"
[16:21:28.387]  $ rshcmd_label    : NULL
[16:21:28.387]  $ rsh_call        : NULL
[16:21:28.387]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:21:28.387]  $ localMachine    : logi TRUE
[16:21:28.387]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:21:28.387]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:21:28.387]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:21:28.387]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:21:28.387]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:21:28.387]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:21:28.387]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:21:28.387]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:21:28.387]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:21:28.387]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:21:28.387]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:21:28.387]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:21:28.387]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:21:28.387]  $ arguments       :List of 28
[16:21:28.387]   ..$ worker          : chr "localhost"
[16:21:28.387]   ..$ master          : NULL
[16:21:28.387]   ..$ port            : int 11925
[16:21:28.387]   ..$ connectTimeout  : num 120
[16:21:28.387]   ..$ timeout         : num 2592000
[16:21:28.387]   ..$ rscript         : NULL
[16:21:28.387]   ..$ homogeneous     : NULL
[16:21:28.387]   ..$ rscript_args    : NULL
[16:21:28.387]   ..$ rscript_envs    : NULL
[16:21:28.387]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:21:28.387]   ..$ rscript_startup : NULL
[16:21:28.387]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:21:28.387]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:21:28.387]   ..$ methods         : logi TRUE
[16:21:28.387]   ..$ socketOptions   : chr "no-delay"
[16:21:28.387]   ..$ useXDR          : logi FALSE
[16:21:28.387]   ..$ outfile         : chr "/dev/null"
[16:21:28.387]   ..$ renice          : int NA
[16:21:28.387]   ..$ rshcmd          : NULL
[16:21:28.387]   ..$ user            : NULL
[16:21:28.387]   ..$ revtunnel       : logi NA
[16:21:28.387]   ..$ rshlogfile      : NULL
[16:21:28.387]   ..$ rshopts         : NULL
[16:21:28.387]   ..$ rank            : int 1
[16:21:28.387]   ..$ manual          : logi FALSE
[16:21:28.387]   ..$ dryrun          : logi FALSE
[16:21:28.387]   ..$ quiet           : logi FALSE
[16:21:28.387]   ..$ setup_strategy  : chr "parallel"
[16:21:28.387]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:21:28.871]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.404] [local output] System call to launch all workers:
[16:21:28.871]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.404] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpnVB70K/worker.rank=1.parallelly.parent=86806.15316490a76.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11925 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:21:28.871]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.405] [local output] Starting PSOCK main server
[16:21:28.871]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.410] [local output] Workers launched
[16:21:28.871]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.410] [local output] Waiting for workers to connect back
[16:21:28.871]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.411]  - [local output] 0 workers out of 2 ready
[16:21:28.872]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.663]  - [local output] 0 workers out of 2 ready
[16:21:28.872]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.663]  - [local output] 1 workers out of 2 ready
[16:21:28.872]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.664]  - [local output] 1 workers out of 2 ready
[16:21:28.872]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.665]  - [local output] 2 workers out of 2 ready
[16:21:28.872]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.665] [local output] Launching of workers completed
[16:21:28.872]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.665] [local output] Collecting session information from workers
[16:21:28.873]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.666] [local output]  - Worker #1 of 2
[16:21:28.873]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.667] [local output]  - Worker #2 of 2
[16:21:28.873]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.667] [local output] makeClusterPSOCK() ... done
[16:21:28.873]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.678] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:28.873]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.678] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:28.873]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.678]   - Field: ‘node’
[16:21:28.874]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.678]   - Field: ‘label’
[16:21:28.874]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.678]   - Field: ‘local’
[16:21:28.874]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.678]   - Field: ‘owner’
[16:21:28.874]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.678]   - Field: ‘envir’
[16:21:28.874]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.679]   - Field: ‘workers’
[16:21:28.874]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.679]   - Field: ‘packages’
[16:21:28.875]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.679]   - Field: ‘gc’
[16:21:28.875]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.679]   - Field: ‘conditions’
[16:21:28.875]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.679]   - Field: ‘persistent’
[16:21:28.875]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.679]   - Field: ‘expr’
[16:21:28.875]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.679]   - Field: ‘uuid’
[16:21:28.875]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.679]   - Field: ‘seed’
[16:21:28.876]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.680]   - Field: ‘version’
[16:21:28.876]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.680]   - Field: ‘result’
[16:21:28.876]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.680]   - Field: ‘asynchronous’
[16:21:28.876]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.680]   - Field: ‘calls’
[16:21:28.876]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.680]   - Field: ‘globals’
[16:21:28.877]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.680]   - Field: ‘stdout’
[16:21:28.877]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.680]   - Field: ‘earlySignal’
[16:21:28.877]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.681]   - Field: ‘lazy’
[16:21:28.877]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.681]   - Field: ‘state’
[16:21:28.877]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.681] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:28.877]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.681] - Launch lazy future ...
[16:21:28.878]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.682] Packages needed by the future expression (n = 0): <none>
[16:21:28.878]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.682] Packages needed by future strategies (n = 0): <none>
[16:21:28.878]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.683] {
[16:21:28.683]     {
[16:21:28.683]         {
[16:21:28.683]             ...future.startTime <- base::Sys.time()
[16:21:28.683]             {
[16:21:28.683]                 {
[16:21:28.683]                   {
[16:21:28.683]                     {
[16:21:28.683]                       base::local({
[16:21:28.683]                         has_future <- base::requireNamespace("future", 
[16:21:28.683]                           quietly = TRUE)
[16:21:28.683]                         if (has_future) {
[16:21:28.683]                           ns <- base::getNamespace("future")
[16:21:28.683]                           version <- ns[[".package"]][["version"]]
[16:21:28.683]                           if (is.null(version)) 
[16:21:28.683]                             version <- utils::packageVersion("future")
[16:21:28.683]                         }
[16:21:28.683]                         else {
[16:21:28.683]                           version <- NULL
[16:21:28.683]                         }
[16:21:28.683]                         if (!has_future || version < "1.8.0") {
[16:21:28.683]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:28.683]                             "", base::R.version$version.string), 
[16:21:28.683]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:28.683]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:28.683]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:28.683]                               "release", "version")], collapse = " "), 
[16:21:28.683]                             hostname = base::Sys.info()[["nodename"]])
[16:21:28.683]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:28.683]                             info)
[16:21:28.683]                           info <- base::paste(info, collapse = "; ")
[16:21:28.683]                           if (!has_future) {
[16:21:28.683]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:28.683]                               info)
[16:21:28.683]                           }
[16:21:28.683]                           else {
[16:21:28.683]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:28.683]                               info, version)
[16:21:28.683]                           }
[16:21:28.683]                           base::stop(msg)
[16:21:28.683]                         }
[16:21:28.683]                       })
[16:21:28.683]                     }
[16:21:28.683]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:28.683]                     base::options(mc.cores = 1L)
[16:21:28.683]                   }
[16:21:28.683]                   ...future.strategy.old <- future::plan("list")
[16:21:28.683]                   options(future.plan = NULL)
[16:21:28.683]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:28.683]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:28.683]                 }
[16:21:28.683]                 ...future.workdir <- getwd()
[16:21:28.683]             }
[16:21:28.683]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:28.683]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:28.683]         }
[16:21:28.683]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:28.683]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:28.683]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:28.683]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:28.683]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:28.683]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:28.683]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:28.683]             base::names(...future.oldOptions))
[16:21:28.683]     }
[16:21:28.683]     if (FALSE) {
[16:21:28.683]     }
[16:21:28.683]     else {
[16:21:28.683]         if (TRUE) {
[16:21:28.683]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:28.683]                 open = "w")
[16:21:28.683]         }
[16:21:28.683]         else {
[16:21:28.683]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:28.683]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:28.683]         }
[16:21:28.683]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:28.683]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:28.683]             base::sink(type = "output", split = FALSE)
[16:21:28.683]             base::close(...future.stdout)
[16:21:28.683]         }, add = TRUE)
[16:21:28.683]     }
[16:21:28.683]     ...future.frame <- base::sys.nframe()
[16:21:28.683]     ...future.conditions <- base::list()
[16:21:28.683]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:28.683]     if (FALSE) {
[16:21:28.683]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:28.683]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:28.683]     }
[16:21:28.683]     ...future.result <- base::tryCatch({
[16:21:28.683]         base::withCallingHandlers({
[16:21:28.683]             ...future.value <- base::withVisible(base::local({
[16:21:28.683]                 ...future.makeSendCondition <- base::local({
[16:21:28.683]                   sendCondition <- NULL
[16:21:28.683]                   function(frame = 1L) {
[16:21:28.683]                     if (is.function(sendCondition)) 
[16:21:28.683]                       return(sendCondition)
[16:21:28.683]                     ns <- getNamespace("parallel")
[16:21:28.683]                     if (exists("sendData", mode = "function", 
[16:21:28.683]                       envir = ns)) {
[16:21:28.683]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:28.683]                         envir = ns)
[16:21:28.683]                       envir <- sys.frame(frame)
[16:21:28.683]                       master <- NULL
[16:21:28.683]                       while (!identical(envir, .GlobalEnv) && 
[16:21:28.683]                         !identical(envir, emptyenv())) {
[16:21:28.683]                         if (exists("master", mode = "list", envir = envir, 
[16:21:28.683]                           inherits = FALSE)) {
[16:21:28.683]                           master <- get("master", mode = "list", 
[16:21:28.683]                             envir = envir, inherits = FALSE)
[16:21:28.683]                           if (inherits(master, c("SOCKnode", 
[16:21:28.683]                             "SOCK0node"))) {
[16:21:28.683]                             sendCondition <<- function(cond) {
[16:21:28.683]                               data <- list(type = "VALUE", value = cond, 
[16:21:28.683]                                 success = TRUE)
[16:21:28.683]                               parallel_sendData(master, data)
[16:21:28.683]                             }
[16:21:28.683]                             return(sendCondition)
[16:21:28.683]                           }
[16:21:28.683]                         }
[16:21:28.683]                         frame <- frame + 1L
[16:21:28.683]                         envir <- sys.frame(frame)
[16:21:28.683]                       }
[16:21:28.683]                     }
[16:21:28.683]                     sendCondition <<- function(cond) NULL
[16:21:28.683]                   }
[16:21:28.683]                 })
[16:21:28.683]                 withCallingHandlers({
[16:21:28.683]                   {
[16:21:28.683]                     b <- 2L
[16:21:28.683]                     plan_b <- future::plan("list")
[16:21:28.683]                     nested_b <- nested_a[-1]
[16:21:28.683]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:21:28.683]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:21:28.683]                       "sequential"))
[16:21:28.683]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:21:28.683]                       b = b, nested_b = nested_b, plan_b = plan_b)
[16:21:28.683]                   }
[16:21:28.683]                 }, immediateCondition = function(cond) {
[16:21:28.683]                   sendCondition <- ...future.makeSendCondition()
[16:21:28.683]                   sendCondition(cond)
[16:21:28.683]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:28.683]                   {
[16:21:28.683]                     inherits <- base::inherits
[16:21:28.683]                     invokeRestart <- base::invokeRestart
[16:21:28.683]                     is.null <- base::is.null
[16:21:28.683]                     muffled <- FALSE
[16:21:28.683]                     if (inherits(cond, "message")) {
[16:21:28.683]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:28.683]                       if (muffled) 
[16:21:28.683]                         invokeRestart("muffleMessage")
[16:21:28.683]                     }
[16:21:28.683]                     else if (inherits(cond, "warning")) {
[16:21:28.683]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:28.683]                       if (muffled) 
[16:21:28.683]                         invokeRestart("muffleWarning")
[16:21:28.683]                     }
[16:21:28.683]                     else if (inherits(cond, "condition")) {
[16:21:28.683]                       if (!is.null(pattern)) {
[16:21:28.683]                         computeRestarts <- base::computeRestarts
[16:21:28.683]                         grepl <- base::grepl
[16:21:28.683]                         restarts <- computeRestarts(cond)
[16:21:28.683]                         for (restart in restarts) {
[16:21:28.683]                           name <- restart$name
[16:21:28.683]                           if (is.null(name)) 
[16:21:28.683]                             next
[16:21:28.683]                           if (!grepl(pattern, name)) 
[16:21:28.683]                             next
[16:21:28.683]                           invokeRestart(restart)
[16:21:28.683]                           muffled <- TRUE
[16:21:28.683]                           break
[16:21:28.683]                         }
[16:21:28.683]                       }
[16:21:28.683]                     }
[16:21:28.683]                     invisible(muffled)
[16:21:28.683]                   }
[16:21:28.683]                   muffleCondition(cond)
[16:21:28.683]                 })
[16:21:28.683]             }))
[16:21:28.683]             future::FutureResult(value = ...future.value$value, 
[16:21:28.683]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:28.683]                   ...future.rng), globalenv = if (FALSE) 
[16:21:28.683]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:28.683]                     ...future.globalenv.names))
[16:21:28.683]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:28.683]         }, condition = base::local({
[16:21:28.683]             c <- base::c
[16:21:28.683]             inherits <- base::inherits
[16:21:28.683]             invokeRestart <- base::invokeRestart
[16:21:28.683]             length <- base::length
[16:21:28.683]             list <- base::list
[16:21:28.683]             seq.int <- base::seq.int
[16:21:28.683]             signalCondition <- base::signalCondition
[16:21:28.683]             sys.calls <- base::sys.calls
[16:21:28.683]             `[[` <- base::`[[`
[16:21:28.683]             `+` <- base::`+`
[16:21:28.683]             `<<-` <- base::`<<-`
[16:21:28.683]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:28.683]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:28.683]                   3L)]
[16:21:28.683]             }
[16:21:28.683]             function(cond) {
[16:21:28.683]                 is_error <- inherits(cond, "error")
[16:21:28.683]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:28.683]                   NULL)
[16:21:28.683]                 if (is_error) {
[16:21:28.683]                   sessionInformation <- function() {
[16:21:28.683]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:28.683]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:28.683]                       search = base::search(), system = base::Sys.info())
[16:21:28.683]                   }
[16:21:28.683]                   ...future.conditions[[length(...future.conditions) + 
[16:21:28.683]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:28.683]                     cond$call), session = sessionInformation(), 
[16:21:28.683]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:28.683]                   signalCondition(cond)
[16:21:28.683]                 }
[16:21:28.683]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:28.683]                 "immediateCondition"))) {
[16:21:28.683]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:28.683]                   ...future.conditions[[length(...future.conditions) + 
[16:21:28.683]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:28.683]                   if (TRUE && !signal) {
[16:21:28.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:28.683]                     {
[16:21:28.683]                       inherits <- base::inherits
[16:21:28.683]                       invokeRestart <- base::invokeRestart
[16:21:28.683]                       is.null <- base::is.null
[16:21:28.683]                       muffled <- FALSE
[16:21:28.683]                       if (inherits(cond, "message")) {
[16:21:28.683]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:28.683]                         if (muffled) 
[16:21:28.683]                           invokeRestart("muffleMessage")
[16:21:28.683]                       }
[16:21:28.683]                       else if (inherits(cond, "warning")) {
[16:21:28.683]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:28.683]                         if (muffled) 
[16:21:28.683]                           invokeRestart("muffleWarning")
[16:21:28.683]                       }
[16:21:28.683]                       else if (inherits(cond, "condition")) {
[16:21:28.683]                         if (!is.null(pattern)) {
[16:21:28.683]                           computeRestarts <- base::computeRestarts
[16:21:28.683]                           grepl <- base::grepl
[16:21:28.683]                           restarts <- computeRestarts(cond)
[16:21:28.683]                           for (restart in restarts) {
[16:21:28.683]                             name <- restart$name
[16:21:28.683]                             if (is.null(name)) 
[16:21:28.683]                               next
[16:21:28.683]                             if (!grepl(pattern, name)) 
[16:21:28.683]                               next
[16:21:28.683]                             invokeRestart(restart)
[16:21:28.683]                             muffled <- TRUE
[16:21:28.683]                             break
[16:21:28.683]                           }
[16:21:28.683]                         }
[16:21:28.683]                       }
[16:21:28.683]                       invisible(muffled)
[16:21:28.683]                     }
[16:21:28.683]                     muffleCondition(cond, pattern = "^muffle")
[16:21:28.683]                   }
[16:21:28.683]                 }
[16:21:28.683]                 else {
[16:21:28.683]                   if (TRUE) {
[16:21:28.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:28.683]                     {
[16:21:28.683]                       inherits <- base::inherits
[16:21:28.683]                       invokeRestart <- base::invokeRestart
[16:21:28.683]                       is.null <- base::is.null
[16:21:28.683]                       muffled <- FALSE
[16:21:28.683]                       if (inherits(cond, "message")) {
[16:21:28.683]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:28.683]                         if (muffled) 
[16:21:28.683]                           invokeRestart("muffleMessage")
[16:21:28.683]                       }
[16:21:28.683]                       else if (inherits(cond, "warning")) {
[16:21:28.683]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:28.683]                         if (muffled) 
[16:21:28.683]                           invokeRestart("muffleWarning")
[16:21:28.683]                       }
[16:21:28.683]                       else if (inherits(cond, "condition")) {
[16:21:28.683]                         if (!is.null(pattern)) {
[16:21:28.683]                           computeRestarts <- base::computeRestarts
[16:21:28.683]                           grepl <- base::grepl
[16:21:28.683]                           restarts <- computeRestarts(cond)
[16:21:28.683]                           for (restart in restarts) {
[16:21:28.683]                             name <- restart$name
[16:21:28.683]                             if (is.null(name)) 
[16:21:28.683]                               next
[16:21:28.683]                             if (!grepl(pattern, name)) 
[16:21:28.683]                               next
[16:21:28.683]                             invokeRestart(restart)
[16:21:28.683]                             muffled <- TRUE
[16:21:28.683]                             break
[16:21:28.683]                           }
[16:21:28.683]                         }
[16:21:28.683]                       }
[16:21:28.683]                       invisible(muffled)
[16:21:28.683]                     }
[16:21:28.683]                     muffleCondition(cond, pattern = "^muffle")
[16:21:28.683]                   }
[16:21:28.683]                 }
[16:21:28.683]             }
[16:21:28.683]         }))
[16:21:28.683]     }, error = function(ex) {
[16:21:28.683]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:28.683]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:28.683]                 ...future.rng), started = ...future.startTime, 
[16:21:28.683]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:28.683]             version = "1.8"), class = "FutureResult")
[16:21:28.683]     }, finally = {
[16:21:28.683]         if (!identical(...future.workdir, getwd())) 
[16:21:28.683]             setwd(...future.workdir)
[16:21:28.683]         {
[16:21:28.683]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:28.683]                 ...future.oldOptions$nwarnings <- NULL
[16:21:28.683]             }
[16:21:28.683]             base::options(...future.oldOptions)
[16:21:28.683]             if (.Platform$OS.type == "windows") {
[16:21:28.683]                 old_names <- names(...future.oldEnvVars)
[16:21:28.683]                 envs <- base::Sys.getenv()
[16:21:28.683]                 names <- names(envs)
[16:21:28.683]                 common <- intersect(names, old_names)
[16:21:28.683]                 added <- setdiff(names, old_names)
[16:21:28.683]                 removed <- setdiff(old_names, names)
[16:21:28.683]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:28.683]                   envs[common]]
[16:21:28.683]                 NAMES <- toupper(changed)
[16:21:28.683]                 args <- list()
[16:21:28.683]                 for (kk in seq_along(NAMES)) {
[16:21:28.683]                   name <- changed[[kk]]
[16:21:28.683]                   NAME <- NAMES[[kk]]
[16:21:28.683]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:28.683]                     next
[16:21:28.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:28.683]                 }
[16:21:28.683]                 NAMES <- toupper(added)
[16:21:28.683]                 for (kk in seq_along(NAMES)) {
[16:21:28.683]                   name <- added[[kk]]
[16:21:28.683]                   NAME <- NAMES[[kk]]
[16:21:28.683]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:28.683]                     next
[16:21:28.683]                   args[[name]] <- ""
[16:21:28.683]                 }
[16:21:28.683]                 NAMES <- toupper(removed)
[16:21:28.683]                 for (kk in seq_along(NAMES)) {
[16:21:28.683]                   name <- removed[[kk]]
[16:21:28.683]                   NAME <- NAMES[[kk]]
[16:21:28.683]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:28.683]                     next
[16:21:28.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:28.683]                 }
[16:21:28.683]                 if (length(args) > 0) 
[16:21:28.683]                   base::do.call(base::Sys.setenv, args = args)
[16:21:28.683]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:28.683]             }
[16:21:28.683]             else {
[16:21:28.683]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:28.683]             }
[16:21:28.683]             {
[16:21:28.683]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:28.683]                   0L) {
[16:21:28.683]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:28.683]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:28.683]                   base::options(opts)
[16:21:28.683]                 }
[16:21:28.683]                 {
[16:21:28.683]                   {
[16:21:28.683]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:28.683]                     NULL
[16:21:28.683]                   }
[16:21:28.683]                   options(future.plan = NULL)
[16:21:28.683]                   if (is.na(NA_character_)) 
[16:21:28.683]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:28.683]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:28.683]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:28.683]                     .init = FALSE)
[16:21:28.683]                 }
[16:21:28.683]             }
[16:21:28.683]         }
[16:21:28.683]     })
[16:21:28.683]     if (TRUE) {
[16:21:28.683]         base::sink(type = "output", split = FALSE)
[16:21:28.683]         if (TRUE) {
[16:21:28.683]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:28.683]         }
[16:21:28.683]         else {
[16:21:28.683]             ...future.result["stdout"] <- base::list(NULL)
[16:21:28.683]         }
[16:21:28.683]         base::close(...future.stdout)
[16:21:28.683]         ...future.stdout <- NULL
[16:21:28.683]     }
[16:21:28.683]     ...future.result$conditions <- ...future.conditions
[16:21:28.683]     ...future.result$finished <- base::Sys.time()
[16:21:28.683]     ...future.result
[16:21:28.683] }
[16:21:28.878]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.738] Exporting 3 global objects (87.82 KiB) to cluster node #1 ...
[16:21:28.878]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.738] Exporting ‘nested_a’ (43.88 KiB) to cluster node #1 ...
[16:21:28.878]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.739] Exporting ‘nested_a’ (43.88 KiB) to cluster node #1 ... DONE
[16:21:28.879]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.739] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:21:28.879]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.740] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:21:28.879]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.740] Exporting ‘plan_a’ (43.88 KiB) to cluster node #1 ...
[16:21:28.879]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.781] Exporting ‘plan_a’ (43.88 KiB) to cluster node #1 ... DONE
[16:21:28.879]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.781] Exporting 3 global objects (87.82 KiB) to cluster node #1 ... DONE
[16:21:28.879]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.782] MultisessionFuture started
[16:21:28.880]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.782] - Launch lazy future ... done
[16:21:28.880]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.782] run() for ‘MultisessionFuture’ ... done
[16:21:28.880]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.783] result() for ClusterFuture ...
[16:21:28.880]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.783] receiveMessageFromWorker() for ClusterFuture ...
[16:21:28.880]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.784] - Validating connection of MultisessionFuture
[16:21:28.880]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.859] - received message: FutureResult
[16:21:28.881]  - Condition #89: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.860] - Received FutureResult
[16:21:28.881]  - Condition #90: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.860] - Erased future from FutureRegistry
[16:21:28.881]  - Condition #91: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.860] result() for ClusterFuture ...
[16:21:28.881]  - Condition #92: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.860] - result already collected: FutureResult
[16:21:28.881]  - Condition #93: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.860] result() for ClusterFuture ... done
[16:21:28.881]  - Condition #94: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.860] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:28.882]  - Condition #95: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.861] result() for ClusterFuture ... done
[16:21:28.882]  - Condition #96: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.861] result() for ClusterFuture ...
[16:21:28.882]  - Condition #97: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.861] - result already collected: FutureResult
[16:21:28.882]  - Condition #98: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.861] result() for ClusterFuture ... done
[16:21:28.882] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:21:28.889] getGlobalsAndPackages() ...
[16:21:28.889] Searching for globals...
[16:21:28.891] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:21:28.891] Searching for globals ... DONE
[16:21:28.891] Resolving globals: FALSE
[16:21:28.892] The total size of the 1 globals is 128 bytes (128 bytes)
[16:21:28.892] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:21:28.892] - globals: [1] ‘data’
[16:21:28.893] - packages: [1] ‘future’
[16:21:28.893] getGlobalsAndPackages() ... DONE
[16:21:28.893] run() for ‘Future’ ...
[16:21:28.893] - state: ‘created’
[16:21:28.893] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:28.894] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:28.894] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:28.894]   - Field: ‘label’
[16:21:28.894]   - Field: ‘local’
[16:21:28.894]   - Field: ‘owner’
[16:21:28.894]   - Field: ‘envir’
[16:21:28.894]   - Field: ‘packages’
[16:21:28.895]   - Field: ‘gc’
[16:21:28.895]   - Field: ‘conditions’
[16:21:28.895]   - Field: ‘expr’
[16:21:28.895]   - Field: ‘uuid’
[16:21:28.895]   - Field: ‘seed’
[16:21:28.895]   - Field: ‘version’
[16:21:28.895]   - Field: ‘result’
[16:21:28.895]   - Field: ‘asynchronous’
[16:21:28.895]   - Field: ‘calls’
[16:21:28.896]   - Field: ‘globals’
[16:21:28.896]   - Field: ‘stdout’
[16:21:28.896]   - Field: ‘earlySignal’
[16:21:28.896]   - Field: ‘lazy’
[16:21:28.896]   - Field: ‘state’
[16:21:28.896] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:28.896] - Launch lazy future ...
[16:21:28.897] Packages needed by the future expression (n = 1): ‘future’
[16:21:28.897] Packages needed by future strategies (n = 1): ‘future’
[16:21:28.897] {
[16:21:28.897]     {
[16:21:28.897]         {
[16:21:28.897]             ...future.startTime <- base::Sys.time()
[16:21:28.897]             {
[16:21:28.897]                 {
[16:21:28.897]                   {
[16:21:28.897]                     {
[16:21:28.897]                       base::local({
[16:21:28.897]                         has_future <- base::requireNamespace("future", 
[16:21:28.897]                           quietly = TRUE)
[16:21:28.897]                         if (has_future) {
[16:21:28.897]                           ns <- base::getNamespace("future")
[16:21:28.897]                           version <- ns[[".package"]][["version"]]
[16:21:28.897]                           if (is.null(version)) 
[16:21:28.897]                             version <- utils::packageVersion("future")
[16:21:28.897]                         }
[16:21:28.897]                         else {
[16:21:28.897]                           version <- NULL
[16:21:28.897]                         }
[16:21:28.897]                         if (!has_future || version < "1.8.0") {
[16:21:28.897]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:28.897]                             "", base::R.version$version.string), 
[16:21:28.897]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:28.897]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:28.897]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:28.897]                               "release", "version")], collapse = " "), 
[16:21:28.897]                             hostname = base::Sys.info()[["nodename"]])
[16:21:28.897]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:28.897]                             info)
[16:21:28.897]                           info <- base::paste(info, collapse = "; ")
[16:21:28.897]                           if (!has_future) {
[16:21:28.897]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:28.897]                               info)
[16:21:28.897]                           }
[16:21:28.897]                           else {
[16:21:28.897]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:28.897]                               info, version)
[16:21:28.897]                           }
[16:21:28.897]                           base::stop(msg)
[16:21:28.897]                         }
[16:21:28.897]                       })
[16:21:28.897]                     }
[16:21:28.897]                     base::local({
[16:21:28.897]                       for (pkg in "future") {
[16:21:28.897]                         base::loadNamespace(pkg)
[16:21:28.897]                         base::library(pkg, character.only = TRUE)
[16:21:28.897]                       }
[16:21:28.897]                     })
[16:21:28.897]                   }
[16:21:28.897]                   ...future.strategy.old <- future::plan("list")
[16:21:28.897]                   options(future.plan = NULL)
[16:21:28.897]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:28.897]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:21:28.897]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:21:28.897]                     envir = parent.frame()) 
[16:21:28.897]                   {
[16:21:28.897]                     if (is.function(workers)) 
[16:21:28.897]                       workers <- workers()
[16:21:28.897]                     workers <- structure(as.integer(workers), 
[16:21:28.897]                       class = class(workers))
[16:21:28.897]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:21:28.897]                       workers >= 1)
[16:21:28.897]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:21:28.897]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:21:28.897]                     }
[16:21:28.897]                     future <- MultisessionFuture(..., workers = workers, 
[16:21:28.897]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:21:28.897]                       envir = envir)
[16:21:28.897]                     if (!future$lazy) 
[16:21:28.897]                       future <- run(future)
[16:21:28.897]                     invisible(future)
[16:21:28.897]                   }), .cleanup = FALSE, .init = FALSE)
[16:21:28.897]                 }
[16:21:28.897]                 ...future.workdir <- getwd()
[16:21:28.897]             }
[16:21:28.897]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:28.897]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:28.897]         }
[16:21:28.897]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:28.897]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:28.897]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:28.897]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:28.897]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:28.897]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:28.897]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:28.897]             base::names(...future.oldOptions))
[16:21:28.897]     }
[16:21:28.897]     if (FALSE) {
[16:21:28.897]     }
[16:21:28.897]     else {
[16:21:28.897]         if (TRUE) {
[16:21:28.897]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:28.897]                 open = "w")
[16:21:28.897]         }
[16:21:28.897]         else {
[16:21:28.897]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:28.897]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:28.897]         }
[16:21:28.897]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:28.897]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:28.897]             base::sink(type = "output", split = FALSE)
[16:21:28.897]             base::close(...future.stdout)
[16:21:28.897]         }, add = TRUE)
[16:21:28.897]     }
[16:21:28.897]     ...future.frame <- base::sys.nframe()
[16:21:28.897]     ...future.conditions <- base::list()
[16:21:28.897]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:28.897]     if (FALSE) {
[16:21:28.897]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:28.897]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:28.897]     }
[16:21:28.897]     ...future.result <- base::tryCatch({
[16:21:28.897]         base::withCallingHandlers({
[16:21:28.897]             ...future.value <- base::withVisible(base::local({
[16:21:28.897]                 value(future(subset(data, a == 2)))
[16:21:28.897]             }))
[16:21:28.897]             future::FutureResult(value = ...future.value$value, 
[16:21:28.897]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:28.897]                   ...future.rng), globalenv = if (FALSE) 
[16:21:28.897]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:28.897]                     ...future.globalenv.names))
[16:21:28.897]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:28.897]         }, condition = base::local({
[16:21:28.897]             c <- base::c
[16:21:28.897]             inherits <- base::inherits
[16:21:28.897]             invokeRestart <- base::invokeRestart
[16:21:28.897]             length <- base::length
[16:21:28.897]             list <- base::list
[16:21:28.897]             seq.int <- base::seq.int
[16:21:28.897]             signalCondition <- base::signalCondition
[16:21:28.897]             sys.calls <- base::sys.calls
[16:21:28.897]             `[[` <- base::`[[`
[16:21:28.897]             `+` <- base::`+`
[16:21:28.897]             `<<-` <- base::`<<-`
[16:21:28.897]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:28.897]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:28.897]                   3L)]
[16:21:28.897]             }
[16:21:28.897]             function(cond) {
[16:21:28.897]                 is_error <- inherits(cond, "error")
[16:21:28.897]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:28.897]                   NULL)
[16:21:28.897]                 if (is_error) {
[16:21:28.897]                   sessionInformation <- function() {
[16:21:28.897]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:28.897]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:28.897]                       search = base::search(), system = base::Sys.info())
[16:21:28.897]                   }
[16:21:28.897]                   ...future.conditions[[length(...future.conditions) + 
[16:21:28.897]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:28.897]                     cond$call), session = sessionInformation(), 
[16:21:28.897]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:28.897]                   signalCondition(cond)
[16:21:28.897]                 }
[16:21:28.897]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:28.897]                 "immediateCondition"))) {
[16:21:28.897]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:28.897]                   ...future.conditions[[length(...future.conditions) + 
[16:21:28.897]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:28.897]                   if (TRUE && !signal) {
[16:21:28.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:28.897]                     {
[16:21:28.897]                       inherits <- base::inherits
[16:21:28.897]                       invokeRestart <- base::invokeRestart
[16:21:28.897]                       is.null <- base::is.null
[16:21:28.897]                       muffled <- FALSE
[16:21:28.897]                       if (inherits(cond, "message")) {
[16:21:28.897]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:28.897]                         if (muffled) 
[16:21:28.897]                           invokeRestart("muffleMessage")
[16:21:28.897]                       }
[16:21:28.897]                       else if (inherits(cond, "warning")) {
[16:21:28.897]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:28.897]                         if (muffled) 
[16:21:28.897]                           invokeRestart("muffleWarning")
[16:21:28.897]                       }
[16:21:28.897]                       else if (inherits(cond, "condition")) {
[16:21:28.897]                         if (!is.null(pattern)) {
[16:21:28.897]                           computeRestarts <- base::computeRestarts
[16:21:28.897]                           grepl <- base::grepl
[16:21:28.897]                           restarts <- computeRestarts(cond)
[16:21:28.897]                           for (restart in restarts) {
[16:21:28.897]                             name <- restart$name
[16:21:28.897]                             if (is.null(name)) 
[16:21:28.897]                               next
[16:21:28.897]                             if (!grepl(pattern, name)) 
[16:21:28.897]                               next
[16:21:28.897]                             invokeRestart(restart)
[16:21:28.897]                             muffled <- TRUE
[16:21:28.897]                             break
[16:21:28.897]                           }
[16:21:28.897]                         }
[16:21:28.897]                       }
[16:21:28.897]                       invisible(muffled)
[16:21:28.897]                     }
[16:21:28.897]                     muffleCondition(cond, pattern = "^muffle")
[16:21:28.897]                   }
[16:21:28.897]                 }
[16:21:28.897]                 else {
[16:21:28.897]                   if (TRUE) {
[16:21:28.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:28.897]                     {
[16:21:28.897]                       inherits <- base::inherits
[16:21:28.897]                       invokeRestart <- base::invokeRestart
[16:21:28.897]                       is.null <- base::is.null
[16:21:28.897]                       muffled <- FALSE
[16:21:28.897]                       if (inherits(cond, "message")) {
[16:21:28.897]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:28.897]                         if (muffled) 
[16:21:28.897]                           invokeRestart("muffleMessage")
[16:21:28.897]                       }
[16:21:28.897]                       else if (inherits(cond, "warning")) {
[16:21:28.897]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:28.897]                         if (muffled) 
[16:21:28.897]                           invokeRestart("muffleWarning")
[16:21:28.897]                       }
[16:21:28.897]                       else if (inherits(cond, "condition")) {
[16:21:28.897]                         if (!is.null(pattern)) {
[16:21:28.897]                           computeRestarts <- base::computeRestarts
[16:21:28.897]                           grepl <- base::grepl
[16:21:28.897]                           restarts <- computeRestarts(cond)
[16:21:28.897]                           for (restart in restarts) {
[16:21:28.897]                             name <- restart$name
[16:21:28.897]                             if (is.null(name)) 
[16:21:28.897]                               next
[16:21:28.897]                             if (!grepl(pattern, name)) 
[16:21:28.897]                               next
[16:21:28.897]                             invokeRestart(restart)
[16:21:28.897]                             muffled <- TRUE
[16:21:28.897]                             break
[16:21:28.897]                           }
[16:21:28.897]                         }
[16:21:28.897]                       }
[16:21:28.897]                       invisible(muffled)
[16:21:28.897]                     }
[16:21:28.897]                     muffleCondition(cond, pattern = "^muffle")
[16:21:28.897]                   }
[16:21:28.897]                 }
[16:21:28.897]             }
[16:21:28.897]         }))
[16:21:28.897]     }, error = function(ex) {
[16:21:28.897]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:28.897]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:28.897]                 ...future.rng), started = ...future.startTime, 
[16:21:28.897]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:28.897]             version = "1.8"), class = "FutureResult")
[16:21:28.897]     }, finally = {
[16:21:28.897]         if (!identical(...future.workdir, getwd())) 
[16:21:28.897]             setwd(...future.workdir)
[16:21:28.897]         {
[16:21:28.897]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:28.897]                 ...future.oldOptions$nwarnings <- NULL
[16:21:28.897]             }
[16:21:28.897]             base::options(...future.oldOptions)
[16:21:28.897]             if (.Platform$OS.type == "windows") {
[16:21:28.897]                 old_names <- names(...future.oldEnvVars)
[16:21:28.897]                 envs <- base::Sys.getenv()
[16:21:28.897]                 names <- names(envs)
[16:21:28.897]                 common <- intersect(names, old_names)
[16:21:28.897]                 added <- setdiff(names, old_names)
[16:21:28.897]                 removed <- setdiff(old_names, names)
[16:21:28.897]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:28.897]                   envs[common]]
[16:21:28.897]                 NAMES <- toupper(changed)
[16:21:28.897]                 args <- list()
[16:21:28.897]                 for (kk in seq_along(NAMES)) {
[16:21:28.897]                   name <- changed[[kk]]
[16:21:28.897]                   NAME <- NAMES[[kk]]
[16:21:28.897]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:28.897]                     next
[16:21:28.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:28.897]                 }
[16:21:28.897]                 NAMES <- toupper(added)
[16:21:28.897]                 for (kk in seq_along(NAMES)) {
[16:21:28.897]                   name <- added[[kk]]
[16:21:28.897]                   NAME <- NAMES[[kk]]
[16:21:28.897]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:28.897]                     next
[16:21:28.897]                   args[[name]] <- ""
[16:21:28.897]                 }
[16:21:28.897]                 NAMES <- toupper(removed)
[16:21:28.897]                 for (kk in seq_along(NAMES)) {
[16:21:28.897]                   name <- removed[[kk]]
[16:21:28.897]                   NAME <- NAMES[[kk]]
[16:21:28.897]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:28.897]                     next
[16:21:28.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:28.897]                 }
[16:21:28.897]                 if (length(args) > 0) 
[16:21:28.897]                   base::do.call(base::Sys.setenv, args = args)
[16:21:28.897]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:28.897]             }
[16:21:28.897]             else {
[16:21:28.897]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:28.897]             }
[16:21:28.897]             {
[16:21:28.897]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:28.897]                   0L) {
[16:21:28.897]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:28.897]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:28.897]                   base::options(opts)
[16:21:28.897]                 }
[16:21:28.897]                 {
[16:21:28.897]                   {
[16:21:28.897]                     NULL
[16:21:28.897]                     RNGkind("Mersenne-Twister")
[16:21:28.897]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:28.897]                       inherits = FALSE)
[16:21:28.897]                   }
[16:21:28.897]                   options(future.plan = NULL)
[16:21:28.897]                   if (is.na(NA_character_)) 
[16:21:28.897]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:28.897]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:28.897]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:28.897]                     .init = FALSE)
[16:21:28.897]                 }
[16:21:28.897]             }
[16:21:28.897]         }
[16:21:28.897]     })
[16:21:28.897]     if (TRUE) {
[16:21:28.897]         base::sink(type = "output", split = FALSE)
[16:21:28.897]         if (TRUE) {
[16:21:28.897]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:28.897]         }
[16:21:28.897]         else {
[16:21:28.897]             ...future.result["stdout"] <- base::list(NULL)
[16:21:28.897]         }
[16:21:28.897]         base::close(...future.stdout)
[16:21:28.897]         ...future.stdout <- NULL
[16:21:28.897]     }
[16:21:28.897]     ...future.result$conditions <- ...future.conditions
[16:21:28.897]     ...future.result$finished <- base::Sys.time()
[16:21:28.897]     ...future.result
[16:21:28.897] }
[16:21:28.899] assign_globals() ...
[16:21:28.899] List of 1
[16:21:28.899]  $ data:'data.frame':	3 obs. of  2 variables:
[16:21:28.899]   ..$ a: int [1:3] 1 2 3
[16:21:28.899]   ..$ b: int [1:3] 3 2 1
[16:21:28.899]  - attr(*, "where")=List of 1
[16:21:28.899]   ..$ data:<environment: R_EmptyEnv> 
[16:21:28.899]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:28.899]  - attr(*, "resolved")= logi FALSE
[16:21:28.899]  - attr(*, "total_size")= num 128
[16:21:28.899]  - attr(*, "already-done")= logi TRUE
[16:21:28.905] - copied ‘data’ to environment
[16:21:28.905] assign_globals() ... done
[16:21:28.906] plan(): Setting new future strategy stack:
[16:21:28.906] List of future strategies:
[16:21:28.906] 1. multisession:
[16:21:28.906]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:28.906]    - tweaked: FALSE
[16:21:28.906]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:28.909] plan(): nbrOfWorkers() = 2
[16:21:28.955] plan(): Setting new future strategy stack:
[16:21:28.955] List of future strategies:
[16:21:28.955] 1. sequential:
[16:21:28.955]    - args: function (..., envir = parent.frame())
[16:21:28.955]    - tweaked: FALSE
[16:21:28.955]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:28.955] 2. multisession:
[16:21:28.955]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:28.955]    - tweaked: FALSE
[16:21:28.955]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:28.956] plan(): nbrOfWorkers() = 1
[16:21:28.956] SequentialFuture started (and completed)
[16:21:28.956] signalConditions() ...
[16:21:28.956]  - include = ‘immediateCondition’
[16:21:28.956]  - exclude = 
[16:21:28.957]  - resignal = FALSE
[16:21:28.957]  - Number of conditions: 63
[16:21:28.957] signalConditions() ... done
[16:21:28.957] - Launch lazy future ... done
[16:21:28.957] run() for ‘SequentialFuture’ ... done
[16:21:28.957] signalConditions() ...
[16:21:28.957]  - include = ‘immediateCondition’
[16:21:28.957]  - exclude = 
[16:21:28.957]  - resignal = FALSE
[16:21:28.957]  - Number of conditions: 63
[16:21:28.958] signalConditions() ... done
[16:21:28.958] Future state: ‘finished’
[16:21:28.958] signalConditions() ...
[16:21:28.958]  - include = ‘condition’
[16:21:28.958]  - exclude = ‘immediateCondition’
[16:21:28.958]  - resignal = TRUE
[16:21:28.958]  - Number of conditions: 63
[16:21:28.958]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.910] getGlobalsAndPackages() ...
[16:21:28.958]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.910] Searching for globals...
[16:21:28.959]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.923] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[16:21:28.959]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.923] Searching for globals ... DONE
[16:21:28.959]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.923] Resolving globals: FALSE
[16:21:28.959]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.924] The total size of the 1 globals is 128 bytes (128 bytes)
[16:21:28.959]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.924] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:21:28.959]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.924] - globals: [1] ‘data’
[16:21:28.959]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.924] 
[16:21:28.960]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.925] getGlobalsAndPackages() ... DONE
[16:21:28.960]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.925] run() for ‘Future’ ...
[16:21:28.960]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.925] - state: ‘created’
[16:21:28.960]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.925] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:28.960]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.939] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:28.960]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.940] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:28.960]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.940]   - Field: ‘node’
[16:21:28.961]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.940]   - Field: ‘label’
[16:21:28.961]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.940]   - Field: ‘local’
[16:21:28.961]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.940]   - Field: ‘owner’
[16:21:28.961]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.940]   - Field: ‘envir’
[16:21:28.961]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.940]   - Field: ‘workers’
[16:21:28.961]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.940]   - Field: ‘packages’
[16:21:28.961]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.941]   - Field: ‘gc’
[16:21:28.961]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.941]   - Field: ‘conditions’
[16:21:28.962]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.941]   - Field: ‘persistent’
[16:21:28.962]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.941]   - Field: ‘expr’
[16:21:28.962]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.941]   - Field: ‘uuid’
[16:21:28.962]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.941]   - Field: ‘seed’
[16:21:28.962]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.941]   - Field: ‘version’
[16:21:28.962]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.941]   - Field: ‘result’
[16:21:28.962]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.941]   - Field: ‘asynchronous’
[16:21:28.962]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.941]   - Field: ‘calls’
[16:21:28.963]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.942]   - Field: ‘globals’
[16:21:28.963]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.942]   - Field: ‘stdout’
[16:21:28.963]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.942]   - Field: ‘earlySignal’
[16:21:28.963]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.942]   - Field: ‘lazy’
[16:21:28.963]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.942]   - Field: ‘state’
[16:21:28.963]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.942] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:28.963]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.942] - Launch lazy future ...
[16:21:28.964]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.943] Packages needed by the future expression (n = 0): <none>
[16:21:28.964]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.943] Packages needed by future strategies (n = 0): <none>
[16:21:28.964]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.943] {
[16:21:28.943]     {
[16:21:28.943]         {
[16:21:28.943]             ...future.startTime <- base::Sys.time()
[16:21:28.943]             {
[16:21:28.943]                 {
[16:21:28.943]                   {
[16:21:28.943]                     {
[16:21:28.943]                       base::local({
[16:21:28.943]                         has_future <- base::requireNamespace("future", 
[16:21:28.943]                           quietly = TRUE)
[16:21:28.943]                         if (has_future) {
[16:21:28.943]                           ns <- base::getNamespace("future")
[16:21:28.943]                           version <- ns[[".package"]][["version"]]
[16:21:28.943]                           if (is.null(version)) 
[16:21:28.943]                             version <- utils::packageVersion("future")
[16:21:28.943]                         }
[16:21:28.943]                         else {
[16:21:28.943]                           version <- NULL
[16:21:28.943]                         }
[16:21:28.943]                         if (!has_future || version < "1.8.0") {
[16:21:28.943]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:28.943]                             "", base::R.version$version.string), 
[16:21:28.943]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:28.943]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:28.943]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:28.943]                               "release", "version")], collapse = " "), 
[16:21:28.943]                             hostname = base::Sys.info()[["nodename"]])
[16:21:28.943]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:28.943]                             info)
[16:21:28.943]                           info <- base::paste(info, collapse = "; ")
[16:21:28.943]                           if (!has_future) {
[16:21:28.943]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:28.943]                               info)
[16:21:28.943]                           }
[16:21:28.943]                           else {
[16:21:28.943]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:28.943]                               info, version)
[16:21:28.943]                           }
[16:21:28.943]                           base::stop(msg)
[16:21:28.943]                         }
[16:21:28.943]                       })
[16:21:28.943]                     }
[16:21:28.943]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:28.943]                     base::options(mc.cores = 1L)
[16:21:28.943]                   }
[16:21:28.943]                   ...future.strategy.old <- future::plan("list")
[16:21:28.943]                   options(future.plan = NULL)
[16:21:28.943]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:28.943]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:28.943]                 }
[16:21:28.943]                 ...future.workdir <- getwd()
[16:21:28.943]             }
[16:21:28.943]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:28.943]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:28.943]         }
[16:21:28.943]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:28.943]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:28.943]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:28.943]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:28.943]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:28.943]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:28.943]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:28.943]             base::names(...future.oldOptions))
[16:21:28.943]     }
[16:21:28.943]     if (FALSE) {
[16:21:28.943]     }
[16:21:28.943]     else {
[16:21:28.943]         if (TRUE) {
[16:21:28.943]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:28.943]                 open = "w")
[16:21:28.943]         }
[16:21:28.943]         else {
[16:21:28.943]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:28.943]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:28.943]         }
[16:21:28.943]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:28.943]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:28.943]             base::sink(type = "output", split = FALSE)
[16:21:28.943]             base::close(...future.stdout)
[16:21:28.943]         }, add = TRUE)
[16:21:28.943]     }
[16:21:28.943]     ...future.frame <- base::sys.nframe()
[16:21:28.943]     ...future.conditions <- base::list()
[16:21:28.943]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:28.943]     if (FALSE) {
[16:21:28.943]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:28.943]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:28.943]     }
[16:21:28.943]     ...future.result <- base::tryCatch({
[16:21:28.943]         base::withCallingHandlers({
[16:21:28.943]             ...future.value <- base::withVisible(base::local({
[16:21:28.943]                 ...future.makeSendCondition <- base::local({
[16:21:28.943]                   sendCondition <- NULL
[16:21:28.943]                   function(frame = 1L) {
[16:21:28.943]                     if (is.function(sendCondition)) 
[16:21:28.943]                       return(sendCondition)
[16:21:28.943]                     ns <- getNamespace("parallel")
[16:21:28.943]                     if (exists("sendData", mode = "function", 
[16:21:28.943]                       envir = ns)) {
[16:21:28.943]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:28.943]                         envir = ns)
[16:21:28.943]                       envir <- sys.frame(frame)
[16:21:28.943]                       master <- NULL
[16:21:28.943]                       while (!identical(envir, .GlobalEnv) && 
[16:21:28.943]                         !identical(envir, emptyenv())) {
[16:21:28.943]                         if (exists("master", mode = "list", envir = envir, 
[16:21:28.943]                           inherits = FALSE)) {
[16:21:28.943]                           master <- get("master", mode = "list", 
[16:21:28.943]                             envir = envir, inherits = FALSE)
[16:21:28.943]                           if (inherits(master, c("SOCKnode", 
[16:21:28.943]                             "SOCK0node"))) {
[16:21:28.943]                             sendCondition <<- function(cond) {
[16:21:28.943]                               data <- list(type = "VALUE", value = cond, 
[16:21:28.943]                                 success = TRUE)
[16:21:28.943]                               parallel_sendData(master, data)
[16:21:28.943]                             }
[16:21:28.943]                             return(sendCondition)
[16:21:28.943]                           }
[16:21:28.943]                         }
[16:21:28.943]                         frame <- frame + 1L
[16:21:28.943]                         envir <- sys.frame(frame)
[16:21:28.943]                       }
[16:21:28.943]                     }
[16:21:28.943]                     sendCondition <<- function(cond) NULL
[16:21:28.943]                   }
[16:21:28.943]                 })
[16:21:28.943]                 withCallingHandlers({
[16:21:28.943]                   subset(data, a == 2)
[16:21:28.943]                 }, immediateCondition = function(cond) {
[16:21:28.943]                   sendCondition <- ...future.makeSendCondition()
[16:21:28.943]                   sendCondition(cond)
[16:21:28.943]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:28.943]                   {
[16:21:28.943]                     inherits <- base::inherits
[16:21:28.943]                     invokeRestart <- base::invokeRestart
[16:21:28.943]                     is.null <- base::is.null
[16:21:28.943]                     muffled <- FALSE
[16:21:28.943]                     if (inherits(cond, "message")) {
[16:21:28.943]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:28.943]                       if (muffled) 
[16:21:28.943]                         invokeRestart("muffleMessage")
[16:21:28.943]                     }
[16:21:28.943]                     else if (inherits(cond, "warning")) {
[16:21:28.943]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:28.943]                       if (muffled) 
[16:21:28.943]                         invokeRestart("muffleWarning")
[16:21:28.943]                     }
[16:21:28.943]                     else if (inherits(cond, "condition")) {
[16:21:28.943]                       if (!is.null(pattern)) {
[16:21:28.943]                         computeRestarts <- base::computeRestarts
[16:21:28.943]                         grepl <- base::grepl
[16:21:28.943]                         restarts <- computeRestarts(cond)
[16:21:28.943]                         for (restart in restarts) {
[16:21:28.943]                           name <- restart$name
[16:21:28.943]                           if (is.null(name)) 
[16:21:28.943]                             next
[16:21:28.943]                           if (!grepl(pattern, name)) 
[16:21:28.943]                             next
[16:21:28.943]                           invokeRestart(restart)
[16:21:28.943]                           muffled <- TRUE
[16:21:28.943]                           break
[16:21:28.943]                         }
[16:21:28.943]                       }
[16:21:28.943]                     }
[16:21:28.943]                     invisible(muffled)
[16:21:28.943]                   }
[16:21:28.943]                   muffleCondition(cond)
[16:21:28.943]                 })
[16:21:28.943]             }))
[16:21:28.943]             future::FutureResult(value = ...future.value$value, 
[16:21:28.943]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:28.943]                   ...future.rng), globalenv = if (FALSE) 
[16:21:28.943]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:28.943]                     ...future.globalenv.names))
[16:21:28.943]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:28.943]         }, condition = base::local({
[16:21:28.943]             c <- base::c
[16:21:28.943]             inherits <- base::inherits
[16:21:28.943]             invokeRestart <- base::invokeRestart
[16:21:28.943]             length <- base::length
[16:21:28.943]             list <- base::list
[16:21:28.943]             seq.int <- base::seq.int
[16:21:28.943]             signalCondition <- base::signalCondition
[16:21:28.943]             sys.calls <- base::sys.calls
[16:21:28.943]             `[[` <- base::`[[`
[16:21:28.943]             `+` <- base::`+`
[16:21:28.943]             `<<-` <- base::`<<-`
[16:21:28.943]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:28.943]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:28.943]                   3L)]
[16:21:28.943]             }
[16:21:28.943]             function(cond) {
[16:21:28.943]                 is_error <- inherits(cond, "error")
[16:21:28.943]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:28.943]                   NULL)
[16:21:28.943]                 if (is_error) {
[16:21:28.943]                   sessionInformation <- function() {
[16:21:28.943]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:28.943]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:28.943]                       search = base::search(), system = base::Sys.info())
[16:21:28.943]                   }
[16:21:28.943]                   ...future.conditions[[length(...future.conditions) + 
[16:21:28.943]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:28.943]                     cond$call), session = sessionInformation(), 
[16:21:28.943]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:28.943]                   signalCondition(cond)
[16:21:28.943]                 }
[16:21:28.943]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:28.943]                 "immediateCondition"))) {
[16:21:28.943]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:28.943]                   ...future.conditions[[length(...future.conditions) + 
[16:21:28.943]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:28.943]                   if (TRUE && !signal) {
[16:21:28.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:28.943]                     {
[16:21:28.943]                       inherits <- base::inherits
[16:21:28.943]                       invokeRestart <- base::invokeRestart
[16:21:28.943]                       is.null <- base::is.null
[16:21:28.943]                       muffled <- FALSE
[16:21:28.943]                       if (inherits(cond, "message")) {
[16:21:28.943]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:28.943]                         if (muffled) 
[16:21:28.943]                           invokeRestart("muffleMessage")
[16:21:28.943]                       }
[16:21:28.943]                       else if (inherits(cond, "warning")) {
[16:21:28.943]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:28.943]                         if (muffled) 
[16:21:28.943]                           invokeRestart("muffleWarning")
[16:21:28.943]                       }
[16:21:28.943]                       else if (inherits(cond, "condition")) {
[16:21:28.943]                         if (!is.null(pattern)) {
[16:21:28.943]                           computeRestarts <- base::computeRestarts
[16:21:28.943]                           grepl <- base::grepl
[16:21:28.943]                           restarts <- computeRestarts(cond)
[16:21:28.943]                           for (restart in restarts) {
[16:21:28.943]                             name <- restart$name
[16:21:28.943]                             if (is.null(name)) 
[16:21:28.943]                               next
[16:21:28.943]                             if (!grepl(pattern, name)) 
[16:21:28.943]                               next
[16:21:28.943]                             invokeRestart(restart)
[16:21:28.943]                             muffled <- TRUE
[16:21:28.943]                             break
[16:21:28.943]                           }
[16:21:28.943]                         }
[16:21:28.943]                       }
[16:21:28.943]                       invisible(muffled)
[16:21:28.943]                     }
[16:21:28.943]                     muffleCondition(cond, pattern = "^muffle")
[16:21:28.943]                   }
[16:21:28.943]                 }
[16:21:28.943]                 else {
[16:21:28.943]                   if (TRUE) {
[16:21:28.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:28.943]                     {
[16:21:28.943]                       inherits <- base::inherits
[16:21:28.943]                       invokeRestart <- base::invokeRestart
[16:21:28.943]                       is.null <- base::is.null
[16:21:28.943]                       muffled <- FALSE
[16:21:28.943]                       if (inherits(cond, "message")) {
[16:21:28.943]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:28.943]                         if (muffled) 
[16:21:28.943]                           invokeRestart("muffleMessage")
[16:21:28.943]                       }
[16:21:28.943]                       else if (inherits(cond, "warning")) {
[16:21:28.943]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:28.943]                         if (muffled) 
[16:21:28.943]                           invokeRestart("muffleWarning")
[16:21:28.943]                       }
[16:21:28.943]                       else if (inherits(cond, "condition")) {
[16:21:28.943]                         if (!is.null(pattern)) {
[16:21:28.943]                           computeRestarts <- base::computeRestarts
[16:21:28.943]                           grepl <- base::grepl
[16:21:28.943]                           restarts <- computeRestarts(cond)
[16:21:28.943]                           for (restart in restarts) {
[16:21:28.943]                             name <- restart$name
[16:21:28.943]                             if (is.null(name)) 
[16:21:28.943]                               next
[16:21:28.943]                             if (!grepl(pattern, name)) 
[16:21:28.943]                               next
[16:21:28.943]                             invokeRestart(restart)
[16:21:28.943]                             muffled <- TRUE
[16:21:28.943]                             break
[16:21:28.943]                           }
[16:21:28.943]                         }
[16:21:28.943]                       }
[16:21:28.943]                       invisible(muffled)
[16:21:28.943]                     }
[16:21:28.943]                     muffleCondition(cond, pattern = "^muffle")
[16:21:28.943]                   }
[16:21:28.943]                 }
[16:21:28.943]             }
[16:21:28.943]         }))
[16:21:28.943]     }, error = function(ex) {
[16:21:28.943]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:28.943]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:28.943]                 ...future.rng), started = ...future.startTime, 
[16:21:28.943]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:28.943]             version = "1.8"), class = "FutureResult")
[16:21:28.943]     }, finally = {
[16:21:28.943]         if (!identical(...future.workdir, getwd())) 
[16:21:28.943]             setwd(...future.workdir)
[16:21:28.943]         {
[16:21:28.943]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:28.943]                 ...future.oldOptions$nwarnings <- NULL
[16:21:28.943]             }
[16:21:28.943]             base::options(...future.oldOptions)
[16:21:28.943]             if (.Platform$OS.type == "windows") {
[16:21:28.943]                 old_names <- names(...future.oldEnvVars)
[16:21:28.943]                 envs <- base::Sys.getenv()
[16:21:28.943]                 names <- names(envs)
[16:21:28.943]                 common <- intersect(names, old_names)
[16:21:28.943]                 added <- setdiff(names, old_names)
[16:21:28.943]                 removed <- setdiff(old_names, names)
[16:21:28.943]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:28.943]                   envs[common]]
[16:21:28.943]                 NAMES <- toupper(changed)
[16:21:28.943]                 args <- list()
[16:21:28.943]                 for (kk in seq_along(NAMES)) {
[16:21:28.943]                   name <- changed[[kk]]
[16:21:28.943]                   NAME <- NAMES[[kk]]
[16:21:28.943]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:28.943]                     next
[16:21:28.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:28.943]                 }
[16:21:28.943]                 NAMES <- toupper(added)
[16:21:28.943]                 for (kk in seq_along(NAMES)) {
[16:21:28.943]                   name <- added[[kk]]
[16:21:28.943]                   NAME <- NAMES[[kk]]
[16:21:28.943]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:28.943]                     next
[16:21:28.943]                   args[[name]] <- ""
[16:21:28.943]                 }
[16:21:28.943]                 NAMES <- toupper(removed)
[16:21:28.943]                 for (kk in seq_along(NAMES)) {
[16:21:28.943]                   name <- removed[[kk]]
[16:21:28.943]                   NAME <- NAMES[[kk]]
[16:21:28.943]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:28.943]                     next
[16:21:28.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:28.943]                 }
[16:21:28.943]                 if (length(args) > 0) 
[16:21:28.943]                   base::do.call(base::Sys.setenv, args = args)
[16:21:28.943]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:28.943]             }
[16:21:28.943]             else {
[16:21:28.943]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:28.943]             }
[16:21:28.943]             {
[16:21:28.943]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:28.943]                   0L) {
[16:21:28.943]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:28.943]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:28.943]                   base::options(opts)
[16:21:28.943]                 }
[16:21:28.943]                 {
[16:21:28.943]                   {
[16:21:28.943]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:28.943]                     NULL
[16:21:28.943]                   }
[16:21:28.943]                   options(future.plan = NULL)
[16:21:28.943]                   if (is.na(NA_character_)) 
[16:21:28.943]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:28.943]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:28.943]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:28.943]                     .init = FALSE)
[16:21:28.943]                 }
[16:21:28.943]             }
[16:21:28.943]         }
[16:21:28.943]     })
[16:21:28.943]     if (TRUE) {
[16:21:28.943]         base::sink(type = "output", split = FALSE)
[16:21:28.943]         if (TRUE) {
[16:21:28.943]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:28.943]         }
[16:21:28.943]         else {
[16:21:28.943]             ...future.result["stdout"] <- base::list(NULL)
[16:21:28.943]         }
[16:21:28.943]         base::close(...future.stdout)
[16:21:28.943]         ...future.stdout <- NULL
[16:21:28.943]     }
[16:21:28.943]     ...future.result$conditions <- ...future.conditions
[16:21:28.943]     ...future.result$finished <- base::Sys.time()
[16:21:28.943]     ...future.result
[16:21:28.943] }
[16:21:28.964]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.946] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[16:21:28.964]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.946] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[16:21:28.964]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.947] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[16:21:28.964]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.947] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[16:21:28.965]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.947] MultisessionFuture started
[16:21:28.965]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.948] - Launch lazy future ... done
[16:21:28.965]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.948] run() for ‘MultisessionFuture’ ... done
[16:21:28.965]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.948] result() for ClusterFuture ...
[16:21:28.965]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.948] receiveMessageFromWorker() for ClusterFuture ...
[16:21:28.965]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.948] - Validating connection of MultisessionFuture
[16:21:28.965]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.953] - received message: FutureResult
[16:21:28.965]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.954] - Received FutureResult
[16:21:28.966]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.954] - Erased future from FutureRegistry
[16:21:28.966]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.954] result() for ClusterFuture ...
[16:21:28.966]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.954] - result already collected: FutureResult
[16:21:28.966]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.954] result() for ClusterFuture ... done
[16:21:28.966]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.954] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:28.966]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.954] result() for ClusterFuture ... done
[16:21:28.966]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.955] result() for ClusterFuture ...
[16:21:28.966]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.955] - result already collected: FutureResult
[16:21:28.967]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:28.955] result() for ClusterFuture ... done
[16:21:28.967] signalConditions() ... done
- plan(list('sequential', 'multisession')) ... DONE
- plan(list('multicore', 'sequential')) ...
[16:21:28.967] plan(): Setting new future strategy stack:
[16:21:28.967] List of future strategies:
[16:21:28.967] 1. multicore:
[16:21:28.967]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:28.967]    - tweaked: FALSE
[16:21:28.967]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:28.967] 2. sequential:
[16:21:28.967]    - args: function (..., envir = parent.frame())
[16:21:28.967]    - tweaked: FALSE
[16:21:28.967]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:28.973] plan(): nbrOfWorkers() = 2
[16:21:28.973] getGlobalsAndPackages() ...
[16:21:28.974] Searching for globals...
[16:21:28.998] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:21:28.998] Searching for globals ... DONE
[16:21:28.998] Resolving globals: FALSE
[16:21:28.999] The total size of the 2 globals is 57.84 KiB (59224 bytes)
[16:21:28.999] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 57.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (57.72 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:21:29.000] - globals: [2] ‘nested’, ‘strategy2’
[16:21:29.000] - packages: [1] ‘future’
[16:21:29.000] getGlobalsAndPackages() ... DONE
[16:21:29.000] run() for ‘Future’ ...
[16:21:29.000] - state: ‘created’
[16:21:29.000] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:29.004] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:29.004] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:29.004]   - Field: ‘label’
[16:21:29.005]   - Field: ‘local’
[16:21:29.005]   - Field: ‘owner’
[16:21:29.005]   - Field: ‘envir’
[16:21:29.005]   - Field: ‘workers’
[16:21:29.005]   - Field: ‘packages’
[16:21:29.005]   - Field: ‘gc’
[16:21:29.005]   - Field: ‘job’
[16:21:29.005]   - Field: ‘conditions’
[16:21:29.005]   - Field: ‘expr’
[16:21:29.005]   - Field: ‘uuid’
[16:21:29.005]   - Field: ‘seed’
[16:21:29.006]   - Field: ‘version’
[16:21:29.006]   - Field: ‘result’
[16:21:29.006]   - Field: ‘asynchronous’
[16:21:29.006]   - Field: ‘calls’
[16:21:29.006]   - Field: ‘globals’
[16:21:29.006]   - Field: ‘stdout’
[16:21:29.006]   - Field: ‘earlySignal’
[16:21:29.006]   - Field: ‘lazy’
[16:21:29.006]   - Field: ‘state’
[16:21:29.006] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:29.006] - Launch lazy future ...
[16:21:29.007] Packages needed by the future expression (n = 1): ‘future’
[16:21:29.007] Packages needed by future strategies (n = 1): ‘future’
[16:21:29.007] {
[16:21:29.007]     {
[16:21:29.007]         {
[16:21:29.007]             ...future.startTime <- base::Sys.time()
[16:21:29.007]             {
[16:21:29.007]                 {
[16:21:29.007]                   {
[16:21:29.007]                     {
[16:21:29.007]                       {
[16:21:29.007]                         base::local({
[16:21:29.007]                           has_future <- base::requireNamespace("future", 
[16:21:29.007]                             quietly = TRUE)
[16:21:29.007]                           if (has_future) {
[16:21:29.007]                             ns <- base::getNamespace("future")
[16:21:29.007]                             version <- ns[[".package"]][["version"]]
[16:21:29.007]                             if (is.null(version)) 
[16:21:29.007]                               version <- utils::packageVersion("future")
[16:21:29.007]                           }
[16:21:29.007]                           else {
[16:21:29.007]                             version <- NULL
[16:21:29.007]                           }
[16:21:29.007]                           if (!has_future || version < "1.8.0") {
[16:21:29.007]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:29.007]                               "", base::R.version$version.string), 
[16:21:29.007]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:29.007]                                 base::R.version$platform, 8 * 
[16:21:29.007]                                   base::.Machine$sizeof.pointer), 
[16:21:29.007]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:29.007]                                 "release", "version")], collapse = " "), 
[16:21:29.007]                               hostname = base::Sys.info()[["nodename"]])
[16:21:29.007]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:29.007]                               info)
[16:21:29.007]                             info <- base::paste(info, collapse = "; ")
[16:21:29.007]                             if (!has_future) {
[16:21:29.007]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:29.007]                                 info)
[16:21:29.007]                             }
[16:21:29.007]                             else {
[16:21:29.007]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:29.007]                                 info, version)
[16:21:29.007]                             }
[16:21:29.007]                             base::stop(msg)
[16:21:29.007]                           }
[16:21:29.007]                         })
[16:21:29.007]                       }
[16:21:29.007]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:29.007]                       base::options(mc.cores = 1L)
[16:21:29.007]                     }
[16:21:29.007]                     base::local({
[16:21:29.007]                       for (pkg in "future") {
[16:21:29.007]                         base::loadNamespace(pkg)
[16:21:29.007]                         base::library(pkg, character.only = TRUE)
[16:21:29.007]                       }
[16:21:29.007]                     })
[16:21:29.007]                   }
[16:21:29.007]                   ...future.strategy.old <- future::plan("list")
[16:21:29.007]                   options(future.plan = NULL)
[16:21:29.007]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.007]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:21:29.007]                   {
[16:21:29.007]                     future <- SequentialFuture(..., envir = envir)
[16:21:29.007]                     if (!future$lazy) 
[16:21:29.007]                       future <- run(future)
[16:21:29.007]                     invisible(future)
[16:21:29.007]                   }), .cleanup = FALSE, .init = FALSE)
[16:21:29.007]                 }
[16:21:29.007]                 ...future.workdir <- getwd()
[16:21:29.007]             }
[16:21:29.007]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:29.007]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:29.007]         }
[16:21:29.007]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:29.007]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:29.007]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:29.007]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:29.007]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:29.007]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:29.007]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:29.007]             base::names(...future.oldOptions))
[16:21:29.007]     }
[16:21:29.007]     if (FALSE) {
[16:21:29.007]     }
[16:21:29.007]     else {
[16:21:29.007]         if (TRUE) {
[16:21:29.007]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:29.007]                 open = "w")
[16:21:29.007]         }
[16:21:29.007]         else {
[16:21:29.007]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:29.007]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:29.007]         }
[16:21:29.007]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:29.007]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:29.007]             base::sink(type = "output", split = FALSE)
[16:21:29.007]             base::close(...future.stdout)
[16:21:29.007]         }, add = TRUE)
[16:21:29.007]     }
[16:21:29.007]     ...future.frame <- base::sys.nframe()
[16:21:29.007]     ...future.conditions <- base::list()
[16:21:29.007]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:29.007]     if (FALSE) {
[16:21:29.007]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:29.007]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:29.007]     }
[16:21:29.007]     ...future.result <- base::tryCatch({
[16:21:29.007]         base::withCallingHandlers({
[16:21:29.007]             ...future.value <- base::withVisible(base::local({
[16:21:29.007]                 withCallingHandlers({
[16:21:29.007]                   {
[16:21:29.007]                     a <- 1L
[16:21:29.007]                     plan_a <- unclass(future::plan("list"))
[16:21:29.007]                     nested_a <- nested[-1]
[16:21:29.007]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:21:29.007]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:21:29.007]                       strategy2))
[16:21:29.007]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:21:29.007]                       "init") <- NULL
[16:21:29.007]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:21:29.007]                       "init") <- NULL
[16:21:29.007]                     stopifnot(all.equal(plan_a, nested_a))
[16:21:29.007]                     y %<-% {
[16:21:29.007]                       b <- 2L
[16:21:29.007]                       plan_b <- future::plan("list")
[16:21:29.007]                       nested_b <- nested_a[-1]
[16:21:29.007]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:21:29.007]                         1L, inherits(plan_b[[1]], "future"), 
[16:21:29.007]                         inherits(future::plan("next"), "sequential"))
[16:21:29.007]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:21:29.007]                         b = b, nested_b = nested_b, plan_b = plan_b)
[16:21:29.007]                     }
[16:21:29.007]                     y
[16:21:29.007]                   }
[16:21:29.007]                 }, immediateCondition = function(cond) {
[16:21:29.007]                   save_rds <- function (object, pathname, ...) 
[16:21:29.007]                   {
[16:21:29.007]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:29.007]                     if (file_test("-f", pathname_tmp)) {
[16:21:29.007]                       fi_tmp <- file.info(pathname_tmp)
[16:21:29.007]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:29.007]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:29.007]                         fi_tmp[["mtime"]])
[16:21:29.007]                     }
[16:21:29.007]                     tryCatch({
[16:21:29.007]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:29.007]                     }, error = function(ex) {
[16:21:29.007]                       msg <- conditionMessage(ex)
[16:21:29.007]                       fi_tmp <- file.info(pathname_tmp)
[16:21:29.007]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:29.007]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:29.007]                         fi_tmp[["mtime"]], msg)
[16:21:29.007]                       ex$message <- msg
[16:21:29.007]                       stop(ex)
[16:21:29.007]                     })
[16:21:29.007]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:29.007]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:29.007]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:29.007]                       fi_tmp <- file.info(pathname_tmp)
[16:21:29.007]                       fi <- file.info(pathname)
[16:21:29.007]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:29.007]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:29.007]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:29.007]                         fi[["size"]], fi[["mtime"]])
[16:21:29.007]                       stop(msg)
[16:21:29.007]                     }
[16:21:29.007]                     invisible(pathname)
[16:21:29.007]                   }
[16:21:29.007]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:29.007]                     rootPath = tempdir()) 
[16:21:29.007]                   {
[16:21:29.007]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:29.007]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:29.007]                       tmpdir = path, fileext = ".rds")
[16:21:29.007]                     save_rds(obj, file)
[16:21:29.007]                   }
[16:21:29.007]                   saveImmediateCondition(cond, path = "/tmp/RtmpnVB70K/.future/immediateConditions")
[16:21:29.007]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.007]                   {
[16:21:29.007]                     inherits <- base::inherits
[16:21:29.007]                     invokeRestart <- base::invokeRestart
[16:21:29.007]                     is.null <- base::is.null
[16:21:29.007]                     muffled <- FALSE
[16:21:29.007]                     if (inherits(cond, "message")) {
[16:21:29.007]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:29.007]                       if (muffled) 
[16:21:29.007]                         invokeRestart("muffleMessage")
[16:21:29.007]                     }
[16:21:29.007]                     else if (inherits(cond, "warning")) {
[16:21:29.007]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:29.007]                       if (muffled) 
[16:21:29.007]                         invokeRestart("muffleWarning")
[16:21:29.007]                     }
[16:21:29.007]                     else if (inherits(cond, "condition")) {
[16:21:29.007]                       if (!is.null(pattern)) {
[16:21:29.007]                         computeRestarts <- base::computeRestarts
[16:21:29.007]                         grepl <- base::grepl
[16:21:29.007]                         restarts <- computeRestarts(cond)
[16:21:29.007]                         for (restart in restarts) {
[16:21:29.007]                           name <- restart$name
[16:21:29.007]                           if (is.null(name)) 
[16:21:29.007]                             next
[16:21:29.007]                           if (!grepl(pattern, name)) 
[16:21:29.007]                             next
[16:21:29.007]                           invokeRestart(restart)
[16:21:29.007]                           muffled <- TRUE
[16:21:29.007]                           break
[16:21:29.007]                         }
[16:21:29.007]                       }
[16:21:29.007]                     }
[16:21:29.007]                     invisible(muffled)
[16:21:29.007]                   }
[16:21:29.007]                   muffleCondition(cond)
[16:21:29.007]                 })
[16:21:29.007]             }))
[16:21:29.007]             future::FutureResult(value = ...future.value$value, 
[16:21:29.007]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.007]                   ...future.rng), globalenv = if (FALSE) 
[16:21:29.007]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:29.007]                     ...future.globalenv.names))
[16:21:29.007]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:29.007]         }, condition = base::local({
[16:21:29.007]             c <- base::c
[16:21:29.007]             inherits <- base::inherits
[16:21:29.007]             invokeRestart <- base::invokeRestart
[16:21:29.007]             length <- base::length
[16:21:29.007]             list <- base::list
[16:21:29.007]             seq.int <- base::seq.int
[16:21:29.007]             signalCondition <- base::signalCondition
[16:21:29.007]             sys.calls <- base::sys.calls
[16:21:29.007]             `[[` <- base::`[[`
[16:21:29.007]             `+` <- base::`+`
[16:21:29.007]             `<<-` <- base::`<<-`
[16:21:29.007]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:29.007]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:29.007]                   3L)]
[16:21:29.007]             }
[16:21:29.007]             function(cond) {
[16:21:29.007]                 is_error <- inherits(cond, "error")
[16:21:29.007]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:29.007]                   NULL)
[16:21:29.007]                 if (is_error) {
[16:21:29.007]                   sessionInformation <- function() {
[16:21:29.007]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:29.007]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:29.007]                       search = base::search(), system = base::Sys.info())
[16:21:29.007]                   }
[16:21:29.007]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.007]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:29.007]                     cond$call), session = sessionInformation(), 
[16:21:29.007]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:29.007]                   signalCondition(cond)
[16:21:29.007]                 }
[16:21:29.007]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:29.007]                 "immediateCondition"))) {
[16:21:29.007]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:29.007]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.007]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:29.007]                   if (TRUE && !signal) {
[16:21:29.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.007]                     {
[16:21:29.007]                       inherits <- base::inherits
[16:21:29.007]                       invokeRestart <- base::invokeRestart
[16:21:29.007]                       is.null <- base::is.null
[16:21:29.007]                       muffled <- FALSE
[16:21:29.007]                       if (inherits(cond, "message")) {
[16:21:29.007]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.007]                         if (muffled) 
[16:21:29.007]                           invokeRestart("muffleMessage")
[16:21:29.007]                       }
[16:21:29.007]                       else if (inherits(cond, "warning")) {
[16:21:29.007]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.007]                         if (muffled) 
[16:21:29.007]                           invokeRestart("muffleWarning")
[16:21:29.007]                       }
[16:21:29.007]                       else if (inherits(cond, "condition")) {
[16:21:29.007]                         if (!is.null(pattern)) {
[16:21:29.007]                           computeRestarts <- base::computeRestarts
[16:21:29.007]                           grepl <- base::grepl
[16:21:29.007]                           restarts <- computeRestarts(cond)
[16:21:29.007]                           for (restart in restarts) {
[16:21:29.007]                             name <- restart$name
[16:21:29.007]                             if (is.null(name)) 
[16:21:29.007]                               next
[16:21:29.007]                             if (!grepl(pattern, name)) 
[16:21:29.007]                               next
[16:21:29.007]                             invokeRestart(restart)
[16:21:29.007]                             muffled <- TRUE
[16:21:29.007]                             break
[16:21:29.007]                           }
[16:21:29.007]                         }
[16:21:29.007]                       }
[16:21:29.007]                       invisible(muffled)
[16:21:29.007]                     }
[16:21:29.007]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.007]                   }
[16:21:29.007]                 }
[16:21:29.007]                 else {
[16:21:29.007]                   if (TRUE) {
[16:21:29.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.007]                     {
[16:21:29.007]                       inherits <- base::inherits
[16:21:29.007]                       invokeRestart <- base::invokeRestart
[16:21:29.007]                       is.null <- base::is.null
[16:21:29.007]                       muffled <- FALSE
[16:21:29.007]                       if (inherits(cond, "message")) {
[16:21:29.007]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.007]                         if (muffled) 
[16:21:29.007]                           invokeRestart("muffleMessage")
[16:21:29.007]                       }
[16:21:29.007]                       else if (inherits(cond, "warning")) {
[16:21:29.007]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.007]                         if (muffled) 
[16:21:29.007]                           invokeRestart("muffleWarning")
[16:21:29.007]                       }
[16:21:29.007]                       else if (inherits(cond, "condition")) {
[16:21:29.007]                         if (!is.null(pattern)) {
[16:21:29.007]                           computeRestarts <- base::computeRestarts
[16:21:29.007]                           grepl <- base::grepl
[16:21:29.007]                           restarts <- computeRestarts(cond)
[16:21:29.007]                           for (restart in restarts) {
[16:21:29.007]                             name <- restart$name
[16:21:29.007]                             if (is.null(name)) 
[16:21:29.007]                               next
[16:21:29.007]                             if (!grepl(pattern, name)) 
[16:21:29.007]                               next
[16:21:29.007]                             invokeRestart(restart)
[16:21:29.007]                             muffled <- TRUE
[16:21:29.007]                             break
[16:21:29.007]                           }
[16:21:29.007]                         }
[16:21:29.007]                       }
[16:21:29.007]                       invisible(muffled)
[16:21:29.007]                     }
[16:21:29.007]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.007]                   }
[16:21:29.007]                 }
[16:21:29.007]             }
[16:21:29.007]         }))
[16:21:29.007]     }, error = function(ex) {
[16:21:29.007]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:29.007]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.007]                 ...future.rng), started = ...future.startTime, 
[16:21:29.007]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:29.007]             version = "1.8"), class = "FutureResult")
[16:21:29.007]     }, finally = {
[16:21:29.007]         if (!identical(...future.workdir, getwd())) 
[16:21:29.007]             setwd(...future.workdir)
[16:21:29.007]         {
[16:21:29.007]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:29.007]                 ...future.oldOptions$nwarnings <- NULL
[16:21:29.007]             }
[16:21:29.007]             base::options(...future.oldOptions)
[16:21:29.007]             if (.Platform$OS.type == "windows") {
[16:21:29.007]                 old_names <- names(...future.oldEnvVars)
[16:21:29.007]                 envs <- base::Sys.getenv()
[16:21:29.007]                 names <- names(envs)
[16:21:29.007]                 common <- intersect(names, old_names)
[16:21:29.007]                 added <- setdiff(names, old_names)
[16:21:29.007]                 removed <- setdiff(old_names, names)
[16:21:29.007]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:29.007]                   envs[common]]
[16:21:29.007]                 NAMES <- toupper(changed)
[16:21:29.007]                 args <- list()
[16:21:29.007]                 for (kk in seq_along(NAMES)) {
[16:21:29.007]                   name <- changed[[kk]]
[16:21:29.007]                   NAME <- NAMES[[kk]]
[16:21:29.007]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.007]                     next
[16:21:29.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.007]                 }
[16:21:29.007]                 NAMES <- toupper(added)
[16:21:29.007]                 for (kk in seq_along(NAMES)) {
[16:21:29.007]                   name <- added[[kk]]
[16:21:29.007]                   NAME <- NAMES[[kk]]
[16:21:29.007]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.007]                     next
[16:21:29.007]                   args[[name]] <- ""
[16:21:29.007]                 }
[16:21:29.007]                 NAMES <- toupper(removed)
[16:21:29.007]                 for (kk in seq_along(NAMES)) {
[16:21:29.007]                   name <- removed[[kk]]
[16:21:29.007]                   NAME <- NAMES[[kk]]
[16:21:29.007]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.007]                     next
[16:21:29.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.007]                 }
[16:21:29.007]                 if (length(args) > 0) 
[16:21:29.007]                   base::do.call(base::Sys.setenv, args = args)
[16:21:29.007]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:29.007]             }
[16:21:29.007]             else {
[16:21:29.007]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:29.007]             }
[16:21:29.007]             {
[16:21:29.007]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:29.007]                   0L) {
[16:21:29.007]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:29.007]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:29.007]                   base::options(opts)
[16:21:29.007]                 }
[16:21:29.007]                 {
[16:21:29.007]                   {
[16:21:29.007]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:29.007]                     NULL
[16:21:29.007]                   }
[16:21:29.007]                   options(future.plan = NULL)
[16:21:29.007]                   if (is.na(NA_character_)) 
[16:21:29.007]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.007]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:29.007]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:29.007]                     .init = FALSE)
[16:21:29.007]                 }
[16:21:29.007]             }
[16:21:29.007]         }
[16:21:29.007]     })
[16:21:29.007]     if (TRUE) {
[16:21:29.007]         base::sink(type = "output", split = FALSE)
[16:21:29.007]         if (TRUE) {
[16:21:29.007]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:29.007]         }
[16:21:29.007]         else {
[16:21:29.007]             ...future.result["stdout"] <- base::list(NULL)
[16:21:29.007]         }
[16:21:29.007]         base::close(...future.stdout)
[16:21:29.007]         ...future.stdout <- NULL
[16:21:29.007]     }
[16:21:29.007]     ...future.result$conditions <- ...future.conditions
[16:21:29.007]     ...future.result$finished <- base::Sys.time()
[16:21:29.007]     ...future.result
[16:21:29.007] }
[16:21:29.010] assign_globals() ...
[16:21:29.010] List of 2
[16:21:29.010]  $ nested   :List of 2
[16:21:29.010]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:21:29.010]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:21:29.010]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:21:29.010]   ..$ b:function (..., envir = parent.frame())  
[16:21:29.010]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:21:29.010]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:21:29.010]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:21:29.010]  $ strategy2: chr "sequential"
[16:21:29.010]  - attr(*, "where")=List of 2
[16:21:29.010]   ..$ nested   :<environment: R_EmptyEnv> 
[16:21:29.010]   ..$ strategy2:<environment: R_EmptyEnv> 
[16:21:29.010]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:29.010]  - attr(*, "resolved")= logi FALSE
[16:21:29.010]  - attr(*, "total_size")= num 59224
[16:21:29.010]  - attr(*, "already-done")= logi TRUE
[16:21:29.015] - copied ‘nested’ to environment
[16:21:29.015] - copied ‘strategy2’ to environment
[16:21:29.015] assign_globals() ... done
[16:21:29.015] requestCore(): workers = 2
[16:21:29.018] MulticoreFuture started
[16:21:29.018] - Launch lazy future ... done
[16:21:29.019] run() for ‘MulticoreFuture’ ... done
[16:21:29.019] plan(): Setting new future strategy stack:
[16:21:29.019] result() for MulticoreFuture ...
[16:21:29.019] List of future strategies:
[16:21:29.019] 1. sequential:
[16:21:29.019]    - args: function (..., envir = parent.frame())
[16:21:29.019]    - tweaked: FALSE
[16:21:29.019]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.020] plan(): nbrOfWorkers() = 1
[16:21:29.058] plan(): Setting new future strategy stack:
[16:21:29.058] List of future strategies:
[16:21:29.058] 1. multicore:
[16:21:29.058]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:29.058]    - tweaked: FALSE
[16:21:29.058]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.058] 2. sequential:
[16:21:29.058]    - args: function (..., envir = parent.frame())
[16:21:29.058]    - tweaked: FALSE
[16:21:29.058]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.062] plan(): nbrOfWorkers() = 2
[16:21:29.064] result() for MulticoreFuture ...
[16:21:29.064] result() for MulticoreFuture ... done
[16:21:29.064] signalConditions() ...
[16:21:29.064]  - include = ‘immediateCondition’
[16:21:29.064]  - exclude = 
[16:21:29.065]  - resignal = FALSE
[16:21:29.065]  - Number of conditions: 54
[16:21:29.065] signalConditions() ... done
[16:21:29.065] result() for MulticoreFuture ... done
[16:21:29.065] result() for MulticoreFuture ...
[16:21:29.065] result() for MulticoreFuture ... done
[16:21:29.065] signalConditions() ...
[16:21:29.065]  - include = ‘immediateCondition’
[16:21:29.066]  - exclude = 
[16:21:29.066]  - resignal = FALSE
[16:21:29.066]  - Number of conditions: 54
[16:21:29.066] signalConditions() ... done
[16:21:29.066] Future state: ‘finished’
[16:21:29.066] result() for MulticoreFuture ...
[16:21:29.066] result() for MulticoreFuture ... done
[16:21:29.067] signalConditions() ...
[16:21:29.067]  - include = ‘condition’
[16:21:29.067]  - exclude = ‘immediateCondition’
[16:21:29.067]  - resignal = TRUE
[16:21:29.067]  - Number of conditions: 54
[16:21:29.067]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.022] getGlobalsAndPackages() ...
[16:21:29.067]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.023] Searching for globals...
[16:21:29.068]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.033] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[16:21:29.068]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.033] Searching for globals ... DONE
[16:21:29.068]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.033] Resolving globals: FALSE
[16:21:29.068]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.035] The total size of the 3 globals is 22.54 KiB (23080 bytes)
[16:21:29.068]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.035] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 22.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (11.24 KiB of class ‘list’), ‘plan_a’ (11.24 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[16:21:29.068]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.036] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[16:21:29.069]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.036] 
[16:21:29.069]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.036] getGlobalsAndPackages() ... DONE
[16:21:29.069]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.037] run() for ‘Future’ ...
[16:21:29.069]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.037] - state: ‘created’
[16:21:29.069]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.037] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:29.070]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.038] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:29.070]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.038] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:29.070]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.038]   - Field: ‘label’
[16:21:29.070]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.038]   - Field: ‘local’
[16:21:29.070]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.039]   - Field: ‘owner’
[16:21:29.071]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.039]   - Field: ‘envir’
[16:21:29.071]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.039]   - Field: ‘packages’
[16:21:29.071]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.039]   - Field: ‘gc’
[16:21:29.071]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.039]   - Field: ‘conditions’
[16:21:29.071]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.039]   - Field: ‘expr’
[16:21:29.071]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.040]   - Field: ‘uuid’
[16:21:29.072]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.040]   - Field: ‘seed’
[16:21:29.072]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.040]   - Field: ‘version’
[16:21:29.072]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.040]   - Field: ‘result’
[16:21:29.072]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.040]   - Field: ‘asynchronous’
[16:21:29.072]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.041]   - Field: ‘calls’
[16:21:29.073]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.041]   - Field: ‘globals’
[16:21:29.073]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.041]   - Field: ‘stdout’
[16:21:29.073]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.041]   - Field: ‘earlySignal’
[16:21:29.073]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.041]   - Field: ‘lazy’
[16:21:29.073]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.041]   - Field: ‘state’
[16:21:29.074]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.042] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:29.074]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.042] - Launch lazy future ...
[16:21:29.074]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.042] Packages needed by the future expression (n = 0): <none>
[16:21:29.074]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.042] Packages needed by future strategies (n = 0): <none>
[16:21:29.074]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.043] {
[16:21:29.043]     {
[16:21:29.043]         {
[16:21:29.043]             ...future.startTime <- base::Sys.time()
[16:21:29.043]             {
[16:21:29.043]                 {
[16:21:29.043]                   {
[16:21:29.043]                     base::local({
[16:21:29.043]                       has_future <- base::requireNamespace("future", 
[16:21:29.043]                         quietly = TRUE)
[16:21:29.043]                       if (has_future) {
[16:21:29.043]                         ns <- base::getNamespace("future")
[16:21:29.043]                         version <- ns[[".package"]][["version"]]
[16:21:29.043]                         if (is.null(version)) 
[16:21:29.043]                           version <- utils::packageVersion("future")
[16:21:29.043]                       }
[16:21:29.043]                       else {
[16:21:29.043]                         version <- NULL
[16:21:29.043]                       }
[16:21:29.043]                       if (!has_future || version < "1.8.0") {
[16:21:29.043]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:29.043]                           "", base::R.version$version.string), 
[16:21:29.043]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:29.043]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:29.043]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:29.043]                             "release", "version")], collapse = " "), 
[16:21:29.043]                           hostname = base::Sys.info()[["nodename"]])
[16:21:29.043]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:29.043]                           info)
[16:21:29.043]                         info <- base::paste(info, collapse = "; ")
[16:21:29.043]                         if (!has_future) {
[16:21:29.043]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:29.043]                             info)
[16:21:29.043]                         }
[16:21:29.043]                         else {
[16:21:29.043]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:29.043]                             info, version)
[16:21:29.043]                         }
[16:21:29.043]                         base::stop(msg)
[16:21:29.043]                       }
[16:21:29.043]                     })
[16:21:29.043]                   }
[16:21:29.043]                   ...future.strategy.old <- future::plan("list")
[16:21:29.043]                   options(future.plan = NULL)
[16:21:29.043]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.043]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:29.043]                 }
[16:21:29.043]                 ...future.workdir <- getwd()
[16:21:29.043]             }
[16:21:29.043]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:29.043]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:29.043]         }
[16:21:29.043]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:29.043]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:29.043]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:29.043]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:29.043]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:29.043]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:29.043]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:29.043]             base::names(...future.oldOptions))
[16:21:29.043]     }
[16:21:29.043]     if (FALSE) {
[16:21:29.043]     }
[16:21:29.043]     else {
[16:21:29.043]         if (TRUE) {
[16:21:29.043]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:29.043]                 open = "w")
[16:21:29.043]         }
[16:21:29.043]         else {
[16:21:29.043]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:29.043]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:29.043]         }
[16:21:29.043]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:29.043]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:29.043]             base::sink(type = "output", split = FALSE)
[16:21:29.043]             base::close(...future.stdout)
[16:21:29.043]         }, add = TRUE)
[16:21:29.043]     }
[16:21:29.043]     ...future.frame <- base::sys.nframe()
[16:21:29.043]     ...future.conditions <- base::list()
[16:21:29.043]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:29.043]     if (FALSE) {
[16:21:29.043]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:29.043]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:29.043]     }
[16:21:29.043]     ...future.result <- base::tryCatch({
[16:21:29.043]         base::withCallingHandlers({
[16:21:29.043]             ...future.value <- base::withVisible(base::local({
[16:21:29.043]                 b <- 2L
[16:21:29.043]                 plan_b <- future::plan("list")
[16:21:29.043]                 nested_b <- nested_a[-1]
[16:21:29.043]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:21:29.043]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:21:29.043]                   "sequential"))
[16:21:29.043]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:21:29.043]                   b = b, nested_b = nested_b, plan_b = plan_b)
[16:21:29.043]             }))
[16:21:29.043]             future::FutureResult(value = ...future.value$value, 
[16:21:29.043]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.043]                   ...future.rng), globalenv = if (FALSE) 
[16:21:29.043]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:29.043]                     ...future.globalenv.names))
[16:21:29.043]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:29.043]         }, condition = base::local({
[16:21:29.043]             c <- base::c
[16:21:29.043]             inherits <- base::inherits
[16:21:29.043]             invokeRestart <- base::invokeRestart
[16:21:29.043]             length <- base::length
[16:21:29.043]             list <- base::list
[16:21:29.043]             seq.int <- base::seq.int
[16:21:29.043]             signalCondition <- base::signalCondition
[16:21:29.043]             sys.calls <- base::sys.calls
[16:21:29.043]             `[[` <- base::`[[`
[16:21:29.043]             `+` <- base::`+`
[16:21:29.043]             `<<-` <- base::`<<-`
[16:21:29.043]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:29.043]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:29.043]                   3L)]
[16:21:29.043]             }
[16:21:29.043]             function(cond) {
[16:21:29.043]                 is_error <- inherits(cond, "error")
[16:21:29.043]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:29.043]                   NULL)
[16:21:29.043]                 if (is_error) {
[16:21:29.043]                   sessionInformation <- function() {
[16:21:29.043]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:29.043]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:29.043]                       search = base::search(), system = base::Sys.info())
[16:21:29.043]                   }
[16:21:29.043]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.043]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:29.043]                     cond$call), session = sessionInformation(), 
[16:21:29.043]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:29.043]                   signalCondition(cond)
[16:21:29.043]                 }
[16:21:29.043]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:29.043]                 "immediateCondition"))) {
[16:21:29.043]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:29.043]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.043]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:29.043]                   if (TRUE && !signal) {
[16:21:29.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.043]                     {
[16:21:29.043]                       inherits <- base::inherits
[16:21:29.043]                       invokeRestart <- base::invokeRestart
[16:21:29.043]                       is.null <- base::is.null
[16:21:29.043]                       muffled <- FALSE
[16:21:29.043]                       if (inherits(cond, "message")) {
[16:21:29.043]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.043]                         if (muffled) 
[16:21:29.043]                           invokeRestart("muffleMessage")
[16:21:29.043]                       }
[16:21:29.043]                       else if (inherits(cond, "warning")) {
[16:21:29.043]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.043]                         if (muffled) 
[16:21:29.043]                           invokeRestart("muffleWarning")
[16:21:29.043]                       }
[16:21:29.043]                       else if (inherits(cond, "condition")) {
[16:21:29.043]                         if (!is.null(pattern)) {
[16:21:29.043]                           computeRestarts <- base::computeRestarts
[16:21:29.043]                           grepl <- base::grepl
[16:21:29.043]                           restarts <- computeRestarts(cond)
[16:21:29.043]                           for (restart in restarts) {
[16:21:29.043]                             name <- restart$name
[16:21:29.043]                             if (is.null(name)) 
[16:21:29.043]                               next
[16:21:29.043]                             if (!grepl(pattern, name)) 
[16:21:29.043]                               next
[16:21:29.043]                             invokeRestart(restart)
[16:21:29.043]                             muffled <- TRUE
[16:21:29.043]                             break
[16:21:29.043]                           }
[16:21:29.043]                         }
[16:21:29.043]                       }
[16:21:29.043]                       invisible(muffled)
[16:21:29.043]                     }
[16:21:29.043]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.043]                   }
[16:21:29.043]                 }
[16:21:29.043]                 else {
[16:21:29.043]                   if (TRUE) {
[16:21:29.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.043]                     {
[16:21:29.043]                       inherits <- base::inherits
[16:21:29.043]                       invokeRestart <- base::invokeRestart
[16:21:29.043]                       is.null <- base::is.null
[16:21:29.043]                       muffled <- FALSE
[16:21:29.043]                       if (inherits(cond, "message")) {
[16:21:29.043]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.043]                         if (muffled) 
[16:21:29.043]                           invokeRestart("muffleMessage")
[16:21:29.043]                       }
[16:21:29.043]                       else if (inherits(cond, "warning")) {
[16:21:29.043]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.043]                         if (muffled) 
[16:21:29.043]                           invokeRestart("muffleWarning")
[16:21:29.043]                       }
[16:21:29.043]                       else if (inherits(cond, "condition")) {
[16:21:29.043]                         if (!is.null(pattern)) {
[16:21:29.043]                           computeRestarts <- base::computeRestarts
[16:21:29.043]                           grepl <- base::grepl
[16:21:29.043]                           restarts <- computeRestarts(cond)
[16:21:29.043]                           for (restart in restarts) {
[16:21:29.043]                             name <- restart$name
[16:21:29.043]                             if (is.null(name)) 
[16:21:29.043]                               next
[16:21:29.043]                             if (!grepl(pattern, name)) 
[16:21:29.043]                               next
[16:21:29.043]                             invokeRestart(restart)
[16:21:29.043]                             muffled <- TRUE
[16:21:29.043]                             break
[16:21:29.043]                           }
[16:21:29.043]                         }
[16:21:29.043]                       }
[16:21:29.043]                       invisible(muffled)
[16:21:29.043]                     }
[16:21:29.043]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.043]                   }
[16:21:29.043]                 }
[16:21:29.043]             }
[16:21:29.043]         }))
[16:21:29.043]     }, error = function(ex) {
[16:21:29.043]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:29.043]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.043]                 ...future.rng), started = ...future.startTime, 
[16:21:29.043]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:29.043]             version = "1.8"), class = "FutureResult")
[16:21:29.043]     }, finally = {
[16:21:29.043]         if (!identical(...future.workdir, getwd())) 
[16:21:29.043]             setwd(...future.workdir)
[16:21:29.043]         {
[16:21:29.043]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:29.043]                 ...future.oldOptions$nwarnings <- NULL
[16:21:29.043]             }
[16:21:29.043]             base::options(...future.oldOptions)
[16:21:29.043]             if (.Platform$OS.type == "windows") {
[16:21:29.043]                 old_names <- names(...future.oldEnvVars)
[16:21:29.043]                 envs <- base::Sys.getenv()
[16:21:29.043]                 names <- names(envs)
[16:21:29.043]                 common <- intersect(names, old_names)
[16:21:29.043]                 added <- setdiff(names, old_names)
[16:21:29.043]                 removed <- setdiff(old_names, names)
[16:21:29.043]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:29.043]                   envs[common]]
[16:21:29.043]                 NAMES <- toupper(changed)
[16:21:29.043]                 args <- list()
[16:21:29.043]                 for (kk in seq_along(NAMES)) {
[16:21:29.043]                   name <- changed[[kk]]
[16:21:29.043]                   NAME <- NAMES[[kk]]
[16:21:29.043]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.043]                     next
[16:21:29.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.043]                 }
[16:21:29.043]                 NAMES <- toupper(added)
[16:21:29.043]                 for (kk in seq_along(NAMES)) {
[16:21:29.043]                   name <- added[[kk]]
[16:21:29.043]                   NAME <- NAMES[[kk]]
[16:21:29.043]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.043]                     next
[16:21:29.043]                   args[[name]] <- ""
[16:21:29.043]                 }
[16:21:29.043]                 NAMES <- toupper(removed)
[16:21:29.043]                 for (kk in seq_along(NAMES)) {
[16:21:29.043]                   name <- removed[[kk]]
[16:21:29.043]                   NAME <- NAMES[[kk]]
[16:21:29.043]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.043]                     next
[16:21:29.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.043]                 }
[16:21:29.043]                 if (length(args) > 0) 
[16:21:29.043]                   base::do.call(base::Sys.setenv, args = args)
[16:21:29.043]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:29.043]             }
[16:21:29.043]             else {
[16:21:29.043]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:29.043]             }
[16:21:29.043]             {
[16:21:29.043]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:29.043]                   0L) {
[16:21:29.043]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:29.043]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:29.043]                   base::options(opts)
[16:21:29.043]                 }
[16:21:29.043]                 {
[16:21:29.043]                   {
[16:21:29.043]                     NULL
[16:21:29.043]                     RNGkind("Mersenne-Twister")
[16:21:29.043]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:29.043]                       inherits = FALSE)
[16:21:29.043]                   }
[16:21:29.043]                   options(future.plan = NULL)
[16:21:29.043]                   if (is.na(NA_character_)) 
[16:21:29.043]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.043]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:29.043]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:29.043]                     .init = FALSE)
[16:21:29.043]                 }
[16:21:29.043]             }
[16:21:29.043]         }
[16:21:29.043]     })
[16:21:29.043]     if (TRUE) {
[16:21:29.043]         base::sink(type = "output", split = FALSE)
[16:21:29.043]         if (TRUE) {
[16:21:29.043]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:29.043]         }
[16:21:29.043]         else {
[16:21:29.043]             ...future.result["stdout"] <- base::list(NULL)
[16:21:29.043]         }
[16:21:29.043]         base::close(...future.stdout)
[16:21:29.043]         ...future.stdout <- NULL
[16:21:29.043]     }
[16:21:29.043]     ...future.result$conditions <- ...future.conditions
[16:21:29.043]     ...future.result$finished <- base::Sys.time()
[16:21:29.043]     ...future.result
[16:21:29.043] }
[16:21:29.075]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.046] assign_globals() ...
[16:21:29.075]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.046] List of 3
[16:21:29.046]  $ nested_a:List of 1
[16:21:29.046]   ..$ b:function (..., envir = parent.frame())  
[16:21:29.046]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:21:29.046]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:21:29.046]  $ a       : int 1
[16:21:29.046]  $ plan_a  :List of 1
[16:21:29.046]   ..$ b:function (..., envir = parent.frame())  
[16:21:29.046]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:21:29.046]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:21:29.046]  - attr(*, "where")=List of 3
[16:21:29.046]   ..$ nested_a:<environment: R_EmptyEnv> 
[16:21:29.046]   ..$ a       :<environment: R_EmptyEnv> 
[16:21:29.046]   ..$ plan_a  :<environment: R_EmptyEnv> 
[16:21:29.046]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:29.046]  - attr(*, "resolved")= logi FALSE
[16:21:29.046]  - attr(*, "total_size")= num 23080
[16:21:29.046]  - attr(*, "already-done")= logi TRUE
[16:21:29.075]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.053] - copied ‘nested_a’ to environment
[16:21:29.075]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.053] - copied ‘a’ to environment
[16:21:29.075]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.054] - copied ‘plan_a’ to environment
[16:21:29.075]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.054] assign_globals() ... done
[16:21:29.076]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.054] plan(): Setting new future strategy stack:
[16:21:29.076]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.054] List of future strategies:
[16:21:29.054] 1. sequential:
[16:21:29.054]    - args: function (..., envir = parent.frame())
[16:21:29.054]    - tweaked: FALSE
[16:21:29.054]    - call: NULL
[16:21:29.076]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.055] plan(): nbrOfWorkers() = 1
[16:21:29.076]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.056] plan(): Setting new future strategy stack:
[16:21:29.076]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.056] List of future strategies:
[16:21:29.056] 1. sequential:
[16:21:29.056]    - args: function (..., envir = parent.frame())
[16:21:29.056]    - tweaked: FALSE
[16:21:29.056]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.076]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.056] plan(): nbrOfWorkers() = 1
[16:21:29.077]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.057] SequentialFuture started (and completed)
[16:21:29.077]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.057] - Launch lazy future ... done
[16:21:29.077]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.057] run() for ‘SequentialFuture’ ... done
[16:21:29.077] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:21:29.083] getGlobalsAndPackages() ...
[16:21:29.083] Searching for globals...
[16:21:29.085] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:21:29.085] Searching for globals ... DONE
[16:21:29.085] Resolving globals: FALSE
[16:21:29.086] The total size of the 1 globals is 128 bytes (128 bytes)
[16:21:29.087] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:21:29.087] - globals: [1] ‘data’
[16:21:29.087] - packages: [1] ‘future’
[16:21:29.087] getGlobalsAndPackages() ... DONE
[16:21:29.087] run() for ‘Future’ ...
[16:21:29.087] - state: ‘created’
[16:21:29.088] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:29.092] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:29.092] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:29.092]   - Field: ‘label’
[16:21:29.092]   - Field: ‘local’
[16:21:29.092]   - Field: ‘owner’
[16:21:29.092]   - Field: ‘envir’
[16:21:29.093]   - Field: ‘workers’
[16:21:29.093]   - Field: ‘packages’
[16:21:29.093]   - Field: ‘gc’
[16:21:29.093]   - Field: ‘job’
[16:21:29.093]   - Field: ‘conditions’
[16:21:29.093]   - Field: ‘expr’
[16:21:29.093]   - Field: ‘uuid’
[16:21:29.093]   - Field: ‘seed’
[16:21:29.093]   - Field: ‘version’
[16:21:29.094]   - Field: ‘result’
[16:21:29.094]   - Field: ‘asynchronous’
[16:21:29.094]   - Field: ‘calls’
[16:21:29.094]   - Field: ‘globals’
[16:21:29.094]   - Field: ‘stdout’
[16:21:29.094]   - Field: ‘earlySignal’
[16:21:29.094]   - Field: ‘lazy’
[16:21:29.094]   - Field: ‘state’
[16:21:29.094] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:29.095] - Launch lazy future ...
[16:21:29.095] Packages needed by the future expression (n = 1): ‘future’
[16:21:29.095] Packages needed by future strategies (n = 1): ‘future’
[16:21:29.096] {
[16:21:29.096]     {
[16:21:29.096]         {
[16:21:29.096]             ...future.startTime <- base::Sys.time()
[16:21:29.096]             {
[16:21:29.096]                 {
[16:21:29.096]                   {
[16:21:29.096]                     {
[16:21:29.096]                       {
[16:21:29.096]                         base::local({
[16:21:29.096]                           has_future <- base::requireNamespace("future", 
[16:21:29.096]                             quietly = TRUE)
[16:21:29.096]                           if (has_future) {
[16:21:29.096]                             ns <- base::getNamespace("future")
[16:21:29.096]                             version <- ns[[".package"]][["version"]]
[16:21:29.096]                             if (is.null(version)) 
[16:21:29.096]                               version <- utils::packageVersion("future")
[16:21:29.096]                           }
[16:21:29.096]                           else {
[16:21:29.096]                             version <- NULL
[16:21:29.096]                           }
[16:21:29.096]                           if (!has_future || version < "1.8.0") {
[16:21:29.096]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:29.096]                               "", base::R.version$version.string), 
[16:21:29.096]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:29.096]                                 base::R.version$platform, 8 * 
[16:21:29.096]                                   base::.Machine$sizeof.pointer), 
[16:21:29.096]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:29.096]                                 "release", "version")], collapse = " "), 
[16:21:29.096]                               hostname = base::Sys.info()[["nodename"]])
[16:21:29.096]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:29.096]                               info)
[16:21:29.096]                             info <- base::paste(info, collapse = "; ")
[16:21:29.096]                             if (!has_future) {
[16:21:29.096]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:29.096]                                 info)
[16:21:29.096]                             }
[16:21:29.096]                             else {
[16:21:29.096]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:29.096]                                 info, version)
[16:21:29.096]                             }
[16:21:29.096]                             base::stop(msg)
[16:21:29.096]                           }
[16:21:29.096]                         })
[16:21:29.096]                       }
[16:21:29.096]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:29.096]                       base::options(mc.cores = 1L)
[16:21:29.096]                     }
[16:21:29.096]                     base::local({
[16:21:29.096]                       for (pkg in "future") {
[16:21:29.096]                         base::loadNamespace(pkg)
[16:21:29.096]                         base::library(pkg, character.only = TRUE)
[16:21:29.096]                       }
[16:21:29.096]                     })
[16:21:29.096]                   }
[16:21:29.096]                   ...future.strategy.old <- future::plan("list")
[16:21:29.096]                   options(future.plan = NULL)
[16:21:29.096]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.096]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:21:29.096]                   {
[16:21:29.096]                     future <- SequentialFuture(..., envir = envir)
[16:21:29.096]                     if (!future$lazy) 
[16:21:29.096]                       future <- run(future)
[16:21:29.096]                     invisible(future)
[16:21:29.096]                   }), .cleanup = FALSE, .init = FALSE)
[16:21:29.096]                 }
[16:21:29.096]                 ...future.workdir <- getwd()
[16:21:29.096]             }
[16:21:29.096]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:29.096]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:29.096]         }
[16:21:29.096]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:29.096]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:29.096]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:29.096]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:29.096]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:29.096]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:29.096]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:29.096]             base::names(...future.oldOptions))
[16:21:29.096]     }
[16:21:29.096]     if (FALSE) {
[16:21:29.096]     }
[16:21:29.096]     else {
[16:21:29.096]         if (TRUE) {
[16:21:29.096]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:29.096]                 open = "w")
[16:21:29.096]         }
[16:21:29.096]         else {
[16:21:29.096]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:29.096]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:29.096]         }
[16:21:29.096]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:29.096]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:29.096]             base::sink(type = "output", split = FALSE)
[16:21:29.096]             base::close(...future.stdout)
[16:21:29.096]         }, add = TRUE)
[16:21:29.096]     }
[16:21:29.096]     ...future.frame <- base::sys.nframe()
[16:21:29.096]     ...future.conditions <- base::list()
[16:21:29.096]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:29.096]     if (FALSE) {
[16:21:29.096]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:29.096]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:29.096]     }
[16:21:29.096]     ...future.result <- base::tryCatch({
[16:21:29.096]         base::withCallingHandlers({
[16:21:29.096]             ...future.value <- base::withVisible(base::local({
[16:21:29.096]                 withCallingHandlers({
[16:21:29.096]                   {
[16:21:29.096]                     value(future(subset(data, a == 2)))
[16:21:29.096]                   }
[16:21:29.096]                 }, immediateCondition = function(cond) {
[16:21:29.096]                   save_rds <- function (object, pathname, ...) 
[16:21:29.096]                   {
[16:21:29.096]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:29.096]                     if (file_test("-f", pathname_tmp)) {
[16:21:29.096]                       fi_tmp <- file.info(pathname_tmp)
[16:21:29.096]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:29.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:29.096]                         fi_tmp[["mtime"]])
[16:21:29.096]                     }
[16:21:29.096]                     tryCatch({
[16:21:29.096]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:29.096]                     }, error = function(ex) {
[16:21:29.096]                       msg <- conditionMessage(ex)
[16:21:29.096]                       fi_tmp <- file.info(pathname_tmp)
[16:21:29.096]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:29.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:29.096]                         fi_tmp[["mtime"]], msg)
[16:21:29.096]                       ex$message <- msg
[16:21:29.096]                       stop(ex)
[16:21:29.096]                     })
[16:21:29.096]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:29.096]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:29.096]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:29.096]                       fi_tmp <- file.info(pathname_tmp)
[16:21:29.096]                       fi <- file.info(pathname)
[16:21:29.096]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:29.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:29.096]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:29.096]                         fi[["size"]], fi[["mtime"]])
[16:21:29.096]                       stop(msg)
[16:21:29.096]                     }
[16:21:29.096]                     invisible(pathname)
[16:21:29.096]                   }
[16:21:29.096]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:29.096]                     rootPath = tempdir()) 
[16:21:29.096]                   {
[16:21:29.096]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:29.096]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:29.096]                       tmpdir = path, fileext = ".rds")
[16:21:29.096]                     save_rds(obj, file)
[16:21:29.096]                   }
[16:21:29.096]                   saveImmediateCondition(cond, path = "/tmp/RtmpnVB70K/.future/immediateConditions")
[16:21:29.096]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.096]                   {
[16:21:29.096]                     inherits <- base::inherits
[16:21:29.096]                     invokeRestart <- base::invokeRestart
[16:21:29.096]                     is.null <- base::is.null
[16:21:29.096]                     muffled <- FALSE
[16:21:29.096]                     if (inherits(cond, "message")) {
[16:21:29.096]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:29.096]                       if (muffled) 
[16:21:29.096]                         invokeRestart("muffleMessage")
[16:21:29.096]                     }
[16:21:29.096]                     else if (inherits(cond, "warning")) {
[16:21:29.096]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:29.096]                       if (muffled) 
[16:21:29.096]                         invokeRestart("muffleWarning")
[16:21:29.096]                     }
[16:21:29.096]                     else if (inherits(cond, "condition")) {
[16:21:29.096]                       if (!is.null(pattern)) {
[16:21:29.096]                         computeRestarts <- base::computeRestarts
[16:21:29.096]                         grepl <- base::grepl
[16:21:29.096]                         restarts <- computeRestarts(cond)
[16:21:29.096]                         for (restart in restarts) {
[16:21:29.096]                           name <- restart$name
[16:21:29.096]                           if (is.null(name)) 
[16:21:29.096]                             next
[16:21:29.096]                           if (!grepl(pattern, name)) 
[16:21:29.096]                             next
[16:21:29.096]                           invokeRestart(restart)
[16:21:29.096]                           muffled <- TRUE
[16:21:29.096]                           break
[16:21:29.096]                         }
[16:21:29.096]                       }
[16:21:29.096]                     }
[16:21:29.096]                     invisible(muffled)
[16:21:29.096]                   }
[16:21:29.096]                   muffleCondition(cond)
[16:21:29.096]                 })
[16:21:29.096]             }))
[16:21:29.096]             future::FutureResult(value = ...future.value$value, 
[16:21:29.096]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.096]                   ...future.rng), globalenv = if (FALSE) 
[16:21:29.096]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:29.096]                     ...future.globalenv.names))
[16:21:29.096]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:29.096]         }, condition = base::local({
[16:21:29.096]             c <- base::c
[16:21:29.096]             inherits <- base::inherits
[16:21:29.096]             invokeRestart <- base::invokeRestart
[16:21:29.096]             length <- base::length
[16:21:29.096]             list <- base::list
[16:21:29.096]             seq.int <- base::seq.int
[16:21:29.096]             signalCondition <- base::signalCondition
[16:21:29.096]             sys.calls <- base::sys.calls
[16:21:29.096]             `[[` <- base::`[[`
[16:21:29.096]             `+` <- base::`+`
[16:21:29.096]             `<<-` <- base::`<<-`
[16:21:29.096]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:29.096]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:29.096]                   3L)]
[16:21:29.096]             }
[16:21:29.096]             function(cond) {
[16:21:29.096]                 is_error <- inherits(cond, "error")
[16:21:29.096]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:29.096]                   NULL)
[16:21:29.096]                 if (is_error) {
[16:21:29.096]                   sessionInformation <- function() {
[16:21:29.096]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:29.096]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:29.096]                       search = base::search(), system = base::Sys.info())
[16:21:29.096]                   }
[16:21:29.096]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.096]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:29.096]                     cond$call), session = sessionInformation(), 
[16:21:29.096]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:29.096]                   signalCondition(cond)
[16:21:29.096]                 }
[16:21:29.096]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:29.096]                 "immediateCondition"))) {
[16:21:29.096]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:29.096]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.096]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:29.096]                   if (TRUE && !signal) {
[16:21:29.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.096]                     {
[16:21:29.096]                       inherits <- base::inherits
[16:21:29.096]                       invokeRestart <- base::invokeRestart
[16:21:29.096]                       is.null <- base::is.null
[16:21:29.096]                       muffled <- FALSE
[16:21:29.096]                       if (inherits(cond, "message")) {
[16:21:29.096]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.096]                         if (muffled) 
[16:21:29.096]                           invokeRestart("muffleMessage")
[16:21:29.096]                       }
[16:21:29.096]                       else if (inherits(cond, "warning")) {
[16:21:29.096]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.096]                         if (muffled) 
[16:21:29.096]                           invokeRestart("muffleWarning")
[16:21:29.096]                       }
[16:21:29.096]                       else if (inherits(cond, "condition")) {
[16:21:29.096]                         if (!is.null(pattern)) {
[16:21:29.096]                           computeRestarts <- base::computeRestarts
[16:21:29.096]                           grepl <- base::grepl
[16:21:29.096]                           restarts <- computeRestarts(cond)
[16:21:29.096]                           for (restart in restarts) {
[16:21:29.096]                             name <- restart$name
[16:21:29.096]                             if (is.null(name)) 
[16:21:29.096]                               next
[16:21:29.096]                             if (!grepl(pattern, name)) 
[16:21:29.096]                               next
[16:21:29.096]                             invokeRestart(restart)
[16:21:29.096]                             muffled <- TRUE
[16:21:29.096]                             break
[16:21:29.096]                           }
[16:21:29.096]                         }
[16:21:29.096]                       }
[16:21:29.096]                       invisible(muffled)
[16:21:29.096]                     }
[16:21:29.096]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.096]                   }
[16:21:29.096]                 }
[16:21:29.096]                 else {
[16:21:29.096]                   if (TRUE) {
[16:21:29.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.096]                     {
[16:21:29.096]                       inherits <- base::inherits
[16:21:29.096]                       invokeRestart <- base::invokeRestart
[16:21:29.096]                       is.null <- base::is.null
[16:21:29.096]                       muffled <- FALSE
[16:21:29.096]                       if (inherits(cond, "message")) {
[16:21:29.096]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.096]                         if (muffled) 
[16:21:29.096]                           invokeRestart("muffleMessage")
[16:21:29.096]                       }
[16:21:29.096]                       else if (inherits(cond, "warning")) {
[16:21:29.096]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.096]                         if (muffled) 
[16:21:29.096]                           invokeRestart("muffleWarning")
[16:21:29.096]                       }
[16:21:29.096]                       else if (inherits(cond, "condition")) {
[16:21:29.096]                         if (!is.null(pattern)) {
[16:21:29.096]                           computeRestarts <- base::computeRestarts
[16:21:29.096]                           grepl <- base::grepl
[16:21:29.096]                           restarts <- computeRestarts(cond)
[16:21:29.096]                           for (restart in restarts) {
[16:21:29.096]                             name <- restart$name
[16:21:29.096]                             if (is.null(name)) 
[16:21:29.096]                               next
[16:21:29.096]                             if (!grepl(pattern, name)) 
[16:21:29.096]                               next
[16:21:29.096]                             invokeRestart(restart)
[16:21:29.096]                             muffled <- TRUE
[16:21:29.096]                             break
[16:21:29.096]                           }
[16:21:29.096]                         }
[16:21:29.096]                       }
[16:21:29.096]                       invisible(muffled)
[16:21:29.096]                     }
[16:21:29.096]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.096]                   }
[16:21:29.096]                 }
[16:21:29.096]             }
[16:21:29.096]         }))
[16:21:29.096]     }, error = function(ex) {
[16:21:29.096]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:29.096]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.096]                 ...future.rng), started = ...future.startTime, 
[16:21:29.096]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:29.096]             version = "1.8"), class = "FutureResult")
[16:21:29.096]     }, finally = {
[16:21:29.096]         if (!identical(...future.workdir, getwd())) 
[16:21:29.096]             setwd(...future.workdir)
[16:21:29.096]         {
[16:21:29.096]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:29.096]                 ...future.oldOptions$nwarnings <- NULL
[16:21:29.096]             }
[16:21:29.096]             base::options(...future.oldOptions)
[16:21:29.096]             if (.Platform$OS.type == "windows") {
[16:21:29.096]                 old_names <- names(...future.oldEnvVars)
[16:21:29.096]                 envs <- base::Sys.getenv()
[16:21:29.096]                 names <- names(envs)
[16:21:29.096]                 common <- intersect(names, old_names)
[16:21:29.096]                 added <- setdiff(names, old_names)
[16:21:29.096]                 removed <- setdiff(old_names, names)
[16:21:29.096]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:29.096]                   envs[common]]
[16:21:29.096]                 NAMES <- toupper(changed)
[16:21:29.096]                 args <- list()
[16:21:29.096]                 for (kk in seq_along(NAMES)) {
[16:21:29.096]                   name <- changed[[kk]]
[16:21:29.096]                   NAME <- NAMES[[kk]]
[16:21:29.096]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.096]                     next
[16:21:29.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.096]                 }
[16:21:29.096]                 NAMES <- toupper(added)
[16:21:29.096]                 for (kk in seq_along(NAMES)) {
[16:21:29.096]                   name <- added[[kk]]
[16:21:29.096]                   NAME <- NAMES[[kk]]
[16:21:29.096]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.096]                     next
[16:21:29.096]                   args[[name]] <- ""
[16:21:29.096]                 }
[16:21:29.096]                 NAMES <- toupper(removed)
[16:21:29.096]                 for (kk in seq_along(NAMES)) {
[16:21:29.096]                   name <- removed[[kk]]
[16:21:29.096]                   NAME <- NAMES[[kk]]
[16:21:29.096]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.096]                     next
[16:21:29.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.096]                 }
[16:21:29.096]                 if (length(args) > 0) 
[16:21:29.096]                   base::do.call(base::Sys.setenv, args = args)
[16:21:29.096]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:29.096]             }
[16:21:29.096]             else {
[16:21:29.096]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:29.096]             }
[16:21:29.096]             {
[16:21:29.096]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:29.096]                   0L) {
[16:21:29.096]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:29.096]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:29.096]                   base::options(opts)
[16:21:29.096]                 }
[16:21:29.096]                 {
[16:21:29.096]                   {
[16:21:29.096]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:29.096]                     NULL
[16:21:29.096]                   }
[16:21:29.096]                   options(future.plan = NULL)
[16:21:29.096]                   if (is.na(NA_character_)) 
[16:21:29.096]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.096]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:29.096]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:29.096]                     .init = FALSE)
[16:21:29.096]                 }
[16:21:29.096]             }
[16:21:29.096]         }
[16:21:29.096]     })
[16:21:29.096]     if (TRUE) {
[16:21:29.096]         base::sink(type = "output", split = FALSE)
[16:21:29.096]         if (TRUE) {
[16:21:29.096]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:29.096]         }
[16:21:29.096]         else {
[16:21:29.096]             ...future.result["stdout"] <- base::list(NULL)
[16:21:29.096]         }
[16:21:29.096]         base::close(...future.stdout)
[16:21:29.096]         ...future.stdout <- NULL
[16:21:29.096]     }
[16:21:29.096]     ...future.result$conditions <- ...future.conditions
[16:21:29.096]     ...future.result$finished <- base::Sys.time()
[16:21:29.096]     ...future.result
[16:21:29.096] }
[16:21:29.098] assign_globals() ...
[16:21:29.098] List of 1
[16:21:29.098]  $ data:'data.frame':	3 obs. of  2 variables:
[16:21:29.098]   ..$ a: int [1:3] 1 2 3
[16:21:29.098]   ..$ b: int [1:3] 3 2 1
[16:21:29.098]  - attr(*, "where")=List of 1
[16:21:29.098]   ..$ data:<environment: R_EmptyEnv> 
[16:21:29.098]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:29.098]  - attr(*, "resolved")= logi FALSE
[16:21:29.098]  - attr(*, "total_size")= num 128
[16:21:29.098]  - attr(*, "already-done")= logi TRUE
[16:21:29.102] - copied ‘data’ to environment
[16:21:29.102] assign_globals() ... done
[16:21:29.102] requestCore(): workers = 2
[16:21:29.105] MulticoreFuture started
[16:21:29.105] - Launch lazy future ... done
[16:21:29.105] run() for ‘MulticoreFuture’ ... done
[16:21:29.106] result() for MulticoreFuture ...
[16:21:29.106] plan(): Setting new future strategy stack:
[16:21:29.106] List of future strategies:
[16:21:29.106] 1. sequential:
[16:21:29.106]    - args: function (..., envir = parent.frame())
[16:21:29.106]    - tweaked: FALSE
[16:21:29.106]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.107] plan(): nbrOfWorkers() = 1
[16:21:29.132] plan(): Setting new future strategy stack:
[16:21:29.132] List of future strategies:
[16:21:29.132] 1. multicore:
[16:21:29.132]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:29.132]    - tweaked: FALSE
[16:21:29.132]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.132] 2. sequential:
[16:21:29.132]    - args: function (..., envir = parent.frame())
[16:21:29.132]    - tweaked: FALSE
[16:21:29.132]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.137] plan(): nbrOfWorkers() = 2
[16:21:29.138] result() for MulticoreFuture ...
[16:21:29.138] result() for MulticoreFuture ... done
[16:21:29.138] signalConditions() ...
[16:21:29.138]  - include = ‘immediateCondition’
[16:21:29.138]  - exclude = 
[16:21:29.139]  - resignal = FALSE
[16:21:29.139]  - Number of conditions: 52
[16:21:29.139] signalConditions() ... done
[16:21:29.139] result() for MulticoreFuture ... done
[16:21:29.139] result() for MulticoreFuture ...
[16:21:29.139] result() for MulticoreFuture ... done
[16:21:29.139] signalConditions() ...
[16:21:29.139]  - include = ‘immediateCondition’
[16:21:29.139]  - exclude = 
[16:21:29.140]  - resignal = FALSE
[16:21:29.140]  - Number of conditions: 52
[16:21:29.140] signalConditions() ... done
[16:21:29.140] Future state: ‘finished’
[16:21:29.140] result() for MulticoreFuture ...
[16:21:29.140] result() for MulticoreFuture ... done
[16:21:29.140] signalConditions() ...
[16:21:29.140]  - include = ‘condition’
[16:21:29.141]  - exclude = ‘immediateCondition’
[16:21:29.141]  - resignal = TRUE
[16:21:29.141]  - Number of conditions: 52
[16:21:29.141]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.108] getGlobalsAndPackages() ...
[16:21:29.141]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.109] Searching for globals...
[16:21:29.141]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.111] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[16:21:29.141]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.111] Searching for globals ... DONE
[16:21:29.142]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.111] Resolving globals: FALSE
[16:21:29.142]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.112] The total size of the 1 globals is 128 bytes (128 bytes)
[16:21:29.142]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.113] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:21:29.142]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.113] - globals: [1] ‘data’
[16:21:29.142]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.113] 
[16:21:29.142]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.113] getGlobalsAndPackages() ... DONE
[16:21:29.143]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.114] run() for ‘Future’ ...
[16:21:29.143]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.114] - state: ‘created’
[16:21:29.143]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.114] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:29.143]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.115] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:29.143]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.115] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:29.143]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.115]   - Field: ‘label’
[16:21:29.143]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.115]   - Field: ‘local’
[16:21:29.144]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.116]   - Field: ‘owner’
[16:21:29.144]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.116]   - Field: ‘envir’
[16:21:29.144]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.116]   - Field: ‘packages’
[16:21:29.144]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.116]   - Field: ‘gc’
[16:21:29.144]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.116]   - Field: ‘conditions’
[16:21:29.144]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.117]   - Field: ‘expr’
[16:21:29.145]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.117]   - Field: ‘uuid’
[16:21:29.145]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.117]   - Field: ‘seed’
[16:21:29.145]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.117]   - Field: ‘version’
[16:21:29.145]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.117]   - Field: ‘result’
[16:21:29.145]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.117]   - Field: ‘asynchronous’
[16:21:29.145]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.117]   - Field: ‘calls’
[16:21:29.145]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.118]   - Field: ‘globals’
[16:21:29.146]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.118]   - Field: ‘stdout’
[16:21:29.146]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.118]   - Field: ‘earlySignal’
[16:21:29.146]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.118]   - Field: ‘lazy’
[16:21:29.146]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.118]   - Field: ‘state’
[16:21:29.146]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.118] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:29.146]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.119] - Launch lazy future ...
[16:21:29.147]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.119] Packages needed by the future expression (n = 0): <none>
[16:21:29.147]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.119] Packages needed by future strategies (n = 0): <none>
[16:21:29.147]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.120] {
[16:21:29.120]     {
[16:21:29.120]         {
[16:21:29.120]             ...future.startTime <- base::Sys.time()
[16:21:29.120]             {
[16:21:29.120]                 {
[16:21:29.120]                   {
[16:21:29.120]                     base::local({
[16:21:29.120]                       has_future <- base::requireNamespace("future", 
[16:21:29.120]                         quietly = TRUE)
[16:21:29.120]                       if (has_future) {
[16:21:29.120]                         ns <- base::getNamespace("future")
[16:21:29.120]                         version <- ns[[".package"]][["version"]]
[16:21:29.120]                         if (is.null(version)) 
[16:21:29.120]                           version <- utils::packageVersion("future")
[16:21:29.120]                       }
[16:21:29.120]                       else {
[16:21:29.120]                         version <- NULL
[16:21:29.120]                       }
[16:21:29.120]                       if (!has_future || version < "1.8.0") {
[16:21:29.120]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:29.120]                           "", base::R.version$version.string), 
[16:21:29.120]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:29.120]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:29.120]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:29.120]                             "release", "version")], collapse = " "), 
[16:21:29.120]                           hostname = base::Sys.info()[["nodename"]])
[16:21:29.120]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:29.120]                           info)
[16:21:29.120]                         info <- base::paste(info, collapse = "; ")
[16:21:29.120]                         if (!has_future) {
[16:21:29.120]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:29.120]                             info)
[16:21:29.120]                         }
[16:21:29.120]                         else {
[16:21:29.120]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:29.120]                             info, version)
[16:21:29.120]                         }
[16:21:29.120]                         base::stop(msg)
[16:21:29.120]                       }
[16:21:29.120]                     })
[16:21:29.120]                   }
[16:21:29.120]                   ...future.strategy.old <- future::plan("list")
[16:21:29.120]                   options(future.plan = NULL)
[16:21:29.120]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.120]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:29.120]                 }
[16:21:29.120]                 ...future.workdir <- getwd()
[16:21:29.120]             }
[16:21:29.120]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:29.120]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:29.120]         }
[16:21:29.120]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:29.120]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:29.120]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:29.120]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:29.120]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:29.120]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:29.120]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:29.120]             base::names(...future.oldOptions))
[16:21:29.120]     }
[16:21:29.120]     if (FALSE) {
[16:21:29.120]     }
[16:21:29.120]     else {
[16:21:29.120]         if (TRUE) {
[16:21:29.120]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:29.120]                 open = "w")
[16:21:29.120]         }
[16:21:29.120]         else {
[16:21:29.120]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:29.120]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:29.120]         }
[16:21:29.120]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:29.120]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:29.120]             base::sink(type = "output", split = FALSE)
[16:21:29.120]             base::close(...future.stdout)
[16:21:29.120]         }, add = TRUE)
[16:21:29.120]     }
[16:21:29.120]     ...future.frame <- base::sys.nframe()
[16:21:29.120]     ...future.conditions <- base::list()
[16:21:29.120]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:29.120]     if (FALSE) {
[16:21:29.120]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:29.120]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:29.120]     }
[16:21:29.120]     ...future.result <- base::tryCatch({
[16:21:29.120]         base::withCallingHandlers({
[16:21:29.120]             ...future.value <- base::withVisible(base::local(subset(data, 
[16:21:29.120]                 a == 2)))
[16:21:29.120]             future::FutureResult(value = ...future.value$value, 
[16:21:29.120]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.120]                   ...future.rng), globalenv = if (FALSE) 
[16:21:29.120]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:29.120]                     ...future.globalenv.names))
[16:21:29.120]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:29.120]         }, condition = base::local({
[16:21:29.120]             c <- base::c
[16:21:29.120]             inherits <- base::inherits
[16:21:29.120]             invokeRestart <- base::invokeRestart
[16:21:29.120]             length <- base::length
[16:21:29.120]             list <- base::list
[16:21:29.120]             seq.int <- base::seq.int
[16:21:29.120]             signalCondition <- base::signalCondition
[16:21:29.120]             sys.calls <- base::sys.calls
[16:21:29.120]             `[[` <- base::`[[`
[16:21:29.120]             `+` <- base::`+`
[16:21:29.120]             `<<-` <- base::`<<-`
[16:21:29.120]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:29.120]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:29.120]                   3L)]
[16:21:29.120]             }
[16:21:29.120]             function(cond) {
[16:21:29.120]                 is_error <- inherits(cond, "error")
[16:21:29.120]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:29.120]                   NULL)
[16:21:29.120]                 if (is_error) {
[16:21:29.120]                   sessionInformation <- function() {
[16:21:29.120]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:29.120]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:29.120]                       search = base::search(), system = base::Sys.info())
[16:21:29.120]                   }
[16:21:29.120]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.120]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:29.120]                     cond$call), session = sessionInformation(), 
[16:21:29.120]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:29.120]                   signalCondition(cond)
[16:21:29.120]                 }
[16:21:29.120]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:29.120]                 "immediateCondition"))) {
[16:21:29.120]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:29.120]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.120]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:29.120]                   if (TRUE && !signal) {
[16:21:29.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.120]                     {
[16:21:29.120]                       inherits <- base::inherits
[16:21:29.120]                       invokeRestart <- base::invokeRestart
[16:21:29.120]                       is.null <- base::is.null
[16:21:29.120]                       muffled <- FALSE
[16:21:29.120]                       if (inherits(cond, "message")) {
[16:21:29.120]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.120]                         if (muffled) 
[16:21:29.120]                           invokeRestart("muffleMessage")
[16:21:29.120]                       }
[16:21:29.120]                       else if (inherits(cond, "warning")) {
[16:21:29.120]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.120]                         if (muffled) 
[16:21:29.120]                           invokeRestart("muffleWarning")
[16:21:29.120]                       }
[16:21:29.120]                       else if (inherits(cond, "condition")) {
[16:21:29.120]                         if (!is.null(pattern)) {
[16:21:29.120]                           computeRestarts <- base::computeRestarts
[16:21:29.120]                           grepl <- base::grepl
[16:21:29.120]                           restarts <- computeRestarts(cond)
[16:21:29.120]                           for (restart in restarts) {
[16:21:29.120]                             name <- restart$name
[16:21:29.120]                             if (is.null(name)) 
[16:21:29.120]                               next
[16:21:29.120]                             if (!grepl(pattern, name)) 
[16:21:29.120]                               next
[16:21:29.120]                             invokeRestart(restart)
[16:21:29.120]                             muffled <- TRUE
[16:21:29.120]                             break
[16:21:29.120]                           }
[16:21:29.120]                         }
[16:21:29.120]                       }
[16:21:29.120]                       invisible(muffled)
[16:21:29.120]                     }
[16:21:29.120]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.120]                   }
[16:21:29.120]                 }
[16:21:29.120]                 else {
[16:21:29.120]                   if (TRUE) {
[16:21:29.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.120]                     {
[16:21:29.120]                       inherits <- base::inherits
[16:21:29.120]                       invokeRestart <- base::invokeRestart
[16:21:29.120]                       is.null <- base::is.null
[16:21:29.120]                       muffled <- FALSE
[16:21:29.120]                       if (inherits(cond, "message")) {
[16:21:29.120]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.120]                         if (muffled) 
[16:21:29.120]                           invokeRestart("muffleMessage")
[16:21:29.120]                       }
[16:21:29.120]                       else if (inherits(cond, "warning")) {
[16:21:29.120]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.120]                         if (muffled) 
[16:21:29.120]                           invokeRestart("muffleWarning")
[16:21:29.120]                       }
[16:21:29.120]                       else if (inherits(cond, "condition")) {
[16:21:29.120]                         if (!is.null(pattern)) {
[16:21:29.120]                           computeRestarts <- base::computeRestarts
[16:21:29.120]                           grepl <- base::grepl
[16:21:29.120]                           restarts <- computeRestarts(cond)
[16:21:29.120]                           for (restart in restarts) {
[16:21:29.120]                             name <- restart$name
[16:21:29.120]                             if (is.null(name)) 
[16:21:29.120]                               next
[16:21:29.120]                             if (!grepl(pattern, name)) 
[16:21:29.120]                               next
[16:21:29.120]                             invokeRestart(restart)
[16:21:29.120]                             muffled <- TRUE
[16:21:29.120]                             break
[16:21:29.120]                           }
[16:21:29.120]                         }
[16:21:29.120]                       }
[16:21:29.120]                       invisible(muffled)
[16:21:29.120]                     }
[16:21:29.120]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.120]                   }
[16:21:29.120]                 }
[16:21:29.120]             }
[16:21:29.120]         }))
[16:21:29.120]     }, error = function(ex) {
[16:21:29.120]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:29.120]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.120]                 ...future.rng), started = ...future.startTime, 
[16:21:29.120]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:29.120]             version = "1.8"), class = "FutureResult")
[16:21:29.120]     }, finally = {
[16:21:29.120]         if (!identical(...future.workdir, getwd())) 
[16:21:29.120]             setwd(...future.workdir)
[16:21:29.120]         {
[16:21:29.120]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:29.120]                 ...future.oldOptions$nwarnings <- NULL
[16:21:29.120]             }
[16:21:29.120]             base::options(...future.oldOptions)
[16:21:29.120]             if (.Platform$OS.type == "windows") {
[16:21:29.120]                 old_names <- names(...future.oldEnvVars)
[16:21:29.120]                 envs <- base::Sys.getenv()
[16:21:29.120]                 names <- names(envs)
[16:21:29.120]                 common <- intersect(names, old_names)
[16:21:29.120]                 added <- setdiff(names, old_names)
[16:21:29.120]                 removed <- setdiff(old_names, names)
[16:21:29.120]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:29.120]                   envs[common]]
[16:21:29.120]                 NAMES <- toupper(changed)
[16:21:29.120]                 args <- list()
[16:21:29.120]                 for (kk in seq_along(NAMES)) {
[16:21:29.120]                   name <- changed[[kk]]
[16:21:29.120]                   NAME <- NAMES[[kk]]
[16:21:29.120]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.120]                     next
[16:21:29.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.120]                 }
[16:21:29.120]                 NAMES <- toupper(added)
[16:21:29.120]                 for (kk in seq_along(NAMES)) {
[16:21:29.120]                   name <- added[[kk]]
[16:21:29.120]                   NAME <- NAMES[[kk]]
[16:21:29.120]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.120]                     next
[16:21:29.120]                   args[[name]] <- ""
[16:21:29.120]                 }
[16:21:29.120]                 NAMES <- toupper(removed)
[16:21:29.120]                 for (kk in seq_along(NAMES)) {
[16:21:29.120]                   name <- removed[[kk]]
[16:21:29.120]                   NAME <- NAMES[[kk]]
[16:21:29.120]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.120]                     next
[16:21:29.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.120]                 }
[16:21:29.120]                 if (length(args) > 0) 
[16:21:29.120]                   base::do.call(base::Sys.setenv, args = args)
[16:21:29.120]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:29.120]             }
[16:21:29.120]             else {
[16:21:29.120]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:29.120]             }
[16:21:29.120]             {
[16:21:29.120]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:29.120]                   0L) {
[16:21:29.120]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:29.120]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:29.120]                   base::options(opts)
[16:21:29.120]                 }
[16:21:29.120]                 {
[16:21:29.120]                   {
[16:21:29.120]                     NULL
[16:21:29.120]                     RNGkind("Mersenne-Twister")
[16:21:29.120]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:29.120]                       inherits = FALSE)
[16:21:29.120]                   }
[16:21:29.120]                   options(future.plan = NULL)
[16:21:29.120]                   if (is.na(NA_character_)) 
[16:21:29.120]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.120]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:29.120]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:29.120]                     .init = FALSE)
[16:21:29.120]                 }
[16:21:29.120]             }
[16:21:29.120]         }
[16:21:29.120]     })
[16:21:29.120]     if (TRUE) {
[16:21:29.120]         base::sink(type = "output", split = FALSE)
[16:21:29.120]         if (TRUE) {
[16:21:29.120]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:29.120]         }
[16:21:29.120]         else {
[16:21:29.120]             ...future.result["stdout"] <- base::list(NULL)
[16:21:29.120]         }
[16:21:29.120]         base::close(...future.stdout)
[16:21:29.120]         ...future.stdout <- NULL
[16:21:29.120]     }
[16:21:29.120]     ...future.result$conditions <- ...future.conditions
[16:21:29.120]     ...future.result$finished <- base::Sys.time()
[16:21:29.120]     ...future.result
[16:21:29.120] }
[16:21:29.147]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.122] assign_globals() ...
[16:21:29.147]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.122] List of 1
[16:21:29.122]  $ data:'data.frame':	3 obs. of  2 variables:
[16:21:29.122]   ..$ a: int [1:3] 1 2 3
[16:21:29.122]   ..$ b: int [1:3] 3 2 1
[16:21:29.122]  - attr(*, "where")=List of 1
[16:21:29.122]   ..$ data:<environment: R_EmptyEnv> 
[16:21:29.122]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:29.122]  - attr(*, "resolved")= logi FALSE
[16:21:29.122]  - attr(*, "total_size")= num 128
[16:21:29.122]  - attr(*, "already-done")= logi TRUE
[16:21:29.147]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.127] - copied ‘data’ to environment
[16:21:29.147]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.127] assign_globals() ... done
[16:21:29.148]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.128] plan(): Setting new future strategy stack:
[16:21:29.148]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.128] List of future strategies:
[16:21:29.128] 1. sequential:
[16:21:29.128]    - args: function (..., envir = parent.frame())
[16:21:29.128]    - tweaked: FALSE
[16:21:29.128]    - call: NULL
[16:21:29.148]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.128] plan(): nbrOfWorkers() = 1
[16:21:29.148]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.130] plan(): Setting new future strategy stack:
[16:21:29.148]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.130] List of future strategies:
[16:21:29.130] 1. sequential:
[16:21:29.130]    - args: function (..., envir = parent.frame())
[16:21:29.130]    - tweaked: FALSE
[16:21:29.130]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.148]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.130] plan(): nbrOfWorkers() = 1
[16:21:29.149]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.131] SequentialFuture started (and completed)
[16:21:29.149]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.131] - Launch lazy future ... done
[16:21:29.149]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.131] run() for ‘SequentialFuture’ ... done
[16:21:29.149] signalConditions() ... done
- plan(list('multicore', 'sequential')) ... DONE
- plan(list('multicore', 'multicore')) ...
[16:21:29.150] plan(): Setting new future strategy stack:
[16:21:29.150] List of future strategies:
[16:21:29.150] 1. multicore:
[16:21:29.150]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:29.150]    - tweaked: FALSE
[16:21:29.150]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.150] 2. multicore:
[16:21:29.150]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:29.150]    - tweaked: FALSE
[16:21:29.150]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.154] plan(): nbrOfWorkers() = 2
[16:21:29.155] getGlobalsAndPackages() ...
[16:21:29.155] Searching for globals...
[16:21:29.177] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:21:29.177] Searching for globals ... DONE
[16:21:29.177] Resolving globals: FALSE
[16:21:29.178] The total size of the 2 globals is 93.07 KiB (95304 bytes)
[16:21:29.179] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 93.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (92.95 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:21:29.179] - globals: [2] ‘nested’, ‘strategy2’
[16:21:29.179] - packages: [1] ‘future’
[16:21:29.179] getGlobalsAndPackages() ... DONE
[16:21:29.180] run() for ‘Future’ ...
[16:21:29.180] - state: ‘created’
[16:21:29.180] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:29.184] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:29.184] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:29.184]   - Field: ‘label’
[16:21:29.184]   - Field: ‘local’
[16:21:29.184]   - Field: ‘owner’
[16:21:29.184]   - Field: ‘envir’
[16:21:29.185]   - Field: ‘workers’
[16:21:29.185]   - Field: ‘packages’
[16:21:29.185]   - Field: ‘gc’
[16:21:29.185]   - Field: ‘job’
[16:21:29.185]   - Field: ‘conditions’
[16:21:29.185]   - Field: ‘expr’
[16:21:29.185]   - Field: ‘uuid’
[16:21:29.185]   - Field: ‘seed’
[16:21:29.185]   - Field: ‘version’
[16:21:29.186]   - Field: ‘result’
[16:21:29.186]   - Field: ‘asynchronous’
[16:21:29.186]   - Field: ‘calls’
[16:21:29.186]   - Field: ‘globals’
[16:21:29.186]   - Field: ‘stdout’
[16:21:29.186]   - Field: ‘earlySignal’
[16:21:29.186]   - Field: ‘lazy’
[16:21:29.186]   - Field: ‘state’
[16:21:29.186] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:29.187] - Launch lazy future ...
[16:21:29.187] Packages needed by the future expression (n = 1): ‘future’
[16:21:29.187] Packages needed by future strategies (n = 1): ‘future’
[16:21:29.188] {
[16:21:29.188]     {
[16:21:29.188]         {
[16:21:29.188]             ...future.startTime <- base::Sys.time()
[16:21:29.188]             {
[16:21:29.188]                 {
[16:21:29.188]                   {
[16:21:29.188]                     {
[16:21:29.188]                       {
[16:21:29.188]                         base::local({
[16:21:29.188]                           has_future <- base::requireNamespace("future", 
[16:21:29.188]                             quietly = TRUE)
[16:21:29.188]                           if (has_future) {
[16:21:29.188]                             ns <- base::getNamespace("future")
[16:21:29.188]                             version <- ns[[".package"]][["version"]]
[16:21:29.188]                             if (is.null(version)) 
[16:21:29.188]                               version <- utils::packageVersion("future")
[16:21:29.188]                           }
[16:21:29.188]                           else {
[16:21:29.188]                             version <- NULL
[16:21:29.188]                           }
[16:21:29.188]                           if (!has_future || version < "1.8.0") {
[16:21:29.188]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:29.188]                               "", base::R.version$version.string), 
[16:21:29.188]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:29.188]                                 base::R.version$platform, 8 * 
[16:21:29.188]                                   base::.Machine$sizeof.pointer), 
[16:21:29.188]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:29.188]                                 "release", "version")], collapse = " "), 
[16:21:29.188]                               hostname = base::Sys.info()[["nodename"]])
[16:21:29.188]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:29.188]                               info)
[16:21:29.188]                             info <- base::paste(info, collapse = "; ")
[16:21:29.188]                             if (!has_future) {
[16:21:29.188]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:29.188]                                 info)
[16:21:29.188]                             }
[16:21:29.188]                             else {
[16:21:29.188]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:29.188]                                 info, version)
[16:21:29.188]                             }
[16:21:29.188]                             base::stop(msg)
[16:21:29.188]                           }
[16:21:29.188]                         })
[16:21:29.188]                       }
[16:21:29.188]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:29.188]                       base::options(mc.cores = 1L)
[16:21:29.188]                     }
[16:21:29.188]                     base::local({
[16:21:29.188]                       for (pkg in "future") {
[16:21:29.188]                         base::loadNamespace(pkg)
[16:21:29.188]                         base::library(pkg, character.only = TRUE)
[16:21:29.188]                       }
[16:21:29.188]                     })
[16:21:29.188]                   }
[16:21:29.188]                   ...future.strategy.old <- future::plan("list")
[16:21:29.188]                   options(future.plan = NULL)
[16:21:29.188]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.188]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:21:29.188]                     envir = parent.frame()) 
[16:21:29.188]                   {
[16:21:29.188]                     default_workers <- missing(workers)
[16:21:29.188]                     if (is.function(workers)) 
[16:21:29.188]                       workers <- workers()
[16:21:29.188]                     workers <- structure(as.integer(workers), 
[16:21:29.188]                       class = class(workers))
[16:21:29.188]                     stop_if_not(is.finite(workers), workers >= 
[16:21:29.188]                       1L)
[16:21:29.188]                     if ((workers == 1L && !inherits(workers, 
[16:21:29.188]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:21:29.188]                       if (default_workers) 
[16:21:29.188]                         supportsMulticore(warn = TRUE)
[16:21:29.188]                       return(sequential(..., envir = envir))
[16:21:29.188]                     }
[16:21:29.188]                     oopts <- options(mc.cores = workers)
[16:21:29.188]                     on.exit(options(oopts))
[16:21:29.188]                     future <- MulticoreFuture(..., workers = workers, 
[16:21:29.188]                       envir = envir)
[16:21:29.188]                     if (!future$lazy) 
[16:21:29.188]                       future <- run(future)
[16:21:29.188]                     invisible(future)
[16:21:29.188]                   }), .cleanup = FALSE, .init = FALSE)
[16:21:29.188]                 }
[16:21:29.188]                 ...future.workdir <- getwd()
[16:21:29.188]             }
[16:21:29.188]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:29.188]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:29.188]         }
[16:21:29.188]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:29.188]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:29.188]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:29.188]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:29.188]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:29.188]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:29.188]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:29.188]             base::names(...future.oldOptions))
[16:21:29.188]     }
[16:21:29.188]     if (FALSE) {
[16:21:29.188]     }
[16:21:29.188]     else {
[16:21:29.188]         if (TRUE) {
[16:21:29.188]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:29.188]                 open = "w")
[16:21:29.188]         }
[16:21:29.188]         else {
[16:21:29.188]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:29.188]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:29.188]         }
[16:21:29.188]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:29.188]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:29.188]             base::sink(type = "output", split = FALSE)
[16:21:29.188]             base::close(...future.stdout)
[16:21:29.188]         }, add = TRUE)
[16:21:29.188]     }
[16:21:29.188]     ...future.frame <- base::sys.nframe()
[16:21:29.188]     ...future.conditions <- base::list()
[16:21:29.188]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:29.188]     if (FALSE) {
[16:21:29.188]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:29.188]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:29.188]     }
[16:21:29.188]     ...future.result <- base::tryCatch({
[16:21:29.188]         base::withCallingHandlers({
[16:21:29.188]             ...future.value <- base::withVisible(base::local({
[16:21:29.188]                 withCallingHandlers({
[16:21:29.188]                   {
[16:21:29.188]                     a <- 1L
[16:21:29.188]                     plan_a <- unclass(future::plan("list"))
[16:21:29.188]                     nested_a <- nested[-1]
[16:21:29.188]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:21:29.188]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:21:29.188]                       strategy2))
[16:21:29.188]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:21:29.188]                       "init") <- NULL
[16:21:29.188]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:21:29.188]                       "init") <- NULL
[16:21:29.188]                     stopifnot(all.equal(plan_a, nested_a))
[16:21:29.188]                     y %<-% {
[16:21:29.188]                       b <- 2L
[16:21:29.188]                       plan_b <- future::plan("list")
[16:21:29.188]                       nested_b <- nested_a[-1]
[16:21:29.188]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:21:29.188]                         1L, inherits(plan_b[[1]], "future"), 
[16:21:29.188]                         inherits(future::plan("next"), "sequential"))
[16:21:29.188]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:21:29.188]                         b = b, nested_b = nested_b, plan_b = plan_b)
[16:21:29.188]                     }
[16:21:29.188]                     y
[16:21:29.188]                   }
[16:21:29.188]                 }, immediateCondition = function(cond) {
[16:21:29.188]                   save_rds <- function (object, pathname, ...) 
[16:21:29.188]                   {
[16:21:29.188]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:29.188]                     if (file_test("-f", pathname_tmp)) {
[16:21:29.188]                       fi_tmp <- file.info(pathname_tmp)
[16:21:29.188]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:29.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:29.188]                         fi_tmp[["mtime"]])
[16:21:29.188]                     }
[16:21:29.188]                     tryCatch({
[16:21:29.188]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:29.188]                     }, error = function(ex) {
[16:21:29.188]                       msg <- conditionMessage(ex)
[16:21:29.188]                       fi_tmp <- file.info(pathname_tmp)
[16:21:29.188]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:29.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:29.188]                         fi_tmp[["mtime"]], msg)
[16:21:29.188]                       ex$message <- msg
[16:21:29.188]                       stop(ex)
[16:21:29.188]                     })
[16:21:29.188]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:29.188]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:29.188]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:29.188]                       fi_tmp <- file.info(pathname_tmp)
[16:21:29.188]                       fi <- file.info(pathname)
[16:21:29.188]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:29.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:29.188]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:29.188]                         fi[["size"]], fi[["mtime"]])
[16:21:29.188]                       stop(msg)
[16:21:29.188]                     }
[16:21:29.188]                     invisible(pathname)
[16:21:29.188]                   }
[16:21:29.188]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:29.188]                     rootPath = tempdir()) 
[16:21:29.188]                   {
[16:21:29.188]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:29.188]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:29.188]                       tmpdir = path, fileext = ".rds")
[16:21:29.188]                     save_rds(obj, file)
[16:21:29.188]                   }
[16:21:29.188]                   saveImmediateCondition(cond, path = "/tmp/RtmpnVB70K/.future/immediateConditions")
[16:21:29.188]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.188]                   {
[16:21:29.188]                     inherits <- base::inherits
[16:21:29.188]                     invokeRestart <- base::invokeRestart
[16:21:29.188]                     is.null <- base::is.null
[16:21:29.188]                     muffled <- FALSE
[16:21:29.188]                     if (inherits(cond, "message")) {
[16:21:29.188]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:29.188]                       if (muffled) 
[16:21:29.188]                         invokeRestart("muffleMessage")
[16:21:29.188]                     }
[16:21:29.188]                     else if (inherits(cond, "warning")) {
[16:21:29.188]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:29.188]                       if (muffled) 
[16:21:29.188]                         invokeRestart("muffleWarning")
[16:21:29.188]                     }
[16:21:29.188]                     else if (inherits(cond, "condition")) {
[16:21:29.188]                       if (!is.null(pattern)) {
[16:21:29.188]                         computeRestarts <- base::computeRestarts
[16:21:29.188]                         grepl <- base::grepl
[16:21:29.188]                         restarts <- computeRestarts(cond)
[16:21:29.188]                         for (restart in restarts) {
[16:21:29.188]                           name <- restart$name
[16:21:29.188]                           if (is.null(name)) 
[16:21:29.188]                             next
[16:21:29.188]                           if (!grepl(pattern, name)) 
[16:21:29.188]                             next
[16:21:29.188]                           invokeRestart(restart)
[16:21:29.188]                           muffled <- TRUE
[16:21:29.188]                           break
[16:21:29.188]                         }
[16:21:29.188]                       }
[16:21:29.188]                     }
[16:21:29.188]                     invisible(muffled)
[16:21:29.188]                   }
[16:21:29.188]                   muffleCondition(cond)
[16:21:29.188]                 })
[16:21:29.188]             }))
[16:21:29.188]             future::FutureResult(value = ...future.value$value, 
[16:21:29.188]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.188]                   ...future.rng), globalenv = if (FALSE) 
[16:21:29.188]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:29.188]                     ...future.globalenv.names))
[16:21:29.188]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:29.188]         }, condition = base::local({
[16:21:29.188]             c <- base::c
[16:21:29.188]             inherits <- base::inherits
[16:21:29.188]             invokeRestart <- base::invokeRestart
[16:21:29.188]             length <- base::length
[16:21:29.188]             list <- base::list
[16:21:29.188]             seq.int <- base::seq.int
[16:21:29.188]             signalCondition <- base::signalCondition
[16:21:29.188]             sys.calls <- base::sys.calls
[16:21:29.188]             `[[` <- base::`[[`
[16:21:29.188]             `+` <- base::`+`
[16:21:29.188]             `<<-` <- base::`<<-`
[16:21:29.188]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:29.188]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:29.188]                   3L)]
[16:21:29.188]             }
[16:21:29.188]             function(cond) {
[16:21:29.188]                 is_error <- inherits(cond, "error")
[16:21:29.188]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:29.188]                   NULL)
[16:21:29.188]                 if (is_error) {
[16:21:29.188]                   sessionInformation <- function() {
[16:21:29.188]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:29.188]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:29.188]                       search = base::search(), system = base::Sys.info())
[16:21:29.188]                   }
[16:21:29.188]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.188]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:29.188]                     cond$call), session = sessionInformation(), 
[16:21:29.188]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:29.188]                   signalCondition(cond)
[16:21:29.188]                 }
[16:21:29.188]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:29.188]                 "immediateCondition"))) {
[16:21:29.188]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:29.188]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.188]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:29.188]                   if (TRUE && !signal) {
[16:21:29.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.188]                     {
[16:21:29.188]                       inherits <- base::inherits
[16:21:29.188]                       invokeRestart <- base::invokeRestart
[16:21:29.188]                       is.null <- base::is.null
[16:21:29.188]                       muffled <- FALSE
[16:21:29.188]                       if (inherits(cond, "message")) {
[16:21:29.188]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.188]                         if (muffled) 
[16:21:29.188]                           invokeRestart("muffleMessage")
[16:21:29.188]                       }
[16:21:29.188]                       else if (inherits(cond, "warning")) {
[16:21:29.188]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.188]                         if (muffled) 
[16:21:29.188]                           invokeRestart("muffleWarning")
[16:21:29.188]                       }
[16:21:29.188]                       else if (inherits(cond, "condition")) {
[16:21:29.188]                         if (!is.null(pattern)) {
[16:21:29.188]                           computeRestarts <- base::computeRestarts
[16:21:29.188]                           grepl <- base::grepl
[16:21:29.188]                           restarts <- computeRestarts(cond)
[16:21:29.188]                           for (restart in restarts) {
[16:21:29.188]                             name <- restart$name
[16:21:29.188]                             if (is.null(name)) 
[16:21:29.188]                               next
[16:21:29.188]                             if (!grepl(pattern, name)) 
[16:21:29.188]                               next
[16:21:29.188]                             invokeRestart(restart)
[16:21:29.188]                             muffled <- TRUE
[16:21:29.188]                             break
[16:21:29.188]                           }
[16:21:29.188]                         }
[16:21:29.188]                       }
[16:21:29.188]                       invisible(muffled)
[16:21:29.188]                     }
[16:21:29.188]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.188]                   }
[16:21:29.188]                 }
[16:21:29.188]                 else {
[16:21:29.188]                   if (TRUE) {
[16:21:29.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.188]                     {
[16:21:29.188]                       inherits <- base::inherits
[16:21:29.188]                       invokeRestart <- base::invokeRestart
[16:21:29.188]                       is.null <- base::is.null
[16:21:29.188]                       muffled <- FALSE
[16:21:29.188]                       if (inherits(cond, "message")) {
[16:21:29.188]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.188]                         if (muffled) 
[16:21:29.188]                           invokeRestart("muffleMessage")
[16:21:29.188]                       }
[16:21:29.188]                       else if (inherits(cond, "warning")) {
[16:21:29.188]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.188]                         if (muffled) 
[16:21:29.188]                           invokeRestart("muffleWarning")
[16:21:29.188]                       }
[16:21:29.188]                       else if (inherits(cond, "condition")) {
[16:21:29.188]                         if (!is.null(pattern)) {
[16:21:29.188]                           computeRestarts <- base::computeRestarts
[16:21:29.188]                           grepl <- base::grepl
[16:21:29.188]                           restarts <- computeRestarts(cond)
[16:21:29.188]                           for (restart in restarts) {
[16:21:29.188]                             name <- restart$name
[16:21:29.188]                             if (is.null(name)) 
[16:21:29.188]                               next
[16:21:29.188]                             if (!grepl(pattern, name)) 
[16:21:29.188]                               next
[16:21:29.188]                             invokeRestart(restart)
[16:21:29.188]                             muffled <- TRUE
[16:21:29.188]                             break
[16:21:29.188]                           }
[16:21:29.188]                         }
[16:21:29.188]                       }
[16:21:29.188]                       invisible(muffled)
[16:21:29.188]                     }
[16:21:29.188]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.188]                   }
[16:21:29.188]                 }
[16:21:29.188]             }
[16:21:29.188]         }))
[16:21:29.188]     }, error = function(ex) {
[16:21:29.188]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:29.188]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.188]                 ...future.rng), started = ...future.startTime, 
[16:21:29.188]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:29.188]             version = "1.8"), class = "FutureResult")
[16:21:29.188]     }, finally = {
[16:21:29.188]         if (!identical(...future.workdir, getwd())) 
[16:21:29.188]             setwd(...future.workdir)
[16:21:29.188]         {
[16:21:29.188]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:29.188]                 ...future.oldOptions$nwarnings <- NULL
[16:21:29.188]             }
[16:21:29.188]             base::options(...future.oldOptions)
[16:21:29.188]             if (.Platform$OS.type == "windows") {
[16:21:29.188]                 old_names <- names(...future.oldEnvVars)
[16:21:29.188]                 envs <- base::Sys.getenv()
[16:21:29.188]                 names <- names(envs)
[16:21:29.188]                 common <- intersect(names, old_names)
[16:21:29.188]                 added <- setdiff(names, old_names)
[16:21:29.188]                 removed <- setdiff(old_names, names)
[16:21:29.188]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:29.188]                   envs[common]]
[16:21:29.188]                 NAMES <- toupper(changed)
[16:21:29.188]                 args <- list()
[16:21:29.188]                 for (kk in seq_along(NAMES)) {
[16:21:29.188]                   name <- changed[[kk]]
[16:21:29.188]                   NAME <- NAMES[[kk]]
[16:21:29.188]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.188]                     next
[16:21:29.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.188]                 }
[16:21:29.188]                 NAMES <- toupper(added)
[16:21:29.188]                 for (kk in seq_along(NAMES)) {
[16:21:29.188]                   name <- added[[kk]]
[16:21:29.188]                   NAME <- NAMES[[kk]]
[16:21:29.188]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.188]                     next
[16:21:29.188]                   args[[name]] <- ""
[16:21:29.188]                 }
[16:21:29.188]                 NAMES <- toupper(removed)
[16:21:29.188]                 for (kk in seq_along(NAMES)) {
[16:21:29.188]                   name <- removed[[kk]]
[16:21:29.188]                   NAME <- NAMES[[kk]]
[16:21:29.188]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.188]                     next
[16:21:29.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.188]                 }
[16:21:29.188]                 if (length(args) > 0) 
[16:21:29.188]                   base::do.call(base::Sys.setenv, args = args)
[16:21:29.188]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:29.188]             }
[16:21:29.188]             else {
[16:21:29.188]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:29.188]             }
[16:21:29.188]             {
[16:21:29.188]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:29.188]                   0L) {
[16:21:29.188]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:29.188]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:29.188]                   base::options(opts)
[16:21:29.188]                 }
[16:21:29.188]                 {
[16:21:29.188]                   {
[16:21:29.188]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:29.188]                     NULL
[16:21:29.188]                   }
[16:21:29.188]                   options(future.plan = NULL)
[16:21:29.188]                   if (is.na(NA_character_)) 
[16:21:29.188]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.188]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:29.188]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:29.188]                     .init = FALSE)
[16:21:29.188]                 }
[16:21:29.188]             }
[16:21:29.188]         }
[16:21:29.188]     })
[16:21:29.188]     if (TRUE) {
[16:21:29.188]         base::sink(type = "output", split = FALSE)
[16:21:29.188]         if (TRUE) {
[16:21:29.188]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:29.188]         }
[16:21:29.188]         else {
[16:21:29.188]             ...future.result["stdout"] <- base::list(NULL)
[16:21:29.188]         }
[16:21:29.188]         base::close(...future.stdout)
[16:21:29.188]         ...future.stdout <- NULL
[16:21:29.188]     }
[16:21:29.188]     ...future.result$conditions <- ...future.conditions
[16:21:29.188]     ...future.result$finished <- base::Sys.time()
[16:21:29.188]     ...future.result
[16:21:29.188] }
[16:21:29.190] assign_globals() ...
[16:21:29.190] List of 2
[16:21:29.190]  $ nested   :List of 2
[16:21:29.190]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:21:29.190]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:21:29.190]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:21:29.190]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:21:29.190]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:21:29.190]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:21:29.190]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:21:29.190]  $ strategy2: chr "multicore"
[16:21:29.190]  - attr(*, "where")=List of 2
[16:21:29.190]   ..$ nested   :<environment: R_EmptyEnv> 
[16:21:29.190]   ..$ strategy2:<environment: R_EmptyEnv> 
[16:21:29.190]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:29.190]  - attr(*, "resolved")= logi FALSE
[16:21:29.190]  - attr(*, "total_size")= num 95304
[16:21:29.190]  - attr(*, "already-done")= logi TRUE
[16:21:29.196] - copied ‘nested’ to environment
[16:21:29.196] - copied ‘strategy2’ to environment
[16:21:29.196] assign_globals() ... done
[16:21:29.196] requestCore(): workers = 2
[16:21:29.199] MulticoreFuture started
[16:21:29.199] - Launch lazy future ... done
[16:21:29.199] run() for ‘MulticoreFuture’ ... done
[16:21:29.200] result() for MulticoreFuture ...
[16:21:29.200] plan(): Setting new future strategy stack:
[16:21:29.201] List of future strategies:
[16:21:29.201] 1. multicore:
[16:21:29.201]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:29.201]    - tweaked: FALSE
[16:21:29.201]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.206] plan(): nbrOfWorkers() = 1
[16:21:29.247] plan(): Setting new future strategy stack:
[16:21:29.247] List of future strategies:
[16:21:29.247] 1. multicore:
[16:21:29.247]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:29.247]    - tweaked: FALSE
[16:21:29.247]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.247] 2. multicore:
[16:21:29.247]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:29.247]    - tweaked: FALSE
[16:21:29.247]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.251] plan(): nbrOfWorkers() = 2
[16:21:29.253] result() for MulticoreFuture ...
[16:21:29.253] result() for MulticoreFuture ... done
[16:21:29.253] signalConditions() ...
[16:21:29.253]  - include = ‘immediateCondition’
[16:21:29.253]  - exclude = 
[16:21:29.253]  - resignal = FALSE
[16:21:29.254]  - Number of conditions: 54
[16:21:29.254] signalConditions() ... done
[16:21:29.254] result() for MulticoreFuture ... done
[16:21:29.254] result() for MulticoreFuture ...
[16:21:29.254] result() for MulticoreFuture ... done
[16:21:29.254] signalConditions() ...
[16:21:29.254]  - include = ‘immediateCondition’
[16:21:29.254]  - exclude = 
[16:21:29.255]  - resignal = FALSE
[16:21:29.255]  - Number of conditions: 54
[16:21:29.255] signalConditions() ... done
[16:21:29.255] Future state: ‘finished’
[16:21:29.255] result() for MulticoreFuture ...
[16:21:29.255] result() for MulticoreFuture ... done
[16:21:29.255] signalConditions() ...
[16:21:29.256]  - include = ‘condition’
[16:21:29.256]  - exclude = ‘immediateCondition’
[16:21:29.256]  - resignal = TRUE
[16:21:29.256]  - Number of conditions: 54
[16:21:29.256]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.208] getGlobalsAndPackages() ...
[16:21:29.256]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.209] Searching for globals...
[16:21:29.256]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.216] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[16:21:29.257]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.217] Searching for globals ... DONE
[16:21:29.257]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.217] Resolving globals: FALSE
[16:21:29.257]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.218] The total size of the 3 globals is 93.01 KiB (95240 bytes)
[16:21:29.257]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.218] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 93.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (46.48 KiB of class ‘list’), ‘plan_a’ (46.48 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[16:21:29.257]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.219] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[16:21:29.257]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.219] 
[16:21:29.258]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.219] getGlobalsAndPackages() ... DONE
[16:21:29.258]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.220] run() for ‘Future’ ...
[16:21:29.258]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.220] - state: ‘created’
[16:21:29.258]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.220] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:29.258]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.224] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:29.258]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.224] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:29.258]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.225]   - Field: ‘label’
[16:21:29.259]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.225]   - Field: ‘local’
[16:21:29.259]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.225]   - Field: ‘owner’
[16:21:29.259]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.225]   - Field: ‘envir’
[16:21:29.259]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.225]   - Field: ‘packages’
[16:21:29.259]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.225]   - Field: ‘gc’
[16:21:29.259]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.226]   - Field: ‘conditions’
[16:21:29.260]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.226]   - Field: ‘expr’
[16:21:29.260]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.226]   - Field: ‘uuid’
[16:21:29.260]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.226]   - Field: ‘seed’
[16:21:29.260]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.226]   - Field: ‘version’
[16:21:29.260]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.226]   - Field: ‘result’
[16:21:29.260]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.226]   - Field: ‘asynchronous’
[16:21:29.261]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.227]   - Field: ‘calls’
[16:21:29.261]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.227]   - Field: ‘globals’
[16:21:29.261]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.227]   - Field: ‘stdout’
[16:21:29.261]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.227]   - Field: ‘earlySignal’
[16:21:29.261]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.227]   - Field: ‘lazy’
[16:21:29.261]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.227]   - Field: ‘state’
[16:21:29.262]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.228] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:29.262]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.228] - Launch lazy future ...
[16:21:29.262]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.228] Packages needed by the future expression (n = 0): <none>
[16:21:29.262]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.228] Packages needed by future strategies (n = 0): <none>
[16:21:29.262]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.229] {
[16:21:29.229]     {
[16:21:29.229]         {
[16:21:29.229]             ...future.startTime <- base::Sys.time()
[16:21:29.229]             {
[16:21:29.229]                 {
[16:21:29.229]                   {
[16:21:29.229]                     base::local({
[16:21:29.229]                       has_future <- base::requireNamespace("future", 
[16:21:29.229]                         quietly = TRUE)
[16:21:29.229]                       if (has_future) {
[16:21:29.229]                         ns <- base::getNamespace("future")
[16:21:29.229]                         version <- ns[[".package"]][["version"]]
[16:21:29.229]                         if (is.null(version)) 
[16:21:29.229]                           version <- utils::packageVersion("future")
[16:21:29.229]                       }
[16:21:29.229]                       else {
[16:21:29.229]                         version <- NULL
[16:21:29.229]                       }
[16:21:29.229]                       if (!has_future || version < "1.8.0") {
[16:21:29.229]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:29.229]                           "", base::R.version$version.string), 
[16:21:29.229]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:29.229]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:29.229]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:29.229]                             "release", "version")], collapse = " "), 
[16:21:29.229]                           hostname = base::Sys.info()[["nodename"]])
[16:21:29.229]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:29.229]                           info)
[16:21:29.229]                         info <- base::paste(info, collapse = "; ")
[16:21:29.229]                         if (!has_future) {
[16:21:29.229]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:29.229]                             info)
[16:21:29.229]                         }
[16:21:29.229]                         else {
[16:21:29.229]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:29.229]                             info, version)
[16:21:29.229]                         }
[16:21:29.229]                         base::stop(msg)
[16:21:29.229]                       }
[16:21:29.229]                     })
[16:21:29.229]                   }
[16:21:29.229]                   ...future.strategy.old <- future::plan("list")
[16:21:29.229]                   options(future.plan = NULL)
[16:21:29.229]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.229]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:29.229]                 }
[16:21:29.229]                 ...future.workdir <- getwd()
[16:21:29.229]             }
[16:21:29.229]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:29.229]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:29.229]         }
[16:21:29.229]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:29.229]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:29.229]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:29.229]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:29.229]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:29.229]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:29.229]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:29.229]             base::names(...future.oldOptions))
[16:21:29.229]     }
[16:21:29.229]     if (FALSE) {
[16:21:29.229]     }
[16:21:29.229]     else {
[16:21:29.229]         if (TRUE) {
[16:21:29.229]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:29.229]                 open = "w")
[16:21:29.229]         }
[16:21:29.229]         else {
[16:21:29.229]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:29.229]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:29.229]         }
[16:21:29.229]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:29.229]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:29.229]             base::sink(type = "output", split = FALSE)
[16:21:29.229]             base::close(...future.stdout)
[16:21:29.229]         }, add = TRUE)
[16:21:29.229]     }
[16:21:29.229]     ...future.frame <- base::sys.nframe()
[16:21:29.229]     ...future.conditions <- base::list()
[16:21:29.229]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:29.229]     if (FALSE) {
[16:21:29.229]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:29.229]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:29.229]     }
[16:21:29.229]     ...future.result <- base::tryCatch({
[16:21:29.229]         base::withCallingHandlers({
[16:21:29.229]             ...future.value <- base::withVisible(base::local({
[16:21:29.229]                 b <- 2L
[16:21:29.229]                 plan_b <- future::plan("list")
[16:21:29.229]                 nested_b <- nested_a[-1]
[16:21:29.229]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:21:29.229]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:21:29.229]                   "sequential"))
[16:21:29.229]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:21:29.229]                   b = b, nested_b = nested_b, plan_b = plan_b)
[16:21:29.229]             }))
[16:21:29.229]             future::FutureResult(value = ...future.value$value, 
[16:21:29.229]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.229]                   ...future.rng), globalenv = if (FALSE) 
[16:21:29.229]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:29.229]                     ...future.globalenv.names))
[16:21:29.229]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:29.229]         }, condition = base::local({
[16:21:29.229]             c <- base::c
[16:21:29.229]             inherits <- base::inherits
[16:21:29.229]             invokeRestart <- base::invokeRestart
[16:21:29.229]             length <- base::length
[16:21:29.229]             list <- base::list
[16:21:29.229]             seq.int <- base::seq.int
[16:21:29.229]             signalCondition <- base::signalCondition
[16:21:29.229]             sys.calls <- base::sys.calls
[16:21:29.229]             `[[` <- base::`[[`
[16:21:29.229]             `+` <- base::`+`
[16:21:29.229]             `<<-` <- base::`<<-`
[16:21:29.229]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:29.229]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:29.229]                   3L)]
[16:21:29.229]             }
[16:21:29.229]             function(cond) {
[16:21:29.229]                 is_error <- inherits(cond, "error")
[16:21:29.229]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:29.229]                   NULL)
[16:21:29.229]                 if (is_error) {
[16:21:29.229]                   sessionInformation <- function() {
[16:21:29.229]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:29.229]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:29.229]                       search = base::search(), system = base::Sys.info())
[16:21:29.229]                   }
[16:21:29.229]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.229]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:29.229]                     cond$call), session = sessionInformation(), 
[16:21:29.229]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:29.229]                   signalCondition(cond)
[16:21:29.229]                 }
[16:21:29.229]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:29.229]                 "immediateCondition"))) {
[16:21:29.229]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:29.229]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.229]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:29.229]                   if (TRUE && !signal) {
[16:21:29.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.229]                     {
[16:21:29.229]                       inherits <- base::inherits
[16:21:29.229]                       invokeRestart <- base::invokeRestart
[16:21:29.229]                       is.null <- base::is.null
[16:21:29.229]                       muffled <- FALSE
[16:21:29.229]                       if (inherits(cond, "message")) {
[16:21:29.229]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.229]                         if (muffled) 
[16:21:29.229]                           invokeRestart("muffleMessage")
[16:21:29.229]                       }
[16:21:29.229]                       else if (inherits(cond, "warning")) {
[16:21:29.229]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.229]                         if (muffled) 
[16:21:29.229]                           invokeRestart("muffleWarning")
[16:21:29.229]                       }
[16:21:29.229]                       else if (inherits(cond, "condition")) {
[16:21:29.229]                         if (!is.null(pattern)) {
[16:21:29.229]                           computeRestarts <- base::computeRestarts
[16:21:29.229]                           grepl <- base::grepl
[16:21:29.229]                           restarts <- computeRestarts(cond)
[16:21:29.229]                           for (restart in restarts) {
[16:21:29.229]                             name <- restart$name
[16:21:29.229]                             if (is.null(name)) 
[16:21:29.229]                               next
[16:21:29.229]                             if (!grepl(pattern, name)) 
[16:21:29.229]                               next
[16:21:29.229]                             invokeRestart(restart)
[16:21:29.229]                             muffled <- TRUE
[16:21:29.229]                             break
[16:21:29.229]                           }
[16:21:29.229]                         }
[16:21:29.229]                       }
[16:21:29.229]                       invisible(muffled)
[16:21:29.229]                     }
[16:21:29.229]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.229]                   }
[16:21:29.229]                 }
[16:21:29.229]                 else {
[16:21:29.229]                   if (TRUE) {
[16:21:29.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.229]                     {
[16:21:29.229]                       inherits <- base::inherits
[16:21:29.229]                       invokeRestart <- base::invokeRestart
[16:21:29.229]                       is.null <- base::is.null
[16:21:29.229]                       muffled <- FALSE
[16:21:29.229]                       if (inherits(cond, "message")) {
[16:21:29.229]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.229]                         if (muffled) 
[16:21:29.229]                           invokeRestart("muffleMessage")
[16:21:29.229]                       }
[16:21:29.229]                       else if (inherits(cond, "warning")) {
[16:21:29.229]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.229]                         if (muffled) 
[16:21:29.229]                           invokeRestart("muffleWarning")
[16:21:29.229]                       }
[16:21:29.229]                       else if (inherits(cond, "condition")) {
[16:21:29.229]                         if (!is.null(pattern)) {
[16:21:29.229]                           computeRestarts <- base::computeRestarts
[16:21:29.229]                           grepl <- base::grepl
[16:21:29.229]                           restarts <- computeRestarts(cond)
[16:21:29.229]                           for (restart in restarts) {
[16:21:29.229]                             name <- restart$name
[16:21:29.229]                             if (is.null(name)) 
[16:21:29.229]                               next
[16:21:29.229]                             if (!grepl(pattern, name)) 
[16:21:29.229]                               next
[16:21:29.229]                             invokeRestart(restart)
[16:21:29.229]                             muffled <- TRUE
[16:21:29.229]                             break
[16:21:29.229]                           }
[16:21:29.229]                         }
[16:21:29.229]                       }
[16:21:29.229]                       invisible(muffled)
[16:21:29.229]                     }
[16:21:29.229]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.229]                   }
[16:21:29.229]                 }
[16:21:29.229]             }
[16:21:29.229]         }))
[16:21:29.229]     }, error = function(ex) {
[16:21:29.229]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:29.229]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.229]                 ...future.rng), started = ...future.startTime, 
[16:21:29.229]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:29.229]             version = "1.8"), class = "FutureResult")
[16:21:29.229]     }, finally = {
[16:21:29.229]         if (!identical(...future.workdir, getwd())) 
[16:21:29.229]             setwd(...future.workdir)
[16:21:29.229]         {
[16:21:29.229]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:29.229]                 ...future.oldOptions$nwarnings <- NULL
[16:21:29.229]             }
[16:21:29.229]             base::options(...future.oldOptions)
[16:21:29.229]             if (.Platform$OS.type == "windows") {
[16:21:29.229]                 old_names <- names(...future.oldEnvVars)
[16:21:29.229]                 envs <- base::Sys.getenv()
[16:21:29.229]                 names <- names(envs)
[16:21:29.229]                 common <- intersect(names, old_names)
[16:21:29.229]                 added <- setdiff(names, old_names)
[16:21:29.229]                 removed <- setdiff(old_names, names)
[16:21:29.229]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:29.229]                   envs[common]]
[16:21:29.229]                 NAMES <- toupper(changed)
[16:21:29.229]                 args <- list()
[16:21:29.229]                 for (kk in seq_along(NAMES)) {
[16:21:29.229]                   name <- changed[[kk]]
[16:21:29.229]                   NAME <- NAMES[[kk]]
[16:21:29.229]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.229]                     next
[16:21:29.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.229]                 }
[16:21:29.229]                 NAMES <- toupper(added)
[16:21:29.229]                 for (kk in seq_along(NAMES)) {
[16:21:29.229]                   name <- added[[kk]]
[16:21:29.229]                   NAME <- NAMES[[kk]]
[16:21:29.229]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.229]                     next
[16:21:29.229]                   args[[name]] <- ""
[16:21:29.229]                 }
[16:21:29.229]                 NAMES <- toupper(removed)
[16:21:29.229]                 for (kk in seq_along(NAMES)) {
[16:21:29.229]                   name <- removed[[kk]]
[16:21:29.229]                   NAME <- NAMES[[kk]]
[16:21:29.229]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.229]                     next
[16:21:29.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.229]                 }
[16:21:29.229]                 if (length(args) > 0) 
[16:21:29.229]                   base::do.call(base::Sys.setenv, args = args)
[16:21:29.229]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:29.229]             }
[16:21:29.229]             else {
[16:21:29.229]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:29.229]             }
[16:21:29.229]             {
[16:21:29.229]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:29.229]                   0L) {
[16:21:29.229]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:29.229]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:29.229]                   base::options(opts)
[16:21:29.229]                 }
[16:21:29.229]                 {
[16:21:29.229]                   {
[16:21:29.229]                     NULL
[16:21:29.229]                     RNGkind("Mersenne-Twister")
[16:21:29.229]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:29.229]                       inherits = FALSE)
[16:21:29.229]                   }
[16:21:29.229]                   options(future.plan = NULL)
[16:21:29.229]                   if (is.na(NA_character_)) 
[16:21:29.229]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.229]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:29.229]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:29.229]                     .init = FALSE)
[16:21:29.229]                 }
[16:21:29.229]             }
[16:21:29.229]         }
[16:21:29.229]     })
[16:21:29.229]     if (TRUE) {
[16:21:29.229]         base::sink(type = "output", split = FALSE)
[16:21:29.229]         if (TRUE) {
[16:21:29.229]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:29.229]         }
[16:21:29.229]         else {
[16:21:29.229]             ...future.result["stdout"] <- base::list(NULL)
[16:21:29.229]         }
[16:21:29.229]         base::close(...future.stdout)
[16:21:29.229]         ...future.stdout <- NULL
[16:21:29.229]     }
[16:21:29.229]     ...future.result$conditions <- ...future.conditions
[16:21:29.229]     ...future.result$finished <- base::Sys.time()
[16:21:29.229]     ...future.result
[16:21:29.229] }
[16:21:29.262]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.231] assign_globals() ...
[16:21:29.262]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.232] List of 3
[16:21:29.232]  $ nested_a:List of 1
[16:21:29.232]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:21:29.232]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:21:29.232]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:21:29.232]  $ a       : int 1
[16:21:29.232]  $ plan_a  :List of 1
[16:21:29.232]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:21:29.232]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:21:29.232]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:21:29.232]  - attr(*, "where")=List of 3
[16:21:29.232]   ..$ nested_a:<environment: R_EmptyEnv> 
[16:21:29.232]   ..$ a       :<environment: R_EmptyEnv> 
[16:21:29.232]   ..$ plan_a  :<environment: R_EmptyEnv> 
[16:21:29.232]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:29.232]  - attr(*, "resolved")= logi FALSE
[16:21:29.232]  - attr(*, "total_size")= num 95240
[16:21:29.232]  - attr(*, "already-done")= logi TRUE
[16:21:29.263]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.239] - copied ‘nested_a’ to environment
[16:21:29.263]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.239] - copied ‘a’ to environment
[16:21:29.263]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.239] - copied ‘plan_a’ to environment
[16:21:29.263]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.239] assign_globals() ... done
[16:21:29.263]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.239] plan(): Setting new future strategy stack:
[16:21:29.263]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.240] List of future strategies:
[16:21:29.240] 1. sequential:
[16:21:29.240]    - args: function (..., envir = parent.frame())
[16:21:29.240]    - tweaked: FALSE
[16:21:29.240]    - call: NULL
[16:21:29.264]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.240] plan(): nbrOfWorkers() = 1
[16:21:29.264]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.241] plan(): Setting new future strategy stack:
[16:21:29.264]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.241] List of future strategies:
[16:21:29.241] 1. multicore:
[16:21:29.241]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:29.241]    - tweaked: FALSE
[16:21:29.241]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.264]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.246] plan(): nbrOfWorkers() = 1
[16:21:29.264]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.246] SequentialFuture started (and completed)
[16:21:29.264]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.246] - Launch lazy future ... done
[16:21:29.265]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.246] run() for ‘SequentialFuture’ ... done
[16:21:29.265] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:21:29.271] getGlobalsAndPackages() ...
[16:21:29.271] Searching for globals...
[16:21:29.273] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:21:29.273] Searching for globals ... DONE
[16:21:29.273] Resolving globals: FALSE
[16:21:29.274] The total size of the 1 globals is 128 bytes (128 bytes)
[16:21:29.274] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:21:29.274] - globals: [1] ‘data’
[16:21:29.275] - packages: [1] ‘future’
[16:21:29.275] getGlobalsAndPackages() ... DONE
[16:21:29.275] run() for ‘Future’ ...
[16:21:29.275] - state: ‘created’
[16:21:29.275] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:29.280] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:29.280] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:29.280]   - Field: ‘label’
[16:21:29.280]   - Field: ‘local’
[16:21:29.280]   - Field: ‘owner’
[16:21:29.280]   - Field: ‘envir’
[16:21:29.280]   - Field: ‘workers’
[16:21:29.281]   - Field: ‘packages’
[16:21:29.281]   - Field: ‘gc’
[16:21:29.281]   - Field: ‘job’
[16:21:29.281]   - Field: ‘conditions’
[16:21:29.281]   - Field: ‘expr’
[16:21:29.281]   - Field: ‘uuid’
[16:21:29.281]   - Field: ‘seed’
[16:21:29.281]   - Field: ‘version’
[16:21:29.281]   - Field: ‘result’
[16:21:29.282]   - Field: ‘asynchronous’
[16:21:29.282]   - Field: ‘calls’
[16:21:29.282]   - Field: ‘globals’
[16:21:29.282]   - Field: ‘stdout’
[16:21:29.282]   - Field: ‘earlySignal’
[16:21:29.282]   - Field: ‘lazy’
[16:21:29.282]   - Field: ‘state’
[16:21:29.282] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:29.282] - Launch lazy future ...
[16:21:29.283] Packages needed by the future expression (n = 1): ‘future’
[16:21:29.283] Packages needed by future strategies (n = 1): ‘future’
[16:21:29.284] {
[16:21:29.284]     {
[16:21:29.284]         {
[16:21:29.284]             ...future.startTime <- base::Sys.time()
[16:21:29.284]             {
[16:21:29.284]                 {
[16:21:29.284]                   {
[16:21:29.284]                     {
[16:21:29.284]                       {
[16:21:29.284]                         base::local({
[16:21:29.284]                           has_future <- base::requireNamespace("future", 
[16:21:29.284]                             quietly = TRUE)
[16:21:29.284]                           if (has_future) {
[16:21:29.284]                             ns <- base::getNamespace("future")
[16:21:29.284]                             version <- ns[[".package"]][["version"]]
[16:21:29.284]                             if (is.null(version)) 
[16:21:29.284]                               version <- utils::packageVersion("future")
[16:21:29.284]                           }
[16:21:29.284]                           else {
[16:21:29.284]                             version <- NULL
[16:21:29.284]                           }
[16:21:29.284]                           if (!has_future || version < "1.8.0") {
[16:21:29.284]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:29.284]                               "", base::R.version$version.string), 
[16:21:29.284]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:29.284]                                 base::R.version$platform, 8 * 
[16:21:29.284]                                   base::.Machine$sizeof.pointer), 
[16:21:29.284]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:29.284]                                 "release", "version")], collapse = " "), 
[16:21:29.284]                               hostname = base::Sys.info()[["nodename"]])
[16:21:29.284]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:29.284]                               info)
[16:21:29.284]                             info <- base::paste(info, collapse = "; ")
[16:21:29.284]                             if (!has_future) {
[16:21:29.284]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:29.284]                                 info)
[16:21:29.284]                             }
[16:21:29.284]                             else {
[16:21:29.284]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:29.284]                                 info, version)
[16:21:29.284]                             }
[16:21:29.284]                             base::stop(msg)
[16:21:29.284]                           }
[16:21:29.284]                         })
[16:21:29.284]                       }
[16:21:29.284]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:29.284]                       base::options(mc.cores = 1L)
[16:21:29.284]                     }
[16:21:29.284]                     base::local({
[16:21:29.284]                       for (pkg in "future") {
[16:21:29.284]                         base::loadNamespace(pkg)
[16:21:29.284]                         base::library(pkg, character.only = TRUE)
[16:21:29.284]                       }
[16:21:29.284]                     })
[16:21:29.284]                   }
[16:21:29.284]                   ...future.strategy.old <- future::plan("list")
[16:21:29.284]                   options(future.plan = NULL)
[16:21:29.284]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.284]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:21:29.284]                     envir = parent.frame()) 
[16:21:29.284]                   {
[16:21:29.284]                     default_workers <- missing(workers)
[16:21:29.284]                     if (is.function(workers)) 
[16:21:29.284]                       workers <- workers()
[16:21:29.284]                     workers <- structure(as.integer(workers), 
[16:21:29.284]                       class = class(workers))
[16:21:29.284]                     stop_if_not(is.finite(workers), workers >= 
[16:21:29.284]                       1L)
[16:21:29.284]                     if ((workers == 1L && !inherits(workers, 
[16:21:29.284]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:21:29.284]                       if (default_workers) 
[16:21:29.284]                         supportsMulticore(warn = TRUE)
[16:21:29.284]                       return(sequential(..., envir = envir))
[16:21:29.284]                     }
[16:21:29.284]                     oopts <- options(mc.cores = workers)
[16:21:29.284]                     on.exit(options(oopts))
[16:21:29.284]                     future <- MulticoreFuture(..., workers = workers, 
[16:21:29.284]                       envir = envir)
[16:21:29.284]                     if (!future$lazy) 
[16:21:29.284]                       future <- run(future)
[16:21:29.284]                     invisible(future)
[16:21:29.284]                   }), .cleanup = FALSE, .init = FALSE)
[16:21:29.284]                 }
[16:21:29.284]                 ...future.workdir <- getwd()
[16:21:29.284]             }
[16:21:29.284]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:29.284]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:29.284]         }
[16:21:29.284]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:29.284]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:29.284]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:29.284]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:29.284]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:29.284]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:29.284]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:29.284]             base::names(...future.oldOptions))
[16:21:29.284]     }
[16:21:29.284]     if (FALSE) {
[16:21:29.284]     }
[16:21:29.284]     else {
[16:21:29.284]         if (TRUE) {
[16:21:29.284]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:29.284]                 open = "w")
[16:21:29.284]         }
[16:21:29.284]         else {
[16:21:29.284]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:29.284]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:29.284]         }
[16:21:29.284]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:29.284]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:29.284]             base::sink(type = "output", split = FALSE)
[16:21:29.284]             base::close(...future.stdout)
[16:21:29.284]         }, add = TRUE)
[16:21:29.284]     }
[16:21:29.284]     ...future.frame <- base::sys.nframe()
[16:21:29.284]     ...future.conditions <- base::list()
[16:21:29.284]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:29.284]     if (FALSE) {
[16:21:29.284]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:29.284]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:29.284]     }
[16:21:29.284]     ...future.result <- base::tryCatch({
[16:21:29.284]         base::withCallingHandlers({
[16:21:29.284]             ...future.value <- base::withVisible(base::local({
[16:21:29.284]                 withCallingHandlers({
[16:21:29.284]                   {
[16:21:29.284]                     value(future(subset(data, a == 2)))
[16:21:29.284]                   }
[16:21:29.284]                 }, immediateCondition = function(cond) {
[16:21:29.284]                   save_rds <- function (object, pathname, ...) 
[16:21:29.284]                   {
[16:21:29.284]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:29.284]                     if (file_test("-f", pathname_tmp)) {
[16:21:29.284]                       fi_tmp <- file.info(pathname_tmp)
[16:21:29.284]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:29.284]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:29.284]                         fi_tmp[["mtime"]])
[16:21:29.284]                     }
[16:21:29.284]                     tryCatch({
[16:21:29.284]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:29.284]                     }, error = function(ex) {
[16:21:29.284]                       msg <- conditionMessage(ex)
[16:21:29.284]                       fi_tmp <- file.info(pathname_tmp)
[16:21:29.284]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:29.284]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:29.284]                         fi_tmp[["mtime"]], msg)
[16:21:29.284]                       ex$message <- msg
[16:21:29.284]                       stop(ex)
[16:21:29.284]                     })
[16:21:29.284]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:29.284]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:29.284]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:29.284]                       fi_tmp <- file.info(pathname_tmp)
[16:21:29.284]                       fi <- file.info(pathname)
[16:21:29.284]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:29.284]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:29.284]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:29.284]                         fi[["size"]], fi[["mtime"]])
[16:21:29.284]                       stop(msg)
[16:21:29.284]                     }
[16:21:29.284]                     invisible(pathname)
[16:21:29.284]                   }
[16:21:29.284]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:29.284]                     rootPath = tempdir()) 
[16:21:29.284]                   {
[16:21:29.284]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:29.284]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:29.284]                       tmpdir = path, fileext = ".rds")
[16:21:29.284]                     save_rds(obj, file)
[16:21:29.284]                   }
[16:21:29.284]                   saveImmediateCondition(cond, path = "/tmp/RtmpnVB70K/.future/immediateConditions")
[16:21:29.284]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.284]                   {
[16:21:29.284]                     inherits <- base::inherits
[16:21:29.284]                     invokeRestart <- base::invokeRestart
[16:21:29.284]                     is.null <- base::is.null
[16:21:29.284]                     muffled <- FALSE
[16:21:29.284]                     if (inherits(cond, "message")) {
[16:21:29.284]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:29.284]                       if (muffled) 
[16:21:29.284]                         invokeRestart("muffleMessage")
[16:21:29.284]                     }
[16:21:29.284]                     else if (inherits(cond, "warning")) {
[16:21:29.284]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:29.284]                       if (muffled) 
[16:21:29.284]                         invokeRestart("muffleWarning")
[16:21:29.284]                     }
[16:21:29.284]                     else if (inherits(cond, "condition")) {
[16:21:29.284]                       if (!is.null(pattern)) {
[16:21:29.284]                         computeRestarts <- base::computeRestarts
[16:21:29.284]                         grepl <- base::grepl
[16:21:29.284]                         restarts <- computeRestarts(cond)
[16:21:29.284]                         for (restart in restarts) {
[16:21:29.284]                           name <- restart$name
[16:21:29.284]                           if (is.null(name)) 
[16:21:29.284]                             next
[16:21:29.284]                           if (!grepl(pattern, name)) 
[16:21:29.284]                             next
[16:21:29.284]                           invokeRestart(restart)
[16:21:29.284]                           muffled <- TRUE
[16:21:29.284]                           break
[16:21:29.284]                         }
[16:21:29.284]                       }
[16:21:29.284]                     }
[16:21:29.284]                     invisible(muffled)
[16:21:29.284]                   }
[16:21:29.284]                   muffleCondition(cond)
[16:21:29.284]                 })
[16:21:29.284]             }))
[16:21:29.284]             future::FutureResult(value = ...future.value$value, 
[16:21:29.284]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.284]                   ...future.rng), globalenv = if (FALSE) 
[16:21:29.284]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:29.284]                     ...future.globalenv.names))
[16:21:29.284]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:29.284]         }, condition = base::local({
[16:21:29.284]             c <- base::c
[16:21:29.284]             inherits <- base::inherits
[16:21:29.284]             invokeRestart <- base::invokeRestart
[16:21:29.284]             length <- base::length
[16:21:29.284]             list <- base::list
[16:21:29.284]             seq.int <- base::seq.int
[16:21:29.284]             signalCondition <- base::signalCondition
[16:21:29.284]             sys.calls <- base::sys.calls
[16:21:29.284]             `[[` <- base::`[[`
[16:21:29.284]             `+` <- base::`+`
[16:21:29.284]             `<<-` <- base::`<<-`
[16:21:29.284]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:29.284]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:29.284]                   3L)]
[16:21:29.284]             }
[16:21:29.284]             function(cond) {
[16:21:29.284]                 is_error <- inherits(cond, "error")
[16:21:29.284]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:29.284]                   NULL)
[16:21:29.284]                 if (is_error) {
[16:21:29.284]                   sessionInformation <- function() {
[16:21:29.284]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:29.284]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:29.284]                       search = base::search(), system = base::Sys.info())
[16:21:29.284]                   }
[16:21:29.284]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.284]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:29.284]                     cond$call), session = sessionInformation(), 
[16:21:29.284]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:29.284]                   signalCondition(cond)
[16:21:29.284]                 }
[16:21:29.284]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:29.284]                 "immediateCondition"))) {
[16:21:29.284]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:29.284]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.284]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:29.284]                   if (TRUE && !signal) {
[16:21:29.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.284]                     {
[16:21:29.284]                       inherits <- base::inherits
[16:21:29.284]                       invokeRestart <- base::invokeRestart
[16:21:29.284]                       is.null <- base::is.null
[16:21:29.284]                       muffled <- FALSE
[16:21:29.284]                       if (inherits(cond, "message")) {
[16:21:29.284]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.284]                         if (muffled) 
[16:21:29.284]                           invokeRestart("muffleMessage")
[16:21:29.284]                       }
[16:21:29.284]                       else if (inherits(cond, "warning")) {
[16:21:29.284]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.284]                         if (muffled) 
[16:21:29.284]                           invokeRestart("muffleWarning")
[16:21:29.284]                       }
[16:21:29.284]                       else if (inherits(cond, "condition")) {
[16:21:29.284]                         if (!is.null(pattern)) {
[16:21:29.284]                           computeRestarts <- base::computeRestarts
[16:21:29.284]                           grepl <- base::grepl
[16:21:29.284]                           restarts <- computeRestarts(cond)
[16:21:29.284]                           for (restart in restarts) {
[16:21:29.284]                             name <- restart$name
[16:21:29.284]                             if (is.null(name)) 
[16:21:29.284]                               next
[16:21:29.284]                             if (!grepl(pattern, name)) 
[16:21:29.284]                               next
[16:21:29.284]                             invokeRestart(restart)
[16:21:29.284]                             muffled <- TRUE
[16:21:29.284]                             break
[16:21:29.284]                           }
[16:21:29.284]                         }
[16:21:29.284]                       }
[16:21:29.284]                       invisible(muffled)
[16:21:29.284]                     }
[16:21:29.284]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.284]                   }
[16:21:29.284]                 }
[16:21:29.284]                 else {
[16:21:29.284]                   if (TRUE) {
[16:21:29.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.284]                     {
[16:21:29.284]                       inherits <- base::inherits
[16:21:29.284]                       invokeRestart <- base::invokeRestart
[16:21:29.284]                       is.null <- base::is.null
[16:21:29.284]                       muffled <- FALSE
[16:21:29.284]                       if (inherits(cond, "message")) {
[16:21:29.284]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.284]                         if (muffled) 
[16:21:29.284]                           invokeRestart("muffleMessage")
[16:21:29.284]                       }
[16:21:29.284]                       else if (inherits(cond, "warning")) {
[16:21:29.284]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.284]                         if (muffled) 
[16:21:29.284]                           invokeRestart("muffleWarning")
[16:21:29.284]                       }
[16:21:29.284]                       else if (inherits(cond, "condition")) {
[16:21:29.284]                         if (!is.null(pattern)) {
[16:21:29.284]                           computeRestarts <- base::computeRestarts
[16:21:29.284]                           grepl <- base::grepl
[16:21:29.284]                           restarts <- computeRestarts(cond)
[16:21:29.284]                           for (restart in restarts) {
[16:21:29.284]                             name <- restart$name
[16:21:29.284]                             if (is.null(name)) 
[16:21:29.284]                               next
[16:21:29.284]                             if (!grepl(pattern, name)) 
[16:21:29.284]                               next
[16:21:29.284]                             invokeRestart(restart)
[16:21:29.284]                             muffled <- TRUE
[16:21:29.284]                             break
[16:21:29.284]                           }
[16:21:29.284]                         }
[16:21:29.284]                       }
[16:21:29.284]                       invisible(muffled)
[16:21:29.284]                     }
[16:21:29.284]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.284]                   }
[16:21:29.284]                 }
[16:21:29.284]             }
[16:21:29.284]         }))
[16:21:29.284]     }, error = function(ex) {
[16:21:29.284]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:29.284]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.284]                 ...future.rng), started = ...future.startTime, 
[16:21:29.284]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:29.284]             version = "1.8"), class = "FutureResult")
[16:21:29.284]     }, finally = {
[16:21:29.284]         if (!identical(...future.workdir, getwd())) 
[16:21:29.284]             setwd(...future.workdir)
[16:21:29.284]         {
[16:21:29.284]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:29.284]                 ...future.oldOptions$nwarnings <- NULL
[16:21:29.284]             }
[16:21:29.284]             base::options(...future.oldOptions)
[16:21:29.284]             if (.Platform$OS.type == "windows") {
[16:21:29.284]                 old_names <- names(...future.oldEnvVars)
[16:21:29.284]                 envs <- base::Sys.getenv()
[16:21:29.284]                 names <- names(envs)
[16:21:29.284]                 common <- intersect(names, old_names)
[16:21:29.284]                 added <- setdiff(names, old_names)
[16:21:29.284]                 removed <- setdiff(old_names, names)
[16:21:29.284]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:29.284]                   envs[common]]
[16:21:29.284]                 NAMES <- toupper(changed)
[16:21:29.284]                 args <- list()
[16:21:29.284]                 for (kk in seq_along(NAMES)) {
[16:21:29.284]                   name <- changed[[kk]]
[16:21:29.284]                   NAME <- NAMES[[kk]]
[16:21:29.284]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.284]                     next
[16:21:29.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.284]                 }
[16:21:29.284]                 NAMES <- toupper(added)
[16:21:29.284]                 for (kk in seq_along(NAMES)) {
[16:21:29.284]                   name <- added[[kk]]
[16:21:29.284]                   NAME <- NAMES[[kk]]
[16:21:29.284]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.284]                     next
[16:21:29.284]                   args[[name]] <- ""
[16:21:29.284]                 }
[16:21:29.284]                 NAMES <- toupper(removed)
[16:21:29.284]                 for (kk in seq_along(NAMES)) {
[16:21:29.284]                   name <- removed[[kk]]
[16:21:29.284]                   NAME <- NAMES[[kk]]
[16:21:29.284]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.284]                     next
[16:21:29.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.284]                 }
[16:21:29.284]                 if (length(args) > 0) 
[16:21:29.284]                   base::do.call(base::Sys.setenv, args = args)
[16:21:29.284]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:29.284]             }
[16:21:29.284]             else {
[16:21:29.284]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:29.284]             }
[16:21:29.284]             {
[16:21:29.284]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:29.284]                   0L) {
[16:21:29.284]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:29.284]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:29.284]                   base::options(opts)
[16:21:29.284]                 }
[16:21:29.284]                 {
[16:21:29.284]                   {
[16:21:29.284]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:29.284]                     NULL
[16:21:29.284]                   }
[16:21:29.284]                   options(future.plan = NULL)
[16:21:29.284]                   if (is.na(NA_character_)) 
[16:21:29.284]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.284]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:29.284]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:29.284]                     .init = FALSE)
[16:21:29.284]                 }
[16:21:29.284]             }
[16:21:29.284]         }
[16:21:29.284]     })
[16:21:29.284]     if (TRUE) {
[16:21:29.284]         base::sink(type = "output", split = FALSE)
[16:21:29.284]         if (TRUE) {
[16:21:29.284]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:29.284]         }
[16:21:29.284]         else {
[16:21:29.284]             ...future.result["stdout"] <- base::list(NULL)
[16:21:29.284]         }
[16:21:29.284]         base::close(...future.stdout)
[16:21:29.284]         ...future.stdout <- NULL
[16:21:29.284]     }
[16:21:29.284]     ...future.result$conditions <- ...future.conditions
[16:21:29.284]     ...future.result$finished <- base::Sys.time()
[16:21:29.284]     ...future.result
[16:21:29.284] }
[16:21:29.286] assign_globals() ...
[16:21:29.286] List of 1
[16:21:29.286]  $ data:'data.frame':	3 obs. of  2 variables:
[16:21:29.286]   ..$ a: int [1:3] 1 2 3
[16:21:29.286]   ..$ b: int [1:3] 3 2 1
[16:21:29.286]  - attr(*, "where")=List of 1
[16:21:29.286]   ..$ data:<environment: R_EmptyEnv> 
[16:21:29.286]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:29.286]  - attr(*, "resolved")= logi FALSE
[16:21:29.286]  - attr(*, "total_size")= num 128
[16:21:29.286]  - attr(*, "already-done")= logi TRUE
[16:21:29.290] - copied ‘data’ to environment
[16:21:29.290] assign_globals() ... done
[16:21:29.290] requestCore(): workers = 2
[16:21:29.293] MulticoreFuture started
[16:21:29.293] - Launch lazy future ... done
[16:21:29.293] run() for ‘MulticoreFuture’ ... done
[16:21:29.294] result() for MulticoreFuture ...
[16:21:29.294] plan(): Setting new future strategy stack:
[16:21:29.294] List of future strategies:
[16:21:29.294] 1. multicore:
[16:21:29.294]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:29.294]    - tweaked: FALSE
[16:21:29.294]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.300] plan(): nbrOfWorkers() = 1
[16:21:29.337] plan(): Setting new future strategy stack:
[16:21:29.338] List of future strategies:
[16:21:29.338] 1. multicore:
[16:21:29.338]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:29.338]    - tweaked: FALSE
[16:21:29.338]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.338] 2. multicore:
[16:21:29.338]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:29.338]    - tweaked: FALSE
[16:21:29.338]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.342] plan(): nbrOfWorkers() = 2
[16:21:29.343] result() for MulticoreFuture ...
[16:21:29.343] result() for MulticoreFuture ... done
[16:21:29.343] signalConditions() ...
[16:21:29.343]  - include = ‘immediateCondition’
[16:21:29.343]  - exclude = 
[16:21:29.343]  - resignal = FALSE
[16:21:29.344]  - Number of conditions: 52
[16:21:29.344] signalConditions() ... done
[16:21:29.344] result() for MulticoreFuture ... done
[16:21:29.344] result() for MulticoreFuture ...
[16:21:29.344] result() for MulticoreFuture ... done
[16:21:29.344] signalConditions() ...
[16:21:29.344]  - include = ‘immediateCondition’
[16:21:29.344]  - exclude = 
[16:21:29.345]  - resignal = FALSE
[16:21:29.345]  - Number of conditions: 52
[16:21:29.345] signalConditions() ... done
[16:21:29.345] Future state: ‘finished’
[16:21:29.345] result() for MulticoreFuture ...
[16:21:29.345] result() for MulticoreFuture ... done
[16:21:29.345] signalConditions() ...
[16:21:29.345]  - include = ‘condition’
[16:21:29.346]  - exclude = ‘immediateCondition’
[16:21:29.346]  - resignal = TRUE
[16:21:29.346]  - Number of conditions: 52
[16:21:29.346]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.301] getGlobalsAndPackages() ...
[16:21:29.346]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.302] Searching for globals...
[16:21:29.346]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.304] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[16:21:29.346]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.304] Searching for globals ... DONE
[16:21:29.347]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.304] Resolving globals: FALSE
[16:21:29.347]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.306] The total size of the 1 globals is 128 bytes (128 bytes)
[16:21:29.347]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.306] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:21:29.347]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.306] - globals: [1] ‘data’
[16:21:29.347]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.307] 
[16:21:29.347]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.307] getGlobalsAndPackages() ... DONE
[16:21:29.347]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.308] run() for ‘Future’ ...
[16:21:29.348]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.308] - state: ‘created’
[16:21:29.348]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.308] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:29.348]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.312] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:29.348]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.313] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:29.348]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.313]   - Field: ‘label’
[16:21:29.348]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.313]   - Field: ‘local’
[16:21:29.349]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.313]   - Field: ‘owner’
[16:21:29.349]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.313]   - Field: ‘envir’
[16:21:29.349]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.314]   - Field: ‘packages’
[16:21:29.349]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.314]   - Field: ‘gc’
[16:21:29.349]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.314]   - Field: ‘conditions’
[16:21:29.349]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.314]   - Field: ‘expr’
[16:21:29.350]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.314]   - Field: ‘uuid’
[16:21:29.350]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.314]   - Field: ‘seed’
[16:21:29.350]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.314]   - Field: ‘version’
[16:21:29.350]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.315]   - Field: ‘result’
[16:21:29.350]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.315]   - Field: ‘asynchronous’
[16:21:29.350]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.315]   - Field: ‘calls’
[16:21:29.350]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.315]   - Field: ‘globals’
[16:21:29.351]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.315]   - Field: ‘stdout’
[16:21:29.351]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.315]   - Field: ‘earlySignal’
[16:21:29.351]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.316]   - Field: ‘lazy’
[16:21:29.351]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.316]   - Field: ‘state’
[16:21:29.351]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.316] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:29.351]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.316] - Launch lazy future ...
[16:21:29.352]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.316] Packages needed by the future expression (n = 0): <none>
[16:21:29.352]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.317] Packages needed by future strategies (n = 0): <none>
[16:21:29.352]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.317] {
[16:21:29.317]     {
[16:21:29.317]         {
[16:21:29.317]             ...future.startTime <- base::Sys.time()
[16:21:29.317]             {
[16:21:29.317]                 {
[16:21:29.317]                   {
[16:21:29.317]                     base::local({
[16:21:29.317]                       has_future <- base::requireNamespace("future", 
[16:21:29.317]                         quietly = TRUE)
[16:21:29.317]                       if (has_future) {
[16:21:29.317]                         ns <- base::getNamespace("future")
[16:21:29.317]                         version <- ns[[".package"]][["version"]]
[16:21:29.317]                         if (is.null(version)) 
[16:21:29.317]                           version <- utils::packageVersion("future")
[16:21:29.317]                       }
[16:21:29.317]                       else {
[16:21:29.317]                         version <- NULL
[16:21:29.317]                       }
[16:21:29.317]                       if (!has_future || version < "1.8.0") {
[16:21:29.317]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:29.317]                           "", base::R.version$version.string), 
[16:21:29.317]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:29.317]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:29.317]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:29.317]                             "release", "version")], collapse = " "), 
[16:21:29.317]                           hostname = base::Sys.info()[["nodename"]])
[16:21:29.317]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:29.317]                           info)
[16:21:29.317]                         info <- base::paste(info, collapse = "; ")
[16:21:29.317]                         if (!has_future) {
[16:21:29.317]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:29.317]                             info)
[16:21:29.317]                         }
[16:21:29.317]                         else {
[16:21:29.317]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:29.317]                             info, version)
[16:21:29.317]                         }
[16:21:29.317]                         base::stop(msg)
[16:21:29.317]                       }
[16:21:29.317]                     })
[16:21:29.317]                   }
[16:21:29.317]                   ...future.strategy.old <- future::plan("list")
[16:21:29.317]                   options(future.plan = NULL)
[16:21:29.317]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.317]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:29.317]                 }
[16:21:29.317]                 ...future.workdir <- getwd()
[16:21:29.317]             }
[16:21:29.317]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:29.317]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:29.317]         }
[16:21:29.317]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:29.317]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:29.317]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:29.317]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:29.317]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:29.317]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:29.317]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:29.317]             base::names(...future.oldOptions))
[16:21:29.317]     }
[16:21:29.317]     if (FALSE) {
[16:21:29.317]     }
[16:21:29.317]     else {
[16:21:29.317]         if (TRUE) {
[16:21:29.317]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:29.317]                 open = "w")
[16:21:29.317]         }
[16:21:29.317]         else {
[16:21:29.317]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:29.317]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:29.317]         }
[16:21:29.317]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:29.317]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:29.317]             base::sink(type = "output", split = FALSE)
[16:21:29.317]             base::close(...future.stdout)
[16:21:29.317]         }, add = TRUE)
[16:21:29.317]     }
[16:21:29.317]     ...future.frame <- base::sys.nframe()
[16:21:29.317]     ...future.conditions <- base::list()
[16:21:29.317]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:29.317]     if (FALSE) {
[16:21:29.317]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:29.317]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:29.317]     }
[16:21:29.317]     ...future.result <- base::tryCatch({
[16:21:29.317]         base::withCallingHandlers({
[16:21:29.317]             ...future.value <- base::withVisible(base::local(subset(data, 
[16:21:29.317]                 a == 2)))
[16:21:29.317]             future::FutureResult(value = ...future.value$value, 
[16:21:29.317]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.317]                   ...future.rng), globalenv = if (FALSE) 
[16:21:29.317]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:29.317]                     ...future.globalenv.names))
[16:21:29.317]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:29.317]         }, condition = base::local({
[16:21:29.317]             c <- base::c
[16:21:29.317]             inherits <- base::inherits
[16:21:29.317]             invokeRestart <- base::invokeRestart
[16:21:29.317]             length <- base::length
[16:21:29.317]             list <- base::list
[16:21:29.317]             seq.int <- base::seq.int
[16:21:29.317]             signalCondition <- base::signalCondition
[16:21:29.317]             sys.calls <- base::sys.calls
[16:21:29.317]             `[[` <- base::`[[`
[16:21:29.317]             `+` <- base::`+`
[16:21:29.317]             `<<-` <- base::`<<-`
[16:21:29.317]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:29.317]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:29.317]                   3L)]
[16:21:29.317]             }
[16:21:29.317]             function(cond) {
[16:21:29.317]                 is_error <- inherits(cond, "error")
[16:21:29.317]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:29.317]                   NULL)
[16:21:29.317]                 if (is_error) {
[16:21:29.317]                   sessionInformation <- function() {
[16:21:29.317]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:29.317]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:29.317]                       search = base::search(), system = base::Sys.info())
[16:21:29.317]                   }
[16:21:29.317]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.317]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:29.317]                     cond$call), session = sessionInformation(), 
[16:21:29.317]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:29.317]                   signalCondition(cond)
[16:21:29.317]                 }
[16:21:29.317]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:29.317]                 "immediateCondition"))) {
[16:21:29.317]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:29.317]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.317]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:29.317]                   if (TRUE && !signal) {
[16:21:29.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.317]                     {
[16:21:29.317]                       inherits <- base::inherits
[16:21:29.317]                       invokeRestart <- base::invokeRestart
[16:21:29.317]                       is.null <- base::is.null
[16:21:29.317]                       muffled <- FALSE
[16:21:29.317]                       if (inherits(cond, "message")) {
[16:21:29.317]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.317]                         if (muffled) 
[16:21:29.317]                           invokeRestart("muffleMessage")
[16:21:29.317]                       }
[16:21:29.317]                       else if (inherits(cond, "warning")) {
[16:21:29.317]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.317]                         if (muffled) 
[16:21:29.317]                           invokeRestart("muffleWarning")
[16:21:29.317]                       }
[16:21:29.317]                       else if (inherits(cond, "condition")) {
[16:21:29.317]                         if (!is.null(pattern)) {
[16:21:29.317]                           computeRestarts <- base::computeRestarts
[16:21:29.317]                           grepl <- base::grepl
[16:21:29.317]                           restarts <- computeRestarts(cond)
[16:21:29.317]                           for (restart in restarts) {
[16:21:29.317]                             name <- restart$name
[16:21:29.317]                             if (is.null(name)) 
[16:21:29.317]                               next
[16:21:29.317]                             if (!grepl(pattern, name)) 
[16:21:29.317]                               next
[16:21:29.317]                             invokeRestart(restart)
[16:21:29.317]                             muffled <- TRUE
[16:21:29.317]                             break
[16:21:29.317]                           }
[16:21:29.317]                         }
[16:21:29.317]                       }
[16:21:29.317]                       invisible(muffled)
[16:21:29.317]                     }
[16:21:29.317]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.317]                   }
[16:21:29.317]                 }
[16:21:29.317]                 else {
[16:21:29.317]                   if (TRUE) {
[16:21:29.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.317]                     {
[16:21:29.317]                       inherits <- base::inherits
[16:21:29.317]                       invokeRestart <- base::invokeRestart
[16:21:29.317]                       is.null <- base::is.null
[16:21:29.317]                       muffled <- FALSE
[16:21:29.317]                       if (inherits(cond, "message")) {
[16:21:29.317]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.317]                         if (muffled) 
[16:21:29.317]                           invokeRestart("muffleMessage")
[16:21:29.317]                       }
[16:21:29.317]                       else if (inherits(cond, "warning")) {
[16:21:29.317]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.317]                         if (muffled) 
[16:21:29.317]                           invokeRestart("muffleWarning")
[16:21:29.317]                       }
[16:21:29.317]                       else if (inherits(cond, "condition")) {
[16:21:29.317]                         if (!is.null(pattern)) {
[16:21:29.317]                           computeRestarts <- base::computeRestarts
[16:21:29.317]                           grepl <- base::grepl
[16:21:29.317]                           restarts <- computeRestarts(cond)
[16:21:29.317]                           for (restart in restarts) {
[16:21:29.317]                             name <- restart$name
[16:21:29.317]                             if (is.null(name)) 
[16:21:29.317]                               next
[16:21:29.317]                             if (!grepl(pattern, name)) 
[16:21:29.317]                               next
[16:21:29.317]                             invokeRestart(restart)
[16:21:29.317]                             muffled <- TRUE
[16:21:29.317]                             break
[16:21:29.317]                           }
[16:21:29.317]                         }
[16:21:29.317]                       }
[16:21:29.317]                       invisible(muffled)
[16:21:29.317]                     }
[16:21:29.317]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.317]                   }
[16:21:29.317]                 }
[16:21:29.317]             }
[16:21:29.317]         }))
[16:21:29.317]     }, error = function(ex) {
[16:21:29.317]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:29.317]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.317]                 ...future.rng), started = ...future.startTime, 
[16:21:29.317]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:29.317]             version = "1.8"), class = "FutureResult")
[16:21:29.317]     }, finally = {
[16:21:29.317]         if (!identical(...future.workdir, getwd())) 
[16:21:29.317]             setwd(...future.workdir)
[16:21:29.317]         {
[16:21:29.317]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:29.317]                 ...future.oldOptions$nwarnings <- NULL
[16:21:29.317]             }
[16:21:29.317]             base::options(...future.oldOptions)
[16:21:29.317]             if (.Platform$OS.type == "windows") {
[16:21:29.317]                 old_names <- names(...future.oldEnvVars)
[16:21:29.317]                 envs <- base::Sys.getenv()
[16:21:29.317]                 names <- names(envs)
[16:21:29.317]                 common <- intersect(names, old_names)
[16:21:29.317]                 added <- setdiff(names, old_names)
[16:21:29.317]                 removed <- setdiff(old_names, names)
[16:21:29.317]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:29.317]                   envs[common]]
[16:21:29.317]                 NAMES <- toupper(changed)
[16:21:29.317]                 args <- list()
[16:21:29.317]                 for (kk in seq_along(NAMES)) {
[16:21:29.317]                   name <- changed[[kk]]
[16:21:29.317]                   NAME <- NAMES[[kk]]
[16:21:29.317]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.317]                     next
[16:21:29.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.317]                 }
[16:21:29.317]                 NAMES <- toupper(added)
[16:21:29.317]                 for (kk in seq_along(NAMES)) {
[16:21:29.317]                   name <- added[[kk]]
[16:21:29.317]                   NAME <- NAMES[[kk]]
[16:21:29.317]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.317]                     next
[16:21:29.317]                   args[[name]] <- ""
[16:21:29.317]                 }
[16:21:29.317]                 NAMES <- toupper(removed)
[16:21:29.317]                 for (kk in seq_along(NAMES)) {
[16:21:29.317]                   name <- removed[[kk]]
[16:21:29.317]                   NAME <- NAMES[[kk]]
[16:21:29.317]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.317]                     next
[16:21:29.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.317]                 }
[16:21:29.317]                 if (length(args) > 0) 
[16:21:29.317]                   base::do.call(base::Sys.setenv, args = args)
[16:21:29.317]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:29.317]             }
[16:21:29.317]             else {
[16:21:29.317]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:29.317]             }
[16:21:29.317]             {
[16:21:29.317]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:29.317]                   0L) {
[16:21:29.317]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:29.317]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:29.317]                   base::options(opts)
[16:21:29.317]                 }
[16:21:29.317]                 {
[16:21:29.317]                   {
[16:21:29.317]                     NULL
[16:21:29.317]                     RNGkind("Mersenne-Twister")
[16:21:29.317]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:29.317]                       inherits = FALSE)
[16:21:29.317]                   }
[16:21:29.317]                   options(future.plan = NULL)
[16:21:29.317]                   if (is.na(NA_character_)) 
[16:21:29.317]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.317]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:29.317]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:29.317]                     .init = FALSE)
[16:21:29.317]                 }
[16:21:29.317]             }
[16:21:29.317]         }
[16:21:29.317]     })
[16:21:29.317]     if (TRUE) {
[16:21:29.317]         base::sink(type = "output", split = FALSE)
[16:21:29.317]         if (TRUE) {
[16:21:29.317]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:29.317]         }
[16:21:29.317]         else {
[16:21:29.317]             ...future.result["stdout"] <- base::list(NULL)
[16:21:29.317]         }
[16:21:29.317]         base::close(...future.stdout)
[16:21:29.317]         ...future.stdout <- NULL
[16:21:29.317]     }
[16:21:29.317]     ...future.result$conditions <- ...future.conditions
[16:21:29.317]     ...future.result$finished <- base::Sys.time()
[16:21:29.317]     ...future.result
[16:21:29.317] }
[16:21:29.352]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.319] assign_globals() ...
[16:21:29.352]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.320] List of 1
[16:21:29.320]  $ data:'data.frame':	3 obs. of  2 variables:
[16:21:29.320]   ..$ a: int [1:3] 1 2 3
[16:21:29.320]   ..$ b: int [1:3] 3 2 1
[16:21:29.320]  - attr(*, "where")=List of 1
[16:21:29.320]   ..$ data:<environment: R_EmptyEnv> 
[16:21:29.320]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:29.320]  - attr(*, "resolved")= logi FALSE
[16:21:29.320]  - attr(*, "total_size")= num 128
[16:21:29.320]  - attr(*, "already-done")= logi TRUE
[16:21:29.352]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.329] - copied ‘data’ to environment
[16:21:29.353]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.330] assign_globals() ... done
[16:21:29.353]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.330] plan(): Setting new future strategy stack:
[16:21:29.353]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.330] List of future strategies:
[16:21:29.330] 1. sequential:
[16:21:29.330]    - args: function (..., envir = parent.frame())
[16:21:29.330]    - tweaked: FALSE
[16:21:29.330]    - call: NULL
[16:21:29.353]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.331] plan(): nbrOfWorkers() = 1
[16:21:29.353]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.332] plan(): Setting new future strategy stack:
[16:21:29.353]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.332] List of future strategies:
[16:21:29.332] 1. multicore:
[16:21:29.332]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:29.332]    - tweaked: FALSE
[16:21:29.332]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.353]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.336] plan(): nbrOfWorkers() = 1
[16:21:29.354]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.336] SequentialFuture started (and completed)
[16:21:29.354]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.337] - Launch lazy future ... done
[16:21:29.354]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.337] run() for ‘SequentialFuture’ ... done
[16:21:29.354] signalConditions() ... done
- plan(list('multicore', 'multicore')) ... DONE
- plan(list('multicore', 'multisession')) ...
[16:21:29.355] plan(): Setting new future strategy stack:
[16:21:29.355] List of future strategies:
[16:21:29.355] 1. multicore:
[16:21:29.355]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:29.355]    - tweaked: FALSE
[16:21:29.355]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.355] 2. multisession:
[16:21:29.355]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:29.355]    - tweaked: FALSE
[16:21:29.355]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.359] plan(): nbrOfWorkers() = 2
[16:21:29.363] getGlobalsAndPackages() ...
[16:21:29.363] Searching for globals...
[16:21:29.383] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:21:29.383] Searching for globals ... DONE
[16:21:29.383] Resolving globals: FALSE
[16:21:29.385] The total size of the 2 globals is 90.64 KiB (92816 bytes)
[16:21:29.385] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 90.64 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (90.52 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:21:29.385] - globals: [2] ‘nested’, ‘strategy2’
[16:21:29.385] - packages: [1] ‘future’
[16:21:29.386] getGlobalsAndPackages() ... DONE
[16:21:29.386] run() for ‘Future’ ...
[16:21:29.386] - state: ‘created’
[16:21:29.386] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:29.390] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:29.390] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:29.390]   - Field: ‘label’
[16:21:29.391]   - Field: ‘local’
[16:21:29.391]   - Field: ‘owner’
[16:21:29.391]   - Field: ‘envir’
[16:21:29.391]   - Field: ‘workers’
[16:21:29.391]   - Field: ‘packages’
[16:21:29.391]   - Field: ‘gc’
[16:21:29.391]   - Field: ‘job’
[16:21:29.391]   - Field: ‘conditions’
[16:21:29.391]   - Field: ‘expr’
[16:21:29.392]   - Field: ‘uuid’
[16:21:29.392]   - Field: ‘seed’
[16:21:29.392]   - Field: ‘version’
[16:21:29.392]   - Field: ‘result’
[16:21:29.392]   - Field: ‘asynchronous’
[16:21:29.392]   - Field: ‘calls’
[16:21:29.392]   - Field: ‘globals’
[16:21:29.392]   - Field: ‘stdout’
[16:21:29.392]   - Field: ‘earlySignal’
[16:21:29.393]   - Field: ‘lazy’
[16:21:29.393]   - Field: ‘state’
[16:21:29.393] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:29.393] - Launch lazy future ...
[16:21:29.393] Packages needed by the future expression (n = 1): ‘future’
[16:21:29.393] Packages needed by future strategies (n = 1): ‘future’
[16:21:29.394] {
[16:21:29.394]     {
[16:21:29.394]         {
[16:21:29.394]             ...future.startTime <- base::Sys.time()
[16:21:29.394]             {
[16:21:29.394]                 {
[16:21:29.394]                   {
[16:21:29.394]                     {
[16:21:29.394]                       {
[16:21:29.394]                         base::local({
[16:21:29.394]                           has_future <- base::requireNamespace("future", 
[16:21:29.394]                             quietly = TRUE)
[16:21:29.394]                           if (has_future) {
[16:21:29.394]                             ns <- base::getNamespace("future")
[16:21:29.394]                             version <- ns[[".package"]][["version"]]
[16:21:29.394]                             if (is.null(version)) 
[16:21:29.394]                               version <- utils::packageVersion("future")
[16:21:29.394]                           }
[16:21:29.394]                           else {
[16:21:29.394]                             version <- NULL
[16:21:29.394]                           }
[16:21:29.394]                           if (!has_future || version < "1.8.0") {
[16:21:29.394]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:29.394]                               "", base::R.version$version.string), 
[16:21:29.394]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:29.394]                                 base::R.version$platform, 8 * 
[16:21:29.394]                                   base::.Machine$sizeof.pointer), 
[16:21:29.394]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:29.394]                                 "release", "version")], collapse = " "), 
[16:21:29.394]                               hostname = base::Sys.info()[["nodename"]])
[16:21:29.394]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:29.394]                               info)
[16:21:29.394]                             info <- base::paste(info, collapse = "; ")
[16:21:29.394]                             if (!has_future) {
[16:21:29.394]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:29.394]                                 info)
[16:21:29.394]                             }
[16:21:29.394]                             else {
[16:21:29.394]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:29.394]                                 info, version)
[16:21:29.394]                             }
[16:21:29.394]                             base::stop(msg)
[16:21:29.394]                           }
[16:21:29.394]                         })
[16:21:29.394]                       }
[16:21:29.394]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:29.394]                       base::options(mc.cores = 1L)
[16:21:29.394]                     }
[16:21:29.394]                     base::local({
[16:21:29.394]                       for (pkg in "future") {
[16:21:29.394]                         base::loadNamespace(pkg)
[16:21:29.394]                         base::library(pkg, character.only = TRUE)
[16:21:29.394]                       }
[16:21:29.394]                     })
[16:21:29.394]                   }
[16:21:29.394]                   ...future.strategy.old <- future::plan("list")
[16:21:29.394]                   options(future.plan = NULL)
[16:21:29.394]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.394]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:21:29.394]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:21:29.394]                     envir = parent.frame()) 
[16:21:29.394]                   {
[16:21:29.394]                     if (is.function(workers)) 
[16:21:29.394]                       workers <- workers()
[16:21:29.394]                     workers <- structure(as.integer(workers), 
[16:21:29.394]                       class = class(workers))
[16:21:29.394]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:21:29.394]                       workers >= 1)
[16:21:29.394]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:21:29.394]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:21:29.394]                     }
[16:21:29.394]                     future <- MultisessionFuture(..., workers = workers, 
[16:21:29.394]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:21:29.394]                       envir = envir)
[16:21:29.394]                     if (!future$lazy) 
[16:21:29.394]                       future <- run(future)
[16:21:29.394]                     invisible(future)
[16:21:29.394]                   }), .cleanup = FALSE, .init = FALSE)
[16:21:29.394]                 }
[16:21:29.394]                 ...future.workdir <- getwd()
[16:21:29.394]             }
[16:21:29.394]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:29.394]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:29.394]         }
[16:21:29.394]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:29.394]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:29.394]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:29.394]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:29.394]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:29.394]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:29.394]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:29.394]             base::names(...future.oldOptions))
[16:21:29.394]     }
[16:21:29.394]     if (FALSE) {
[16:21:29.394]     }
[16:21:29.394]     else {
[16:21:29.394]         if (TRUE) {
[16:21:29.394]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:29.394]                 open = "w")
[16:21:29.394]         }
[16:21:29.394]         else {
[16:21:29.394]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:29.394]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:29.394]         }
[16:21:29.394]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:29.394]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:29.394]             base::sink(type = "output", split = FALSE)
[16:21:29.394]             base::close(...future.stdout)
[16:21:29.394]         }, add = TRUE)
[16:21:29.394]     }
[16:21:29.394]     ...future.frame <- base::sys.nframe()
[16:21:29.394]     ...future.conditions <- base::list()
[16:21:29.394]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:29.394]     if (FALSE) {
[16:21:29.394]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:29.394]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:29.394]     }
[16:21:29.394]     ...future.result <- base::tryCatch({
[16:21:29.394]         base::withCallingHandlers({
[16:21:29.394]             ...future.value <- base::withVisible(base::local({
[16:21:29.394]                 withCallingHandlers({
[16:21:29.394]                   {
[16:21:29.394]                     a <- 1L
[16:21:29.394]                     plan_a <- unclass(future::plan("list"))
[16:21:29.394]                     nested_a <- nested[-1]
[16:21:29.394]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:21:29.394]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:21:29.394]                       strategy2))
[16:21:29.394]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:21:29.394]                       "init") <- NULL
[16:21:29.394]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:21:29.394]                       "init") <- NULL
[16:21:29.394]                     stopifnot(all.equal(plan_a, nested_a))
[16:21:29.394]                     y %<-% {
[16:21:29.394]                       b <- 2L
[16:21:29.394]                       plan_b <- future::plan("list")
[16:21:29.394]                       nested_b <- nested_a[-1]
[16:21:29.394]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:21:29.394]                         1L, inherits(plan_b[[1]], "future"), 
[16:21:29.394]                         inherits(future::plan("next"), "sequential"))
[16:21:29.394]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:21:29.394]                         b = b, nested_b = nested_b, plan_b = plan_b)
[16:21:29.394]                     }
[16:21:29.394]                     y
[16:21:29.394]                   }
[16:21:29.394]                 }, immediateCondition = function(cond) {
[16:21:29.394]                   save_rds <- function (object, pathname, ...) 
[16:21:29.394]                   {
[16:21:29.394]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:29.394]                     if (file_test("-f", pathname_tmp)) {
[16:21:29.394]                       fi_tmp <- file.info(pathname_tmp)
[16:21:29.394]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:29.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:29.394]                         fi_tmp[["mtime"]])
[16:21:29.394]                     }
[16:21:29.394]                     tryCatch({
[16:21:29.394]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:29.394]                     }, error = function(ex) {
[16:21:29.394]                       msg <- conditionMessage(ex)
[16:21:29.394]                       fi_tmp <- file.info(pathname_tmp)
[16:21:29.394]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:29.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:29.394]                         fi_tmp[["mtime"]], msg)
[16:21:29.394]                       ex$message <- msg
[16:21:29.394]                       stop(ex)
[16:21:29.394]                     })
[16:21:29.394]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:29.394]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:29.394]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:29.394]                       fi_tmp <- file.info(pathname_tmp)
[16:21:29.394]                       fi <- file.info(pathname)
[16:21:29.394]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:29.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:29.394]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:29.394]                         fi[["size"]], fi[["mtime"]])
[16:21:29.394]                       stop(msg)
[16:21:29.394]                     }
[16:21:29.394]                     invisible(pathname)
[16:21:29.394]                   }
[16:21:29.394]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:29.394]                     rootPath = tempdir()) 
[16:21:29.394]                   {
[16:21:29.394]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:29.394]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:29.394]                       tmpdir = path, fileext = ".rds")
[16:21:29.394]                     save_rds(obj, file)
[16:21:29.394]                   }
[16:21:29.394]                   saveImmediateCondition(cond, path = "/tmp/RtmpnVB70K/.future/immediateConditions")
[16:21:29.394]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.394]                   {
[16:21:29.394]                     inherits <- base::inherits
[16:21:29.394]                     invokeRestart <- base::invokeRestart
[16:21:29.394]                     is.null <- base::is.null
[16:21:29.394]                     muffled <- FALSE
[16:21:29.394]                     if (inherits(cond, "message")) {
[16:21:29.394]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:29.394]                       if (muffled) 
[16:21:29.394]                         invokeRestart("muffleMessage")
[16:21:29.394]                     }
[16:21:29.394]                     else if (inherits(cond, "warning")) {
[16:21:29.394]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:29.394]                       if (muffled) 
[16:21:29.394]                         invokeRestart("muffleWarning")
[16:21:29.394]                     }
[16:21:29.394]                     else if (inherits(cond, "condition")) {
[16:21:29.394]                       if (!is.null(pattern)) {
[16:21:29.394]                         computeRestarts <- base::computeRestarts
[16:21:29.394]                         grepl <- base::grepl
[16:21:29.394]                         restarts <- computeRestarts(cond)
[16:21:29.394]                         for (restart in restarts) {
[16:21:29.394]                           name <- restart$name
[16:21:29.394]                           if (is.null(name)) 
[16:21:29.394]                             next
[16:21:29.394]                           if (!grepl(pattern, name)) 
[16:21:29.394]                             next
[16:21:29.394]                           invokeRestart(restart)
[16:21:29.394]                           muffled <- TRUE
[16:21:29.394]                           break
[16:21:29.394]                         }
[16:21:29.394]                       }
[16:21:29.394]                     }
[16:21:29.394]                     invisible(muffled)
[16:21:29.394]                   }
[16:21:29.394]                   muffleCondition(cond)
[16:21:29.394]                 })
[16:21:29.394]             }))
[16:21:29.394]             future::FutureResult(value = ...future.value$value, 
[16:21:29.394]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.394]                   ...future.rng), globalenv = if (FALSE) 
[16:21:29.394]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:29.394]                     ...future.globalenv.names))
[16:21:29.394]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:29.394]         }, condition = base::local({
[16:21:29.394]             c <- base::c
[16:21:29.394]             inherits <- base::inherits
[16:21:29.394]             invokeRestart <- base::invokeRestart
[16:21:29.394]             length <- base::length
[16:21:29.394]             list <- base::list
[16:21:29.394]             seq.int <- base::seq.int
[16:21:29.394]             signalCondition <- base::signalCondition
[16:21:29.394]             sys.calls <- base::sys.calls
[16:21:29.394]             `[[` <- base::`[[`
[16:21:29.394]             `+` <- base::`+`
[16:21:29.394]             `<<-` <- base::`<<-`
[16:21:29.394]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:29.394]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:29.394]                   3L)]
[16:21:29.394]             }
[16:21:29.394]             function(cond) {
[16:21:29.394]                 is_error <- inherits(cond, "error")
[16:21:29.394]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:29.394]                   NULL)
[16:21:29.394]                 if (is_error) {
[16:21:29.394]                   sessionInformation <- function() {
[16:21:29.394]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:29.394]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:29.394]                       search = base::search(), system = base::Sys.info())
[16:21:29.394]                   }
[16:21:29.394]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.394]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:29.394]                     cond$call), session = sessionInformation(), 
[16:21:29.394]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:29.394]                   signalCondition(cond)
[16:21:29.394]                 }
[16:21:29.394]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:29.394]                 "immediateCondition"))) {
[16:21:29.394]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:29.394]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.394]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:29.394]                   if (TRUE && !signal) {
[16:21:29.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.394]                     {
[16:21:29.394]                       inherits <- base::inherits
[16:21:29.394]                       invokeRestart <- base::invokeRestart
[16:21:29.394]                       is.null <- base::is.null
[16:21:29.394]                       muffled <- FALSE
[16:21:29.394]                       if (inherits(cond, "message")) {
[16:21:29.394]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.394]                         if (muffled) 
[16:21:29.394]                           invokeRestart("muffleMessage")
[16:21:29.394]                       }
[16:21:29.394]                       else if (inherits(cond, "warning")) {
[16:21:29.394]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.394]                         if (muffled) 
[16:21:29.394]                           invokeRestart("muffleWarning")
[16:21:29.394]                       }
[16:21:29.394]                       else if (inherits(cond, "condition")) {
[16:21:29.394]                         if (!is.null(pattern)) {
[16:21:29.394]                           computeRestarts <- base::computeRestarts
[16:21:29.394]                           grepl <- base::grepl
[16:21:29.394]                           restarts <- computeRestarts(cond)
[16:21:29.394]                           for (restart in restarts) {
[16:21:29.394]                             name <- restart$name
[16:21:29.394]                             if (is.null(name)) 
[16:21:29.394]                               next
[16:21:29.394]                             if (!grepl(pattern, name)) 
[16:21:29.394]                               next
[16:21:29.394]                             invokeRestart(restart)
[16:21:29.394]                             muffled <- TRUE
[16:21:29.394]                             break
[16:21:29.394]                           }
[16:21:29.394]                         }
[16:21:29.394]                       }
[16:21:29.394]                       invisible(muffled)
[16:21:29.394]                     }
[16:21:29.394]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.394]                   }
[16:21:29.394]                 }
[16:21:29.394]                 else {
[16:21:29.394]                   if (TRUE) {
[16:21:29.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.394]                     {
[16:21:29.394]                       inherits <- base::inherits
[16:21:29.394]                       invokeRestart <- base::invokeRestart
[16:21:29.394]                       is.null <- base::is.null
[16:21:29.394]                       muffled <- FALSE
[16:21:29.394]                       if (inherits(cond, "message")) {
[16:21:29.394]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.394]                         if (muffled) 
[16:21:29.394]                           invokeRestart("muffleMessage")
[16:21:29.394]                       }
[16:21:29.394]                       else if (inherits(cond, "warning")) {
[16:21:29.394]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.394]                         if (muffled) 
[16:21:29.394]                           invokeRestart("muffleWarning")
[16:21:29.394]                       }
[16:21:29.394]                       else if (inherits(cond, "condition")) {
[16:21:29.394]                         if (!is.null(pattern)) {
[16:21:29.394]                           computeRestarts <- base::computeRestarts
[16:21:29.394]                           grepl <- base::grepl
[16:21:29.394]                           restarts <- computeRestarts(cond)
[16:21:29.394]                           for (restart in restarts) {
[16:21:29.394]                             name <- restart$name
[16:21:29.394]                             if (is.null(name)) 
[16:21:29.394]                               next
[16:21:29.394]                             if (!grepl(pattern, name)) 
[16:21:29.394]                               next
[16:21:29.394]                             invokeRestart(restart)
[16:21:29.394]                             muffled <- TRUE
[16:21:29.394]                             break
[16:21:29.394]                           }
[16:21:29.394]                         }
[16:21:29.394]                       }
[16:21:29.394]                       invisible(muffled)
[16:21:29.394]                     }
[16:21:29.394]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.394]                   }
[16:21:29.394]                 }
[16:21:29.394]             }
[16:21:29.394]         }))
[16:21:29.394]     }, error = function(ex) {
[16:21:29.394]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:29.394]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.394]                 ...future.rng), started = ...future.startTime, 
[16:21:29.394]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:29.394]             version = "1.8"), class = "FutureResult")
[16:21:29.394]     }, finally = {
[16:21:29.394]         if (!identical(...future.workdir, getwd())) 
[16:21:29.394]             setwd(...future.workdir)
[16:21:29.394]         {
[16:21:29.394]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:29.394]                 ...future.oldOptions$nwarnings <- NULL
[16:21:29.394]             }
[16:21:29.394]             base::options(...future.oldOptions)
[16:21:29.394]             if (.Platform$OS.type == "windows") {
[16:21:29.394]                 old_names <- names(...future.oldEnvVars)
[16:21:29.394]                 envs <- base::Sys.getenv()
[16:21:29.394]                 names <- names(envs)
[16:21:29.394]                 common <- intersect(names, old_names)
[16:21:29.394]                 added <- setdiff(names, old_names)
[16:21:29.394]                 removed <- setdiff(old_names, names)
[16:21:29.394]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:29.394]                   envs[common]]
[16:21:29.394]                 NAMES <- toupper(changed)
[16:21:29.394]                 args <- list()
[16:21:29.394]                 for (kk in seq_along(NAMES)) {
[16:21:29.394]                   name <- changed[[kk]]
[16:21:29.394]                   NAME <- NAMES[[kk]]
[16:21:29.394]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.394]                     next
[16:21:29.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.394]                 }
[16:21:29.394]                 NAMES <- toupper(added)
[16:21:29.394]                 for (kk in seq_along(NAMES)) {
[16:21:29.394]                   name <- added[[kk]]
[16:21:29.394]                   NAME <- NAMES[[kk]]
[16:21:29.394]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.394]                     next
[16:21:29.394]                   args[[name]] <- ""
[16:21:29.394]                 }
[16:21:29.394]                 NAMES <- toupper(removed)
[16:21:29.394]                 for (kk in seq_along(NAMES)) {
[16:21:29.394]                   name <- removed[[kk]]
[16:21:29.394]                   NAME <- NAMES[[kk]]
[16:21:29.394]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.394]                     next
[16:21:29.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.394]                 }
[16:21:29.394]                 if (length(args) > 0) 
[16:21:29.394]                   base::do.call(base::Sys.setenv, args = args)
[16:21:29.394]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:29.394]             }
[16:21:29.394]             else {
[16:21:29.394]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:29.394]             }
[16:21:29.394]             {
[16:21:29.394]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:29.394]                   0L) {
[16:21:29.394]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:29.394]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:29.394]                   base::options(opts)
[16:21:29.394]                 }
[16:21:29.394]                 {
[16:21:29.394]                   {
[16:21:29.394]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:29.394]                     NULL
[16:21:29.394]                   }
[16:21:29.394]                   options(future.plan = NULL)
[16:21:29.394]                   if (is.na(NA_character_)) 
[16:21:29.394]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.394]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:29.394]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:29.394]                     .init = FALSE)
[16:21:29.394]                 }
[16:21:29.394]             }
[16:21:29.394]         }
[16:21:29.394]     })
[16:21:29.394]     if (TRUE) {
[16:21:29.394]         base::sink(type = "output", split = FALSE)
[16:21:29.394]         if (TRUE) {
[16:21:29.394]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:29.394]         }
[16:21:29.394]         else {
[16:21:29.394]             ...future.result["stdout"] <- base::list(NULL)
[16:21:29.394]         }
[16:21:29.394]         base::close(...future.stdout)
[16:21:29.394]         ...future.stdout <- NULL
[16:21:29.394]     }
[16:21:29.394]     ...future.result$conditions <- ...future.conditions
[16:21:29.394]     ...future.result$finished <- base::Sys.time()
[16:21:29.394]     ...future.result
[16:21:29.394] }
[16:21:29.397] assign_globals() ...
[16:21:29.397] List of 2
[16:21:29.397]  $ nested   :List of 2
[16:21:29.397]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:21:29.397]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:21:29.397]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:21:29.397]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[16:21:29.397]     envir = parent.frame())  
[16:21:29.397]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[16:21:29.397]   .. ..- attr(*, "init")= logi TRUE
[16:21:29.397]   .. ..- attr(*, "untweakable")= chr "persistent"
[16:21:29.397]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:21:29.397]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:21:29.397]  $ strategy2: chr "multisession"
[16:21:29.397]  - attr(*, "where")=List of 2
[16:21:29.397]   ..$ nested   :<environment: R_EmptyEnv> 
[16:21:29.397]   ..$ strategy2:<environment: R_EmptyEnv> 
[16:21:29.397]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:29.397]  - attr(*, "resolved")= logi FALSE
[16:21:29.397]  - attr(*, "total_size")= num 92816
[16:21:29.397]  - attr(*, "already-done")= logi TRUE
[16:21:29.403] - copied ‘nested’ to environment
[16:21:29.403] - copied ‘strategy2’ to environment
[16:21:29.403] assign_globals() ... done
[16:21:29.403] requestCore(): workers = 2
[16:21:29.406] MulticoreFuture started
[16:21:29.406] - Launch lazy future ... done
[16:21:29.406] run() for ‘MulticoreFuture’ ... done
[16:21:29.407] result() for MulticoreFuture ...
[16:21:29.407] plan(): Setting new future strategy stack:
[16:21:29.407] List of future strategies:
[16:21:29.407] 1. multisession:
[16:21:29.407]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:29.407]    - tweaked: FALSE
[16:21:29.407]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.413] plan(): nbrOfWorkers() = 1
[16:21:29.454] plan(): Setting new future strategy stack:
[16:21:29.454] List of future strategies:
[16:21:29.454] 1. multicore:
[16:21:29.454]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:29.454]    - tweaked: FALSE
[16:21:29.454]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.454] 2. multisession:
[16:21:29.454]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:29.454]    - tweaked: FALSE
[16:21:29.454]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.458] plan(): nbrOfWorkers() = 2
[16:21:29.459] result() for MulticoreFuture ...
[16:21:29.460] result() for MulticoreFuture ... done
[16:21:29.460] signalConditions() ...
[16:21:29.460]  - include = ‘immediateCondition’
[16:21:29.460]  - exclude = 
[16:21:29.460]  - resignal = FALSE
[16:21:29.460]  - Number of conditions: 54
[16:21:29.460] signalConditions() ... done
[16:21:29.461] result() for MulticoreFuture ... done
[16:21:29.461] result() for MulticoreFuture ...
[16:21:29.461] result() for MulticoreFuture ... done
[16:21:29.461] signalConditions() ...
[16:21:29.461]  - include = ‘immediateCondition’
[16:21:29.461]  - exclude = 
[16:21:29.461]  - resignal = FALSE
[16:21:29.461]  - Number of conditions: 54
[16:21:29.461] signalConditions() ... done
[16:21:29.462] Future state: ‘finished’
[16:21:29.462] result() for MulticoreFuture ...
[16:21:29.462] result() for MulticoreFuture ... done
[16:21:29.462] signalConditions() ...
[16:21:29.462]  - include = ‘condition’
[16:21:29.462]  - exclude = ‘immediateCondition’
[16:21:29.462]  - resignal = TRUE
[16:21:29.462]  - Number of conditions: 54
[16:21:29.463]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.415] getGlobalsAndPackages() ...
[16:21:29.463]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.415] Searching for globals...
[16:21:29.463]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.422] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[16:21:29.463]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.423] Searching for globals ... DONE
[16:21:29.463]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.423] Resolving globals: FALSE
[16:21:29.463]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.424] The total size of the 3 globals is 87.82 KiB (89928 bytes)
[16:21:29.464]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.425] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 87.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (43.88 KiB of class ‘list’), ‘plan_a’ (43.88 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[16:21:29.464]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.425] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[16:21:29.464]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.425] 
[16:21:29.464]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.425] getGlobalsAndPackages() ... DONE
[16:21:29.464]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.426] run() for ‘Future’ ...
[16:21:29.464]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.426] - state: ‘created’
[16:21:29.465]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.426] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:29.465]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.431] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:29.465]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.431] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:29.465]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.431]   - Field: ‘label’
[16:21:29.465]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.431]   - Field: ‘local’
[16:21:29.465]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.431]   - Field: ‘owner’
[16:21:29.465]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.431]   - Field: ‘envir’
[16:21:29.466]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.432]   - Field: ‘packages’
[16:21:29.466]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.432]   - Field: ‘gc’
[16:21:29.466]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.432]   - Field: ‘conditions’
[16:21:29.466]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.432]   - Field: ‘expr’
[16:21:29.466]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.432]   - Field: ‘uuid’
[16:21:29.466]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.432]   - Field: ‘seed’
[16:21:29.467]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.433]   - Field: ‘version’
[16:21:29.467]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.433]   - Field: ‘result’
[16:21:29.467]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.433]   - Field: ‘asynchronous’
[16:21:29.467]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.433]   - Field: ‘calls’
[16:21:29.467]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.433]   - Field: ‘globals’
[16:21:29.467]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.433]   - Field: ‘stdout’
[16:21:29.467]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.434]   - Field: ‘earlySignal’
[16:21:29.468]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.434]   - Field: ‘lazy’
[16:21:29.468]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.434]   - Field: ‘state’
[16:21:29.468]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.434] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:29.468]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.434] - Launch lazy future ...
[16:21:29.468]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.434] Packages needed by the future expression (n = 0): <none>
[16:21:29.468]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.435] Packages needed by future strategies (n = 0): <none>
[16:21:29.469]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.435] {
[16:21:29.435]     {
[16:21:29.435]         {
[16:21:29.435]             ...future.startTime <- base::Sys.time()
[16:21:29.435]             {
[16:21:29.435]                 {
[16:21:29.435]                   {
[16:21:29.435]                     base::local({
[16:21:29.435]                       has_future <- base::requireNamespace("future", 
[16:21:29.435]                         quietly = TRUE)
[16:21:29.435]                       if (has_future) {
[16:21:29.435]                         ns <- base::getNamespace("future")
[16:21:29.435]                         version <- ns[[".package"]][["version"]]
[16:21:29.435]                         if (is.null(version)) 
[16:21:29.435]                           version <- utils::packageVersion("future")
[16:21:29.435]                       }
[16:21:29.435]                       else {
[16:21:29.435]                         version <- NULL
[16:21:29.435]                       }
[16:21:29.435]                       if (!has_future || version < "1.8.0") {
[16:21:29.435]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:29.435]                           "", base::R.version$version.string), 
[16:21:29.435]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:29.435]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:29.435]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:29.435]                             "release", "version")], collapse = " "), 
[16:21:29.435]                           hostname = base::Sys.info()[["nodename"]])
[16:21:29.435]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:29.435]                           info)
[16:21:29.435]                         info <- base::paste(info, collapse = "; ")
[16:21:29.435]                         if (!has_future) {
[16:21:29.435]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:29.435]                             info)
[16:21:29.435]                         }
[16:21:29.435]                         else {
[16:21:29.435]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:29.435]                             info, version)
[16:21:29.435]                         }
[16:21:29.435]                         base::stop(msg)
[16:21:29.435]                       }
[16:21:29.435]                     })
[16:21:29.435]                   }
[16:21:29.435]                   ...future.strategy.old <- future::plan("list")
[16:21:29.435]                   options(future.plan = NULL)
[16:21:29.435]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.435]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:29.435]                 }
[16:21:29.435]                 ...future.workdir <- getwd()
[16:21:29.435]             }
[16:21:29.435]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:29.435]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:29.435]         }
[16:21:29.435]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:29.435]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:29.435]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:29.435]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:29.435]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:29.435]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:29.435]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:29.435]             base::names(...future.oldOptions))
[16:21:29.435]     }
[16:21:29.435]     if (FALSE) {
[16:21:29.435]     }
[16:21:29.435]     else {
[16:21:29.435]         if (TRUE) {
[16:21:29.435]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:29.435]                 open = "w")
[16:21:29.435]         }
[16:21:29.435]         else {
[16:21:29.435]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:29.435]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:29.435]         }
[16:21:29.435]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:29.435]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:29.435]             base::sink(type = "output", split = FALSE)
[16:21:29.435]             base::close(...future.stdout)
[16:21:29.435]         }, add = TRUE)
[16:21:29.435]     }
[16:21:29.435]     ...future.frame <- base::sys.nframe()
[16:21:29.435]     ...future.conditions <- base::list()
[16:21:29.435]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:29.435]     if (FALSE) {
[16:21:29.435]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:29.435]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:29.435]     }
[16:21:29.435]     ...future.result <- base::tryCatch({
[16:21:29.435]         base::withCallingHandlers({
[16:21:29.435]             ...future.value <- base::withVisible(base::local({
[16:21:29.435]                 b <- 2L
[16:21:29.435]                 plan_b <- future::plan("list")
[16:21:29.435]                 nested_b <- nested_a[-1]
[16:21:29.435]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:21:29.435]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:21:29.435]                   "sequential"))
[16:21:29.435]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:21:29.435]                   b = b, nested_b = nested_b, plan_b = plan_b)
[16:21:29.435]             }))
[16:21:29.435]             future::FutureResult(value = ...future.value$value, 
[16:21:29.435]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.435]                   ...future.rng), globalenv = if (FALSE) 
[16:21:29.435]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:29.435]                     ...future.globalenv.names))
[16:21:29.435]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:29.435]         }, condition = base::local({
[16:21:29.435]             c <- base::c
[16:21:29.435]             inherits <- base::inherits
[16:21:29.435]             invokeRestart <- base::invokeRestart
[16:21:29.435]             length <- base::length
[16:21:29.435]             list <- base::list
[16:21:29.435]             seq.int <- base::seq.int
[16:21:29.435]             signalCondition <- base::signalCondition
[16:21:29.435]             sys.calls <- base::sys.calls
[16:21:29.435]             `[[` <- base::`[[`
[16:21:29.435]             `+` <- base::`+`
[16:21:29.435]             `<<-` <- base::`<<-`
[16:21:29.435]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:29.435]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:29.435]                   3L)]
[16:21:29.435]             }
[16:21:29.435]             function(cond) {
[16:21:29.435]                 is_error <- inherits(cond, "error")
[16:21:29.435]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:29.435]                   NULL)
[16:21:29.435]                 if (is_error) {
[16:21:29.435]                   sessionInformation <- function() {
[16:21:29.435]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:29.435]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:29.435]                       search = base::search(), system = base::Sys.info())
[16:21:29.435]                   }
[16:21:29.435]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.435]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:29.435]                     cond$call), session = sessionInformation(), 
[16:21:29.435]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:29.435]                   signalCondition(cond)
[16:21:29.435]                 }
[16:21:29.435]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:29.435]                 "immediateCondition"))) {
[16:21:29.435]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:29.435]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.435]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:29.435]                   if (TRUE && !signal) {
[16:21:29.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.435]                     {
[16:21:29.435]                       inherits <- base::inherits
[16:21:29.435]                       invokeRestart <- base::invokeRestart
[16:21:29.435]                       is.null <- base::is.null
[16:21:29.435]                       muffled <- FALSE
[16:21:29.435]                       if (inherits(cond, "message")) {
[16:21:29.435]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.435]                         if (muffled) 
[16:21:29.435]                           invokeRestart("muffleMessage")
[16:21:29.435]                       }
[16:21:29.435]                       else if (inherits(cond, "warning")) {
[16:21:29.435]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.435]                         if (muffled) 
[16:21:29.435]                           invokeRestart("muffleWarning")
[16:21:29.435]                       }
[16:21:29.435]                       else if (inherits(cond, "condition")) {
[16:21:29.435]                         if (!is.null(pattern)) {
[16:21:29.435]                           computeRestarts <- base::computeRestarts
[16:21:29.435]                           grepl <- base::grepl
[16:21:29.435]                           restarts <- computeRestarts(cond)
[16:21:29.435]                           for (restart in restarts) {
[16:21:29.435]                             name <- restart$name
[16:21:29.435]                             if (is.null(name)) 
[16:21:29.435]                               next
[16:21:29.435]                             if (!grepl(pattern, name)) 
[16:21:29.435]                               next
[16:21:29.435]                             invokeRestart(restart)
[16:21:29.435]                             muffled <- TRUE
[16:21:29.435]                             break
[16:21:29.435]                           }
[16:21:29.435]                         }
[16:21:29.435]                       }
[16:21:29.435]                       invisible(muffled)
[16:21:29.435]                     }
[16:21:29.435]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.435]                   }
[16:21:29.435]                 }
[16:21:29.435]                 else {
[16:21:29.435]                   if (TRUE) {
[16:21:29.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.435]                     {
[16:21:29.435]                       inherits <- base::inherits
[16:21:29.435]                       invokeRestart <- base::invokeRestart
[16:21:29.435]                       is.null <- base::is.null
[16:21:29.435]                       muffled <- FALSE
[16:21:29.435]                       if (inherits(cond, "message")) {
[16:21:29.435]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.435]                         if (muffled) 
[16:21:29.435]                           invokeRestart("muffleMessage")
[16:21:29.435]                       }
[16:21:29.435]                       else if (inherits(cond, "warning")) {
[16:21:29.435]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.435]                         if (muffled) 
[16:21:29.435]                           invokeRestart("muffleWarning")
[16:21:29.435]                       }
[16:21:29.435]                       else if (inherits(cond, "condition")) {
[16:21:29.435]                         if (!is.null(pattern)) {
[16:21:29.435]                           computeRestarts <- base::computeRestarts
[16:21:29.435]                           grepl <- base::grepl
[16:21:29.435]                           restarts <- computeRestarts(cond)
[16:21:29.435]                           for (restart in restarts) {
[16:21:29.435]                             name <- restart$name
[16:21:29.435]                             if (is.null(name)) 
[16:21:29.435]                               next
[16:21:29.435]                             if (!grepl(pattern, name)) 
[16:21:29.435]                               next
[16:21:29.435]                             invokeRestart(restart)
[16:21:29.435]                             muffled <- TRUE
[16:21:29.435]                             break
[16:21:29.435]                           }
[16:21:29.435]                         }
[16:21:29.435]                       }
[16:21:29.435]                       invisible(muffled)
[16:21:29.435]                     }
[16:21:29.435]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.435]                   }
[16:21:29.435]                 }
[16:21:29.435]             }
[16:21:29.435]         }))
[16:21:29.435]     }, error = function(ex) {
[16:21:29.435]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:29.435]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.435]                 ...future.rng), started = ...future.startTime, 
[16:21:29.435]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:29.435]             version = "1.8"), class = "FutureResult")
[16:21:29.435]     }, finally = {
[16:21:29.435]         if (!identical(...future.workdir, getwd())) 
[16:21:29.435]             setwd(...future.workdir)
[16:21:29.435]         {
[16:21:29.435]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:29.435]                 ...future.oldOptions$nwarnings <- NULL
[16:21:29.435]             }
[16:21:29.435]             base::options(...future.oldOptions)
[16:21:29.435]             if (.Platform$OS.type == "windows") {
[16:21:29.435]                 old_names <- names(...future.oldEnvVars)
[16:21:29.435]                 envs <- base::Sys.getenv()
[16:21:29.435]                 names <- names(envs)
[16:21:29.435]                 common <- intersect(names, old_names)
[16:21:29.435]                 added <- setdiff(names, old_names)
[16:21:29.435]                 removed <- setdiff(old_names, names)
[16:21:29.435]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:29.435]                   envs[common]]
[16:21:29.435]                 NAMES <- toupper(changed)
[16:21:29.435]                 args <- list()
[16:21:29.435]                 for (kk in seq_along(NAMES)) {
[16:21:29.435]                   name <- changed[[kk]]
[16:21:29.435]                   NAME <- NAMES[[kk]]
[16:21:29.435]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.435]                     next
[16:21:29.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.435]                 }
[16:21:29.435]                 NAMES <- toupper(added)
[16:21:29.435]                 for (kk in seq_along(NAMES)) {
[16:21:29.435]                   name <- added[[kk]]
[16:21:29.435]                   NAME <- NAMES[[kk]]
[16:21:29.435]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.435]                     next
[16:21:29.435]                   args[[name]] <- ""
[16:21:29.435]                 }
[16:21:29.435]                 NAMES <- toupper(removed)
[16:21:29.435]                 for (kk in seq_along(NAMES)) {
[16:21:29.435]                   name <- removed[[kk]]
[16:21:29.435]                   NAME <- NAMES[[kk]]
[16:21:29.435]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.435]                     next
[16:21:29.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.435]                 }
[16:21:29.435]                 if (length(args) > 0) 
[16:21:29.435]                   base::do.call(base::Sys.setenv, args = args)
[16:21:29.435]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:29.435]             }
[16:21:29.435]             else {
[16:21:29.435]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:29.435]             }
[16:21:29.435]             {
[16:21:29.435]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:29.435]                   0L) {
[16:21:29.435]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:29.435]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:29.435]                   base::options(opts)
[16:21:29.435]                 }
[16:21:29.435]                 {
[16:21:29.435]                   {
[16:21:29.435]                     NULL
[16:21:29.435]                     RNGkind("Mersenne-Twister")
[16:21:29.435]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:29.435]                       inherits = FALSE)
[16:21:29.435]                   }
[16:21:29.435]                   options(future.plan = NULL)
[16:21:29.435]                   if (is.na(NA_character_)) 
[16:21:29.435]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.435]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:29.435]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:29.435]                     .init = FALSE)
[16:21:29.435]                 }
[16:21:29.435]             }
[16:21:29.435]         }
[16:21:29.435]     })
[16:21:29.435]     if (TRUE) {
[16:21:29.435]         base::sink(type = "output", split = FALSE)
[16:21:29.435]         if (TRUE) {
[16:21:29.435]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:29.435]         }
[16:21:29.435]         else {
[16:21:29.435]             ...future.result["stdout"] <- base::list(NULL)
[16:21:29.435]         }
[16:21:29.435]         base::close(...future.stdout)
[16:21:29.435]         ...future.stdout <- NULL
[16:21:29.435]     }
[16:21:29.435]     ...future.result$conditions <- ...future.conditions
[16:21:29.435]     ...future.result$finished <- base::Sys.time()
[16:21:29.435]     ...future.result
[16:21:29.435] }
[16:21:29.469]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.438] assign_globals() ...
[16:21:29.469]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.438] List of 3
[16:21:29.438]  $ nested_a:List of 1
[16:21:29.438]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[16:21:29.438]     envir = parent.frame())  
[16:21:29.438]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[16:21:29.438]   .. ..- attr(*, "untweakable")= chr "persistent"
[16:21:29.438]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:21:29.438]  $ a       : int 1
[16:21:29.438]  $ plan_a  :List of 1
[16:21:29.438]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[16:21:29.438]     envir = parent.frame())  
[16:21:29.438]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[16:21:29.438]   .. ..- attr(*, "untweakable")= chr "persistent"
[16:21:29.438]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:21:29.438]  - attr(*, "where")=List of 3
[16:21:29.438]   ..$ nested_a:<environment: R_EmptyEnv> 
[16:21:29.438]   ..$ a       :<environment: R_EmptyEnv> 
[16:21:29.438]   ..$ plan_a  :<environment: R_EmptyEnv> 
[16:21:29.438]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:29.438]  - attr(*, "resolved")= logi FALSE
[16:21:29.438]  - attr(*, "total_size")= num 89928
[16:21:29.438]  - attr(*, "already-done")= logi TRUE
[16:21:29.469]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.446] - copied ‘nested_a’ to environment
[16:21:29.469]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.446] - copied ‘a’ to environment
[16:21:29.469]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.446] - copied ‘plan_a’ to environment
[16:21:29.470]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.446] assign_globals() ... done
[16:21:29.470]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.447] plan(): Setting new future strategy stack:
[16:21:29.470]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.447] List of future strategies:
[16:21:29.447] 1. sequential:
[16:21:29.447]    - args: function (..., envir = parent.frame())
[16:21:29.447]    - tweaked: FALSE
[16:21:29.447]    - call: NULL
[16:21:29.470]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.447] plan(): nbrOfWorkers() = 1
[16:21:29.470]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.448] plan(): Setting new future strategy stack:
[16:21:29.470]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.448] List of future strategies:
[16:21:29.448] 1. multisession:
[16:21:29.448]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:29.448]    - tweaked: FALSE
[16:21:29.448]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.471]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.452] plan(): nbrOfWorkers() = 1
[16:21:29.471]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.453] SequentialFuture started (and completed)
[16:21:29.471]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.453] - Launch lazy future ... done
[16:21:29.471]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.453] run() for ‘SequentialFuture’ ... done
[16:21:29.471] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:21:29.478] getGlobalsAndPackages() ...
[16:21:29.478] Searching for globals...
[16:21:29.480] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:21:29.480] Searching for globals ... DONE
[16:21:29.480] Resolving globals: FALSE
[16:21:29.481] The total size of the 1 globals is 128 bytes (128 bytes)
[16:21:29.481] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:21:29.481] - globals: [1] ‘data’
[16:21:29.482] - packages: [1] ‘future’
[16:21:29.482] getGlobalsAndPackages() ... DONE
[16:21:29.482] run() for ‘Future’ ...
[16:21:29.482] - state: ‘created’
[16:21:29.482] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:29.487] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:29.487] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:29.487]   - Field: ‘label’
[16:21:29.487]   - Field: ‘local’
[16:21:29.487]   - Field: ‘owner’
[16:21:29.487]   - Field: ‘envir’
[16:21:29.487]   - Field: ‘workers’
[16:21:29.487]   - Field: ‘packages’
[16:21:29.488]   - Field: ‘gc’
[16:21:29.488]   - Field: ‘job’
[16:21:29.488]   - Field: ‘conditions’
[16:21:29.488]   - Field: ‘expr’
[16:21:29.488]   - Field: ‘uuid’
[16:21:29.488]   - Field: ‘seed’
[16:21:29.488]   - Field: ‘version’
[16:21:29.488]   - Field: ‘result’
[16:21:29.488]   - Field: ‘asynchronous’
[16:21:29.489]   - Field: ‘calls’
[16:21:29.489]   - Field: ‘globals’
[16:21:29.489]   - Field: ‘stdout’
[16:21:29.489]   - Field: ‘earlySignal’
[16:21:29.489]   - Field: ‘lazy’
[16:21:29.489]   - Field: ‘state’
[16:21:29.489] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:29.489] - Launch lazy future ...
[16:21:29.490] Packages needed by the future expression (n = 1): ‘future’
[16:21:29.490] Packages needed by future strategies (n = 1): ‘future’
[16:21:29.490] {
[16:21:29.490]     {
[16:21:29.490]         {
[16:21:29.490]             ...future.startTime <- base::Sys.time()
[16:21:29.490]             {
[16:21:29.490]                 {
[16:21:29.490]                   {
[16:21:29.490]                     {
[16:21:29.490]                       {
[16:21:29.490]                         base::local({
[16:21:29.490]                           has_future <- base::requireNamespace("future", 
[16:21:29.490]                             quietly = TRUE)
[16:21:29.490]                           if (has_future) {
[16:21:29.490]                             ns <- base::getNamespace("future")
[16:21:29.490]                             version <- ns[[".package"]][["version"]]
[16:21:29.490]                             if (is.null(version)) 
[16:21:29.490]                               version <- utils::packageVersion("future")
[16:21:29.490]                           }
[16:21:29.490]                           else {
[16:21:29.490]                             version <- NULL
[16:21:29.490]                           }
[16:21:29.490]                           if (!has_future || version < "1.8.0") {
[16:21:29.490]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:29.490]                               "", base::R.version$version.string), 
[16:21:29.490]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:29.490]                                 base::R.version$platform, 8 * 
[16:21:29.490]                                   base::.Machine$sizeof.pointer), 
[16:21:29.490]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:29.490]                                 "release", "version")], collapse = " "), 
[16:21:29.490]                               hostname = base::Sys.info()[["nodename"]])
[16:21:29.490]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:29.490]                               info)
[16:21:29.490]                             info <- base::paste(info, collapse = "; ")
[16:21:29.490]                             if (!has_future) {
[16:21:29.490]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:29.490]                                 info)
[16:21:29.490]                             }
[16:21:29.490]                             else {
[16:21:29.490]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:29.490]                                 info, version)
[16:21:29.490]                             }
[16:21:29.490]                             base::stop(msg)
[16:21:29.490]                           }
[16:21:29.490]                         })
[16:21:29.490]                       }
[16:21:29.490]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:29.490]                       base::options(mc.cores = 1L)
[16:21:29.490]                     }
[16:21:29.490]                     base::local({
[16:21:29.490]                       for (pkg in "future") {
[16:21:29.490]                         base::loadNamespace(pkg)
[16:21:29.490]                         base::library(pkg, character.only = TRUE)
[16:21:29.490]                       }
[16:21:29.490]                     })
[16:21:29.490]                   }
[16:21:29.490]                   ...future.strategy.old <- future::plan("list")
[16:21:29.490]                   options(future.plan = NULL)
[16:21:29.490]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.490]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:21:29.490]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:21:29.490]                     envir = parent.frame()) 
[16:21:29.490]                   {
[16:21:29.490]                     if (is.function(workers)) 
[16:21:29.490]                       workers <- workers()
[16:21:29.490]                     workers <- structure(as.integer(workers), 
[16:21:29.490]                       class = class(workers))
[16:21:29.490]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:21:29.490]                       workers >= 1)
[16:21:29.490]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:21:29.490]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:21:29.490]                     }
[16:21:29.490]                     future <- MultisessionFuture(..., workers = workers, 
[16:21:29.490]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:21:29.490]                       envir = envir)
[16:21:29.490]                     if (!future$lazy) 
[16:21:29.490]                       future <- run(future)
[16:21:29.490]                     invisible(future)
[16:21:29.490]                   }), .cleanup = FALSE, .init = FALSE)
[16:21:29.490]                 }
[16:21:29.490]                 ...future.workdir <- getwd()
[16:21:29.490]             }
[16:21:29.490]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:29.490]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:29.490]         }
[16:21:29.490]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:29.490]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:29.490]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:29.490]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:29.490]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:29.490]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:29.490]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:29.490]             base::names(...future.oldOptions))
[16:21:29.490]     }
[16:21:29.490]     if (FALSE) {
[16:21:29.490]     }
[16:21:29.490]     else {
[16:21:29.490]         if (TRUE) {
[16:21:29.490]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:29.490]                 open = "w")
[16:21:29.490]         }
[16:21:29.490]         else {
[16:21:29.490]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:29.490]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:29.490]         }
[16:21:29.490]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:29.490]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:29.490]             base::sink(type = "output", split = FALSE)
[16:21:29.490]             base::close(...future.stdout)
[16:21:29.490]         }, add = TRUE)
[16:21:29.490]     }
[16:21:29.490]     ...future.frame <- base::sys.nframe()
[16:21:29.490]     ...future.conditions <- base::list()
[16:21:29.490]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:29.490]     if (FALSE) {
[16:21:29.490]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:29.490]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:29.490]     }
[16:21:29.490]     ...future.result <- base::tryCatch({
[16:21:29.490]         base::withCallingHandlers({
[16:21:29.490]             ...future.value <- base::withVisible(base::local({
[16:21:29.490]                 withCallingHandlers({
[16:21:29.490]                   {
[16:21:29.490]                     value(future(subset(data, a == 2)))
[16:21:29.490]                   }
[16:21:29.490]                 }, immediateCondition = function(cond) {
[16:21:29.490]                   save_rds <- function (object, pathname, ...) 
[16:21:29.490]                   {
[16:21:29.490]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:29.490]                     if (file_test("-f", pathname_tmp)) {
[16:21:29.490]                       fi_tmp <- file.info(pathname_tmp)
[16:21:29.490]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:29.490]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:29.490]                         fi_tmp[["mtime"]])
[16:21:29.490]                     }
[16:21:29.490]                     tryCatch({
[16:21:29.490]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:29.490]                     }, error = function(ex) {
[16:21:29.490]                       msg <- conditionMessage(ex)
[16:21:29.490]                       fi_tmp <- file.info(pathname_tmp)
[16:21:29.490]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:29.490]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:29.490]                         fi_tmp[["mtime"]], msg)
[16:21:29.490]                       ex$message <- msg
[16:21:29.490]                       stop(ex)
[16:21:29.490]                     })
[16:21:29.490]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:29.490]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:29.490]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:29.490]                       fi_tmp <- file.info(pathname_tmp)
[16:21:29.490]                       fi <- file.info(pathname)
[16:21:29.490]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:29.490]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:29.490]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:29.490]                         fi[["size"]], fi[["mtime"]])
[16:21:29.490]                       stop(msg)
[16:21:29.490]                     }
[16:21:29.490]                     invisible(pathname)
[16:21:29.490]                   }
[16:21:29.490]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:29.490]                     rootPath = tempdir()) 
[16:21:29.490]                   {
[16:21:29.490]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:29.490]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:29.490]                       tmpdir = path, fileext = ".rds")
[16:21:29.490]                     save_rds(obj, file)
[16:21:29.490]                   }
[16:21:29.490]                   saveImmediateCondition(cond, path = "/tmp/RtmpnVB70K/.future/immediateConditions")
[16:21:29.490]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.490]                   {
[16:21:29.490]                     inherits <- base::inherits
[16:21:29.490]                     invokeRestart <- base::invokeRestart
[16:21:29.490]                     is.null <- base::is.null
[16:21:29.490]                     muffled <- FALSE
[16:21:29.490]                     if (inherits(cond, "message")) {
[16:21:29.490]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:29.490]                       if (muffled) 
[16:21:29.490]                         invokeRestart("muffleMessage")
[16:21:29.490]                     }
[16:21:29.490]                     else if (inherits(cond, "warning")) {
[16:21:29.490]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:29.490]                       if (muffled) 
[16:21:29.490]                         invokeRestart("muffleWarning")
[16:21:29.490]                     }
[16:21:29.490]                     else if (inherits(cond, "condition")) {
[16:21:29.490]                       if (!is.null(pattern)) {
[16:21:29.490]                         computeRestarts <- base::computeRestarts
[16:21:29.490]                         grepl <- base::grepl
[16:21:29.490]                         restarts <- computeRestarts(cond)
[16:21:29.490]                         for (restart in restarts) {
[16:21:29.490]                           name <- restart$name
[16:21:29.490]                           if (is.null(name)) 
[16:21:29.490]                             next
[16:21:29.490]                           if (!grepl(pattern, name)) 
[16:21:29.490]                             next
[16:21:29.490]                           invokeRestart(restart)
[16:21:29.490]                           muffled <- TRUE
[16:21:29.490]                           break
[16:21:29.490]                         }
[16:21:29.490]                       }
[16:21:29.490]                     }
[16:21:29.490]                     invisible(muffled)
[16:21:29.490]                   }
[16:21:29.490]                   muffleCondition(cond)
[16:21:29.490]                 })
[16:21:29.490]             }))
[16:21:29.490]             future::FutureResult(value = ...future.value$value, 
[16:21:29.490]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.490]                   ...future.rng), globalenv = if (FALSE) 
[16:21:29.490]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:29.490]                     ...future.globalenv.names))
[16:21:29.490]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:29.490]         }, condition = base::local({
[16:21:29.490]             c <- base::c
[16:21:29.490]             inherits <- base::inherits
[16:21:29.490]             invokeRestart <- base::invokeRestart
[16:21:29.490]             length <- base::length
[16:21:29.490]             list <- base::list
[16:21:29.490]             seq.int <- base::seq.int
[16:21:29.490]             signalCondition <- base::signalCondition
[16:21:29.490]             sys.calls <- base::sys.calls
[16:21:29.490]             `[[` <- base::`[[`
[16:21:29.490]             `+` <- base::`+`
[16:21:29.490]             `<<-` <- base::`<<-`
[16:21:29.490]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:29.490]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:29.490]                   3L)]
[16:21:29.490]             }
[16:21:29.490]             function(cond) {
[16:21:29.490]                 is_error <- inherits(cond, "error")
[16:21:29.490]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:29.490]                   NULL)
[16:21:29.490]                 if (is_error) {
[16:21:29.490]                   sessionInformation <- function() {
[16:21:29.490]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:29.490]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:29.490]                       search = base::search(), system = base::Sys.info())
[16:21:29.490]                   }
[16:21:29.490]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.490]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:29.490]                     cond$call), session = sessionInformation(), 
[16:21:29.490]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:29.490]                   signalCondition(cond)
[16:21:29.490]                 }
[16:21:29.490]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:29.490]                 "immediateCondition"))) {
[16:21:29.490]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:29.490]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.490]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:29.490]                   if (TRUE && !signal) {
[16:21:29.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.490]                     {
[16:21:29.490]                       inherits <- base::inherits
[16:21:29.490]                       invokeRestart <- base::invokeRestart
[16:21:29.490]                       is.null <- base::is.null
[16:21:29.490]                       muffled <- FALSE
[16:21:29.490]                       if (inherits(cond, "message")) {
[16:21:29.490]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.490]                         if (muffled) 
[16:21:29.490]                           invokeRestart("muffleMessage")
[16:21:29.490]                       }
[16:21:29.490]                       else if (inherits(cond, "warning")) {
[16:21:29.490]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.490]                         if (muffled) 
[16:21:29.490]                           invokeRestart("muffleWarning")
[16:21:29.490]                       }
[16:21:29.490]                       else if (inherits(cond, "condition")) {
[16:21:29.490]                         if (!is.null(pattern)) {
[16:21:29.490]                           computeRestarts <- base::computeRestarts
[16:21:29.490]                           grepl <- base::grepl
[16:21:29.490]                           restarts <- computeRestarts(cond)
[16:21:29.490]                           for (restart in restarts) {
[16:21:29.490]                             name <- restart$name
[16:21:29.490]                             if (is.null(name)) 
[16:21:29.490]                               next
[16:21:29.490]                             if (!grepl(pattern, name)) 
[16:21:29.490]                               next
[16:21:29.490]                             invokeRestart(restart)
[16:21:29.490]                             muffled <- TRUE
[16:21:29.490]                             break
[16:21:29.490]                           }
[16:21:29.490]                         }
[16:21:29.490]                       }
[16:21:29.490]                       invisible(muffled)
[16:21:29.490]                     }
[16:21:29.490]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.490]                   }
[16:21:29.490]                 }
[16:21:29.490]                 else {
[16:21:29.490]                   if (TRUE) {
[16:21:29.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.490]                     {
[16:21:29.490]                       inherits <- base::inherits
[16:21:29.490]                       invokeRestart <- base::invokeRestart
[16:21:29.490]                       is.null <- base::is.null
[16:21:29.490]                       muffled <- FALSE
[16:21:29.490]                       if (inherits(cond, "message")) {
[16:21:29.490]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.490]                         if (muffled) 
[16:21:29.490]                           invokeRestart("muffleMessage")
[16:21:29.490]                       }
[16:21:29.490]                       else if (inherits(cond, "warning")) {
[16:21:29.490]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.490]                         if (muffled) 
[16:21:29.490]                           invokeRestart("muffleWarning")
[16:21:29.490]                       }
[16:21:29.490]                       else if (inherits(cond, "condition")) {
[16:21:29.490]                         if (!is.null(pattern)) {
[16:21:29.490]                           computeRestarts <- base::computeRestarts
[16:21:29.490]                           grepl <- base::grepl
[16:21:29.490]                           restarts <- computeRestarts(cond)
[16:21:29.490]                           for (restart in restarts) {
[16:21:29.490]                             name <- restart$name
[16:21:29.490]                             if (is.null(name)) 
[16:21:29.490]                               next
[16:21:29.490]                             if (!grepl(pattern, name)) 
[16:21:29.490]                               next
[16:21:29.490]                             invokeRestart(restart)
[16:21:29.490]                             muffled <- TRUE
[16:21:29.490]                             break
[16:21:29.490]                           }
[16:21:29.490]                         }
[16:21:29.490]                       }
[16:21:29.490]                       invisible(muffled)
[16:21:29.490]                     }
[16:21:29.490]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.490]                   }
[16:21:29.490]                 }
[16:21:29.490]             }
[16:21:29.490]         }))
[16:21:29.490]     }, error = function(ex) {
[16:21:29.490]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:29.490]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.490]                 ...future.rng), started = ...future.startTime, 
[16:21:29.490]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:29.490]             version = "1.8"), class = "FutureResult")
[16:21:29.490]     }, finally = {
[16:21:29.490]         if (!identical(...future.workdir, getwd())) 
[16:21:29.490]             setwd(...future.workdir)
[16:21:29.490]         {
[16:21:29.490]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:29.490]                 ...future.oldOptions$nwarnings <- NULL
[16:21:29.490]             }
[16:21:29.490]             base::options(...future.oldOptions)
[16:21:29.490]             if (.Platform$OS.type == "windows") {
[16:21:29.490]                 old_names <- names(...future.oldEnvVars)
[16:21:29.490]                 envs <- base::Sys.getenv()
[16:21:29.490]                 names <- names(envs)
[16:21:29.490]                 common <- intersect(names, old_names)
[16:21:29.490]                 added <- setdiff(names, old_names)
[16:21:29.490]                 removed <- setdiff(old_names, names)
[16:21:29.490]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:29.490]                   envs[common]]
[16:21:29.490]                 NAMES <- toupper(changed)
[16:21:29.490]                 args <- list()
[16:21:29.490]                 for (kk in seq_along(NAMES)) {
[16:21:29.490]                   name <- changed[[kk]]
[16:21:29.490]                   NAME <- NAMES[[kk]]
[16:21:29.490]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.490]                     next
[16:21:29.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.490]                 }
[16:21:29.490]                 NAMES <- toupper(added)
[16:21:29.490]                 for (kk in seq_along(NAMES)) {
[16:21:29.490]                   name <- added[[kk]]
[16:21:29.490]                   NAME <- NAMES[[kk]]
[16:21:29.490]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.490]                     next
[16:21:29.490]                   args[[name]] <- ""
[16:21:29.490]                 }
[16:21:29.490]                 NAMES <- toupper(removed)
[16:21:29.490]                 for (kk in seq_along(NAMES)) {
[16:21:29.490]                   name <- removed[[kk]]
[16:21:29.490]                   NAME <- NAMES[[kk]]
[16:21:29.490]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.490]                     next
[16:21:29.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.490]                 }
[16:21:29.490]                 if (length(args) > 0) 
[16:21:29.490]                   base::do.call(base::Sys.setenv, args = args)
[16:21:29.490]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:29.490]             }
[16:21:29.490]             else {
[16:21:29.490]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:29.490]             }
[16:21:29.490]             {
[16:21:29.490]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:29.490]                   0L) {
[16:21:29.490]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:29.490]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:29.490]                   base::options(opts)
[16:21:29.490]                 }
[16:21:29.490]                 {
[16:21:29.490]                   {
[16:21:29.490]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:29.490]                     NULL
[16:21:29.490]                   }
[16:21:29.490]                   options(future.plan = NULL)
[16:21:29.490]                   if (is.na(NA_character_)) 
[16:21:29.490]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.490]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:29.490]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:29.490]                     .init = FALSE)
[16:21:29.490]                 }
[16:21:29.490]             }
[16:21:29.490]         }
[16:21:29.490]     })
[16:21:29.490]     if (TRUE) {
[16:21:29.490]         base::sink(type = "output", split = FALSE)
[16:21:29.490]         if (TRUE) {
[16:21:29.490]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:29.490]         }
[16:21:29.490]         else {
[16:21:29.490]             ...future.result["stdout"] <- base::list(NULL)
[16:21:29.490]         }
[16:21:29.490]         base::close(...future.stdout)
[16:21:29.490]         ...future.stdout <- NULL
[16:21:29.490]     }
[16:21:29.490]     ...future.result$conditions <- ...future.conditions
[16:21:29.490]     ...future.result$finished <- base::Sys.time()
[16:21:29.490]     ...future.result
[16:21:29.490] }
[16:21:29.493] assign_globals() ...
[16:21:29.493] List of 1
[16:21:29.493]  $ data:'data.frame':	3 obs. of  2 variables:
[16:21:29.493]   ..$ a: int [1:3] 1 2 3
[16:21:29.493]   ..$ b: int [1:3] 3 2 1
[16:21:29.493]  - attr(*, "where")=List of 1
[16:21:29.493]   ..$ data:<environment: R_EmptyEnv> 
[16:21:29.493]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:29.493]  - attr(*, "resolved")= logi FALSE
[16:21:29.493]  - attr(*, "total_size")= num 128
[16:21:29.493]  - attr(*, "already-done")= logi TRUE
[16:21:29.497] - copied ‘data’ to environment
[16:21:29.497] assign_globals() ... done
[16:21:29.497] requestCore(): workers = 2
[16:21:29.500] MulticoreFuture started
[16:21:29.500] - Launch lazy future ... done
[16:21:29.500] run() for ‘MulticoreFuture’ ... done
[16:21:29.501] result() for MulticoreFuture ...
[16:21:29.501] plan(): Setting new future strategy stack:
[16:21:29.501] List of future strategies:
[16:21:29.501] 1. multisession:
[16:21:29.501]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:29.501]    - tweaked: FALSE
[16:21:29.501]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.512] plan(): nbrOfWorkers() = 1
[16:21:29.542] plan(): Setting new future strategy stack:
[16:21:29.542] List of future strategies:
[16:21:29.542] 1. multicore:
[16:21:29.542]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:29.542]    - tweaked: FALSE
[16:21:29.542]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.542] 2. multisession:
[16:21:29.542]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:29.542]    - tweaked: FALSE
[16:21:29.542]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.546] plan(): nbrOfWorkers() = 2
[16:21:29.551] result() for MulticoreFuture ...
[16:21:29.551] result() for MulticoreFuture ... done
[16:21:29.551] signalConditions() ...
[16:21:29.551]  - include = ‘immediateCondition’
[16:21:29.551]  - exclude = 
[16:21:29.551]  - resignal = FALSE
[16:21:29.551]  - Number of conditions: 52
[16:21:29.552] signalConditions() ... done
[16:21:29.552] result() for MulticoreFuture ... done
[16:21:29.552] result() for MulticoreFuture ...
[16:21:29.552] result() for MulticoreFuture ... done
[16:21:29.552] signalConditions() ...
[16:21:29.552]  - include = ‘immediateCondition’
[16:21:29.552]  - exclude = 
[16:21:29.552]  - resignal = FALSE
[16:21:29.553]  - Number of conditions: 52
[16:21:29.553] signalConditions() ... done
[16:21:29.553] Future state: ‘finished’
[16:21:29.553] result() for MulticoreFuture ...
[16:21:29.553] result() for MulticoreFuture ... done
[16:21:29.553] signalConditions() ...
[16:21:29.553]  - include = ‘condition’
[16:21:29.553]  - exclude = ‘immediateCondition’
[16:21:29.554]  - resignal = TRUE
[16:21:29.554]  - Number of conditions: 52
[16:21:29.554]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.512] getGlobalsAndPackages() ...
[16:21:29.554]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.513] Searching for globals...
[16:21:29.554]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.514] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[16:21:29.554]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.515] Searching for globals ... DONE
[16:21:29.554]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.515] Resolving globals: FALSE
[16:21:29.555]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.516] The total size of the 1 globals is 128 bytes (128 bytes)
[16:21:29.555]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.516] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:21:29.555]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.517] - globals: [1] ‘data’
[16:21:29.555]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.517] 
[16:21:29.555]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.517] getGlobalsAndPackages() ... DONE
[16:21:29.555]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.518] run() for ‘Future’ ...
[16:21:29.556]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.518] - state: ‘created’
[16:21:29.556]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.518] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:29.556]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.522] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:29.556]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.522] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:29.556]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.522]   - Field: ‘label’
[16:21:29.556]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.523]   - Field: ‘local’
[16:21:29.557]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.523]   - Field: ‘owner’
[16:21:29.557]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.523]   - Field: ‘envir’
[16:21:29.557]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.523]   - Field: ‘packages’
[16:21:29.557]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.523]   - Field: ‘gc’
[16:21:29.557]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.523]   - Field: ‘conditions’
[16:21:29.557]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.524]   - Field: ‘expr’
[16:21:29.557]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.524]   - Field: ‘uuid’
[16:21:29.558]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.524]   - Field: ‘seed’
[16:21:29.558]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.524]   - Field: ‘version’
[16:21:29.558]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.524]   - Field: ‘result’
[16:21:29.558]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.524]   - Field: ‘asynchronous’
[16:21:29.558]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.525]   - Field: ‘calls’
[16:21:29.558]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.525]   - Field: ‘globals’
[16:21:29.558]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.525]   - Field: ‘stdout’
[16:21:29.559]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.525]   - Field: ‘earlySignal’
[16:21:29.559]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.525]   - Field: ‘lazy’
[16:21:29.559]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.526]   - Field: ‘state’
[16:21:29.559]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.526] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:29.559]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.526] - Launch lazy future ...
[16:21:29.560]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.526] Packages needed by the future expression (n = 0): <none>
[16:21:29.560]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.526] Packages needed by future strategies (n = 0): <none>
[16:21:29.560]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.527] {
[16:21:29.527]     {
[16:21:29.527]         {
[16:21:29.527]             ...future.startTime <- base::Sys.time()
[16:21:29.527]             {
[16:21:29.527]                 {
[16:21:29.527]                   {
[16:21:29.527]                     base::local({
[16:21:29.527]                       has_future <- base::requireNamespace("future", 
[16:21:29.527]                         quietly = TRUE)
[16:21:29.527]                       if (has_future) {
[16:21:29.527]                         ns <- base::getNamespace("future")
[16:21:29.527]                         version <- ns[[".package"]][["version"]]
[16:21:29.527]                         if (is.null(version)) 
[16:21:29.527]                           version <- utils::packageVersion("future")
[16:21:29.527]                       }
[16:21:29.527]                       else {
[16:21:29.527]                         version <- NULL
[16:21:29.527]                       }
[16:21:29.527]                       if (!has_future || version < "1.8.0") {
[16:21:29.527]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:29.527]                           "", base::R.version$version.string), 
[16:21:29.527]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:29.527]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:29.527]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:29.527]                             "release", "version")], collapse = " "), 
[16:21:29.527]                           hostname = base::Sys.info()[["nodename"]])
[16:21:29.527]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:29.527]                           info)
[16:21:29.527]                         info <- base::paste(info, collapse = "; ")
[16:21:29.527]                         if (!has_future) {
[16:21:29.527]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:29.527]                             info)
[16:21:29.527]                         }
[16:21:29.527]                         else {
[16:21:29.527]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:29.527]                             info, version)
[16:21:29.527]                         }
[16:21:29.527]                         base::stop(msg)
[16:21:29.527]                       }
[16:21:29.527]                     })
[16:21:29.527]                   }
[16:21:29.527]                   ...future.strategy.old <- future::plan("list")
[16:21:29.527]                   options(future.plan = NULL)
[16:21:29.527]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.527]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:29.527]                 }
[16:21:29.527]                 ...future.workdir <- getwd()
[16:21:29.527]             }
[16:21:29.527]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:29.527]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:29.527]         }
[16:21:29.527]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:29.527]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:29.527]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:29.527]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:29.527]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:29.527]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:29.527]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:29.527]             base::names(...future.oldOptions))
[16:21:29.527]     }
[16:21:29.527]     if (FALSE) {
[16:21:29.527]     }
[16:21:29.527]     else {
[16:21:29.527]         if (TRUE) {
[16:21:29.527]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:29.527]                 open = "w")
[16:21:29.527]         }
[16:21:29.527]         else {
[16:21:29.527]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:29.527]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:29.527]         }
[16:21:29.527]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:29.527]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:29.527]             base::sink(type = "output", split = FALSE)
[16:21:29.527]             base::close(...future.stdout)
[16:21:29.527]         }, add = TRUE)
[16:21:29.527]     }
[16:21:29.527]     ...future.frame <- base::sys.nframe()
[16:21:29.527]     ...future.conditions <- base::list()
[16:21:29.527]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:29.527]     if (FALSE) {
[16:21:29.527]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:29.527]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:29.527]     }
[16:21:29.527]     ...future.result <- base::tryCatch({
[16:21:29.527]         base::withCallingHandlers({
[16:21:29.527]             ...future.value <- base::withVisible(base::local(subset(data, 
[16:21:29.527]                 a == 2)))
[16:21:29.527]             future::FutureResult(value = ...future.value$value, 
[16:21:29.527]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.527]                   ...future.rng), globalenv = if (FALSE) 
[16:21:29.527]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:29.527]                     ...future.globalenv.names))
[16:21:29.527]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:29.527]         }, condition = base::local({
[16:21:29.527]             c <- base::c
[16:21:29.527]             inherits <- base::inherits
[16:21:29.527]             invokeRestart <- base::invokeRestart
[16:21:29.527]             length <- base::length
[16:21:29.527]             list <- base::list
[16:21:29.527]             seq.int <- base::seq.int
[16:21:29.527]             signalCondition <- base::signalCondition
[16:21:29.527]             sys.calls <- base::sys.calls
[16:21:29.527]             `[[` <- base::`[[`
[16:21:29.527]             `+` <- base::`+`
[16:21:29.527]             `<<-` <- base::`<<-`
[16:21:29.527]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:29.527]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:29.527]                   3L)]
[16:21:29.527]             }
[16:21:29.527]             function(cond) {
[16:21:29.527]                 is_error <- inherits(cond, "error")
[16:21:29.527]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:29.527]                   NULL)
[16:21:29.527]                 if (is_error) {
[16:21:29.527]                   sessionInformation <- function() {
[16:21:29.527]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:29.527]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:29.527]                       search = base::search(), system = base::Sys.info())
[16:21:29.527]                   }
[16:21:29.527]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.527]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:29.527]                     cond$call), session = sessionInformation(), 
[16:21:29.527]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:29.527]                   signalCondition(cond)
[16:21:29.527]                 }
[16:21:29.527]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:29.527]                 "immediateCondition"))) {
[16:21:29.527]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:29.527]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.527]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:29.527]                   if (TRUE && !signal) {
[16:21:29.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.527]                     {
[16:21:29.527]                       inherits <- base::inherits
[16:21:29.527]                       invokeRestart <- base::invokeRestart
[16:21:29.527]                       is.null <- base::is.null
[16:21:29.527]                       muffled <- FALSE
[16:21:29.527]                       if (inherits(cond, "message")) {
[16:21:29.527]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.527]                         if (muffled) 
[16:21:29.527]                           invokeRestart("muffleMessage")
[16:21:29.527]                       }
[16:21:29.527]                       else if (inherits(cond, "warning")) {
[16:21:29.527]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.527]                         if (muffled) 
[16:21:29.527]                           invokeRestart("muffleWarning")
[16:21:29.527]                       }
[16:21:29.527]                       else if (inherits(cond, "condition")) {
[16:21:29.527]                         if (!is.null(pattern)) {
[16:21:29.527]                           computeRestarts <- base::computeRestarts
[16:21:29.527]                           grepl <- base::grepl
[16:21:29.527]                           restarts <- computeRestarts(cond)
[16:21:29.527]                           for (restart in restarts) {
[16:21:29.527]                             name <- restart$name
[16:21:29.527]                             if (is.null(name)) 
[16:21:29.527]                               next
[16:21:29.527]                             if (!grepl(pattern, name)) 
[16:21:29.527]                               next
[16:21:29.527]                             invokeRestart(restart)
[16:21:29.527]                             muffled <- TRUE
[16:21:29.527]                             break
[16:21:29.527]                           }
[16:21:29.527]                         }
[16:21:29.527]                       }
[16:21:29.527]                       invisible(muffled)
[16:21:29.527]                     }
[16:21:29.527]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.527]                   }
[16:21:29.527]                 }
[16:21:29.527]                 else {
[16:21:29.527]                   if (TRUE) {
[16:21:29.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.527]                     {
[16:21:29.527]                       inherits <- base::inherits
[16:21:29.527]                       invokeRestart <- base::invokeRestart
[16:21:29.527]                       is.null <- base::is.null
[16:21:29.527]                       muffled <- FALSE
[16:21:29.527]                       if (inherits(cond, "message")) {
[16:21:29.527]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.527]                         if (muffled) 
[16:21:29.527]                           invokeRestart("muffleMessage")
[16:21:29.527]                       }
[16:21:29.527]                       else if (inherits(cond, "warning")) {
[16:21:29.527]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.527]                         if (muffled) 
[16:21:29.527]                           invokeRestart("muffleWarning")
[16:21:29.527]                       }
[16:21:29.527]                       else if (inherits(cond, "condition")) {
[16:21:29.527]                         if (!is.null(pattern)) {
[16:21:29.527]                           computeRestarts <- base::computeRestarts
[16:21:29.527]                           grepl <- base::grepl
[16:21:29.527]                           restarts <- computeRestarts(cond)
[16:21:29.527]                           for (restart in restarts) {
[16:21:29.527]                             name <- restart$name
[16:21:29.527]                             if (is.null(name)) 
[16:21:29.527]                               next
[16:21:29.527]                             if (!grepl(pattern, name)) 
[16:21:29.527]                               next
[16:21:29.527]                             invokeRestart(restart)
[16:21:29.527]                             muffled <- TRUE
[16:21:29.527]                             break
[16:21:29.527]                           }
[16:21:29.527]                         }
[16:21:29.527]                       }
[16:21:29.527]                       invisible(muffled)
[16:21:29.527]                     }
[16:21:29.527]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.527]                   }
[16:21:29.527]                 }
[16:21:29.527]             }
[16:21:29.527]         }))
[16:21:29.527]     }, error = function(ex) {
[16:21:29.527]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:29.527]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.527]                 ...future.rng), started = ...future.startTime, 
[16:21:29.527]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:29.527]             version = "1.8"), class = "FutureResult")
[16:21:29.527]     }, finally = {
[16:21:29.527]         if (!identical(...future.workdir, getwd())) 
[16:21:29.527]             setwd(...future.workdir)
[16:21:29.527]         {
[16:21:29.527]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:29.527]                 ...future.oldOptions$nwarnings <- NULL
[16:21:29.527]             }
[16:21:29.527]             base::options(...future.oldOptions)
[16:21:29.527]             if (.Platform$OS.type == "windows") {
[16:21:29.527]                 old_names <- names(...future.oldEnvVars)
[16:21:29.527]                 envs <- base::Sys.getenv()
[16:21:29.527]                 names <- names(envs)
[16:21:29.527]                 common <- intersect(names, old_names)
[16:21:29.527]                 added <- setdiff(names, old_names)
[16:21:29.527]                 removed <- setdiff(old_names, names)
[16:21:29.527]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:29.527]                   envs[common]]
[16:21:29.527]                 NAMES <- toupper(changed)
[16:21:29.527]                 args <- list()
[16:21:29.527]                 for (kk in seq_along(NAMES)) {
[16:21:29.527]                   name <- changed[[kk]]
[16:21:29.527]                   NAME <- NAMES[[kk]]
[16:21:29.527]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.527]                     next
[16:21:29.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.527]                 }
[16:21:29.527]                 NAMES <- toupper(added)
[16:21:29.527]                 for (kk in seq_along(NAMES)) {
[16:21:29.527]                   name <- added[[kk]]
[16:21:29.527]                   NAME <- NAMES[[kk]]
[16:21:29.527]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.527]                     next
[16:21:29.527]                   args[[name]] <- ""
[16:21:29.527]                 }
[16:21:29.527]                 NAMES <- toupper(removed)
[16:21:29.527]                 for (kk in seq_along(NAMES)) {
[16:21:29.527]                   name <- removed[[kk]]
[16:21:29.527]                   NAME <- NAMES[[kk]]
[16:21:29.527]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.527]                     next
[16:21:29.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.527]                 }
[16:21:29.527]                 if (length(args) > 0) 
[16:21:29.527]                   base::do.call(base::Sys.setenv, args = args)
[16:21:29.527]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:29.527]             }
[16:21:29.527]             else {
[16:21:29.527]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:29.527]             }
[16:21:29.527]             {
[16:21:29.527]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:29.527]                   0L) {
[16:21:29.527]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:29.527]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:29.527]                   base::options(opts)
[16:21:29.527]                 }
[16:21:29.527]                 {
[16:21:29.527]                   {
[16:21:29.527]                     NULL
[16:21:29.527]                     RNGkind("Mersenne-Twister")
[16:21:29.527]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:29.527]                       inherits = FALSE)
[16:21:29.527]                   }
[16:21:29.527]                   options(future.plan = NULL)
[16:21:29.527]                   if (is.na(NA_character_)) 
[16:21:29.527]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.527]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:29.527]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:29.527]                     .init = FALSE)
[16:21:29.527]                 }
[16:21:29.527]             }
[16:21:29.527]         }
[16:21:29.527]     })
[16:21:29.527]     if (TRUE) {
[16:21:29.527]         base::sink(type = "output", split = FALSE)
[16:21:29.527]         if (TRUE) {
[16:21:29.527]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:29.527]         }
[16:21:29.527]         else {
[16:21:29.527]             ...future.result["stdout"] <- base::list(NULL)
[16:21:29.527]         }
[16:21:29.527]         base::close(...future.stdout)
[16:21:29.527]         ...future.stdout <- NULL
[16:21:29.527]     }
[16:21:29.527]     ...future.result$conditions <- ...future.conditions
[16:21:29.527]     ...future.result$finished <- base::Sys.time()
[16:21:29.527]     ...future.result
[16:21:29.527] }
[16:21:29.560]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.529] assign_globals() ...
[16:21:29.560]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.529] List of 1
[16:21:29.529]  $ data:'data.frame':	3 obs. of  2 variables:
[16:21:29.529]   ..$ a: int [1:3] 1 2 3
[16:21:29.529]   ..$ b: int [1:3] 3 2 1
[16:21:29.529]  - attr(*, "where")=List of 1
[16:21:29.529]   ..$ data:<environment: R_EmptyEnv> 
[16:21:29.529]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:29.529]  - attr(*, "resolved")= logi FALSE
[16:21:29.529]  - attr(*, "total_size")= num 128
[16:21:29.529]  - attr(*, "already-done")= logi TRUE
[16:21:29.560]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.534] - copied ‘data’ to environment
[16:21:29.560]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.534] assign_globals() ... done
[16:21:29.561]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.535] plan(): Setting new future strategy stack:
[16:21:29.561]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.535] List of future strategies:
[16:21:29.535] 1. sequential:
[16:21:29.535]    - args: function (..., envir = parent.frame())
[16:21:29.535]    - tweaked: FALSE
[16:21:29.535]    - call: NULL
[16:21:29.561]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.535] plan(): nbrOfWorkers() = 1
[16:21:29.561]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.536] plan(): Setting new future strategy stack:
[16:21:29.561]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.537] List of future strategies:
[16:21:29.537] 1. multisession:
[16:21:29.537]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:29.537]    - tweaked: FALSE
[16:21:29.537]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.561]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.541] plan(): nbrOfWorkers() = 1
[16:21:29.562]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.541] SequentialFuture started (and completed)
[16:21:29.562]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.541] - Launch lazy future ... done
[16:21:29.562]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:21:29.541] run() for ‘SequentialFuture’ ... done
[16:21:29.562] signalConditions() ... done
- plan(list('multicore', 'multisession')) ... DONE
- plan(list('multisession', 'sequential')) ...
[16:21:29.563] plan(): Setting new future strategy stack:
[16:21:29.563] List of future strategies:
[16:21:29.563] 1. multisession:
[16:21:29.563]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:29.563]    - tweaked: FALSE
[16:21:29.563]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.563] 2. sequential:
[16:21:29.563]    - args: function (..., envir = parent.frame())
[16:21:29.563]    - tweaked: FALSE
[16:21:29.563]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.563] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:21:29.563] multisession:
[16:21:29.563] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:29.563] - tweaked: FALSE
[16:21:29.563] - call: plan(list(a = strategy1, b = strategy2))
[16:21:29.568] getGlobalsAndPackages() ...
[16:21:29.568] Not searching for globals
[16:21:29.568] - globals: [0] <none>
[16:21:29.568] getGlobalsAndPackages() ... DONE
[16:21:29.569] [local output] makeClusterPSOCK() ...
[16:21:29.572] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:21:29.573] [local output] Base port: 11322
[16:21:29.573] [local output] Getting setup options for 2 cluster nodes ...
[16:21:29.573] [local output]  - Node 1 of 2 ...
[16:21:29.573] [local output] localMachine=TRUE => revtunnel=FALSE

[16:21:29.574] [local output] Rscript port: 11322

[16:21:29.574] [local output]  - Node 2 of 2 ...
[16:21:29.575] [local output] localMachine=TRUE => revtunnel=FALSE

[16:21:29.575] [local output] Rscript port: 11322

[16:21:29.576] [local output] Getting setup options for 2 cluster nodes ... done
[16:21:29.576] [local output]  - Parallel setup requested for some PSOCK nodes
[16:21:29.576] [local output] Setting up PSOCK nodes in parallel
[16:21:29.576] List of 36
[16:21:29.576]  $ worker          : chr "localhost"
[16:21:29.576]   ..- attr(*, "localhost")= logi TRUE
[16:21:29.576]  $ master          : chr "localhost"
[16:21:29.576]  $ port            : int 11322
[16:21:29.576]  $ connectTimeout  : num 120
[16:21:29.576]  $ timeout         : num 2592000
[16:21:29.576]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:21:29.576]  $ homogeneous     : logi TRUE
[16:21:29.576]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:21:29.576]  $ rscript_envs    : NULL
[16:21:29.576]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:21:29.576]  $ rscript_startup : NULL
[16:21:29.576]  $ rscript_sh      : chr "sh"
[16:21:29.576]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:21:29.576]  $ methods         : logi TRUE
[16:21:29.576]  $ socketOptions   : chr "no-delay"
[16:21:29.576]  $ useXDR          : logi FALSE
[16:21:29.576]  $ outfile         : chr "/dev/null"
[16:21:29.576]  $ renice          : int NA
[16:21:29.576]  $ rshcmd          : NULL
[16:21:29.576]  $ user            : chr(0) 
[16:21:29.576]  $ revtunnel       : logi FALSE
[16:21:29.576]  $ rshlogfile      : NULL
[16:21:29.576]  $ rshopts         : chr(0) 
[16:21:29.576]  $ rank            : int 1
[16:21:29.576]  $ manual          : logi FALSE
[16:21:29.576]  $ dryrun          : logi FALSE
[16:21:29.576]  $ quiet           : logi FALSE
[16:21:29.576]  $ setup_strategy  : chr "parallel"
[16:21:29.576]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:21:29.576]  $ pidfile         : chr "/tmp/RtmpnVB70K/worker.rank=1.parallelly.parent=86806.153162f4f293b.pid"
[16:21:29.576]  $ rshcmd_label    : NULL
[16:21:29.576]  $ rsh_call        : NULL
[16:21:29.576]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:21:29.576]  $ localMachine    : logi TRUE
[16:21:29.576]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:21:29.576]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:21:29.576]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:21:29.576]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:21:29.576]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:21:29.576]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:21:29.576]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:21:29.576]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:21:29.576]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:21:29.576]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:21:29.576]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:21:29.576]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:21:29.576]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:21:29.576]  $ arguments       :List of 28
[16:21:29.576]   ..$ worker          : chr "localhost"
[16:21:29.576]   ..$ master          : NULL
[16:21:29.576]   ..$ port            : int 11322
[16:21:29.576]   ..$ connectTimeout  : num 120
[16:21:29.576]   ..$ timeout         : num 2592000
[16:21:29.576]   ..$ rscript         : NULL
[16:21:29.576]   ..$ homogeneous     : NULL
[16:21:29.576]   ..$ rscript_args    : NULL
[16:21:29.576]   ..$ rscript_envs    : NULL
[16:21:29.576]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:21:29.576]   ..$ rscript_startup : NULL
[16:21:29.576]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:21:29.576]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:21:29.576]   ..$ methods         : logi TRUE
[16:21:29.576]   ..$ socketOptions   : chr "no-delay"
[16:21:29.576]   ..$ useXDR          : logi FALSE
[16:21:29.576]   ..$ outfile         : chr "/dev/null"
[16:21:29.576]   ..$ renice          : int NA
[16:21:29.576]   ..$ rshcmd          : NULL
[16:21:29.576]   ..$ user            : NULL
[16:21:29.576]   ..$ revtunnel       : logi NA
[16:21:29.576]   ..$ rshlogfile      : NULL
[16:21:29.576]   ..$ rshopts         : NULL
[16:21:29.576]   ..$ rank            : int 1
[16:21:29.576]   ..$ manual          : logi FALSE
[16:21:29.576]   ..$ dryrun          : logi FALSE
[16:21:29.576]   ..$ quiet           : logi FALSE
[16:21:29.576]   ..$ setup_strategy  : chr "parallel"
[16:21:29.576]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:21:29.597] [local output] System call to launch all workers:
[16:21:29.597] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpnVB70K/worker.rank=1.parallelly.parent=86806.153162f4f293b.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11322 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:21:29.597] [local output] Starting PSOCK main server
[16:21:29.598] [local output] Workers launched
[16:21:29.599] [local output] Waiting for workers to connect back
[16:21:29.599]  - [local output] 0 workers out of 2 ready
[16:21:29.865]  - [local output] 0 workers out of 2 ready
[16:21:29.865]  - [local output] 1 workers out of 2 ready
[16:21:29.867]  - [local output] 1 workers out of 2 ready
[16:21:29.868]  - [local output] 2 workers out of 2 ready
[16:21:29.868] [local output] Launching of workers completed
[16:21:29.868] [local output] Collecting session information from workers
[16:21:29.869] [local output]  - Worker #1 of 2
[16:21:29.869] [local output]  - Worker #2 of 2
[16:21:29.869] [local output] makeClusterPSOCK() ... done
[16:21:29.880] Packages needed by the future expression (n = 0): <none>
[16:21:29.881] Packages needed by future strategies (n = 1): ‘future’
[16:21:29.881] {
[16:21:29.881]     {
[16:21:29.881]         {
[16:21:29.881]             ...future.startTime <- base::Sys.time()
[16:21:29.881]             {
[16:21:29.881]                 {
[16:21:29.881]                   {
[16:21:29.881]                     {
[16:21:29.881]                       {
[16:21:29.881]                         base::local({
[16:21:29.881]                           has_future <- base::requireNamespace("future", 
[16:21:29.881]                             quietly = TRUE)
[16:21:29.881]                           if (has_future) {
[16:21:29.881]                             ns <- base::getNamespace("future")
[16:21:29.881]                             version <- ns[[".package"]][["version"]]
[16:21:29.881]                             if (is.null(version)) 
[16:21:29.881]                               version <- utils::packageVersion("future")
[16:21:29.881]                           }
[16:21:29.881]                           else {
[16:21:29.881]                             version <- NULL
[16:21:29.881]                           }
[16:21:29.881]                           if (!has_future || version < "1.8.0") {
[16:21:29.881]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:29.881]                               "", base::R.version$version.string), 
[16:21:29.881]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:29.881]                                 base::R.version$platform, 8 * 
[16:21:29.881]                                   base::.Machine$sizeof.pointer), 
[16:21:29.881]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:29.881]                                 "release", "version")], collapse = " "), 
[16:21:29.881]                               hostname = base::Sys.info()[["nodename"]])
[16:21:29.881]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:29.881]                               info)
[16:21:29.881]                             info <- base::paste(info, collapse = "; ")
[16:21:29.881]                             if (!has_future) {
[16:21:29.881]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:29.881]                                 info)
[16:21:29.881]                             }
[16:21:29.881]                             else {
[16:21:29.881]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:29.881]                                 info, version)
[16:21:29.881]                             }
[16:21:29.881]                             base::stop(msg)
[16:21:29.881]                           }
[16:21:29.881]                         })
[16:21:29.881]                       }
[16:21:29.881]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:29.881]                       base::options(mc.cores = 1L)
[16:21:29.881]                     }
[16:21:29.881]                     base::local({
[16:21:29.881]                       for (pkg in "future") {
[16:21:29.881]                         base::loadNamespace(pkg)
[16:21:29.881]                         base::library(pkg, character.only = TRUE)
[16:21:29.881]                       }
[16:21:29.881]                     })
[16:21:29.881]                   }
[16:21:29.881]                   ...future.strategy.old <- future::plan("list")
[16:21:29.881]                   options(future.plan = NULL)
[16:21:29.881]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.881]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:21:29.881]                   {
[16:21:29.881]                     future <- SequentialFuture(..., envir = envir)
[16:21:29.881]                     if (!future$lazy) 
[16:21:29.881]                       future <- run(future)
[16:21:29.881]                     invisible(future)
[16:21:29.881]                   }), .cleanup = FALSE, .init = FALSE)
[16:21:29.881]                 }
[16:21:29.881]                 ...future.workdir <- getwd()
[16:21:29.881]             }
[16:21:29.881]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:29.881]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:29.881]         }
[16:21:29.881]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:29.881]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:29.881]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:29.881]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:29.881]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:29.881]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:29.881]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:29.881]             base::names(...future.oldOptions))
[16:21:29.881]     }
[16:21:29.881]     if (FALSE) {
[16:21:29.881]     }
[16:21:29.881]     else {
[16:21:29.881]         if (TRUE) {
[16:21:29.881]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:29.881]                 open = "w")
[16:21:29.881]         }
[16:21:29.881]         else {
[16:21:29.881]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:29.881]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:29.881]         }
[16:21:29.881]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:29.881]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:29.881]             base::sink(type = "output", split = FALSE)
[16:21:29.881]             base::close(...future.stdout)
[16:21:29.881]         }, add = TRUE)
[16:21:29.881]     }
[16:21:29.881]     ...future.frame <- base::sys.nframe()
[16:21:29.881]     ...future.conditions <- base::list()
[16:21:29.881]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:29.881]     if (FALSE) {
[16:21:29.881]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:29.881]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:29.881]     }
[16:21:29.881]     ...future.result <- base::tryCatch({
[16:21:29.881]         base::withCallingHandlers({
[16:21:29.881]             ...future.value <- base::withVisible(base::local({
[16:21:29.881]                 ...future.makeSendCondition <- base::local({
[16:21:29.881]                   sendCondition <- NULL
[16:21:29.881]                   function(frame = 1L) {
[16:21:29.881]                     if (is.function(sendCondition)) 
[16:21:29.881]                       return(sendCondition)
[16:21:29.881]                     ns <- getNamespace("parallel")
[16:21:29.881]                     if (exists("sendData", mode = "function", 
[16:21:29.881]                       envir = ns)) {
[16:21:29.881]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:29.881]                         envir = ns)
[16:21:29.881]                       envir <- sys.frame(frame)
[16:21:29.881]                       master <- NULL
[16:21:29.881]                       while (!identical(envir, .GlobalEnv) && 
[16:21:29.881]                         !identical(envir, emptyenv())) {
[16:21:29.881]                         if (exists("master", mode = "list", envir = envir, 
[16:21:29.881]                           inherits = FALSE)) {
[16:21:29.881]                           master <- get("master", mode = "list", 
[16:21:29.881]                             envir = envir, inherits = FALSE)
[16:21:29.881]                           if (inherits(master, c("SOCKnode", 
[16:21:29.881]                             "SOCK0node"))) {
[16:21:29.881]                             sendCondition <<- function(cond) {
[16:21:29.881]                               data <- list(type = "VALUE", value = cond, 
[16:21:29.881]                                 success = TRUE)
[16:21:29.881]                               parallel_sendData(master, data)
[16:21:29.881]                             }
[16:21:29.881]                             return(sendCondition)
[16:21:29.881]                           }
[16:21:29.881]                         }
[16:21:29.881]                         frame <- frame + 1L
[16:21:29.881]                         envir <- sys.frame(frame)
[16:21:29.881]                       }
[16:21:29.881]                     }
[16:21:29.881]                     sendCondition <<- function(cond) NULL
[16:21:29.881]                   }
[16:21:29.881]                 })
[16:21:29.881]                 withCallingHandlers({
[16:21:29.881]                   NA
[16:21:29.881]                 }, immediateCondition = function(cond) {
[16:21:29.881]                   sendCondition <- ...future.makeSendCondition()
[16:21:29.881]                   sendCondition(cond)
[16:21:29.881]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.881]                   {
[16:21:29.881]                     inherits <- base::inherits
[16:21:29.881]                     invokeRestart <- base::invokeRestart
[16:21:29.881]                     is.null <- base::is.null
[16:21:29.881]                     muffled <- FALSE
[16:21:29.881]                     if (inherits(cond, "message")) {
[16:21:29.881]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:29.881]                       if (muffled) 
[16:21:29.881]                         invokeRestart("muffleMessage")
[16:21:29.881]                     }
[16:21:29.881]                     else if (inherits(cond, "warning")) {
[16:21:29.881]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:29.881]                       if (muffled) 
[16:21:29.881]                         invokeRestart("muffleWarning")
[16:21:29.881]                     }
[16:21:29.881]                     else if (inherits(cond, "condition")) {
[16:21:29.881]                       if (!is.null(pattern)) {
[16:21:29.881]                         computeRestarts <- base::computeRestarts
[16:21:29.881]                         grepl <- base::grepl
[16:21:29.881]                         restarts <- computeRestarts(cond)
[16:21:29.881]                         for (restart in restarts) {
[16:21:29.881]                           name <- restart$name
[16:21:29.881]                           if (is.null(name)) 
[16:21:29.881]                             next
[16:21:29.881]                           if (!grepl(pattern, name)) 
[16:21:29.881]                             next
[16:21:29.881]                           invokeRestart(restart)
[16:21:29.881]                           muffled <- TRUE
[16:21:29.881]                           break
[16:21:29.881]                         }
[16:21:29.881]                       }
[16:21:29.881]                     }
[16:21:29.881]                     invisible(muffled)
[16:21:29.881]                   }
[16:21:29.881]                   muffleCondition(cond)
[16:21:29.881]                 })
[16:21:29.881]             }))
[16:21:29.881]             future::FutureResult(value = ...future.value$value, 
[16:21:29.881]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.881]                   ...future.rng), globalenv = if (FALSE) 
[16:21:29.881]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:29.881]                     ...future.globalenv.names))
[16:21:29.881]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:29.881]         }, condition = base::local({
[16:21:29.881]             c <- base::c
[16:21:29.881]             inherits <- base::inherits
[16:21:29.881]             invokeRestart <- base::invokeRestart
[16:21:29.881]             length <- base::length
[16:21:29.881]             list <- base::list
[16:21:29.881]             seq.int <- base::seq.int
[16:21:29.881]             signalCondition <- base::signalCondition
[16:21:29.881]             sys.calls <- base::sys.calls
[16:21:29.881]             `[[` <- base::`[[`
[16:21:29.881]             `+` <- base::`+`
[16:21:29.881]             `<<-` <- base::`<<-`
[16:21:29.881]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:29.881]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:29.881]                   3L)]
[16:21:29.881]             }
[16:21:29.881]             function(cond) {
[16:21:29.881]                 is_error <- inherits(cond, "error")
[16:21:29.881]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:29.881]                   NULL)
[16:21:29.881]                 if (is_error) {
[16:21:29.881]                   sessionInformation <- function() {
[16:21:29.881]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:29.881]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:29.881]                       search = base::search(), system = base::Sys.info())
[16:21:29.881]                   }
[16:21:29.881]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.881]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:29.881]                     cond$call), session = sessionInformation(), 
[16:21:29.881]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:29.881]                   signalCondition(cond)
[16:21:29.881]                 }
[16:21:29.881]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:29.881]                 "immediateCondition"))) {
[16:21:29.881]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:29.881]                   ...future.conditions[[length(...future.conditions) + 
[16:21:29.881]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:29.881]                   if (TRUE && !signal) {
[16:21:29.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.881]                     {
[16:21:29.881]                       inherits <- base::inherits
[16:21:29.881]                       invokeRestart <- base::invokeRestart
[16:21:29.881]                       is.null <- base::is.null
[16:21:29.881]                       muffled <- FALSE
[16:21:29.881]                       if (inherits(cond, "message")) {
[16:21:29.881]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.881]                         if (muffled) 
[16:21:29.881]                           invokeRestart("muffleMessage")
[16:21:29.881]                       }
[16:21:29.881]                       else if (inherits(cond, "warning")) {
[16:21:29.881]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.881]                         if (muffled) 
[16:21:29.881]                           invokeRestart("muffleWarning")
[16:21:29.881]                       }
[16:21:29.881]                       else if (inherits(cond, "condition")) {
[16:21:29.881]                         if (!is.null(pattern)) {
[16:21:29.881]                           computeRestarts <- base::computeRestarts
[16:21:29.881]                           grepl <- base::grepl
[16:21:29.881]                           restarts <- computeRestarts(cond)
[16:21:29.881]                           for (restart in restarts) {
[16:21:29.881]                             name <- restart$name
[16:21:29.881]                             if (is.null(name)) 
[16:21:29.881]                               next
[16:21:29.881]                             if (!grepl(pattern, name)) 
[16:21:29.881]                               next
[16:21:29.881]                             invokeRestart(restart)
[16:21:29.881]                             muffled <- TRUE
[16:21:29.881]                             break
[16:21:29.881]                           }
[16:21:29.881]                         }
[16:21:29.881]                       }
[16:21:29.881]                       invisible(muffled)
[16:21:29.881]                     }
[16:21:29.881]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.881]                   }
[16:21:29.881]                 }
[16:21:29.881]                 else {
[16:21:29.881]                   if (TRUE) {
[16:21:29.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:29.881]                     {
[16:21:29.881]                       inherits <- base::inherits
[16:21:29.881]                       invokeRestart <- base::invokeRestart
[16:21:29.881]                       is.null <- base::is.null
[16:21:29.881]                       muffled <- FALSE
[16:21:29.881]                       if (inherits(cond, "message")) {
[16:21:29.881]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:29.881]                         if (muffled) 
[16:21:29.881]                           invokeRestart("muffleMessage")
[16:21:29.881]                       }
[16:21:29.881]                       else if (inherits(cond, "warning")) {
[16:21:29.881]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:29.881]                         if (muffled) 
[16:21:29.881]                           invokeRestart("muffleWarning")
[16:21:29.881]                       }
[16:21:29.881]                       else if (inherits(cond, "condition")) {
[16:21:29.881]                         if (!is.null(pattern)) {
[16:21:29.881]                           computeRestarts <- base::computeRestarts
[16:21:29.881]                           grepl <- base::grepl
[16:21:29.881]                           restarts <- computeRestarts(cond)
[16:21:29.881]                           for (restart in restarts) {
[16:21:29.881]                             name <- restart$name
[16:21:29.881]                             if (is.null(name)) 
[16:21:29.881]                               next
[16:21:29.881]                             if (!grepl(pattern, name)) 
[16:21:29.881]                               next
[16:21:29.881]                             invokeRestart(restart)
[16:21:29.881]                             muffled <- TRUE
[16:21:29.881]                             break
[16:21:29.881]                           }
[16:21:29.881]                         }
[16:21:29.881]                       }
[16:21:29.881]                       invisible(muffled)
[16:21:29.881]                     }
[16:21:29.881]                     muffleCondition(cond, pattern = "^muffle")
[16:21:29.881]                   }
[16:21:29.881]                 }
[16:21:29.881]             }
[16:21:29.881]         }))
[16:21:29.881]     }, error = function(ex) {
[16:21:29.881]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:29.881]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:29.881]                 ...future.rng), started = ...future.startTime, 
[16:21:29.881]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:29.881]             version = "1.8"), class = "FutureResult")
[16:21:29.881]     }, finally = {
[16:21:29.881]         if (!identical(...future.workdir, getwd())) 
[16:21:29.881]             setwd(...future.workdir)
[16:21:29.881]         {
[16:21:29.881]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:29.881]                 ...future.oldOptions$nwarnings <- NULL
[16:21:29.881]             }
[16:21:29.881]             base::options(...future.oldOptions)
[16:21:29.881]             if (.Platform$OS.type == "windows") {
[16:21:29.881]                 old_names <- names(...future.oldEnvVars)
[16:21:29.881]                 envs <- base::Sys.getenv()
[16:21:29.881]                 names <- names(envs)
[16:21:29.881]                 common <- intersect(names, old_names)
[16:21:29.881]                 added <- setdiff(names, old_names)
[16:21:29.881]                 removed <- setdiff(old_names, names)
[16:21:29.881]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:29.881]                   envs[common]]
[16:21:29.881]                 NAMES <- toupper(changed)
[16:21:29.881]                 args <- list()
[16:21:29.881]                 for (kk in seq_along(NAMES)) {
[16:21:29.881]                   name <- changed[[kk]]
[16:21:29.881]                   NAME <- NAMES[[kk]]
[16:21:29.881]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.881]                     next
[16:21:29.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.881]                 }
[16:21:29.881]                 NAMES <- toupper(added)
[16:21:29.881]                 for (kk in seq_along(NAMES)) {
[16:21:29.881]                   name <- added[[kk]]
[16:21:29.881]                   NAME <- NAMES[[kk]]
[16:21:29.881]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.881]                     next
[16:21:29.881]                   args[[name]] <- ""
[16:21:29.881]                 }
[16:21:29.881]                 NAMES <- toupper(removed)
[16:21:29.881]                 for (kk in seq_along(NAMES)) {
[16:21:29.881]                   name <- removed[[kk]]
[16:21:29.881]                   NAME <- NAMES[[kk]]
[16:21:29.881]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:29.881]                     next
[16:21:29.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:29.881]                 }
[16:21:29.881]                 if (length(args) > 0) 
[16:21:29.881]                   base::do.call(base::Sys.setenv, args = args)
[16:21:29.881]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:29.881]             }
[16:21:29.881]             else {
[16:21:29.881]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:29.881]             }
[16:21:29.881]             {
[16:21:29.881]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:29.881]                   0L) {
[16:21:29.881]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:29.881]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:29.881]                   base::options(opts)
[16:21:29.881]                 }
[16:21:29.881]                 {
[16:21:29.881]                   {
[16:21:29.881]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:29.881]                     NULL
[16:21:29.881]                   }
[16:21:29.881]                   options(future.plan = NULL)
[16:21:29.881]                   if (is.na(NA_character_)) 
[16:21:29.881]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:29.881]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:29.881]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:29.881]                     .init = FALSE)
[16:21:29.881]                 }
[16:21:29.881]             }
[16:21:29.881]         }
[16:21:29.881]     })
[16:21:29.881]     if (TRUE) {
[16:21:29.881]         base::sink(type = "output", split = FALSE)
[16:21:29.881]         if (TRUE) {
[16:21:29.881]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:29.881]         }
[16:21:29.881]         else {
[16:21:29.881]             ...future.result["stdout"] <- base::list(NULL)
[16:21:29.881]         }
[16:21:29.881]         base::close(...future.stdout)
[16:21:29.881]         ...future.stdout <- NULL
[16:21:29.881]     }
[16:21:29.881]     ...future.result$conditions <- ...future.conditions
[16:21:29.881]     ...future.result$finished <- base::Sys.time()
[16:21:29.881]     ...future.result
[16:21:29.881] }
[16:21:29.934] MultisessionFuture started
[16:21:29.934] result() for ClusterFuture ...
[16:21:29.935] receiveMessageFromWorker() for ClusterFuture ...
[16:21:29.935] - Validating connection of MultisessionFuture
[16:21:29.973] - received message: FutureResult
[16:21:29.973] - Received FutureResult
[16:21:29.973] - Erased future from FutureRegistry
[16:21:29.974] result() for ClusterFuture ...
[16:21:29.974] - result already collected: FutureResult
[16:21:29.974] result() for ClusterFuture ... done
[16:21:29.974] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:29.974] result() for ClusterFuture ... done
[16:21:29.974] result() for ClusterFuture ...
[16:21:29.974] - result already collected: FutureResult
[16:21:29.974] result() for ClusterFuture ... done
[16:21:29.975] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:21:29.979] plan(): nbrOfWorkers() = 2
[16:21:29.979] getGlobalsAndPackages() ...
[16:21:29.979] Searching for globals...
[16:21:30.000] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:21:30.000] Searching for globals ... DONE
[16:21:30.000] Resolving globals: FALSE
[16:21:30.001] The total size of the 2 globals is 55.46 KiB (56792 bytes)
[16:21:30.002] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 55.46 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (55.34 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:21:30.002] - globals: [2] ‘nested’, ‘strategy2’
[16:21:30.002] - packages: [1] ‘future’
[16:21:30.002] getGlobalsAndPackages() ... DONE
[16:21:30.002] run() for ‘Future’ ...
[16:21:30.002] - state: ‘created’
[16:21:30.003] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:30.017] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:30.017] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:30.017]   - Field: ‘node’
[16:21:30.017]   - Field: ‘label’
[16:21:30.017]   - Field: ‘local’
[16:21:30.017]   - Field: ‘owner’
[16:21:30.017]   - Field: ‘envir’
[16:21:30.017]   - Field: ‘workers’
[16:21:30.018]   - Field: ‘packages’
[16:21:30.018]   - Field: ‘gc’
[16:21:30.018]   - Field: ‘conditions’
[16:21:30.018]   - Field: ‘persistent’
[16:21:30.018]   - Field: ‘expr’
[16:21:30.018]   - Field: ‘uuid’
[16:21:30.018]   - Field: ‘seed’
[16:21:30.018]   - Field: ‘version’
[16:21:30.018]   - Field: ‘result’
[16:21:30.018]   - Field: ‘asynchronous’
[16:21:30.018]   - Field: ‘calls’
[16:21:30.019]   - Field: ‘globals’
[16:21:30.019]   - Field: ‘stdout’
[16:21:30.019]   - Field: ‘earlySignal’
[16:21:30.019]   - Field: ‘lazy’
[16:21:30.019]   - Field: ‘state’
[16:21:30.019] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:30.019] - Launch lazy future ...
[16:21:30.019] Packages needed by the future expression (n = 1): ‘future’
[16:21:30.020] Packages needed by future strategies (n = 1): ‘future’
[16:21:30.020] {
[16:21:30.020]     {
[16:21:30.020]         {
[16:21:30.020]             ...future.startTime <- base::Sys.time()
[16:21:30.020]             {
[16:21:30.020]                 {
[16:21:30.020]                   {
[16:21:30.020]                     {
[16:21:30.020]                       {
[16:21:30.020]                         base::local({
[16:21:30.020]                           has_future <- base::requireNamespace("future", 
[16:21:30.020]                             quietly = TRUE)
[16:21:30.020]                           if (has_future) {
[16:21:30.020]                             ns <- base::getNamespace("future")
[16:21:30.020]                             version <- ns[[".package"]][["version"]]
[16:21:30.020]                             if (is.null(version)) 
[16:21:30.020]                               version <- utils::packageVersion("future")
[16:21:30.020]                           }
[16:21:30.020]                           else {
[16:21:30.020]                             version <- NULL
[16:21:30.020]                           }
[16:21:30.020]                           if (!has_future || version < "1.8.0") {
[16:21:30.020]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:30.020]                               "", base::R.version$version.string), 
[16:21:30.020]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:30.020]                                 base::R.version$platform, 8 * 
[16:21:30.020]                                   base::.Machine$sizeof.pointer), 
[16:21:30.020]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:30.020]                                 "release", "version")], collapse = " "), 
[16:21:30.020]                               hostname = base::Sys.info()[["nodename"]])
[16:21:30.020]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:30.020]                               info)
[16:21:30.020]                             info <- base::paste(info, collapse = "; ")
[16:21:30.020]                             if (!has_future) {
[16:21:30.020]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:30.020]                                 info)
[16:21:30.020]                             }
[16:21:30.020]                             else {
[16:21:30.020]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:30.020]                                 info, version)
[16:21:30.020]                             }
[16:21:30.020]                             base::stop(msg)
[16:21:30.020]                           }
[16:21:30.020]                         })
[16:21:30.020]                       }
[16:21:30.020]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:30.020]                       base::options(mc.cores = 1L)
[16:21:30.020]                     }
[16:21:30.020]                     base::local({
[16:21:30.020]                       for (pkg in "future") {
[16:21:30.020]                         base::loadNamespace(pkg)
[16:21:30.020]                         base::library(pkg, character.only = TRUE)
[16:21:30.020]                       }
[16:21:30.020]                     })
[16:21:30.020]                   }
[16:21:30.020]                   ...future.strategy.old <- future::plan("list")
[16:21:30.020]                   options(future.plan = NULL)
[16:21:30.020]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:30.020]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:21:30.020]                   {
[16:21:30.020]                     future <- SequentialFuture(..., envir = envir)
[16:21:30.020]                     if (!future$lazy) 
[16:21:30.020]                       future <- run(future)
[16:21:30.020]                     invisible(future)
[16:21:30.020]                   }), .cleanup = FALSE, .init = FALSE)
[16:21:30.020]                 }
[16:21:30.020]                 ...future.workdir <- getwd()
[16:21:30.020]             }
[16:21:30.020]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:30.020]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:30.020]         }
[16:21:30.020]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:30.020]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:30.020]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:30.020]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:30.020]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:30.020]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:30.020]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:30.020]             base::names(...future.oldOptions))
[16:21:30.020]     }
[16:21:30.020]     if (FALSE) {
[16:21:30.020]     }
[16:21:30.020]     else {
[16:21:30.020]         if (TRUE) {
[16:21:30.020]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:30.020]                 open = "w")
[16:21:30.020]         }
[16:21:30.020]         else {
[16:21:30.020]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:30.020]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:30.020]         }
[16:21:30.020]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:30.020]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:30.020]             base::sink(type = "output", split = FALSE)
[16:21:30.020]             base::close(...future.stdout)
[16:21:30.020]         }, add = TRUE)
[16:21:30.020]     }
[16:21:30.020]     ...future.frame <- base::sys.nframe()
[16:21:30.020]     ...future.conditions <- base::list()
[16:21:30.020]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:30.020]     if (FALSE) {
[16:21:30.020]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:30.020]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:30.020]     }
[16:21:30.020]     ...future.result <- base::tryCatch({
[16:21:30.020]         base::withCallingHandlers({
[16:21:30.020]             ...future.value <- base::withVisible(base::local({
[16:21:30.020]                 ...future.makeSendCondition <- base::local({
[16:21:30.020]                   sendCondition <- NULL
[16:21:30.020]                   function(frame = 1L) {
[16:21:30.020]                     if (is.function(sendCondition)) 
[16:21:30.020]                       return(sendCondition)
[16:21:30.020]                     ns <- getNamespace("parallel")
[16:21:30.020]                     if (exists("sendData", mode = "function", 
[16:21:30.020]                       envir = ns)) {
[16:21:30.020]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:30.020]                         envir = ns)
[16:21:30.020]                       envir <- sys.frame(frame)
[16:21:30.020]                       master <- NULL
[16:21:30.020]                       while (!identical(envir, .GlobalEnv) && 
[16:21:30.020]                         !identical(envir, emptyenv())) {
[16:21:30.020]                         if (exists("master", mode = "list", envir = envir, 
[16:21:30.020]                           inherits = FALSE)) {
[16:21:30.020]                           master <- get("master", mode = "list", 
[16:21:30.020]                             envir = envir, inherits = FALSE)
[16:21:30.020]                           if (inherits(master, c("SOCKnode", 
[16:21:30.020]                             "SOCK0node"))) {
[16:21:30.020]                             sendCondition <<- function(cond) {
[16:21:30.020]                               data <- list(type = "VALUE", value = cond, 
[16:21:30.020]                                 success = TRUE)
[16:21:30.020]                               parallel_sendData(master, data)
[16:21:30.020]                             }
[16:21:30.020]                             return(sendCondition)
[16:21:30.020]                           }
[16:21:30.020]                         }
[16:21:30.020]                         frame <- frame + 1L
[16:21:30.020]                         envir <- sys.frame(frame)
[16:21:30.020]                       }
[16:21:30.020]                     }
[16:21:30.020]                     sendCondition <<- function(cond) NULL
[16:21:30.020]                   }
[16:21:30.020]                 })
[16:21:30.020]                 withCallingHandlers({
[16:21:30.020]                   {
[16:21:30.020]                     a <- 1L
[16:21:30.020]                     plan_a <- unclass(future::plan("list"))
[16:21:30.020]                     nested_a <- nested[-1]
[16:21:30.020]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:21:30.020]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:21:30.020]                       strategy2))
[16:21:30.020]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:21:30.020]                       "init") <- NULL
[16:21:30.020]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:21:30.020]                       "init") <- NULL
[16:21:30.020]                     stopifnot(all.equal(plan_a, nested_a))
[16:21:30.020]                     y %<-% {
[16:21:30.020]                       b <- 2L
[16:21:30.020]                       plan_b <- future::plan("list")
[16:21:30.020]                       nested_b <- nested_a[-1]
[16:21:30.020]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:21:30.020]                         1L, inherits(plan_b[[1]], "future"), 
[16:21:30.020]                         inherits(future::plan("next"), "sequential"))
[16:21:30.020]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:21:30.020]                         b = b, nested_b = nested_b, plan_b = plan_b)
[16:21:30.020]                     }
[16:21:30.020]                     y
[16:21:30.020]                   }
[16:21:30.020]                 }, immediateCondition = function(cond) {
[16:21:30.020]                   sendCondition <- ...future.makeSendCondition()
[16:21:30.020]                   sendCondition(cond)
[16:21:30.020]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:30.020]                   {
[16:21:30.020]                     inherits <- base::inherits
[16:21:30.020]                     invokeRestart <- base::invokeRestart
[16:21:30.020]                     is.null <- base::is.null
[16:21:30.020]                     muffled <- FALSE
[16:21:30.020]                     if (inherits(cond, "message")) {
[16:21:30.020]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:30.020]                       if (muffled) 
[16:21:30.020]                         invokeRestart("muffleMessage")
[16:21:30.020]                     }
[16:21:30.020]                     else if (inherits(cond, "warning")) {
[16:21:30.020]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:30.020]                       if (muffled) 
[16:21:30.020]                         invokeRestart("muffleWarning")
[16:21:30.020]                     }
[16:21:30.020]                     else if (inherits(cond, "condition")) {
[16:21:30.020]                       if (!is.null(pattern)) {
[16:21:30.020]                         computeRestarts <- base::computeRestarts
[16:21:30.020]                         grepl <- base::grepl
[16:21:30.020]                         restarts <- computeRestarts(cond)
[16:21:30.020]                         for (restart in restarts) {
[16:21:30.020]                           name <- restart$name
[16:21:30.020]                           if (is.null(name)) 
[16:21:30.020]                             next
[16:21:30.020]                           if (!grepl(pattern, name)) 
[16:21:30.020]                             next
[16:21:30.020]                           invokeRestart(restart)
[16:21:30.020]                           muffled <- TRUE
[16:21:30.020]                           break
[16:21:30.020]                         }
[16:21:30.020]                       }
[16:21:30.020]                     }
[16:21:30.020]                     invisible(muffled)
[16:21:30.020]                   }
[16:21:30.020]                   muffleCondition(cond)
[16:21:30.020]                 })
[16:21:30.020]             }))
[16:21:30.020]             future::FutureResult(value = ...future.value$value, 
[16:21:30.020]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:30.020]                   ...future.rng), globalenv = if (FALSE) 
[16:21:30.020]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:30.020]                     ...future.globalenv.names))
[16:21:30.020]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:30.020]         }, condition = base::local({
[16:21:30.020]             c <- base::c
[16:21:30.020]             inherits <- base::inherits
[16:21:30.020]             invokeRestart <- base::invokeRestart
[16:21:30.020]             length <- base::length
[16:21:30.020]             list <- base::list
[16:21:30.020]             seq.int <- base::seq.int
[16:21:30.020]             signalCondition <- base::signalCondition
[16:21:30.020]             sys.calls <- base::sys.calls
[16:21:30.020]             `[[` <- base::`[[`
[16:21:30.020]             `+` <- base::`+`
[16:21:30.020]             `<<-` <- base::`<<-`
[16:21:30.020]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:30.020]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:30.020]                   3L)]
[16:21:30.020]             }
[16:21:30.020]             function(cond) {
[16:21:30.020]                 is_error <- inherits(cond, "error")
[16:21:30.020]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:30.020]                   NULL)
[16:21:30.020]                 if (is_error) {
[16:21:30.020]                   sessionInformation <- function() {
[16:21:30.020]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:30.020]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:30.020]                       search = base::search(), system = base::Sys.info())
[16:21:30.020]                   }
[16:21:30.020]                   ...future.conditions[[length(...future.conditions) + 
[16:21:30.020]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:30.020]                     cond$call), session = sessionInformation(), 
[16:21:30.020]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:30.020]                   signalCondition(cond)
[16:21:30.020]                 }
[16:21:30.020]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:30.020]                 "immediateCondition"))) {
[16:21:30.020]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:30.020]                   ...future.conditions[[length(...future.conditions) + 
[16:21:30.020]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:30.020]                   if (TRUE && !signal) {
[16:21:30.020]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:30.020]                     {
[16:21:30.020]                       inherits <- base::inherits
[16:21:30.020]                       invokeRestart <- base::invokeRestart
[16:21:30.020]                       is.null <- base::is.null
[16:21:30.020]                       muffled <- FALSE
[16:21:30.020]                       if (inherits(cond, "message")) {
[16:21:30.020]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:30.020]                         if (muffled) 
[16:21:30.020]                           invokeRestart("muffleMessage")
[16:21:30.020]                       }
[16:21:30.020]                       else if (inherits(cond, "warning")) {
[16:21:30.020]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:30.020]                         if (muffled) 
[16:21:30.020]                           invokeRestart("muffleWarning")
[16:21:30.020]                       }
[16:21:30.020]                       else if (inherits(cond, "condition")) {
[16:21:30.020]                         if (!is.null(pattern)) {
[16:21:30.020]                           computeRestarts <- base::computeRestarts
[16:21:30.020]                           grepl <- base::grepl
[16:21:30.020]                           restarts <- computeRestarts(cond)
[16:21:30.020]                           for (restart in restarts) {
[16:21:30.020]                             name <- restart$name
[16:21:30.020]                             if (is.null(name)) 
[16:21:30.020]                               next
[16:21:30.020]                             if (!grepl(pattern, name)) 
[16:21:30.020]                               next
[16:21:30.020]                             invokeRestart(restart)
[16:21:30.020]                             muffled <- TRUE
[16:21:30.020]                             break
[16:21:30.020]                           }
[16:21:30.020]                         }
[16:21:30.020]                       }
[16:21:30.020]                       invisible(muffled)
[16:21:30.020]                     }
[16:21:30.020]                     muffleCondition(cond, pattern = "^muffle")
[16:21:30.020]                   }
[16:21:30.020]                 }
[16:21:30.020]                 else {
[16:21:30.020]                   if (TRUE) {
[16:21:30.020]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:30.020]                     {
[16:21:30.020]                       inherits <- base::inherits
[16:21:30.020]                       invokeRestart <- base::invokeRestart
[16:21:30.020]                       is.null <- base::is.null
[16:21:30.020]                       muffled <- FALSE
[16:21:30.020]                       if (inherits(cond, "message")) {
[16:21:30.020]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:30.020]                         if (muffled) 
[16:21:30.020]                           invokeRestart("muffleMessage")
[16:21:30.020]                       }
[16:21:30.020]                       else if (inherits(cond, "warning")) {
[16:21:30.020]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:30.020]                         if (muffled) 
[16:21:30.020]                           invokeRestart("muffleWarning")
[16:21:30.020]                       }
[16:21:30.020]                       else if (inherits(cond, "condition")) {
[16:21:30.020]                         if (!is.null(pattern)) {
[16:21:30.020]                           computeRestarts <- base::computeRestarts
[16:21:30.020]                           grepl <- base::grepl
[16:21:30.020]                           restarts <- computeRestarts(cond)
[16:21:30.020]                           for (restart in restarts) {
[16:21:30.020]                             name <- restart$name
[16:21:30.020]                             if (is.null(name)) 
[16:21:30.020]                               next
[16:21:30.020]                             if (!grepl(pattern, name)) 
[16:21:30.020]                               next
[16:21:30.020]                             invokeRestart(restart)
[16:21:30.020]                             muffled <- TRUE
[16:21:30.020]                             break
[16:21:30.020]                           }
[16:21:30.020]                         }
[16:21:30.020]                       }
[16:21:30.020]                       invisible(muffled)
[16:21:30.020]                     }
[16:21:30.020]                     muffleCondition(cond, pattern = "^muffle")
[16:21:30.020]                   }
[16:21:30.020]                 }
[16:21:30.020]             }
[16:21:30.020]         }))
[16:21:30.020]     }, error = function(ex) {
[16:21:30.020]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:30.020]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:30.020]                 ...future.rng), started = ...future.startTime, 
[16:21:30.020]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:30.020]             version = "1.8"), class = "FutureResult")
[16:21:30.020]     }, finally = {
[16:21:30.020]         if (!identical(...future.workdir, getwd())) 
[16:21:30.020]             setwd(...future.workdir)
[16:21:30.020]         {
[16:21:30.020]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:30.020]                 ...future.oldOptions$nwarnings <- NULL
[16:21:30.020]             }
[16:21:30.020]             base::options(...future.oldOptions)
[16:21:30.020]             if (.Platform$OS.type == "windows") {
[16:21:30.020]                 old_names <- names(...future.oldEnvVars)
[16:21:30.020]                 envs <- base::Sys.getenv()
[16:21:30.020]                 names <- names(envs)
[16:21:30.020]                 common <- intersect(names, old_names)
[16:21:30.020]                 added <- setdiff(names, old_names)
[16:21:30.020]                 removed <- setdiff(old_names, names)
[16:21:30.020]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:30.020]                   envs[common]]
[16:21:30.020]                 NAMES <- toupper(changed)
[16:21:30.020]                 args <- list()
[16:21:30.020]                 for (kk in seq_along(NAMES)) {
[16:21:30.020]                   name <- changed[[kk]]
[16:21:30.020]                   NAME <- NAMES[[kk]]
[16:21:30.020]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:30.020]                     next
[16:21:30.020]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:30.020]                 }
[16:21:30.020]                 NAMES <- toupper(added)
[16:21:30.020]                 for (kk in seq_along(NAMES)) {
[16:21:30.020]                   name <- added[[kk]]
[16:21:30.020]                   NAME <- NAMES[[kk]]
[16:21:30.020]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:30.020]                     next
[16:21:30.020]                   args[[name]] <- ""
[16:21:30.020]                 }
[16:21:30.020]                 NAMES <- toupper(removed)
[16:21:30.020]                 for (kk in seq_along(NAMES)) {
[16:21:30.020]                   name <- removed[[kk]]
[16:21:30.020]                   NAME <- NAMES[[kk]]
[16:21:30.020]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:30.020]                     next
[16:21:30.020]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:30.020]                 }
[16:21:30.020]                 if (length(args) > 0) 
[16:21:30.020]                   base::do.call(base::Sys.setenv, args = args)
[16:21:30.020]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:30.020]             }
[16:21:30.020]             else {
[16:21:30.020]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:30.020]             }
[16:21:30.020]             {
[16:21:30.020]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:30.020]                   0L) {
[16:21:30.020]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:30.020]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:30.020]                   base::options(opts)
[16:21:30.020]                 }
[16:21:30.020]                 {
[16:21:30.020]                   {
[16:21:30.020]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:30.020]                     NULL
[16:21:30.020]                   }
[16:21:30.020]                   options(future.plan = NULL)
[16:21:30.020]                   if (is.na(NA_character_)) 
[16:21:30.020]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:30.020]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:30.020]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:30.020]                     .init = FALSE)
[16:21:30.020]                 }
[16:21:30.020]             }
[16:21:30.020]         }
[16:21:30.020]     })
[16:21:30.020]     if (TRUE) {
[16:21:30.020]         base::sink(type = "output", split = FALSE)
[16:21:30.020]         if (TRUE) {
[16:21:30.020]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:30.020]         }
[16:21:30.020]         else {
[16:21:30.020]             ...future.result["stdout"] <- base::list(NULL)
[16:21:30.020]         }
[16:21:30.020]         base::close(...future.stdout)
[16:21:30.020]         ...future.stdout <- NULL
[16:21:30.020]     }
[16:21:30.020]     ...future.result$conditions <- ...future.conditions
[16:21:30.020]     ...future.result$finished <- base::Sys.time()
[16:21:30.020]     ...future.result
[16:21:30.020] }
[16:21:30.023] Exporting 2 global objects (55.46 KiB) to cluster node #1 ...
[16:21:30.023] Exporting ‘nested’ (55.34 KiB) to cluster node #1 ...
[16:21:30.065] Exporting ‘nested’ (55.34 KiB) to cluster node #1 ... DONE
[16:21:30.065] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[16:21:30.065] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[16:21:30.066] Exporting 2 global objects (55.46 KiB) to cluster node #1 ... DONE
[16:21:30.066] MultisessionFuture started
[16:21:30.066] - Launch lazy future ... done
[16:21:30.066] run() for ‘MultisessionFuture’ ... done
[16:21:30.067] result() for ClusterFuture ...
[16:21:30.067] receiveMessageFromWorker() for ClusterFuture ...
[16:21:30.067] - Validating connection of MultisessionFuture
[16:21:30.130] - received message: FutureResult
[16:21:30.131] - Received FutureResult
[16:21:30.131] - Erased future from FutureRegistry
[16:21:30.131] result() for ClusterFuture ...
[16:21:30.131] - result already collected: FutureResult
[16:21:30.131] result() for ClusterFuture ... done
[16:21:30.131] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:30.131] result() for ClusterFuture ... done
[16:21:30.131] result() for ClusterFuture ...
[16:21:30.132] - result already collected: FutureResult
[16:21:30.132] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:21:30.137] getGlobalsAndPackages() ...
[16:21:30.137] Searching for globals...
[16:21:30.138] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:21:30.138] Searching for globals ... DONE
[16:21:30.138] Resolving globals: FALSE
[16:21:30.139] The total size of the 1 globals is 128 bytes (128 bytes)
[16:21:30.139] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:21:30.139] - globals: [1] ‘data’
[16:21:30.140] - packages: [1] ‘future’
[16:21:30.140] getGlobalsAndPackages() ... DONE
[16:21:30.140] run() for ‘Future’ ...
[16:21:30.140] - state: ‘created’
[16:21:30.140] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:30.157] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:30.157] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:30.157]   - Field: ‘node’
[16:21:30.157]   - Field: ‘label’
[16:21:30.157]   - Field: ‘local’
[16:21:30.157]   - Field: ‘owner’
[16:21:30.157]   - Field: ‘envir’
[16:21:30.157]   - Field: ‘workers’
[16:21:30.157]   - Field: ‘packages’
[16:21:30.158]   - Field: ‘gc’
[16:21:30.158]   - Field: ‘conditions’
[16:21:30.158]   - Field: ‘persistent’
[16:21:30.158]   - Field: ‘expr’
[16:21:30.158]   - Field: ‘uuid’
[16:21:30.158]   - Field: ‘seed’
[16:21:30.158]   - Field: ‘version’
[16:21:30.158]   - Field: ‘result’
[16:21:30.158]   - Field: ‘asynchronous’
[16:21:30.158]   - Field: ‘calls’
[16:21:30.158]   - Field: ‘globals’
[16:21:30.159]   - Field: ‘stdout’
[16:21:30.159]   - Field: ‘earlySignal’
[16:21:30.159]   - Field: ‘lazy’
[16:21:30.159]   - Field: ‘state’
[16:21:30.159] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:30.159] - Launch lazy future ...
[16:21:30.159] Packages needed by the future expression (n = 1): ‘future’
[16:21:30.159] Packages needed by future strategies (n = 1): ‘future’
[16:21:30.160] {
[16:21:30.160]     {
[16:21:30.160]         {
[16:21:30.160]             ...future.startTime <- base::Sys.time()
[16:21:30.160]             {
[16:21:30.160]                 {
[16:21:30.160]                   {
[16:21:30.160]                     {
[16:21:30.160]                       {
[16:21:30.160]                         base::local({
[16:21:30.160]                           has_future <- base::requireNamespace("future", 
[16:21:30.160]                             quietly = TRUE)
[16:21:30.160]                           if (has_future) {
[16:21:30.160]                             ns <- base::getNamespace("future")
[16:21:30.160]                             version <- ns[[".package"]][["version"]]
[16:21:30.160]                             if (is.null(version)) 
[16:21:30.160]                               version <- utils::packageVersion("future")
[16:21:30.160]                           }
[16:21:30.160]                           else {
[16:21:30.160]                             version <- NULL
[16:21:30.160]                           }
[16:21:30.160]                           if (!has_future || version < "1.8.0") {
[16:21:30.160]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:30.160]                               "", base::R.version$version.string), 
[16:21:30.160]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:30.160]                                 base::R.version$platform, 8 * 
[16:21:30.160]                                   base::.Machine$sizeof.pointer), 
[16:21:30.160]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:30.160]                                 "release", "version")], collapse = " "), 
[16:21:30.160]                               hostname = base::Sys.info()[["nodename"]])
[16:21:30.160]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:30.160]                               info)
[16:21:30.160]                             info <- base::paste(info, collapse = "; ")
[16:21:30.160]                             if (!has_future) {
[16:21:30.160]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:30.160]                                 info)
[16:21:30.160]                             }
[16:21:30.160]                             else {
[16:21:30.160]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:30.160]                                 info, version)
[16:21:30.160]                             }
[16:21:30.160]                             base::stop(msg)
[16:21:30.160]                           }
[16:21:30.160]                         })
[16:21:30.160]                       }
[16:21:30.160]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:30.160]                       base::options(mc.cores = 1L)
[16:21:30.160]                     }
[16:21:30.160]                     base::local({
[16:21:30.160]                       for (pkg in "future") {
[16:21:30.160]                         base::loadNamespace(pkg)
[16:21:30.160]                         base::library(pkg, character.only = TRUE)
[16:21:30.160]                       }
[16:21:30.160]                     })
[16:21:30.160]                   }
[16:21:30.160]                   ...future.strategy.old <- future::plan("list")
[16:21:30.160]                   options(future.plan = NULL)
[16:21:30.160]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:30.160]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:21:30.160]                   {
[16:21:30.160]                     future <- SequentialFuture(..., envir = envir)
[16:21:30.160]                     if (!future$lazy) 
[16:21:30.160]                       future <- run(future)
[16:21:30.160]                     invisible(future)
[16:21:30.160]                   }), .cleanup = FALSE, .init = FALSE)
[16:21:30.160]                 }
[16:21:30.160]                 ...future.workdir <- getwd()
[16:21:30.160]             }
[16:21:30.160]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:30.160]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:30.160]         }
[16:21:30.160]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:30.160]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:30.160]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:30.160]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:30.160]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:30.160]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:30.160]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:30.160]             base::names(...future.oldOptions))
[16:21:30.160]     }
[16:21:30.160]     if (FALSE) {
[16:21:30.160]     }
[16:21:30.160]     else {
[16:21:30.160]         if (TRUE) {
[16:21:30.160]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:30.160]                 open = "w")
[16:21:30.160]         }
[16:21:30.160]         else {
[16:21:30.160]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:30.160]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:30.160]         }
[16:21:30.160]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:30.160]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:30.160]             base::sink(type = "output", split = FALSE)
[16:21:30.160]             base::close(...future.stdout)
[16:21:30.160]         }, add = TRUE)
[16:21:30.160]     }
[16:21:30.160]     ...future.frame <- base::sys.nframe()
[16:21:30.160]     ...future.conditions <- base::list()
[16:21:30.160]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:30.160]     if (FALSE) {
[16:21:30.160]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:30.160]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:30.160]     }
[16:21:30.160]     ...future.result <- base::tryCatch({
[16:21:30.160]         base::withCallingHandlers({
[16:21:30.160]             ...future.value <- base::withVisible(base::local({
[16:21:30.160]                 ...future.makeSendCondition <- base::local({
[16:21:30.160]                   sendCondition <- NULL
[16:21:30.160]                   function(frame = 1L) {
[16:21:30.160]                     if (is.function(sendCondition)) 
[16:21:30.160]                       return(sendCondition)
[16:21:30.160]                     ns <- getNamespace("parallel")
[16:21:30.160]                     if (exists("sendData", mode = "function", 
[16:21:30.160]                       envir = ns)) {
[16:21:30.160]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:30.160]                         envir = ns)
[16:21:30.160]                       envir <- sys.frame(frame)
[16:21:30.160]                       master <- NULL
[16:21:30.160]                       while (!identical(envir, .GlobalEnv) && 
[16:21:30.160]                         !identical(envir, emptyenv())) {
[16:21:30.160]                         if (exists("master", mode = "list", envir = envir, 
[16:21:30.160]                           inherits = FALSE)) {
[16:21:30.160]                           master <- get("master", mode = "list", 
[16:21:30.160]                             envir = envir, inherits = FALSE)
[16:21:30.160]                           if (inherits(master, c("SOCKnode", 
[16:21:30.160]                             "SOCK0node"))) {
[16:21:30.160]                             sendCondition <<- function(cond) {
[16:21:30.160]                               data <- list(type = "VALUE", value = cond, 
[16:21:30.160]                                 success = TRUE)
[16:21:30.160]                               parallel_sendData(master, data)
[16:21:30.160]                             }
[16:21:30.160]                             return(sendCondition)
[16:21:30.160]                           }
[16:21:30.160]                         }
[16:21:30.160]                         frame <- frame + 1L
[16:21:30.160]                         envir <- sys.frame(frame)
[16:21:30.160]                       }
[16:21:30.160]                     }
[16:21:30.160]                     sendCondition <<- function(cond) NULL
[16:21:30.160]                   }
[16:21:30.160]                 })
[16:21:30.160]                 withCallingHandlers({
[16:21:30.160]                   {
[16:21:30.160]                     value(future(subset(data, a == 2)))
[16:21:30.160]                   }
[16:21:30.160]                 }, immediateCondition = function(cond) {
[16:21:30.160]                   sendCondition <- ...future.makeSendCondition()
[16:21:30.160]                   sendCondition(cond)
[16:21:30.160]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:30.160]                   {
[16:21:30.160]                     inherits <- base::inherits
[16:21:30.160]                     invokeRestart <- base::invokeRestart
[16:21:30.160]                     is.null <- base::is.null
[16:21:30.160]                     muffled <- FALSE
[16:21:30.160]                     if (inherits(cond, "message")) {
[16:21:30.160]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:30.160]                       if (muffled) 
[16:21:30.160]                         invokeRestart("muffleMessage")
[16:21:30.160]                     }
[16:21:30.160]                     else if (inherits(cond, "warning")) {
[16:21:30.160]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:30.160]                       if (muffled) 
[16:21:30.160]                         invokeRestart("muffleWarning")
[16:21:30.160]                     }
[16:21:30.160]                     else if (inherits(cond, "condition")) {
[16:21:30.160]                       if (!is.null(pattern)) {
[16:21:30.160]                         computeRestarts <- base::computeRestarts
[16:21:30.160]                         grepl <- base::grepl
[16:21:30.160]                         restarts <- computeRestarts(cond)
[16:21:30.160]                         for (restart in restarts) {
[16:21:30.160]                           name <- restart$name
[16:21:30.160]                           if (is.null(name)) 
[16:21:30.160]                             next
[16:21:30.160]                           if (!grepl(pattern, name)) 
[16:21:30.160]                             next
[16:21:30.160]                           invokeRestart(restart)
[16:21:30.160]                           muffled <- TRUE
[16:21:30.160]                           break
[16:21:30.160]                         }
[16:21:30.160]                       }
[16:21:30.160]                     }
[16:21:30.160]                     invisible(muffled)
[16:21:30.160]                   }
[16:21:30.160]                   muffleCondition(cond)
[16:21:30.160]                 })
[16:21:30.160]             }))
[16:21:30.160]             future::FutureResult(value = ...future.value$value, 
[16:21:30.160]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:30.160]                   ...future.rng), globalenv = if (FALSE) 
[16:21:30.160]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:30.160]                     ...future.globalenv.names))
[16:21:30.160]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:30.160]         }, condition = base::local({
[16:21:30.160]             c <- base::c
[16:21:30.160]             inherits <- base::inherits
[16:21:30.160]             invokeRestart <- base::invokeRestart
[16:21:30.160]             length <- base::length
[16:21:30.160]             list <- base::list
[16:21:30.160]             seq.int <- base::seq.int
[16:21:30.160]             signalCondition <- base::signalCondition
[16:21:30.160]             sys.calls <- base::sys.calls
[16:21:30.160]             `[[` <- base::`[[`
[16:21:30.160]             `+` <- base::`+`
[16:21:30.160]             `<<-` <- base::`<<-`
[16:21:30.160]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:30.160]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:30.160]                   3L)]
[16:21:30.160]             }
[16:21:30.160]             function(cond) {
[16:21:30.160]                 is_error <- inherits(cond, "error")
[16:21:30.160]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:30.160]                   NULL)
[16:21:30.160]                 if (is_error) {
[16:21:30.160]                   sessionInformation <- function() {
[16:21:30.160]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:30.160]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:30.160]                       search = base::search(), system = base::Sys.info())
[16:21:30.160]                   }
[16:21:30.160]                   ...future.conditions[[length(...future.conditions) + 
[16:21:30.160]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:30.160]                     cond$call), session = sessionInformation(), 
[16:21:30.160]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:30.160]                   signalCondition(cond)
[16:21:30.160]                 }
[16:21:30.160]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:30.160]                 "immediateCondition"))) {
[16:21:30.160]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:30.160]                   ...future.conditions[[length(...future.conditions) + 
[16:21:30.160]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:30.160]                   if (TRUE && !signal) {
[16:21:30.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:30.160]                     {
[16:21:30.160]                       inherits <- base::inherits
[16:21:30.160]                       invokeRestart <- base::invokeRestart
[16:21:30.160]                       is.null <- base::is.null
[16:21:30.160]                       muffled <- FALSE
[16:21:30.160]                       if (inherits(cond, "message")) {
[16:21:30.160]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:30.160]                         if (muffled) 
[16:21:30.160]                           invokeRestart("muffleMessage")
[16:21:30.160]                       }
[16:21:30.160]                       else if (inherits(cond, "warning")) {
[16:21:30.160]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:30.160]                         if (muffled) 
[16:21:30.160]                           invokeRestart("muffleWarning")
[16:21:30.160]                       }
[16:21:30.160]                       else if (inherits(cond, "condition")) {
[16:21:30.160]                         if (!is.null(pattern)) {
[16:21:30.160]                           computeRestarts <- base::computeRestarts
[16:21:30.160]                           grepl <- base::grepl
[16:21:30.160]                           restarts <- computeRestarts(cond)
[16:21:30.160]                           for (restart in restarts) {
[16:21:30.160]                             name <- restart$name
[16:21:30.160]                             if (is.null(name)) 
[16:21:30.160]                               next
[16:21:30.160]                             if (!grepl(pattern, name)) 
[16:21:30.160]                               next
[16:21:30.160]                             invokeRestart(restart)
[16:21:30.160]                             muffled <- TRUE
[16:21:30.160]                             break
[16:21:30.160]                           }
[16:21:30.160]                         }
[16:21:30.160]                       }
[16:21:30.160]                       invisible(muffled)
[16:21:30.160]                     }
[16:21:30.160]                     muffleCondition(cond, pattern = "^muffle")
[16:21:30.160]                   }
[16:21:30.160]                 }
[16:21:30.160]                 else {
[16:21:30.160]                   if (TRUE) {
[16:21:30.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:30.160]                     {
[16:21:30.160]                       inherits <- base::inherits
[16:21:30.160]                       invokeRestart <- base::invokeRestart
[16:21:30.160]                       is.null <- base::is.null
[16:21:30.160]                       muffled <- FALSE
[16:21:30.160]                       if (inherits(cond, "message")) {
[16:21:30.160]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:30.160]                         if (muffled) 
[16:21:30.160]                           invokeRestart("muffleMessage")
[16:21:30.160]                       }
[16:21:30.160]                       else if (inherits(cond, "warning")) {
[16:21:30.160]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:30.160]                         if (muffled) 
[16:21:30.160]                           invokeRestart("muffleWarning")
[16:21:30.160]                       }
[16:21:30.160]                       else if (inherits(cond, "condition")) {
[16:21:30.160]                         if (!is.null(pattern)) {
[16:21:30.160]                           computeRestarts <- base::computeRestarts
[16:21:30.160]                           grepl <- base::grepl
[16:21:30.160]                           restarts <- computeRestarts(cond)
[16:21:30.160]                           for (restart in restarts) {
[16:21:30.160]                             name <- restart$name
[16:21:30.160]                             if (is.null(name)) 
[16:21:30.160]                               next
[16:21:30.160]                             if (!grepl(pattern, name)) 
[16:21:30.160]                               next
[16:21:30.160]                             invokeRestart(restart)
[16:21:30.160]                             muffled <- TRUE
[16:21:30.160]                             break
[16:21:30.160]                           }
[16:21:30.160]                         }
[16:21:30.160]                       }
[16:21:30.160]                       invisible(muffled)
[16:21:30.160]                     }
[16:21:30.160]                     muffleCondition(cond, pattern = "^muffle")
[16:21:30.160]                   }
[16:21:30.160]                 }
[16:21:30.160]             }
[16:21:30.160]         }))
[16:21:30.160]     }, error = function(ex) {
[16:21:30.160]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:30.160]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:30.160]                 ...future.rng), started = ...future.startTime, 
[16:21:30.160]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:30.160]             version = "1.8"), class = "FutureResult")
[16:21:30.160]     }, finally = {
[16:21:30.160]         if (!identical(...future.workdir, getwd())) 
[16:21:30.160]             setwd(...future.workdir)
[16:21:30.160]         {
[16:21:30.160]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:30.160]                 ...future.oldOptions$nwarnings <- NULL
[16:21:30.160]             }
[16:21:30.160]             base::options(...future.oldOptions)
[16:21:30.160]             if (.Platform$OS.type == "windows") {
[16:21:30.160]                 old_names <- names(...future.oldEnvVars)
[16:21:30.160]                 envs <- base::Sys.getenv()
[16:21:30.160]                 names <- names(envs)
[16:21:30.160]                 common <- intersect(names, old_names)
[16:21:30.160]                 added <- setdiff(names, old_names)
[16:21:30.160]                 removed <- setdiff(old_names, names)
[16:21:30.160]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:30.160]                   envs[common]]
[16:21:30.160]                 NAMES <- toupper(changed)
[16:21:30.160]                 args <- list()
[16:21:30.160]                 for (kk in seq_along(NAMES)) {
[16:21:30.160]                   name <- changed[[kk]]
[16:21:30.160]                   NAME <- NAMES[[kk]]
[16:21:30.160]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:30.160]                     next
[16:21:30.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:30.160]                 }
[16:21:30.160]                 NAMES <- toupper(added)
[16:21:30.160]                 for (kk in seq_along(NAMES)) {
[16:21:30.160]                   name <- added[[kk]]
[16:21:30.160]                   NAME <- NAMES[[kk]]
[16:21:30.160]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:30.160]                     next
[16:21:30.160]                   args[[name]] <- ""
[16:21:30.160]                 }
[16:21:30.160]                 NAMES <- toupper(removed)
[16:21:30.160]                 for (kk in seq_along(NAMES)) {
[16:21:30.160]                   name <- removed[[kk]]
[16:21:30.160]                   NAME <- NAMES[[kk]]
[16:21:30.160]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:30.160]                     next
[16:21:30.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:30.160]                 }
[16:21:30.160]                 if (length(args) > 0) 
[16:21:30.160]                   base::do.call(base::Sys.setenv, args = args)
[16:21:30.160]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:30.160]             }
[16:21:30.160]             else {
[16:21:30.160]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:30.160]             }
[16:21:30.160]             {
[16:21:30.160]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:30.160]                   0L) {
[16:21:30.160]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:30.160]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:30.160]                   base::options(opts)
[16:21:30.160]                 }
[16:21:30.160]                 {
[16:21:30.160]                   {
[16:21:30.160]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:30.160]                     NULL
[16:21:30.160]                   }
[16:21:30.160]                   options(future.plan = NULL)
[16:21:30.160]                   if (is.na(NA_character_)) 
[16:21:30.160]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:30.160]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:30.160]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:30.160]                     .init = FALSE)
[16:21:30.160]                 }
[16:21:30.160]             }
[16:21:30.160]         }
[16:21:30.160]     })
[16:21:30.160]     if (TRUE) {
[16:21:30.160]         base::sink(type = "output", split = FALSE)
[16:21:30.160]         if (TRUE) {
[16:21:30.160]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:30.160]         }
[16:21:30.160]         else {
[16:21:30.160]             ...future.result["stdout"] <- base::list(NULL)
[16:21:30.160]         }
[16:21:30.160]         base::close(...future.stdout)
[16:21:30.160]         ...future.stdout <- NULL
[16:21:30.160]     }
[16:21:30.160]     ...future.result$conditions <- ...future.conditions
[16:21:30.160]     ...future.result$finished <- base::Sys.time()
[16:21:30.160]     ...future.result
[16:21:30.160] }
[16:21:30.163] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[16:21:30.163] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[16:21:30.163] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[16:21:30.164] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[16:21:30.164] MultisessionFuture started
[16:21:30.164] - Launch lazy future ... done
[16:21:30.164] run() for ‘MultisessionFuture’ ... done
[16:21:30.164] result() for ClusterFuture ...
[16:21:30.165] receiveMessageFromWorker() for ClusterFuture ...
[16:21:30.165] - Validating connection of MultisessionFuture
[16:21:30.210] - received message: FutureResult
[16:21:30.210] - Received FutureResult
[16:21:30.210] - Erased future from FutureRegistry
[16:21:30.210] result() for ClusterFuture ...
[16:21:30.210] - result already collected: FutureResult
[16:21:30.210] result() for ClusterFuture ... done
[16:21:30.211] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:30.211] result() for ClusterFuture ... done
[16:21:30.211] result() for ClusterFuture ...
[16:21:30.211] - result already collected: FutureResult
[16:21:30.211] result() for ClusterFuture ... done
- plan(list('multisession', 'sequential')) ... DONE
- plan(list('multisession', 'multicore')) ...
[16:21:30.211] plan(): Setting new future strategy stack:
[16:21:30.211] List of future strategies:
[16:21:30.211] 1. multisession:
[16:21:30.211]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:30.211]    - tweaked: FALSE
[16:21:30.211]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:30.211] 2. multicore:
[16:21:30.211]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:30.211]    - tweaked: FALSE
[16:21:30.211]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:30.212] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:21:30.212] multisession:
[16:21:30.212] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:30.212] - tweaked: FALSE
[16:21:30.212] - call: plan(list(a = strategy1, b = strategy2))
[16:21:30.217] getGlobalsAndPackages() ...
[16:21:30.217] Not searching for globals
[16:21:30.217] - globals: [0] <none>
[16:21:30.217] getGlobalsAndPackages() ... DONE
[16:21:30.217] [local output] makeClusterPSOCK() ...
[16:21:30.221] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:21:30.221] [local output] Base port: 11849
[16:21:30.221] [local output] Getting setup options for 2 cluster nodes ...
[16:21:30.221] [local output]  - Node 1 of 2 ...
[16:21:30.222] [local output] localMachine=TRUE => revtunnel=FALSE

[16:21:30.222] [local output] Rscript port: 11849

[16:21:30.223] [local output]  - Node 2 of 2 ...
[16:21:30.223] [local output] localMachine=TRUE => revtunnel=FALSE

[16:21:30.224] [local output] Rscript port: 11849

[16:21:30.224] [local output] Getting setup options for 2 cluster nodes ... done
[16:21:30.224] [local output]  - Parallel setup requested for some PSOCK nodes
[16:21:30.224] [local output] Setting up PSOCK nodes in parallel
[16:21:30.224] List of 36
[16:21:30.224]  $ worker          : chr "localhost"
[16:21:30.224]   ..- attr(*, "localhost")= logi TRUE
[16:21:30.224]  $ master          : chr "localhost"
[16:21:30.224]  $ port            : int 11849
[16:21:30.224]  $ connectTimeout  : num 120
[16:21:30.224]  $ timeout         : num 2592000
[16:21:30.224]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:21:30.224]  $ homogeneous     : logi TRUE
[16:21:30.224]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:21:30.224]  $ rscript_envs    : NULL
[16:21:30.224]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:21:30.224]  $ rscript_startup : NULL
[16:21:30.224]  $ rscript_sh      : chr "sh"
[16:21:30.224]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:21:30.224]  $ methods         : logi TRUE
[16:21:30.224]  $ socketOptions   : chr "no-delay"
[16:21:30.224]  $ useXDR          : logi FALSE
[16:21:30.224]  $ outfile         : chr "/dev/null"
[16:21:30.224]  $ renice          : int NA
[16:21:30.224]  $ rshcmd          : NULL
[16:21:30.224]  $ user            : chr(0) 
[16:21:30.224]  $ revtunnel       : logi FALSE
[16:21:30.224]  $ rshlogfile      : NULL
[16:21:30.224]  $ rshopts         : chr(0) 
[16:21:30.224]  $ rank            : int 1
[16:21:30.224]  $ manual          : logi FALSE
[16:21:30.224]  $ dryrun          : logi FALSE
[16:21:30.224]  $ quiet           : logi FALSE
[16:21:30.224]  $ setup_strategy  : chr "parallel"
[16:21:30.224]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:21:30.224]  $ pidfile         : chr "/tmp/RtmpnVB70K/worker.rank=1.parallelly.parent=86806.1531610331b28.pid"
[16:21:30.224]  $ rshcmd_label    : NULL
[16:21:30.224]  $ rsh_call        : NULL
[16:21:30.224]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:21:30.224]  $ localMachine    : logi TRUE
[16:21:30.224]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:21:30.224]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:21:30.224]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:21:30.224]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:21:30.224]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:21:30.224]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:21:30.224]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:21:30.224]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:21:30.224]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:21:30.224]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:21:30.224]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:21:30.224]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:21:30.224]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:21:30.224]  $ arguments       :List of 28
[16:21:30.224]   ..$ worker          : chr "localhost"
[16:21:30.224]   ..$ master          : NULL
[16:21:30.224]   ..$ port            : int 11849
[16:21:30.224]   ..$ connectTimeout  : num 120
[16:21:30.224]   ..$ timeout         : num 2592000
[16:21:30.224]   ..$ rscript         : NULL
[16:21:30.224]   ..$ homogeneous     : NULL
[16:21:30.224]   ..$ rscript_args    : NULL
[16:21:30.224]   ..$ rscript_envs    : NULL
[16:21:30.224]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:21:30.224]   ..$ rscript_startup : NULL
[16:21:30.224]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:21:30.224]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:21:30.224]   ..$ methods         : logi TRUE
[16:21:30.224]   ..$ socketOptions   : chr "no-delay"
[16:21:30.224]   ..$ useXDR          : logi FALSE
[16:21:30.224]   ..$ outfile         : chr "/dev/null"
[16:21:30.224]   ..$ renice          : int NA
[16:21:30.224]   ..$ rshcmd          : NULL
[16:21:30.224]   ..$ user            : NULL
[16:21:30.224]   ..$ revtunnel       : logi NA
[16:21:30.224]   ..$ rshlogfile      : NULL
[16:21:30.224]   ..$ rshopts         : NULL
[16:21:30.224]   ..$ rank            : int 1
[16:21:30.224]   ..$ manual          : logi FALSE
[16:21:30.224]   ..$ dryrun          : logi FALSE
[16:21:30.224]   ..$ quiet           : logi FALSE
[16:21:30.224]   ..$ setup_strategy  : chr "parallel"
[16:21:30.224]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:21:30.244] [local output] System call to launch all workers:
[16:21:30.244] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpnVB70K/worker.rank=1.parallelly.parent=86806.1531610331b28.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11849 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:21:30.244] [local output] Starting PSOCK main server
[16:21:30.245] [local output] Workers launched
[16:21:30.245] [local output] Waiting for workers to connect back
[16:21:30.246]  - [local output] 0 workers out of 2 ready
[16:21:30.494]  - [local output] 0 workers out of 2 ready
[16:21:30.494]  - [local output] 1 workers out of 2 ready
[16:21:30.505]  - [local output] 1 workers out of 2 ready
[16:21:30.505]  - [local output] 2 workers out of 2 ready
[16:21:30.505] [local output] Launching of workers completed
[16:21:30.506] [local output] Collecting session information from workers
[16:21:30.506] [local output]  - Worker #1 of 2
[16:21:30.507] [local output]  - Worker #2 of 2
[16:21:30.507] [local output] makeClusterPSOCK() ... done
[16:21:30.518] Packages needed by the future expression (n = 0): <none>
[16:21:30.518] Packages needed by future strategies (n = 1): ‘future’
[16:21:30.519] {
[16:21:30.519]     {
[16:21:30.519]         {
[16:21:30.519]             ...future.startTime <- base::Sys.time()
[16:21:30.519]             {
[16:21:30.519]                 {
[16:21:30.519]                   {
[16:21:30.519]                     {
[16:21:30.519]                       {
[16:21:30.519]                         base::local({
[16:21:30.519]                           has_future <- base::requireNamespace("future", 
[16:21:30.519]                             quietly = TRUE)
[16:21:30.519]                           if (has_future) {
[16:21:30.519]                             ns <- base::getNamespace("future")
[16:21:30.519]                             version <- ns[[".package"]][["version"]]
[16:21:30.519]                             if (is.null(version)) 
[16:21:30.519]                               version <- utils::packageVersion("future")
[16:21:30.519]                           }
[16:21:30.519]                           else {
[16:21:30.519]                             version <- NULL
[16:21:30.519]                           }
[16:21:30.519]                           if (!has_future || version < "1.8.0") {
[16:21:30.519]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:30.519]                               "", base::R.version$version.string), 
[16:21:30.519]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:30.519]                                 base::R.version$platform, 8 * 
[16:21:30.519]                                   base::.Machine$sizeof.pointer), 
[16:21:30.519]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:30.519]                                 "release", "version")], collapse = " "), 
[16:21:30.519]                               hostname = base::Sys.info()[["nodename"]])
[16:21:30.519]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:30.519]                               info)
[16:21:30.519]                             info <- base::paste(info, collapse = "; ")
[16:21:30.519]                             if (!has_future) {
[16:21:30.519]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:30.519]                                 info)
[16:21:30.519]                             }
[16:21:30.519]                             else {
[16:21:30.519]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:30.519]                                 info, version)
[16:21:30.519]                             }
[16:21:30.519]                             base::stop(msg)
[16:21:30.519]                           }
[16:21:30.519]                         })
[16:21:30.519]                       }
[16:21:30.519]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:30.519]                       base::options(mc.cores = 1L)
[16:21:30.519]                     }
[16:21:30.519]                     base::local({
[16:21:30.519]                       for (pkg in "future") {
[16:21:30.519]                         base::loadNamespace(pkg)
[16:21:30.519]                         base::library(pkg, character.only = TRUE)
[16:21:30.519]                       }
[16:21:30.519]                     })
[16:21:30.519]                   }
[16:21:30.519]                   ...future.strategy.old <- future::plan("list")
[16:21:30.519]                   options(future.plan = NULL)
[16:21:30.519]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:30.519]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:21:30.519]                     envir = parent.frame()) 
[16:21:30.519]                   {
[16:21:30.519]                     default_workers <- missing(workers)
[16:21:30.519]                     if (is.function(workers)) 
[16:21:30.519]                       workers <- workers()
[16:21:30.519]                     workers <- structure(as.integer(workers), 
[16:21:30.519]                       class = class(workers))
[16:21:30.519]                     stop_if_not(is.finite(workers), workers >= 
[16:21:30.519]                       1L)
[16:21:30.519]                     if ((workers == 1L && !inherits(workers, 
[16:21:30.519]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:21:30.519]                       if (default_workers) 
[16:21:30.519]                         supportsMulticore(warn = TRUE)
[16:21:30.519]                       return(sequential(..., envir = envir))
[16:21:30.519]                     }
[16:21:30.519]                     oopts <- options(mc.cores = workers)
[16:21:30.519]                     on.exit(options(oopts))
[16:21:30.519]                     future <- MulticoreFuture(..., workers = workers, 
[16:21:30.519]                       envir = envir)
[16:21:30.519]                     if (!future$lazy) 
[16:21:30.519]                       future <- run(future)
[16:21:30.519]                     invisible(future)
[16:21:30.519]                   }), .cleanup = FALSE, .init = FALSE)
[16:21:30.519]                 }
[16:21:30.519]                 ...future.workdir <- getwd()
[16:21:30.519]             }
[16:21:30.519]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:30.519]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:30.519]         }
[16:21:30.519]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:30.519]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:30.519]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:30.519]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:30.519]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:30.519]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:30.519]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:30.519]             base::names(...future.oldOptions))
[16:21:30.519]     }
[16:21:30.519]     if (FALSE) {
[16:21:30.519]     }
[16:21:30.519]     else {
[16:21:30.519]         if (TRUE) {
[16:21:30.519]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:30.519]                 open = "w")
[16:21:30.519]         }
[16:21:30.519]         else {
[16:21:30.519]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:30.519]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:30.519]         }
[16:21:30.519]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:30.519]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:30.519]             base::sink(type = "output", split = FALSE)
[16:21:30.519]             base::close(...future.stdout)
[16:21:30.519]         }, add = TRUE)
[16:21:30.519]     }
[16:21:30.519]     ...future.frame <- base::sys.nframe()
[16:21:30.519]     ...future.conditions <- base::list()
[16:21:30.519]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:30.519]     if (FALSE) {
[16:21:30.519]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:30.519]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:30.519]     }
[16:21:30.519]     ...future.result <- base::tryCatch({
[16:21:30.519]         base::withCallingHandlers({
[16:21:30.519]             ...future.value <- base::withVisible(base::local({
[16:21:30.519]                 ...future.makeSendCondition <- base::local({
[16:21:30.519]                   sendCondition <- NULL
[16:21:30.519]                   function(frame = 1L) {
[16:21:30.519]                     if (is.function(sendCondition)) 
[16:21:30.519]                       return(sendCondition)
[16:21:30.519]                     ns <- getNamespace("parallel")
[16:21:30.519]                     if (exists("sendData", mode = "function", 
[16:21:30.519]                       envir = ns)) {
[16:21:30.519]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:30.519]                         envir = ns)
[16:21:30.519]                       envir <- sys.frame(frame)
[16:21:30.519]                       master <- NULL
[16:21:30.519]                       while (!identical(envir, .GlobalEnv) && 
[16:21:30.519]                         !identical(envir, emptyenv())) {
[16:21:30.519]                         if (exists("master", mode = "list", envir = envir, 
[16:21:30.519]                           inherits = FALSE)) {
[16:21:30.519]                           master <- get("master", mode = "list", 
[16:21:30.519]                             envir = envir, inherits = FALSE)
[16:21:30.519]                           if (inherits(master, c("SOCKnode", 
[16:21:30.519]                             "SOCK0node"))) {
[16:21:30.519]                             sendCondition <<- function(cond) {
[16:21:30.519]                               data <- list(type = "VALUE", value = cond, 
[16:21:30.519]                                 success = TRUE)
[16:21:30.519]                               parallel_sendData(master, data)
[16:21:30.519]                             }
[16:21:30.519]                             return(sendCondition)
[16:21:30.519]                           }
[16:21:30.519]                         }
[16:21:30.519]                         frame <- frame + 1L
[16:21:30.519]                         envir <- sys.frame(frame)
[16:21:30.519]                       }
[16:21:30.519]                     }
[16:21:30.519]                     sendCondition <<- function(cond) NULL
[16:21:30.519]                   }
[16:21:30.519]                 })
[16:21:30.519]                 withCallingHandlers({
[16:21:30.519]                   NA
[16:21:30.519]                 }, immediateCondition = function(cond) {
[16:21:30.519]                   sendCondition <- ...future.makeSendCondition()
[16:21:30.519]                   sendCondition(cond)
[16:21:30.519]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:30.519]                   {
[16:21:30.519]                     inherits <- base::inherits
[16:21:30.519]                     invokeRestart <- base::invokeRestart
[16:21:30.519]                     is.null <- base::is.null
[16:21:30.519]                     muffled <- FALSE
[16:21:30.519]                     if (inherits(cond, "message")) {
[16:21:30.519]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:30.519]                       if (muffled) 
[16:21:30.519]                         invokeRestart("muffleMessage")
[16:21:30.519]                     }
[16:21:30.519]                     else if (inherits(cond, "warning")) {
[16:21:30.519]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:30.519]                       if (muffled) 
[16:21:30.519]                         invokeRestart("muffleWarning")
[16:21:30.519]                     }
[16:21:30.519]                     else if (inherits(cond, "condition")) {
[16:21:30.519]                       if (!is.null(pattern)) {
[16:21:30.519]                         computeRestarts <- base::computeRestarts
[16:21:30.519]                         grepl <- base::grepl
[16:21:30.519]                         restarts <- computeRestarts(cond)
[16:21:30.519]                         for (restart in restarts) {
[16:21:30.519]                           name <- restart$name
[16:21:30.519]                           if (is.null(name)) 
[16:21:30.519]                             next
[16:21:30.519]                           if (!grepl(pattern, name)) 
[16:21:30.519]                             next
[16:21:30.519]                           invokeRestart(restart)
[16:21:30.519]                           muffled <- TRUE
[16:21:30.519]                           break
[16:21:30.519]                         }
[16:21:30.519]                       }
[16:21:30.519]                     }
[16:21:30.519]                     invisible(muffled)
[16:21:30.519]                   }
[16:21:30.519]                   muffleCondition(cond)
[16:21:30.519]                 })
[16:21:30.519]             }))
[16:21:30.519]             future::FutureResult(value = ...future.value$value, 
[16:21:30.519]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:30.519]                   ...future.rng), globalenv = if (FALSE) 
[16:21:30.519]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:30.519]                     ...future.globalenv.names))
[16:21:30.519]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:30.519]         }, condition = base::local({
[16:21:30.519]             c <- base::c
[16:21:30.519]             inherits <- base::inherits
[16:21:30.519]             invokeRestart <- base::invokeRestart
[16:21:30.519]             length <- base::length
[16:21:30.519]             list <- base::list
[16:21:30.519]             seq.int <- base::seq.int
[16:21:30.519]             signalCondition <- base::signalCondition
[16:21:30.519]             sys.calls <- base::sys.calls
[16:21:30.519]             `[[` <- base::`[[`
[16:21:30.519]             `+` <- base::`+`
[16:21:30.519]             `<<-` <- base::`<<-`
[16:21:30.519]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:30.519]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:30.519]                   3L)]
[16:21:30.519]             }
[16:21:30.519]             function(cond) {
[16:21:30.519]                 is_error <- inherits(cond, "error")
[16:21:30.519]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:30.519]                   NULL)
[16:21:30.519]                 if (is_error) {
[16:21:30.519]                   sessionInformation <- function() {
[16:21:30.519]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:30.519]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:30.519]                       search = base::search(), system = base::Sys.info())
[16:21:30.519]                   }
[16:21:30.519]                   ...future.conditions[[length(...future.conditions) + 
[16:21:30.519]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:30.519]                     cond$call), session = sessionInformation(), 
[16:21:30.519]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:30.519]                   signalCondition(cond)
[16:21:30.519]                 }
[16:21:30.519]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:30.519]                 "immediateCondition"))) {
[16:21:30.519]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:30.519]                   ...future.conditions[[length(...future.conditions) + 
[16:21:30.519]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:30.519]                   if (TRUE && !signal) {
[16:21:30.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:30.519]                     {
[16:21:30.519]                       inherits <- base::inherits
[16:21:30.519]                       invokeRestart <- base::invokeRestart
[16:21:30.519]                       is.null <- base::is.null
[16:21:30.519]                       muffled <- FALSE
[16:21:30.519]                       if (inherits(cond, "message")) {
[16:21:30.519]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:30.519]                         if (muffled) 
[16:21:30.519]                           invokeRestart("muffleMessage")
[16:21:30.519]                       }
[16:21:30.519]                       else if (inherits(cond, "warning")) {
[16:21:30.519]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:30.519]                         if (muffled) 
[16:21:30.519]                           invokeRestart("muffleWarning")
[16:21:30.519]                       }
[16:21:30.519]                       else if (inherits(cond, "condition")) {
[16:21:30.519]                         if (!is.null(pattern)) {
[16:21:30.519]                           computeRestarts <- base::computeRestarts
[16:21:30.519]                           grepl <- base::grepl
[16:21:30.519]                           restarts <- computeRestarts(cond)
[16:21:30.519]                           for (restart in restarts) {
[16:21:30.519]                             name <- restart$name
[16:21:30.519]                             if (is.null(name)) 
[16:21:30.519]                               next
[16:21:30.519]                             if (!grepl(pattern, name)) 
[16:21:30.519]                               next
[16:21:30.519]                             invokeRestart(restart)
[16:21:30.519]                             muffled <- TRUE
[16:21:30.519]                             break
[16:21:30.519]                           }
[16:21:30.519]                         }
[16:21:30.519]                       }
[16:21:30.519]                       invisible(muffled)
[16:21:30.519]                     }
[16:21:30.519]                     muffleCondition(cond, pattern = "^muffle")
[16:21:30.519]                   }
[16:21:30.519]                 }
[16:21:30.519]                 else {
[16:21:30.519]                   if (TRUE) {
[16:21:30.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:30.519]                     {
[16:21:30.519]                       inherits <- base::inherits
[16:21:30.519]                       invokeRestart <- base::invokeRestart
[16:21:30.519]                       is.null <- base::is.null
[16:21:30.519]                       muffled <- FALSE
[16:21:30.519]                       if (inherits(cond, "message")) {
[16:21:30.519]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:30.519]                         if (muffled) 
[16:21:30.519]                           invokeRestart("muffleMessage")
[16:21:30.519]                       }
[16:21:30.519]                       else if (inherits(cond, "warning")) {
[16:21:30.519]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:30.519]                         if (muffled) 
[16:21:30.519]                           invokeRestart("muffleWarning")
[16:21:30.519]                       }
[16:21:30.519]                       else if (inherits(cond, "condition")) {
[16:21:30.519]                         if (!is.null(pattern)) {
[16:21:30.519]                           computeRestarts <- base::computeRestarts
[16:21:30.519]                           grepl <- base::grepl
[16:21:30.519]                           restarts <- computeRestarts(cond)
[16:21:30.519]                           for (restart in restarts) {
[16:21:30.519]                             name <- restart$name
[16:21:30.519]                             if (is.null(name)) 
[16:21:30.519]                               next
[16:21:30.519]                             if (!grepl(pattern, name)) 
[16:21:30.519]                               next
[16:21:30.519]                             invokeRestart(restart)
[16:21:30.519]                             muffled <- TRUE
[16:21:30.519]                             break
[16:21:30.519]                           }
[16:21:30.519]                         }
[16:21:30.519]                       }
[16:21:30.519]                       invisible(muffled)
[16:21:30.519]                     }
[16:21:30.519]                     muffleCondition(cond, pattern = "^muffle")
[16:21:30.519]                   }
[16:21:30.519]                 }
[16:21:30.519]             }
[16:21:30.519]         }))
[16:21:30.519]     }, error = function(ex) {
[16:21:30.519]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:30.519]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:30.519]                 ...future.rng), started = ...future.startTime, 
[16:21:30.519]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:30.519]             version = "1.8"), class = "FutureResult")
[16:21:30.519]     }, finally = {
[16:21:30.519]         if (!identical(...future.workdir, getwd())) 
[16:21:30.519]             setwd(...future.workdir)
[16:21:30.519]         {
[16:21:30.519]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:30.519]                 ...future.oldOptions$nwarnings <- NULL
[16:21:30.519]             }
[16:21:30.519]             base::options(...future.oldOptions)
[16:21:30.519]             if (.Platform$OS.type == "windows") {
[16:21:30.519]                 old_names <- names(...future.oldEnvVars)
[16:21:30.519]                 envs <- base::Sys.getenv()
[16:21:30.519]                 names <- names(envs)
[16:21:30.519]                 common <- intersect(names, old_names)
[16:21:30.519]                 added <- setdiff(names, old_names)
[16:21:30.519]                 removed <- setdiff(old_names, names)
[16:21:30.519]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:30.519]                   envs[common]]
[16:21:30.519]                 NAMES <- toupper(changed)
[16:21:30.519]                 args <- list()
[16:21:30.519]                 for (kk in seq_along(NAMES)) {
[16:21:30.519]                   name <- changed[[kk]]
[16:21:30.519]                   NAME <- NAMES[[kk]]
[16:21:30.519]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:30.519]                     next
[16:21:30.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:30.519]                 }
[16:21:30.519]                 NAMES <- toupper(added)
[16:21:30.519]                 for (kk in seq_along(NAMES)) {
[16:21:30.519]                   name <- added[[kk]]
[16:21:30.519]                   NAME <- NAMES[[kk]]
[16:21:30.519]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:30.519]                     next
[16:21:30.519]                   args[[name]] <- ""
[16:21:30.519]                 }
[16:21:30.519]                 NAMES <- toupper(removed)
[16:21:30.519]                 for (kk in seq_along(NAMES)) {
[16:21:30.519]                   name <- removed[[kk]]
[16:21:30.519]                   NAME <- NAMES[[kk]]
[16:21:30.519]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:30.519]                     next
[16:21:30.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:30.519]                 }
[16:21:30.519]                 if (length(args) > 0) 
[16:21:30.519]                   base::do.call(base::Sys.setenv, args = args)
[16:21:30.519]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:30.519]             }
[16:21:30.519]             else {
[16:21:30.519]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:30.519]             }
[16:21:30.519]             {
[16:21:30.519]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:30.519]                   0L) {
[16:21:30.519]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:30.519]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:30.519]                   base::options(opts)
[16:21:30.519]                 }
[16:21:30.519]                 {
[16:21:30.519]                   {
[16:21:30.519]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:30.519]                     NULL
[16:21:30.519]                   }
[16:21:30.519]                   options(future.plan = NULL)
[16:21:30.519]                   if (is.na(NA_character_)) 
[16:21:30.519]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:30.519]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:30.519]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:30.519]                     .init = FALSE)
[16:21:30.519]                 }
[16:21:30.519]             }
[16:21:30.519]         }
[16:21:30.519]     })
[16:21:30.519]     if (TRUE) {
[16:21:30.519]         base::sink(type = "output", split = FALSE)
[16:21:30.519]         if (TRUE) {
[16:21:30.519]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:30.519]         }
[16:21:30.519]         else {
[16:21:30.519]             ...future.result["stdout"] <- base::list(NULL)
[16:21:30.519]         }
[16:21:30.519]         base::close(...future.stdout)
[16:21:30.519]         ...future.stdout <- NULL
[16:21:30.519]     }
[16:21:30.519]     ...future.result$conditions <- ...future.conditions
[16:21:30.519]     ...future.result$finished <- base::Sys.time()
[16:21:30.519]     ...future.result
[16:21:30.519] }
[16:21:30.573] MultisessionFuture started
[16:21:30.573] result() for ClusterFuture ...
[16:21:30.573] receiveMessageFromWorker() for ClusterFuture ...
[16:21:30.574] - Validating connection of MultisessionFuture
[16:21:30.621] - received message: FutureResult
[16:21:30.621] - Received FutureResult
[16:21:30.621] - Erased future from FutureRegistry
[16:21:30.621] result() for ClusterFuture ...
[16:21:30.621] - result already collected: FutureResult
[16:21:30.621] result() for ClusterFuture ... done
[16:21:30.622] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:30.622] result() for ClusterFuture ... done
[16:21:30.622] result() for ClusterFuture ...
[16:21:30.622] - result already collected: FutureResult
[16:21:30.622] result() for ClusterFuture ... done
[16:21:30.622] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:21:30.626] plan(): nbrOfWorkers() = 2
[16:21:30.626] getGlobalsAndPackages() ...
[16:21:30.626] Searching for globals...
[16:21:30.644] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:21:30.644] Searching for globals ... DONE
[16:21:30.645] Resolving globals: FALSE
[16:21:30.645] The total size of the 2 globals is 90.70 KiB (92872 bytes)
[16:21:30.646] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 90.70 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (90.58 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:21:30.646] - globals: [2] ‘nested’, ‘strategy2’
[16:21:30.646] - packages: [1] ‘future’
[16:21:30.646] getGlobalsAndPackages() ... DONE
[16:21:30.647] run() for ‘Future’ ...
[16:21:30.647] - state: ‘created’
[16:21:30.647] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:30.661] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:30.661] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:30.661]   - Field: ‘node’
[16:21:30.661]   - Field: ‘label’
[16:21:30.661]   - Field: ‘local’
[16:21:30.661]   - Field: ‘owner’
[16:21:30.662]   - Field: ‘envir’
[16:21:30.662]   - Field: ‘workers’
[16:21:30.662]   - Field: ‘packages’
[16:21:30.662]   - Field: ‘gc’
[16:21:30.662]   - Field: ‘conditions’
[16:21:30.662]   - Field: ‘persistent’
[16:21:30.662]   - Field: ‘expr’
[16:21:30.662]   - Field: ‘uuid’
[16:21:30.662]   - Field: ‘seed’
[16:21:30.662]   - Field: ‘version’
[16:21:30.663]   - Field: ‘result’
[16:21:30.663]   - Field: ‘asynchronous’
[16:21:30.663]   - Field: ‘calls’
[16:21:30.663]   - Field: ‘globals’
[16:21:30.663]   - Field: ‘stdout’
[16:21:30.663]   - Field: ‘earlySignal’
[16:21:30.663]   - Field: ‘lazy’
[16:21:30.663]   - Field: ‘state’
[16:21:30.663] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:30.663] - Launch lazy future ...
[16:21:30.664] Packages needed by the future expression (n = 1): ‘future’
[16:21:30.664] Packages needed by future strategies (n = 1): ‘future’
[16:21:30.664] {
[16:21:30.664]     {
[16:21:30.664]         {
[16:21:30.664]             ...future.startTime <- base::Sys.time()
[16:21:30.664]             {
[16:21:30.664]                 {
[16:21:30.664]                   {
[16:21:30.664]                     {
[16:21:30.664]                       {
[16:21:30.664]                         base::local({
[16:21:30.664]                           has_future <- base::requireNamespace("future", 
[16:21:30.664]                             quietly = TRUE)
[16:21:30.664]                           if (has_future) {
[16:21:30.664]                             ns <- base::getNamespace("future")
[16:21:30.664]                             version <- ns[[".package"]][["version"]]
[16:21:30.664]                             if (is.null(version)) 
[16:21:30.664]                               version <- utils::packageVersion("future")
[16:21:30.664]                           }
[16:21:30.664]                           else {
[16:21:30.664]                             version <- NULL
[16:21:30.664]                           }
[16:21:30.664]                           if (!has_future || version < "1.8.0") {
[16:21:30.664]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:30.664]                               "", base::R.version$version.string), 
[16:21:30.664]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:30.664]                                 base::R.version$platform, 8 * 
[16:21:30.664]                                   base::.Machine$sizeof.pointer), 
[16:21:30.664]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:30.664]                                 "release", "version")], collapse = " "), 
[16:21:30.664]                               hostname = base::Sys.info()[["nodename"]])
[16:21:30.664]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:30.664]                               info)
[16:21:30.664]                             info <- base::paste(info, collapse = "; ")
[16:21:30.664]                             if (!has_future) {
[16:21:30.664]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:30.664]                                 info)
[16:21:30.664]                             }
[16:21:30.664]                             else {
[16:21:30.664]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:30.664]                                 info, version)
[16:21:30.664]                             }
[16:21:30.664]                             base::stop(msg)
[16:21:30.664]                           }
[16:21:30.664]                         })
[16:21:30.664]                       }
[16:21:30.664]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:30.664]                       base::options(mc.cores = 1L)
[16:21:30.664]                     }
[16:21:30.664]                     base::local({
[16:21:30.664]                       for (pkg in "future") {
[16:21:30.664]                         base::loadNamespace(pkg)
[16:21:30.664]                         base::library(pkg, character.only = TRUE)
[16:21:30.664]                       }
[16:21:30.664]                     })
[16:21:30.664]                   }
[16:21:30.664]                   ...future.strategy.old <- future::plan("list")
[16:21:30.664]                   options(future.plan = NULL)
[16:21:30.664]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:30.664]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:21:30.664]                     envir = parent.frame()) 
[16:21:30.664]                   {
[16:21:30.664]                     default_workers <- missing(workers)
[16:21:30.664]                     if (is.function(workers)) 
[16:21:30.664]                       workers <- workers()
[16:21:30.664]                     workers <- structure(as.integer(workers), 
[16:21:30.664]                       class = class(workers))
[16:21:30.664]                     stop_if_not(is.finite(workers), workers >= 
[16:21:30.664]                       1L)
[16:21:30.664]                     if ((workers == 1L && !inherits(workers, 
[16:21:30.664]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:21:30.664]                       if (default_workers) 
[16:21:30.664]                         supportsMulticore(warn = TRUE)
[16:21:30.664]                       return(sequential(..., envir = envir))
[16:21:30.664]                     }
[16:21:30.664]                     oopts <- options(mc.cores = workers)
[16:21:30.664]                     on.exit(options(oopts))
[16:21:30.664]                     future <- MulticoreFuture(..., workers = workers, 
[16:21:30.664]                       envir = envir)
[16:21:30.664]                     if (!future$lazy) 
[16:21:30.664]                       future <- run(future)
[16:21:30.664]                     invisible(future)
[16:21:30.664]                   }), .cleanup = FALSE, .init = FALSE)
[16:21:30.664]                 }
[16:21:30.664]                 ...future.workdir <- getwd()
[16:21:30.664]             }
[16:21:30.664]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:30.664]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:30.664]         }
[16:21:30.664]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:30.664]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:30.664]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:30.664]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:30.664]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:30.664]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:30.664]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:30.664]             base::names(...future.oldOptions))
[16:21:30.664]     }
[16:21:30.664]     if (FALSE) {
[16:21:30.664]     }
[16:21:30.664]     else {
[16:21:30.664]         if (TRUE) {
[16:21:30.664]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:30.664]                 open = "w")
[16:21:30.664]         }
[16:21:30.664]         else {
[16:21:30.664]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:30.664]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:30.664]         }
[16:21:30.664]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:30.664]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:30.664]             base::sink(type = "output", split = FALSE)
[16:21:30.664]             base::close(...future.stdout)
[16:21:30.664]         }, add = TRUE)
[16:21:30.664]     }
[16:21:30.664]     ...future.frame <- base::sys.nframe()
[16:21:30.664]     ...future.conditions <- base::list()
[16:21:30.664]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:30.664]     if (FALSE) {
[16:21:30.664]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:30.664]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:30.664]     }
[16:21:30.664]     ...future.result <- base::tryCatch({
[16:21:30.664]         base::withCallingHandlers({
[16:21:30.664]             ...future.value <- base::withVisible(base::local({
[16:21:30.664]                 ...future.makeSendCondition <- base::local({
[16:21:30.664]                   sendCondition <- NULL
[16:21:30.664]                   function(frame = 1L) {
[16:21:30.664]                     if (is.function(sendCondition)) 
[16:21:30.664]                       return(sendCondition)
[16:21:30.664]                     ns <- getNamespace("parallel")
[16:21:30.664]                     if (exists("sendData", mode = "function", 
[16:21:30.664]                       envir = ns)) {
[16:21:30.664]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:30.664]                         envir = ns)
[16:21:30.664]                       envir <- sys.frame(frame)
[16:21:30.664]                       master <- NULL
[16:21:30.664]                       while (!identical(envir, .GlobalEnv) && 
[16:21:30.664]                         !identical(envir, emptyenv())) {
[16:21:30.664]                         if (exists("master", mode = "list", envir = envir, 
[16:21:30.664]                           inherits = FALSE)) {
[16:21:30.664]                           master <- get("master", mode = "list", 
[16:21:30.664]                             envir = envir, inherits = FALSE)
[16:21:30.664]                           if (inherits(master, c("SOCKnode", 
[16:21:30.664]                             "SOCK0node"))) {
[16:21:30.664]                             sendCondition <<- function(cond) {
[16:21:30.664]                               data <- list(type = "VALUE", value = cond, 
[16:21:30.664]                                 success = TRUE)
[16:21:30.664]                               parallel_sendData(master, data)
[16:21:30.664]                             }
[16:21:30.664]                             return(sendCondition)
[16:21:30.664]                           }
[16:21:30.664]                         }
[16:21:30.664]                         frame <- frame + 1L
[16:21:30.664]                         envir <- sys.frame(frame)
[16:21:30.664]                       }
[16:21:30.664]                     }
[16:21:30.664]                     sendCondition <<- function(cond) NULL
[16:21:30.664]                   }
[16:21:30.664]                 })
[16:21:30.664]                 withCallingHandlers({
[16:21:30.664]                   {
[16:21:30.664]                     a <- 1L
[16:21:30.664]                     plan_a <- unclass(future::plan("list"))
[16:21:30.664]                     nested_a <- nested[-1]
[16:21:30.664]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:21:30.664]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:21:30.664]                       strategy2))
[16:21:30.664]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:21:30.664]                       "init") <- NULL
[16:21:30.664]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:21:30.664]                       "init") <- NULL
[16:21:30.664]                     stopifnot(all.equal(plan_a, nested_a))
[16:21:30.664]                     y %<-% {
[16:21:30.664]                       b <- 2L
[16:21:30.664]                       plan_b <- future::plan("list")
[16:21:30.664]                       nested_b <- nested_a[-1]
[16:21:30.664]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:21:30.664]                         1L, inherits(plan_b[[1]], "future"), 
[16:21:30.664]                         inherits(future::plan("next"), "sequential"))
[16:21:30.664]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:21:30.664]                         b = b, nested_b = nested_b, plan_b = plan_b)
[16:21:30.664]                     }
[16:21:30.664]                     y
[16:21:30.664]                   }
[16:21:30.664]                 }, immediateCondition = function(cond) {
[16:21:30.664]                   sendCondition <- ...future.makeSendCondition()
[16:21:30.664]                   sendCondition(cond)
[16:21:30.664]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:30.664]                   {
[16:21:30.664]                     inherits <- base::inherits
[16:21:30.664]                     invokeRestart <- base::invokeRestart
[16:21:30.664]                     is.null <- base::is.null
[16:21:30.664]                     muffled <- FALSE
[16:21:30.664]                     if (inherits(cond, "message")) {
[16:21:30.664]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:30.664]                       if (muffled) 
[16:21:30.664]                         invokeRestart("muffleMessage")
[16:21:30.664]                     }
[16:21:30.664]                     else if (inherits(cond, "warning")) {
[16:21:30.664]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:30.664]                       if (muffled) 
[16:21:30.664]                         invokeRestart("muffleWarning")
[16:21:30.664]                     }
[16:21:30.664]                     else if (inherits(cond, "condition")) {
[16:21:30.664]                       if (!is.null(pattern)) {
[16:21:30.664]                         computeRestarts <- base::computeRestarts
[16:21:30.664]                         grepl <- base::grepl
[16:21:30.664]                         restarts <- computeRestarts(cond)
[16:21:30.664]                         for (restart in restarts) {
[16:21:30.664]                           name <- restart$name
[16:21:30.664]                           if (is.null(name)) 
[16:21:30.664]                             next
[16:21:30.664]                           if (!grepl(pattern, name)) 
[16:21:30.664]                             next
[16:21:30.664]                           invokeRestart(restart)
[16:21:30.664]                           muffled <- TRUE
[16:21:30.664]                           break
[16:21:30.664]                         }
[16:21:30.664]                       }
[16:21:30.664]                     }
[16:21:30.664]                     invisible(muffled)
[16:21:30.664]                   }
[16:21:30.664]                   muffleCondition(cond)
[16:21:30.664]                 })
[16:21:30.664]             }))
[16:21:30.664]             future::FutureResult(value = ...future.value$value, 
[16:21:30.664]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:30.664]                   ...future.rng), globalenv = if (FALSE) 
[16:21:30.664]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:30.664]                     ...future.globalenv.names))
[16:21:30.664]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:30.664]         }, condition = base::local({
[16:21:30.664]             c <- base::c
[16:21:30.664]             inherits <- base::inherits
[16:21:30.664]             invokeRestart <- base::invokeRestart
[16:21:30.664]             length <- base::length
[16:21:30.664]             list <- base::list
[16:21:30.664]             seq.int <- base::seq.int
[16:21:30.664]             signalCondition <- base::signalCondition
[16:21:30.664]             sys.calls <- base::sys.calls
[16:21:30.664]             `[[` <- base::`[[`
[16:21:30.664]             `+` <- base::`+`
[16:21:30.664]             `<<-` <- base::`<<-`
[16:21:30.664]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:30.664]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:30.664]                   3L)]
[16:21:30.664]             }
[16:21:30.664]             function(cond) {
[16:21:30.664]                 is_error <- inherits(cond, "error")
[16:21:30.664]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:30.664]                   NULL)
[16:21:30.664]                 if (is_error) {
[16:21:30.664]                   sessionInformation <- function() {
[16:21:30.664]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:30.664]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:30.664]                       search = base::search(), system = base::Sys.info())
[16:21:30.664]                   }
[16:21:30.664]                   ...future.conditions[[length(...future.conditions) + 
[16:21:30.664]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:30.664]                     cond$call), session = sessionInformation(), 
[16:21:30.664]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:30.664]                   signalCondition(cond)
[16:21:30.664]                 }
[16:21:30.664]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:30.664]                 "immediateCondition"))) {
[16:21:30.664]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:30.664]                   ...future.conditions[[length(...future.conditions) + 
[16:21:30.664]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:30.664]                   if (TRUE && !signal) {
[16:21:30.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:30.664]                     {
[16:21:30.664]                       inherits <- base::inherits
[16:21:30.664]                       invokeRestart <- base::invokeRestart
[16:21:30.664]                       is.null <- base::is.null
[16:21:30.664]                       muffled <- FALSE
[16:21:30.664]                       if (inherits(cond, "message")) {
[16:21:30.664]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:30.664]                         if (muffled) 
[16:21:30.664]                           invokeRestart("muffleMessage")
[16:21:30.664]                       }
[16:21:30.664]                       else if (inherits(cond, "warning")) {
[16:21:30.664]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:30.664]                         if (muffled) 
[16:21:30.664]                           invokeRestart("muffleWarning")
[16:21:30.664]                       }
[16:21:30.664]                       else if (inherits(cond, "condition")) {
[16:21:30.664]                         if (!is.null(pattern)) {
[16:21:30.664]                           computeRestarts <- base::computeRestarts
[16:21:30.664]                           grepl <- base::grepl
[16:21:30.664]                           restarts <- computeRestarts(cond)
[16:21:30.664]                           for (restart in restarts) {
[16:21:30.664]                             name <- restart$name
[16:21:30.664]                             if (is.null(name)) 
[16:21:30.664]                               next
[16:21:30.664]                             if (!grepl(pattern, name)) 
[16:21:30.664]                               next
[16:21:30.664]                             invokeRestart(restart)
[16:21:30.664]                             muffled <- TRUE
[16:21:30.664]                             break
[16:21:30.664]                           }
[16:21:30.664]                         }
[16:21:30.664]                       }
[16:21:30.664]                       invisible(muffled)
[16:21:30.664]                     }
[16:21:30.664]                     muffleCondition(cond, pattern = "^muffle")
[16:21:30.664]                   }
[16:21:30.664]                 }
[16:21:30.664]                 else {
[16:21:30.664]                   if (TRUE) {
[16:21:30.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:30.664]                     {
[16:21:30.664]                       inherits <- base::inherits
[16:21:30.664]                       invokeRestart <- base::invokeRestart
[16:21:30.664]                       is.null <- base::is.null
[16:21:30.664]                       muffled <- FALSE
[16:21:30.664]                       if (inherits(cond, "message")) {
[16:21:30.664]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:30.664]                         if (muffled) 
[16:21:30.664]                           invokeRestart("muffleMessage")
[16:21:30.664]                       }
[16:21:30.664]                       else if (inherits(cond, "warning")) {
[16:21:30.664]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:30.664]                         if (muffled) 
[16:21:30.664]                           invokeRestart("muffleWarning")
[16:21:30.664]                       }
[16:21:30.664]                       else if (inherits(cond, "condition")) {
[16:21:30.664]                         if (!is.null(pattern)) {
[16:21:30.664]                           computeRestarts <- base::computeRestarts
[16:21:30.664]                           grepl <- base::grepl
[16:21:30.664]                           restarts <- computeRestarts(cond)
[16:21:30.664]                           for (restart in restarts) {
[16:21:30.664]                             name <- restart$name
[16:21:30.664]                             if (is.null(name)) 
[16:21:30.664]                               next
[16:21:30.664]                             if (!grepl(pattern, name)) 
[16:21:30.664]                               next
[16:21:30.664]                             invokeRestart(restart)
[16:21:30.664]                             muffled <- TRUE
[16:21:30.664]                             break
[16:21:30.664]                           }
[16:21:30.664]                         }
[16:21:30.664]                       }
[16:21:30.664]                       invisible(muffled)
[16:21:30.664]                     }
[16:21:30.664]                     muffleCondition(cond, pattern = "^muffle")
[16:21:30.664]                   }
[16:21:30.664]                 }
[16:21:30.664]             }
[16:21:30.664]         }))
[16:21:30.664]     }, error = function(ex) {
[16:21:30.664]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:30.664]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:30.664]                 ...future.rng), started = ...future.startTime, 
[16:21:30.664]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:30.664]             version = "1.8"), class = "FutureResult")
[16:21:30.664]     }, finally = {
[16:21:30.664]         if (!identical(...future.workdir, getwd())) 
[16:21:30.664]             setwd(...future.workdir)
[16:21:30.664]         {
[16:21:30.664]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:30.664]                 ...future.oldOptions$nwarnings <- NULL
[16:21:30.664]             }
[16:21:30.664]             base::options(...future.oldOptions)
[16:21:30.664]             if (.Platform$OS.type == "windows") {
[16:21:30.664]                 old_names <- names(...future.oldEnvVars)
[16:21:30.664]                 envs <- base::Sys.getenv()
[16:21:30.664]                 names <- names(envs)
[16:21:30.664]                 common <- intersect(names, old_names)
[16:21:30.664]                 added <- setdiff(names, old_names)
[16:21:30.664]                 removed <- setdiff(old_names, names)
[16:21:30.664]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:30.664]                   envs[common]]
[16:21:30.664]                 NAMES <- toupper(changed)
[16:21:30.664]                 args <- list()
[16:21:30.664]                 for (kk in seq_along(NAMES)) {
[16:21:30.664]                   name <- changed[[kk]]
[16:21:30.664]                   NAME <- NAMES[[kk]]
[16:21:30.664]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:30.664]                     next
[16:21:30.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:30.664]                 }
[16:21:30.664]                 NAMES <- toupper(added)
[16:21:30.664]                 for (kk in seq_along(NAMES)) {
[16:21:30.664]                   name <- added[[kk]]
[16:21:30.664]                   NAME <- NAMES[[kk]]
[16:21:30.664]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:30.664]                     next
[16:21:30.664]                   args[[name]] <- ""
[16:21:30.664]                 }
[16:21:30.664]                 NAMES <- toupper(removed)
[16:21:30.664]                 for (kk in seq_along(NAMES)) {
[16:21:30.664]                   name <- removed[[kk]]
[16:21:30.664]                   NAME <- NAMES[[kk]]
[16:21:30.664]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:30.664]                     next
[16:21:30.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:30.664]                 }
[16:21:30.664]                 if (length(args) > 0) 
[16:21:30.664]                   base::do.call(base::Sys.setenv, args = args)
[16:21:30.664]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:30.664]             }
[16:21:30.664]             else {
[16:21:30.664]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:30.664]             }
[16:21:30.664]             {
[16:21:30.664]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:30.664]                   0L) {
[16:21:30.664]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:30.664]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:30.664]                   base::options(opts)
[16:21:30.664]                 }
[16:21:30.664]                 {
[16:21:30.664]                   {
[16:21:30.664]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:30.664]                     NULL
[16:21:30.664]                   }
[16:21:30.664]                   options(future.plan = NULL)
[16:21:30.664]                   if (is.na(NA_character_)) 
[16:21:30.664]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:30.664]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:30.664]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:30.664]                     .init = FALSE)
[16:21:30.664]                 }
[16:21:30.664]             }
[16:21:30.664]         }
[16:21:30.664]     })
[16:21:30.664]     if (TRUE) {
[16:21:30.664]         base::sink(type = "output", split = FALSE)
[16:21:30.664]         if (TRUE) {
[16:21:30.664]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:30.664]         }
[16:21:30.664]         else {
[16:21:30.664]             ...future.result["stdout"] <- base::list(NULL)
[16:21:30.664]         }
[16:21:30.664]         base::close(...future.stdout)
[16:21:30.664]         ...future.stdout <- NULL
[16:21:30.664]     }
[16:21:30.664]     ...future.result$conditions <- ...future.conditions
[16:21:30.664]     ...future.result$finished <- base::Sys.time()
[16:21:30.664]     ...future.result
[16:21:30.664] }
[16:21:30.667] Exporting 2 global objects (90.70 KiB) to cluster node #1 ...
[16:21:30.668] Exporting ‘nested’ (90.58 KiB) to cluster node #1 ...
[16:21:30.709] Exporting ‘nested’ (90.58 KiB) to cluster node #1 ... DONE
[16:21:30.709] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[16:21:30.709] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[16:21:30.709] Exporting 2 global objects (90.70 KiB) to cluster node #1 ... DONE
[16:21:30.710] MultisessionFuture started
[16:21:30.710] - Launch lazy future ... done
[16:21:30.710] run() for ‘MultisessionFuture’ ... done
[16:21:30.710] result() for ClusterFuture ...
[16:21:30.710] receiveMessageFromWorker() for ClusterFuture ...
[16:21:30.711] - Validating connection of MultisessionFuture
[16:21:30.785] - received message: FutureResult
[16:21:30.785] - Received FutureResult
[16:21:30.785] - Erased future from FutureRegistry
[16:21:30.785] result() for ClusterFuture ...
[16:21:30.786] - result already collected: FutureResult
[16:21:30.786] result() for ClusterFuture ... done
[16:21:30.786] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:30.786] result() for ClusterFuture ... done
[16:21:30.786] result() for ClusterFuture ...
[16:21:30.786] - result already collected: FutureResult
[16:21:30.786] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:21:30.791] getGlobalsAndPackages() ...
[16:21:30.791] Searching for globals...
[16:21:30.793] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:21:30.793] Searching for globals ... DONE
[16:21:30.793] Resolving globals: FALSE
[16:21:30.794] The total size of the 1 globals is 128 bytes (128 bytes)
[16:21:30.794] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:21:30.794] - globals: [1] ‘data’
[16:21:30.794] - packages: [1] ‘future’
[16:21:30.794] getGlobalsAndPackages() ... DONE
[16:21:30.795] run() for ‘Future’ ...
[16:21:30.795] - state: ‘created’
[16:21:30.795] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:30.809] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:30.809] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:30.809]   - Field: ‘node’
[16:21:30.809]   - Field: ‘label’
[16:21:30.809]   - Field: ‘local’
[16:21:30.809]   - Field: ‘owner’
[16:21:30.809]   - Field: ‘envir’
[16:21:30.809]   - Field: ‘workers’
[16:21:30.809]   - Field: ‘packages’
[16:21:30.809]   - Field: ‘gc’
[16:21:30.810]   - Field: ‘conditions’
[16:21:30.810]   - Field: ‘persistent’
[16:21:30.810]   - Field: ‘expr’
[16:21:30.810]   - Field: ‘uuid’
[16:21:30.810]   - Field: ‘seed’
[16:21:30.810]   - Field: ‘version’
[16:21:30.810]   - Field: ‘result’
[16:21:30.810]   - Field: ‘asynchronous’
[16:21:30.810]   - Field: ‘calls’
[16:21:30.810]   - Field: ‘globals’
[16:21:30.810]   - Field: ‘stdout’
[16:21:30.811]   - Field: ‘earlySignal’
[16:21:30.811]   - Field: ‘lazy’
[16:21:30.811]   - Field: ‘state’
[16:21:30.811] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:30.811] - Launch lazy future ...
[16:21:30.811] Packages needed by the future expression (n = 1): ‘future’
[16:21:30.811] Packages needed by future strategies (n = 1): ‘future’
[16:21:30.812] {
[16:21:30.812]     {
[16:21:30.812]         {
[16:21:30.812]             ...future.startTime <- base::Sys.time()
[16:21:30.812]             {
[16:21:30.812]                 {
[16:21:30.812]                   {
[16:21:30.812]                     {
[16:21:30.812]                       {
[16:21:30.812]                         base::local({
[16:21:30.812]                           has_future <- base::requireNamespace("future", 
[16:21:30.812]                             quietly = TRUE)
[16:21:30.812]                           if (has_future) {
[16:21:30.812]                             ns <- base::getNamespace("future")
[16:21:30.812]                             version <- ns[[".package"]][["version"]]
[16:21:30.812]                             if (is.null(version)) 
[16:21:30.812]                               version <- utils::packageVersion("future")
[16:21:30.812]                           }
[16:21:30.812]                           else {
[16:21:30.812]                             version <- NULL
[16:21:30.812]                           }
[16:21:30.812]                           if (!has_future || version < "1.8.0") {
[16:21:30.812]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:30.812]                               "", base::R.version$version.string), 
[16:21:30.812]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:30.812]                                 base::R.version$platform, 8 * 
[16:21:30.812]                                   base::.Machine$sizeof.pointer), 
[16:21:30.812]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:30.812]                                 "release", "version")], collapse = " "), 
[16:21:30.812]                               hostname = base::Sys.info()[["nodename"]])
[16:21:30.812]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:30.812]                               info)
[16:21:30.812]                             info <- base::paste(info, collapse = "; ")
[16:21:30.812]                             if (!has_future) {
[16:21:30.812]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:30.812]                                 info)
[16:21:30.812]                             }
[16:21:30.812]                             else {
[16:21:30.812]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:30.812]                                 info, version)
[16:21:30.812]                             }
[16:21:30.812]                             base::stop(msg)
[16:21:30.812]                           }
[16:21:30.812]                         })
[16:21:30.812]                       }
[16:21:30.812]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:30.812]                       base::options(mc.cores = 1L)
[16:21:30.812]                     }
[16:21:30.812]                     base::local({
[16:21:30.812]                       for (pkg in "future") {
[16:21:30.812]                         base::loadNamespace(pkg)
[16:21:30.812]                         base::library(pkg, character.only = TRUE)
[16:21:30.812]                       }
[16:21:30.812]                     })
[16:21:30.812]                   }
[16:21:30.812]                   ...future.strategy.old <- future::plan("list")
[16:21:30.812]                   options(future.plan = NULL)
[16:21:30.812]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:30.812]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:21:30.812]                     envir = parent.frame()) 
[16:21:30.812]                   {
[16:21:30.812]                     default_workers <- missing(workers)
[16:21:30.812]                     if (is.function(workers)) 
[16:21:30.812]                       workers <- workers()
[16:21:30.812]                     workers <- structure(as.integer(workers), 
[16:21:30.812]                       class = class(workers))
[16:21:30.812]                     stop_if_not(is.finite(workers), workers >= 
[16:21:30.812]                       1L)
[16:21:30.812]                     if ((workers == 1L && !inherits(workers, 
[16:21:30.812]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:21:30.812]                       if (default_workers) 
[16:21:30.812]                         supportsMulticore(warn = TRUE)
[16:21:30.812]                       return(sequential(..., envir = envir))
[16:21:30.812]                     }
[16:21:30.812]                     oopts <- options(mc.cores = workers)
[16:21:30.812]                     on.exit(options(oopts))
[16:21:30.812]                     future <- MulticoreFuture(..., workers = workers, 
[16:21:30.812]                       envir = envir)
[16:21:30.812]                     if (!future$lazy) 
[16:21:30.812]                       future <- run(future)
[16:21:30.812]                     invisible(future)
[16:21:30.812]                   }), .cleanup = FALSE, .init = FALSE)
[16:21:30.812]                 }
[16:21:30.812]                 ...future.workdir <- getwd()
[16:21:30.812]             }
[16:21:30.812]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:30.812]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:30.812]         }
[16:21:30.812]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:30.812]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:30.812]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:30.812]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:30.812]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:30.812]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:30.812]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:30.812]             base::names(...future.oldOptions))
[16:21:30.812]     }
[16:21:30.812]     if (FALSE) {
[16:21:30.812]     }
[16:21:30.812]     else {
[16:21:30.812]         if (TRUE) {
[16:21:30.812]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:30.812]                 open = "w")
[16:21:30.812]         }
[16:21:30.812]         else {
[16:21:30.812]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:30.812]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:30.812]         }
[16:21:30.812]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:30.812]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:30.812]             base::sink(type = "output", split = FALSE)
[16:21:30.812]             base::close(...future.stdout)
[16:21:30.812]         }, add = TRUE)
[16:21:30.812]     }
[16:21:30.812]     ...future.frame <- base::sys.nframe()
[16:21:30.812]     ...future.conditions <- base::list()
[16:21:30.812]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:30.812]     if (FALSE) {
[16:21:30.812]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:30.812]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:30.812]     }
[16:21:30.812]     ...future.result <- base::tryCatch({
[16:21:30.812]         base::withCallingHandlers({
[16:21:30.812]             ...future.value <- base::withVisible(base::local({
[16:21:30.812]                 ...future.makeSendCondition <- base::local({
[16:21:30.812]                   sendCondition <- NULL
[16:21:30.812]                   function(frame = 1L) {
[16:21:30.812]                     if (is.function(sendCondition)) 
[16:21:30.812]                       return(sendCondition)
[16:21:30.812]                     ns <- getNamespace("parallel")
[16:21:30.812]                     if (exists("sendData", mode = "function", 
[16:21:30.812]                       envir = ns)) {
[16:21:30.812]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:30.812]                         envir = ns)
[16:21:30.812]                       envir <- sys.frame(frame)
[16:21:30.812]                       master <- NULL
[16:21:30.812]                       while (!identical(envir, .GlobalEnv) && 
[16:21:30.812]                         !identical(envir, emptyenv())) {
[16:21:30.812]                         if (exists("master", mode = "list", envir = envir, 
[16:21:30.812]                           inherits = FALSE)) {
[16:21:30.812]                           master <- get("master", mode = "list", 
[16:21:30.812]                             envir = envir, inherits = FALSE)
[16:21:30.812]                           if (inherits(master, c("SOCKnode", 
[16:21:30.812]                             "SOCK0node"))) {
[16:21:30.812]                             sendCondition <<- function(cond) {
[16:21:30.812]                               data <- list(type = "VALUE", value = cond, 
[16:21:30.812]                                 success = TRUE)
[16:21:30.812]                               parallel_sendData(master, data)
[16:21:30.812]                             }
[16:21:30.812]                             return(sendCondition)
[16:21:30.812]                           }
[16:21:30.812]                         }
[16:21:30.812]                         frame <- frame + 1L
[16:21:30.812]                         envir <- sys.frame(frame)
[16:21:30.812]                       }
[16:21:30.812]                     }
[16:21:30.812]                     sendCondition <<- function(cond) NULL
[16:21:30.812]                   }
[16:21:30.812]                 })
[16:21:30.812]                 withCallingHandlers({
[16:21:30.812]                   {
[16:21:30.812]                     value(future(subset(data, a == 2)))
[16:21:30.812]                   }
[16:21:30.812]                 }, immediateCondition = function(cond) {
[16:21:30.812]                   sendCondition <- ...future.makeSendCondition()
[16:21:30.812]                   sendCondition(cond)
[16:21:30.812]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:30.812]                   {
[16:21:30.812]                     inherits <- base::inherits
[16:21:30.812]                     invokeRestart <- base::invokeRestart
[16:21:30.812]                     is.null <- base::is.null
[16:21:30.812]                     muffled <- FALSE
[16:21:30.812]                     if (inherits(cond, "message")) {
[16:21:30.812]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:30.812]                       if (muffled) 
[16:21:30.812]                         invokeRestart("muffleMessage")
[16:21:30.812]                     }
[16:21:30.812]                     else if (inherits(cond, "warning")) {
[16:21:30.812]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:30.812]                       if (muffled) 
[16:21:30.812]                         invokeRestart("muffleWarning")
[16:21:30.812]                     }
[16:21:30.812]                     else if (inherits(cond, "condition")) {
[16:21:30.812]                       if (!is.null(pattern)) {
[16:21:30.812]                         computeRestarts <- base::computeRestarts
[16:21:30.812]                         grepl <- base::grepl
[16:21:30.812]                         restarts <- computeRestarts(cond)
[16:21:30.812]                         for (restart in restarts) {
[16:21:30.812]                           name <- restart$name
[16:21:30.812]                           if (is.null(name)) 
[16:21:30.812]                             next
[16:21:30.812]                           if (!grepl(pattern, name)) 
[16:21:30.812]                             next
[16:21:30.812]                           invokeRestart(restart)
[16:21:30.812]                           muffled <- TRUE
[16:21:30.812]                           break
[16:21:30.812]                         }
[16:21:30.812]                       }
[16:21:30.812]                     }
[16:21:30.812]                     invisible(muffled)
[16:21:30.812]                   }
[16:21:30.812]                   muffleCondition(cond)
[16:21:30.812]                 })
[16:21:30.812]             }))
[16:21:30.812]             future::FutureResult(value = ...future.value$value, 
[16:21:30.812]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:30.812]                   ...future.rng), globalenv = if (FALSE) 
[16:21:30.812]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:30.812]                     ...future.globalenv.names))
[16:21:30.812]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:30.812]         }, condition = base::local({
[16:21:30.812]             c <- base::c
[16:21:30.812]             inherits <- base::inherits
[16:21:30.812]             invokeRestart <- base::invokeRestart
[16:21:30.812]             length <- base::length
[16:21:30.812]             list <- base::list
[16:21:30.812]             seq.int <- base::seq.int
[16:21:30.812]             signalCondition <- base::signalCondition
[16:21:30.812]             sys.calls <- base::sys.calls
[16:21:30.812]             `[[` <- base::`[[`
[16:21:30.812]             `+` <- base::`+`
[16:21:30.812]             `<<-` <- base::`<<-`
[16:21:30.812]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:30.812]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:30.812]                   3L)]
[16:21:30.812]             }
[16:21:30.812]             function(cond) {
[16:21:30.812]                 is_error <- inherits(cond, "error")
[16:21:30.812]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:30.812]                   NULL)
[16:21:30.812]                 if (is_error) {
[16:21:30.812]                   sessionInformation <- function() {
[16:21:30.812]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:30.812]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:30.812]                       search = base::search(), system = base::Sys.info())
[16:21:30.812]                   }
[16:21:30.812]                   ...future.conditions[[length(...future.conditions) + 
[16:21:30.812]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:30.812]                     cond$call), session = sessionInformation(), 
[16:21:30.812]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:30.812]                   signalCondition(cond)
[16:21:30.812]                 }
[16:21:30.812]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:30.812]                 "immediateCondition"))) {
[16:21:30.812]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:30.812]                   ...future.conditions[[length(...future.conditions) + 
[16:21:30.812]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:30.812]                   if (TRUE && !signal) {
[16:21:30.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:30.812]                     {
[16:21:30.812]                       inherits <- base::inherits
[16:21:30.812]                       invokeRestart <- base::invokeRestart
[16:21:30.812]                       is.null <- base::is.null
[16:21:30.812]                       muffled <- FALSE
[16:21:30.812]                       if (inherits(cond, "message")) {
[16:21:30.812]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:30.812]                         if (muffled) 
[16:21:30.812]                           invokeRestart("muffleMessage")
[16:21:30.812]                       }
[16:21:30.812]                       else if (inherits(cond, "warning")) {
[16:21:30.812]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:30.812]                         if (muffled) 
[16:21:30.812]                           invokeRestart("muffleWarning")
[16:21:30.812]                       }
[16:21:30.812]                       else if (inherits(cond, "condition")) {
[16:21:30.812]                         if (!is.null(pattern)) {
[16:21:30.812]                           computeRestarts <- base::computeRestarts
[16:21:30.812]                           grepl <- base::grepl
[16:21:30.812]                           restarts <- computeRestarts(cond)
[16:21:30.812]                           for (restart in restarts) {
[16:21:30.812]                             name <- restart$name
[16:21:30.812]                             if (is.null(name)) 
[16:21:30.812]                               next
[16:21:30.812]                             if (!grepl(pattern, name)) 
[16:21:30.812]                               next
[16:21:30.812]                             invokeRestart(restart)
[16:21:30.812]                             muffled <- TRUE
[16:21:30.812]                             break
[16:21:30.812]                           }
[16:21:30.812]                         }
[16:21:30.812]                       }
[16:21:30.812]                       invisible(muffled)
[16:21:30.812]                     }
[16:21:30.812]                     muffleCondition(cond, pattern = "^muffle")
[16:21:30.812]                   }
[16:21:30.812]                 }
[16:21:30.812]                 else {
[16:21:30.812]                   if (TRUE) {
[16:21:30.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:30.812]                     {
[16:21:30.812]                       inherits <- base::inherits
[16:21:30.812]                       invokeRestart <- base::invokeRestart
[16:21:30.812]                       is.null <- base::is.null
[16:21:30.812]                       muffled <- FALSE
[16:21:30.812]                       if (inherits(cond, "message")) {
[16:21:30.812]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:30.812]                         if (muffled) 
[16:21:30.812]                           invokeRestart("muffleMessage")
[16:21:30.812]                       }
[16:21:30.812]                       else if (inherits(cond, "warning")) {
[16:21:30.812]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:30.812]                         if (muffled) 
[16:21:30.812]                           invokeRestart("muffleWarning")
[16:21:30.812]                       }
[16:21:30.812]                       else if (inherits(cond, "condition")) {
[16:21:30.812]                         if (!is.null(pattern)) {
[16:21:30.812]                           computeRestarts <- base::computeRestarts
[16:21:30.812]                           grepl <- base::grepl
[16:21:30.812]                           restarts <- computeRestarts(cond)
[16:21:30.812]                           for (restart in restarts) {
[16:21:30.812]                             name <- restart$name
[16:21:30.812]                             if (is.null(name)) 
[16:21:30.812]                               next
[16:21:30.812]                             if (!grepl(pattern, name)) 
[16:21:30.812]                               next
[16:21:30.812]                             invokeRestart(restart)
[16:21:30.812]                             muffled <- TRUE
[16:21:30.812]                             break
[16:21:30.812]                           }
[16:21:30.812]                         }
[16:21:30.812]                       }
[16:21:30.812]                       invisible(muffled)
[16:21:30.812]                     }
[16:21:30.812]                     muffleCondition(cond, pattern = "^muffle")
[16:21:30.812]                   }
[16:21:30.812]                 }
[16:21:30.812]             }
[16:21:30.812]         }))
[16:21:30.812]     }, error = function(ex) {
[16:21:30.812]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:30.812]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:30.812]                 ...future.rng), started = ...future.startTime, 
[16:21:30.812]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:30.812]             version = "1.8"), class = "FutureResult")
[16:21:30.812]     }, finally = {
[16:21:30.812]         if (!identical(...future.workdir, getwd())) 
[16:21:30.812]             setwd(...future.workdir)
[16:21:30.812]         {
[16:21:30.812]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:30.812]                 ...future.oldOptions$nwarnings <- NULL
[16:21:30.812]             }
[16:21:30.812]             base::options(...future.oldOptions)
[16:21:30.812]             if (.Platform$OS.type == "windows") {
[16:21:30.812]                 old_names <- names(...future.oldEnvVars)
[16:21:30.812]                 envs <- base::Sys.getenv()
[16:21:30.812]                 names <- names(envs)
[16:21:30.812]                 common <- intersect(names, old_names)
[16:21:30.812]                 added <- setdiff(names, old_names)
[16:21:30.812]                 removed <- setdiff(old_names, names)
[16:21:30.812]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:30.812]                   envs[common]]
[16:21:30.812]                 NAMES <- toupper(changed)
[16:21:30.812]                 args <- list()
[16:21:30.812]                 for (kk in seq_along(NAMES)) {
[16:21:30.812]                   name <- changed[[kk]]
[16:21:30.812]                   NAME <- NAMES[[kk]]
[16:21:30.812]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:30.812]                     next
[16:21:30.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:30.812]                 }
[16:21:30.812]                 NAMES <- toupper(added)
[16:21:30.812]                 for (kk in seq_along(NAMES)) {
[16:21:30.812]                   name <- added[[kk]]
[16:21:30.812]                   NAME <- NAMES[[kk]]
[16:21:30.812]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:30.812]                     next
[16:21:30.812]                   args[[name]] <- ""
[16:21:30.812]                 }
[16:21:30.812]                 NAMES <- toupper(removed)
[16:21:30.812]                 for (kk in seq_along(NAMES)) {
[16:21:30.812]                   name <- removed[[kk]]
[16:21:30.812]                   NAME <- NAMES[[kk]]
[16:21:30.812]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:30.812]                     next
[16:21:30.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:30.812]                 }
[16:21:30.812]                 if (length(args) > 0) 
[16:21:30.812]                   base::do.call(base::Sys.setenv, args = args)
[16:21:30.812]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:30.812]             }
[16:21:30.812]             else {
[16:21:30.812]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:30.812]             }
[16:21:30.812]             {
[16:21:30.812]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:30.812]                   0L) {
[16:21:30.812]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:30.812]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:30.812]                   base::options(opts)
[16:21:30.812]                 }
[16:21:30.812]                 {
[16:21:30.812]                   {
[16:21:30.812]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:30.812]                     NULL
[16:21:30.812]                   }
[16:21:30.812]                   options(future.plan = NULL)
[16:21:30.812]                   if (is.na(NA_character_)) 
[16:21:30.812]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:30.812]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:30.812]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:30.812]                     .init = FALSE)
[16:21:30.812]                 }
[16:21:30.812]             }
[16:21:30.812]         }
[16:21:30.812]     })
[16:21:30.812]     if (TRUE) {
[16:21:30.812]         base::sink(type = "output", split = FALSE)
[16:21:30.812]         if (TRUE) {
[16:21:30.812]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:30.812]         }
[16:21:30.812]         else {
[16:21:30.812]             ...future.result["stdout"] <- base::list(NULL)
[16:21:30.812]         }
[16:21:30.812]         base::close(...future.stdout)
[16:21:30.812]         ...future.stdout <- NULL
[16:21:30.812]     }
[16:21:30.812]     ...future.result$conditions <- ...future.conditions
[16:21:30.812]     ...future.result$finished <- base::Sys.time()
[16:21:30.812]     ...future.result
[16:21:30.812] }
[16:21:30.815] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[16:21:30.815] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[16:21:30.815] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[16:21:30.815] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[16:21:30.816] MultisessionFuture started
[16:21:30.816] - Launch lazy future ... done
[16:21:30.816] run() for ‘MultisessionFuture’ ... done
[16:21:30.816] result() for ClusterFuture ...
[16:21:30.816] receiveMessageFromWorker() for ClusterFuture ...
[16:21:30.816] - Validating connection of MultisessionFuture
[16:21:30.872] - received message: FutureResult
[16:21:30.872] - Received FutureResult
[16:21:30.872] - Erased future from FutureRegistry
[16:21:30.872] result() for ClusterFuture ...
[16:21:30.872] - result already collected: FutureResult
[16:21:30.872] result() for ClusterFuture ... done
[16:21:30.873] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:30.873] result() for ClusterFuture ... done
[16:21:30.873] result() for ClusterFuture ...
[16:21:30.873] - result already collected: FutureResult
[16:21:30.873] result() for ClusterFuture ... done
- plan(list('multisession', 'multicore')) ... DONE
- plan(list('multisession', 'multisession')) ...
[16:21:30.873] plan(): Setting new future strategy stack:
[16:21:30.873] List of future strategies:
[16:21:30.873] 1. multisession:
[16:21:30.873]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:30.873]    - tweaked: FALSE
[16:21:30.873]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:30.873] 2. multisession:
[16:21:30.873]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:30.873]    - tweaked: FALSE
[16:21:30.873]    - call: plan(list(a = strategy1, b = strategy2))
[16:21:30.874] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:21:30.874] multisession:
[16:21:30.874] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:30.874] - tweaked: FALSE
[16:21:30.874] - call: plan(list(a = strategy1, b = strategy2))
[16:21:30.878] getGlobalsAndPackages() ...
[16:21:30.878] Not searching for globals
[16:21:30.878] - globals: [0] <none>
[16:21:30.878] getGlobalsAndPackages() ... DONE
[16:21:30.879] [local output] makeClusterPSOCK() ...
[16:21:30.882] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:21:30.883] [local output] Base port: 11488
[16:21:30.883] [local output] Getting setup options for 2 cluster nodes ...
[16:21:30.883] [local output]  - Node 1 of 2 ...
[16:21:30.883] [local output] localMachine=TRUE => revtunnel=FALSE

[16:21:30.884] [local output] Rscript port: 11488

[16:21:30.884] [local output]  - Node 2 of 2 ...
[16:21:30.884] [local output] localMachine=TRUE => revtunnel=FALSE

[16:21:30.885] [local output] Rscript port: 11488

[16:21:30.885] [local output] Getting setup options for 2 cluster nodes ... done
[16:21:30.885] [local output]  - Parallel setup requested for some PSOCK nodes
[16:21:30.886] [local output] Setting up PSOCK nodes in parallel
[16:21:30.886] List of 36
[16:21:30.886]  $ worker          : chr "localhost"
[16:21:30.886]   ..- attr(*, "localhost")= logi TRUE
[16:21:30.886]  $ master          : chr "localhost"
[16:21:30.886]  $ port            : int 11488
[16:21:30.886]  $ connectTimeout  : num 120
[16:21:30.886]  $ timeout         : num 2592000
[16:21:30.886]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:21:30.886]  $ homogeneous     : logi TRUE
[16:21:30.886]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:21:30.886]  $ rscript_envs    : NULL
[16:21:30.886]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:21:30.886]  $ rscript_startup : NULL
[16:21:30.886]  $ rscript_sh      : chr "sh"
[16:21:30.886]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:21:30.886]  $ methods         : logi TRUE
[16:21:30.886]  $ socketOptions   : chr "no-delay"
[16:21:30.886]  $ useXDR          : logi FALSE
[16:21:30.886]  $ outfile         : chr "/dev/null"
[16:21:30.886]  $ renice          : int NA
[16:21:30.886]  $ rshcmd          : NULL
[16:21:30.886]  $ user            : chr(0) 
[16:21:30.886]  $ revtunnel       : logi FALSE
[16:21:30.886]  $ rshlogfile      : NULL
[16:21:30.886]  $ rshopts         : chr(0) 
[16:21:30.886]  $ rank            : int 1
[16:21:30.886]  $ manual          : logi FALSE
[16:21:30.886]  $ dryrun          : logi FALSE
[16:21:30.886]  $ quiet           : logi FALSE
[16:21:30.886]  $ setup_strategy  : chr "parallel"
[16:21:30.886]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:21:30.886]  $ pidfile         : chr "/tmp/RtmpnVB70K/worker.rank=1.parallelly.parent=86806.153164fc2f12d.pid"
[16:21:30.886]  $ rshcmd_label    : NULL
[16:21:30.886]  $ rsh_call        : NULL
[16:21:30.886]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:21:30.886]  $ localMachine    : logi TRUE
[16:21:30.886]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:21:30.886]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:21:30.886]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:21:30.886]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:21:30.886]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:21:30.886]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:21:30.886]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:21:30.886]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:21:30.886]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:21:30.886]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:21:30.886]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:21:30.886]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:21:30.886]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:21:30.886]  $ arguments       :List of 28
[16:21:30.886]   ..$ worker          : chr "localhost"
[16:21:30.886]   ..$ master          : NULL
[16:21:30.886]   ..$ port            : int 11488
[16:21:30.886]   ..$ connectTimeout  : num 120
[16:21:30.886]   ..$ timeout         : num 2592000
[16:21:30.886]   ..$ rscript         : NULL
[16:21:30.886]   ..$ homogeneous     : NULL
[16:21:30.886]   ..$ rscript_args    : NULL
[16:21:30.886]   ..$ rscript_envs    : NULL
[16:21:30.886]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:21:30.886]   ..$ rscript_startup : NULL
[16:21:30.886]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:21:30.886]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:21:30.886]   ..$ methods         : logi TRUE
[16:21:30.886]   ..$ socketOptions   : chr "no-delay"
[16:21:30.886]   ..$ useXDR          : logi FALSE
[16:21:30.886]   ..$ outfile         : chr "/dev/null"
[16:21:30.886]   ..$ renice          : int NA
[16:21:30.886]   ..$ rshcmd          : NULL
[16:21:30.886]   ..$ user            : NULL
[16:21:30.886]   ..$ revtunnel       : logi NA
[16:21:30.886]   ..$ rshlogfile      : NULL
[16:21:30.886]   ..$ rshopts         : NULL
[16:21:30.886]   ..$ rank            : int 1
[16:21:30.886]   ..$ manual          : logi FALSE
[16:21:30.886]   ..$ dryrun          : logi FALSE
[16:21:30.886]   ..$ quiet           : logi FALSE
[16:21:30.886]   ..$ setup_strategy  : chr "parallel"
[16:21:30.886]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:21:30.907] [local output] System call to launch all workers:
[16:21:30.907] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpnVB70K/worker.rank=1.parallelly.parent=86806.153164fc2f12d.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11488 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:21:30.907] [local output] Starting PSOCK main server
[16:21:30.909] [local output] Workers launched
[16:21:30.909] [local output] Waiting for workers to connect back
[16:21:30.909]  - [local output] 0 workers out of 2 ready
[16:21:31.184]  - [local output] 0 workers out of 2 ready
[16:21:31.184]  - [local output] 1 workers out of 2 ready
[16:21:31.186]  - [local output] 1 workers out of 2 ready
[16:21:31.186]  - [local output] 2 workers out of 2 ready
[16:21:31.186] [local output] Launching of workers completed
[16:21:31.186] [local output] Collecting session information from workers
[16:21:31.187] [local output]  - Worker #1 of 2
[16:21:31.188] [local output]  - Worker #2 of 2
[16:21:31.188] [local output] makeClusterPSOCK() ... done
[16:21:31.198] Packages needed by the future expression (n = 0): <none>
[16:21:31.199] Packages needed by future strategies (n = 1): ‘future’
[16:21:31.199] {
[16:21:31.199]     {
[16:21:31.199]         {
[16:21:31.199]             ...future.startTime <- base::Sys.time()
[16:21:31.199]             {
[16:21:31.199]                 {
[16:21:31.199]                   {
[16:21:31.199]                     {
[16:21:31.199]                       {
[16:21:31.199]                         base::local({
[16:21:31.199]                           has_future <- base::requireNamespace("future", 
[16:21:31.199]                             quietly = TRUE)
[16:21:31.199]                           if (has_future) {
[16:21:31.199]                             ns <- base::getNamespace("future")
[16:21:31.199]                             version <- ns[[".package"]][["version"]]
[16:21:31.199]                             if (is.null(version)) 
[16:21:31.199]                               version <- utils::packageVersion("future")
[16:21:31.199]                           }
[16:21:31.199]                           else {
[16:21:31.199]                             version <- NULL
[16:21:31.199]                           }
[16:21:31.199]                           if (!has_future || version < "1.8.0") {
[16:21:31.199]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:31.199]                               "", base::R.version$version.string), 
[16:21:31.199]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:31.199]                                 base::R.version$platform, 8 * 
[16:21:31.199]                                   base::.Machine$sizeof.pointer), 
[16:21:31.199]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:31.199]                                 "release", "version")], collapse = " "), 
[16:21:31.199]                               hostname = base::Sys.info()[["nodename"]])
[16:21:31.199]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:31.199]                               info)
[16:21:31.199]                             info <- base::paste(info, collapse = "; ")
[16:21:31.199]                             if (!has_future) {
[16:21:31.199]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:31.199]                                 info)
[16:21:31.199]                             }
[16:21:31.199]                             else {
[16:21:31.199]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:31.199]                                 info, version)
[16:21:31.199]                             }
[16:21:31.199]                             base::stop(msg)
[16:21:31.199]                           }
[16:21:31.199]                         })
[16:21:31.199]                       }
[16:21:31.199]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:31.199]                       base::options(mc.cores = 1L)
[16:21:31.199]                     }
[16:21:31.199]                     base::local({
[16:21:31.199]                       for (pkg in "future") {
[16:21:31.199]                         base::loadNamespace(pkg)
[16:21:31.199]                         base::library(pkg, character.only = TRUE)
[16:21:31.199]                       }
[16:21:31.199]                     })
[16:21:31.199]                   }
[16:21:31.199]                   ...future.strategy.old <- future::plan("list")
[16:21:31.199]                   options(future.plan = NULL)
[16:21:31.199]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:31.199]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:21:31.199]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:21:31.199]                     envir = parent.frame()) 
[16:21:31.199]                   {
[16:21:31.199]                     if (is.function(workers)) 
[16:21:31.199]                       workers <- workers()
[16:21:31.199]                     workers <- structure(as.integer(workers), 
[16:21:31.199]                       class = class(workers))
[16:21:31.199]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:21:31.199]                       workers >= 1)
[16:21:31.199]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:21:31.199]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:21:31.199]                     }
[16:21:31.199]                     future <- MultisessionFuture(..., workers = workers, 
[16:21:31.199]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:21:31.199]                       envir = envir)
[16:21:31.199]                     if (!future$lazy) 
[16:21:31.199]                       future <- run(future)
[16:21:31.199]                     invisible(future)
[16:21:31.199]                   }), .cleanup = FALSE, .init = FALSE)
[16:21:31.199]                 }
[16:21:31.199]                 ...future.workdir <- getwd()
[16:21:31.199]             }
[16:21:31.199]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:31.199]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:31.199]         }
[16:21:31.199]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:31.199]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:31.199]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:31.199]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:31.199]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:31.199]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:31.199]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:31.199]             base::names(...future.oldOptions))
[16:21:31.199]     }
[16:21:31.199]     if (FALSE) {
[16:21:31.199]     }
[16:21:31.199]     else {
[16:21:31.199]         if (TRUE) {
[16:21:31.199]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:31.199]                 open = "w")
[16:21:31.199]         }
[16:21:31.199]         else {
[16:21:31.199]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:31.199]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:31.199]         }
[16:21:31.199]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:31.199]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:31.199]             base::sink(type = "output", split = FALSE)
[16:21:31.199]             base::close(...future.stdout)
[16:21:31.199]         }, add = TRUE)
[16:21:31.199]     }
[16:21:31.199]     ...future.frame <- base::sys.nframe()
[16:21:31.199]     ...future.conditions <- base::list()
[16:21:31.199]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:31.199]     if (FALSE) {
[16:21:31.199]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:31.199]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:31.199]     }
[16:21:31.199]     ...future.result <- base::tryCatch({
[16:21:31.199]         base::withCallingHandlers({
[16:21:31.199]             ...future.value <- base::withVisible(base::local({
[16:21:31.199]                 ...future.makeSendCondition <- base::local({
[16:21:31.199]                   sendCondition <- NULL
[16:21:31.199]                   function(frame = 1L) {
[16:21:31.199]                     if (is.function(sendCondition)) 
[16:21:31.199]                       return(sendCondition)
[16:21:31.199]                     ns <- getNamespace("parallel")
[16:21:31.199]                     if (exists("sendData", mode = "function", 
[16:21:31.199]                       envir = ns)) {
[16:21:31.199]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:31.199]                         envir = ns)
[16:21:31.199]                       envir <- sys.frame(frame)
[16:21:31.199]                       master <- NULL
[16:21:31.199]                       while (!identical(envir, .GlobalEnv) && 
[16:21:31.199]                         !identical(envir, emptyenv())) {
[16:21:31.199]                         if (exists("master", mode = "list", envir = envir, 
[16:21:31.199]                           inherits = FALSE)) {
[16:21:31.199]                           master <- get("master", mode = "list", 
[16:21:31.199]                             envir = envir, inherits = FALSE)
[16:21:31.199]                           if (inherits(master, c("SOCKnode", 
[16:21:31.199]                             "SOCK0node"))) {
[16:21:31.199]                             sendCondition <<- function(cond) {
[16:21:31.199]                               data <- list(type = "VALUE", value = cond, 
[16:21:31.199]                                 success = TRUE)
[16:21:31.199]                               parallel_sendData(master, data)
[16:21:31.199]                             }
[16:21:31.199]                             return(sendCondition)
[16:21:31.199]                           }
[16:21:31.199]                         }
[16:21:31.199]                         frame <- frame + 1L
[16:21:31.199]                         envir <- sys.frame(frame)
[16:21:31.199]                       }
[16:21:31.199]                     }
[16:21:31.199]                     sendCondition <<- function(cond) NULL
[16:21:31.199]                   }
[16:21:31.199]                 })
[16:21:31.199]                 withCallingHandlers({
[16:21:31.199]                   NA
[16:21:31.199]                 }, immediateCondition = function(cond) {
[16:21:31.199]                   sendCondition <- ...future.makeSendCondition()
[16:21:31.199]                   sendCondition(cond)
[16:21:31.199]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:31.199]                   {
[16:21:31.199]                     inherits <- base::inherits
[16:21:31.199]                     invokeRestart <- base::invokeRestart
[16:21:31.199]                     is.null <- base::is.null
[16:21:31.199]                     muffled <- FALSE
[16:21:31.199]                     if (inherits(cond, "message")) {
[16:21:31.199]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:31.199]                       if (muffled) 
[16:21:31.199]                         invokeRestart("muffleMessage")
[16:21:31.199]                     }
[16:21:31.199]                     else if (inherits(cond, "warning")) {
[16:21:31.199]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:31.199]                       if (muffled) 
[16:21:31.199]                         invokeRestart("muffleWarning")
[16:21:31.199]                     }
[16:21:31.199]                     else if (inherits(cond, "condition")) {
[16:21:31.199]                       if (!is.null(pattern)) {
[16:21:31.199]                         computeRestarts <- base::computeRestarts
[16:21:31.199]                         grepl <- base::grepl
[16:21:31.199]                         restarts <- computeRestarts(cond)
[16:21:31.199]                         for (restart in restarts) {
[16:21:31.199]                           name <- restart$name
[16:21:31.199]                           if (is.null(name)) 
[16:21:31.199]                             next
[16:21:31.199]                           if (!grepl(pattern, name)) 
[16:21:31.199]                             next
[16:21:31.199]                           invokeRestart(restart)
[16:21:31.199]                           muffled <- TRUE
[16:21:31.199]                           break
[16:21:31.199]                         }
[16:21:31.199]                       }
[16:21:31.199]                     }
[16:21:31.199]                     invisible(muffled)
[16:21:31.199]                   }
[16:21:31.199]                   muffleCondition(cond)
[16:21:31.199]                 })
[16:21:31.199]             }))
[16:21:31.199]             future::FutureResult(value = ...future.value$value, 
[16:21:31.199]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:31.199]                   ...future.rng), globalenv = if (FALSE) 
[16:21:31.199]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:31.199]                     ...future.globalenv.names))
[16:21:31.199]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:31.199]         }, condition = base::local({
[16:21:31.199]             c <- base::c
[16:21:31.199]             inherits <- base::inherits
[16:21:31.199]             invokeRestart <- base::invokeRestart
[16:21:31.199]             length <- base::length
[16:21:31.199]             list <- base::list
[16:21:31.199]             seq.int <- base::seq.int
[16:21:31.199]             signalCondition <- base::signalCondition
[16:21:31.199]             sys.calls <- base::sys.calls
[16:21:31.199]             `[[` <- base::`[[`
[16:21:31.199]             `+` <- base::`+`
[16:21:31.199]             `<<-` <- base::`<<-`
[16:21:31.199]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:31.199]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:31.199]                   3L)]
[16:21:31.199]             }
[16:21:31.199]             function(cond) {
[16:21:31.199]                 is_error <- inherits(cond, "error")
[16:21:31.199]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:31.199]                   NULL)
[16:21:31.199]                 if (is_error) {
[16:21:31.199]                   sessionInformation <- function() {
[16:21:31.199]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:31.199]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:31.199]                       search = base::search(), system = base::Sys.info())
[16:21:31.199]                   }
[16:21:31.199]                   ...future.conditions[[length(...future.conditions) + 
[16:21:31.199]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:31.199]                     cond$call), session = sessionInformation(), 
[16:21:31.199]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:31.199]                   signalCondition(cond)
[16:21:31.199]                 }
[16:21:31.199]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:31.199]                 "immediateCondition"))) {
[16:21:31.199]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:31.199]                   ...future.conditions[[length(...future.conditions) + 
[16:21:31.199]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:31.199]                   if (TRUE && !signal) {
[16:21:31.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:31.199]                     {
[16:21:31.199]                       inherits <- base::inherits
[16:21:31.199]                       invokeRestart <- base::invokeRestart
[16:21:31.199]                       is.null <- base::is.null
[16:21:31.199]                       muffled <- FALSE
[16:21:31.199]                       if (inherits(cond, "message")) {
[16:21:31.199]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:31.199]                         if (muffled) 
[16:21:31.199]                           invokeRestart("muffleMessage")
[16:21:31.199]                       }
[16:21:31.199]                       else if (inherits(cond, "warning")) {
[16:21:31.199]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:31.199]                         if (muffled) 
[16:21:31.199]                           invokeRestart("muffleWarning")
[16:21:31.199]                       }
[16:21:31.199]                       else if (inherits(cond, "condition")) {
[16:21:31.199]                         if (!is.null(pattern)) {
[16:21:31.199]                           computeRestarts <- base::computeRestarts
[16:21:31.199]                           grepl <- base::grepl
[16:21:31.199]                           restarts <- computeRestarts(cond)
[16:21:31.199]                           for (restart in restarts) {
[16:21:31.199]                             name <- restart$name
[16:21:31.199]                             if (is.null(name)) 
[16:21:31.199]                               next
[16:21:31.199]                             if (!grepl(pattern, name)) 
[16:21:31.199]                               next
[16:21:31.199]                             invokeRestart(restart)
[16:21:31.199]                             muffled <- TRUE
[16:21:31.199]                             break
[16:21:31.199]                           }
[16:21:31.199]                         }
[16:21:31.199]                       }
[16:21:31.199]                       invisible(muffled)
[16:21:31.199]                     }
[16:21:31.199]                     muffleCondition(cond, pattern = "^muffle")
[16:21:31.199]                   }
[16:21:31.199]                 }
[16:21:31.199]                 else {
[16:21:31.199]                   if (TRUE) {
[16:21:31.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:31.199]                     {
[16:21:31.199]                       inherits <- base::inherits
[16:21:31.199]                       invokeRestart <- base::invokeRestart
[16:21:31.199]                       is.null <- base::is.null
[16:21:31.199]                       muffled <- FALSE
[16:21:31.199]                       if (inherits(cond, "message")) {
[16:21:31.199]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:31.199]                         if (muffled) 
[16:21:31.199]                           invokeRestart("muffleMessage")
[16:21:31.199]                       }
[16:21:31.199]                       else if (inherits(cond, "warning")) {
[16:21:31.199]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:31.199]                         if (muffled) 
[16:21:31.199]                           invokeRestart("muffleWarning")
[16:21:31.199]                       }
[16:21:31.199]                       else if (inherits(cond, "condition")) {
[16:21:31.199]                         if (!is.null(pattern)) {
[16:21:31.199]                           computeRestarts <- base::computeRestarts
[16:21:31.199]                           grepl <- base::grepl
[16:21:31.199]                           restarts <- computeRestarts(cond)
[16:21:31.199]                           for (restart in restarts) {
[16:21:31.199]                             name <- restart$name
[16:21:31.199]                             if (is.null(name)) 
[16:21:31.199]                               next
[16:21:31.199]                             if (!grepl(pattern, name)) 
[16:21:31.199]                               next
[16:21:31.199]                             invokeRestart(restart)
[16:21:31.199]                             muffled <- TRUE
[16:21:31.199]                             break
[16:21:31.199]                           }
[16:21:31.199]                         }
[16:21:31.199]                       }
[16:21:31.199]                       invisible(muffled)
[16:21:31.199]                     }
[16:21:31.199]                     muffleCondition(cond, pattern = "^muffle")
[16:21:31.199]                   }
[16:21:31.199]                 }
[16:21:31.199]             }
[16:21:31.199]         }))
[16:21:31.199]     }, error = function(ex) {
[16:21:31.199]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:31.199]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:31.199]                 ...future.rng), started = ...future.startTime, 
[16:21:31.199]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:31.199]             version = "1.8"), class = "FutureResult")
[16:21:31.199]     }, finally = {
[16:21:31.199]         if (!identical(...future.workdir, getwd())) 
[16:21:31.199]             setwd(...future.workdir)
[16:21:31.199]         {
[16:21:31.199]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:31.199]                 ...future.oldOptions$nwarnings <- NULL
[16:21:31.199]             }
[16:21:31.199]             base::options(...future.oldOptions)
[16:21:31.199]             if (.Platform$OS.type == "windows") {
[16:21:31.199]                 old_names <- names(...future.oldEnvVars)
[16:21:31.199]                 envs <- base::Sys.getenv()
[16:21:31.199]                 names <- names(envs)
[16:21:31.199]                 common <- intersect(names, old_names)
[16:21:31.199]                 added <- setdiff(names, old_names)
[16:21:31.199]                 removed <- setdiff(old_names, names)
[16:21:31.199]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:31.199]                   envs[common]]
[16:21:31.199]                 NAMES <- toupper(changed)
[16:21:31.199]                 args <- list()
[16:21:31.199]                 for (kk in seq_along(NAMES)) {
[16:21:31.199]                   name <- changed[[kk]]
[16:21:31.199]                   NAME <- NAMES[[kk]]
[16:21:31.199]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:31.199]                     next
[16:21:31.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:31.199]                 }
[16:21:31.199]                 NAMES <- toupper(added)
[16:21:31.199]                 for (kk in seq_along(NAMES)) {
[16:21:31.199]                   name <- added[[kk]]
[16:21:31.199]                   NAME <- NAMES[[kk]]
[16:21:31.199]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:31.199]                     next
[16:21:31.199]                   args[[name]] <- ""
[16:21:31.199]                 }
[16:21:31.199]                 NAMES <- toupper(removed)
[16:21:31.199]                 for (kk in seq_along(NAMES)) {
[16:21:31.199]                   name <- removed[[kk]]
[16:21:31.199]                   NAME <- NAMES[[kk]]
[16:21:31.199]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:31.199]                     next
[16:21:31.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:31.199]                 }
[16:21:31.199]                 if (length(args) > 0) 
[16:21:31.199]                   base::do.call(base::Sys.setenv, args = args)
[16:21:31.199]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:31.199]             }
[16:21:31.199]             else {
[16:21:31.199]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:31.199]             }
[16:21:31.199]             {
[16:21:31.199]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:31.199]                   0L) {
[16:21:31.199]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:31.199]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:31.199]                   base::options(opts)
[16:21:31.199]                 }
[16:21:31.199]                 {
[16:21:31.199]                   {
[16:21:31.199]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:31.199]                     NULL
[16:21:31.199]                   }
[16:21:31.199]                   options(future.plan = NULL)
[16:21:31.199]                   if (is.na(NA_character_)) 
[16:21:31.199]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:31.199]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:31.199]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:31.199]                     .init = FALSE)
[16:21:31.199]                 }
[16:21:31.199]             }
[16:21:31.199]         }
[16:21:31.199]     })
[16:21:31.199]     if (TRUE) {
[16:21:31.199]         base::sink(type = "output", split = FALSE)
[16:21:31.199]         if (TRUE) {
[16:21:31.199]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:31.199]         }
[16:21:31.199]         else {
[16:21:31.199]             ...future.result["stdout"] <- base::list(NULL)
[16:21:31.199]         }
[16:21:31.199]         base::close(...future.stdout)
[16:21:31.199]         ...future.stdout <- NULL
[16:21:31.199]     }
[16:21:31.199]     ...future.result$conditions <- ...future.conditions
[16:21:31.199]     ...future.result$finished <- base::Sys.time()
[16:21:31.199]     ...future.result
[16:21:31.199] }
[16:21:31.255] MultisessionFuture started
[16:21:31.255] result() for ClusterFuture ...
[16:21:31.256] receiveMessageFromWorker() for ClusterFuture ...
[16:21:31.256] - Validating connection of MultisessionFuture
[16:21:31.307] - received message: FutureResult
[16:21:31.307] - Received FutureResult
[16:21:31.307] - Erased future from FutureRegistry
[16:21:31.307] result() for ClusterFuture ...
[16:21:31.307] - result already collected: FutureResult
[16:21:31.307] result() for ClusterFuture ... done
[16:21:31.308] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:31.308] result() for ClusterFuture ... done
[16:21:31.308] result() for ClusterFuture ...
[16:21:31.308] - result already collected: FutureResult
[16:21:31.308] result() for ClusterFuture ... done
[16:21:31.308] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:21:31.312] plan(): nbrOfWorkers() = 2
[16:21:31.312] getGlobalsAndPackages() ...
[16:21:31.312] Searching for globals...
[16:21:31.328] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:21:31.328] Searching for globals ... DONE
[16:21:31.328] Resolving globals: FALSE
[16:21:31.329] The total size of the 2 globals is 88.27 KiB (90384 bytes)
[16:21:31.330] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 88.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (88.15 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:21:31.330] - globals: [2] ‘nested’, ‘strategy2’
[16:21:31.330] - packages: [1] ‘future’
[16:21:31.330] getGlobalsAndPackages() ... DONE
[16:21:31.330] run() for ‘Future’ ...
[16:21:31.330] - state: ‘created’
[16:21:31.331] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:31.344] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:31.344] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:31.344]   - Field: ‘node’
[16:21:31.345]   - Field: ‘label’
[16:21:31.345]   - Field: ‘local’
[16:21:31.345]   - Field: ‘owner’
[16:21:31.345]   - Field: ‘envir’
[16:21:31.345]   - Field: ‘workers’
[16:21:31.345]   - Field: ‘packages’
[16:21:31.345]   - Field: ‘gc’
[16:21:31.345]   - Field: ‘conditions’
[16:21:31.345]   - Field: ‘persistent’
[16:21:31.345]   - Field: ‘expr’
[16:21:31.345]   - Field: ‘uuid’
[16:21:31.346]   - Field: ‘seed’
[16:21:31.346]   - Field: ‘version’
[16:21:31.346]   - Field: ‘result’
[16:21:31.346]   - Field: ‘asynchronous’
[16:21:31.346]   - Field: ‘calls’
[16:21:31.346]   - Field: ‘globals’
[16:21:31.346]   - Field: ‘stdout’
[16:21:31.346]   - Field: ‘earlySignal’
[16:21:31.346]   - Field: ‘lazy’
[16:21:31.346]   - Field: ‘state’
[16:21:31.346] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:31.347] - Launch lazy future ...
[16:21:31.347] Packages needed by the future expression (n = 1): ‘future’
[16:21:31.347] Packages needed by future strategies (n = 1): ‘future’
[16:21:31.348] {
[16:21:31.348]     {
[16:21:31.348]         {
[16:21:31.348]             ...future.startTime <- base::Sys.time()
[16:21:31.348]             {
[16:21:31.348]                 {
[16:21:31.348]                   {
[16:21:31.348]                     {
[16:21:31.348]                       {
[16:21:31.348]                         base::local({
[16:21:31.348]                           has_future <- base::requireNamespace("future", 
[16:21:31.348]                             quietly = TRUE)
[16:21:31.348]                           if (has_future) {
[16:21:31.348]                             ns <- base::getNamespace("future")
[16:21:31.348]                             version <- ns[[".package"]][["version"]]
[16:21:31.348]                             if (is.null(version)) 
[16:21:31.348]                               version <- utils::packageVersion("future")
[16:21:31.348]                           }
[16:21:31.348]                           else {
[16:21:31.348]                             version <- NULL
[16:21:31.348]                           }
[16:21:31.348]                           if (!has_future || version < "1.8.0") {
[16:21:31.348]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:31.348]                               "", base::R.version$version.string), 
[16:21:31.348]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:31.348]                                 base::R.version$platform, 8 * 
[16:21:31.348]                                   base::.Machine$sizeof.pointer), 
[16:21:31.348]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:31.348]                                 "release", "version")], collapse = " "), 
[16:21:31.348]                               hostname = base::Sys.info()[["nodename"]])
[16:21:31.348]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:31.348]                               info)
[16:21:31.348]                             info <- base::paste(info, collapse = "; ")
[16:21:31.348]                             if (!has_future) {
[16:21:31.348]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:31.348]                                 info)
[16:21:31.348]                             }
[16:21:31.348]                             else {
[16:21:31.348]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:31.348]                                 info, version)
[16:21:31.348]                             }
[16:21:31.348]                             base::stop(msg)
[16:21:31.348]                           }
[16:21:31.348]                         })
[16:21:31.348]                       }
[16:21:31.348]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:31.348]                       base::options(mc.cores = 1L)
[16:21:31.348]                     }
[16:21:31.348]                     base::local({
[16:21:31.348]                       for (pkg in "future") {
[16:21:31.348]                         base::loadNamespace(pkg)
[16:21:31.348]                         base::library(pkg, character.only = TRUE)
[16:21:31.348]                       }
[16:21:31.348]                     })
[16:21:31.348]                   }
[16:21:31.348]                   ...future.strategy.old <- future::plan("list")
[16:21:31.348]                   options(future.plan = NULL)
[16:21:31.348]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:31.348]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:21:31.348]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:21:31.348]                     envir = parent.frame()) 
[16:21:31.348]                   {
[16:21:31.348]                     if (is.function(workers)) 
[16:21:31.348]                       workers <- workers()
[16:21:31.348]                     workers <- structure(as.integer(workers), 
[16:21:31.348]                       class = class(workers))
[16:21:31.348]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:21:31.348]                       workers >= 1)
[16:21:31.348]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:21:31.348]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:21:31.348]                     }
[16:21:31.348]                     future <- MultisessionFuture(..., workers = workers, 
[16:21:31.348]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:21:31.348]                       envir = envir)
[16:21:31.348]                     if (!future$lazy) 
[16:21:31.348]                       future <- run(future)
[16:21:31.348]                     invisible(future)
[16:21:31.348]                   }), .cleanup = FALSE, .init = FALSE)
[16:21:31.348]                 }
[16:21:31.348]                 ...future.workdir <- getwd()
[16:21:31.348]             }
[16:21:31.348]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:31.348]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:31.348]         }
[16:21:31.348]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:31.348]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:31.348]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:31.348]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:31.348]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:31.348]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:31.348]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:31.348]             base::names(...future.oldOptions))
[16:21:31.348]     }
[16:21:31.348]     if (FALSE) {
[16:21:31.348]     }
[16:21:31.348]     else {
[16:21:31.348]         if (TRUE) {
[16:21:31.348]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:31.348]                 open = "w")
[16:21:31.348]         }
[16:21:31.348]         else {
[16:21:31.348]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:31.348]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:31.348]         }
[16:21:31.348]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:31.348]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:31.348]             base::sink(type = "output", split = FALSE)
[16:21:31.348]             base::close(...future.stdout)
[16:21:31.348]         }, add = TRUE)
[16:21:31.348]     }
[16:21:31.348]     ...future.frame <- base::sys.nframe()
[16:21:31.348]     ...future.conditions <- base::list()
[16:21:31.348]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:31.348]     if (FALSE) {
[16:21:31.348]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:31.348]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:31.348]     }
[16:21:31.348]     ...future.result <- base::tryCatch({
[16:21:31.348]         base::withCallingHandlers({
[16:21:31.348]             ...future.value <- base::withVisible(base::local({
[16:21:31.348]                 ...future.makeSendCondition <- base::local({
[16:21:31.348]                   sendCondition <- NULL
[16:21:31.348]                   function(frame = 1L) {
[16:21:31.348]                     if (is.function(sendCondition)) 
[16:21:31.348]                       return(sendCondition)
[16:21:31.348]                     ns <- getNamespace("parallel")
[16:21:31.348]                     if (exists("sendData", mode = "function", 
[16:21:31.348]                       envir = ns)) {
[16:21:31.348]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:31.348]                         envir = ns)
[16:21:31.348]                       envir <- sys.frame(frame)
[16:21:31.348]                       master <- NULL
[16:21:31.348]                       while (!identical(envir, .GlobalEnv) && 
[16:21:31.348]                         !identical(envir, emptyenv())) {
[16:21:31.348]                         if (exists("master", mode = "list", envir = envir, 
[16:21:31.348]                           inherits = FALSE)) {
[16:21:31.348]                           master <- get("master", mode = "list", 
[16:21:31.348]                             envir = envir, inherits = FALSE)
[16:21:31.348]                           if (inherits(master, c("SOCKnode", 
[16:21:31.348]                             "SOCK0node"))) {
[16:21:31.348]                             sendCondition <<- function(cond) {
[16:21:31.348]                               data <- list(type = "VALUE", value = cond, 
[16:21:31.348]                                 success = TRUE)
[16:21:31.348]                               parallel_sendData(master, data)
[16:21:31.348]                             }
[16:21:31.348]                             return(sendCondition)
[16:21:31.348]                           }
[16:21:31.348]                         }
[16:21:31.348]                         frame <- frame + 1L
[16:21:31.348]                         envir <- sys.frame(frame)
[16:21:31.348]                       }
[16:21:31.348]                     }
[16:21:31.348]                     sendCondition <<- function(cond) NULL
[16:21:31.348]                   }
[16:21:31.348]                 })
[16:21:31.348]                 withCallingHandlers({
[16:21:31.348]                   {
[16:21:31.348]                     a <- 1L
[16:21:31.348]                     plan_a <- unclass(future::plan("list"))
[16:21:31.348]                     nested_a <- nested[-1]
[16:21:31.348]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:21:31.348]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:21:31.348]                       strategy2))
[16:21:31.348]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:21:31.348]                       "init") <- NULL
[16:21:31.348]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:21:31.348]                       "init") <- NULL
[16:21:31.348]                     stopifnot(all.equal(plan_a, nested_a))
[16:21:31.348]                     y %<-% {
[16:21:31.348]                       b <- 2L
[16:21:31.348]                       plan_b <- future::plan("list")
[16:21:31.348]                       nested_b <- nested_a[-1]
[16:21:31.348]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:21:31.348]                         1L, inherits(plan_b[[1]], "future"), 
[16:21:31.348]                         inherits(future::plan("next"), "sequential"))
[16:21:31.348]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:21:31.348]                         b = b, nested_b = nested_b, plan_b = plan_b)
[16:21:31.348]                     }
[16:21:31.348]                     y
[16:21:31.348]                   }
[16:21:31.348]                 }, immediateCondition = function(cond) {
[16:21:31.348]                   sendCondition <- ...future.makeSendCondition()
[16:21:31.348]                   sendCondition(cond)
[16:21:31.348]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:31.348]                   {
[16:21:31.348]                     inherits <- base::inherits
[16:21:31.348]                     invokeRestart <- base::invokeRestart
[16:21:31.348]                     is.null <- base::is.null
[16:21:31.348]                     muffled <- FALSE
[16:21:31.348]                     if (inherits(cond, "message")) {
[16:21:31.348]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:31.348]                       if (muffled) 
[16:21:31.348]                         invokeRestart("muffleMessage")
[16:21:31.348]                     }
[16:21:31.348]                     else if (inherits(cond, "warning")) {
[16:21:31.348]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:31.348]                       if (muffled) 
[16:21:31.348]                         invokeRestart("muffleWarning")
[16:21:31.348]                     }
[16:21:31.348]                     else if (inherits(cond, "condition")) {
[16:21:31.348]                       if (!is.null(pattern)) {
[16:21:31.348]                         computeRestarts <- base::computeRestarts
[16:21:31.348]                         grepl <- base::grepl
[16:21:31.348]                         restarts <- computeRestarts(cond)
[16:21:31.348]                         for (restart in restarts) {
[16:21:31.348]                           name <- restart$name
[16:21:31.348]                           if (is.null(name)) 
[16:21:31.348]                             next
[16:21:31.348]                           if (!grepl(pattern, name)) 
[16:21:31.348]                             next
[16:21:31.348]                           invokeRestart(restart)
[16:21:31.348]                           muffled <- TRUE
[16:21:31.348]                           break
[16:21:31.348]                         }
[16:21:31.348]                       }
[16:21:31.348]                     }
[16:21:31.348]                     invisible(muffled)
[16:21:31.348]                   }
[16:21:31.348]                   muffleCondition(cond)
[16:21:31.348]                 })
[16:21:31.348]             }))
[16:21:31.348]             future::FutureResult(value = ...future.value$value, 
[16:21:31.348]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:31.348]                   ...future.rng), globalenv = if (FALSE) 
[16:21:31.348]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:31.348]                     ...future.globalenv.names))
[16:21:31.348]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:31.348]         }, condition = base::local({
[16:21:31.348]             c <- base::c
[16:21:31.348]             inherits <- base::inherits
[16:21:31.348]             invokeRestart <- base::invokeRestart
[16:21:31.348]             length <- base::length
[16:21:31.348]             list <- base::list
[16:21:31.348]             seq.int <- base::seq.int
[16:21:31.348]             signalCondition <- base::signalCondition
[16:21:31.348]             sys.calls <- base::sys.calls
[16:21:31.348]             `[[` <- base::`[[`
[16:21:31.348]             `+` <- base::`+`
[16:21:31.348]             `<<-` <- base::`<<-`
[16:21:31.348]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:31.348]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:31.348]                   3L)]
[16:21:31.348]             }
[16:21:31.348]             function(cond) {
[16:21:31.348]                 is_error <- inherits(cond, "error")
[16:21:31.348]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:31.348]                   NULL)
[16:21:31.348]                 if (is_error) {
[16:21:31.348]                   sessionInformation <- function() {
[16:21:31.348]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:31.348]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:31.348]                       search = base::search(), system = base::Sys.info())
[16:21:31.348]                   }
[16:21:31.348]                   ...future.conditions[[length(...future.conditions) + 
[16:21:31.348]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:31.348]                     cond$call), session = sessionInformation(), 
[16:21:31.348]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:31.348]                   signalCondition(cond)
[16:21:31.348]                 }
[16:21:31.348]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:31.348]                 "immediateCondition"))) {
[16:21:31.348]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:31.348]                   ...future.conditions[[length(...future.conditions) + 
[16:21:31.348]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:31.348]                   if (TRUE && !signal) {
[16:21:31.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:31.348]                     {
[16:21:31.348]                       inherits <- base::inherits
[16:21:31.348]                       invokeRestart <- base::invokeRestart
[16:21:31.348]                       is.null <- base::is.null
[16:21:31.348]                       muffled <- FALSE
[16:21:31.348]                       if (inherits(cond, "message")) {
[16:21:31.348]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:31.348]                         if (muffled) 
[16:21:31.348]                           invokeRestart("muffleMessage")
[16:21:31.348]                       }
[16:21:31.348]                       else if (inherits(cond, "warning")) {
[16:21:31.348]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:31.348]                         if (muffled) 
[16:21:31.348]                           invokeRestart("muffleWarning")
[16:21:31.348]                       }
[16:21:31.348]                       else if (inherits(cond, "condition")) {
[16:21:31.348]                         if (!is.null(pattern)) {
[16:21:31.348]                           computeRestarts <- base::computeRestarts
[16:21:31.348]                           grepl <- base::grepl
[16:21:31.348]                           restarts <- computeRestarts(cond)
[16:21:31.348]                           for (restart in restarts) {
[16:21:31.348]                             name <- restart$name
[16:21:31.348]                             if (is.null(name)) 
[16:21:31.348]                               next
[16:21:31.348]                             if (!grepl(pattern, name)) 
[16:21:31.348]                               next
[16:21:31.348]                             invokeRestart(restart)
[16:21:31.348]                             muffled <- TRUE
[16:21:31.348]                             break
[16:21:31.348]                           }
[16:21:31.348]                         }
[16:21:31.348]                       }
[16:21:31.348]                       invisible(muffled)
[16:21:31.348]                     }
[16:21:31.348]                     muffleCondition(cond, pattern = "^muffle")
[16:21:31.348]                   }
[16:21:31.348]                 }
[16:21:31.348]                 else {
[16:21:31.348]                   if (TRUE) {
[16:21:31.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:31.348]                     {
[16:21:31.348]                       inherits <- base::inherits
[16:21:31.348]                       invokeRestart <- base::invokeRestart
[16:21:31.348]                       is.null <- base::is.null
[16:21:31.348]                       muffled <- FALSE
[16:21:31.348]                       if (inherits(cond, "message")) {
[16:21:31.348]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:31.348]                         if (muffled) 
[16:21:31.348]                           invokeRestart("muffleMessage")
[16:21:31.348]                       }
[16:21:31.348]                       else if (inherits(cond, "warning")) {
[16:21:31.348]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:31.348]                         if (muffled) 
[16:21:31.348]                           invokeRestart("muffleWarning")
[16:21:31.348]                       }
[16:21:31.348]                       else if (inherits(cond, "condition")) {
[16:21:31.348]                         if (!is.null(pattern)) {
[16:21:31.348]                           computeRestarts <- base::computeRestarts
[16:21:31.348]                           grepl <- base::grepl
[16:21:31.348]                           restarts <- computeRestarts(cond)
[16:21:31.348]                           for (restart in restarts) {
[16:21:31.348]                             name <- restart$name
[16:21:31.348]                             if (is.null(name)) 
[16:21:31.348]                               next
[16:21:31.348]                             if (!grepl(pattern, name)) 
[16:21:31.348]                               next
[16:21:31.348]                             invokeRestart(restart)
[16:21:31.348]                             muffled <- TRUE
[16:21:31.348]                             break
[16:21:31.348]                           }
[16:21:31.348]                         }
[16:21:31.348]                       }
[16:21:31.348]                       invisible(muffled)
[16:21:31.348]                     }
[16:21:31.348]                     muffleCondition(cond, pattern = "^muffle")
[16:21:31.348]                   }
[16:21:31.348]                 }
[16:21:31.348]             }
[16:21:31.348]         }))
[16:21:31.348]     }, error = function(ex) {
[16:21:31.348]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:31.348]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:31.348]                 ...future.rng), started = ...future.startTime, 
[16:21:31.348]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:31.348]             version = "1.8"), class = "FutureResult")
[16:21:31.348]     }, finally = {
[16:21:31.348]         if (!identical(...future.workdir, getwd())) 
[16:21:31.348]             setwd(...future.workdir)
[16:21:31.348]         {
[16:21:31.348]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:31.348]                 ...future.oldOptions$nwarnings <- NULL
[16:21:31.348]             }
[16:21:31.348]             base::options(...future.oldOptions)
[16:21:31.348]             if (.Platform$OS.type == "windows") {
[16:21:31.348]                 old_names <- names(...future.oldEnvVars)
[16:21:31.348]                 envs <- base::Sys.getenv()
[16:21:31.348]                 names <- names(envs)
[16:21:31.348]                 common <- intersect(names, old_names)
[16:21:31.348]                 added <- setdiff(names, old_names)
[16:21:31.348]                 removed <- setdiff(old_names, names)
[16:21:31.348]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:31.348]                   envs[common]]
[16:21:31.348]                 NAMES <- toupper(changed)
[16:21:31.348]                 args <- list()
[16:21:31.348]                 for (kk in seq_along(NAMES)) {
[16:21:31.348]                   name <- changed[[kk]]
[16:21:31.348]                   NAME <- NAMES[[kk]]
[16:21:31.348]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:31.348]                     next
[16:21:31.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:31.348]                 }
[16:21:31.348]                 NAMES <- toupper(added)
[16:21:31.348]                 for (kk in seq_along(NAMES)) {
[16:21:31.348]                   name <- added[[kk]]
[16:21:31.348]                   NAME <- NAMES[[kk]]
[16:21:31.348]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:31.348]                     next
[16:21:31.348]                   args[[name]] <- ""
[16:21:31.348]                 }
[16:21:31.348]                 NAMES <- toupper(removed)
[16:21:31.348]                 for (kk in seq_along(NAMES)) {
[16:21:31.348]                   name <- removed[[kk]]
[16:21:31.348]                   NAME <- NAMES[[kk]]
[16:21:31.348]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:31.348]                     next
[16:21:31.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:31.348]                 }
[16:21:31.348]                 if (length(args) > 0) 
[16:21:31.348]                   base::do.call(base::Sys.setenv, args = args)
[16:21:31.348]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:31.348]             }
[16:21:31.348]             else {
[16:21:31.348]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:31.348]             }
[16:21:31.348]             {
[16:21:31.348]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:31.348]                   0L) {
[16:21:31.348]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:31.348]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:31.348]                   base::options(opts)
[16:21:31.348]                 }
[16:21:31.348]                 {
[16:21:31.348]                   {
[16:21:31.348]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:31.348]                     NULL
[16:21:31.348]                   }
[16:21:31.348]                   options(future.plan = NULL)
[16:21:31.348]                   if (is.na(NA_character_)) 
[16:21:31.348]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:31.348]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:31.348]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:31.348]                     .init = FALSE)
[16:21:31.348]                 }
[16:21:31.348]             }
[16:21:31.348]         }
[16:21:31.348]     })
[16:21:31.348]     if (TRUE) {
[16:21:31.348]         base::sink(type = "output", split = FALSE)
[16:21:31.348]         if (TRUE) {
[16:21:31.348]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:31.348]         }
[16:21:31.348]         else {
[16:21:31.348]             ...future.result["stdout"] <- base::list(NULL)
[16:21:31.348]         }
[16:21:31.348]         base::close(...future.stdout)
[16:21:31.348]         ...future.stdout <- NULL
[16:21:31.348]     }
[16:21:31.348]     ...future.result$conditions <- ...future.conditions
[16:21:31.348]     ...future.result$finished <- base::Sys.time()
[16:21:31.348]     ...future.result
[16:21:31.348] }
[16:21:31.351] Exporting 2 global objects (88.27 KiB) to cluster node #1 ...
[16:21:31.351] Exporting ‘nested’ (88.15 KiB) to cluster node #1 ...
[16:21:31.393] Exporting ‘nested’ (88.15 KiB) to cluster node #1 ... DONE
[16:21:31.393] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[16:21:31.393] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[16:21:31.393] Exporting 2 global objects (88.27 KiB) to cluster node #1 ... DONE
[16:21:31.394] MultisessionFuture started
[16:21:31.394] - Launch lazy future ... done
[16:21:31.394] run() for ‘MultisessionFuture’ ... done
[16:21:31.394] result() for ClusterFuture ...
[16:21:31.394] receiveMessageFromWorker() for ClusterFuture ...
[16:21:31.395] - Validating connection of MultisessionFuture
[16:21:31.468] - received message: FutureResult
[16:21:31.468] - Received FutureResult
[16:21:31.468] - Erased future from FutureRegistry
[16:21:31.468] result() for ClusterFuture ...
[16:21:31.468] - result already collected: FutureResult
[16:21:31.468] result() for ClusterFuture ... done
[16:21:31.468] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:31.468] result() for ClusterFuture ... done
[16:21:31.469] result() for ClusterFuture ...
[16:21:31.469] - result already collected: FutureResult
[16:21:31.469] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:21:31.474] getGlobalsAndPackages() ...
[16:21:31.475] Searching for globals...
[16:21:31.476] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:21:31.476] Searching for globals ... DONE
[16:21:31.476] Resolving globals: FALSE
[16:21:31.477] The total size of the 1 globals is 128 bytes (128 bytes)
[16:21:31.477] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:21:31.477] - globals: [1] ‘data’
[16:21:31.477] - packages: [1] ‘future’
[16:21:31.477] getGlobalsAndPackages() ... DONE
[16:21:31.478] run() for ‘Future’ ...
[16:21:31.478] - state: ‘created’
[16:21:31.478] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:31.492] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:31.492] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:31.492]   - Field: ‘node’
[16:21:31.492]   - Field: ‘label’
[16:21:31.492]   - Field: ‘local’
[16:21:31.492]   - Field: ‘owner’
[16:21:31.493]   - Field: ‘envir’
[16:21:31.493]   - Field: ‘workers’
[16:21:31.493]   - Field: ‘packages’
[16:21:31.493]   - Field: ‘gc’
[16:21:31.493]   - Field: ‘conditions’
[16:21:31.493]   - Field: ‘persistent’
[16:21:31.493]   - Field: ‘expr’
[16:21:31.493]   - Field: ‘uuid’
[16:21:31.493]   - Field: ‘seed’
[16:21:31.493]   - Field: ‘version’
[16:21:31.493]   - Field: ‘result’
[16:21:31.494]   - Field: ‘asynchronous’
[16:21:31.494]   - Field: ‘calls’
[16:21:31.494]   - Field: ‘globals’
[16:21:31.494]   - Field: ‘stdout’
[16:21:31.496]   - Field: ‘earlySignal’
[16:21:31.496]   - Field: ‘lazy’
[16:21:31.496]   - Field: ‘state’
[16:21:31.496] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:31.497] - Launch lazy future ...
[16:21:31.497] Packages needed by the future expression (n = 1): ‘future’
[16:21:31.497] Packages needed by future strategies (n = 1): ‘future’
[16:21:31.497] {
[16:21:31.497]     {
[16:21:31.497]         {
[16:21:31.497]             ...future.startTime <- base::Sys.time()
[16:21:31.497]             {
[16:21:31.497]                 {
[16:21:31.497]                   {
[16:21:31.497]                     {
[16:21:31.497]                       {
[16:21:31.497]                         base::local({
[16:21:31.497]                           has_future <- base::requireNamespace("future", 
[16:21:31.497]                             quietly = TRUE)
[16:21:31.497]                           if (has_future) {
[16:21:31.497]                             ns <- base::getNamespace("future")
[16:21:31.497]                             version <- ns[[".package"]][["version"]]
[16:21:31.497]                             if (is.null(version)) 
[16:21:31.497]                               version <- utils::packageVersion("future")
[16:21:31.497]                           }
[16:21:31.497]                           else {
[16:21:31.497]                             version <- NULL
[16:21:31.497]                           }
[16:21:31.497]                           if (!has_future || version < "1.8.0") {
[16:21:31.497]                             info <- base::c(r_version = base::gsub("R version ", 
[16:21:31.497]                               "", base::R.version$version.string), 
[16:21:31.497]                               platform = base::sprintf("%s (%s-bit)", 
[16:21:31.497]                                 base::R.version$platform, 8 * 
[16:21:31.497]                                   base::.Machine$sizeof.pointer), 
[16:21:31.497]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:31.497]                                 "release", "version")], collapse = " "), 
[16:21:31.497]                               hostname = base::Sys.info()[["nodename"]])
[16:21:31.497]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:21:31.497]                               info)
[16:21:31.497]                             info <- base::paste(info, collapse = "; ")
[16:21:31.497]                             if (!has_future) {
[16:21:31.497]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:31.497]                                 info)
[16:21:31.497]                             }
[16:21:31.497]                             else {
[16:21:31.497]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:31.497]                                 info, version)
[16:21:31.497]                             }
[16:21:31.497]                             base::stop(msg)
[16:21:31.497]                           }
[16:21:31.497]                         })
[16:21:31.497]                       }
[16:21:31.497]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:31.497]                       base::options(mc.cores = 1L)
[16:21:31.497]                     }
[16:21:31.497]                     base::local({
[16:21:31.497]                       for (pkg in "future") {
[16:21:31.497]                         base::loadNamespace(pkg)
[16:21:31.497]                         base::library(pkg, character.only = TRUE)
[16:21:31.497]                       }
[16:21:31.497]                     })
[16:21:31.497]                   }
[16:21:31.497]                   ...future.strategy.old <- future::plan("list")
[16:21:31.497]                   options(future.plan = NULL)
[16:21:31.497]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:31.497]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:21:31.497]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:21:31.497]                     envir = parent.frame()) 
[16:21:31.497]                   {
[16:21:31.497]                     if (is.function(workers)) 
[16:21:31.497]                       workers <- workers()
[16:21:31.497]                     workers <- structure(as.integer(workers), 
[16:21:31.497]                       class = class(workers))
[16:21:31.497]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:21:31.497]                       workers >= 1)
[16:21:31.497]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:21:31.497]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:21:31.497]                     }
[16:21:31.497]                     future <- MultisessionFuture(..., workers = workers, 
[16:21:31.497]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:21:31.497]                       envir = envir)
[16:21:31.497]                     if (!future$lazy) 
[16:21:31.497]                       future <- run(future)
[16:21:31.497]                     invisible(future)
[16:21:31.497]                   }), .cleanup = FALSE, .init = FALSE)
[16:21:31.497]                 }
[16:21:31.497]                 ...future.workdir <- getwd()
[16:21:31.497]             }
[16:21:31.497]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:31.497]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:31.497]         }
[16:21:31.497]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:31.497]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:31.497]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:31.497]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:31.497]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:31.497]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:31.497]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:31.497]             base::names(...future.oldOptions))
[16:21:31.497]     }
[16:21:31.497]     if (FALSE) {
[16:21:31.497]     }
[16:21:31.497]     else {
[16:21:31.497]         if (TRUE) {
[16:21:31.497]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:31.497]                 open = "w")
[16:21:31.497]         }
[16:21:31.497]         else {
[16:21:31.497]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:31.497]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:31.497]         }
[16:21:31.497]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:31.497]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:31.497]             base::sink(type = "output", split = FALSE)
[16:21:31.497]             base::close(...future.stdout)
[16:21:31.497]         }, add = TRUE)
[16:21:31.497]     }
[16:21:31.497]     ...future.frame <- base::sys.nframe()
[16:21:31.497]     ...future.conditions <- base::list()
[16:21:31.497]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:31.497]     if (FALSE) {
[16:21:31.497]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:31.497]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:31.497]     }
[16:21:31.497]     ...future.result <- base::tryCatch({
[16:21:31.497]         base::withCallingHandlers({
[16:21:31.497]             ...future.value <- base::withVisible(base::local({
[16:21:31.497]                 ...future.makeSendCondition <- base::local({
[16:21:31.497]                   sendCondition <- NULL
[16:21:31.497]                   function(frame = 1L) {
[16:21:31.497]                     if (is.function(sendCondition)) 
[16:21:31.497]                       return(sendCondition)
[16:21:31.497]                     ns <- getNamespace("parallel")
[16:21:31.497]                     if (exists("sendData", mode = "function", 
[16:21:31.497]                       envir = ns)) {
[16:21:31.497]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:31.497]                         envir = ns)
[16:21:31.497]                       envir <- sys.frame(frame)
[16:21:31.497]                       master <- NULL
[16:21:31.497]                       while (!identical(envir, .GlobalEnv) && 
[16:21:31.497]                         !identical(envir, emptyenv())) {
[16:21:31.497]                         if (exists("master", mode = "list", envir = envir, 
[16:21:31.497]                           inherits = FALSE)) {
[16:21:31.497]                           master <- get("master", mode = "list", 
[16:21:31.497]                             envir = envir, inherits = FALSE)
[16:21:31.497]                           if (inherits(master, c("SOCKnode", 
[16:21:31.497]                             "SOCK0node"))) {
[16:21:31.497]                             sendCondition <<- function(cond) {
[16:21:31.497]                               data <- list(type = "VALUE", value = cond, 
[16:21:31.497]                                 success = TRUE)
[16:21:31.497]                               parallel_sendData(master, data)
[16:21:31.497]                             }
[16:21:31.497]                             return(sendCondition)
[16:21:31.497]                           }
[16:21:31.497]                         }
[16:21:31.497]                         frame <- frame + 1L
[16:21:31.497]                         envir <- sys.frame(frame)
[16:21:31.497]                       }
[16:21:31.497]                     }
[16:21:31.497]                     sendCondition <<- function(cond) NULL
[16:21:31.497]                   }
[16:21:31.497]                 })
[16:21:31.497]                 withCallingHandlers({
[16:21:31.497]                   {
[16:21:31.497]                     value(future(subset(data, a == 2)))
[16:21:31.497]                   }
[16:21:31.497]                 }, immediateCondition = function(cond) {
[16:21:31.497]                   sendCondition <- ...future.makeSendCondition()
[16:21:31.497]                   sendCondition(cond)
[16:21:31.497]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:31.497]                   {
[16:21:31.497]                     inherits <- base::inherits
[16:21:31.497]                     invokeRestart <- base::invokeRestart
[16:21:31.497]                     is.null <- base::is.null
[16:21:31.497]                     muffled <- FALSE
[16:21:31.497]                     if (inherits(cond, "message")) {
[16:21:31.497]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:31.497]                       if (muffled) 
[16:21:31.497]                         invokeRestart("muffleMessage")
[16:21:31.497]                     }
[16:21:31.497]                     else if (inherits(cond, "warning")) {
[16:21:31.497]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:31.497]                       if (muffled) 
[16:21:31.497]                         invokeRestart("muffleWarning")
[16:21:31.497]                     }
[16:21:31.497]                     else if (inherits(cond, "condition")) {
[16:21:31.497]                       if (!is.null(pattern)) {
[16:21:31.497]                         computeRestarts <- base::computeRestarts
[16:21:31.497]                         grepl <- base::grepl
[16:21:31.497]                         restarts <- computeRestarts(cond)
[16:21:31.497]                         for (restart in restarts) {
[16:21:31.497]                           name <- restart$name
[16:21:31.497]                           if (is.null(name)) 
[16:21:31.497]                             next
[16:21:31.497]                           if (!grepl(pattern, name)) 
[16:21:31.497]                             next
[16:21:31.497]                           invokeRestart(restart)
[16:21:31.497]                           muffled <- TRUE
[16:21:31.497]                           break
[16:21:31.497]                         }
[16:21:31.497]                       }
[16:21:31.497]                     }
[16:21:31.497]                     invisible(muffled)
[16:21:31.497]                   }
[16:21:31.497]                   muffleCondition(cond)
[16:21:31.497]                 })
[16:21:31.497]             }))
[16:21:31.497]             future::FutureResult(value = ...future.value$value, 
[16:21:31.497]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:31.497]                   ...future.rng), globalenv = if (FALSE) 
[16:21:31.497]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:31.497]                     ...future.globalenv.names))
[16:21:31.497]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:31.497]         }, condition = base::local({
[16:21:31.497]             c <- base::c
[16:21:31.497]             inherits <- base::inherits
[16:21:31.497]             invokeRestart <- base::invokeRestart
[16:21:31.497]             length <- base::length
[16:21:31.497]             list <- base::list
[16:21:31.497]             seq.int <- base::seq.int
[16:21:31.497]             signalCondition <- base::signalCondition
[16:21:31.497]             sys.calls <- base::sys.calls
[16:21:31.497]             `[[` <- base::`[[`
[16:21:31.497]             `+` <- base::`+`
[16:21:31.497]             `<<-` <- base::`<<-`
[16:21:31.497]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:31.497]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:31.497]                   3L)]
[16:21:31.497]             }
[16:21:31.497]             function(cond) {
[16:21:31.497]                 is_error <- inherits(cond, "error")
[16:21:31.497]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:31.497]                   NULL)
[16:21:31.497]                 if (is_error) {
[16:21:31.497]                   sessionInformation <- function() {
[16:21:31.497]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:31.497]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:31.497]                       search = base::search(), system = base::Sys.info())
[16:21:31.497]                   }
[16:21:31.497]                   ...future.conditions[[length(...future.conditions) + 
[16:21:31.497]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:31.497]                     cond$call), session = sessionInformation(), 
[16:21:31.497]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:31.497]                   signalCondition(cond)
[16:21:31.497]                 }
[16:21:31.497]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:31.497]                 "immediateCondition"))) {
[16:21:31.497]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:31.497]                   ...future.conditions[[length(...future.conditions) + 
[16:21:31.497]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:31.497]                   if (TRUE && !signal) {
[16:21:31.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:31.497]                     {
[16:21:31.497]                       inherits <- base::inherits
[16:21:31.497]                       invokeRestart <- base::invokeRestart
[16:21:31.497]                       is.null <- base::is.null
[16:21:31.497]                       muffled <- FALSE
[16:21:31.497]                       if (inherits(cond, "message")) {
[16:21:31.497]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:31.497]                         if (muffled) 
[16:21:31.497]                           invokeRestart("muffleMessage")
[16:21:31.497]                       }
[16:21:31.497]                       else if (inherits(cond, "warning")) {
[16:21:31.497]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:31.497]                         if (muffled) 
[16:21:31.497]                           invokeRestart("muffleWarning")
[16:21:31.497]                       }
[16:21:31.497]                       else if (inherits(cond, "condition")) {
[16:21:31.497]                         if (!is.null(pattern)) {
[16:21:31.497]                           computeRestarts <- base::computeRestarts
[16:21:31.497]                           grepl <- base::grepl
[16:21:31.497]                           restarts <- computeRestarts(cond)
[16:21:31.497]                           for (restart in restarts) {
[16:21:31.497]                             name <- restart$name
[16:21:31.497]                             if (is.null(name)) 
[16:21:31.497]                               next
[16:21:31.497]                             if (!grepl(pattern, name)) 
[16:21:31.497]                               next
[16:21:31.497]                             invokeRestart(restart)
[16:21:31.497]                             muffled <- TRUE
[16:21:31.497]                             break
[16:21:31.497]                           }
[16:21:31.497]                         }
[16:21:31.497]                       }
[16:21:31.497]                       invisible(muffled)
[16:21:31.497]                     }
[16:21:31.497]                     muffleCondition(cond, pattern = "^muffle")
[16:21:31.497]                   }
[16:21:31.497]                 }
[16:21:31.497]                 else {
[16:21:31.497]                   if (TRUE) {
[16:21:31.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:31.497]                     {
[16:21:31.497]                       inherits <- base::inherits
[16:21:31.497]                       invokeRestart <- base::invokeRestart
[16:21:31.497]                       is.null <- base::is.null
[16:21:31.497]                       muffled <- FALSE
[16:21:31.497]                       if (inherits(cond, "message")) {
[16:21:31.497]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:31.497]                         if (muffled) 
[16:21:31.497]                           invokeRestart("muffleMessage")
[16:21:31.497]                       }
[16:21:31.497]                       else if (inherits(cond, "warning")) {
[16:21:31.497]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:31.497]                         if (muffled) 
[16:21:31.497]                           invokeRestart("muffleWarning")
[16:21:31.497]                       }
[16:21:31.497]                       else if (inherits(cond, "condition")) {
[16:21:31.497]                         if (!is.null(pattern)) {
[16:21:31.497]                           computeRestarts <- base::computeRestarts
[16:21:31.497]                           grepl <- base::grepl
[16:21:31.497]                           restarts <- computeRestarts(cond)
[16:21:31.497]                           for (restart in restarts) {
[16:21:31.497]                             name <- restart$name
[16:21:31.497]                             if (is.null(name)) 
[16:21:31.497]                               next
[16:21:31.497]                             if (!grepl(pattern, name)) 
[16:21:31.497]                               next
[16:21:31.497]                             invokeRestart(restart)
[16:21:31.497]                             muffled <- TRUE
[16:21:31.497]                             break
[16:21:31.497]                           }
[16:21:31.497]                         }
[16:21:31.497]                       }
[16:21:31.497]                       invisible(muffled)
[16:21:31.497]                     }
[16:21:31.497]                     muffleCondition(cond, pattern = "^muffle")
[16:21:31.497]                   }
[16:21:31.497]                 }
[16:21:31.497]             }
[16:21:31.497]         }))
[16:21:31.497]     }, error = function(ex) {
[16:21:31.497]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:31.497]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:31.497]                 ...future.rng), started = ...future.startTime, 
[16:21:31.497]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:31.497]             version = "1.8"), class = "FutureResult")
[16:21:31.497]     }, finally = {
[16:21:31.497]         if (!identical(...future.workdir, getwd())) 
[16:21:31.497]             setwd(...future.workdir)
[16:21:31.497]         {
[16:21:31.497]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:31.497]                 ...future.oldOptions$nwarnings <- NULL
[16:21:31.497]             }
[16:21:31.497]             base::options(...future.oldOptions)
[16:21:31.497]             if (.Platform$OS.type == "windows") {
[16:21:31.497]                 old_names <- names(...future.oldEnvVars)
[16:21:31.497]                 envs <- base::Sys.getenv()
[16:21:31.497]                 names <- names(envs)
[16:21:31.497]                 common <- intersect(names, old_names)
[16:21:31.497]                 added <- setdiff(names, old_names)
[16:21:31.497]                 removed <- setdiff(old_names, names)
[16:21:31.497]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:31.497]                   envs[common]]
[16:21:31.497]                 NAMES <- toupper(changed)
[16:21:31.497]                 args <- list()
[16:21:31.497]                 for (kk in seq_along(NAMES)) {
[16:21:31.497]                   name <- changed[[kk]]
[16:21:31.497]                   NAME <- NAMES[[kk]]
[16:21:31.497]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:31.497]                     next
[16:21:31.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:31.497]                 }
[16:21:31.497]                 NAMES <- toupper(added)
[16:21:31.497]                 for (kk in seq_along(NAMES)) {
[16:21:31.497]                   name <- added[[kk]]
[16:21:31.497]                   NAME <- NAMES[[kk]]
[16:21:31.497]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:31.497]                     next
[16:21:31.497]                   args[[name]] <- ""
[16:21:31.497]                 }
[16:21:31.497]                 NAMES <- toupper(removed)
[16:21:31.497]                 for (kk in seq_along(NAMES)) {
[16:21:31.497]                   name <- removed[[kk]]
[16:21:31.497]                   NAME <- NAMES[[kk]]
[16:21:31.497]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:31.497]                     next
[16:21:31.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:31.497]                 }
[16:21:31.497]                 if (length(args) > 0) 
[16:21:31.497]                   base::do.call(base::Sys.setenv, args = args)
[16:21:31.497]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:31.497]             }
[16:21:31.497]             else {
[16:21:31.497]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:31.497]             }
[16:21:31.497]             {
[16:21:31.497]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:31.497]                   0L) {
[16:21:31.497]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:31.497]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:31.497]                   base::options(opts)
[16:21:31.497]                 }
[16:21:31.497]                 {
[16:21:31.497]                   {
[16:21:31.497]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:31.497]                     NULL
[16:21:31.497]                   }
[16:21:31.497]                   options(future.plan = NULL)
[16:21:31.497]                   if (is.na(NA_character_)) 
[16:21:31.497]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:31.497]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:31.497]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:31.497]                     .init = FALSE)
[16:21:31.497]                 }
[16:21:31.497]             }
[16:21:31.497]         }
[16:21:31.497]     })
[16:21:31.497]     if (TRUE) {
[16:21:31.497]         base::sink(type = "output", split = FALSE)
[16:21:31.497]         if (TRUE) {
[16:21:31.497]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:31.497]         }
[16:21:31.497]         else {
[16:21:31.497]             ...future.result["stdout"] <- base::list(NULL)
[16:21:31.497]         }
[16:21:31.497]         base::close(...future.stdout)
[16:21:31.497]         ...future.stdout <- NULL
[16:21:31.497]     }
[16:21:31.497]     ...future.result$conditions <- ...future.conditions
[16:21:31.497]     ...future.result$finished <- base::Sys.time()
[16:21:31.497]     ...future.result
[16:21:31.497] }
[16:21:31.500] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[16:21:31.501] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[16:21:31.501] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[16:21:31.501] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[16:21:31.501] MultisessionFuture started
[16:21:31.502] - Launch lazy future ... done
[16:21:31.502] run() for ‘MultisessionFuture’ ... done
[16:21:31.502] result() for ClusterFuture ...
[16:21:31.502] receiveMessageFromWorker() for ClusterFuture ...
[16:21:31.502] - Validating connection of MultisessionFuture
[16:21:31.560] - received message: FutureResult
[16:21:31.560] - Received FutureResult
[16:21:31.560] - Erased future from FutureRegistry
[16:21:31.560] result() for ClusterFuture ...
[16:21:31.560] - result already collected: FutureResult
[16:21:31.560] result() for ClusterFuture ... done
[16:21:31.561] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:31.561] result() for ClusterFuture ... done
[16:21:31.561] result() for ClusterFuture ...
[16:21:31.561] - result already collected: FutureResult
[16:21:31.561] result() for ClusterFuture ... done
- plan(list('multisession', 'multisession')) ... DONE
> 
> message("*** Nested futures ... DONE")
*** Nested futures ... DONE
> 
> source("incl/end.R")
[16:21:31.562] plan(): Setting new future strategy stack:
[16:21:31.562] List of future strategies:
[16:21:31.562] 1. FutureStrategy:
[16:21:31.562]    - args: function (..., envir = parent.frame())
[16:21:31.562]    - tweaked: FALSE
[16:21:31.562]    - call: future::plan(oplan)
[16:21:31.562] plan(): nbrOfWorkers() = 1
> 
