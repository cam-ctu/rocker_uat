
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:32:56.776] plan(): Setting new future strategy stack:
[10:32:56.776] List of future strategies:
[10:32:56.776] 1. sequential:
[10:32:56.776]    - args: function (..., envir = parent.frame())
[10:32:56.776]    - tweaked: FALSE
[10:32:56.776]    - call: future::plan("sequential")
[10:32:56.790] plan(): nbrOfWorkers() = 1
> 
> library("datasets") ## cars data set
> library("stats")    ## lm(), poly(), xtabs()
> 
> message("*** Globals - formulas ...")
*** Globals - formulas ...
> 
> ## (i) lm(<formula>):
> ## From example("lm", package = "stats")
> ctl <- c(4.17, 5.58, 5.18, 6.11, 4.50, 4.61, 5.17, 4.53, 5.33, 5.14)
> trt <- c(4.81, 4.17, 4.41, 3.59, 5.87, 3.83, 6.03, 4.89, 4.32, 4.69)
> group <- gl(2, 10, 20, labels = c("Ctl", "Trt"))
> weight <- c(ctl, trt)
> ctl <- trt <- NULL
> ## Truth:
> fit_i <- lm(weight ~ group - 1)
> print(fit_i)

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

> 
> ## (ii) xtabs(~ x):
> x <- c(1, 1, 2, 2, 2)
> ## Truth:
> tbl_ii <- xtabs(~ x)
> print(tbl_ii)
x
1 2 
2 3 
> 
> ## (iii) lm(<formula>, data = cars):
> exprs <- list(
+   # "remove-intercept-term" form of no-intercept
+   a = substitute({ lm(dist ~ . -1, data = cars) }),
+   # "make-intercept-zero" form of no-intercept
+   b = substitute({ lm(dist ~ . +0, data = cars) }),
+   # doesn't do what we want here
+   c = substitute({ lm(dist ~ speed + speed ^ 2, data = cars) }),
+   # gets us a quadratic term
+   d = substitute({ lm(dist ~ speed + I(speed ^ 2), data = cars) }),
+   # avoid potential multicollinearity
+   e = substitute({ lm(dist ~ poly(speed, 2), data = cars) })
+ )
> 
> ## (iv) Globals - map(x, ~ expr):
> ## A fake purrr::map() function with limited functionality
> map <- function(.x, .f, ...) {
+   if (inherits(.f, "formula")) {
+     expr <- .f[[-1]]
+     .f <- eval(bquote(function(...) {
+       .(expr)
+     }))
+   }
+   eval(lapply(.x, FUN = .f, ...))
+ }
> 
> inner_function <- function(x) { x + 1 }
> 
> outer_function <- function(x) {
+   map(1:2, ~ inner_function(.x))
+ }
> 
> y_iv <- outer_function(1L)
> str(y_iv)
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
> 
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     message("- lm(<formula>) ...")
+     
+     ## Explicit future
+     f <- future({ lm(weight ~ group - 1) })
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Explicit future (lazy)
+     f <- future({ lm(weight ~ group - 1) }, lazy = TRUE)
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment
+     fit %<-% { lm(weight ~ group - 1) }
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (non-lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% FALSE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% TRUE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     message("- Globals - one-side formulas, e.g. xtabs(~ x) ...")
+     ## Explicit future
+     f <- future({ xtabs(~ x) })
+     tbl <- value(f)
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     ## Future assignment
+     tbl %<-% { xtabs(~ x) }
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     message("- Globals - lm(<formula>, data = cars) ...")
+     for (kk in seq_along(exprs)) {
+       expr <- exprs[[kk]]
+       name <- names(exprs)[kk]
+       message(sprintf("- Globals - lm(<formula #%d (%s)>, data = cars) ...",
+                       kk, sQuote(name)))
+     
+       fit_iii <- eval(expr)
+       print(fit_iii)
+     
+       f <- future(expr, substitute = FALSE)
+       fit <- value(f)
+       print(fit)
+     
+       stopifnot(all.equal(fit, fit_iii))
+     } ## for (kk ...)
+ 
+     message("- Globals - map(x, ~ expr) ...")
+     f <- future({ outer_function(1L) })
+     y <- value(f)
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+ 
+     y %<-% { outer_function(1L) }
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+   } ## for (strategy ...)
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[10:32:56.844] plan(): Setting new future strategy stack:
[10:32:56.844] List of future strategies:
[10:32:56.844] 1. sequential:
[10:32:56.844]    - args: function (..., envir = parent.frame())
[10:32:56.844]    - tweaked: FALSE
[10:32:56.844]    - call: plan(strategy)
[10:32:56.856] plan(): nbrOfWorkers() = 1
- lm(<formula>) ...
[10:32:56.857] getGlobalsAndPackages() ...
[10:32:56.857] Searching for globals...
[10:32:56.863] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:32:56.864] Searching for globals ... DONE
[10:32:56.864] Resolving globals: FALSE
[10:32:56.865] The total size of the 2 globals is 896 bytes (896 bytes)
[10:32:56.865] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:32:56.865] - globals: [2] ‘weight’, ‘group’
[10:32:56.866] - packages: [1] ‘stats’
[10:32:56.866] getGlobalsAndPackages() ... DONE
[10:32:56.866] run() for ‘Future’ ...
[10:32:56.866] - state: ‘created’
[10:32:56.867] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:56.867] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:56.867] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:56.867]   - Field: ‘label’
[10:32:56.867]   - Field: ‘local’
[10:32:56.867]   - Field: ‘owner’
[10:32:56.867]   - Field: ‘envir’
[10:32:56.868]   - Field: ‘packages’
[10:32:56.868]   - Field: ‘gc’
[10:32:56.868]   - Field: ‘conditions’
[10:32:56.868]   - Field: ‘expr’
[10:32:56.868]   - Field: ‘uuid’
[10:32:56.868]   - Field: ‘seed’
[10:32:56.868]   - Field: ‘version’
[10:32:56.868]   - Field: ‘result’
[10:32:56.868]   - Field: ‘asynchronous’
[10:32:56.868]   - Field: ‘calls’
[10:32:56.868]   - Field: ‘globals’
[10:32:56.869]   - Field: ‘stdout’
[10:32:56.869]   - Field: ‘earlySignal’
[10:32:56.869]   - Field: ‘lazy’
[10:32:56.869]   - Field: ‘state’
[10:32:56.869] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:56.869] - Launch lazy future ...
[10:32:56.870] Packages needed by the future expression (n = 1): ‘stats’
[10:32:56.870] Packages needed by future strategies (n = 0): <none>
[10:32:56.871] {
[10:32:56.871]     {
[10:32:56.871]         {
[10:32:56.871]             ...future.startTime <- base::Sys.time()
[10:32:56.871]             {
[10:32:56.871]                 {
[10:32:56.871]                   {
[10:32:56.871]                     {
[10:32:56.871]                       base::local({
[10:32:56.871]                         has_future <- base::requireNamespace("future", 
[10:32:56.871]                           quietly = TRUE)
[10:32:56.871]                         if (has_future) {
[10:32:56.871]                           ns <- base::getNamespace("future")
[10:32:56.871]                           version <- ns[[".package"]][["version"]]
[10:32:56.871]                           if (is.null(version)) 
[10:32:56.871]                             version <- utils::packageVersion("future")
[10:32:56.871]                         }
[10:32:56.871]                         else {
[10:32:56.871]                           version <- NULL
[10:32:56.871]                         }
[10:32:56.871]                         if (!has_future || version < "1.8.0") {
[10:32:56.871]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:56.871]                             "", base::R.version$version.string), 
[10:32:56.871]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:56.871]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:56.871]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:56.871]                               "release", "version")], collapse = " "), 
[10:32:56.871]                             hostname = base::Sys.info()[["nodename"]])
[10:32:56.871]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:56.871]                             info)
[10:32:56.871]                           info <- base::paste(info, collapse = "; ")
[10:32:56.871]                           if (!has_future) {
[10:32:56.871]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:56.871]                               info)
[10:32:56.871]                           }
[10:32:56.871]                           else {
[10:32:56.871]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:56.871]                               info, version)
[10:32:56.871]                           }
[10:32:56.871]                           base::stop(msg)
[10:32:56.871]                         }
[10:32:56.871]                       })
[10:32:56.871]                     }
[10:32:56.871]                     base::local({
[10:32:56.871]                       for (pkg in "stats") {
[10:32:56.871]                         base::loadNamespace(pkg)
[10:32:56.871]                         base::library(pkg, character.only = TRUE)
[10:32:56.871]                       }
[10:32:56.871]                     })
[10:32:56.871]                   }
[10:32:56.871]                   ...future.strategy.old <- future::plan("list")
[10:32:56.871]                   options(future.plan = NULL)
[10:32:56.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:56.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:56.871]                 }
[10:32:56.871]                 ...future.workdir <- getwd()
[10:32:56.871]             }
[10:32:56.871]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:56.871]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:56.871]         }
[10:32:56.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:56.871]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:56.871]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:56.871]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:56.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:56.871]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:56.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:56.871]             base::names(...future.oldOptions))
[10:32:56.871]     }
[10:32:56.871]     if (FALSE) {
[10:32:56.871]     }
[10:32:56.871]     else {
[10:32:56.871]         if (TRUE) {
[10:32:56.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:56.871]                 open = "w")
[10:32:56.871]         }
[10:32:56.871]         else {
[10:32:56.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:56.871]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:56.871]         }
[10:32:56.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:56.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:56.871]             base::sink(type = "output", split = FALSE)
[10:32:56.871]             base::close(...future.stdout)
[10:32:56.871]         }, add = TRUE)
[10:32:56.871]     }
[10:32:56.871]     ...future.frame <- base::sys.nframe()
[10:32:56.871]     ...future.conditions <- base::list()
[10:32:56.871]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:56.871]     if (FALSE) {
[10:32:56.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:56.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:56.871]     }
[10:32:56.871]     ...future.result <- base::tryCatch({
[10:32:56.871]         base::withCallingHandlers({
[10:32:56.871]             ...future.value <- base::withVisible(base::local({
[10:32:56.871]                 lm(weight ~ group - 1)
[10:32:56.871]             }))
[10:32:56.871]             future::FutureResult(value = ...future.value$value, 
[10:32:56.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:56.871]                   ...future.rng), globalenv = if (FALSE) 
[10:32:56.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:56.871]                     ...future.globalenv.names))
[10:32:56.871]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:56.871]         }, condition = base::local({
[10:32:56.871]             c <- base::c
[10:32:56.871]             inherits <- base::inherits
[10:32:56.871]             invokeRestart <- base::invokeRestart
[10:32:56.871]             length <- base::length
[10:32:56.871]             list <- base::list
[10:32:56.871]             seq.int <- base::seq.int
[10:32:56.871]             signalCondition <- base::signalCondition
[10:32:56.871]             sys.calls <- base::sys.calls
[10:32:56.871]             `[[` <- base::`[[`
[10:32:56.871]             `+` <- base::`+`
[10:32:56.871]             `<<-` <- base::`<<-`
[10:32:56.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:56.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:56.871]                   3L)]
[10:32:56.871]             }
[10:32:56.871]             function(cond) {
[10:32:56.871]                 is_error <- inherits(cond, "error")
[10:32:56.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:56.871]                   NULL)
[10:32:56.871]                 if (is_error) {
[10:32:56.871]                   sessionInformation <- function() {
[10:32:56.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:56.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:56.871]                       search = base::search(), system = base::Sys.info())
[10:32:56.871]                   }
[10:32:56.871]                   ...future.conditions[[length(...future.conditions) + 
[10:32:56.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:56.871]                     cond$call), session = sessionInformation(), 
[10:32:56.871]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:56.871]                   signalCondition(cond)
[10:32:56.871]                 }
[10:32:56.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:56.871]                 "immediateCondition"))) {
[10:32:56.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:56.871]                   ...future.conditions[[length(...future.conditions) + 
[10:32:56.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:56.871]                   if (TRUE && !signal) {
[10:32:56.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:56.871]                     {
[10:32:56.871]                       inherits <- base::inherits
[10:32:56.871]                       invokeRestart <- base::invokeRestart
[10:32:56.871]                       is.null <- base::is.null
[10:32:56.871]                       muffled <- FALSE
[10:32:56.871]                       if (inherits(cond, "message")) {
[10:32:56.871]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:56.871]                         if (muffled) 
[10:32:56.871]                           invokeRestart("muffleMessage")
[10:32:56.871]                       }
[10:32:56.871]                       else if (inherits(cond, "warning")) {
[10:32:56.871]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:56.871]                         if (muffled) 
[10:32:56.871]                           invokeRestart("muffleWarning")
[10:32:56.871]                       }
[10:32:56.871]                       else if (inherits(cond, "condition")) {
[10:32:56.871]                         if (!is.null(pattern)) {
[10:32:56.871]                           computeRestarts <- base::computeRestarts
[10:32:56.871]                           grepl <- base::grepl
[10:32:56.871]                           restarts <- computeRestarts(cond)
[10:32:56.871]                           for (restart in restarts) {
[10:32:56.871]                             name <- restart$name
[10:32:56.871]                             if (is.null(name)) 
[10:32:56.871]                               next
[10:32:56.871]                             if (!grepl(pattern, name)) 
[10:32:56.871]                               next
[10:32:56.871]                             invokeRestart(restart)
[10:32:56.871]                             muffled <- TRUE
[10:32:56.871]                             break
[10:32:56.871]                           }
[10:32:56.871]                         }
[10:32:56.871]                       }
[10:32:56.871]                       invisible(muffled)
[10:32:56.871]                     }
[10:32:56.871]                     muffleCondition(cond, pattern = "^muffle")
[10:32:56.871]                   }
[10:32:56.871]                 }
[10:32:56.871]                 else {
[10:32:56.871]                   if (TRUE) {
[10:32:56.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:56.871]                     {
[10:32:56.871]                       inherits <- base::inherits
[10:32:56.871]                       invokeRestart <- base::invokeRestart
[10:32:56.871]                       is.null <- base::is.null
[10:32:56.871]                       muffled <- FALSE
[10:32:56.871]                       if (inherits(cond, "message")) {
[10:32:56.871]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:56.871]                         if (muffled) 
[10:32:56.871]                           invokeRestart("muffleMessage")
[10:32:56.871]                       }
[10:32:56.871]                       else if (inherits(cond, "warning")) {
[10:32:56.871]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:56.871]                         if (muffled) 
[10:32:56.871]                           invokeRestart("muffleWarning")
[10:32:56.871]                       }
[10:32:56.871]                       else if (inherits(cond, "condition")) {
[10:32:56.871]                         if (!is.null(pattern)) {
[10:32:56.871]                           computeRestarts <- base::computeRestarts
[10:32:56.871]                           grepl <- base::grepl
[10:32:56.871]                           restarts <- computeRestarts(cond)
[10:32:56.871]                           for (restart in restarts) {
[10:32:56.871]                             name <- restart$name
[10:32:56.871]                             if (is.null(name)) 
[10:32:56.871]                               next
[10:32:56.871]                             if (!grepl(pattern, name)) 
[10:32:56.871]                               next
[10:32:56.871]                             invokeRestart(restart)
[10:32:56.871]                             muffled <- TRUE
[10:32:56.871]                             break
[10:32:56.871]                           }
[10:32:56.871]                         }
[10:32:56.871]                       }
[10:32:56.871]                       invisible(muffled)
[10:32:56.871]                     }
[10:32:56.871]                     muffleCondition(cond, pattern = "^muffle")
[10:32:56.871]                   }
[10:32:56.871]                 }
[10:32:56.871]             }
[10:32:56.871]         }))
[10:32:56.871]     }, error = function(ex) {
[10:32:56.871]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:56.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:56.871]                 ...future.rng), started = ...future.startTime, 
[10:32:56.871]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:56.871]             version = "1.8"), class = "FutureResult")
[10:32:56.871]     }, finally = {
[10:32:56.871]         if (!identical(...future.workdir, getwd())) 
[10:32:56.871]             setwd(...future.workdir)
[10:32:56.871]         {
[10:32:56.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:56.871]                 ...future.oldOptions$nwarnings <- NULL
[10:32:56.871]             }
[10:32:56.871]             base::options(...future.oldOptions)
[10:32:56.871]             if (.Platform$OS.type == "windows") {
[10:32:56.871]                 old_names <- names(...future.oldEnvVars)
[10:32:56.871]                 envs <- base::Sys.getenv()
[10:32:56.871]                 names <- names(envs)
[10:32:56.871]                 common <- intersect(names, old_names)
[10:32:56.871]                 added <- setdiff(names, old_names)
[10:32:56.871]                 removed <- setdiff(old_names, names)
[10:32:56.871]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:56.871]                   envs[common]]
[10:32:56.871]                 NAMES <- toupper(changed)
[10:32:56.871]                 args <- list()
[10:32:56.871]                 for (kk in seq_along(NAMES)) {
[10:32:56.871]                   name <- changed[[kk]]
[10:32:56.871]                   NAME <- NAMES[[kk]]
[10:32:56.871]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.871]                     next
[10:32:56.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:56.871]                 }
[10:32:56.871]                 NAMES <- toupper(added)
[10:32:56.871]                 for (kk in seq_along(NAMES)) {
[10:32:56.871]                   name <- added[[kk]]
[10:32:56.871]                   NAME <- NAMES[[kk]]
[10:32:56.871]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.871]                     next
[10:32:56.871]                   args[[name]] <- ""
[10:32:56.871]                 }
[10:32:56.871]                 NAMES <- toupper(removed)
[10:32:56.871]                 for (kk in seq_along(NAMES)) {
[10:32:56.871]                   name <- removed[[kk]]
[10:32:56.871]                   NAME <- NAMES[[kk]]
[10:32:56.871]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.871]                     next
[10:32:56.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:56.871]                 }
[10:32:56.871]                 if (length(args) > 0) 
[10:32:56.871]                   base::do.call(base::Sys.setenv, args = args)
[10:32:56.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:56.871]             }
[10:32:56.871]             else {
[10:32:56.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:56.871]             }
[10:32:56.871]             {
[10:32:56.871]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:56.871]                   0L) {
[10:32:56.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:56.871]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:56.871]                   base::options(opts)
[10:32:56.871]                 }
[10:32:56.871]                 {
[10:32:56.871]                   {
[10:32:56.871]                     NULL
[10:32:56.871]                     RNGkind("Mersenne-Twister")
[10:32:56.871]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:56.871]                       inherits = FALSE)
[10:32:56.871]                   }
[10:32:56.871]                   options(future.plan = NULL)
[10:32:56.871]                   if (is.na(NA_character_)) 
[10:32:56.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:56.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:56.871]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:56.871]                     .init = FALSE)
[10:32:56.871]                 }
[10:32:56.871]             }
[10:32:56.871]         }
[10:32:56.871]     })
[10:32:56.871]     if (TRUE) {
[10:32:56.871]         base::sink(type = "output", split = FALSE)
[10:32:56.871]         if (TRUE) {
[10:32:56.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:56.871]         }
[10:32:56.871]         else {
[10:32:56.871]             ...future.result["stdout"] <- base::list(NULL)
[10:32:56.871]         }
[10:32:56.871]         base::close(...future.stdout)
[10:32:56.871]         ...future.stdout <- NULL
[10:32:56.871]     }
[10:32:56.871]     ...future.result$conditions <- ...future.conditions
[10:32:56.871]     ...future.result$finished <- base::Sys.time()
[10:32:56.871]     ...future.result
[10:32:56.871] }
[10:32:56.872] assign_globals() ...
[10:32:56.873] List of 2
[10:32:56.873]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:32:56.873]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:32:56.873]  - attr(*, "where")=List of 2
[10:32:56.873]   ..$ weight:<environment: R_EmptyEnv> 
[10:32:56.873]   ..$ group :<environment: R_EmptyEnv> 
[10:32:56.873]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:56.873]  - attr(*, "resolved")= logi FALSE
[10:32:56.873]  - attr(*, "total_size")= num 896
[10:32:56.873]  - attr(*, "already-done")= logi TRUE
[10:32:56.876] - copied ‘weight’ to environment
[10:32:56.876] - copied ‘group’ to environment
[10:32:56.876] assign_globals() ... done
[10:32:56.876] plan(): Setting new future strategy stack:
[10:32:56.876] List of future strategies:
[10:32:56.876] 1. sequential:
[10:32:56.876]    - args: function (..., envir = parent.frame())
[10:32:56.876]    - tweaked: FALSE
[10:32:56.876]    - call: NULL
[10:32:56.877] plan(): nbrOfWorkers() = 1
[10:32:56.879] plan(): Setting new future strategy stack:
[10:32:56.879] List of future strategies:
[10:32:56.879] 1. sequential:
[10:32:56.879]    - args: function (..., envir = parent.frame())
[10:32:56.879]    - tweaked: FALSE
[10:32:56.879]    - call: plan(strategy)
[10:32:56.879] plan(): nbrOfWorkers() = 1
[10:32:56.879] SequentialFuture started (and completed)
[10:32:56.880] - Launch lazy future ... done
[10:32:56.880] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:32:56.885] getGlobalsAndPackages() ...
[10:32:56.885] Searching for globals...
[10:32:56.886] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:32:56.886] Searching for globals ... DONE
[10:32:56.886] Resolving globals: FALSE
[10:32:56.887] The total size of the 2 globals is 896 bytes (896 bytes)
[10:32:56.887] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:32:56.887] - globals: [2] ‘weight’, ‘group’
[10:32:56.888] - packages: [1] ‘stats’
[10:32:56.888] getGlobalsAndPackages() ... DONE
[10:32:56.888] run() for ‘Future’ ...
[10:32:56.888] - state: ‘created’
[10:32:56.888] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:56.888] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:56.888] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:56.889]   - Field: ‘label’
[10:32:56.889]   - Field: ‘local’
[10:32:56.889]   - Field: ‘owner’
[10:32:56.889]   - Field: ‘envir’
[10:32:56.889]   - Field: ‘packages’
[10:32:56.889]   - Field: ‘gc’
[10:32:56.889]   - Field: ‘conditions’
[10:32:56.889]   - Field: ‘expr’
[10:32:56.889]   - Field: ‘uuid’
[10:32:56.889]   - Field: ‘seed’
[10:32:56.890]   - Field: ‘version’
[10:32:56.890]   - Field: ‘result’
[10:32:56.890]   - Field: ‘asynchronous’
[10:32:56.890]   - Field: ‘calls’
[10:32:56.890]   - Field: ‘globals’
[10:32:56.890]   - Field: ‘stdout’
[10:32:56.890]   - Field: ‘earlySignal’
[10:32:56.890]   - Field: ‘lazy’
[10:32:56.890]   - Field: ‘state’
[10:32:56.890] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:56.890] - Launch lazy future ...
[10:32:56.891] Packages needed by the future expression (n = 1): ‘stats’
[10:32:56.891] Packages needed by future strategies (n = 0): <none>
[10:32:56.891] {
[10:32:56.891]     {
[10:32:56.891]         {
[10:32:56.891]             ...future.startTime <- base::Sys.time()
[10:32:56.891]             {
[10:32:56.891]                 {
[10:32:56.891]                   {
[10:32:56.891]                     {
[10:32:56.891]                       base::local({
[10:32:56.891]                         has_future <- base::requireNamespace("future", 
[10:32:56.891]                           quietly = TRUE)
[10:32:56.891]                         if (has_future) {
[10:32:56.891]                           ns <- base::getNamespace("future")
[10:32:56.891]                           version <- ns[[".package"]][["version"]]
[10:32:56.891]                           if (is.null(version)) 
[10:32:56.891]                             version <- utils::packageVersion("future")
[10:32:56.891]                         }
[10:32:56.891]                         else {
[10:32:56.891]                           version <- NULL
[10:32:56.891]                         }
[10:32:56.891]                         if (!has_future || version < "1.8.0") {
[10:32:56.891]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:56.891]                             "", base::R.version$version.string), 
[10:32:56.891]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:56.891]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:56.891]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:56.891]                               "release", "version")], collapse = " "), 
[10:32:56.891]                             hostname = base::Sys.info()[["nodename"]])
[10:32:56.891]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:56.891]                             info)
[10:32:56.891]                           info <- base::paste(info, collapse = "; ")
[10:32:56.891]                           if (!has_future) {
[10:32:56.891]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:56.891]                               info)
[10:32:56.891]                           }
[10:32:56.891]                           else {
[10:32:56.891]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:56.891]                               info, version)
[10:32:56.891]                           }
[10:32:56.891]                           base::stop(msg)
[10:32:56.891]                         }
[10:32:56.891]                       })
[10:32:56.891]                     }
[10:32:56.891]                     base::local({
[10:32:56.891]                       for (pkg in "stats") {
[10:32:56.891]                         base::loadNamespace(pkg)
[10:32:56.891]                         base::library(pkg, character.only = TRUE)
[10:32:56.891]                       }
[10:32:56.891]                     })
[10:32:56.891]                   }
[10:32:56.891]                   ...future.strategy.old <- future::plan("list")
[10:32:56.891]                   options(future.plan = NULL)
[10:32:56.891]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:56.891]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:56.891]                 }
[10:32:56.891]                 ...future.workdir <- getwd()
[10:32:56.891]             }
[10:32:56.891]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:56.891]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:56.891]         }
[10:32:56.891]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:56.891]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:56.891]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:56.891]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:56.891]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:56.891]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:56.891]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:56.891]             base::names(...future.oldOptions))
[10:32:56.891]     }
[10:32:56.891]     if (FALSE) {
[10:32:56.891]     }
[10:32:56.891]     else {
[10:32:56.891]         if (TRUE) {
[10:32:56.891]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:56.891]                 open = "w")
[10:32:56.891]         }
[10:32:56.891]         else {
[10:32:56.891]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:56.891]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:56.891]         }
[10:32:56.891]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:56.891]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:56.891]             base::sink(type = "output", split = FALSE)
[10:32:56.891]             base::close(...future.stdout)
[10:32:56.891]         }, add = TRUE)
[10:32:56.891]     }
[10:32:56.891]     ...future.frame <- base::sys.nframe()
[10:32:56.891]     ...future.conditions <- base::list()
[10:32:56.891]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:56.891]     if (FALSE) {
[10:32:56.891]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:56.891]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:56.891]     }
[10:32:56.891]     ...future.result <- base::tryCatch({
[10:32:56.891]         base::withCallingHandlers({
[10:32:56.891]             ...future.value <- base::withVisible(base::local({
[10:32:56.891]                 lm(weight ~ group - 1)
[10:32:56.891]             }))
[10:32:56.891]             future::FutureResult(value = ...future.value$value, 
[10:32:56.891]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:56.891]                   ...future.rng), globalenv = if (FALSE) 
[10:32:56.891]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:56.891]                     ...future.globalenv.names))
[10:32:56.891]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:56.891]         }, condition = base::local({
[10:32:56.891]             c <- base::c
[10:32:56.891]             inherits <- base::inherits
[10:32:56.891]             invokeRestart <- base::invokeRestart
[10:32:56.891]             length <- base::length
[10:32:56.891]             list <- base::list
[10:32:56.891]             seq.int <- base::seq.int
[10:32:56.891]             signalCondition <- base::signalCondition
[10:32:56.891]             sys.calls <- base::sys.calls
[10:32:56.891]             `[[` <- base::`[[`
[10:32:56.891]             `+` <- base::`+`
[10:32:56.891]             `<<-` <- base::`<<-`
[10:32:56.891]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:56.891]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:56.891]                   3L)]
[10:32:56.891]             }
[10:32:56.891]             function(cond) {
[10:32:56.891]                 is_error <- inherits(cond, "error")
[10:32:56.891]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:56.891]                   NULL)
[10:32:56.891]                 if (is_error) {
[10:32:56.891]                   sessionInformation <- function() {
[10:32:56.891]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:56.891]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:56.891]                       search = base::search(), system = base::Sys.info())
[10:32:56.891]                   }
[10:32:56.891]                   ...future.conditions[[length(...future.conditions) + 
[10:32:56.891]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:56.891]                     cond$call), session = sessionInformation(), 
[10:32:56.891]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:56.891]                   signalCondition(cond)
[10:32:56.891]                 }
[10:32:56.891]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:56.891]                 "immediateCondition"))) {
[10:32:56.891]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:56.891]                   ...future.conditions[[length(...future.conditions) + 
[10:32:56.891]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:56.891]                   if (TRUE && !signal) {
[10:32:56.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:56.891]                     {
[10:32:56.891]                       inherits <- base::inherits
[10:32:56.891]                       invokeRestart <- base::invokeRestart
[10:32:56.891]                       is.null <- base::is.null
[10:32:56.891]                       muffled <- FALSE
[10:32:56.891]                       if (inherits(cond, "message")) {
[10:32:56.891]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:56.891]                         if (muffled) 
[10:32:56.891]                           invokeRestart("muffleMessage")
[10:32:56.891]                       }
[10:32:56.891]                       else if (inherits(cond, "warning")) {
[10:32:56.891]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:56.891]                         if (muffled) 
[10:32:56.891]                           invokeRestart("muffleWarning")
[10:32:56.891]                       }
[10:32:56.891]                       else if (inherits(cond, "condition")) {
[10:32:56.891]                         if (!is.null(pattern)) {
[10:32:56.891]                           computeRestarts <- base::computeRestarts
[10:32:56.891]                           grepl <- base::grepl
[10:32:56.891]                           restarts <- computeRestarts(cond)
[10:32:56.891]                           for (restart in restarts) {
[10:32:56.891]                             name <- restart$name
[10:32:56.891]                             if (is.null(name)) 
[10:32:56.891]                               next
[10:32:56.891]                             if (!grepl(pattern, name)) 
[10:32:56.891]                               next
[10:32:56.891]                             invokeRestart(restart)
[10:32:56.891]                             muffled <- TRUE
[10:32:56.891]                             break
[10:32:56.891]                           }
[10:32:56.891]                         }
[10:32:56.891]                       }
[10:32:56.891]                       invisible(muffled)
[10:32:56.891]                     }
[10:32:56.891]                     muffleCondition(cond, pattern = "^muffle")
[10:32:56.891]                   }
[10:32:56.891]                 }
[10:32:56.891]                 else {
[10:32:56.891]                   if (TRUE) {
[10:32:56.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:56.891]                     {
[10:32:56.891]                       inherits <- base::inherits
[10:32:56.891]                       invokeRestart <- base::invokeRestart
[10:32:56.891]                       is.null <- base::is.null
[10:32:56.891]                       muffled <- FALSE
[10:32:56.891]                       if (inherits(cond, "message")) {
[10:32:56.891]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:56.891]                         if (muffled) 
[10:32:56.891]                           invokeRestart("muffleMessage")
[10:32:56.891]                       }
[10:32:56.891]                       else if (inherits(cond, "warning")) {
[10:32:56.891]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:56.891]                         if (muffled) 
[10:32:56.891]                           invokeRestart("muffleWarning")
[10:32:56.891]                       }
[10:32:56.891]                       else if (inherits(cond, "condition")) {
[10:32:56.891]                         if (!is.null(pattern)) {
[10:32:56.891]                           computeRestarts <- base::computeRestarts
[10:32:56.891]                           grepl <- base::grepl
[10:32:56.891]                           restarts <- computeRestarts(cond)
[10:32:56.891]                           for (restart in restarts) {
[10:32:56.891]                             name <- restart$name
[10:32:56.891]                             if (is.null(name)) 
[10:32:56.891]                               next
[10:32:56.891]                             if (!grepl(pattern, name)) 
[10:32:56.891]                               next
[10:32:56.891]                             invokeRestart(restart)
[10:32:56.891]                             muffled <- TRUE
[10:32:56.891]                             break
[10:32:56.891]                           }
[10:32:56.891]                         }
[10:32:56.891]                       }
[10:32:56.891]                       invisible(muffled)
[10:32:56.891]                     }
[10:32:56.891]                     muffleCondition(cond, pattern = "^muffle")
[10:32:56.891]                   }
[10:32:56.891]                 }
[10:32:56.891]             }
[10:32:56.891]         }))
[10:32:56.891]     }, error = function(ex) {
[10:32:56.891]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:56.891]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:56.891]                 ...future.rng), started = ...future.startTime, 
[10:32:56.891]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:56.891]             version = "1.8"), class = "FutureResult")
[10:32:56.891]     }, finally = {
[10:32:56.891]         if (!identical(...future.workdir, getwd())) 
[10:32:56.891]             setwd(...future.workdir)
[10:32:56.891]         {
[10:32:56.891]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:56.891]                 ...future.oldOptions$nwarnings <- NULL
[10:32:56.891]             }
[10:32:56.891]             base::options(...future.oldOptions)
[10:32:56.891]             if (.Platform$OS.type == "windows") {
[10:32:56.891]                 old_names <- names(...future.oldEnvVars)
[10:32:56.891]                 envs <- base::Sys.getenv()
[10:32:56.891]                 names <- names(envs)
[10:32:56.891]                 common <- intersect(names, old_names)
[10:32:56.891]                 added <- setdiff(names, old_names)
[10:32:56.891]                 removed <- setdiff(old_names, names)
[10:32:56.891]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:56.891]                   envs[common]]
[10:32:56.891]                 NAMES <- toupper(changed)
[10:32:56.891]                 args <- list()
[10:32:56.891]                 for (kk in seq_along(NAMES)) {
[10:32:56.891]                   name <- changed[[kk]]
[10:32:56.891]                   NAME <- NAMES[[kk]]
[10:32:56.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.891]                     next
[10:32:56.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:56.891]                 }
[10:32:56.891]                 NAMES <- toupper(added)
[10:32:56.891]                 for (kk in seq_along(NAMES)) {
[10:32:56.891]                   name <- added[[kk]]
[10:32:56.891]                   NAME <- NAMES[[kk]]
[10:32:56.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.891]                     next
[10:32:56.891]                   args[[name]] <- ""
[10:32:56.891]                 }
[10:32:56.891]                 NAMES <- toupper(removed)
[10:32:56.891]                 for (kk in seq_along(NAMES)) {
[10:32:56.891]                   name <- removed[[kk]]
[10:32:56.891]                   NAME <- NAMES[[kk]]
[10:32:56.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.891]                     next
[10:32:56.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:56.891]                 }
[10:32:56.891]                 if (length(args) > 0) 
[10:32:56.891]                   base::do.call(base::Sys.setenv, args = args)
[10:32:56.891]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:56.891]             }
[10:32:56.891]             else {
[10:32:56.891]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:56.891]             }
[10:32:56.891]             {
[10:32:56.891]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:56.891]                   0L) {
[10:32:56.891]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:56.891]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:56.891]                   base::options(opts)
[10:32:56.891]                 }
[10:32:56.891]                 {
[10:32:56.891]                   {
[10:32:56.891]                     NULL
[10:32:56.891]                     RNGkind("Mersenne-Twister")
[10:32:56.891]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:56.891]                       inherits = FALSE)
[10:32:56.891]                   }
[10:32:56.891]                   options(future.plan = NULL)
[10:32:56.891]                   if (is.na(NA_character_)) 
[10:32:56.891]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:56.891]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:56.891]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:56.891]                     .init = FALSE)
[10:32:56.891]                 }
[10:32:56.891]             }
[10:32:56.891]         }
[10:32:56.891]     })
[10:32:56.891]     if (TRUE) {
[10:32:56.891]         base::sink(type = "output", split = FALSE)
[10:32:56.891]         if (TRUE) {
[10:32:56.891]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:56.891]         }
[10:32:56.891]         else {
[10:32:56.891]             ...future.result["stdout"] <- base::list(NULL)
[10:32:56.891]         }
[10:32:56.891]         base::close(...future.stdout)
[10:32:56.891]         ...future.stdout <- NULL
[10:32:56.891]     }
[10:32:56.891]     ...future.result$conditions <- ...future.conditions
[10:32:56.891]     ...future.result$finished <- base::Sys.time()
[10:32:56.891]     ...future.result
[10:32:56.891] }
[10:32:56.893] assign_globals() ...
[10:32:56.893] List of 2
[10:32:56.893]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:32:56.893]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:32:56.893]  - attr(*, "where")=List of 2
[10:32:56.893]   ..$ weight:<environment: R_EmptyEnv> 
[10:32:56.893]   ..$ group :<environment: R_EmptyEnv> 
[10:32:56.893]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:56.893]  - attr(*, "resolved")= logi FALSE
[10:32:56.893]  - attr(*, "total_size")= num 896
[10:32:56.893]  - attr(*, "already-done")= logi TRUE
[10:32:56.896] - copied ‘weight’ to environment
[10:32:56.896] - copied ‘group’ to environment
[10:32:56.896] assign_globals() ... done
[10:32:56.896] plan(): Setting new future strategy stack:
[10:32:56.896] List of future strategies:
[10:32:56.896] 1. sequential:
[10:32:56.896]    - args: function (..., envir = parent.frame())
[10:32:56.896]    - tweaked: FALSE
[10:32:56.896]    - call: NULL
[10:32:56.897] plan(): nbrOfWorkers() = 1
[10:32:56.898] plan(): Setting new future strategy stack:
[10:32:56.898] List of future strategies:
[10:32:56.898] 1. sequential:
[10:32:56.898]    - args: function (..., envir = parent.frame())
[10:32:56.898]    - tweaked: FALSE
[10:32:56.898]    - call: plan(strategy)
[10:32:56.899] plan(): nbrOfWorkers() = 1
[10:32:56.899] SequentialFuture started (and completed)
[10:32:56.899] - Launch lazy future ... done
[10:32:56.899] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:32:56.901] getGlobalsAndPackages() ...
[10:32:56.901] Searching for globals...
[10:32:56.903] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:32:56.903] Searching for globals ... DONE
[10:32:56.903] Resolving globals: FALSE
[10:32:56.903] The total size of the 2 globals is 896 bytes (896 bytes)
[10:32:56.904] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:32:56.904] - globals: [2] ‘weight’, ‘group’
[10:32:56.904] - packages: [1] ‘stats’
[10:32:56.904] getGlobalsAndPackages() ... DONE
[10:32:56.904] run() for ‘Future’ ...
[10:32:56.904] - state: ‘created’
[10:32:56.905] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:56.905] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:56.905] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:56.905]   - Field: ‘label’
[10:32:56.905]   - Field: ‘local’
[10:32:56.905]   - Field: ‘owner’
[10:32:56.905]   - Field: ‘envir’
[10:32:56.905]   - Field: ‘packages’
[10:32:56.906]   - Field: ‘gc’
[10:32:56.906]   - Field: ‘conditions’
[10:32:56.906]   - Field: ‘expr’
[10:32:56.906]   - Field: ‘uuid’
[10:32:56.906]   - Field: ‘seed’
[10:32:56.906]   - Field: ‘version’
[10:32:56.906]   - Field: ‘result’
[10:32:56.906]   - Field: ‘asynchronous’
[10:32:56.906]   - Field: ‘calls’
[10:32:56.906]   - Field: ‘globals’
[10:32:56.906]   - Field: ‘stdout’
[10:32:56.906]   - Field: ‘earlySignal’
[10:32:56.907]   - Field: ‘lazy’
[10:32:56.907]   - Field: ‘state’
[10:32:56.907] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:56.907] - Launch lazy future ...
[10:32:56.907] Packages needed by the future expression (n = 1): ‘stats’
[10:32:56.907] Packages needed by future strategies (n = 0): <none>
[10:32:56.909] {
[10:32:56.909]     {
[10:32:56.909]         {
[10:32:56.909]             ...future.startTime <- base::Sys.time()
[10:32:56.909]             {
[10:32:56.909]                 {
[10:32:56.909]                   {
[10:32:56.909]                     {
[10:32:56.909]                       base::local({
[10:32:56.909]                         has_future <- base::requireNamespace("future", 
[10:32:56.909]                           quietly = TRUE)
[10:32:56.909]                         if (has_future) {
[10:32:56.909]                           ns <- base::getNamespace("future")
[10:32:56.909]                           version <- ns[[".package"]][["version"]]
[10:32:56.909]                           if (is.null(version)) 
[10:32:56.909]                             version <- utils::packageVersion("future")
[10:32:56.909]                         }
[10:32:56.909]                         else {
[10:32:56.909]                           version <- NULL
[10:32:56.909]                         }
[10:32:56.909]                         if (!has_future || version < "1.8.0") {
[10:32:56.909]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:56.909]                             "", base::R.version$version.string), 
[10:32:56.909]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:56.909]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:56.909]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:56.909]                               "release", "version")], collapse = " "), 
[10:32:56.909]                             hostname = base::Sys.info()[["nodename"]])
[10:32:56.909]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:56.909]                             info)
[10:32:56.909]                           info <- base::paste(info, collapse = "; ")
[10:32:56.909]                           if (!has_future) {
[10:32:56.909]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:56.909]                               info)
[10:32:56.909]                           }
[10:32:56.909]                           else {
[10:32:56.909]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:56.909]                               info, version)
[10:32:56.909]                           }
[10:32:56.909]                           base::stop(msg)
[10:32:56.909]                         }
[10:32:56.909]                       })
[10:32:56.909]                     }
[10:32:56.909]                     base::local({
[10:32:56.909]                       for (pkg in "stats") {
[10:32:56.909]                         base::loadNamespace(pkg)
[10:32:56.909]                         base::library(pkg, character.only = TRUE)
[10:32:56.909]                       }
[10:32:56.909]                     })
[10:32:56.909]                   }
[10:32:56.909]                   ...future.strategy.old <- future::plan("list")
[10:32:56.909]                   options(future.plan = NULL)
[10:32:56.909]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:56.909]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:56.909]                 }
[10:32:56.909]                 ...future.workdir <- getwd()
[10:32:56.909]             }
[10:32:56.909]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:56.909]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:56.909]         }
[10:32:56.909]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:56.909]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:56.909]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:56.909]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:56.909]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:56.909]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:56.909]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:56.909]             base::names(...future.oldOptions))
[10:32:56.909]     }
[10:32:56.909]     if (FALSE) {
[10:32:56.909]     }
[10:32:56.909]     else {
[10:32:56.909]         if (TRUE) {
[10:32:56.909]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:56.909]                 open = "w")
[10:32:56.909]         }
[10:32:56.909]         else {
[10:32:56.909]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:56.909]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:56.909]         }
[10:32:56.909]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:56.909]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:56.909]             base::sink(type = "output", split = FALSE)
[10:32:56.909]             base::close(...future.stdout)
[10:32:56.909]         }, add = TRUE)
[10:32:56.909]     }
[10:32:56.909]     ...future.frame <- base::sys.nframe()
[10:32:56.909]     ...future.conditions <- base::list()
[10:32:56.909]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:56.909]     if (FALSE) {
[10:32:56.909]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:56.909]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:56.909]     }
[10:32:56.909]     ...future.result <- base::tryCatch({
[10:32:56.909]         base::withCallingHandlers({
[10:32:56.909]             ...future.value <- base::withVisible(base::local({
[10:32:56.909]                 lm(weight ~ group - 1)
[10:32:56.909]             }))
[10:32:56.909]             future::FutureResult(value = ...future.value$value, 
[10:32:56.909]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:56.909]                   ...future.rng), globalenv = if (FALSE) 
[10:32:56.909]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:56.909]                     ...future.globalenv.names))
[10:32:56.909]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:56.909]         }, condition = base::local({
[10:32:56.909]             c <- base::c
[10:32:56.909]             inherits <- base::inherits
[10:32:56.909]             invokeRestart <- base::invokeRestart
[10:32:56.909]             length <- base::length
[10:32:56.909]             list <- base::list
[10:32:56.909]             seq.int <- base::seq.int
[10:32:56.909]             signalCondition <- base::signalCondition
[10:32:56.909]             sys.calls <- base::sys.calls
[10:32:56.909]             `[[` <- base::`[[`
[10:32:56.909]             `+` <- base::`+`
[10:32:56.909]             `<<-` <- base::`<<-`
[10:32:56.909]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:56.909]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:56.909]                   3L)]
[10:32:56.909]             }
[10:32:56.909]             function(cond) {
[10:32:56.909]                 is_error <- inherits(cond, "error")
[10:32:56.909]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:56.909]                   NULL)
[10:32:56.909]                 if (is_error) {
[10:32:56.909]                   sessionInformation <- function() {
[10:32:56.909]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:56.909]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:56.909]                       search = base::search(), system = base::Sys.info())
[10:32:56.909]                   }
[10:32:56.909]                   ...future.conditions[[length(...future.conditions) + 
[10:32:56.909]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:56.909]                     cond$call), session = sessionInformation(), 
[10:32:56.909]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:56.909]                   signalCondition(cond)
[10:32:56.909]                 }
[10:32:56.909]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:56.909]                 "immediateCondition"))) {
[10:32:56.909]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:56.909]                   ...future.conditions[[length(...future.conditions) + 
[10:32:56.909]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:56.909]                   if (TRUE && !signal) {
[10:32:56.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:56.909]                     {
[10:32:56.909]                       inherits <- base::inherits
[10:32:56.909]                       invokeRestart <- base::invokeRestart
[10:32:56.909]                       is.null <- base::is.null
[10:32:56.909]                       muffled <- FALSE
[10:32:56.909]                       if (inherits(cond, "message")) {
[10:32:56.909]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:56.909]                         if (muffled) 
[10:32:56.909]                           invokeRestart("muffleMessage")
[10:32:56.909]                       }
[10:32:56.909]                       else if (inherits(cond, "warning")) {
[10:32:56.909]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:56.909]                         if (muffled) 
[10:32:56.909]                           invokeRestart("muffleWarning")
[10:32:56.909]                       }
[10:32:56.909]                       else if (inherits(cond, "condition")) {
[10:32:56.909]                         if (!is.null(pattern)) {
[10:32:56.909]                           computeRestarts <- base::computeRestarts
[10:32:56.909]                           grepl <- base::grepl
[10:32:56.909]                           restarts <- computeRestarts(cond)
[10:32:56.909]                           for (restart in restarts) {
[10:32:56.909]                             name <- restart$name
[10:32:56.909]                             if (is.null(name)) 
[10:32:56.909]                               next
[10:32:56.909]                             if (!grepl(pattern, name)) 
[10:32:56.909]                               next
[10:32:56.909]                             invokeRestart(restart)
[10:32:56.909]                             muffled <- TRUE
[10:32:56.909]                             break
[10:32:56.909]                           }
[10:32:56.909]                         }
[10:32:56.909]                       }
[10:32:56.909]                       invisible(muffled)
[10:32:56.909]                     }
[10:32:56.909]                     muffleCondition(cond, pattern = "^muffle")
[10:32:56.909]                   }
[10:32:56.909]                 }
[10:32:56.909]                 else {
[10:32:56.909]                   if (TRUE) {
[10:32:56.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:56.909]                     {
[10:32:56.909]                       inherits <- base::inherits
[10:32:56.909]                       invokeRestart <- base::invokeRestart
[10:32:56.909]                       is.null <- base::is.null
[10:32:56.909]                       muffled <- FALSE
[10:32:56.909]                       if (inherits(cond, "message")) {
[10:32:56.909]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:56.909]                         if (muffled) 
[10:32:56.909]                           invokeRestart("muffleMessage")
[10:32:56.909]                       }
[10:32:56.909]                       else if (inherits(cond, "warning")) {
[10:32:56.909]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:56.909]                         if (muffled) 
[10:32:56.909]                           invokeRestart("muffleWarning")
[10:32:56.909]                       }
[10:32:56.909]                       else if (inherits(cond, "condition")) {
[10:32:56.909]                         if (!is.null(pattern)) {
[10:32:56.909]                           computeRestarts <- base::computeRestarts
[10:32:56.909]                           grepl <- base::grepl
[10:32:56.909]                           restarts <- computeRestarts(cond)
[10:32:56.909]                           for (restart in restarts) {
[10:32:56.909]                             name <- restart$name
[10:32:56.909]                             if (is.null(name)) 
[10:32:56.909]                               next
[10:32:56.909]                             if (!grepl(pattern, name)) 
[10:32:56.909]                               next
[10:32:56.909]                             invokeRestart(restart)
[10:32:56.909]                             muffled <- TRUE
[10:32:56.909]                             break
[10:32:56.909]                           }
[10:32:56.909]                         }
[10:32:56.909]                       }
[10:32:56.909]                       invisible(muffled)
[10:32:56.909]                     }
[10:32:56.909]                     muffleCondition(cond, pattern = "^muffle")
[10:32:56.909]                   }
[10:32:56.909]                 }
[10:32:56.909]             }
[10:32:56.909]         }))
[10:32:56.909]     }, error = function(ex) {
[10:32:56.909]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:56.909]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:56.909]                 ...future.rng), started = ...future.startTime, 
[10:32:56.909]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:56.909]             version = "1.8"), class = "FutureResult")
[10:32:56.909]     }, finally = {
[10:32:56.909]         if (!identical(...future.workdir, getwd())) 
[10:32:56.909]             setwd(...future.workdir)
[10:32:56.909]         {
[10:32:56.909]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:56.909]                 ...future.oldOptions$nwarnings <- NULL
[10:32:56.909]             }
[10:32:56.909]             base::options(...future.oldOptions)
[10:32:56.909]             if (.Platform$OS.type == "windows") {
[10:32:56.909]                 old_names <- names(...future.oldEnvVars)
[10:32:56.909]                 envs <- base::Sys.getenv()
[10:32:56.909]                 names <- names(envs)
[10:32:56.909]                 common <- intersect(names, old_names)
[10:32:56.909]                 added <- setdiff(names, old_names)
[10:32:56.909]                 removed <- setdiff(old_names, names)
[10:32:56.909]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:56.909]                   envs[common]]
[10:32:56.909]                 NAMES <- toupper(changed)
[10:32:56.909]                 args <- list()
[10:32:56.909]                 for (kk in seq_along(NAMES)) {
[10:32:56.909]                   name <- changed[[kk]]
[10:32:56.909]                   NAME <- NAMES[[kk]]
[10:32:56.909]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.909]                     next
[10:32:56.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:56.909]                 }
[10:32:56.909]                 NAMES <- toupper(added)
[10:32:56.909]                 for (kk in seq_along(NAMES)) {
[10:32:56.909]                   name <- added[[kk]]
[10:32:56.909]                   NAME <- NAMES[[kk]]
[10:32:56.909]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.909]                     next
[10:32:56.909]                   args[[name]] <- ""
[10:32:56.909]                 }
[10:32:56.909]                 NAMES <- toupper(removed)
[10:32:56.909]                 for (kk in seq_along(NAMES)) {
[10:32:56.909]                   name <- removed[[kk]]
[10:32:56.909]                   NAME <- NAMES[[kk]]
[10:32:56.909]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.909]                     next
[10:32:56.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:56.909]                 }
[10:32:56.909]                 if (length(args) > 0) 
[10:32:56.909]                   base::do.call(base::Sys.setenv, args = args)
[10:32:56.909]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:56.909]             }
[10:32:56.909]             else {
[10:32:56.909]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:56.909]             }
[10:32:56.909]             {
[10:32:56.909]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:56.909]                   0L) {
[10:32:56.909]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:56.909]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:56.909]                   base::options(opts)
[10:32:56.909]                 }
[10:32:56.909]                 {
[10:32:56.909]                   {
[10:32:56.909]                     NULL
[10:32:56.909]                     RNGkind("Mersenne-Twister")
[10:32:56.909]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:56.909]                       inherits = FALSE)
[10:32:56.909]                   }
[10:32:56.909]                   options(future.plan = NULL)
[10:32:56.909]                   if (is.na(NA_character_)) 
[10:32:56.909]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:56.909]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:56.909]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:56.909]                     .init = FALSE)
[10:32:56.909]                 }
[10:32:56.909]             }
[10:32:56.909]         }
[10:32:56.909]     })
[10:32:56.909]     if (TRUE) {
[10:32:56.909]         base::sink(type = "output", split = FALSE)
[10:32:56.909]         if (TRUE) {
[10:32:56.909]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:56.909]         }
[10:32:56.909]         else {
[10:32:56.909]             ...future.result["stdout"] <- base::list(NULL)
[10:32:56.909]         }
[10:32:56.909]         base::close(...future.stdout)
[10:32:56.909]         ...future.stdout <- NULL
[10:32:56.909]     }
[10:32:56.909]     ...future.result$conditions <- ...future.conditions
[10:32:56.909]     ...future.result$finished <- base::Sys.time()
[10:32:56.909]     ...future.result
[10:32:56.909] }
[10:32:56.910] assign_globals() ...
[10:32:56.911] List of 2
[10:32:56.911]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:32:56.911]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:32:56.911]  - attr(*, "where")=List of 2
[10:32:56.911]   ..$ weight:<environment: R_EmptyEnv> 
[10:32:56.911]   ..$ group :<environment: R_EmptyEnv> 
[10:32:56.911]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:56.911]  - attr(*, "resolved")= logi FALSE
[10:32:56.911]  - attr(*, "total_size")= num 896
[10:32:56.911]  - attr(*, "already-done")= logi TRUE
[10:32:56.914] - copied ‘weight’ to environment
[10:32:56.914] - copied ‘group’ to environment
[10:32:56.914] assign_globals() ... done
[10:32:56.915] plan(): Setting new future strategy stack:
[10:32:56.915] List of future strategies:
[10:32:56.915] 1. sequential:
[10:32:56.915]    - args: function (..., envir = parent.frame())
[10:32:56.915]    - tweaked: FALSE
[10:32:56.915]    - call: NULL
[10:32:56.915] plan(): nbrOfWorkers() = 1
[10:32:56.917] plan(): Setting new future strategy stack:
[10:32:56.917] List of future strategies:
[10:32:56.917] 1. sequential:
[10:32:56.917]    - args: function (..., envir = parent.frame())
[10:32:56.917]    - tweaked: FALSE
[10:32:56.917]    - call: plan(strategy)
[10:32:56.917] plan(): nbrOfWorkers() = 1
[10:32:56.917] SequentialFuture started (and completed)
[10:32:56.917] - Launch lazy future ... done
[10:32:56.918] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:32:56.919] getGlobalsAndPackages() ...
[10:32:56.919] Searching for globals...
[10:32:56.921] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:32:56.921] Searching for globals ... DONE
[10:32:56.921] Resolving globals: FALSE
[10:32:56.922] The total size of the 2 globals is 896 bytes (896 bytes)
[10:32:56.922] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:32:56.922] - globals: [2] ‘weight’, ‘group’
[10:32:56.922] - packages: [1] ‘stats’
[10:32:56.922] getGlobalsAndPackages() ... DONE
[10:32:56.923] run() for ‘Future’ ...
[10:32:56.923] - state: ‘created’
[10:32:56.923] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:56.923] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:56.923] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:56.923]   - Field: ‘label’
[10:32:56.923]   - Field: ‘local’
[10:32:56.923]   - Field: ‘owner’
[10:32:56.923]   - Field: ‘envir’
[10:32:56.924]   - Field: ‘packages’
[10:32:56.924]   - Field: ‘gc’
[10:32:56.924]   - Field: ‘conditions’
[10:32:56.924]   - Field: ‘expr’
[10:32:56.924]   - Field: ‘uuid’
[10:32:56.924]   - Field: ‘seed’
[10:32:56.924]   - Field: ‘version’
[10:32:56.924]   - Field: ‘result’
[10:32:56.924]   - Field: ‘asynchronous’
[10:32:56.924]   - Field: ‘calls’
[10:32:56.924]   - Field: ‘globals’
[10:32:56.925]   - Field: ‘stdout’
[10:32:56.925]   - Field: ‘earlySignal’
[10:32:56.925]   - Field: ‘lazy’
[10:32:56.925]   - Field: ‘state’
[10:32:56.925] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:56.925] - Launch lazy future ...
[10:32:56.925] Packages needed by the future expression (n = 1): ‘stats’
[10:32:56.925] Packages needed by future strategies (n = 0): <none>
[10:32:56.926] {
[10:32:56.926]     {
[10:32:56.926]         {
[10:32:56.926]             ...future.startTime <- base::Sys.time()
[10:32:56.926]             {
[10:32:56.926]                 {
[10:32:56.926]                   {
[10:32:56.926]                     {
[10:32:56.926]                       base::local({
[10:32:56.926]                         has_future <- base::requireNamespace("future", 
[10:32:56.926]                           quietly = TRUE)
[10:32:56.926]                         if (has_future) {
[10:32:56.926]                           ns <- base::getNamespace("future")
[10:32:56.926]                           version <- ns[[".package"]][["version"]]
[10:32:56.926]                           if (is.null(version)) 
[10:32:56.926]                             version <- utils::packageVersion("future")
[10:32:56.926]                         }
[10:32:56.926]                         else {
[10:32:56.926]                           version <- NULL
[10:32:56.926]                         }
[10:32:56.926]                         if (!has_future || version < "1.8.0") {
[10:32:56.926]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:56.926]                             "", base::R.version$version.string), 
[10:32:56.926]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:56.926]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:56.926]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:56.926]                               "release", "version")], collapse = " "), 
[10:32:56.926]                             hostname = base::Sys.info()[["nodename"]])
[10:32:56.926]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:56.926]                             info)
[10:32:56.926]                           info <- base::paste(info, collapse = "; ")
[10:32:56.926]                           if (!has_future) {
[10:32:56.926]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:56.926]                               info)
[10:32:56.926]                           }
[10:32:56.926]                           else {
[10:32:56.926]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:56.926]                               info, version)
[10:32:56.926]                           }
[10:32:56.926]                           base::stop(msg)
[10:32:56.926]                         }
[10:32:56.926]                       })
[10:32:56.926]                     }
[10:32:56.926]                     base::local({
[10:32:56.926]                       for (pkg in "stats") {
[10:32:56.926]                         base::loadNamespace(pkg)
[10:32:56.926]                         base::library(pkg, character.only = TRUE)
[10:32:56.926]                       }
[10:32:56.926]                     })
[10:32:56.926]                   }
[10:32:56.926]                   ...future.strategy.old <- future::plan("list")
[10:32:56.926]                   options(future.plan = NULL)
[10:32:56.926]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:56.926]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:56.926]                 }
[10:32:56.926]                 ...future.workdir <- getwd()
[10:32:56.926]             }
[10:32:56.926]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:56.926]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:56.926]         }
[10:32:56.926]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:56.926]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:56.926]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:56.926]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:56.926]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:56.926]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:56.926]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:56.926]             base::names(...future.oldOptions))
[10:32:56.926]     }
[10:32:56.926]     if (FALSE) {
[10:32:56.926]     }
[10:32:56.926]     else {
[10:32:56.926]         if (TRUE) {
[10:32:56.926]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:56.926]                 open = "w")
[10:32:56.926]         }
[10:32:56.926]         else {
[10:32:56.926]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:56.926]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:56.926]         }
[10:32:56.926]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:56.926]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:56.926]             base::sink(type = "output", split = FALSE)
[10:32:56.926]             base::close(...future.stdout)
[10:32:56.926]         }, add = TRUE)
[10:32:56.926]     }
[10:32:56.926]     ...future.frame <- base::sys.nframe()
[10:32:56.926]     ...future.conditions <- base::list()
[10:32:56.926]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:56.926]     if (FALSE) {
[10:32:56.926]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:56.926]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:56.926]     }
[10:32:56.926]     ...future.result <- base::tryCatch({
[10:32:56.926]         base::withCallingHandlers({
[10:32:56.926]             ...future.value <- base::withVisible(base::local({
[10:32:56.926]                 lm(weight ~ group - 1)
[10:32:56.926]             }))
[10:32:56.926]             future::FutureResult(value = ...future.value$value, 
[10:32:56.926]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:56.926]                   ...future.rng), globalenv = if (FALSE) 
[10:32:56.926]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:56.926]                     ...future.globalenv.names))
[10:32:56.926]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:56.926]         }, condition = base::local({
[10:32:56.926]             c <- base::c
[10:32:56.926]             inherits <- base::inherits
[10:32:56.926]             invokeRestart <- base::invokeRestart
[10:32:56.926]             length <- base::length
[10:32:56.926]             list <- base::list
[10:32:56.926]             seq.int <- base::seq.int
[10:32:56.926]             signalCondition <- base::signalCondition
[10:32:56.926]             sys.calls <- base::sys.calls
[10:32:56.926]             `[[` <- base::`[[`
[10:32:56.926]             `+` <- base::`+`
[10:32:56.926]             `<<-` <- base::`<<-`
[10:32:56.926]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:56.926]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:56.926]                   3L)]
[10:32:56.926]             }
[10:32:56.926]             function(cond) {
[10:32:56.926]                 is_error <- inherits(cond, "error")
[10:32:56.926]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:56.926]                   NULL)
[10:32:56.926]                 if (is_error) {
[10:32:56.926]                   sessionInformation <- function() {
[10:32:56.926]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:56.926]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:56.926]                       search = base::search(), system = base::Sys.info())
[10:32:56.926]                   }
[10:32:56.926]                   ...future.conditions[[length(...future.conditions) + 
[10:32:56.926]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:56.926]                     cond$call), session = sessionInformation(), 
[10:32:56.926]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:56.926]                   signalCondition(cond)
[10:32:56.926]                 }
[10:32:56.926]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:56.926]                 "immediateCondition"))) {
[10:32:56.926]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:56.926]                   ...future.conditions[[length(...future.conditions) + 
[10:32:56.926]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:56.926]                   if (TRUE && !signal) {
[10:32:56.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:56.926]                     {
[10:32:56.926]                       inherits <- base::inherits
[10:32:56.926]                       invokeRestart <- base::invokeRestart
[10:32:56.926]                       is.null <- base::is.null
[10:32:56.926]                       muffled <- FALSE
[10:32:56.926]                       if (inherits(cond, "message")) {
[10:32:56.926]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:56.926]                         if (muffled) 
[10:32:56.926]                           invokeRestart("muffleMessage")
[10:32:56.926]                       }
[10:32:56.926]                       else if (inherits(cond, "warning")) {
[10:32:56.926]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:56.926]                         if (muffled) 
[10:32:56.926]                           invokeRestart("muffleWarning")
[10:32:56.926]                       }
[10:32:56.926]                       else if (inherits(cond, "condition")) {
[10:32:56.926]                         if (!is.null(pattern)) {
[10:32:56.926]                           computeRestarts <- base::computeRestarts
[10:32:56.926]                           grepl <- base::grepl
[10:32:56.926]                           restarts <- computeRestarts(cond)
[10:32:56.926]                           for (restart in restarts) {
[10:32:56.926]                             name <- restart$name
[10:32:56.926]                             if (is.null(name)) 
[10:32:56.926]                               next
[10:32:56.926]                             if (!grepl(pattern, name)) 
[10:32:56.926]                               next
[10:32:56.926]                             invokeRestart(restart)
[10:32:56.926]                             muffled <- TRUE
[10:32:56.926]                             break
[10:32:56.926]                           }
[10:32:56.926]                         }
[10:32:56.926]                       }
[10:32:56.926]                       invisible(muffled)
[10:32:56.926]                     }
[10:32:56.926]                     muffleCondition(cond, pattern = "^muffle")
[10:32:56.926]                   }
[10:32:56.926]                 }
[10:32:56.926]                 else {
[10:32:56.926]                   if (TRUE) {
[10:32:56.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:56.926]                     {
[10:32:56.926]                       inherits <- base::inherits
[10:32:56.926]                       invokeRestart <- base::invokeRestart
[10:32:56.926]                       is.null <- base::is.null
[10:32:56.926]                       muffled <- FALSE
[10:32:56.926]                       if (inherits(cond, "message")) {
[10:32:56.926]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:56.926]                         if (muffled) 
[10:32:56.926]                           invokeRestart("muffleMessage")
[10:32:56.926]                       }
[10:32:56.926]                       else if (inherits(cond, "warning")) {
[10:32:56.926]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:56.926]                         if (muffled) 
[10:32:56.926]                           invokeRestart("muffleWarning")
[10:32:56.926]                       }
[10:32:56.926]                       else if (inherits(cond, "condition")) {
[10:32:56.926]                         if (!is.null(pattern)) {
[10:32:56.926]                           computeRestarts <- base::computeRestarts
[10:32:56.926]                           grepl <- base::grepl
[10:32:56.926]                           restarts <- computeRestarts(cond)
[10:32:56.926]                           for (restart in restarts) {
[10:32:56.926]                             name <- restart$name
[10:32:56.926]                             if (is.null(name)) 
[10:32:56.926]                               next
[10:32:56.926]                             if (!grepl(pattern, name)) 
[10:32:56.926]                               next
[10:32:56.926]                             invokeRestart(restart)
[10:32:56.926]                             muffled <- TRUE
[10:32:56.926]                             break
[10:32:56.926]                           }
[10:32:56.926]                         }
[10:32:56.926]                       }
[10:32:56.926]                       invisible(muffled)
[10:32:56.926]                     }
[10:32:56.926]                     muffleCondition(cond, pattern = "^muffle")
[10:32:56.926]                   }
[10:32:56.926]                 }
[10:32:56.926]             }
[10:32:56.926]         }))
[10:32:56.926]     }, error = function(ex) {
[10:32:56.926]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:56.926]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:56.926]                 ...future.rng), started = ...future.startTime, 
[10:32:56.926]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:56.926]             version = "1.8"), class = "FutureResult")
[10:32:56.926]     }, finally = {
[10:32:56.926]         if (!identical(...future.workdir, getwd())) 
[10:32:56.926]             setwd(...future.workdir)
[10:32:56.926]         {
[10:32:56.926]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:56.926]                 ...future.oldOptions$nwarnings <- NULL
[10:32:56.926]             }
[10:32:56.926]             base::options(...future.oldOptions)
[10:32:56.926]             if (.Platform$OS.type == "windows") {
[10:32:56.926]                 old_names <- names(...future.oldEnvVars)
[10:32:56.926]                 envs <- base::Sys.getenv()
[10:32:56.926]                 names <- names(envs)
[10:32:56.926]                 common <- intersect(names, old_names)
[10:32:56.926]                 added <- setdiff(names, old_names)
[10:32:56.926]                 removed <- setdiff(old_names, names)
[10:32:56.926]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:56.926]                   envs[common]]
[10:32:56.926]                 NAMES <- toupper(changed)
[10:32:56.926]                 args <- list()
[10:32:56.926]                 for (kk in seq_along(NAMES)) {
[10:32:56.926]                   name <- changed[[kk]]
[10:32:56.926]                   NAME <- NAMES[[kk]]
[10:32:56.926]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.926]                     next
[10:32:56.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:56.926]                 }
[10:32:56.926]                 NAMES <- toupper(added)
[10:32:56.926]                 for (kk in seq_along(NAMES)) {
[10:32:56.926]                   name <- added[[kk]]
[10:32:56.926]                   NAME <- NAMES[[kk]]
[10:32:56.926]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.926]                     next
[10:32:56.926]                   args[[name]] <- ""
[10:32:56.926]                 }
[10:32:56.926]                 NAMES <- toupper(removed)
[10:32:56.926]                 for (kk in seq_along(NAMES)) {
[10:32:56.926]                   name <- removed[[kk]]
[10:32:56.926]                   NAME <- NAMES[[kk]]
[10:32:56.926]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.926]                     next
[10:32:56.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:56.926]                 }
[10:32:56.926]                 if (length(args) > 0) 
[10:32:56.926]                   base::do.call(base::Sys.setenv, args = args)
[10:32:56.926]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:56.926]             }
[10:32:56.926]             else {
[10:32:56.926]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:56.926]             }
[10:32:56.926]             {
[10:32:56.926]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:56.926]                   0L) {
[10:32:56.926]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:56.926]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:56.926]                   base::options(opts)
[10:32:56.926]                 }
[10:32:56.926]                 {
[10:32:56.926]                   {
[10:32:56.926]                     NULL
[10:32:56.926]                     RNGkind("Mersenne-Twister")
[10:32:56.926]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:56.926]                       inherits = FALSE)
[10:32:56.926]                   }
[10:32:56.926]                   options(future.plan = NULL)
[10:32:56.926]                   if (is.na(NA_character_)) 
[10:32:56.926]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:56.926]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:56.926]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:56.926]                     .init = FALSE)
[10:32:56.926]                 }
[10:32:56.926]             }
[10:32:56.926]         }
[10:32:56.926]     })
[10:32:56.926]     if (TRUE) {
[10:32:56.926]         base::sink(type = "output", split = FALSE)
[10:32:56.926]         if (TRUE) {
[10:32:56.926]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:56.926]         }
[10:32:56.926]         else {
[10:32:56.926]             ...future.result["stdout"] <- base::list(NULL)
[10:32:56.926]         }
[10:32:56.926]         base::close(...future.stdout)
[10:32:56.926]         ...future.stdout <- NULL
[10:32:56.926]     }
[10:32:56.926]     ...future.result$conditions <- ...future.conditions
[10:32:56.926]     ...future.result$finished <- base::Sys.time()
[10:32:56.926]     ...future.result
[10:32:56.926] }
[10:32:56.927] assign_globals() ...
[10:32:56.928] List of 2
[10:32:56.928]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:32:56.928]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:32:56.928]  - attr(*, "where")=List of 2
[10:32:56.928]   ..$ weight:<environment: R_EmptyEnv> 
[10:32:56.928]   ..$ group :<environment: R_EmptyEnv> 
[10:32:56.928]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:56.928]  - attr(*, "resolved")= logi FALSE
[10:32:56.928]  - attr(*, "total_size")= num 896
[10:32:56.928]  - attr(*, "already-done")= logi TRUE
[10:32:56.930] - copied ‘weight’ to environment
[10:32:56.931] - copied ‘group’ to environment
[10:32:56.931] assign_globals() ... done
[10:32:56.931] plan(): Setting new future strategy stack:
[10:32:56.931] List of future strategies:
[10:32:56.931] 1. sequential:
[10:32:56.931]    - args: function (..., envir = parent.frame())
[10:32:56.931]    - tweaked: FALSE
[10:32:56.931]    - call: NULL
[10:32:56.931] plan(): nbrOfWorkers() = 1
[10:32:56.933] plan(): Setting new future strategy stack:
[10:32:56.933] List of future strategies:
[10:32:56.933] 1. sequential:
[10:32:56.933]    - args: function (..., envir = parent.frame())
[10:32:56.933]    - tweaked: FALSE
[10:32:56.933]    - call: plan(strategy)
[10:32:56.933] plan(): nbrOfWorkers() = 1
[10:32:56.933] SequentialFuture started (and completed)
[10:32:56.934] - Launch lazy future ... done
[10:32:56.934] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:32:56.937] getGlobalsAndPackages() ...
[10:32:56.937] Searching for globals...
[10:32:56.938] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:32:56.938] Searching for globals ... DONE
[10:32:56.939] Resolving globals: FALSE
[10:32:56.939] The total size of the 2 globals is 896 bytes (896 bytes)
[10:32:56.939] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:32:56.940] - globals: [2] ‘weight’, ‘group’
[10:32:56.940] - packages: [1] ‘stats’
[10:32:56.940] getGlobalsAndPackages() ... DONE
[10:32:56.940] run() for ‘Future’ ...
[10:32:56.940] - state: ‘created’
[10:32:56.940] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:56.940] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:56.941] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:56.941]   - Field: ‘label’
[10:32:56.941]   - Field: ‘local’
[10:32:56.941]   - Field: ‘owner’
[10:32:56.941]   - Field: ‘envir’
[10:32:56.941]   - Field: ‘packages’
[10:32:56.941]   - Field: ‘gc’
[10:32:56.941]   - Field: ‘conditions’
[10:32:56.941]   - Field: ‘expr’
[10:32:56.941]   - Field: ‘uuid’
[10:32:56.942]   - Field: ‘seed’
[10:32:56.942]   - Field: ‘version’
[10:32:56.942]   - Field: ‘result’
[10:32:56.942]   - Field: ‘asynchronous’
[10:32:56.942]   - Field: ‘calls’
[10:32:56.942]   - Field: ‘globals’
[10:32:56.942]   - Field: ‘stdout’
[10:32:56.942]   - Field: ‘earlySignal’
[10:32:56.942]   - Field: ‘lazy’
[10:32:56.942]   - Field: ‘state’
[10:32:56.942] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:56.943] - Launch lazy future ...
[10:32:56.943] Packages needed by the future expression (n = 1): ‘stats’
[10:32:56.943] Packages needed by future strategies (n = 0): <none>
[10:32:56.943] {
[10:32:56.943]     {
[10:32:56.943]         {
[10:32:56.943]             ...future.startTime <- base::Sys.time()
[10:32:56.943]             {
[10:32:56.943]                 {
[10:32:56.943]                   {
[10:32:56.943]                     {
[10:32:56.943]                       base::local({
[10:32:56.943]                         has_future <- base::requireNamespace("future", 
[10:32:56.943]                           quietly = TRUE)
[10:32:56.943]                         if (has_future) {
[10:32:56.943]                           ns <- base::getNamespace("future")
[10:32:56.943]                           version <- ns[[".package"]][["version"]]
[10:32:56.943]                           if (is.null(version)) 
[10:32:56.943]                             version <- utils::packageVersion("future")
[10:32:56.943]                         }
[10:32:56.943]                         else {
[10:32:56.943]                           version <- NULL
[10:32:56.943]                         }
[10:32:56.943]                         if (!has_future || version < "1.8.0") {
[10:32:56.943]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:56.943]                             "", base::R.version$version.string), 
[10:32:56.943]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:56.943]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:56.943]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:56.943]                               "release", "version")], collapse = " "), 
[10:32:56.943]                             hostname = base::Sys.info()[["nodename"]])
[10:32:56.943]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:56.943]                             info)
[10:32:56.943]                           info <- base::paste(info, collapse = "; ")
[10:32:56.943]                           if (!has_future) {
[10:32:56.943]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:56.943]                               info)
[10:32:56.943]                           }
[10:32:56.943]                           else {
[10:32:56.943]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:56.943]                               info, version)
[10:32:56.943]                           }
[10:32:56.943]                           base::stop(msg)
[10:32:56.943]                         }
[10:32:56.943]                       })
[10:32:56.943]                     }
[10:32:56.943]                     base::local({
[10:32:56.943]                       for (pkg in "stats") {
[10:32:56.943]                         base::loadNamespace(pkg)
[10:32:56.943]                         base::library(pkg, character.only = TRUE)
[10:32:56.943]                       }
[10:32:56.943]                     })
[10:32:56.943]                   }
[10:32:56.943]                   ...future.strategy.old <- future::plan("list")
[10:32:56.943]                   options(future.plan = NULL)
[10:32:56.943]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:56.943]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:56.943]                 }
[10:32:56.943]                 ...future.workdir <- getwd()
[10:32:56.943]             }
[10:32:56.943]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:56.943]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:56.943]         }
[10:32:56.943]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:56.943]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:56.943]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:56.943]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:56.943]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:56.943]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:56.943]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:56.943]             base::names(...future.oldOptions))
[10:32:56.943]     }
[10:32:56.943]     if (FALSE) {
[10:32:56.943]     }
[10:32:56.943]     else {
[10:32:56.943]         if (TRUE) {
[10:32:56.943]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:56.943]                 open = "w")
[10:32:56.943]         }
[10:32:56.943]         else {
[10:32:56.943]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:56.943]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:56.943]         }
[10:32:56.943]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:56.943]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:56.943]             base::sink(type = "output", split = FALSE)
[10:32:56.943]             base::close(...future.stdout)
[10:32:56.943]         }, add = TRUE)
[10:32:56.943]     }
[10:32:56.943]     ...future.frame <- base::sys.nframe()
[10:32:56.943]     ...future.conditions <- base::list()
[10:32:56.943]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:56.943]     if (FALSE) {
[10:32:56.943]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:56.943]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:56.943]     }
[10:32:56.943]     ...future.result <- base::tryCatch({
[10:32:56.943]         base::withCallingHandlers({
[10:32:56.943]             ...future.value <- base::withVisible(base::local({
[10:32:56.943]                 lm(weight ~ group - 1)
[10:32:56.943]             }))
[10:32:56.943]             future::FutureResult(value = ...future.value$value, 
[10:32:56.943]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:56.943]                   ...future.rng), globalenv = if (FALSE) 
[10:32:56.943]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:56.943]                     ...future.globalenv.names))
[10:32:56.943]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:56.943]         }, condition = base::local({
[10:32:56.943]             c <- base::c
[10:32:56.943]             inherits <- base::inherits
[10:32:56.943]             invokeRestart <- base::invokeRestart
[10:32:56.943]             length <- base::length
[10:32:56.943]             list <- base::list
[10:32:56.943]             seq.int <- base::seq.int
[10:32:56.943]             signalCondition <- base::signalCondition
[10:32:56.943]             sys.calls <- base::sys.calls
[10:32:56.943]             `[[` <- base::`[[`
[10:32:56.943]             `+` <- base::`+`
[10:32:56.943]             `<<-` <- base::`<<-`
[10:32:56.943]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:56.943]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:56.943]                   3L)]
[10:32:56.943]             }
[10:32:56.943]             function(cond) {
[10:32:56.943]                 is_error <- inherits(cond, "error")
[10:32:56.943]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:56.943]                   NULL)
[10:32:56.943]                 if (is_error) {
[10:32:56.943]                   sessionInformation <- function() {
[10:32:56.943]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:56.943]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:56.943]                       search = base::search(), system = base::Sys.info())
[10:32:56.943]                   }
[10:32:56.943]                   ...future.conditions[[length(...future.conditions) + 
[10:32:56.943]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:56.943]                     cond$call), session = sessionInformation(), 
[10:32:56.943]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:56.943]                   signalCondition(cond)
[10:32:56.943]                 }
[10:32:56.943]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:56.943]                 "immediateCondition"))) {
[10:32:56.943]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:56.943]                   ...future.conditions[[length(...future.conditions) + 
[10:32:56.943]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:56.943]                   if (TRUE && !signal) {
[10:32:56.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:56.943]                     {
[10:32:56.943]                       inherits <- base::inherits
[10:32:56.943]                       invokeRestart <- base::invokeRestart
[10:32:56.943]                       is.null <- base::is.null
[10:32:56.943]                       muffled <- FALSE
[10:32:56.943]                       if (inherits(cond, "message")) {
[10:32:56.943]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:56.943]                         if (muffled) 
[10:32:56.943]                           invokeRestart("muffleMessage")
[10:32:56.943]                       }
[10:32:56.943]                       else if (inherits(cond, "warning")) {
[10:32:56.943]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:56.943]                         if (muffled) 
[10:32:56.943]                           invokeRestart("muffleWarning")
[10:32:56.943]                       }
[10:32:56.943]                       else if (inherits(cond, "condition")) {
[10:32:56.943]                         if (!is.null(pattern)) {
[10:32:56.943]                           computeRestarts <- base::computeRestarts
[10:32:56.943]                           grepl <- base::grepl
[10:32:56.943]                           restarts <- computeRestarts(cond)
[10:32:56.943]                           for (restart in restarts) {
[10:32:56.943]                             name <- restart$name
[10:32:56.943]                             if (is.null(name)) 
[10:32:56.943]                               next
[10:32:56.943]                             if (!grepl(pattern, name)) 
[10:32:56.943]                               next
[10:32:56.943]                             invokeRestart(restart)
[10:32:56.943]                             muffled <- TRUE
[10:32:56.943]                             break
[10:32:56.943]                           }
[10:32:56.943]                         }
[10:32:56.943]                       }
[10:32:56.943]                       invisible(muffled)
[10:32:56.943]                     }
[10:32:56.943]                     muffleCondition(cond, pattern = "^muffle")
[10:32:56.943]                   }
[10:32:56.943]                 }
[10:32:56.943]                 else {
[10:32:56.943]                   if (TRUE) {
[10:32:56.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:56.943]                     {
[10:32:56.943]                       inherits <- base::inherits
[10:32:56.943]                       invokeRestart <- base::invokeRestart
[10:32:56.943]                       is.null <- base::is.null
[10:32:56.943]                       muffled <- FALSE
[10:32:56.943]                       if (inherits(cond, "message")) {
[10:32:56.943]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:56.943]                         if (muffled) 
[10:32:56.943]                           invokeRestart("muffleMessage")
[10:32:56.943]                       }
[10:32:56.943]                       else if (inherits(cond, "warning")) {
[10:32:56.943]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:56.943]                         if (muffled) 
[10:32:56.943]                           invokeRestart("muffleWarning")
[10:32:56.943]                       }
[10:32:56.943]                       else if (inherits(cond, "condition")) {
[10:32:56.943]                         if (!is.null(pattern)) {
[10:32:56.943]                           computeRestarts <- base::computeRestarts
[10:32:56.943]                           grepl <- base::grepl
[10:32:56.943]                           restarts <- computeRestarts(cond)
[10:32:56.943]                           for (restart in restarts) {
[10:32:56.943]                             name <- restart$name
[10:32:56.943]                             if (is.null(name)) 
[10:32:56.943]                               next
[10:32:56.943]                             if (!grepl(pattern, name)) 
[10:32:56.943]                               next
[10:32:56.943]                             invokeRestart(restart)
[10:32:56.943]                             muffled <- TRUE
[10:32:56.943]                             break
[10:32:56.943]                           }
[10:32:56.943]                         }
[10:32:56.943]                       }
[10:32:56.943]                       invisible(muffled)
[10:32:56.943]                     }
[10:32:56.943]                     muffleCondition(cond, pattern = "^muffle")
[10:32:56.943]                   }
[10:32:56.943]                 }
[10:32:56.943]             }
[10:32:56.943]         }))
[10:32:56.943]     }, error = function(ex) {
[10:32:56.943]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:56.943]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:56.943]                 ...future.rng), started = ...future.startTime, 
[10:32:56.943]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:56.943]             version = "1.8"), class = "FutureResult")
[10:32:56.943]     }, finally = {
[10:32:56.943]         if (!identical(...future.workdir, getwd())) 
[10:32:56.943]             setwd(...future.workdir)
[10:32:56.943]         {
[10:32:56.943]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:56.943]                 ...future.oldOptions$nwarnings <- NULL
[10:32:56.943]             }
[10:32:56.943]             base::options(...future.oldOptions)
[10:32:56.943]             if (.Platform$OS.type == "windows") {
[10:32:56.943]                 old_names <- names(...future.oldEnvVars)
[10:32:56.943]                 envs <- base::Sys.getenv()
[10:32:56.943]                 names <- names(envs)
[10:32:56.943]                 common <- intersect(names, old_names)
[10:32:56.943]                 added <- setdiff(names, old_names)
[10:32:56.943]                 removed <- setdiff(old_names, names)
[10:32:56.943]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:56.943]                   envs[common]]
[10:32:56.943]                 NAMES <- toupper(changed)
[10:32:56.943]                 args <- list()
[10:32:56.943]                 for (kk in seq_along(NAMES)) {
[10:32:56.943]                   name <- changed[[kk]]
[10:32:56.943]                   NAME <- NAMES[[kk]]
[10:32:56.943]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.943]                     next
[10:32:56.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:56.943]                 }
[10:32:56.943]                 NAMES <- toupper(added)
[10:32:56.943]                 for (kk in seq_along(NAMES)) {
[10:32:56.943]                   name <- added[[kk]]
[10:32:56.943]                   NAME <- NAMES[[kk]]
[10:32:56.943]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.943]                     next
[10:32:56.943]                   args[[name]] <- ""
[10:32:56.943]                 }
[10:32:56.943]                 NAMES <- toupper(removed)
[10:32:56.943]                 for (kk in seq_along(NAMES)) {
[10:32:56.943]                   name <- removed[[kk]]
[10:32:56.943]                   NAME <- NAMES[[kk]]
[10:32:56.943]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.943]                     next
[10:32:56.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:56.943]                 }
[10:32:56.943]                 if (length(args) > 0) 
[10:32:56.943]                   base::do.call(base::Sys.setenv, args = args)
[10:32:56.943]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:56.943]             }
[10:32:56.943]             else {
[10:32:56.943]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:56.943]             }
[10:32:56.943]             {
[10:32:56.943]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:56.943]                   0L) {
[10:32:56.943]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:56.943]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:56.943]                   base::options(opts)
[10:32:56.943]                 }
[10:32:56.943]                 {
[10:32:56.943]                   {
[10:32:56.943]                     NULL
[10:32:56.943]                     RNGkind("Mersenne-Twister")
[10:32:56.943]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:56.943]                       inherits = FALSE)
[10:32:56.943]                   }
[10:32:56.943]                   options(future.plan = NULL)
[10:32:56.943]                   if (is.na(NA_character_)) 
[10:32:56.943]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:56.943]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:56.943]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:56.943]                     .init = FALSE)
[10:32:56.943]                 }
[10:32:56.943]             }
[10:32:56.943]         }
[10:32:56.943]     })
[10:32:56.943]     if (TRUE) {
[10:32:56.943]         base::sink(type = "output", split = FALSE)
[10:32:56.943]         if (TRUE) {
[10:32:56.943]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:56.943]         }
[10:32:56.943]         else {
[10:32:56.943]             ...future.result["stdout"] <- base::list(NULL)
[10:32:56.943]         }
[10:32:56.943]         base::close(...future.stdout)
[10:32:56.943]         ...future.stdout <- NULL
[10:32:56.943]     }
[10:32:56.943]     ...future.result$conditions <- ...future.conditions
[10:32:56.943]     ...future.result$finished <- base::Sys.time()
[10:32:56.943]     ...future.result
[10:32:56.943] }
[10:32:56.945] assign_globals() ...
[10:32:56.945] List of 2
[10:32:56.945]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:32:56.945]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:32:56.945]  - attr(*, "where")=List of 2
[10:32:56.945]   ..$ weight:<environment: R_EmptyEnv> 
[10:32:56.945]   ..$ group :<environment: R_EmptyEnv> 
[10:32:56.945]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:56.945]  - attr(*, "resolved")= logi FALSE
[10:32:56.945]  - attr(*, "total_size")= num 896
[10:32:56.945]  - attr(*, "already-done")= logi TRUE
[10:32:56.948] - copied ‘weight’ to environment
[10:32:56.948] - copied ‘group’ to environment
[10:32:56.948] assign_globals() ... done
[10:32:56.948] plan(): Setting new future strategy stack:
[10:32:56.948] List of future strategies:
[10:32:56.948] 1. sequential:
[10:32:56.948]    - args: function (..., envir = parent.frame())
[10:32:56.948]    - tweaked: FALSE
[10:32:56.948]    - call: NULL
[10:32:56.949] plan(): nbrOfWorkers() = 1
[10:32:56.950] plan(): Setting new future strategy stack:
[10:32:56.950] List of future strategies:
[10:32:56.950] 1. sequential:
[10:32:56.950]    - args: function (..., envir = parent.frame())
[10:32:56.950]    - tweaked: FALSE
[10:32:56.950]    - call: plan(strategy)
[10:32:56.951] plan(): nbrOfWorkers() = 1
[10:32:56.951] SequentialFuture started (and completed)
[10:32:56.951] - Launch lazy future ... done
[10:32:56.951] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[10:32:56.952] getGlobalsAndPackages() ...
[10:32:56.953] Searching for globals...
[10:32:56.954] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[10:32:56.954] Searching for globals ... DONE
[10:32:56.954] Resolving globals: FALSE
[10:32:56.954] The total size of the 1 globals is 96 bytes (96 bytes)
[10:32:56.954] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[10:32:56.955] - globals: [1] ‘x’
[10:32:56.955] - packages: [1] ‘stats’
[10:32:56.955] getGlobalsAndPackages() ... DONE
[10:32:56.955] run() for ‘Future’ ...
[10:32:56.955] - state: ‘created’
[10:32:56.955] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:56.956] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:56.956] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:56.956]   - Field: ‘label’
[10:32:56.956]   - Field: ‘local’
[10:32:56.956]   - Field: ‘owner’
[10:32:56.956]   - Field: ‘envir’
[10:32:56.956]   - Field: ‘packages’
[10:32:56.956]   - Field: ‘gc’
[10:32:56.956]   - Field: ‘conditions’
[10:32:56.956]   - Field: ‘expr’
[10:32:56.956]   - Field: ‘uuid’
[10:32:56.957]   - Field: ‘seed’
[10:32:56.958]   - Field: ‘version’
[10:32:56.958]   - Field: ‘result’
[10:32:56.958]   - Field: ‘asynchronous’
[10:32:56.958]   - Field: ‘calls’
[10:32:56.958]   - Field: ‘globals’
[10:32:56.958]   - Field: ‘stdout’
[10:32:56.958]   - Field: ‘earlySignal’
[10:32:56.958]   - Field: ‘lazy’
[10:32:56.959]   - Field: ‘state’
[10:32:56.959] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:56.959] - Launch lazy future ...
[10:32:56.959] Packages needed by the future expression (n = 1): ‘stats’
[10:32:56.959] Packages needed by future strategies (n = 0): <none>
[10:32:56.959] {
[10:32:56.959]     {
[10:32:56.959]         {
[10:32:56.959]             ...future.startTime <- base::Sys.time()
[10:32:56.959]             {
[10:32:56.959]                 {
[10:32:56.959]                   {
[10:32:56.959]                     {
[10:32:56.959]                       base::local({
[10:32:56.959]                         has_future <- base::requireNamespace("future", 
[10:32:56.959]                           quietly = TRUE)
[10:32:56.959]                         if (has_future) {
[10:32:56.959]                           ns <- base::getNamespace("future")
[10:32:56.959]                           version <- ns[[".package"]][["version"]]
[10:32:56.959]                           if (is.null(version)) 
[10:32:56.959]                             version <- utils::packageVersion("future")
[10:32:56.959]                         }
[10:32:56.959]                         else {
[10:32:56.959]                           version <- NULL
[10:32:56.959]                         }
[10:32:56.959]                         if (!has_future || version < "1.8.0") {
[10:32:56.959]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:56.959]                             "", base::R.version$version.string), 
[10:32:56.959]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:56.959]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:56.959]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:56.959]                               "release", "version")], collapse = " "), 
[10:32:56.959]                             hostname = base::Sys.info()[["nodename"]])
[10:32:56.959]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:56.959]                             info)
[10:32:56.959]                           info <- base::paste(info, collapse = "; ")
[10:32:56.959]                           if (!has_future) {
[10:32:56.959]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:56.959]                               info)
[10:32:56.959]                           }
[10:32:56.959]                           else {
[10:32:56.959]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:56.959]                               info, version)
[10:32:56.959]                           }
[10:32:56.959]                           base::stop(msg)
[10:32:56.959]                         }
[10:32:56.959]                       })
[10:32:56.959]                     }
[10:32:56.959]                     base::local({
[10:32:56.959]                       for (pkg in "stats") {
[10:32:56.959]                         base::loadNamespace(pkg)
[10:32:56.959]                         base::library(pkg, character.only = TRUE)
[10:32:56.959]                       }
[10:32:56.959]                     })
[10:32:56.959]                   }
[10:32:56.959]                   ...future.strategy.old <- future::plan("list")
[10:32:56.959]                   options(future.plan = NULL)
[10:32:56.959]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:56.959]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:56.959]                 }
[10:32:56.959]                 ...future.workdir <- getwd()
[10:32:56.959]             }
[10:32:56.959]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:56.959]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:56.959]         }
[10:32:56.959]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:56.959]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:56.959]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:56.959]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:56.959]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:56.959]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:56.959]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:56.959]             base::names(...future.oldOptions))
[10:32:56.959]     }
[10:32:56.959]     if (FALSE) {
[10:32:56.959]     }
[10:32:56.959]     else {
[10:32:56.959]         if (TRUE) {
[10:32:56.959]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:56.959]                 open = "w")
[10:32:56.959]         }
[10:32:56.959]         else {
[10:32:56.959]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:56.959]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:56.959]         }
[10:32:56.959]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:56.959]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:56.959]             base::sink(type = "output", split = FALSE)
[10:32:56.959]             base::close(...future.stdout)
[10:32:56.959]         }, add = TRUE)
[10:32:56.959]     }
[10:32:56.959]     ...future.frame <- base::sys.nframe()
[10:32:56.959]     ...future.conditions <- base::list()
[10:32:56.959]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:56.959]     if (FALSE) {
[10:32:56.959]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:56.959]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:56.959]     }
[10:32:56.959]     ...future.result <- base::tryCatch({
[10:32:56.959]         base::withCallingHandlers({
[10:32:56.959]             ...future.value <- base::withVisible(base::local({
[10:32:56.959]                 xtabs(~x)
[10:32:56.959]             }))
[10:32:56.959]             future::FutureResult(value = ...future.value$value, 
[10:32:56.959]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:56.959]                   ...future.rng), globalenv = if (FALSE) 
[10:32:56.959]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:56.959]                     ...future.globalenv.names))
[10:32:56.959]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:56.959]         }, condition = base::local({
[10:32:56.959]             c <- base::c
[10:32:56.959]             inherits <- base::inherits
[10:32:56.959]             invokeRestart <- base::invokeRestart
[10:32:56.959]             length <- base::length
[10:32:56.959]             list <- base::list
[10:32:56.959]             seq.int <- base::seq.int
[10:32:56.959]             signalCondition <- base::signalCondition
[10:32:56.959]             sys.calls <- base::sys.calls
[10:32:56.959]             `[[` <- base::`[[`
[10:32:56.959]             `+` <- base::`+`
[10:32:56.959]             `<<-` <- base::`<<-`
[10:32:56.959]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:56.959]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:56.959]                   3L)]
[10:32:56.959]             }
[10:32:56.959]             function(cond) {
[10:32:56.959]                 is_error <- inherits(cond, "error")
[10:32:56.959]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:56.959]                   NULL)
[10:32:56.959]                 if (is_error) {
[10:32:56.959]                   sessionInformation <- function() {
[10:32:56.959]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:56.959]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:56.959]                       search = base::search(), system = base::Sys.info())
[10:32:56.959]                   }
[10:32:56.959]                   ...future.conditions[[length(...future.conditions) + 
[10:32:56.959]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:56.959]                     cond$call), session = sessionInformation(), 
[10:32:56.959]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:56.959]                   signalCondition(cond)
[10:32:56.959]                 }
[10:32:56.959]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:56.959]                 "immediateCondition"))) {
[10:32:56.959]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:56.959]                   ...future.conditions[[length(...future.conditions) + 
[10:32:56.959]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:56.959]                   if (TRUE && !signal) {
[10:32:56.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:56.959]                     {
[10:32:56.959]                       inherits <- base::inherits
[10:32:56.959]                       invokeRestart <- base::invokeRestart
[10:32:56.959]                       is.null <- base::is.null
[10:32:56.959]                       muffled <- FALSE
[10:32:56.959]                       if (inherits(cond, "message")) {
[10:32:56.959]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:56.959]                         if (muffled) 
[10:32:56.959]                           invokeRestart("muffleMessage")
[10:32:56.959]                       }
[10:32:56.959]                       else if (inherits(cond, "warning")) {
[10:32:56.959]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:56.959]                         if (muffled) 
[10:32:56.959]                           invokeRestart("muffleWarning")
[10:32:56.959]                       }
[10:32:56.959]                       else if (inherits(cond, "condition")) {
[10:32:56.959]                         if (!is.null(pattern)) {
[10:32:56.959]                           computeRestarts <- base::computeRestarts
[10:32:56.959]                           grepl <- base::grepl
[10:32:56.959]                           restarts <- computeRestarts(cond)
[10:32:56.959]                           for (restart in restarts) {
[10:32:56.959]                             name <- restart$name
[10:32:56.959]                             if (is.null(name)) 
[10:32:56.959]                               next
[10:32:56.959]                             if (!grepl(pattern, name)) 
[10:32:56.959]                               next
[10:32:56.959]                             invokeRestart(restart)
[10:32:56.959]                             muffled <- TRUE
[10:32:56.959]                             break
[10:32:56.959]                           }
[10:32:56.959]                         }
[10:32:56.959]                       }
[10:32:56.959]                       invisible(muffled)
[10:32:56.959]                     }
[10:32:56.959]                     muffleCondition(cond, pattern = "^muffle")
[10:32:56.959]                   }
[10:32:56.959]                 }
[10:32:56.959]                 else {
[10:32:56.959]                   if (TRUE) {
[10:32:56.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:56.959]                     {
[10:32:56.959]                       inherits <- base::inherits
[10:32:56.959]                       invokeRestart <- base::invokeRestart
[10:32:56.959]                       is.null <- base::is.null
[10:32:56.959]                       muffled <- FALSE
[10:32:56.959]                       if (inherits(cond, "message")) {
[10:32:56.959]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:56.959]                         if (muffled) 
[10:32:56.959]                           invokeRestart("muffleMessage")
[10:32:56.959]                       }
[10:32:56.959]                       else if (inherits(cond, "warning")) {
[10:32:56.959]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:56.959]                         if (muffled) 
[10:32:56.959]                           invokeRestart("muffleWarning")
[10:32:56.959]                       }
[10:32:56.959]                       else if (inherits(cond, "condition")) {
[10:32:56.959]                         if (!is.null(pattern)) {
[10:32:56.959]                           computeRestarts <- base::computeRestarts
[10:32:56.959]                           grepl <- base::grepl
[10:32:56.959]                           restarts <- computeRestarts(cond)
[10:32:56.959]                           for (restart in restarts) {
[10:32:56.959]                             name <- restart$name
[10:32:56.959]                             if (is.null(name)) 
[10:32:56.959]                               next
[10:32:56.959]                             if (!grepl(pattern, name)) 
[10:32:56.959]                               next
[10:32:56.959]                             invokeRestart(restart)
[10:32:56.959]                             muffled <- TRUE
[10:32:56.959]                             break
[10:32:56.959]                           }
[10:32:56.959]                         }
[10:32:56.959]                       }
[10:32:56.959]                       invisible(muffled)
[10:32:56.959]                     }
[10:32:56.959]                     muffleCondition(cond, pattern = "^muffle")
[10:32:56.959]                   }
[10:32:56.959]                 }
[10:32:56.959]             }
[10:32:56.959]         }))
[10:32:56.959]     }, error = function(ex) {
[10:32:56.959]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:56.959]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:56.959]                 ...future.rng), started = ...future.startTime, 
[10:32:56.959]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:56.959]             version = "1.8"), class = "FutureResult")
[10:32:56.959]     }, finally = {
[10:32:56.959]         if (!identical(...future.workdir, getwd())) 
[10:32:56.959]             setwd(...future.workdir)
[10:32:56.959]         {
[10:32:56.959]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:56.959]                 ...future.oldOptions$nwarnings <- NULL
[10:32:56.959]             }
[10:32:56.959]             base::options(...future.oldOptions)
[10:32:56.959]             if (.Platform$OS.type == "windows") {
[10:32:56.959]                 old_names <- names(...future.oldEnvVars)
[10:32:56.959]                 envs <- base::Sys.getenv()
[10:32:56.959]                 names <- names(envs)
[10:32:56.959]                 common <- intersect(names, old_names)
[10:32:56.959]                 added <- setdiff(names, old_names)
[10:32:56.959]                 removed <- setdiff(old_names, names)
[10:32:56.959]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:56.959]                   envs[common]]
[10:32:56.959]                 NAMES <- toupper(changed)
[10:32:56.959]                 args <- list()
[10:32:56.959]                 for (kk in seq_along(NAMES)) {
[10:32:56.959]                   name <- changed[[kk]]
[10:32:56.959]                   NAME <- NAMES[[kk]]
[10:32:56.959]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.959]                     next
[10:32:56.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:56.959]                 }
[10:32:56.959]                 NAMES <- toupper(added)
[10:32:56.959]                 for (kk in seq_along(NAMES)) {
[10:32:56.959]                   name <- added[[kk]]
[10:32:56.959]                   NAME <- NAMES[[kk]]
[10:32:56.959]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.959]                     next
[10:32:56.959]                   args[[name]] <- ""
[10:32:56.959]                 }
[10:32:56.959]                 NAMES <- toupper(removed)
[10:32:56.959]                 for (kk in seq_along(NAMES)) {
[10:32:56.959]                   name <- removed[[kk]]
[10:32:56.959]                   NAME <- NAMES[[kk]]
[10:32:56.959]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.959]                     next
[10:32:56.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:56.959]                 }
[10:32:56.959]                 if (length(args) > 0) 
[10:32:56.959]                   base::do.call(base::Sys.setenv, args = args)
[10:32:56.959]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:56.959]             }
[10:32:56.959]             else {
[10:32:56.959]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:56.959]             }
[10:32:56.959]             {
[10:32:56.959]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:56.959]                   0L) {
[10:32:56.959]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:56.959]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:56.959]                   base::options(opts)
[10:32:56.959]                 }
[10:32:56.959]                 {
[10:32:56.959]                   {
[10:32:56.959]                     NULL
[10:32:56.959]                     RNGkind("Mersenne-Twister")
[10:32:56.959]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:56.959]                       inherits = FALSE)
[10:32:56.959]                   }
[10:32:56.959]                   options(future.plan = NULL)
[10:32:56.959]                   if (is.na(NA_character_)) 
[10:32:56.959]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:56.959]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:56.959]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:56.959]                     .init = FALSE)
[10:32:56.959]                 }
[10:32:56.959]             }
[10:32:56.959]         }
[10:32:56.959]     })
[10:32:56.959]     if (TRUE) {
[10:32:56.959]         base::sink(type = "output", split = FALSE)
[10:32:56.959]         if (TRUE) {
[10:32:56.959]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:56.959]         }
[10:32:56.959]         else {
[10:32:56.959]             ...future.result["stdout"] <- base::list(NULL)
[10:32:56.959]         }
[10:32:56.959]         base::close(...future.stdout)
[10:32:56.959]         ...future.stdout <- NULL
[10:32:56.959]     }
[10:32:56.959]     ...future.result$conditions <- ...future.conditions
[10:32:56.959]     ...future.result$finished <- base::Sys.time()
[10:32:56.959]     ...future.result
[10:32:56.959] }
[10:32:56.961] assign_globals() ...
[10:32:56.961] List of 1
[10:32:56.961]  $ x: num [1:5] 1 1 2 2 2
[10:32:56.961]  - attr(*, "where")=List of 1
[10:32:56.961]   ..$ x:<environment: R_EmptyEnv> 
[10:32:56.961]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:56.961]  - attr(*, "resolved")= logi FALSE
[10:32:56.961]  - attr(*, "total_size")= num 96
[10:32:56.961]  - attr(*, "already-done")= logi TRUE
[10:32:56.963] - copied ‘x’ to environment
[10:32:56.964] assign_globals() ... done
[10:32:56.964] plan(): Setting new future strategy stack:
[10:32:56.964] List of future strategies:
[10:32:56.964] 1. sequential:
[10:32:56.964]    - args: function (..., envir = parent.frame())
[10:32:56.964]    - tweaked: FALSE
[10:32:56.964]    - call: NULL
[10:32:56.964] plan(): nbrOfWorkers() = 1
[10:32:56.965] plan(): Setting new future strategy stack:
[10:32:56.965] List of future strategies:
[10:32:56.965] 1. sequential:
[10:32:56.965]    - args: function (..., envir = parent.frame())
[10:32:56.965]    - tweaked: FALSE
[10:32:56.965]    - call: plan(strategy)
[10:32:56.966] plan(): nbrOfWorkers() = 1
[10:32:56.966] SequentialFuture started (and completed)
[10:32:56.966] - Launch lazy future ... done
[10:32:56.966] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
[10:32:56.967] getGlobalsAndPackages() ...
[10:32:56.967] Searching for globals...
[10:32:56.968] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[10:32:56.968] Searching for globals ... DONE
[10:32:56.968] Resolving globals: FALSE
[10:32:56.968] The total size of the 1 globals is 96 bytes (96 bytes)
[10:32:56.969] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[10:32:56.969] - globals: [1] ‘x’
[10:32:56.969] - packages: [1] ‘stats’
[10:32:56.969] getGlobalsAndPackages() ... DONE
[10:32:56.969] run() for ‘Future’ ...
[10:32:56.969] - state: ‘created’
[10:32:56.970] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:56.970] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:56.970] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:56.970]   - Field: ‘label’
[10:32:56.970]   - Field: ‘local’
[10:32:56.970]   - Field: ‘owner’
[10:32:56.970]   - Field: ‘envir’
[10:32:56.970]   - Field: ‘packages’
[10:32:56.970]   - Field: ‘gc’
[10:32:56.971]   - Field: ‘conditions’
[10:32:56.971]   - Field: ‘expr’
[10:32:56.971]   - Field: ‘uuid’
[10:32:56.971]   - Field: ‘seed’
[10:32:56.971]   - Field: ‘version’
[10:32:56.971]   - Field: ‘result’
[10:32:56.971]   - Field: ‘asynchronous’
[10:32:56.971]   - Field: ‘calls’
[10:32:56.971]   - Field: ‘globals’
[10:32:56.971]   - Field: ‘stdout’
[10:32:56.971]   - Field: ‘earlySignal’
[10:32:56.972]   - Field: ‘lazy’
[10:32:56.972]   - Field: ‘state’
[10:32:56.972] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:56.972] - Launch lazy future ...
[10:32:56.972] Packages needed by the future expression (n = 1): ‘stats’
[10:32:56.972] Packages needed by future strategies (n = 0): <none>
[10:32:56.973] {
[10:32:56.973]     {
[10:32:56.973]         {
[10:32:56.973]             ...future.startTime <- base::Sys.time()
[10:32:56.973]             {
[10:32:56.973]                 {
[10:32:56.973]                   {
[10:32:56.973]                     {
[10:32:56.973]                       base::local({
[10:32:56.973]                         has_future <- base::requireNamespace("future", 
[10:32:56.973]                           quietly = TRUE)
[10:32:56.973]                         if (has_future) {
[10:32:56.973]                           ns <- base::getNamespace("future")
[10:32:56.973]                           version <- ns[[".package"]][["version"]]
[10:32:56.973]                           if (is.null(version)) 
[10:32:56.973]                             version <- utils::packageVersion("future")
[10:32:56.973]                         }
[10:32:56.973]                         else {
[10:32:56.973]                           version <- NULL
[10:32:56.973]                         }
[10:32:56.973]                         if (!has_future || version < "1.8.0") {
[10:32:56.973]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:56.973]                             "", base::R.version$version.string), 
[10:32:56.973]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:56.973]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:56.973]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:56.973]                               "release", "version")], collapse = " "), 
[10:32:56.973]                             hostname = base::Sys.info()[["nodename"]])
[10:32:56.973]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:56.973]                             info)
[10:32:56.973]                           info <- base::paste(info, collapse = "; ")
[10:32:56.973]                           if (!has_future) {
[10:32:56.973]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:56.973]                               info)
[10:32:56.973]                           }
[10:32:56.973]                           else {
[10:32:56.973]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:56.973]                               info, version)
[10:32:56.973]                           }
[10:32:56.973]                           base::stop(msg)
[10:32:56.973]                         }
[10:32:56.973]                       })
[10:32:56.973]                     }
[10:32:56.973]                     base::local({
[10:32:56.973]                       for (pkg in "stats") {
[10:32:56.973]                         base::loadNamespace(pkg)
[10:32:56.973]                         base::library(pkg, character.only = TRUE)
[10:32:56.973]                       }
[10:32:56.973]                     })
[10:32:56.973]                   }
[10:32:56.973]                   ...future.strategy.old <- future::plan("list")
[10:32:56.973]                   options(future.plan = NULL)
[10:32:56.973]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:56.973]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:56.973]                 }
[10:32:56.973]                 ...future.workdir <- getwd()
[10:32:56.973]             }
[10:32:56.973]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:56.973]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:56.973]         }
[10:32:56.973]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:56.973]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:56.973]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:56.973]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:56.973]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:56.973]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:56.973]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:56.973]             base::names(...future.oldOptions))
[10:32:56.973]     }
[10:32:56.973]     if (FALSE) {
[10:32:56.973]     }
[10:32:56.973]     else {
[10:32:56.973]         if (TRUE) {
[10:32:56.973]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:56.973]                 open = "w")
[10:32:56.973]         }
[10:32:56.973]         else {
[10:32:56.973]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:56.973]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:56.973]         }
[10:32:56.973]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:56.973]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:56.973]             base::sink(type = "output", split = FALSE)
[10:32:56.973]             base::close(...future.stdout)
[10:32:56.973]         }, add = TRUE)
[10:32:56.973]     }
[10:32:56.973]     ...future.frame <- base::sys.nframe()
[10:32:56.973]     ...future.conditions <- base::list()
[10:32:56.973]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:56.973]     if (FALSE) {
[10:32:56.973]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:56.973]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:56.973]     }
[10:32:56.973]     ...future.result <- base::tryCatch({
[10:32:56.973]         base::withCallingHandlers({
[10:32:56.973]             ...future.value <- base::withVisible(base::local({
[10:32:56.973]                 xtabs(~x)
[10:32:56.973]             }))
[10:32:56.973]             future::FutureResult(value = ...future.value$value, 
[10:32:56.973]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:56.973]                   ...future.rng), globalenv = if (FALSE) 
[10:32:56.973]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:56.973]                     ...future.globalenv.names))
[10:32:56.973]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:56.973]         }, condition = base::local({
[10:32:56.973]             c <- base::c
[10:32:56.973]             inherits <- base::inherits
[10:32:56.973]             invokeRestart <- base::invokeRestart
[10:32:56.973]             length <- base::length
[10:32:56.973]             list <- base::list
[10:32:56.973]             seq.int <- base::seq.int
[10:32:56.973]             signalCondition <- base::signalCondition
[10:32:56.973]             sys.calls <- base::sys.calls
[10:32:56.973]             `[[` <- base::`[[`
[10:32:56.973]             `+` <- base::`+`
[10:32:56.973]             `<<-` <- base::`<<-`
[10:32:56.973]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:56.973]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:56.973]                   3L)]
[10:32:56.973]             }
[10:32:56.973]             function(cond) {
[10:32:56.973]                 is_error <- inherits(cond, "error")
[10:32:56.973]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:56.973]                   NULL)
[10:32:56.973]                 if (is_error) {
[10:32:56.973]                   sessionInformation <- function() {
[10:32:56.973]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:56.973]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:56.973]                       search = base::search(), system = base::Sys.info())
[10:32:56.973]                   }
[10:32:56.973]                   ...future.conditions[[length(...future.conditions) + 
[10:32:56.973]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:56.973]                     cond$call), session = sessionInformation(), 
[10:32:56.973]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:56.973]                   signalCondition(cond)
[10:32:56.973]                 }
[10:32:56.973]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:56.973]                 "immediateCondition"))) {
[10:32:56.973]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:56.973]                   ...future.conditions[[length(...future.conditions) + 
[10:32:56.973]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:56.973]                   if (TRUE && !signal) {
[10:32:56.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:56.973]                     {
[10:32:56.973]                       inherits <- base::inherits
[10:32:56.973]                       invokeRestart <- base::invokeRestart
[10:32:56.973]                       is.null <- base::is.null
[10:32:56.973]                       muffled <- FALSE
[10:32:56.973]                       if (inherits(cond, "message")) {
[10:32:56.973]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:56.973]                         if (muffled) 
[10:32:56.973]                           invokeRestart("muffleMessage")
[10:32:56.973]                       }
[10:32:56.973]                       else if (inherits(cond, "warning")) {
[10:32:56.973]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:56.973]                         if (muffled) 
[10:32:56.973]                           invokeRestart("muffleWarning")
[10:32:56.973]                       }
[10:32:56.973]                       else if (inherits(cond, "condition")) {
[10:32:56.973]                         if (!is.null(pattern)) {
[10:32:56.973]                           computeRestarts <- base::computeRestarts
[10:32:56.973]                           grepl <- base::grepl
[10:32:56.973]                           restarts <- computeRestarts(cond)
[10:32:56.973]                           for (restart in restarts) {
[10:32:56.973]                             name <- restart$name
[10:32:56.973]                             if (is.null(name)) 
[10:32:56.973]                               next
[10:32:56.973]                             if (!grepl(pattern, name)) 
[10:32:56.973]                               next
[10:32:56.973]                             invokeRestart(restart)
[10:32:56.973]                             muffled <- TRUE
[10:32:56.973]                             break
[10:32:56.973]                           }
[10:32:56.973]                         }
[10:32:56.973]                       }
[10:32:56.973]                       invisible(muffled)
[10:32:56.973]                     }
[10:32:56.973]                     muffleCondition(cond, pattern = "^muffle")
[10:32:56.973]                   }
[10:32:56.973]                 }
[10:32:56.973]                 else {
[10:32:56.973]                   if (TRUE) {
[10:32:56.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:56.973]                     {
[10:32:56.973]                       inherits <- base::inherits
[10:32:56.973]                       invokeRestart <- base::invokeRestart
[10:32:56.973]                       is.null <- base::is.null
[10:32:56.973]                       muffled <- FALSE
[10:32:56.973]                       if (inherits(cond, "message")) {
[10:32:56.973]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:56.973]                         if (muffled) 
[10:32:56.973]                           invokeRestart("muffleMessage")
[10:32:56.973]                       }
[10:32:56.973]                       else if (inherits(cond, "warning")) {
[10:32:56.973]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:56.973]                         if (muffled) 
[10:32:56.973]                           invokeRestart("muffleWarning")
[10:32:56.973]                       }
[10:32:56.973]                       else if (inherits(cond, "condition")) {
[10:32:56.973]                         if (!is.null(pattern)) {
[10:32:56.973]                           computeRestarts <- base::computeRestarts
[10:32:56.973]                           grepl <- base::grepl
[10:32:56.973]                           restarts <- computeRestarts(cond)
[10:32:56.973]                           for (restart in restarts) {
[10:32:56.973]                             name <- restart$name
[10:32:56.973]                             if (is.null(name)) 
[10:32:56.973]                               next
[10:32:56.973]                             if (!grepl(pattern, name)) 
[10:32:56.973]                               next
[10:32:56.973]                             invokeRestart(restart)
[10:32:56.973]                             muffled <- TRUE
[10:32:56.973]                             break
[10:32:56.973]                           }
[10:32:56.973]                         }
[10:32:56.973]                       }
[10:32:56.973]                       invisible(muffled)
[10:32:56.973]                     }
[10:32:56.973]                     muffleCondition(cond, pattern = "^muffle")
[10:32:56.973]                   }
[10:32:56.973]                 }
[10:32:56.973]             }
[10:32:56.973]         }))
[10:32:56.973]     }, error = function(ex) {
[10:32:56.973]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:56.973]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:56.973]                 ...future.rng), started = ...future.startTime, 
[10:32:56.973]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:56.973]             version = "1.8"), class = "FutureResult")
[10:32:56.973]     }, finally = {
[10:32:56.973]         if (!identical(...future.workdir, getwd())) 
[10:32:56.973]             setwd(...future.workdir)
[10:32:56.973]         {
[10:32:56.973]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:56.973]                 ...future.oldOptions$nwarnings <- NULL
[10:32:56.973]             }
[10:32:56.973]             base::options(...future.oldOptions)
[10:32:56.973]             if (.Platform$OS.type == "windows") {
[10:32:56.973]                 old_names <- names(...future.oldEnvVars)
[10:32:56.973]                 envs <- base::Sys.getenv()
[10:32:56.973]                 names <- names(envs)
[10:32:56.973]                 common <- intersect(names, old_names)
[10:32:56.973]                 added <- setdiff(names, old_names)
[10:32:56.973]                 removed <- setdiff(old_names, names)
[10:32:56.973]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:56.973]                   envs[common]]
[10:32:56.973]                 NAMES <- toupper(changed)
[10:32:56.973]                 args <- list()
[10:32:56.973]                 for (kk in seq_along(NAMES)) {
[10:32:56.973]                   name <- changed[[kk]]
[10:32:56.973]                   NAME <- NAMES[[kk]]
[10:32:56.973]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.973]                     next
[10:32:56.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:56.973]                 }
[10:32:56.973]                 NAMES <- toupper(added)
[10:32:56.973]                 for (kk in seq_along(NAMES)) {
[10:32:56.973]                   name <- added[[kk]]
[10:32:56.973]                   NAME <- NAMES[[kk]]
[10:32:56.973]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.973]                     next
[10:32:56.973]                   args[[name]] <- ""
[10:32:56.973]                 }
[10:32:56.973]                 NAMES <- toupper(removed)
[10:32:56.973]                 for (kk in seq_along(NAMES)) {
[10:32:56.973]                   name <- removed[[kk]]
[10:32:56.973]                   NAME <- NAMES[[kk]]
[10:32:56.973]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.973]                     next
[10:32:56.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:56.973]                 }
[10:32:56.973]                 if (length(args) > 0) 
[10:32:56.973]                   base::do.call(base::Sys.setenv, args = args)
[10:32:56.973]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:56.973]             }
[10:32:56.973]             else {
[10:32:56.973]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:56.973]             }
[10:32:56.973]             {
[10:32:56.973]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:56.973]                   0L) {
[10:32:56.973]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:56.973]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:56.973]                   base::options(opts)
[10:32:56.973]                 }
[10:32:56.973]                 {
[10:32:56.973]                   {
[10:32:56.973]                     NULL
[10:32:56.973]                     RNGkind("Mersenne-Twister")
[10:32:56.973]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:56.973]                       inherits = FALSE)
[10:32:56.973]                   }
[10:32:56.973]                   options(future.plan = NULL)
[10:32:56.973]                   if (is.na(NA_character_)) 
[10:32:56.973]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:56.973]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:56.973]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:56.973]                     .init = FALSE)
[10:32:56.973]                 }
[10:32:56.973]             }
[10:32:56.973]         }
[10:32:56.973]     })
[10:32:56.973]     if (TRUE) {
[10:32:56.973]         base::sink(type = "output", split = FALSE)
[10:32:56.973]         if (TRUE) {
[10:32:56.973]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:56.973]         }
[10:32:56.973]         else {
[10:32:56.973]             ...future.result["stdout"] <- base::list(NULL)
[10:32:56.973]         }
[10:32:56.973]         base::close(...future.stdout)
[10:32:56.973]         ...future.stdout <- NULL
[10:32:56.973]     }
[10:32:56.973]     ...future.result$conditions <- ...future.conditions
[10:32:56.973]     ...future.result$finished <- base::Sys.time()
[10:32:56.973]     ...future.result
[10:32:56.973] }
[10:32:56.974] assign_globals() ...
[10:32:56.974] List of 1
[10:32:56.974]  $ x: num [1:5] 1 1 2 2 2
[10:32:56.974]  - attr(*, "where")=List of 1
[10:32:56.974]   ..$ x:<environment: R_EmptyEnv> 
[10:32:56.974]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:56.974]  - attr(*, "resolved")= logi FALSE
[10:32:56.974]  - attr(*, "total_size")= num 96
[10:32:56.974]  - attr(*, "already-done")= logi TRUE
[10:32:56.976] - copied ‘x’ to environment
[10:32:56.977] assign_globals() ... done
[10:32:56.977] plan(): Setting new future strategy stack:
[10:32:56.977] List of future strategies:
[10:32:56.977] 1. sequential:
[10:32:56.977]    - args: function (..., envir = parent.frame())
[10:32:56.977]    - tweaked: FALSE
[10:32:56.977]    - call: NULL
[10:32:56.977] plan(): nbrOfWorkers() = 1
[10:32:56.978] plan(): Setting new future strategy stack:
[10:32:56.978] List of future strategies:
[10:32:56.978] 1. sequential:
[10:32:56.978]    - args: function (..., envir = parent.frame())
[10:32:56.978]    - tweaked: FALSE
[10:32:56.978]    - call: plan(strategy)
[10:32:56.979] plan(): nbrOfWorkers() = 1
[10:32:56.979] SequentialFuture started (and completed)
[10:32:56.979] - Launch lazy future ... done
[10:32:56.979] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[10:32:56.981] getGlobalsAndPackages() ...
[10:32:56.981] Searching for globals...
[10:32:56.984] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[10:32:56.984] Searching for globals ... DONE
[10:32:56.984] Resolving globals: FALSE
[10:32:56.985] 
[10:32:56.985] - packages: [2] ‘stats’, ‘datasets’
[10:32:56.985] getGlobalsAndPackages() ... DONE
[10:32:56.985] run() for ‘Future’ ...
[10:32:56.985] - state: ‘created’
[10:32:56.985] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:56.985] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:56.986] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:56.986]   - Field: ‘label’
[10:32:56.986]   - Field: ‘local’
[10:32:56.986]   - Field: ‘owner’
[10:32:56.986]   - Field: ‘envir’
[10:32:56.986]   - Field: ‘packages’
[10:32:56.986]   - Field: ‘gc’
[10:32:56.986]   - Field: ‘conditions’
[10:32:56.986]   - Field: ‘expr’
[10:32:56.986]   - Field: ‘uuid’
[10:32:56.987]   - Field: ‘seed’
[10:32:56.987]   - Field: ‘version’
[10:32:56.987]   - Field: ‘result’
[10:32:56.987]   - Field: ‘asynchronous’
[10:32:56.987]   - Field: ‘calls’
[10:32:56.987]   - Field: ‘globals’
[10:32:56.987]   - Field: ‘stdout’
[10:32:56.987]   - Field: ‘earlySignal’
[10:32:56.987]   - Field: ‘lazy’
[10:32:56.987]   - Field: ‘state’
[10:32:56.987] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:56.987] - Launch lazy future ...
[10:32:56.988] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:32:56.988] Packages needed by future strategies (n = 0): <none>
[10:32:56.988] {
[10:32:56.988]     {
[10:32:56.988]         {
[10:32:56.988]             ...future.startTime <- base::Sys.time()
[10:32:56.988]             {
[10:32:56.988]                 {
[10:32:56.988]                   {
[10:32:56.988]                     {
[10:32:56.988]                       base::local({
[10:32:56.988]                         has_future <- base::requireNamespace("future", 
[10:32:56.988]                           quietly = TRUE)
[10:32:56.988]                         if (has_future) {
[10:32:56.988]                           ns <- base::getNamespace("future")
[10:32:56.988]                           version <- ns[[".package"]][["version"]]
[10:32:56.988]                           if (is.null(version)) 
[10:32:56.988]                             version <- utils::packageVersion("future")
[10:32:56.988]                         }
[10:32:56.988]                         else {
[10:32:56.988]                           version <- NULL
[10:32:56.988]                         }
[10:32:56.988]                         if (!has_future || version < "1.8.0") {
[10:32:56.988]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:56.988]                             "", base::R.version$version.string), 
[10:32:56.988]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:56.988]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:56.988]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:56.988]                               "release", "version")], collapse = " "), 
[10:32:56.988]                             hostname = base::Sys.info()[["nodename"]])
[10:32:56.988]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:56.988]                             info)
[10:32:56.988]                           info <- base::paste(info, collapse = "; ")
[10:32:56.988]                           if (!has_future) {
[10:32:56.988]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:56.988]                               info)
[10:32:56.988]                           }
[10:32:56.988]                           else {
[10:32:56.988]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:56.988]                               info, version)
[10:32:56.988]                           }
[10:32:56.988]                           base::stop(msg)
[10:32:56.988]                         }
[10:32:56.988]                       })
[10:32:56.988]                     }
[10:32:56.988]                     base::local({
[10:32:56.988]                       for (pkg in c("stats", "datasets")) {
[10:32:56.988]                         base::loadNamespace(pkg)
[10:32:56.988]                         base::library(pkg, character.only = TRUE)
[10:32:56.988]                       }
[10:32:56.988]                     })
[10:32:56.988]                   }
[10:32:56.988]                   ...future.strategy.old <- future::plan("list")
[10:32:56.988]                   options(future.plan = NULL)
[10:32:56.988]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:56.988]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:56.988]                 }
[10:32:56.988]                 ...future.workdir <- getwd()
[10:32:56.988]             }
[10:32:56.988]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:56.988]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:56.988]         }
[10:32:56.988]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:56.988]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:56.988]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:56.988]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:56.988]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:56.988]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:56.988]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:56.988]             base::names(...future.oldOptions))
[10:32:56.988]     }
[10:32:56.988]     if (FALSE) {
[10:32:56.988]     }
[10:32:56.988]     else {
[10:32:56.988]         if (TRUE) {
[10:32:56.988]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:56.988]                 open = "w")
[10:32:56.988]         }
[10:32:56.988]         else {
[10:32:56.988]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:56.988]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:56.988]         }
[10:32:56.988]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:56.988]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:56.988]             base::sink(type = "output", split = FALSE)
[10:32:56.988]             base::close(...future.stdout)
[10:32:56.988]         }, add = TRUE)
[10:32:56.988]     }
[10:32:56.988]     ...future.frame <- base::sys.nframe()
[10:32:56.988]     ...future.conditions <- base::list()
[10:32:56.988]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:56.988]     if (FALSE) {
[10:32:56.988]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:56.988]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:56.988]     }
[10:32:56.988]     ...future.result <- base::tryCatch({
[10:32:56.988]         base::withCallingHandlers({
[10:32:56.988]             ...future.value <- base::withVisible(base::local({
[10:32:56.988]                 lm(dist ~ . - 1, data = cars)
[10:32:56.988]             }))
[10:32:56.988]             future::FutureResult(value = ...future.value$value, 
[10:32:56.988]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:56.988]                   ...future.rng), globalenv = if (FALSE) 
[10:32:56.988]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:56.988]                     ...future.globalenv.names))
[10:32:56.988]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:56.988]         }, condition = base::local({
[10:32:56.988]             c <- base::c
[10:32:56.988]             inherits <- base::inherits
[10:32:56.988]             invokeRestart <- base::invokeRestart
[10:32:56.988]             length <- base::length
[10:32:56.988]             list <- base::list
[10:32:56.988]             seq.int <- base::seq.int
[10:32:56.988]             signalCondition <- base::signalCondition
[10:32:56.988]             sys.calls <- base::sys.calls
[10:32:56.988]             `[[` <- base::`[[`
[10:32:56.988]             `+` <- base::`+`
[10:32:56.988]             `<<-` <- base::`<<-`
[10:32:56.988]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:56.988]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:56.988]                   3L)]
[10:32:56.988]             }
[10:32:56.988]             function(cond) {
[10:32:56.988]                 is_error <- inherits(cond, "error")
[10:32:56.988]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:56.988]                   NULL)
[10:32:56.988]                 if (is_error) {
[10:32:56.988]                   sessionInformation <- function() {
[10:32:56.988]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:56.988]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:56.988]                       search = base::search(), system = base::Sys.info())
[10:32:56.988]                   }
[10:32:56.988]                   ...future.conditions[[length(...future.conditions) + 
[10:32:56.988]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:56.988]                     cond$call), session = sessionInformation(), 
[10:32:56.988]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:56.988]                   signalCondition(cond)
[10:32:56.988]                 }
[10:32:56.988]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:56.988]                 "immediateCondition"))) {
[10:32:56.988]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:56.988]                   ...future.conditions[[length(...future.conditions) + 
[10:32:56.988]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:56.988]                   if (TRUE && !signal) {
[10:32:56.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:56.988]                     {
[10:32:56.988]                       inherits <- base::inherits
[10:32:56.988]                       invokeRestart <- base::invokeRestart
[10:32:56.988]                       is.null <- base::is.null
[10:32:56.988]                       muffled <- FALSE
[10:32:56.988]                       if (inherits(cond, "message")) {
[10:32:56.988]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:56.988]                         if (muffled) 
[10:32:56.988]                           invokeRestart("muffleMessage")
[10:32:56.988]                       }
[10:32:56.988]                       else if (inherits(cond, "warning")) {
[10:32:56.988]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:56.988]                         if (muffled) 
[10:32:56.988]                           invokeRestart("muffleWarning")
[10:32:56.988]                       }
[10:32:56.988]                       else if (inherits(cond, "condition")) {
[10:32:56.988]                         if (!is.null(pattern)) {
[10:32:56.988]                           computeRestarts <- base::computeRestarts
[10:32:56.988]                           grepl <- base::grepl
[10:32:56.988]                           restarts <- computeRestarts(cond)
[10:32:56.988]                           for (restart in restarts) {
[10:32:56.988]                             name <- restart$name
[10:32:56.988]                             if (is.null(name)) 
[10:32:56.988]                               next
[10:32:56.988]                             if (!grepl(pattern, name)) 
[10:32:56.988]                               next
[10:32:56.988]                             invokeRestart(restart)
[10:32:56.988]                             muffled <- TRUE
[10:32:56.988]                             break
[10:32:56.988]                           }
[10:32:56.988]                         }
[10:32:56.988]                       }
[10:32:56.988]                       invisible(muffled)
[10:32:56.988]                     }
[10:32:56.988]                     muffleCondition(cond, pattern = "^muffle")
[10:32:56.988]                   }
[10:32:56.988]                 }
[10:32:56.988]                 else {
[10:32:56.988]                   if (TRUE) {
[10:32:56.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:56.988]                     {
[10:32:56.988]                       inherits <- base::inherits
[10:32:56.988]                       invokeRestart <- base::invokeRestart
[10:32:56.988]                       is.null <- base::is.null
[10:32:56.988]                       muffled <- FALSE
[10:32:56.988]                       if (inherits(cond, "message")) {
[10:32:56.988]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:56.988]                         if (muffled) 
[10:32:56.988]                           invokeRestart("muffleMessage")
[10:32:56.988]                       }
[10:32:56.988]                       else if (inherits(cond, "warning")) {
[10:32:56.988]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:56.988]                         if (muffled) 
[10:32:56.988]                           invokeRestart("muffleWarning")
[10:32:56.988]                       }
[10:32:56.988]                       else if (inherits(cond, "condition")) {
[10:32:56.988]                         if (!is.null(pattern)) {
[10:32:56.988]                           computeRestarts <- base::computeRestarts
[10:32:56.988]                           grepl <- base::grepl
[10:32:56.988]                           restarts <- computeRestarts(cond)
[10:32:56.988]                           for (restart in restarts) {
[10:32:56.988]                             name <- restart$name
[10:32:56.988]                             if (is.null(name)) 
[10:32:56.988]                               next
[10:32:56.988]                             if (!grepl(pattern, name)) 
[10:32:56.988]                               next
[10:32:56.988]                             invokeRestart(restart)
[10:32:56.988]                             muffled <- TRUE
[10:32:56.988]                             break
[10:32:56.988]                           }
[10:32:56.988]                         }
[10:32:56.988]                       }
[10:32:56.988]                       invisible(muffled)
[10:32:56.988]                     }
[10:32:56.988]                     muffleCondition(cond, pattern = "^muffle")
[10:32:56.988]                   }
[10:32:56.988]                 }
[10:32:56.988]             }
[10:32:56.988]         }))
[10:32:56.988]     }, error = function(ex) {
[10:32:56.988]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:56.988]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:56.988]                 ...future.rng), started = ...future.startTime, 
[10:32:56.988]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:56.988]             version = "1.8"), class = "FutureResult")
[10:32:56.988]     }, finally = {
[10:32:56.988]         if (!identical(...future.workdir, getwd())) 
[10:32:56.988]             setwd(...future.workdir)
[10:32:56.988]         {
[10:32:56.988]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:56.988]                 ...future.oldOptions$nwarnings <- NULL
[10:32:56.988]             }
[10:32:56.988]             base::options(...future.oldOptions)
[10:32:56.988]             if (.Platform$OS.type == "windows") {
[10:32:56.988]                 old_names <- names(...future.oldEnvVars)
[10:32:56.988]                 envs <- base::Sys.getenv()
[10:32:56.988]                 names <- names(envs)
[10:32:56.988]                 common <- intersect(names, old_names)
[10:32:56.988]                 added <- setdiff(names, old_names)
[10:32:56.988]                 removed <- setdiff(old_names, names)
[10:32:56.988]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:56.988]                   envs[common]]
[10:32:56.988]                 NAMES <- toupper(changed)
[10:32:56.988]                 args <- list()
[10:32:56.988]                 for (kk in seq_along(NAMES)) {
[10:32:56.988]                   name <- changed[[kk]]
[10:32:56.988]                   NAME <- NAMES[[kk]]
[10:32:56.988]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.988]                     next
[10:32:56.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:56.988]                 }
[10:32:56.988]                 NAMES <- toupper(added)
[10:32:56.988]                 for (kk in seq_along(NAMES)) {
[10:32:56.988]                   name <- added[[kk]]
[10:32:56.988]                   NAME <- NAMES[[kk]]
[10:32:56.988]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.988]                     next
[10:32:56.988]                   args[[name]] <- ""
[10:32:56.988]                 }
[10:32:56.988]                 NAMES <- toupper(removed)
[10:32:56.988]                 for (kk in seq_along(NAMES)) {
[10:32:56.988]                   name <- removed[[kk]]
[10:32:56.988]                   NAME <- NAMES[[kk]]
[10:32:56.988]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:56.988]                     next
[10:32:56.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:56.988]                 }
[10:32:56.988]                 if (length(args) > 0) 
[10:32:56.988]                   base::do.call(base::Sys.setenv, args = args)
[10:32:56.988]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:56.988]             }
[10:32:56.988]             else {
[10:32:56.988]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:56.988]             }
[10:32:56.988]             {
[10:32:56.988]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:56.988]                   0L) {
[10:32:56.988]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:56.988]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:56.988]                   base::options(opts)
[10:32:56.988]                 }
[10:32:56.988]                 {
[10:32:56.988]                   {
[10:32:56.988]                     NULL
[10:32:56.988]                     RNGkind("Mersenne-Twister")
[10:32:56.988]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:56.988]                       inherits = FALSE)
[10:32:56.988]                   }
[10:32:56.988]                   options(future.plan = NULL)
[10:32:56.988]                   if (is.na(NA_character_)) 
[10:32:56.988]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:56.988]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:56.988]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:56.988]                     .init = FALSE)
[10:32:56.988]                 }
[10:32:56.988]             }
[10:32:56.988]         }
[10:32:56.988]     })
[10:32:56.988]     if (TRUE) {
[10:32:56.988]         base::sink(type = "output", split = FALSE)
[10:32:56.988]         if (TRUE) {
[10:32:56.988]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:56.988]         }
[10:32:56.988]         else {
[10:32:56.988]             ...future.result["stdout"] <- base::list(NULL)
[10:32:56.988]         }
[10:32:56.988]         base::close(...future.stdout)
[10:32:56.988]         ...future.stdout <- NULL
[10:32:56.988]     }
[10:32:56.988]     ...future.result$conditions <- ...future.conditions
[10:32:56.988]     ...future.result$finished <- base::Sys.time()
[10:32:56.988]     ...future.result
[10:32:56.988] }
[10:32:56.990] plan(): Setting new future strategy stack:
[10:32:56.990] List of future strategies:
[10:32:56.990] 1. sequential:
[10:32:56.990]    - args: function (..., envir = parent.frame())
[10:32:56.990]    - tweaked: FALSE
[10:32:56.990]    - call: NULL
[10:32:56.991] plan(): nbrOfWorkers() = 1
[10:32:56.992] plan(): Setting new future strategy stack:
[10:32:56.992] List of future strategies:
[10:32:56.992] 1. sequential:
[10:32:56.992]    - args: function (..., envir = parent.frame())
[10:32:56.992]    - tweaked: FALSE
[10:32:56.992]    - call: plan(strategy)
[10:32:56.992] plan(): nbrOfWorkers() = 1
[10:32:56.992] SequentialFuture started (and completed)
[10:32:56.992] - Launch lazy future ... done
[10:32:56.993] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[10:32:56.995] getGlobalsAndPackages() ...
[10:32:56.995] Searching for globals...
[10:32:56.996] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[10:32:56.996] Searching for globals ... DONE
[10:32:56.996] Resolving globals: FALSE
[10:32:56.997] 
[10:32:56.997] - packages: [2] ‘stats’, ‘datasets’
[10:32:56.997] getGlobalsAndPackages() ... DONE
[10:32:56.997] run() for ‘Future’ ...
[10:32:56.997] - state: ‘created’
[10:32:56.997] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:56.998] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:56.998] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:56.998]   - Field: ‘label’
[10:32:56.998]   - Field: ‘local’
[10:32:56.998]   - Field: ‘owner’
[10:32:56.998]   - Field: ‘envir’
[10:32:56.998]   - Field: ‘packages’
[10:32:56.998]   - Field: ‘gc’
[10:32:56.998]   - Field: ‘conditions’
[10:32:56.999]   - Field: ‘expr’
[10:32:56.999]   - Field: ‘uuid’
[10:32:56.999]   - Field: ‘seed’
[10:32:56.999]   - Field: ‘version’
[10:32:56.999]   - Field: ‘result’
[10:32:56.999]   - Field: ‘asynchronous’
[10:32:56.999]   - Field: ‘calls’
[10:32:56.999]   - Field: ‘globals’
[10:32:56.999]   - Field: ‘stdout’
[10:32:56.999]   - Field: ‘earlySignal’
[10:32:56.999]   - Field: ‘lazy’
[10:32:56.999]   - Field: ‘state’
[10:32:57.000] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:57.000] - Launch lazy future ...
[10:32:57.000] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:32:57.000] Packages needed by future strategies (n = 0): <none>
[10:32:57.000] {
[10:32:57.000]     {
[10:32:57.000]         {
[10:32:57.000]             ...future.startTime <- base::Sys.time()
[10:32:57.000]             {
[10:32:57.000]                 {
[10:32:57.000]                   {
[10:32:57.000]                     {
[10:32:57.000]                       base::local({
[10:32:57.000]                         has_future <- base::requireNamespace("future", 
[10:32:57.000]                           quietly = TRUE)
[10:32:57.000]                         if (has_future) {
[10:32:57.000]                           ns <- base::getNamespace("future")
[10:32:57.000]                           version <- ns[[".package"]][["version"]]
[10:32:57.000]                           if (is.null(version)) 
[10:32:57.000]                             version <- utils::packageVersion("future")
[10:32:57.000]                         }
[10:32:57.000]                         else {
[10:32:57.000]                           version <- NULL
[10:32:57.000]                         }
[10:32:57.000]                         if (!has_future || version < "1.8.0") {
[10:32:57.000]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:57.000]                             "", base::R.version$version.string), 
[10:32:57.000]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:57.000]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:57.000]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:57.000]                               "release", "version")], collapse = " "), 
[10:32:57.000]                             hostname = base::Sys.info()[["nodename"]])
[10:32:57.000]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:57.000]                             info)
[10:32:57.000]                           info <- base::paste(info, collapse = "; ")
[10:32:57.000]                           if (!has_future) {
[10:32:57.000]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:57.000]                               info)
[10:32:57.000]                           }
[10:32:57.000]                           else {
[10:32:57.000]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:57.000]                               info, version)
[10:32:57.000]                           }
[10:32:57.000]                           base::stop(msg)
[10:32:57.000]                         }
[10:32:57.000]                       })
[10:32:57.000]                     }
[10:32:57.000]                     base::local({
[10:32:57.000]                       for (pkg in c("stats", "datasets")) {
[10:32:57.000]                         base::loadNamespace(pkg)
[10:32:57.000]                         base::library(pkg, character.only = TRUE)
[10:32:57.000]                       }
[10:32:57.000]                     })
[10:32:57.000]                   }
[10:32:57.000]                   ...future.strategy.old <- future::plan("list")
[10:32:57.000]                   options(future.plan = NULL)
[10:32:57.000]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.000]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:57.000]                 }
[10:32:57.000]                 ...future.workdir <- getwd()
[10:32:57.000]             }
[10:32:57.000]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:57.000]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:57.000]         }
[10:32:57.000]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:57.000]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:57.000]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:57.000]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:57.000]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:57.000]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:57.000]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:57.000]             base::names(...future.oldOptions))
[10:32:57.000]     }
[10:32:57.000]     if (FALSE) {
[10:32:57.000]     }
[10:32:57.000]     else {
[10:32:57.000]         if (TRUE) {
[10:32:57.000]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:57.000]                 open = "w")
[10:32:57.000]         }
[10:32:57.000]         else {
[10:32:57.000]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:57.000]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:57.000]         }
[10:32:57.000]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:57.000]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:57.000]             base::sink(type = "output", split = FALSE)
[10:32:57.000]             base::close(...future.stdout)
[10:32:57.000]         }, add = TRUE)
[10:32:57.000]     }
[10:32:57.000]     ...future.frame <- base::sys.nframe()
[10:32:57.000]     ...future.conditions <- base::list()
[10:32:57.000]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:57.000]     if (FALSE) {
[10:32:57.000]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:57.000]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:57.000]     }
[10:32:57.000]     ...future.result <- base::tryCatch({
[10:32:57.000]         base::withCallingHandlers({
[10:32:57.000]             ...future.value <- base::withVisible(base::local({
[10:32:57.000]                 lm(dist ~ . + 0, data = cars)
[10:32:57.000]             }))
[10:32:57.000]             future::FutureResult(value = ...future.value$value, 
[10:32:57.000]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.000]                   ...future.rng), globalenv = if (FALSE) 
[10:32:57.000]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:57.000]                     ...future.globalenv.names))
[10:32:57.000]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:57.000]         }, condition = base::local({
[10:32:57.000]             c <- base::c
[10:32:57.000]             inherits <- base::inherits
[10:32:57.000]             invokeRestart <- base::invokeRestart
[10:32:57.000]             length <- base::length
[10:32:57.000]             list <- base::list
[10:32:57.000]             seq.int <- base::seq.int
[10:32:57.000]             signalCondition <- base::signalCondition
[10:32:57.000]             sys.calls <- base::sys.calls
[10:32:57.000]             `[[` <- base::`[[`
[10:32:57.000]             `+` <- base::`+`
[10:32:57.000]             `<<-` <- base::`<<-`
[10:32:57.000]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:57.000]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:57.000]                   3L)]
[10:32:57.000]             }
[10:32:57.000]             function(cond) {
[10:32:57.000]                 is_error <- inherits(cond, "error")
[10:32:57.000]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:57.000]                   NULL)
[10:32:57.000]                 if (is_error) {
[10:32:57.000]                   sessionInformation <- function() {
[10:32:57.000]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:57.000]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:57.000]                       search = base::search(), system = base::Sys.info())
[10:32:57.000]                   }
[10:32:57.000]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.000]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:57.000]                     cond$call), session = sessionInformation(), 
[10:32:57.000]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:57.000]                   signalCondition(cond)
[10:32:57.000]                 }
[10:32:57.000]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:57.000]                 "immediateCondition"))) {
[10:32:57.000]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:57.000]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.000]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:57.000]                   if (TRUE && !signal) {
[10:32:57.000]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.000]                     {
[10:32:57.000]                       inherits <- base::inherits
[10:32:57.000]                       invokeRestart <- base::invokeRestart
[10:32:57.000]                       is.null <- base::is.null
[10:32:57.000]                       muffled <- FALSE
[10:32:57.000]                       if (inherits(cond, "message")) {
[10:32:57.000]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.000]                         if (muffled) 
[10:32:57.000]                           invokeRestart("muffleMessage")
[10:32:57.000]                       }
[10:32:57.000]                       else if (inherits(cond, "warning")) {
[10:32:57.000]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.000]                         if (muffled) 
[10:32:57.000]                           invokeRestart("muffleWarning")
[10:32:57.000]                       }
[10:32:57.000]                       else if (inherits(cond, "condition")) {
[10:32:57.000]                         if (!is.null(pattern)) {
[10:32:57.000]                           computeRestarts <- base::computeRestarts
[10:32:57.000]                           grepl <- base::grepl
[10:32:57.000]                           restarts <- computeRestarts(cond)
[10:32:57.000]                           for (restart in restarts) {
[10:32:57.000]                             name <- restart$name
[10:32:57.000]                             if (is.null(name)) 
[10:32:57.000]                               next
[10:32:57.000]                             if (!grepl(pattern, name)) 
[10:32:57.000]                               next
[10:32:57.000]                             invokeRestart(restart)
[10:32:57.000]                             muffled <- TRUE
[10:32:57.000]                             break
[10:32:57.000]                           }
[10:32:57.000]                         }
[10:32:57.000]                       }
[10:32:57.000]                       invisible(muffled)
[10:32:57.000]                     }
[10:32:57.000]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.000]                   }
[10:32:57.000]                 }
[10:32:57.000]                 else {
[10:32:57.000]                   if (TRUE) {
[10:32:57.000]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.000]                     {
[10:32:57.000]                       inherits <- base::inherits
[10:32:57.000]                       invokeRestart <- base::invokeRestart
[10:32:57.000]                       is.null <- base::is.null
[10:32:57.000]                       muffled <- FALSE
[10:32:57.000]                       if (inherits(cond, "message")) {
[10:32:57.000]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.000]                         if (muffled) 
[10:32:57.000]                           invokeRestart("muffleMessage")
[10:32:57.000]                       }
[10:32:57.000]                       else if (inherits(cond, "warning")) {
[10:32:57.000]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.000]                         if (muffled) 
[10:32:57.000]                           invokeRestart("muffleWarning")
[10:32:57.000]                       }
[10:32:57.000]                       else if (inherits(cond, "condition")) {
[10:32:57.000]                         if (!is.null(pattern)) {
[10:32:57.000]                           computeRestarts <- base::computeRestarts
[10:32:57.000]                           grepl <- base::grepl
[10:32:57.000]                           restarts <- computeRestarts(cond)
[10:32:57.000]                           for (restart in restarts) {
[10:32:57.000]                             name <- restart$name
[10:32:57.000]                             if (is.null(name)) 
[10:32:57.000]                               next
[10:32:57.000]                             if (!grepl(pattern, name)) 
[10:32:57.000]                               next
[10:32:57.000]                             invokeRestart(restart)
[10:32:57.000]                             muffled <- TRUE
[10:32:57.000]                             break
[10:32:57.000]                           }
[10:32:57.000]                         }
[10:32:57.000]                       }
[10:32:57.000]                       invisible(muffled)
[10:32:57.000]                     }
[10:32:57.000]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.000]                   }
[10:32:57.000]                 }
[10:32:57.000]             }
[10:32:57.000]         }))
[10:32:57.000]     }, error = function(ex) {
[10:32:57.000]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:57.000]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.000]                 ...future.rng), started = ...future.startTime, 
[10:32:57.000]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:57.000]             version = "1.8"), class = "FutureResult")
[10:32:57.000]     }, finally = {
[10:32:57.000]         if (!identical(...future.workdir, getwd())) 
[10:32:57.000]             setwd(...future.workdir)
[10:32:57.000]         {
[10:32:57.000]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:57.000]                 ...future.oldOptions$nwarnings <- NULL
[10:32:57.000]             }
[10:32:57.000]             base::options(...future.oldOptions)
[10:32:57.000]             if (.Platform$OS.type == "windows") {
[10:32:57.000]                 old_names <- names(...future.oldEnvVars)
[10:32:57.000]                 envs <- base::Sys.getenv()
[10:32:57.000]                 names <- names(envs)
[10:32:57.000]                 common <- intersect(names, old_names)
[10:32:57.000]                 added <- setdiff(names, old_names)
[10:32:57.000]                 removed <- setdiff(old_names, names)
[10:32:57.000]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:57.000]                   envs[common]]
[10:32:57.000]                 NAMES <- toupper(changed)
[10:32:57.000]                 args <- list()
[10:32:57.000]                 for (kk in seq_along(NAMES)) {
[10:32:57.000]                   name <- changed[[kk]]
[10:32:57.000]                   NAME <- NAMES[[kk]]
[10:32:57.000]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.000]                     next
[10:32:57.000]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.000]                 }
[10:32:57.000]                 NAMES <- toupper(added)
[10:32:57.000]                 for (kk in seq_along(NAMES)) {
[10:32:57.000]                   name <- added[[kk]]
[10:32:57.000]                   NAME <- NAMES[[kk]]
[10:32:57.000]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.000]                     next
[10:32:57.000]                   args[[name]] <- ""
[10:32:57.000]                 }
[10:32:57.000]                 NAMES <- toupper(removed)
[10:32:57.000]                 for (kk in seq_along(NAMES)) {
[10:32:57.000]                   name <- removed[[kk]]
[10:32:57.000]                   NAME <- NAMES[[kk]]
[10:32:57.000]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.000]                     next
[10:32:57.000]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.000]                 }
[10:32:57.000]                 if (length(args) > 0) 
[10:32:57.000]                   base::do.call(base::Sys.setenv, args = args)
[10:32:57.000]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:57.000]             }
[10:32:57.000]             else {
[10:32:57.000]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:57.000]             }
[10:32:57.000]             {
[10:32:57.000]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:57.000]                   0L) {
[10:32:57.000]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:57.000]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:57.000]                   base::options(opts)
[10:32:57.000]                 }
[10:32:57.000]                 {
[10:32:57.000]                   {
[10:32:57.000]                     NULL
[10:32:57.000]                     RNGkind("Mersenne-Twister")
[10:32:57.000]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:57.000]                       inherits = FALSE)
[10:32:57.000]                   }
[10:32:57.000]                   options(future.plan = NULL)
[10:32:57.000]                   if (is.na(NA_character_)) 
[10:32:57.000]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.000]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:57.000]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:57.000]                     .init = FALSE)
[10:32:57.000]                 }
[10:32:57.000]             }
[10:32:57.000]         }
[10:32:57.000]     })
[10:32:57.000]     if (TRUE) {
[10:32:57.000]         base::sink(type = "output", split = FALSE)
[10:32:57.000]         if (TRUE) {
[10:32:57.000]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:57.000]         }
[10:32:57.000]         else {
[10:32:57.000]             ...future.result["stdout"] <- base::list(NULL)
[10:32:57.000]         }
[10:32:57.000]         base::close(...future.stdout)
[10:32:57.000]         ...future.stdout <- NULL
[10:32:57.000]     }
[10:32:57.000]     ...future.result$conditions <- ...future.conditions
[10:32:57.000]     ...future.result$finished <- base::Sys.time()
[10:32:57.000]     ...future.result
[10:32:57.000] }
[10:32:57.002] plan(): Setting new future strategy stack:
[10:32:57.002] List of future strategies:
[10:32:57.002] 1. sequential:
[10:32:57.002]    - args: function (..., envir = parent.frame())
[10:32:57.002]    - tweaked: FALSE
[10:32:57.002]    - call: NULL
[10:32:57.003] plan(): nbrOfWorkers() = 1
[10:32:57.004] plan(): Setting new future strategy stack:
[10:32:57.004] List of future strategies:
[10:32:57.004] 1. sequential:
[10:32:57.004]    - args: function (..., envir = parent.frame())
[10:32:57.004]    - tweaked: FALSE
[10:32:57.004]    - call: plan(strategy)
[10:32:57.004] plan(): nbrOfWorkers() = 1
[10:32:57.004] SequentialFuture started (and completed)
[10:32:57.005] - Launch lazy future ... done
[10:32:57.005] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[10:32:57.008] getGlobalsAndPackages() ...
[10:32:57.008] Searching for globals...
[10:32:57.010] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[10:32:57.010] Searching for globals ... DONE
[10:32:57.010] Resolving globals: FALSE
[10:32:57.010] 
[10:32:57.011] - packages: [2] ‘stats’, ‘datasets’
[10:32:57.011] getGlobalsAndPackages() ... DONE
[10:32:57.011] run() for ‘Future’ ...
[10:32:57.011] - state: ‘created’
[10:32:57.011] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:57.011] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:57.011] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:57.012]   - Field: ‘label’
[10:32:57.012]   - Field: ‘local’
[10:32:57.012]   - Field: ‘owner’
[10:32:57.012]   - Field: ‘envir’
[10:32:57.012]   - Field: ‘packages’
[10:32:57.012]   - Field: ‘gc’
[10:32:57.012]   - Field: ‘conditions’
[10:32:57.012]   - Field: ‘expr’
[10:32:57.012]   - Field: ‘uuid’
[10:32:57.012]   - Field: ‘seed’
[10:32:57.012]   - Field: ‘version’
[10:32:57.013]   - Field: ‘result’
[10:32:57.013]   - Field: ‘asynchronous’
[10:32:57.013]   - Field: ‘calls’
[10:32:57.013]   - Field: ‘globals’
[10:32:57.013]   - Field: ‘stdout’
[10:32:57.013]   - Field: ‘earlySignal’
[10:32:57.013]   - Field: ‘lazy’
[10:32:57.013]   - Field: ‘state’
[10:32:57.013] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:57.013] - Launch lazy future ...
[10:32:57.013] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:32:57.014] Packages needed by future strategies (n = 0): <none>
[10:32:57.014] {
[10:32:57.014]     {
[10:32:57.014]         {
[10:32:57.014]             ...future.startTime <- base::Sys.time()
[10:32:57.014]             {
[10:32:57.014]                 {
[10:32:57.014]                   {
[10:32:57.014]                     {
[10:32:57.014]                       base::local({
[10:32:57.014]                         has_future <- base::requireNamespace("future", 
[10:32:57.014]                           quietly = TRUE)
[10:32:57.014]                         if (has_future) {
[10:32:57.014]                           ns <- base::getNamespace("future")
[10:32:57.014]                           version <- ns[[".package"]][["version"]]
[10:32:57.014]                           if (is.null(version)) 
[10:32:57.014]                             version <- utils::packageVersion("future")
[10:32:57.014]                         }
[10:32:57.014]                         else {
[10:32:57.014]                           version <- NULL
[10:32:57.014]                         }
[10:32:57.014]                         if (!has_future || version < "1.8.0") {
[10:32:57.014]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:57.014]                             "", base::R.version$version.string), 
[10:32:57.014]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:57.014]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:57.014]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:57.014]                               "release", "version")], collapse = " "), 
[10:32:57.014]                             hostname = base::Sys.info()[["nodename"]])
[10:32:57.014]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:57.014]                             info)
[10:32:57.014]                           info <- base::paste(info, collapse = "; ")
[10:32:57.014]                           if (!has_future) {
[10:32:57.014]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:57.014]                               info)
[10:32:57.014]                           }
[10:32:57.014]                           else {
[10:32:57.014]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:57.014]                               info, version)
[10:32:57.014]                           }
[10:32:57.014]                           base::stop(msg)
[10:32:57.014]                         }
[10:32:57.014]                       })
[10:32:57.014]                     }
[10:32:57.014]                     base::local({
[10:32:57.014]                       for (pkg in c("stats", "datasets")) {
[10:32:57.014]                         base::loadNamespace(pkg)
[10:32:57.014]                         base::library(pkg, character.only = TRUE)
[10:32:57.014]                       }
[10:32:57.014]                     })
[10:32:57.014]                   }
[10:32:57.014]                   ...future.strategy.old <- future::plan("list")
[10:32:57.014]                   options(future.plan = NULL)
[10:32:57.014]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.014]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:57.014]                 }
[10:32:57.014]                 ...future.workdir <- getwd()
[10:32:57.014]             }
[10:32:57.014]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:57.014]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:57.014]         }
[10:32:57.014]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:57.014]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:57.014]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:57.014]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:57.014]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:57.014]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:57.014]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:57.014]             base::names(...future.oldOptions))
[10:32:57.014]     }
[10:32:57.014]     if (FALSE) {
[10:32:57.014]     }
[10:32:57.014]     else {
[10:32:57.014]         if (TRUE) {
[10:32:57.014]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:57.014]                 open = "w")
[10:32:57.014]         }
[10:32:57.014]         else {
[10:32:57.014]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:57.014]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:57.014]         }
[10:32:57.014]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:57.014]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:57.014]             base::sink(type = "output", split = FALSE)
[10:32:57.014]             base::close(...future.stdout)
[10:32:57.014]         }, add = TRUE)
[10:32:57.014]     }
[10:32:57.014]     ...future.frame <- base::sys.nframe()
[10:32:57.014]     ...future.conditions <- base::list()
[10:32:57.014]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:57.014]     if (FALSE) {
[10:32:57.014]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:57.014]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:57.014]     }
[10:32:57.014]     ...future.result <- base::tryCatch({
[10:32:57.014]         base::withCallingHandlers({
[10:32:57.014]             ...future.value <- base::withVisible(base::local({
[10:32:57.014]                 lm(dist ~ speed + speed^2, data = cars)
[10:32:57.014]             }))
[10:32:57.014]             future::FutureResult(value = ...future.value$value, 
[10:32:57.014]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.014]                   ...future.rng), globalenv = if (FALSE) 
[10:32:57.014]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:57.014]                     ...future.globalenv.names))
[10:32:57.014]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:57.014]         }, condition = base::local({
[10:32:57.014]             c <- base::c
[10:32:57.014]             inherits <- base::inherits
[10:32:57.014]             invokeRestart <- base::invokeRestart
[10:32:57.014]             length <- base::length
[10:32:57.014]             list <- base::list
[10:32:57.014]             seq.int <- base::seq.int
[10:32:57.014]             signalCondition <- base::signalCondition
[10:32:57.014]             sys.calls <- base::sys.calls
[10:32:57.014]             `[[` <- base::`[[`
[10:32:57.014]             `+` <- base::`+`
[10:32:57.014]             `<<-` <- base::`<<-`
[10:32:57.014]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:57.014]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:57.014]                   3L)]
[10:32:57.014]             }
[10:32:57.014]             function(cond) {
[10:32:57.014]                 is_error <- inherits(cond, "error")
[10:32:57.014]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:57.014]                   NULL)
[10:32:57.014]                 if (is_error) {
[10:32:57.014]                   sessionInformation <- function() {
[10:32:57.014]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:57.014]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:57.014]                       search = base::search(), system = base::Sys.info())
[10:32:57.014]                   }
[10:32:57.014]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.014]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:57.014]                     cond$call), session = sessionInformation(), 
[10:32:57.014]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:57.014]                   signalCondition(cond)
[10:32:57.014]                 }
[10:32:57.014]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:57.014]                 "immediateCondition"))) {
[10:32:57.014]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:57.014]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.014]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:57.014]                   if (TRUE && !signal) {
[10:32:57.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.014]                     {
[10:32:57.014]                       inherits <- base::inherits
[10:32:57.014]                       invokeRestart <- base::invokeRestart
[10:32:57.014]                       is.null <- base::is.null
[10:32:57.014]                       muffled <- FALSE
[10:32:57.014]                       if (inherits(cond, "message")) {
[10:32:57.014]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.014]                         if (muffled) 
[10:32:57.014]                           invokeRestart("muffleMessage")
[10:32:57.014]                       }
[10:32:57.014]                       else if (inherits(cond, "warning")) {
[10:32:57.014]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.014]                         if (muffled) 
[10:32:57.014]                           invokeRestart("muffleWarning")
[10:32:57.014]                       }
[10:32:57.014]                       else if (inherits(cond, "condition")) {
[10:32:57.014]                         if (!is.null(pattern)) {
[10:32:57.014]                           computeRestarts <- base::computeRestarts
[10:32:57.014]                           grepl <- base::grepl
[10:32:57.014]                           restarts <- computeRestarts(cond)
[10:32:57.014]                           for (restart in restarts) {
[10:32:57.014]                             name <- restart$name
[10:32:57.014]                             if (is.null(name)) 
[10:32:57.014]                               next
[10:32:57.014]                             if (!grepl(pattern, name)) 
[10:32:57.014]                               next
[10:32:57.014]                             invokeRestart(restart)
[10:32:57.014]                             muffled <- TRUE
[10:32:57.014]                             break
[10:32:57.014]                           }
[10:32:57.014]                         }
[10:32:57.014]                       }
[10:32:57.014]                       invisible(muffled)
[10:32:57.014]                     }
[10:32:57.014]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.014]                   }
[10:32:57.014]                 }
[10:32:57.014]                 else {
[10:32:57.014]                   if (TRUE) {
[10:32:57.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.014]                     {
[10:32:57.014]                       inherits <- base::inherits
[10:32:57.014]                       invokeRestart <- base::invokeRestart
[10:32:57.014]                       is.null <- base::is.null
[10:32:57.014]                       muffled <- FALSE
[10:32:57.014]                       if (inherits(cond, "message")) {
[10:32:57.014]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.014]                         if (muffled) 
[10:32:57.014]                           invokeRestart("muffleMessage")
[10:32:57.014]                       }
[10:32:57.014]                       else if (inherits(cond, "warning")) {
[10:32:57.014]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.014]                         if (muffled) 
[10:32:57.014]                           invokeRestart("muffleWarning")
[10:32:57.014]                       }
[10:32:57.014]                       else if (inherits(cond, "condition")) {
[10:32:57.014]                         if (!is.null(pattern)) {
[10:32:57.014]                           computeRestarts <- base::computeRestarts
[10:32:57.014]                           grepl <- base::grepl
[10:32:57.014]                           restarts <- computeRestarts(cond)
[10:32:57.014]                           for (restart in restarts) {
[10:32:57.014]                             name <- restart$name
[10:32:57.014]                             if (is.null(name)) 
[10:32:57.014]                               next
[10:32:57.014]                             if (!grepl(pattern, name)) 
[10:32:57.014]                               next
[10:32:57.014]                             invokeRestart(restart)
[10:32:57.014]                             muffled <- TRUE
[10:32:57.014]                             break
[10:32:57.014]                           }
[10:32:57.014]                         }
[10:32:57.014]                       }
[10:32:57.014]                       invisible(muffled)
[10:32:57.014]                     }
[10:32:57.014]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.014]                   }
[10:32:57.014]                 }
[10:32:57.014]             }
[10:32:57.014]         }))
[10:32:57.014]     }, error = function(ex) {
[10:32:57.014]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:57.014]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.014]                 ...future.rng), started = ...future.startTime, 
[10:32:57.014]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:57.014]             version = "1.8"), class = "FutureResult")
[10:32:57.014]     }, finally = {
[10:32:57.014]         if (!identical(...future.workdir, getwd())) 
[10:32:57.014]             setwd(...future.workdir)
[10:32:57.014]         {
[10:32:57.014]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:57.014]                 ...future.oldOptions$nwarnings <- NULL
[10:32:57.014]             }
[10:32:57.014]             base::options(...future.oldOptions)
[10:32:57.014]             if (.Platform$OS.type == "windows") {
[10:32:57.014]                 old_names <- names(...future.oldEnvVars)
[10:32:57.014]                 envs <- base::Sys.getenv()
[10:32:57.014]                 names <- names(envs)
[10:32:57.014]                 common <- intersect(names, old_names)
[10:32:57.014]                 added <- setdiff(names, old_names)
[10:32:57.014]                 removed <- setdiff(old_names, names)
[10:32:57.014]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:57.014]                   envs[common]]
[10:32:57.014]                 NAMES <- toupper(changed)
[10:32:57.014]                 args <- list()
[10:32:57.014]                 for (kk in seq_along(NAMES)) {
[10:32:57.014]                   name <- changed[[kk]]
[10:32:57.014]                   NAME <- NAMES[[kk]]
[10:32:57.014]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.014]                     next
[10:32:57.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.014]                 }
[10:32:57.014]                 NAMES <- toupper(added)
[10:32:57.014]                 for (kk in seq_along(NAMES)) {
[10:32:57.014]                   name <- added[[kk]]
[10:32:57.014]                   NAME <- NAMES[[kk]]
[10:32:57.014]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.014]                     next
[10:32:57.014]                   args[[name]] <- ""
[10:32:57.014]                 }
[10:32:57.014]                 NAMES <- toupper(removed)
[10:32:57.014]                 for (kk in seq_along(NAMES)) {
[10:32:57.014]                   name <- removed[[kk]]
[10:32:57.014]                   NAME <- NAMES[[kk]]
[10:32:57.014]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.014]                     next
[10:32:57.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.014]                 }
[10:32:57.014]                 if (length(args) > 0) 
[10:32:57.014]                   base::do.call(base::Sys.setenv, args = args)
[10:32:57.014]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:57.014]             }
[10:32:57.014]             else {
[10:32:57.014]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:57.014]             }
[10:32:57.014]             {
[10:32:57.014]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:57.014]                   0L) {
[10:32:57.014]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:57.014]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:57.014]                   base::options(opts)
[10:32:57.014]                 }
[10:32:57.014]                 {
[10:32:57.014]                   {
[10:32:57.014]                     NULL
[10:32:57.014]                     RNGkind("Mersenne-Twister")
[10:32:57.014]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:57.014]                       inherits = FALSE)
[10:32:57.014]                   }
[10:32:57.014]                   options(future.plan = NULL)
[10:32:57.014]                   if (is.na(NA_character_)) 
[10:32:57.014]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.014]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:57.014]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:57.014]                     .init = FALSE)
[10:32:57.014]                 }
[10:32:57.014]             }
[10:32:57.014]         }
[10:32:57.014]     })
[10:32:57.014]     if (TRUE) {
[10:32:57.014]         base::sink(type = "output", split = FALSE)
[10:32:57.014]         if (TRUE) {
[10:32:57.014]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:57.014]         }
[10:32:57.014]         else {
[10:32:57.014]             ...future.result["stdout"] <- base::list(NULL)
[10:32:57.014]         }
[10:32:57.014]         base::close(...future.stdout)
[10:32:57.014]         ...future.stdout <- NULL
[10:32:57.014]     }
[10:32:57.014]     ...future.result$conditions <- ...future.conditions
[10:32:57.014]     ...future.result$finished <- base::Sys.time()
[10:32:57.014]     ...future.result
[10:32:57.014] }
[10:32:57.016] plan(): Setting new future strategy stack:
[10:32:57.016] List of future strategies:
[10:32:57.016] 1. sequential:
[10:32:57.016]    - args: function (..., envir = parent.frame())
[10:32:57.016]    - tweaked: FALSE
[10:32:57.016]    - call: NULL
[10:32:57.016] plan(): nbrOfWorkers() = 1
[10:32:57.017] plan(): Setting new future strategy stack:
[10:32:57.018] List of future strategies:
[10:32:57.018] 1. sequential:
[10:32:57.018]    - args: function (..., envir = parent.frame())
[10:32:57.018]    - tweaked: FALSE
[10:32:57.018]    - call: plan(strategy)
[10:32:57.018] plan(): nbrOfWorkers() = 1
[10:32:57.018] SequentialFuture started (and completed)
[10:32:57.018] - Launch lazy future ... done
[10:32:57.018] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[10:32:57.021] getGlobalsAndPackages() ...
[10:32:57.021] Searching for globals...
[10:32:57.022] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[10:32:57.023] Searching for globals ... DONE
[10:32:57.023] Resolving globals: FALSE
[10:32:57.023] 
[10:32:57.023] - packages: [2] ‘stats’, ‘datasets’
[10:32:57.023] getGlobalsAndPackages() ... DONE
[10:32:57.024] run() for ‘Future’ ...
[10:32:57.024] - state: ‘created’
[10:32:57.024] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:57.024] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:57.024] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:57.024]   - Field: ‘label’
[10:32:57.024]   - Field: ‘local’
[10:32:57.024]   - Field: ‘owner’
[10:32:57.024]   - Field: ‘envir’
[10:32:57.025]   - Field: ‘packages’
[10:32:57.025]   - Field: ‘gc’
[10:32:57.025]   - Field: ‘conditions’
[10:32:57.025]   - Field: ‘expr’
[10:32:57.025]   - Field: ‘uuid’
[10:32:57.025]   - Field: ‘seed’
[10:32:57.025]   - Field: ‘version’
[10:32:57.025]   - Field: ‘result’
[10:32:57.025]   - Field: ‘asynchronous’
[10:32:57.025]   - Field: ‘calls’
[10:32:57.025]   - Field: ‘globals’
[10:32:57.026]   - Field: ‘stdout’
[10:32:57.026]   - Field: ‘earlySignal’
[10:32:57.026]   - Field: ‘lazy’
[10:32:57.026]   - Field: ‘state’
[10:32:57.026] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:57.026] - Launch lazy future ...
[10:32:57.026] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:32:57.026] Packages needed by future strategies (n = 0): <none>
[10:32:57.027] {
[10:32:57.027]     {
[10:32:57.027]         {
[10:32:57.027]             ...future.startTime <- base::Sys.time()
[10:32:57.027]             {
[10:32:57.027]                 {
[10:32:57.027]                   {
[10:32:57.027]                     {
[10:32:57.027]                       base::local({
[10:32:57.027]                         has_future <- base::requireNamespace("future", 
[10:32:57.027]                           quietly = TRUE)
[10:32:57.027]                         if (has_future) {
[10:32:57.027]                           ns <- base::getNamespace("future")
[10:32:57.027]                           version <- ns[[".package"]][["version"]]
[10:32:57.027]                           if (is.null(version)) 
[10:32:57.027]                             version <- utils::packageVersion("future")
[10:32:57.027]                         }
[10:32:57.027]                         else {
[10:32:57.027]                           version <- NULL
[10:32:57.027]                         }
[10:32:57.027]                         if (!has_future || version < "1.8.0") {
[10:32:57.027]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:57.027]                             "", base::R.version$version.string), 
[10:32:57.027]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:57.027]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:57.027]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:57.027]                               "release", "version")], collapse = " "), 
[10:32:57.027]                             hostname = base::Sys.info()[["nodename"]])
[10:32:57.027]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:57.027]                             info)
[10:32:57.027]                           info <- base::paste(info, collapse = "; ")
[10:32:57.027]                           if (!has_future) {
[10:32:57.027]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:57.027]                               info)
[10:32:57.027]                           }
[10:32:57.027]                           else {
[10:32:57.027]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:57.027]                               info, version)
[10:32:57.027]                           }
[10:32:57.027]                           base::stop(msg)
[10:32:57.027]                         }
[10:32:57.027]                       })
[10:32:57.027]                     }
[10:32:57.027]                     base::local({
[10:32:57.027]                       for (pkg in c("stats", "datasets")) {
[10:32:57.027]                         base::loadNamespace(pkg)
[10:32:57.027]                         base::library(pkg, character.only = TRUE)
[10:32:57.027]                       }
[10:32:57.027]                     })
[10:32:57.027]                   }
[10:32:57.027]                   ...future.strategy.old <- future::plan("list")
[10:32:57.027]                   options(future.plan = NULL)
[10:32:57.027]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.027]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:57.027]                 }
[10:32:57.027]                 ...future.workdir <- getwd()
[10:32:57.027]             }
[10:32:57.027]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:57.027]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:57.027]         }
[10:32:57.027]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:57.027]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:57.027]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:57.027]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:57.027]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:57.027]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:57.027]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:57.027]             base::names(...future.oldOptions))
[10:32:57.027]     }
[10:32:57.027]     if (FALSE) {
[10:32:57.027]     }
[10:32:57.027]     else {
[10:32:57.027]         if (TRUE) {
[10:32:57.027]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:57.027]                 open = "w")
[10:32:57.027]         }
[10:32:57.027]         else {
[10:32:57.027]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:57.027]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:57.027]         }
[10:32:57.027]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:57.027]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:57.027]             base::sink(type = "output", split = FALSE)
[10:32:57.027]             base::close(...future.stdout)
[10:32:57.027]         }, add = TRUE)
[10:32:57.027]     }
[10:32:57.027]     ...future.frame <- base::sys.nframe()
[10:32:57.027]     ...future.conditions <- base::list()
[10:32:57.027]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:57.027]     if (FALSE) {
[10:32:57.027]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:57.027]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:57.027]     }
[10:32:57.027]     ...future.result <- base::tryCatch({
[10:32:57.027]         base::withCallingHandlers({
[10:32:57.027]             ...future.value <- base::withVisible(base::local({
[10:32:57.027]                 lm(dist ~ speed + I(speed^2), data = cars)
[10:32:57.027]             }))
[10:32:57.027]             future::FutureResult(value = ...future.value$value, 
[10:32:57.027]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.027]                   ...future.rng), globalenv = if (FALSE) 
[10:32:57.027]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:57.027]                     ...future.globalenv.names))
[10:32:57.027]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:57.027]         }, condition = base::local({
[10:32:57.027]             c <- base::c
[10:32:57.027]             inherits <- base::inherits
[10:32:57.027]             invokeRestart <- base::invokeRestart
[10:32:57.027]             length <- base::length
[10:32:57.027]             list <- base::list
[10:32:57.027]             seq.int <- base::seq.int
[10:32:57.027]             signalCondition <- base::signalCondition
[10:32:57.027]             sys.calls <- base::sys.calls
[10:32:57.027]             `[[` <- base::`[[`
[10:32:57.027]             `+` <- base::`+`
[10:32:57.027]             `<<-` <- base::`<<-`
[10:32:57.027]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:57.027]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:57.027]                   3L)]
[10:32:57.027]             }
[10:32:57.027]             function(cond) {
[10:32:57.027]                 is_error <- inherits(cond, "error")
[10:32:57.027]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:57.027]                   NULL)
[10:32:57.027]                 if (is_error) {
[10:32:57.027]                   sessionInformation <- function() {
[10:32:57.027]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:57.027]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:57.027]                       search = base::search(), system = base::Sys.info())
[10:32:57.027]                   }
[10:32:57.027]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.027]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:57.027]                     cond$call), session = sessionInformation(), 
[10:32:57.027]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:57.027]                   signalCondition(cond)
[10:32:57.027]                 }
[10:32:57.027]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:57.027]                 "immediateCondition"))) {
[10:32:57.027]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:57.027]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.027]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:57.027]                   if (TRUE && !signal) {
[10:32:57.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.027]                     {
[10:32:57.027]                       inherits <- base::inherits
[10:32:57.027]                       invokeRestart <- base::invokeRestart
[10:32:57.027]                       is.null <- base::is.null
[10:32:57.027]                       muffled <- FALSE
[10:32:57.027]                       if (inherits(cond, "message")) {
[10:32:57.027]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.027]                         if (muffled) 
[10:32:57.027]                           invokeRestart("muffleMessage")
[10:32:57.027]                       }
[10:32:57.027]                       else if (inherits(cond, "warning")) {
[10:32:57.027]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.027]                         if (muffled) 
[10:32:57.027]                           invokeRestart("muffleWarning")
[10:32:57.027]                       }
[10:32:57.027]                       else if (inherits(cond, "condition")) {
[10:32:57.027]                         if (!is.null(pattern)) {
[10:32:57.027]                           computeRestarts <- base::computeRestarts
[10:32:57.027]                           grepl <- base::grepl
[10:32:57.027]                           restarts <- computeRestarts(cond)
[10:32:57.027]                           for (restart in restarts) {
[10:32:57.027]                             name <- restart$name
[10:32:57.027]                             if (is.null(name)) 
[10:32:57.027]                               next
[10:32:57.027]                             if (!grepl(pattern, name)) 
[10:32:57.027]                               next
[10:32:57.027]                             invokeRestart(restart)
[10:32:57.027]                             muffled <- TRUE
[10:32:57.027]                             break
[10:32:57.027]                           }
[10:32:57.027]                         }
[10:32:57.027]                       }
[10:32:57.027]                       invisible(muffled)
[10:32:57.027]                     }
[10:32:57.027]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.027]                   }
[10:32:57.027]                 }
[10:32:57.027]                 else {
[10:32:57.027]                   if (TRUE) {
[10:32:57.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.027]                     {
[10:32:57.027]                       inherits <- base::inherits
[10:32:57.027]                       invokeRestart <- base::invokeRestart
[10:32:57.027]                       is.null <- base::is.null
[10:32:57.027]                       muffled <- FALSE
[10:32:57.027]                       if (inherits(cond, "message")) {
[10:32:57.027]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.027]                         if (muffled) 
[10:32:57.027]                           invokeRestart("muffleMessage")
[10:32:57.027]                       }
[10:32:57.027]                       else if (inherits(cond, "warning")) {
[10:32:57.027]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.027]                         if (muffled) 
[10:32:57.027]                           invokeRestart("muffleWarning")
[10:32:57.027]                       }
[10:32:57.027]                       else if (inherits(cond, "condition")) {
[10:32:57.027]                         if (!is.null(pattern)) {
[10:32:57.027]                           computeRestarts <- base::computeRestarts
[10:32:57.027]                           grepl <- base::grepl
[10:32:57.027]                           restarts <- computeRestarts(cond)
[10:32:57.027]                           for (restart in restarts) {
[10:32:57.027]                             name <- restart$name
[10:32:57.027]                             if (is.null(name)) 
[10:32:57.027]                               next
[10:32:57.027]                             if (!grepl(pattern, name)) 
[10:32:57.027]                               next
[10:32:57.027]                             invokeRestart(restart)
[10:32:57.027]                             muffled <- TRUE
[10:32:57.027]                             break
[10:32:57.027]                           }
[10:32:57.027]                         }
[10:32:57.027]                       }
[10:32:57.027]                       invisible(muffled)
[10:32:57.027]                     }
[10:32:57.027]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.027]                   }
[10:32:57.027]                 }
[10:32:57.027]             }
[10:32:57.027]         }))
[10:32:57.027]     }, error = function(ex) {
[10:32:57.027]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:57.027]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.027]                 ...future.rng), started = ...future.startTime, 
[10:32:57.027]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:57.027]             version = "1.8"), class = "FutureResult")
[10:32:57.027]     }, finally = {
[10:32:57.027]         if (!identical(...future.workdir, getwd())) 
[10:32:57.027]             setwd(...future.workdir)
[10:32:57.027]         {
[10:32:57.027]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:57.027]                 ...future.oldOptions$nwarnings <- NULL
[10:32:57.027]             }
[10:32:57.027]             base::options(...future.oldOptions)
[10:32:57.027]             if (.Platform$OS.type == "windows") {
[10:32:57.027]                 old_names <- names(...future.oldEnvVars)
[10:32:57.027]                 envs <- base::Sys.getenv()
[10:32:57.027]                 names <- names(envs)
[10:32:57.027]                 common <- intersect(names, old_names)
[10:32:57.027]                 added <- setdiff(names, old_names)
[10:32:57.027]                 removed <- setdiff(old_names, names)
[10:32:57.027]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:57.027]                   envs[common]]
[10:32:57.027]                 NAMES <- toupper(changed)
[10:32:57.027]                 args <- list()
[10:32:57.027]                 for (kk in seq_along(NAMES)) {
[10:32:57.027]                   name <- changed[[kk]]
[10:32:57.027]                   NAME <- NAMES[[kk]]
[10:32:57.027]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.027]                     next
[10:32:57.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.027]                 }
[10:32:57.027]                 NAMES <- toupper(added)
[10:32:57.027]                 for (kk in seq_along(NAMES)) {
[10:32:57.027]                   name <- added[[kk]]
[10:32:57.027]                   NAME <- NAMES[[kk]]
[10:32:57.027]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.027]                     next
[10:32:57.027]                   args[[name]] <- ""
[10:32:57.027]                 }
[10:32:57.027]                 NAMES <- toupper(removed)
[10:32:57.027]                 for (kk in seq_along(NAMES)) {
[10:32:57.027]                   name <- removed[[kk]]
[10:32:57.027]                   NAME <- NAMES[[kk]]
[10:32:57.027]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.027]                     next
[10:32:57.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.027]                 }
[10:32:57.027]                 if (length(args) > 0) 
[10:32:57.027]                   base::do.call(base::Sys.setenv, args = args)
[10:32:57.027]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:57.027]             }
[10:32:57.027]             else {
[10:32:57.027]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:57.027]             }
[10:32:57.027]             {
[10:32:57.027]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:57.027]                   0L) {
[10:32:57.027]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:57.027]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:57.027]                   base::options(opts)
[10:32:57.027]                 }
[10:32:57.027]                 {
[10:32:57.027]                   {
[10:32:57.027]                     NULL
[10:32:57.027]                     RNGkind("Mersenne-Twister")
[10:32:57.027]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:57.027]                       inherits = FALSE)
[10:32:57.027]                   }
[10:32:57.027]                   options(future.plan = NULL)
[10:32:57.027]                   if (is.na(NA_character_)) 
[10:32:57.027]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.027]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:57.027]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:57.027]                     .init = FALSE)
[10:32:57.027]                 }
[10:32:57.027]             }
[10:32:57.027]         }
[10:32:57.027]     })
[10:32:57.027]     if (TRUE) {
[10:32:57.027]         base::sink(type = "output", split = FALSE)
[10:32:57.027]         if (TRUE) {
[10:32:57.027]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:57.027]         }
[10:32:57.027]         else {
[10:32:57.027]             ...future.result["stdout"] <- base::list(NULL)
[10:32:57.027]         }
[10:32:57.027]         base::close(...future.stdout)
[10:32:57.027]         ...future.stdout <- NULL
[10:32:57.027]     }
[10:32:57.027]     ...future.result$conditions <- ...future.conditions
[10:32:57.027]     ...future.result$finished <- base::Sys.time()
[10:32:57.027]     ...future.result
[10:32:57.027] }
[10:32:57.029] plan(): Setting new future strategy stack:
[10:32:57.029] List of future strategies:
[10:32:57.029] 1. sequential:
[10:32:57.029]    - args: function (..., envir = parent.frame())
[10:32:57.029]    - tweaked: FALSE
[10:32:57.029]    - call: NULL
[10:32:57.030] plan(): nbrOfWorkers() = 1
[10:32:57.031] plan(): Setting new future strategy stack:
[10:32:57.031] List of future strategies:
[10:32:57.031] 1. sequential:
[10:32:57.031]    - args: function (..., envir = parent.frame())
[10:32:57.031]    - tweaked: FALSE
[10:32:57.031]    - call: plan(strategy)
[10:32:57.032] plan(): nbrOfWorkers() = 1
[10:32:57.032] SequentialFuture started (and completed)
[10:32:57.032] - Launch lazy future ... done
[10:32:57.032] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[10:32:57.035] getGlobalsAndPackages() ...
[10:32:57.036] Searching for globals...
[10:32:57.037] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[10:32:57.037] Searching for globals ... DONE
[10:32:57.037] Resolving globals: FALSE
[10:32:57.038] 
[10:32:57.038] - packages: [2] ‘stats’, ‘datasets’
[10:32:57.038] getGlobalsAndPackages() ... DONE
[10:32:57.038] run() for ‘Future’ ...
[10:32:57.038] - state: ‘created’
[10:32:57.038] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:57.039] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:57.039] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:57.039]   - Field: ‘label’
[10:32:57.039]   - Field: ‘local’
[10:32:57.039]   - Field: ‘owner’
[10:32:57.039]   - Field: ‘envir’
[10:32:57.039]   - Field: ‘packages’
[10:32:57.039]   - Field: ‘gc’
[10:32:57.039]   - Field: ‘conditions’
[10:32:57.039]   - Field: ‘expr’
[10:32:57.040]   - Field: ‘uuid’
[10:32:57.040]   - Field: ‘seed’
[10:32:57.040]   - Field: ‘version’
[10:32:57.040]   - Field: ‘result’
[10:32:57.040]   - Field: ‘asynchronous’
[10:32:57.040]   - Field: ‘calls’
[10:32:57.040]   - Field: ‘globals’
[10:32:57.040]   - Field: ‘stdout’
[10:32:57.040]   - Field: ‘earlySignal’
[10:32:57.040]   - Field: ‘lazy’
[10:32:57.040]   - Field: ‘state’
[10:32:57.040] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:57.041] - Launch lazy future ...
[10:32:57.041] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:32:57.041] Packages needed by future strategies (n = 0): <none>
[10:32:57.041] {
[10:32:57.041]     {
[10:32:57.041]         {
[10:32:57.041]             ...future.startTime <- base::Sys.time()
[10:32:57.041]             {
[10:32:57.041]                 {
[10:32:57.041]                   {
[10:32:57.041]                     {
[10:32:57.041]                       base::local({
[10:32:57.041]                         has_future <- base::requireNamespace("future", 
[10:32:57.041]                           quietly = TRUE)
[10:32:57.041]                         if (has_future) {
[10:32:57.041]                           ns <- base::getNamespace("future")
[10:32:57.041]                           version <- ns[[".package"]][["version"]]
[10:32:57.041]                           if (is.null(version)) 
[10:32:57.041]                             version <- utils::packageVersion("future")
[10:32:57.041]                         }
[10:32:57.041]                         else {
[10:32:57.041]                           version <- NULL
[10:32:57.041]                         }
[10:32:57.041]                         if (!has_future || version < "1.8.0") {
[10:32:57.041]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:57.041]                             "", base::R.version$version.string), 
[10:32:57.041]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:57.041]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:57.041]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:57.041]                               "release", "version")], collapse = " "), 
[10:32:57.041]                             hostname = base::Sys.info()[["nodename"]])
[10:32:57.041]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:57.041]                             info)
[10:32:57.041]                           info <- base::paste(info, collapse = "; ")
[10:32:57.041]                           if (!has_future) {
[10:32:57.041]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:57.041]                               info)
[10:32:57.041]                           }
[10:32:57.041]                           else {
[10:32:57.041]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:57.041]                               info, version)
[10:32:57.041]                           }
[10:32:57.041]                           base::stop(msg)
[10:32:57.041]                         }
[10:32:57.041]                       })
[10:32:57.041]                     }
[10:32:57.041]                     base::local({
[10:32:57.041]                       for (pkg in c("stats", "datasets")) {
[10:32:57.041]                         base::loadNamespace(pkg)
[10:32:57.041]                         base::library(pkg, character.only = TRUE)
[10:32:57.041]                       }
[10:32:57.041]                     })
[10:32:57.041]                   }
[10:32:57.041]                   ...future.strategy.old <- future::plan("list")
[10:32:57.041]                   options(future.plan = NULL)
[10:32:57.041]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.041]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:57.041]                 }
[10:32:57.041]                 ...future.workdir <- getwd()
[10:32:57.041]             }
[10:32:57.041]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:57.041]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:57.041]         }
[10:32:57.041]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:57.041]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:57.041]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:57.041]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:57.041]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:57.041]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:57.041]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:57.041]             base::names(...future.oldOptions))
[10:32:57.041]     }
[10:32:57.041]     if (FALSE) {
[10:32:57.041]     }
[10:32:57.041]     else {
[10:32:57.041]         if (TRUE) {
[10:32:57.041]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:57.041]                 open = "w")
[10:32:57.041]         }
[10:32:57.041]         else {
[10:32:57.041]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:57.041]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:57.041]         }
[10:32:57.041]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:57.041]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:57.041]             base::sink(type = "output", split = FALSE)
[10:32:57.041]             base::close(...future.stdout)
[10:32:57.041]         }, add = TRUE)
[10:32:57.041]     }
[10:32:57.041]     ...future.frame <- base::sys.nframe()
[10:32:57.041]     ...future.conditions <- base::list()
[10:32:57.041]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:57.041]     if (FALSE) {
[10:32:57.041]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:57.041]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:57.041]     }
[10:32:57.041]     ...future.result <- base::tryCatch({
[10:32:57.041]         base::withCallingHandlers({
[10:32:57.041]             ...future.value <- base::withVisible(base::local({
[10:32:57.041]                 lm(dist ~ poly(speed, 2), data = cars)
[10:32:57.041]             }))
[10:32:57.041]             future::FutureResult(value = ...future.value$value, 
[10:32:57.041]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.041]                   ...future.rng), globalenv = if (FALSE) 
[10:32:57.041]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:57.041]                     ...future.globalenv.names))
[10:32:57.041]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:57.041]         }, condition = base::local({
[10:32:57.041]             c <- base::c
[10:32:57.041]             inherits <- base::inherits
[10:32:57.041]             invokeRestart <- base::invokeRestart
[10:32:57.041]             length <- base::length
[10:32:57.041]             list <- base::list
[10:32:57.041]             seq.int <- base::seq.int
[10:32:57.041]             signalCondition <- base::signalCondition
[10:32:57.041]             sys.calls <- base::sys.calls
[10:32:57.041]             `[[` <- base::`[[`
[10:32:57.041]             `+` <- base::`+`
[10:32:57.041]             `<<-` <- base::`<<-`
[10:32:57.041]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:57.041]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:57.041]                   3L)]
[10:32:57.041]             }
[10:32:57.041]             function(cond) {
[10:32:57.041]                 is_error <- inherits(cond, "error")
[10:32:57.041]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:57.041]                   NULL)
[10:32:57.041]                 if (is_error) {
[10:32:57.041]                   sessionInformation <- function() {
[10:32:57.041]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:57.041]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:57.041]                       search = base::search(), system = base::Sys.info())
[10:32:57.041]                   }
[10:32:57.041]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.041]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:57.041]                     cond$call), session = sessionInformation(), 
[10:32:57.041]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:57.041]                   signalCondition(cond)
[10:32:57.041]                 }
[10:32:57.041]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:57.041]                 "immediateCondition"))) {
[10:32:57.041]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:57.041]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.041]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:57.041]                   if (TRUE && !signal) {
[10:32:57.041]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.041]                     {
[10:32:57.041]                       inherits <- base::inherits
[10:32:57.041]                       invokeRestart <- base::invokeRestart
[10:32:57.041]                       is.null <- base::is.null
[10:32:57.041]                       muffled <- FALSE
[10:32:57.041]                       if (inherits(cond, "message")) {
[10:32:57.041]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.041]                         if (muffled) 
[10:32:57.041]                           invokeRestart("muffleMessage")
[10:32:57.041]                       }
[10:32:57.041]                       else if (inherits(cond, "warning")) {
[10:32:57.041]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.041]                         if (muffled) 
[10:32:57.041]                           invokeRestart("muffleWarning")
[10:32:57.041]                       }
[10:32:57.041]                       else if (inherits(cond, "condition")) {
[10:32:57.041]                         if (!is.null(pattern)) {
[10:32:57.041]                           computeRestarts <- base::computeRestarts
[10:32:57.041]                           grepl <- base::grepl
[10:32:57.041]                           restarts <- computeRestarts(cond)
[10:32:57.041]                           for (restart in restarts) {
[10:32:57.041]                             name <- restart$name
[10:32:57.041]                             if (is.null(name)) 
[10:32:57.041]                               next
[10:32:57.041]                             if (!grepl(pattern, name)) 
[10:32:57.041]                               next
[10:32:57.041]                             invokeRestart(restart)
[10:32:57.041]                             muffled <- TRUE
[10:32:57.041]                             break
[10:32:57.041]                           }
[10:32:57.041]                         }
[10:32:57.041]                       }
[10:32:57.041]                       invisible(muffled)
[10:32:57.041]                     }
[10:32:57.041]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.041]                   }
[10:32:57.041]                 }
[10:32:57.041]                 else {
[10:32:57.041]                   if (TRUE) {
[10:32:57.041]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.041]                     {
[10:32:57.041]                       inherits <- base::inherits
[10:32:57.041]                       invokeRestart <- base::invokeRestart
[10:32:57.041]                       is.null <- base::is.null
[10:32:57.041]                       muffled <- FALSE
[10:32:57.041]                       if (inherits(cond, "message")) {
[10:32:57.041]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.041]                         if (muffled) 
[10:32:57.041]                           invokeRestart("muffleMessage")
[10:32:57.041]                       }
[10:32:57.041]                       else if (inherits(cond, "warning")) {
[10:32:57.041]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.041]                         if (muffled) 
[10:32:57.041]                           invokeRestart("muffleWarning")
[10:32:57.041]                       }
[10:32:57.041]                       else if (inherits(cond, "condition")) {
[10:32:57.041]                         if (!is.null(pattern)) {
[10:32:57.041]                           computeRestarts <- base::computeRestarts
[10:32:57.041]                           grepl <- base::grepl
[10:32:57.041]                           restarts <- computeRestarts(cond)
[10:32:57.041]                           for (restart in restarts) {
[10:32:57.041]                             name <- restart$name
[10:32:57.041]                             if (is.null(name)) 
[10:32:57.041]                               next
[10:32:57.041]                             if (!grepl(pattern, name)) 
[10:32:57.041]                               next
[10:32:57.041]                             invokeRestart(restart)
[10:32:57.041]                             muffled <- TRUE
[10:32:57.041]                             break
[10:32:57.041]                           }
[10:32:57.041]                         }
[10:32:57.041]                       }
[10:32:57.041]                       invisible(muffled)
[10:32:57.041]                     }
[10:32:57.041]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.041]                   }
[10:32:57.041]                 }
[10:32:57.041]             }
[10:32:57.041]         }))
[10:32:57.041]     }, error = function(ex) {
[10:32:57.041]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:57.041]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.041]                 ...future.rng), started = ...future.startTime, 
[10:32:57.041]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:57.041]             version = "1.8"), class = "FutureResult")
[10:32:57.041]     }, finally = {
[10:32:57.041]         if (!identical(...future.workdir, getwd())) 
[10:32:57.041]             setwd(...future.workdir)
[10:32:57.041]         {
[10:32:57.041]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:57.041]                 ...future.oldOptions$nwarnings <- NULL
[10:32:57.041]             }
[10:32:57.041]             base::options(...future.oldOptions)
[10:32:57.041]             if (.Platform$OS.type == "windows") {
[10:32:57.041]                 old_names <- names(...future.oldEnvVars)
[10:32:57.041]                 envs <- base::Sys.getenv()
[10:32:57.041]                 names <- names(envs)
[10:32:57.041]                 common <- intersect(names, old_names)
[10:32:57.041]                 added <- setdiff(names, old_names)
[10:32:57.041]                 removed <- setdiff(old_names, names)
[10:32:57.041]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:57.041]                   envs[common]]
[10:32:57.041]                 NAMES <- toupper(changed)
[10:32:57.041]                 args <- list()
[10:32:57.041]                 for (kk in seq_along(NAMES)) {
[10:32:57.041]                   name <- changed[[kk]]
[10:32:57.041]                   NAME <- NAMES[[kk]]
[10:32:57.041]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.041]                     next
[10:32:57.041]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.041]                 }
[10:32:57.041]                 NAMES <- toupper(added)
[10:32:57.041]                 for (kk in seq_along(NAMES)) {
[10:32:57.041]                   name <- added[[kk]]
[10:32:57.041]                   NAME <- NAMES[[kk]]
[10:32:57.041]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.041]                     next
[10:32:57.041]                   args[[name]] <- ""
[10:32:57.041]                 }
[10:32:57.041]                 NAMES <- toupper(removed)
[10:32:57.041]                 for (kk in seq_along(NAMES)) {
[10:32:57.041]                   name <- removed[[kk]]
[10:32:57.041]                   NAME <- NAMES[[kk]]
[10:32:57.041]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.041]                     next
[10:32:57.041]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.041]                 }
[10:32:57.041]                 if (length(args) > 0) 
[10:32:57.041]                   base::do.call(base::Sys.setenv, args = args)
[10:32:57.041]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:57.041]             }
[10:32:57.041]             else {
[10:32:57.041]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:57.041]             }
[10:32:57.041]             {
[10:32:57.041]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:57.041]                   0L) {
[10:32:57.041]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:57.041]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:57.041]                   base::options(opts)
[10:32:57.041]                 }
[10:32:57.041]                 {
[10:32:57.041]                   {
[10:32:57.041]                     NULL
[10:32:57.041]                     RNGkind("Mersenne-Twister")
[10:32:57.041]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:57.041]                       inherits = FALSE)
[10:32:57.041]                   }
[10:32:57.041]                   options(future.plan = NULL)
[10:32:57.041]                   if (is.na(NA_character_)) 
[10:32:57.041]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.041]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:57.041]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:57.041]                     .init = FALSE)
[10:32:57.041]                 }
[10:32:57.041]             }
[10:32:57.041]         }
[10:32:57.041]     })
[10:32:57.041]     if (TRUE) {
[10:32:57.041]         base::sink(type = "output", split = FALSE)
[10:32:57.041]         if (TRUE) {
[10:32:57.041]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:57.041]         }
[10:32:57.041]         else {
[10:32:57.041]             ...future.result["stdout"] <- base::list(NULL)
[10:32:57.041]         }
[10:32:57.041]         base::close(...future.stdout)
[10:32:57.041]         ...future.stdout <- NULL
[10:32:57.041]     }
[10:32:57.041]     ...future.result$conditions <- ...future.conditions
[10:32:57.041]     ...future.result$finished <- base::Sys.time()
[10:32:57.041]     ...future.result
[10:32:57.041] }
[10:32:57.043] plan(): Setting new future strategy stack:
[10:32:57.043] List of future strategies:
[10:32:57.043] 1. sequential:
[10:32:57.043]    - args: function (..., envir = parent.frame())
[10:32:57.043]    - tweaked: FALSE
[10:32:57.043]    - call: NULL
[10:32:57.044] plan(): nbrOfWorkers() = 1
[10:32:57.045] plan(): Setting new future strategy stack:
[10:32:57.045] List of future strategies:
[10:32:57.045] 1. sequential:
[10:32:57.045]    - args: function (..., envir = parent.frame())
[10:32:57.045]    - tweaked: FALSE
[10:32:57.045]    - call: plan(strategy)
[10:32:57.046] plan(): nbrOfWorkers() = 1
[10:32:57.046] SequentialFuture started (and completed)
[10:32:57.046] - Launch lazy future ... done
[10:32:57.046] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[10:32:57.048] getGlobalsAndPackages() ...
[10:32:57.048] Searching for globals...
[10:32:57.054] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[10:32:57.054] Searching for globals ... DONE
[10:32:57.054] Resolving globals: FALSE
[10:32:57.055] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[10:32:57.055] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[10:32:57.055] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[10:32:57.055] 
[10:32:57.055] getGlobalsAndPackages() ... DONE
[10:32:57.056] run() for ‘Future’ ...
[10:32:57.056] - state: ‘created’
[10:32:57.056] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:57.056] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:57.056] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:57.056]   - Field: ‘label’
[10:32:57.056]   - Field: ‘local’
[10:32:57.056]   - Field: ‘owner’
[10:32:57.057]   - Field: ‘envir’
[10:32:57.057]   - Field: ‘packages’
[10:32:57.057]   - Field: ‘gc’
[10:32:57.057]   - Field: ‘conditions’
[10:32:57.057]   - Field: ‘expr’
[10:32:57.057]   - Field: ‘uuid’
[10:32:57.057]   - Field: ‘seed’
[10:32:57.057]   - Field: ‘version’
[10:32:57.057]   - Field: ‘result’
[10:32:57.057]   - Field: ‘asynchronous’
[10:32:57.057]   - Field: ‘calls’
[10:32:57.058]   - Field: ‘globals’
[10:32:57.058]   - Field: ‘stdout’
[10:32:57.058]   - Field: ‘earlySignal’
[10:32:57.058]   - Field: ‘lazy’
[10:32:57.058]   - Field: ‘state’
[10:32:57.058] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:57.058] - Launch lazy future ...
[10:32:57.058] Packages needed by the future expression (n = 0): <none>
[10:32:57.058] Packages needed by future strategies (n = 0): <none>
[10:32:57.059] {
[10:32:57.059]     {
[10:32:57.059]         {
[10:32:57.059]             ...future.startTime <- base::Sys.time()
[10:32:57.059]             {
[10:32:57.059]                 {
[10:32:57.059]                   {
[10:32:57.059]                     base::local({
[10:32:57.059]                       has_future <- base::requireNamespace("future", 
[10:32:57.059]                         quietly = TRUE)
[10:32:57.059]                       if (has_future) {
[10:32:57.059]                         ns <- base::getNamespace("future")
[10:32:57.059]                         version <- ns[[".package"]][["version"]]
[10:32:57.059]                         if (is.null(version)) 
[10:32:57.059]                           version <- utils::packageVersion("future")
[10:32:57.059]                       }
[10:32:57.059]                       else {
[10:32:57.059]                         version <- NULL
[10:32:57.059]                       }
[10:32:57.059]                       if (!has_future || version < "1.8.0") {
[10:32:57.059]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:57.059]                           "", base::R.version$version.string), 
[10:32:57.059]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:57.059]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:57.059]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:57.059]                             "release", "version")], collapse = " "), 
[10:32:57.059]                           hostname = base::Sys.info()[["nodename"]])
[10:32:57.059]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:57.059]                           info)
[10:32:57.059]                         info <- base::paste(info, collapse = "; ")
[10:32:57.059]                         if (!has_future) {
[10:32:57.059]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:57.059]                             info)
[10:32:57.059]                         }
[10:32:57.059]                         else {
[10:32:57.059]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:57.059]                             info, version)
[10:32:57.059]                         }
[10:32:57.059]                         base::stop(msg)
[10:32:57.059]                       }
[10:32:57.059]                     })
[10:32:57.059]                   }
[10:32:57.059]                   ...future.strategy.old <- future::plan("list")
[10:32:57.059]                   options(future.plan = NULL)
[10:32:57.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:57.059]                 }
[10:32:57.059]                 ...future.workdir <- getwd()
[10:32:57.059]             }
[10:32:57.059]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:57.059]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:57.059]         }
[10:32:57.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:57.059]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:57.059]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:57.059]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:57.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:57.059]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:57.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:57.059]             base::names(...future.oldOptions))
[10:32:57.059]     }
[10:32:57.059]     if (FALSE) {
[10:32:57.059]     }
[10:32:57.059]     else {
[10:32:57.059]         if (TRUE) {
[10:32:57.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:57.059]                 open = "w")
[10:32:57.059]         }
[10:32:57.059]         else {
[10:32:57.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:57.059]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:57.059]         }
[10:32:57.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:57.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:57.059]             base::sink(type = "output", split = FALSE)
[10:32:57.059]             base::close(...future.stdout)
[10:32:57.059]         }, add = TRUE)
[10:32:57.059]     }
[10:32:57.059]     ...future.frame <- base::sys.nframe()
[10:32:57.059]     ...future.conditions <- base::list()
[10:32:57.059]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:57.059]     if (FALSE) {
[10:32:57.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:57.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:57.059]     }
[10:32:57.059]     ...future.result <- base::tryCatch({
[10:32:57.059]         base::withCallingHandlers({
[10:32:57.059]             ...future.value <- base::withVisible(base::local({
[10:32:57.059]                 outer_function(1L)
[10:32:57.059]             }))
[10:32:57.059]             future::FutureResult(value = ...future.value$value, 
[10:32:57.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.059]                   ...future.rng), globalenv = if (FALSE) 
[10:32:57.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:57.059]                     ...future.globalenv.names))
[10:32:57.059]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:57.059]         }, condition = base::local({
[10:32:57.059]             c <- base::c
[10:32:57.059]             inherits <- base::inherits
[10:32:57.059]             invokeRestart <- base::invokeRestart
[10:32:57.059]             length <- base::length
[10:32:57.059]             list <- base::list
[10:32:57.059]             seq.int <- base::seq.int
[10:32:57.059]             signalCondition <- base::signalCondition
[10:32:57.059]             sys.calls <- base::sys.calls
[10:32:57.059]             `[[` <- base::`[[`
[10:32:57.059]             `+` <- base::`+`
[10:32:57.059]             `<<-` <- base::`<<-`
[10:32:57.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:57.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:57.059]                   3L)]
[10:32:57.059]             }
[10:32:57.059]             function(cond) {
[10:32:57.059]                 is_error <- inherits(cond, "error")
[10:32:57.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:57.059]                   NULL)
[10:32:57.059]                 if (is_error) {
[10:32:57.059]                   sessionInformation <- function() {
[10:32:57.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:57.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:57.059]                       search = base::search(), system = base::Sys.info())
[10:32:57.059]                   }
[10:32:57.059]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:57.059]                     cond$call), session = sessionInformation(), 
[10:32:57.059]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:57.059]                   signalCondition(cond)
[10:32:57.059]                 }
[10:32:57.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:57.059]                 "immediateCondition"))) {
[10:32:57.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:57.059]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:57.059]                   if (TRUE && !signal) {
[10:32:57.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.059]                     {
[10:32:57.059]                       inherits <- base::inherits
[10:32:57.059]                       invokeRestart <- base::invokeRestart
[10:32:57.059]                       is.null <- base::is.null
[10:32:57.059]                       muffled <- FALSE
[10:32:57.059]                       if (inherits(cond, "message")) {
[10:32:57.059]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.059]                         if (muffled) 
[10:32:57.059]                           invokeRestart("muffleMessage")
[10:32:57.059]                       }
[10:32:57.059]                       else if (inherits(cond, "warning")) {
[10:32:57.059]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.059]                         if (muffled) 
[10:32:57.059]                           invokeRestart("muffleWarning")
[10:32:57.059]                       }
[10:32:57.059]                       else if (inherits(cond, "condition")) {
[10:32:57.059]                         if (!is.null(pattern)) {
[10:32:57.059]                           computeRestarts <- base::computeRestarts
[10:32:57.059]                           grepl <- base::grepl
[10:32:57.059]                           restarts <- computeRestarts(cond)
[10:32:57.059]                           for (restart in restarts) {
[10:32:57.059]                             name <- restart$name
[10:32:57.059]                             if (is.null(name)) 
[10:32:57.059]                               next
[10:32:57.059]                             if (!grepl(pattern, name)) 
[10:32:57.059]                               next
[10:32:57.059]                             invokeRestart(restart)
[10:32:57.059]                             muffled <- TRUE
[10:32:57.059]                             break
[10:32:57.059]                           }
[10:32:57.059]                         }
[10:32:57.059]                       }
[10:32:57.059]                       invisible(muffled)
[10:32:57.059]                     }
[10:32:57.059]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.059]                   }
[10:32:57.059]                 }
[10:32:57.059]                 else {
[10:32:57.059]                   if (TRUE) {
[10:32:57.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.059]                     {
[10:32:57.059]                       inherits <- base::inherits
[10:32:57.059]                       invokeRestart <- base::invokeRestart
[10:32:57.059]                       is.null <- base::is.null
[10:32:57.059]                       muffled <- FALSE
[10:32:57.059]                       if (inherits(cond, "message")) {
[10:32:57.059]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.059]                         if (muffled) 
[10:32:57.059]                           invokeRestart("muffleMessage")
[10:32:57.059]                       }
[10:32:57.059]                       else if (inherits(cond, "warning")) {
[10:32:57.059]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.059]                         if (muffled) 
[10:32:57.059]                           invokeRestart("muffleWarning")
[10:32:57.059]                       }
[10:32:57.059]                       else if (inherits(cond, "condition")) {
[10:32:57.059]                         if (!is.null(pattern)) {
[10:32:57.059]                           computeRestarts <- base::computeRestarts
[10:32:57.059]                           grepl <- base::grepl
[10:32:57.059]                           restarts <- computeRestarts(cond)
[10:32:57.059]                           for (restart in restarts) {
[10:32:57.059]                             name <- restart$name
[10:32:57.059]                             if (is.null(name)) 
[10:32:57.059]                               next
[10:32:57.059]                             if (!grepl(pattern, name)) 
[10:32:57.059]                               next
[10:32:57.059]                             invokeRestart(restart)
[10:32:57.059]                             muffled <- TRUE
[10:32:57.059]                             break
[10:32:57.059]                           }
[10:32:57.059]                         }
[10:32:57.059]                       }
[10:32:57.059]                       invisible(muffled)
[10:32:57.059]                     }
[10:32:57.059]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.059]                   }
[10:32:57.059]                 }
[10:32:57.059]             }
[10:32:57.059]         }))
[10:32:57.059]     }, error = function(ex) {
[10:32:57.059]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:57.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.059]                 ...future.rng), started = ...future.startTime, 
[10:32:57.059]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:57.059]             version = "1.8"), class = "FutureResult")
[10:32:57.059]     }, finally = {
[10:32:57.059]         if (!identical(...future.workdir, getwd())) 
[10:32:57.059]             setwd(...future.workdir)
[10:32:57.059]         {
[10:32:57.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:57.059]                 ...future.oldOptions$nwarnings <- NULL
[10:32:57.059]             }
[10:32:57.059]             base::options(...future.oldOptions)
[10:32:57.059]             if (.Platform$OS.type == "windows") {
[10:32:57.059]                 old_names <- names(...future.oldEnvVars)
[10:32:57.059]                 envs <- base::Sys.getenv()
[10:32:57.059]                 names <- names(envs)
[10:32:57.059]                 common <- intersect(names, old_names)
[10:32:57.059]                 added <- setdiff(names, old_names)
[10:32:57.059]                 removed <- setdiff(old_names, names)
[10:32:57.059]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:57.059]                   envs[common]]
[10:32:57.059]                 NAMES <- toupper(changed)
[10:32:57.059]                 args <- list()
[10:32:57.059]                 for (kk in seq_along(NAMES)) {
[10:32:57.059]                   name <- changed[[kk]]
[10:32:57.059]                   NAME <- NAMES[[kk]]
[10:32:57.059]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.059]                     next
[10:32:57.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.059]                 }
[10:32:57.059]                 NAMES <- toupper(added)
[10:32:57.059]                 for (kk in seq_along(NAMES)) {
[10:32:57.059]                   name <- added[[kk]]
[10:32:57.059]                   NAME <- NAMES[[kk]]
[10:32:57.059]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.059]                     next
[10:32:57.059]                   args[[name]] <- ""
[10:32:57.059]                 }
[10:32:57.059]                 NAMES <- toupper(removed)
[10:32:57.059]                 for (kk in seq_along(NAMES)) {
[10:32:57.059]                   name <- removed[[kk]]
[10:32:57.059]                   NAME <- NAMES[[kk]]
[10:32:57.059]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.059]                     next
[10:32:57.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.059]                 }
[10:32:57.059]                 if (length(args) > 0) 
[10:32:57.059]                   base::do.call(base::Sys.setenv, args = args)
[10:32:57.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:57.059]             }
[10:32:57.059]             else {
[10:32:57.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:57.059]             }
[10:32:57.059]             {
[10:32:57.059]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:57.059]                   0L) {
[10:32:57.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:57.059]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:57.059]                   base::options(opts)
[10:32:57.059]                 }
[10:32:57.059]                 {
[10:32:57.059]                   {
[10:32:57.059]                     NULL
[10:32:57.059]                     RNGkind("Mersenne-Twister")
[10:32:57.059]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:57.059]                       inherits = FALSE)
[10:32:57.059]                   }
[10:32:57.059]                   options(future.plan = NULL)
[10:32:57.059]                   if (is.na(NA_character_)) 
[10:32:57.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:57.059]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:57.059]                     .init = FALSE)
[10:32:57.059]                 }
[10:32:57.059]             }
[10:32:57.059]         }
[10:32:57.059]     })
[10:32:57.059]     if (TRUE) {
[10:32:57.059]         base::sink(type = "output", split = FALSE)
[10:32:57.059]         if (TRUE) {
[10:32:57.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:57.059]         }
[10:32:57.059]         else {
[10:32:57.059]             ...future.result["stdout"] <- base::list(NULL)
[10:32:57.059]         }
[10:32:57.059]         base::close(...future.stdout)
[10:32:57.059]         ...future.stdout <- NULL
[10:32:57.059]     }
[10:32:57.059]     ...future.result$conditions <- ...future.conditions
[10:32:57.059]     ...future.result$finished <- base::Sys.time()
[10:32:57.059]     ...future.result
[10:32:57.059] }
[10:32:57.060] assign_globals() ...
[10:32:57.060] List of 3
[10:32:57.060]  $ outer_function:function (x)  
[10:32:57.060]  $ map           :function (.x, .f, ...)  
[10:32:57.060]  $ inner_function:function (x)  
[10:32:57.060]  - attr(*, "where")=List of 3
[10:32:57.060]   ..$ outer_function:<environment: R_EmptyEnv> 
[10:32:57.060]   ..$ map           :<environment: R_EmptyEnv> 
[10:32:57.060]   ..$ inner_function:<environment: R_EmptyEnv> 
[10:32:57.060]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:57.060]  - attr(*, "resolved")= logi FALSE
[10:32:57.060]  - attr(*, "total_size")= num 7704
[10:32:57.060]  - attr(*, "already-done")= logi TRUE
[10:32:57.063] - reassign environment for ‘outer_function’
[10:32:57.064] - copied ‘outer_function’ to environment
[10:32:57.064] - reassign environment for ‘map’
[10:32:57.064] - copied ‘map’ to environment
[10:32:57.064] - reassign environment for ‘inner_function’
[10:32:57.064] - copied ‘inner_function’ to environment
[10:32:57.064] assign_globals() ... done
[10:32:57.064] plan(): Setting new future strategy stack:
[10:32:57.064] List of future strategies:
[10:32:57.064] 1. sequential:
[10:32:57.064]    - args: function (..., envir = parent.frame())
[10:32:57.064]    - tweaked: FALSE
[10:32:57.064]    - call: NULL
[10:32:57.065] plan(): nbrOfWorkers() = 1
[10:32:57.069] plan(): Setting new future strategy stack:
[10:32:57.069] List of future strategies:
[10:32:57.069] 1. sequential:
[10:32:57.069]    - args: function (..., envir = parent.frame())
[10:32:57.069]    - tweaked: FALSE
[10:32:57.069]    - call: plan(strategy)
[10:32:57.070] plan(): nbrOfWorkers() = 1
[10:32:57.070] SequentialFuture started (and completed)
[10:32:57.070] - Launch lazy future ... done
[10:32:57.070] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[10:32:57.071] getGlobalsAndPackages() ...
[10:32:57.071] Searching for globals...
[10:32:57.076] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[10:32:57.077] Searching for globals ... DONE
[10:32:57.077] Resolving globals: FALSE
[10:32:57.077] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[10:32:57.078] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[10:32:57.078] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[10:32:57.078] 
[10:32:57.078] getGlobalsAndPackages() ... DONE
[10:32:57.078] run() for ‘Future’ ...
[10:32:57.078] - state: ‘created’
[10:32:57.079] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:57.079] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:57.079] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:57.079]   - Field: ‘label’
[10:32:57.079]   - Field: ‘local’
[10:32:57.079]   - Field: ‘owner’
[10:32:57.079]   - Field: ‘envir’
[10:32:57.079]   - Field: ‘packages’
[10:32:57.079]   - Field: ‘gc’
[10:32:57.079]   - Field: ‘conditions’
[10:32:57.080]   - Field: ‘expr’
[10:32:57.080]   - Field: ‘uuid’
[10:32:57.080]   - Field: ‘seed’
[10:32:57.080]   - Field: ‘version’
[10:32:57.080]   - Field: ‘result’
[10:32:57.080]   - Field: ‘asynchronous’
[10:32:57.080]   - Field: ‘calls’
[10:32:57.080]   - Field: ‘globals’
[10:32:57.080]   - Field: ‘stdout’
[10:32:57.080]   - Field: ‘earlySignal’
[10:32:57.080]   - Field: ‘lazy’
[10:32:57.081]   - Field: ‘state’
[10:32:57.081] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:57.081] - Launch lazy future ...
[10:32:57.081] Packages needed by the future expression (n = 0): <none>
[10:32:57.081] Packages needed by future strategies (n = 0): <none>
[10:32:57.081] {
[10:32:57.081]     {
[10:32:57.081]         {
[10:32:57.081]             ...future.startTime <- base::Sys.time()
[10:32:57.081]             {
[10:32:57.081]                 {
[10:32:57.081]                   {
[10:32:57.081]                     base::local({
[10:32:57.081]                       has_future <- base::requireNamespace("future", 
[10:32:57.081]                         quietly = TRUE)
[10:32:57.081]                       if (has_future) {
[10:32:57.081]                         ns <- base::getNamespace("future")
[10:32:57.081]                         version <- ns[[".package"]][["version"]]
[10:32:57.081]                         if (is.null(version)) 
[10:32:57.081]                           version <- utils::packageVersion("future")
[10:32:57.081]                       }
[10:32:57.081]                       else {
[10:32:57.081]                         version <- NULL
[10:32:57.081]                       }
[10:32:57.081]                       if (!has_future || version < "1.8.0") {
[10:32:57.081]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:57.081]                           "", base::R.version$version.string), 
[10:32:57.081]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:57.081]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:57.081]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:57.081]                             "release", "version")], collapse = " "), 
[10:32:57.081]                           hostname = base::Sys.info()[["nodename"]])
[10:32:57.081]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:57.081]                           info)
[10:32:57.081]                         info <- base::paste(info, collapse = "; ")
[10:32:57.081]                         if (!has_future) {
[10:32:57.081]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:57.081]                             info)
[10:32:57.081]                         }
[10:32:57.081]                         else {
[10:32:57.081]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:57.081]                             info, version)
[10:32:57.081]                         }
[10:32:57.081]                         base::stop(msg)
[10:32:57.081]                       }
[10:32:57.081]                     })
[10:32:57.081]                   }
[10:32:57.081]                   ...future.strategy.old <- future::plan("list")
[10:32:57.081]                   options(future.plan = NULL)
[10:32:57.081]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.081]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:57.081]                 }
[10:32:57.081]                 ...future.workdir <- getwd()
[10:32:57.081]             }
[10:32:57.081]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:57.081]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:57.081]         }
[10:32:57.081]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:57.081]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:57.081]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:57.081]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:57.081]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:57.081]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:57.081]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:57.081]             base::names(...future.oldOptions))
[10:32:57.081]     }
[10:32:57.081]     if (FALSE) {
[10:32:57.081]     }
[10:32:57.081]     else {
[10:32:57.081]         if (TRUE) {
[10:32:57.081]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:57.081]                 open = "w")
[10:32:57.081]         }
[10:32:57.081]         else {
[10:32:57.081]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:57.081]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:57.081]         }
[10:32:57.081]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:57.081]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:57.081]             base::sink(type = "output", split = FALSE)
[10:32:57.081]             base::close(...future.stdout)
[10:32:57.081]         }, add = TRUE)
[10:32:57.081]     }
[10:32:57.081]     ...future.frame <- base::sys.nframe()
[10:32:57.081]     ...future.conditions <- base::list()
[10:32:57.081]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:57.081]     if (FALSE) {
[10:32:57.081]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:57.081]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:57.081]     }
[10:32:57.081]     ...future.result <- base::tryCatch({
[10:32:57.081]         base::withCallingHandlers({
[10:32:57.081]             ...future.value <- base::withVisible(base::local({
[10:32:57.081]                 outer_function(1L)
[10:32:57.081]             }))
[10:32:57.081]             future::FutureResult(value = ...future.value$value, 
[10:32:57.081]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.081]                   ...future.rng), globalenv = if (FALSE) 
[10:32:57.081]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:57.081]                     ...future.globalenv.names))
[10:32:57.081]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:57.081]         }, condition = base::local({
[10:32:57.081]             c <- base::c
[10:32:57.081]             inherits <- base::inherits
[10:32:57.081]             invokeRestart <- base::invokeRestart
[10:32:57.081]             length <- base::length
[10:32:57.081]             list <- base::list
[10:32:57.081]             seq.int <- base::seq.int
[10:32:57.081]             signalCondition <- base::signalCondition
[10:32:57.081]             sys.calls <- base::sys.calls
[10:32:57.081]             `[[` <- base::`[[`
[10:32:57.081]             `+` <- base::`+`
[10:32:57.081]             `<<-` <- base::`<<-`
[10:32:57.081]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:57.081]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:57.081]                   3L)]
[10:32:57.081]             }
[10:32:57.081]             function(cond) {
[10:32:57.081]                 is_error <- inherits(cond, "error")
[10:32:57.081]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:57.081]                   NULL)
[10:32:57.081]                 if (is_error) {
[10:32:57.081]                   sessionInformation <- function() {
[10:32:57.081]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:57.081]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:57.081]                       search = base::search(), system = base::Sys.info())
[10:32:57.081]                   }
[10:32:57.081]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.081]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:57.081]                     cond$call), session = sessionInformation(), 
[10:32:57.081]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:57.081]                   signalCondition(cond)
[10:32:57.081]                 }
[10:32:57.081]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:57.081]                 "immediateCondition"))) {
[10:32:57.081]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:57.081]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.081]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:57.081]                   if (TRUE && !signal) {
[10:32:57.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.081]                     {
[10:32:57.081]                       inherits <- base::inherits
[10:32:57.081]                       invokeRestart <- base::invokeRestart
[10:32:57.081]                       is.null <- base::is.null
[10:32:57.081]                       muffled <- FALSE
[10:32:57.081]                       if (inherits(cond, "message")) {
[10:32:57.081]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.081]                         if (muffled) 
[10:32:57.081]                           invokeRestart("muffleMessage")
[10:32:57.081]                       }
[10:32:57.081]                       else if (inherits(cond, "warning")) {
[10:32:57.081]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.081]                         if (muffled) 
[10:32:57.081]                           invokeRestart("muffleWarning")
[10:32:57.081]                       }
[10:32:57.081]                       else if (inherits(cond, "condition")) {
[10:32:57.081]                         if (!is.null(pattern)) {
[10:32:57.081]                           computeRestarts <- base::computeRestarts
[10:32:57.081]                           grepl <- base::grepl
[10:32:57.081]                           restarts <- computeRestarts(cond)
[10:32:57.081]                           for (restart in restarts) {
[10:32:57.081]                             name <- restart$name
[10:32:57.081]                             if (is.null(name)) 
[10:32:57.081]                               next
[10:32:57.081]                             if (!grepl(pattern, name)) 
[10:32:57.081]                               next
[10:32:57.081]                             invokeRestart(restart)
[10:32:57.081]                             muffled <- TRUE
[10:32:57.081]                             break
[10:32:57.081]                           }
[10:32:57.081]                         }
[10:32:57.081]                       }
[10:32:57.081]                       invisible(muffled)
[10:32:57.081]                     }
[10:32:57.081]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.081]                   }
[10:32:57.081]                 }
[10:32:57.081]                 else {
[10:32:57.081]                   if (TRUE) {
[10:32:57.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.081]                     {
[10:32:57.081]                       inherits <- base::inherits
[10:32:57.081]                       invokeRestart <- base::invokeRestart
[10:32:57.081]                       is.null <- base::is.null
[10:32:57.081]                       muffled <- FALSE
[10:32:57.081]                       if (inherits(cond, "message")) {
[10:32:57.081]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.081]                         if (muffled) 
[10:32:57.081]                           invokeRestart("muffleMessage")
[10:32:57.081]                       }
[10:32:57.081]                       else if (inherits(cond, "warning")) {
[10:32:57.081]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.081]                         if (muffled) 
[10:32:57.081]                           invokeRestart("muffleWarning")
[10:32:57.081]                       }
[10:32:57.081]                       else if (inherits(cond, "condition")) {
[10:32:57.081]                         if (!is.null(pattern)) {
[10:32:57.081]                           computeRestarts <- base::computeRestarts
[10:32:57.081]                           grepl <- base::grepl
[10:32:57.081]                           restarts <- computeRestarts(cond)
[10:32:57.081]                           for (restart in restarts) {
[10:32:57.081]                             name <- restart$name
[10:32:57.081]                             if (is.null(name)) 
[10:32:57.081]                               next
[10:32:57.081]                             if (!grepl(pattern, name)) 
[10:32:57.081]                               next
[10:32:57.081]                             invokeRestart(restart)
[10:32:57.081]                             muffled <- TRUE
[10:32:57.081]                             break
[10:32:57.081]                           }
[10:32:57.081]                         }
[10:32:57.081]                       }
[10:32:57.081]                       invisible(muffled)
[10:32:57.081]                     }
[10:32:57.081]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.081]                   }
[10:32:57.081]                 }
[10:32:57.081]             }
[10:32:57.081]         }))
[10:32:57.081]     }, error = function(ex) {
[10:32:57.081]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:57.081]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.081]                 ...future.rng), started = ...future.startTime, 
[10:32:57.081]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:57.081]             version = "1.8"), class = "FutureResult")
[10:32:57.081]     }, finally = {
[10:32:57.081]         if (!identical(...future.workdir, getwd())) 
[10:32:57.081]             setwd(...future.workdir)
[10:32:57.081]         {
[10:32:57.081]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:57.081]                 ...future.oldOptions$nwarnings <- NULL
[10:32:57.081]             }
[10:32:57.081]             base::options(...future.oldOptions)
[10:32:57.081]             if (.Platform$OS.type == "windows") {
[10:32:57.081]                 old_names <- names(...future.oldEnvVars)
[10:32:57.081]                 envs <- base::Sys.getenv()
[10:32:57.081]                 names <- names(envs)
[10:32:57.081]                 common <- intersect(names, old_names)
[10:32:57.081]                 added <- setdiff(names, old_names)
[10:32:57.081]                 removed <- setdiff(old_names, names)
[10:32:57.081]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:57.081]                   envs[common]]
[10:32:57.081]                 NAMES <- toupper(changed)
[10:32:57.081]                 args <- list()
[10:32:57.081]                 for (kk in seq_along(NAMES)) {
[10:32:57.081]                   name <- changed[[kk]]
[10:32:57.081]                   NAME <- NAMES[[kk]]
[10:32:57.081]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.081]                     next
[10:32:57.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.081]                 }
[10:32:57.081]                 NAMES <- toupper(added)
[10:32:57.081]                 for (kk in seq_along(NAMES)) {
[10:32:57.081]                   name <- added[[kk]]
[10:32:57.081]                   NAME <- NAMES[[kk]]
[10:32:57.081]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.081]                     next
[10:32:57.081]                   args[[name]] <- ""
[10:32:57.081]                 }
[10:32:57.081]                 NAMES <- toupper(removed)
[10:32:57.081]                 for (kk in seq_along(NAMES)) {
[10:32:57.081]                   name <- removed[[kk]]
[10:32:57.081]                   NAME <- NAMES[[kk]]
[10:32:57.081]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.081]                     next
[10:32:57.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.081]                 }
[10:32:57.081]                 if (length(args) > 0) 
[10:32:57.081]                   base::do.call(base::Sys.setenv, args = args)
[10:32:57.081]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:57.081]             }
[10:32:57.081]             else {
[10:32:57.081]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:57.081]             }
[10:32:57.081]             {
[10:32:57.081]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:57.081]                   0L) {
[10:32:57.081]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:57.081]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:57.081]                   base::options(opts)
[10:32:57.081]                 }
[10:32:57.081]                 {
[10:32:57.081]                   {
[10:32:57.081]                     NULL
[10:32:57.081]                     RNGkind("Mersenne-Twister")
[10:32:57.081]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:57.081]                       inherits = FALSE)
[10:32:57.081]                   }
[10:32:57.081]                   options(future.plan = NULL)
[10:32:57.081]                   if (is.na(NA_character_)) 
[10:32:57.081]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.081]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:57.081]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:57.081]                     .init = FALSE)
[10:32:57.081]                 }
[10:32:57.081]             }
[10:32:57.081]         }
[10:32:57.081]     })
[10:32:57.081]     if (TRUE) {
[10:32:57.081]         base::sink(type = "output", split = FALSE)
[10:32:57.081]         if (TRUE) {
[10:32:57.081]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:57.081]         }
[10:32:57.081]         else {
[10:32:57.081]             ...future.result["stdout"] <- base::list(NULL)
[10:32:57.081]         }
[10:32:57.081]         base::close(...future.stdout)
[10:32:57.081]         ...future.stdout <- NULL
[10:32:57.081]     }
[10:32:57.081]     ...future.result$conditions <- ...future.conditions
[10:32:57.081]     ...future.result$finished <- base::Sys.time()
[10:32:57.081]     ...future.result
[10:32:57.081] }
[10:32:57.083] assign_globals() ...
[10:32:57.083] List of 3
[10:32:57.083]  $ outer_function:function (x)  
[10:32:57.083]  $ map           :function (.x, .f, ...)  
[10:32:57.083]  $ inner_function:function (x)  
[10:32:57.083]  - attr(*, "where")=List of 3
[10:32:57.083]   ..$ outer_function:<environment: R_EmptyEnv> 
[10:32:57.083]   ..$ map           :<environment: R_EmptyEnv> 
[10:32:57.083]   ..$ inner_function:<environment: R_EmptyEnv> 
[10:32:57.083]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:57.083]  - attr(*, "resolved")= logi FALSE
[10:32:57.083]  - attr(*, "total_size")= num 7704
[10:32:57.083]  - attr(*, "already-done")= logi TRUE
[10:32:57.086] - reassign environment for ‘outer_function’
[10:32:57.086] - copied ‘outer_function’ to environment
[10:32:57.086] - reassign environment for ‘map’
[10:32:57.086] - copied ‘map’ to environment
[10:32:57.087] - reassign environment for ‘inner_function’
[10:32:57.087] - copied ‘inner_function’ to environment
[10:32:57.087] assign_globals() ... done
[10:32:57.087] plan(): Setting new future strategy stack:
[10:32:57.087] List of future strategies:
[10:32:57.087] 1. sequential:
[10:32:57.087]    - args: function (..., envir = parent.frame())
[10:32:57.087]    - tweaked: FALSE
[10:32:57.087]    - call: NULL
[10:32:57.087] plan(): nbrOfWorkers() = 1
[10:32:57.088] plan(): Setting new future strategy stack:
[10:32:57.088] List of future strategies:
[10:32:57.088] 1. sequential:
[10:32:57.088]    - args: function (..., envir = parent.frame())
[10:32:57.088]    - tweaked: FALSE
[10:32:57.088]    - call: plan(strategy)
[10:32:57.088] plan(): nbrOfWorkers() = 1
[10:32:57.089] SequentialFuture started (and completed)
[10:32:57.089] - Launch lazy future ... done
[10:32:57.089] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[10:32:57.099] plan(): Setting new future strategy stack:
[10:32:57.099] List of future strategies:
[10:32:57.099] 1. multicore:
[10:32:57.099]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:57.099]    - tweaked: FALSE
[10:32:57.099]    - call: plan(strategy)
[10:32:57.103] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[10:32:57.103] getGlobalsAndPackages() ...
[10:32:57.103] Searching for globals...
[10:32:57.104] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:32:57.105] Searching for globals ... DONE
[10:32:57.105] Resolving globals: FALSE
[10:32:57.105] The total size of the 2 globals is 896 bytes (896 bytes)
[10:32:57.105] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:32:57.106] - globals: [2] ‘weight’, ‘group’
[10:32:57.106] - packages: [1] ‘stats’
[10:32:57.106] getGlobalsAndPackages() ... DONE
[10:32:57.106] run() for ‘Future’ ...
[10:32:57.106] - state: ‘created’
[10:32:57.106] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:57.110] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:57.110] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:57.110]   - Field: ‘label’
[10:32:57.110]   - Field: ‘local’
[10:32:57.110]   - Field: ‘owner’
[10:32:57.110]   - Field: ‘envir’
[10:32:57.110]   - Field: ‘workers’
[10:32:57.111]   - Field: ‘packages’
[10:32:57.111]   - Field: ‘gc’
[10:32:57.111]   - Field: ‘job’
[10:32:57.111]   - Field: ‘conditions’
[10:32:57.111]   - Field: ‘expr’
[10:32:57.111]   - Field: ‘uuid’
[10:32:57.111]   - Field: ‘seed’
[10:32:57.111]   - Field: ‘version’
[10:32:57.111]   - Field: ‘result’
[10:32:57.111]   - Field: ‘asynchronous’
[10:32:57.111]   - Field: ‘calls’
[10:32:57.111]   - Field: ‘globals’
[10:32:57.112]   - Field: ‘stdout’
[10:32:57.112]   - Field: ‘earlySignal’
[10:32:57.112]   - Field: ‘lazy’
[10:32:57.112]   - Field: ‘state’
[10:32:57.112] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:57.112] - Launch lazy future ...
[10:32:57.113] Packages needed by the future expression (n = 1): ‘stats’
[10:32:57.113] Packages needed by future strategies (n = 0): <none>
[10:32:57.114] {
[10:32:57.114]     {
[10:32:57.114]         {
[10:32:57.114]             ...future.startTime <- base::Sys.time()
[10:32:57.114]             {
[10:32:57.114]                 {
[10:32:57.114]                   {
[10:32:57.114]                     {
[10:32:57.114]                       {
[10:32:57.114]                         base::local({
[10:32:57.114]                           has_future <- base::requireNamespace("future", 
[10:32:57.114]                             quietly = TRUE)
[10:32:57.114]                           if (has_future) {
[10:32:57.114]                             ns <- base::getNamespace("future")
[10:32:57.114]                             version <- ns[[".package"]][["version"]]
[10:32:57.114]                             if (is.null(version)) 
[10:32:57.114]                               version <- utils::packageVersion("future")
[10:32:57.114]                           }
[10:32:57.114]                           else {
[10:32:57.114]                             version <- NULL
[10:32:57.114]                           }
[10:32:57.114]                           if (!has_future || version < "1.8.0") {
[10:32:57.114]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:57.114]                               "", base::R.version$version.string), 
[10:32:57.114]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:57.114]                                 base::R.version$platform, 8 * 
[10:32:57.114]                                   base::.Machine$sizeof.pointer), 
[10:32:57.114]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:57.114]                                 "release", "version")], collapse = " "), 
[10:32:57.114]                               hostname = base::Sys.info()[["nodename"]])
[10:32:57.114]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:57.114]                               info)
[10:32:57.114]                             info <- base::paste(info, collapse = "; ")
[10:32:57.114]                             if (!has_future) {
[10:32:57.114]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:57.114]                                 info)
[10:32:57.114]                             }
[10:32:57.114]                             else {
[10:32:57.114]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:57.114]                                 info, version)
[10:32:57.114]                             }
[10:32:57.114]                             base::stop(msg)
[10:32:57.114]                           }
[10:32:57.114]                         })
[10:32:57.114]                       }
[10:32:57.114]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:57.114]                       base::options(mc.cores = 1L)
[10:32:57.114]                     }
[10:32:57.114]                     base::local({
[10:32:57.114]                       for (pkg in "stats") {
[10:32:57.114]                         base::loadNamespace(pkg)
[10:32:57.114]                         base::library(pkg, character.only = TRUE)
[10:32:57.114]                       }
[10:32:57.114]                     })
[10:32:57.114]                   }
[10:32:57.114]                   ...future.strategy.old <- future::plan("list")
[10:32:57.114]                   options(future.plan = NULL)
[10:32:57.114]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.114]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:57.114]                 }
[10:32:57.114]                 ...future.workdir <- getwd()
[10:32:57.114]             }
[10:32:57.114]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:57.114]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:57.114]         }
[10:32:57.114]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:57.114]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:57.114]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:57.114]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:57.114]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:57.114]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:57.114]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:57.114]             base::names(...future.oldOptions))
[10:32:57.114]     }
[10:32:57.114]     if (FALSE) {
[10:32:57.114]     }
[10:32:57.114]     else {
[10:32:57.114]         if (TRUE) {
[10:32:57.114]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:57.114]                 open = "w")
[10:32:57.114]         }
[10:32:57.114]         else {
[10:32:57.114]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:57.114]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:57.114]         }
[10:32:57.114]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:57.114]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:57.114]             base::sink(type = "output", split = FALSE)
[10:32:57.114]             base::close(...future.stdout)
[10:32:57.114]         }, add = TRUE)
[10:32:57.114]     }
[10:32:57.114]     ...future.frame <- base::sys.nframe()
[10:32:57.114]     ...future.conditions <- base::list()
[10:32:57.114]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:57.114]     if (FALSE) {
[10:32:57.114]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:57.114]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:57.114]     }
[10:32:57.114]     ...future.result <- base::tryCatch({
[10:32:57.114]         base::withCallingHandlers({
[10:32:57.114]             ...future.value <- base::withVisible(base::local({
[10:32:57.114]                 withCallingHandlers({
[10:32:57.114]                   {
[10:32:57.114]                     lm(weight ~ group - 1)
[10:32:57.114]                   }
[10:32:57.114]                 }, immediateCondition = function(cond) {
[10:32:57.114]                   save_rds <- function (object, pathname, ...) 
[10:32:57.114]                   {
[10:32:57.114]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:57.114]                     if (file_test("-f", pathname_tmp)) {
[10:32:57.114]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.114]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:57.114]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.114]                         fi_tmp[["mtime"]])
[10:32:57.114]                     }
[10:32:57.114]                     tryCatch({
[10:32:57.114]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:57.114]                     }, error = function(ex) {
[10:32:57.114]                       msg <- conditionMessage(ex)
[10:32:57.114]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.114]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:57.114]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.114]                         fi_tmp[["mtime"]], msg)
[10:32:57.114]                       ex$message <- msg
[10:32:57.114]                       stop(ex)
[10:32:57.114]                     })
[10:32:57.114]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:57.114]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:57.114]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:57.114]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.114]                       fi <- file.info(pathname)
[10:32:57.114]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:57.114]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.114]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:57.114]                         fi[["size"]], fi[["mtime"]])
[10:32:57.114]                       stop(msg)
[10:32:57.114]                     }
[10:32:57.114]                     invisible(pathname)
[10:32:57.114]                   }
[10:32:57.114]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:57.114]                     rootPath = tempdir()) 
[10:32:57.114]                   {
[10:32:57.114]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:57.114]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:57.114]                       tmpdir = path, fileext = ".rds")
[10:32:57.114]                     save_rds(obj, file)
[10:32:57.114]                   }
[10:32:57.114]                   saveImmediateCondition(cond, path = "/tmp/RtmpZSnOM5/.future/immediateConditions")
[10:32:57.114]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.114]                   {
[10:32:57.114]                     inherits <- base::inherits
[10:32:57.114]                     invokeRestart <- base::invokeRestart
[10:32:57.114]                     is.null <- base::is.null
[10:32:57.114]                     muffled <- FALSE
[10:32:57.114]                     if (inherits(cond, "message")) {
[10:32:57.114]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:57.114]                       if (muffled) 
[10:32:57.114]                         invokeRestart("muffleMessage")
[10:32:57.114]                     }
[10:32:57.114]                     else if (inherits(cond, "warning")) {
[10:32:57.114]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:57.114]                       if (muffled) 
[10:32:57.114]                         invokeRestart("muffleWarning")
[10:32:57.114]                     }
[10:32:57.114]                     else if (inherits(cond, "condition")) {
[10:32:57.114]                       if (!is.null(pattern)) {
[10:32:57.114]                         computeRestarts <- base::computeRestarts
[10:32:57.114]                         grepl <- base::grepl
[10:32:57.114]                         restarts <- computeRestarts(cond)
[10:32:57.114]                         for (restart in restarts) {
[10:32:57.114]                           name <- restart$name
[10:32:57.114]                           if (is.null(name)) 
[10:32:57.114]                             next
[10:32:57.114]                           if (!grepl(pattern, name)) 
[10:32:57.114]                             next
[10:32:57.114]                           invokeRestart(restart)
[10:32:57.114]                           muffled <- TRUE
[10:32:57.114]                           break
[10:32:57.114]                         }
[10:32:57.114]                       }
[10:32:57.114]                     }
[10:32:57.114]                     invisible(muffled)
[10:32:57.114]                   }
[10:32:57.114]                   muffleCondition(cond)
[10:32:57.114]                 })
[10:32:57.114]             }))
[10:32:57.114]             future::FutureResult(value = ...future.value$value, 
[10:32:57.114]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.114]                   ...future.rng), globalenv = if (FALSE) 
[10:32:57.114]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:57.114]                     ...future.globalenv.names))
[10:32:57.114]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:57.114]         }, condition = base::local({
[10:32:57.114]             c <- base::c
[10:32:57.114]             inherits <- base::inherits
[10:32:57.114]             invokeRestart <- base::invokeRestart
[10:32:57.114]             length <- base::length
[10:32:57.114]             list <- base::list
[10:32:57.114]             seq.int <- base::seq.int
[10:32:57.114]             signalCondition <- base::signalCondition
[10:32:57.114]             sys.calls <- base::sys.calls
[10:32:57.114]             `[[` <- base::`[[`
[10:32:57.114]             `+` <- base::`+`
[10:32:57.114]             `<<-` <- base::`<<-`
[10:32:57.114]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:57.114]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:57.114]                   3L)]
[10:32:57.114]             }
[10:32:57.114]             function(cond) {
[10:32:57.114]                 is_error <- inherits(cond, "error")
[10:32:57.114]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:57.114]                   NULL)
[10:32:57.114]                 if (is_error) {
[10:32:57.114]                   sessionInformation <- function() {
[10:32:57.114]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:57.114]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:57.114]                       search = base::search(), system = base::Sys.info())
[10:32:57.114]                   }
[10:32:57.114]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.114]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:57.114]                     cond$call), session = sessionInformation(), 
[10:32:57.114]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:57.114]                   signalCondition(cond)
[10:32:57.114]                 }
[10:32:57.114]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:57.114]                 "immediateCondition"))) {
[10:32:57.114]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:57.114]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.114]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:57.114]                   if (TRUE && !signal) {
[10:32:57.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.114]                     {
[10:32:57.114]                       inherits <- base::inherits
[10:32:57.114]                       invokeRestart <- base::invokeRestart
[10:32:57.114]                       is.null <- base::is.null
[10:32:57.114]                       muffled <- FALSE
[10:32:57.114]                       if (inherits(cond, "message")) {
[10:32:57.114]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.114]                         if (muffled) 
[10:32:57.114]                           invokeRestart("muffleMessage")
[10:32:57.114]                       }
[10:32:57.114]                       else if (inherits(cond, "warning")) {
[10:32:57.114]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.114]                         if (muffled) 
[10:32:57.114]                           invokeRestart("muffleWarning")
[10:32:57.114]                       }
[10:32:57.114]                       else if (inherits(cond, "condition")) {
[10:32:57.114]                         if (!is.null(pattern)) {
[10:32:57.114]                           computeRestarts <- base::computeRestarts
[10:32:57.114]                           grepl <- base::grepl
[10:32:57.114]                           restarts <- computeRestarts(cond)
[10:32:57.114]                           for (restart in restarts) {
[10:32:57.114]                             name <- restart$name
[10:32:57.114]                             if (is.null(name)) 
[10:32:57.114]                               next
[10:32:57.114]                             if (!grepl(pattern, name)) 
[10:32:57.114]                               next
[10:32:57.114]                             invokeRestart(restart)
[10:32:57.114]                             muffled <- TRUE
[10:32:57.114]                             break
[10:32:57.114]                           }
[10:32:57.114]                         }
[10:32:57.114]                       }
[10:32:57.114]                       invisible(muffled)
[10:32:57.114]                     }
[10:32:57.114]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.114]                   }
[10:32:57.114]                 }
[10:32:57.114]                 else {
[10:32:57.114]                   if (TRUE) {
[10:32:57.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.114]                     {
[10:32:57.114]                       inherits <- base::inherits
[10:32:57.114]                       invokeRestart <- base::invokeRestart
[10:32:57.114]                       is.null <- base::is.null
[10:32:57.114]                       muffled <- FALSE
[10:32:57.114]                       if (inherits(cond, "message")) {
[10:32:57.114]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.114]                         if (muffled) 
[10:32:57.114]                           invokeRestart("muffleMessage")
[10:32:57.114]                       }
[10:32:57.114]                       else if (inherits(cond, "warning")) {
[10:32:57.114]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.114]                         if (muffled) 
[10:32:57.114]                           invokeRestart("muffleWarning")
[10:32:57.114]                       }
[10:32:57.114]                       else if (inherits(cond, "condition")) {
[10:32:57.114]                         if (!is.null(pattern)) {
[10:32:57.114]                           computeRestarts <- base::computeRestarts
[10:32:57.114]                           grepl <- base::grepl
[10:32:57.114]                           restarts <- computeRestarts(cond)
[10:32:57.114]                           for (restart in restarts) {
[10:32:57.114]                             name <- restart$name
[10:32:57.114]                             if (is.null(name)) 
[10:32:57.114]                               next
[10:32:57.114]                             if (!grepl(pattern, name)) 
[10:32:57.114]                               next
[10:32:57.114]                             invokeRestart(restart)
[10:32:57.114]                             muffled <- TRUE
[10:32:57.114]                             break
[10:32:57.114]                           }
[10:32:57.114]                         }
[10:32:57.114]                       }
[10:32:57.114]                       invisible(muffled)
[10:32:57.114]                     }
[10:32:57.114]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.114]                   }
[10:32:57.114]                 }
[10:32:57.114]             }
[10:32:57.114]         }))
[10:32:57.114]     }, error = function(ex) {
[10:32:57.114]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:57.114]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.114]                 ...future.rng), started = ...future.startTime, 
[10:32:57.114]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:57.114]             version = "1.8"), class = "FutureResult")
[10:32:57.114]     }, finally = {
[10:32:57.114]         if (!identical(...future.workdir, getwd())) 
[10:32:57.114]             setwd(...future.workdir)
[10:32:57.114]         {
[10:32:57.114]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:57.114]                 ...future.oldOptions$nwarnings <- NULL
[10:32:57.114]             }
[10:32:57.114]             base::options(...future.oldOptions)
[10:32:57.114]             if (.Platform$OS.type == "windows") {
[10:32:57.114]                 old_names <- names(...future.oldEnvVars)
[10:32:57.114]                 envs <- base::Sys.getenv()
[10:32:57.114]                 names <- names(envs)
[10:32:57.114]                 common <- intersect(names, old_names)
[10:32:57.114]                 added <- setdiff(names, old_names)
[10:32:57.114]                 removed <- setdiff(old_names, names)
[10:32:57.114]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:57.114]                   envs[common]]
[10:32:57.114]                 NAMES <- toupper(changed)
[10:32:57.114]                 args <- list()
[10:32:57.114]                 for (kk in seq_along(NAMES)) {
[10:32:57.114]                   name <- changed[[kk]]
[10:32:57.114]                   NAME <- NAMES[[kk]]
[10:32:57.114]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.114]                     next
[10:32:57.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.114]                 }
[10:32:57.114]                 NAMES <- toupper(added)
[10:32:57.114]                 for (kk in seq_along(NAMES)) {
[10:32:57.114]                   name <- added[[kk]]
[10:32:57.114]                   NAME <- NAMES[[kk]]
[10:32:57.114]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.114]                     next
[10:32:57.114]                   args[[name]] <- ""
[10:32:57.114]                 }
[10:32:57.114]                 NAMES <- toupper(removed)
[10:32:57.114]                 for (kk in seq_along(NAMES)) {
[10:32:57.114]                   name <- removed[[kk]]
[10:32:57.114]                   NAME <- NAMES[[kk]]
[10:32:57.114]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.114]                     next
[10:32:57.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.114]                 }
[10:32:57.114]                 if (length(args) > 0) 
[10:32:57.114]                   base::do.call(base::Sys.setenv, args = args)
[10:32:57.114]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:57.114]             }
[10:32:57.114]             else {
[10:32:57.114]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:57.114]             }
[10:32:57.114]             {
[10:32:57.114]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:57.114]                   0L) {
[10:32:57.114]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:57.114]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:57.114]                   base::options(opts)
[10:32:57.114]                 }
[10:32:57.114]                 {
[10:32:57.114]                   {
[10:32:57.114]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:57.114]                     NULL
[10:32:57.114]                   }
[10:32:57.114]                   options(future.plan = NULL)
[10:32:57.114]                   if (is.na(NA_character_)) 
[10:32:57.114]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.114]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:57.114]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:57.114]                     .init = FALSE)
[10:32:57.114]                 }
[10:32:57.114]             }
[10:32:57.114]         }
[10:32:57.114]     })
[10:32:57.114]     if (TRUE) {
[10:32:57.114]         base::sink(type = "output", split = FALSE)
[10:32:57.114]         if (TRUE) {
[10:32:57.114]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:57.114]         }
[10:32:57.114]         else {
[10:32:57.114]             ...future.result["stdout"] <- base::list(NULL)
[10:32:57.114]         }
[10:32:57.114]         base::close(...future.stdout)
[10:32:57.114]         ...future.stdout <- NULL
[10:32:57.114]     }
[10:32:57.114]     ...future.result$conditions <- ...future.conditions
[10:32:57.114]     ...future.result$finished <- base::Sys.time()
[10:32:57.114]     ...future.result
[10:32:57.114] }
[10:32:57.116] assign_globals() ...
[10:32:57.116] List of 2
[10:32:57.116]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:32:57.116]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:32:57.116]  - attr(*, "where")=List of 2
[10:32:57.116]   ..$ weight:<environment: R_EmptyEnv> 
[10:32:57.116]   ..$ group :<environment: R_EmptyEnv> 
[10:32:57.116]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:57.116]  - attr(*, "resolved")= logi FALSE
[10:32:57.116]  - attr(*, "total_size")= num 896
[10:32:57.116]  - attr(*, "already-done")= logi TRUE
[10:32:57.119] - copied ‘weight’ to environment
[10:32:57.119] - copied ‘group’ to environment
[10:32:57.119] assign_globals() ... done
[10:32:57.119] requestCore(): workers = 2
[10:32:57.122] MulticoreFuture started
[10:32:57.122] - Launch lazy future ... done
[10:32:57.122] run() for ‘MulticoreFuture’ ... done
[10:32:57.123] plan(): Setting new future strategy stack:
[10:32:57.124] result() for MulticoreFuture ...
[10:32:57.123] List of future strategies:
[10:32:57.123] 1. sequential:
[10:32:57.123]    - args: function (..., envir = parent.frame())
[10:32:57.123]    - tweaked: FALSE
[10:32:57.123]    - call: NULL
[10:32:57.124] plan(): nbrOfWorkers() = 1
[10:32:57.127] plan(): Setting new future strategy stack:
[10:32:57.128] List of future strategies:
[10:32:57.128] 1. multicore:
[10:32:57.128]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:57.128]    - tweaked: FALSE
[10:32:57.128]    - call: plan(strategy)
[10:32:57.137] plan(): nbrOfWorkers() = 2
[10:32:57.146] result() for MulticoreFuture ...
[10:32:57.146] result() for MulticoreFuture ... done
[10:32:57.146] result() for MulticoreFuture ... done
[10:32:57.147] result() for MulticoreFuture ...
[10:32:57.147] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:32:57.149] getGlobalsAndPackages() ...
[10:32:57.149] Searching for globals...
[10:32:57.151] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:32:57.151] Searching for globals ... DONE
[10:32:57.151] Resolving globals: FALSE
[10:32:57.152] The total size of the 2 globals is 896 bytes (896 bytes)
[10:32:57.152] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:32:57.153] - globals: [2] ‘weight’, ‘group’
[10:32:57.153] - packages: [1] ‘stats’
[10:32:57.153] getGlobalsAndPackages() ... DONE
[10:32:57.153] run() for ‘Future’ ...
[10:32:57.153] - state: ‘created’
[10:32:57.153] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:57.157] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:57.158] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:57.158]   - Field: ‘label’
[10:32:57.158]   - Field: ‘local’
[10:32:57.158]   - Field: ‘owner’
[10:32:57.158]   - Field: ‘envir’
[10:32:57.158]   - Field: ‘workers’
[10:32:57.159]   - Field: ‘packages’
[10:32:57.159]   - Field: ‘gc’
[10:32:57.159]   - Field: ‘job’
[10:32:57.159]   - Field: ‘conditions’
[10:32:57.159]   - Field: ‘expr’
[10:32:57.159]   - Field: ‘uuid’
[10:32:57.159]   - Field: ‘seed’
[10:32:57.159]   - Field: ‘version’
[10:32:57.160]   - Field: ‘result’
[10:32:57.160]   - Field: ‘asynchronous’
[10:32:57.160]   - Field: ‘calls’
[10:32:57.160]   - Field: ‘globals’
[10:32:57.160]   - Field: ‘stdout’
[10:32:57.160]   - Field: ‘earlySignal’
[10:32:57.160]   - Field: ‘lazy’
[10:32:57.160]   - Field: ‘state’
[10:32:57.160] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:57.160] - Launch lazy future ...
[10:32:57.161] Packages needed by the future expression (n = 1): ‘stats’
[10:32:57.161] Packages needed by future strategies (n = 0): <none>
[10:32:57.162] {
[10:32:57.162]     {
[10:32:57.162]         {
[10:32:57.162]             ...future.startTime <- base::Sys.time()
[10:32:57.162]             {
[10:32:57.162]                 {
[10:32:57.162]                   {
[10:32:57.162]                     {
[10:32:57.162]                       {
[10:32:57.162]                         base::local({
[10:32:57.162]                           has_future <- base::requireNamespace("future", 
[10:32:57.162]                             quietly = TRUE)
[10:32:57.162]                           if (has_future) {
[10:32:57.162]                             ns <- base::getNamespace("future")
[10:32:57.162]                             version <- ns[[".package"]][["version"]]
[10:32:57.162]                             if (is.null(version)) 
[10:32:57.162]                               version <- utils::packageVersion("future")
[10:32:57.162]                           }
[10:32:57.162]                           else {
[10:32:57.162]                             version <- NULL
[10:32:57.162]                           }
[10:32:57.162]                           if (!has_future || version < "1.8.0") {
[10:32:57.162]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:57.162]                               "", base::R.version$version.string), 
[10:32:57.162]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:57.162]                                 base::R.version$platform, 8 * 
[10:32:57.162]                                   base::.Machine$sizeof.pointer), 
[10:32:57.162]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:57.162]                                 "release", "version")], collapse = " "), 
[10:32:57.162]                               hostname = base::Sys.info()[["nodename"]])
[10:32:57.162]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:57.162]                               info)
[10:32:57.162]                             info <- base::paste(info, collapse = "; ")
[10:32:57.162]                             if (!has_future) {
[10:32:57.162]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:57.162]                                 info)
[10:32:57.162]                             }
[10:32:57.162]                             else {
[10:32:57.162]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:57.162]                                 info, version)
[10:32:57.162]                             }
[10:32:57.162]                             base::stop(msg)
[10:32:57.162]                           }
[10:32:57.162]                         })
[10:32:57.162]                       }
[10:32:57.162]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:57.162]                       base::options(mc.cores = 1L)
[10:32:57.162]                     }
[10:32:57.162]                     base::local({
[10:32:57.162]                       for (pkg in "stats") {
[10:32:57.162]                         base::loadNamespace(pkg)
[10:32:57.162]                         base::library(pkg, character.only = TRUE)
[10:32:57.162]                       }
[10:32:57.162]                     })
[10:32:57.162]                   }
[10:32:57.162]                   ...future.strategy.old <- future::plan("list")
[10:32:57.162]                   options(future.plan = NULL)
[10:32:57.162]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.162]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:57.162]                 }
[10:32:57.162]                 ...future.workdir <- getwd()
[10:32:57.162]             }
[10:32:57.162]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:57.162]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:57.162]         }
[10:32:57.162]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:57.162]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:57.162]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:57.162]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:57.162]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:57.162]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:57.162]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:57.162]             base::names(...future.oldOptions))
[10:32:57.162]     }
[10:32:57.162]     if (FALSE) {
[10:32:57.162]     }
[10:32:57.162]     else {
[10:32:57.162]         if (TRUE) {
[10:32:57.162]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:57.162]                 open = "w")
[10:32:57.162]         }
[10:32:57.162]         else {
[10:32:57.162]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:57.162]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:57.162]         }
[10:32:57.162]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:57.162]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:57.162]             base::sink(type = "output", split = FALSE)
[10:32:57.162]             base::close(...future.stdout)
[10:32:57.162]         }, add = TRUE)
[10:32:57.162]     }
[10:32:57.162]     ...future.frame <- base::sys.nframe()
[10:32:57.162]     ...future.conditions <- base::list()
[10:32:57.162]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:57.162]     if (FALSE) {
[10:32:57.162]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:57.162]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:57.162]     }
[10:32:57.162]     ...future.result <- base::tryCatch({
[10:32:57.162]         base::withCallingHandlers({
[10:32:57.162]             ...future.value <- base::withVisible(base::local({
[10:32:57.162]                 withCallingHandlers({
[10:32:57.162]                   {
[10:32:57.162]                     lm(weight ~ group - 1)
[10:32:57.162]                   }
[10:32:57.162]                 }, immediateCondition = function(cond) {
[10:32:57.162]                   save_rds <- function (object, pathname, ...) 
[10:32:57.162]                   {
[10:32:57.162]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:57.162]                     if (file_test("-f", pathname_tmp)) {
[10:32:57.162]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.162]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:57.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.162]                         fi_tmp[["mtime"]])
[10:32:57.162]                     }
[10:32:57.162]                     tryCatch({
[10:32:57.162]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:57.162]                     }, error = function(ex) {
[10:32:57.162]                       msg <- conditionMessage(ex)
[10:32:57.162]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.162]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:57.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.162]                         fi_tmp[["mtime"]], msg)
[10:32:57.162]                       ex$message <- msg
[10:32:57.162]                       stop(ex)
[10:32:57.162]                     })
[10:32:57.162]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:57.162]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:57.162]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:57.162]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.162]                       fi <- file.info(pathname)
[10:32:57.162]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:57.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.162]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:57.162]                         fi[["size"]], fi[["mtime"]])
[10:32:57.162]                       stop(msg)
[10:32:57.162]                     }
[10:32:57.162]                     invisible(pathname)
[10:32:57.162]                   }
[10:32:57.162]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:57.162]                     rootPath = tempdir()) 
[10:32:57.162]                   {
[10:32:57.162]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:57.162]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:57.162]                       tmpdir = path, fileext = ".rds")
[10:32:57.162]                     save_rds(obj, file)
[10:32:57.162]                   }
[10:32:57.162]                   saveImmediateCondition(cond, path = "/tmp/RtmpZSnOM5/.future/immediateConditions")
[10:32:57.162]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.162]                   {
[10:32:57.162]                     inherits <- base::inherits
[10:32:57.162]                     invokeRestart <- base::invokeRestart
[10:32:57.162]                     is.null <- base::is.null
[10:32:57.162]                     muffled <- FALSE
[10:32:57.162]                     if (inherits(cond, "message")) {
[10:32:57.162]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:57.162]                       if (muffled) 
[10:32:57.162]                         invokeRestart("muffleMessage")
[10:32:57.162]                     }
[10:32:57.162]                     else if (inherits(cond, "warning")) {
[10:32:57.162]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:57.162]                       if (muffled) 
[10:32:57.162]                         invokeRestart("muffleWarning")
[10:32:57.162]                     }
[10:32:57.162]                     else if (inherits(cond, "condition")) {
[10:32:57.162]                       if (!is.null(pattern)) {
[10:32:57.162]                         computeRestarts <- base::computeRestarts
[10:32:57.162]                         grepl <- base::grepl
[10:32:57.162]                         restarts <- computeRestarts(cond)
[10:32:57.162]                         for (restart in restarts) {
[10:32:57.162]                           name <- restart$name
[10:32:57.162]                           if (is.null(name)) 
[10:32:57.162]                             next
[10:32:57.162]                           if (!grepl(pattern, name)) 
[10:32:57.162]                             next
[10:32:57.162]                           invokeRestart(restart)
[10:32:57.162]                           muffled <- TRUE
[10:32:57.162]                           break
[10:32:57.162]                         }
[10:32:57.162]                       }
[10:32:57.162]                     }
[10:32:57.162]                     invisible(muffled)
[10:32:57.162]                   }
[10:32:57.162]                   muffleCondition(cond)
[10:32:57.162]                 })
[10:32:57.162]             }))
[10:32:57.162]             future::FutureResult(value = ...future.value$value, 
[10:32:57.162]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.162]                   ...future.rng), globalenv = if (FALSE) 
[10:32:57.162]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:57.162]                     ...future.globalenv.names))
[10:32:57.162]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:57.162]         }, condition = base::local({
[10:32:57.162]             c <- base::c
[10:32:57.162]             inherits <- base::inherits
[10:32:57.162]             invokeRestart <- base::invokeRestart
[10:32:57.162]             length <- base::length
[10:32:57.162]             list <- base::list
[10:32:57.162]             seq.int <- base::seq.int
[10:32:57.162]             signalCondition <- base::signalCondition
[10:32:57.162]             sys.calls <- base::sys.calls
[10:32:57.162]             `[[` <- base::`[[`
[10:32:57.162]             `+` <- base::`+`
[10:32:57.162]             `<<-` <- base::`<<-`
[10:32:57.162]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:57.162]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:57.162]                   3L)]
[10:32:57.162]             }
[10:32:57.162]             function(cond) {
[10:32:57.162]                 is_error <- inherits(cond, "error")
[10:32:57.162]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:57.162]                   NULL)
[10:32:57.162]                 if (is_error) {
[10:32:57.162]                   sessionInformation <- function() {
[10:32:57.162]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:57.162]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:57.162]                       search = base::search(), system = base::Sys.info())
[10:32:57.162]                   }
[10:32:57.162]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.162]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:57.162]                     cond$call), session = sessionInformation(), 
[10:32:57.162]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:57.162]                   signalCondition(cond)
[10:32:57.162]                 }
[10:32:57.162]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:57.162]                 "immediateCondition"))) {
[10:32:57.162]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:57.162]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.162]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:57.162]                   if (TRUE && !signal) {
[10:32:57.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.162]                     {
[10:32:57.162]                       inherits <- base::inherits
[10:32:57.162]                       invokeRestart <- base::invokeRestart
[10:32:57.162]                       is.null <- base::is.null
[10:32:57.162]                       muffled <- FALSE
[10:32:57.162]                       if (inherits(cond, "message")) {
[10:32:57.162]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.162]                         if (muffled) 
[10:32:57.162]                           invokeRestart("muffleMessage")
[10:32:57.162]                       }
[10:32:57.162]                       else if (inherits(cond, "warning")) {
[10:32:57.162]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.162]                         if (muffled) 
[10:32:57.162]                           invokeRestart("muffleWarning")
[10:32:57.162]                       }
[10:32:57.162]                       else if (inherits(cond, "condition")) {
[10:32:57.162]                         if (!is.null(pattern)) {
[10:32:57.162]                           computeRestarts <- base::computeRestarts
[10:32:57.162]                           grepl <- base::grepl
[10:32:57.162]                           restarts <- computeRestarts(cond)
[10:32:57.162]                           for (restart in restarts) {
[10:32:57.162]                             name <- restart$name
[10:32:57.162]                             if (is.null(name)) 
[10:32:57.162]                               next
[10:32:57.162]                             if (!grepl(pattern, name)) 
[10:32:57.162]                               next
[10:32:57.162]                             invokeRestart(restart)
[10:32:57.162]                             muffled <- TRUE
[10:32:57.162]                             break
[10:32:57.162]                           }
[10:32:57.162]                         }
[10:32:57.162]                       }
[10:32:57.162]                       invisible(muffled)
[10:32:57.162]                     }
[10:32:57.162]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.162]                   }
[10:32:57.162]                 }
[10:32:57.162]                 else {
[10:32:57.162]                   if (TRUE) {
[10:32:57.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.162]                     {
[10:32:57.162]                       inherits <- base::inherits
[10:32:57.162]                       invokeRestart <- base::invokeRestart
[10:32:57.162]                       is.null <- base::is.null
[10:32:57.162]                       muffled <- FALSE
[10:32:57.162]                       if (inherits(cond, "message")) {
[10:32:57.162]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.162]                         if (muffled) 
[10:32:57.162]                           invokeRestart("muffleMessage")
[10:32:57.162]                       }
[10:32:57.162]                       else if (inherits(cond, "warning")) {
[10:32:57.162]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.162]                         if (muffled) 
[10:32:57.162]                           invokeRestart("muffleWarning")
[10:32:57.162]                       }
[10:32:57.162]                       else if (inherits(cond, "condition")) {
[10:32:57.162]                         if (!is.null(pattern)) {
[10:32:57.162]                           computeRestarts <- base::computeRestarts
[10:32:57.162]                           grepl <- base::grepl
[10:32:57.162]                           restarts <- computeRestarts(cond)
[10:32:57.162]                           for (restart in restarts) {
[10:32:57.162]                             name <- restart$name
[10:32:57.162]                             if (is.null(name)) 
[10:32:57.162]                               next
[10:32:57.162]                             if (!grepl(pattern, name)) 
[10:32:57.162]                               next
[10:32:57.162]                             invokeRestart(restart)
[10:32:57.162]                             muffled <- TRUE
[10:32:57.162]                             break
[10:32:57.162]                           }
[10:32:57.162]                         }
[10:32:57.162]                       }
[10:32:57.162]                       invisible(muffled)
[10:32:57.162]                     }
[10:32:57.162]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.162]                   }
[10:32:57.162]                 }
[10:32:57.162]             }
[10:32:57.162]         }))
[10:32:57.162]     }, error = function(ex) {
[10:32:57.162]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:57.162]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.162]                 ...future.rng), started = ...future.startTime, 
[10:32:57.162]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:57.162]             version = "1.8"), class = "FutureResult")
[10:32:57.162]     }, finally = {
[10:32:57.162]         if (!identical(...future.workdir, getwd())) 
[10:32:57.162]             setwd(...future.workdir)
[10:32:57.162]         {
[10:32:57.162]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:57.162]                 ...future.oldOptions$nwarnings <- NULL
[10:32:57.162]             }
[10:32:57.162]             base::options(...future.oldOptions)
[10:32:57.162]             if (.Platform$OS.type == "windows") {
[10:32:57.162]                 old_names <- names(...future.oldEnvVars)
[10:32:57.162]                 envs <- base::Sys.getenv()
[10:32:57.162]                 names <- names(envs)
[10:32:57.162]                 common <- intersect(names, old_names)
[10:32:57.162]                 added <- setdiff(names, old_names)
[10:32:57.162]                 removed <- setdiff(old_names, names)
[10:32:57.162]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:57.162]                   envs[common]]
[10:32:57.162]                 NAMES <- toupper(changed)
[10:32:57.162]                 args <- list()
[10:32:57.162]                 for (kk in seq_along(NAMES)) {
[10:32:57.162]                   name <- changed[[kk]]
[10:32:57.162]                   NAME <- NAMES[[kk]]
[10:32:57.162]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.162]                     next
[10:32:57.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.162]                 }
[10:32:57.162]                 NAMES <- toupper(added)
[10:32:57.162]                 for (kk in seq_along(NAMES)) {
[10:32:57.162]                   name <- added[[kk]]
[10:32:57.162]                   NAME <- NAMES[[kk]]
[10:32:57.162]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.162]                     next
[10:32:57.162]                   args[[name]] <- ""
[10:32:57.162]                 }
[10:32:57.162]                 NAMES <- toupper(removed)
[10:32:57.162]                 for (kk in seq_along(NAMES)) {
[10:32:57.162]                   name <- removed[[kk]]
[10:32:57.162]                   NAME <- NAMES[[kk]]
[10:32:57.162]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.162]                     next
[10:32:57.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.162]                 }
[10:32:57.162]                 if (length(args) > 0) 
[10:32:57.162]                   base::do.call(base::Sys.setenv, args = args)
[10:32:57.162]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:57.162]             }
[10:32:57.162]             else {
[10:32:57.162]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:57.162]             }
[10:32:57.162]             {
[10:32:57.162]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:57.162]                   0L) {
[10:32:57.162]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:57.162]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:57.162]                   base::options(opts)
[10:32:57.162]                 }
[10:32:57.162]                 {
[10:32:57.162]                   {
[10:32:57.162]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:57.162]                     NULL
[10:32:57.162]                   }
[10:32:57.162]                   options(future.plan = NULL)
[10:32:57.162]                   if (is.na(NA_character_)) 
[10:32:57.162]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.162]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:57.162]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:57.162]                     .init = FALSE)
[10:32:57.162]                 }
[10:32:57.162]             }
[10:32:57.162]         }
[10:32:57.162]     })
[10:32:57.162]     if (TRUE) {
[10:32:57.162]         base::sink(type = "output", split = FALSE)
[10:32:57.162]         if (TRUE) {
[10:32:57.162]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:57.162]         }
[10:32:57.162]         else {
[10:32:57.162]             ...future.result["stdout"] <- base::list(NULL)
[10:32:57.162]         }
[10:32:57.162]         base::close(...future.stdout)
[10:32:57.162]         ...future.stdout <- NULL
[10:32:57.162]     }
[10:32:57.162]     ...future.result$conditions <- ...future.conditions
[10:32:57.162]     ...future.result$finished <- base::Sys.time()
[10:32:57.162]     ...future.result
[10:32:57.162] }
[10:32:57.164] assign_globals() ...
[10:32:57.164] List of 2
[10:32:57.164]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:32:57.164]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:32:57.164]  - attr(*, "where")=List of 2
[10:32:57.164]   ..$ weight:<environment: R_EmptyEnv> 
[10:32:57.164]   ..$ group :<environment: R_EmptyEnv> 
[10:32:57.164]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:57.164]  - attr(*, "resolved")= logi FALSE
[10:32:57.164]  - attr(*, "total_size")= num 896
[10:32:57.164]  - attr(*, "already-done")= logi TRUE
[10:32:57.168] - copied ‘weight’ to environment
[10:32:57.168] - copied ‘group’ to environment
[10:32:57.168] assign_globals() ... done
[10:32:57.168] requestCore(): workers = 2
[10:32:57.170] MulticoreFuture started
[10:32:57.170] - Launch lazy future ... done
[10:32:57.170] run() for ‘MulticoreFuture’ ... done
[10:32:57.171] result() for MulticoreFuture ...
[10:32:57.171] plan(): Setting new future strategy stack:
[10:32:57.171] List of future strategies:
[10:32:57.171] 1. sequential:
[10:32:57.171]    - args: function (..., envir = parent.frame())
[10:32:57.171]    - tweaked: FALSE
[10:32:57.171]    - call: NULL
[10:32:57.172] plan(): nbrOfWorkers() = 1
[10:32:57.176] plan(): Setting new future strategy stack:
[10:32:57.176] List of future strategies:
[10:32:57.176] 1. multicore:
[10:32:57.176]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:57.176]    - tweaked: FALSE
[10:32:57.176]    - call: plan(strategy)
[10:32:57.184] plan(): nbrOfWorkers() = 2
[10:32:57.186] result() for MulticoreFuture ...
[10:32:57.187] result() for MulticoreFuture ... done
[10:32:57.187] result() for MulticoreFuture ... done
[10:32:57.187] result() for MulticoreFuture ...
[10:32:57.187] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:32:57.192] getGlobalsAndPackages() ...
[10:32:57.192] Searching for globals...
[10:32:57.194] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:32:57.194] Searching for globals ... DONE
[10:32:57.194] Resolving globals: FALSE
[10:32:57.195] The total size of the 2 globals is 896 bytes (896 bytes)
[10:32:57.195] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:32:57.196] - globals: [2] ‘weight’, ‘group’
[10:32:57.196] - packages: [1] ‘stats’
[10:32:57.196] getGlobalsAndPackages() ... DONE
[10:32:57.196] run() for ‘Future’ ...
[10:32:57.196] - state: ‘created’
[10:32:57.197] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:57.200] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:57.201] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:57.201]   - Field: ‘label’
[10:32:57.201]   - Field: ‘local’
[10:32:57.201]   - Field: ‘owner’
[10:32:57.201]   - Field: ‘envir’
[10:32:57.201]   - Field: ‘workers’
[10:32:57.201]   - Field: ‘packages’
[10:32:57.201]   - Field: ‘gc’
[10:32:57.202]   - Field: ‘job’
[10:32:57.202]   - Field: ‘conditions’
[10:32:57.202]   - Field: ‘expr’
[10:32:57.202]   - Field: ‘uuid’
[10:32:57.202]   - Field: ‘seed’
[10:32:57.202]   - Field: ‘version’
[10:32:57.202]   - Field: ‘result’
[10:32:57.202]   - Field: ‘asynchronous’
[10:32:57.202]   - Field: ‘calls’
[10:32:57.203]   - Field: ‘globals’
[10:32:57.203]   - Field: ‘stdout’
[10:32:57.203]   - Field: ‘earlySignal’
[10:32:57.203]   - Field: ‘lazy’
[10:32:57.203]   - Field: ‘state’
[10:32:57.203] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:57.203] - Launch lazy future ...
[10:32:57.204] Packages needed by the future expression (n = 1): ‘stats’
[10:32:57.204] Packages needed by future strategies (n = 0): <none>
[10:32:57.204] {
[10:32:57.204]     {
[10:32:57.204]         {
[10:32:57.204]             ...future.startTime <- base::Sys.time()
[10:32:57.204]             {
[10:32:57.204]                 {
[10:32:57.204]                   {
[10:32:57.204]                     {
[10:32:57.204]                       {
[10:32:57.204]                         base::local({
[10:32:57.204]                           has_future <- base::requireNamespace("future", 
[10:32:57.204]                             quietly = TRUE)
[10:32:57.204]                           if (has_future) {
[10:32:57.204]                             ns <- base::getNamespace("future")
[10:32:57.204]                             version <- ns[[".package"]][["version"]]
[10:32:57.204]                             if (is.null(version)) 
[10:32:57.204]                               version <- utils::packageVersion("future")
[10:32:57.204]                           }
[10:32:57.204]                           else {
[10:32:57.204]                             version <- NULL
[10:32:57.204]                           }
[10:32:57.204]                           if (!has_future || version < "1.8.0") {
[10:32:57.204]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:57.204]                               "", base::R.version$version.string), 
[10:32:57.204]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:57.204]                                 base::R.version$platform, 8 * 
[10:32:57.204]                                   base::.Machine$sizeof.pointer), 
[10:32:57.204]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:57.204]                                 "release", "version")], collapse = " "), 
[10:32:57.204]                               hostname = base::Sys.info()[["nodename"]])
[10:32:57.204]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:57.204]                               info)
[10:32:57.204]                             info <- base::paste(info, collapse = "; ")
[10:32:57.204]                             if (!has_future) {
[10:32:57.204]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:57.204]                                 info)
[10:32:57.204]                             }
[10:32:57.204]                             else {
[10:32:57.204]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:57.204]                                 info, version)
[10:32:57.204]                             }
[10:32:57.204]                             base::stop(msg)
[10:32:57.204]                           }
[10:32:57.204]                         })
[10:32:57.204]                       }
[10:32:57.204]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:57.204]                       base::options(mc.cores = 1L)
[10:32:57.204]                     }
[10:32:57.204]                     base::local({
[10:32:57.204]                       for (pkg in "stats") {
[10:32:57.204]                         base::loadNamespace(pkg)
[10:32:57.204]                         base::library(pkg, character.only = TRUE)
[10:32:57.204]                       }
[10:32:57.204]                     })
[10:32:57.204]                   }
[10:32:57.204]                   ...future.strategy.old <- future::plan("list")
[10:32:57.204]                   options(future.plan = NULL)
[10:32:57.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:57.204]                 }
[10:32:57.204]                 ...future.workdir <- getwd()
[10:32:57.204]             }
[10:32:57.204]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:57.204]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:57.204]         }
[10:32:57.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:57.204]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:57.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:57.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:57.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:57.204]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:57.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:57.204]             base::names(...future.oldOptions))
[10:32:57.204]     }
[10:32:57.204]     if (FALSE) {
[10:32:57.204]     }
[10:32:57.204]     else {
[10:32:57.204]         if (TRUE) {
[10:32:57.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:57.204]                 open = "w")
[10:32:57.204]         }
[10:32:57.204]         else {
[10:32:57.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:57.204]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:57.204]         }
[10:32:57.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:57.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:57.204]             base::sink(type = "output", split = FALSE)
[10:32:57.204]             base::close(...future.stdout)
[10:32:57.204]         }, add = TRUE)
[10:32:57.204]     }
[10:32:57.204]     ...future.frame <- base::sys.nframe()
[10:32:57.204]     ...future.conditions <- base::list()
[10:32:57.204]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:57.204]     if (FALSE) {
[10:32:57.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:57.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:57.204]     }
[10:32:57.204]     ...future.result <- base::tryCatch({
[10:32:57.204]         base::withCallingHandlers({
[10:32:57.204]             ...future.value <- base::withVisible(base::local({
[10:32:57.204]                 withCallingHandlers({
[10:32:57.204]                   {
[10:32:57.204]                     lm(weight ~ group - 1)
[10:32:57.204]                   }
[10:32:57.204]                 }, immediateCondition = function(cond) {
[10:32:57.204]                   save_rds <- function (object, pathname, ...) 
[10:32:57.204]                   {
[10:32:57.204]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:57.204]                     if (file_test("-f", pathname_tmp)) {
[10:32:57.204]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.204]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:57.204]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.204]                         fi_tmp[["mtime"]])
[10:32:57.204]                     }
[10:32:57.204]                     tryCatch({
[10:32:57.204]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:57.204]                     }, error = function(ex) {
[10:32:57.204]                       msg <- conditionMessage(ex)
[10:32:57.204]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.204]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:57.204]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.204]                         fi_tmp[["mtime"]], msg)
[10:32:57.204]                       ex$message <- msg
[10:32:57.204]                       stop(ex)
[10:32:57.204]                     })
[10:32:57.204]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:57.204]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:57.204]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:57.204]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.204]                       fi <- file.info(pathname)
[10:32:57.204]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:57.204]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.204]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:57.204]                         fi[["size"]], fi[["mtime"]])
[10:32:57.204]                       stop(msg)
[10:32:57.204]                     }
[10:32:57.204]                     invisible(pathname)
[10:32:57.204]                   }
[10:32:57.204]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:57.204]                     rootPath = tempdir()) 
[10:32:57.204]                   {
[10:32:57.204]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:57.204]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:57.204]                       tmpdir = path, fileext = ".rds")
[10:32:57.204]                     save_rds(obj, file)
[10:32:57.204]                   }
[10:32:57.204]                   saveImmediateCondition(cond, path = "/tmp/RtmpZSnOM5/.future/immediateConditions")
[10:32:57.204]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.204]                   {
[10:32:57.204]                     inherits <- base::inherits
[10:32:57.204]                     invokeRestart <- base::invokeRestart
[10:32:57.204]                     is.null <- base::is.null
[10:32:57.204]                     muffled <- FALSE
[10:32:57.204]                     if (inherits(cond, "message")) {
[10:32:57.204]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:57.204]                       if (muffled) 
[10:32:57.204]                         invokeRestart("muffleMessage")
[10:32:57.204]                     }
[10:32:57.204]                     else if (inherits(cond, "warning")) {
[10:32:57.204]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:57.204]                       if (muffled) 
[10:32:57.204]                         invokeRestart("muffleWarning")
[10:32:57.204]                     }
[10:32:57.204]                     else if (inherits(cond, "condition")) {
[10:32:57.204]                       if (!is.null(pattern)) {
[10:32:57.204]                         computeRestarts <- base::computeRestarts
[10:32:57.204]                         grepl <- base::grepl
[10:32:57.204]                         restarts <- computeRestarts(cond)
[10:32:57.204]                         for (restart in restarts) {
[10:32:57.204]                           name <- restart$name
[10:32:57.204]                           if (is.null(name)) 
[10:32:57.204]                             next
[10:32:57.204]                           if (!grepl(pattern, name)) 
[10:32:57.204]                             next
[10:32:57.204]                           invokeRestart(restart)
[10:32:57.204]                           muffled <- TRUE
[10:32:57.204]                           break
[10:32:57.204]                         }
[10:32:57.204]                       }
[10:32:57.204]                     }
[10:32:57.204]                     invisible(muffled)
[10:32:57.204]                   }
[10:32:57.204]                   muffleCondition(cond)
[10:32:57.204]                 })
[10:32:57.204]             }))
[10:32:57.204]             future::FutureResult(value = ...future.value$value, 
[10:32:57.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.204]                   ...future.rng), globalenv = if (FALSE) 
[10:32:57.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:57.204]                     ...future.globalenv.names))
[10:32:57.204]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:57.204]         }, condition = base::local({
[10:32:57.204]             c <- base::c
[10:32:57.204]             inherits <- base::inherits
[10:32:57.204]             invokeRestart <- base::invokeRestart
[10:32:57.204]             length <- base::length
[10:32:57.204]             list <- base::list
[10:32:57.204]             seq.int <- base::seq.int
[10:32:57.204]             signalCondition <- base::signalCondition
[10:32:57.204]             sys.calls <- base::sys.calls
[10:32:57.204]             `[[` <- base::`[[`
[10:32:57.204]             `+` <- base::`+`
[10:32:57.204]             `<<-` <- base::`<<-`
[10:32:57.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:57.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:57.204]                   3L)]
[10:32:57.204]             }
[10:32:57.204]             function(cond) {
[10:32:57.204]                 is_error <- inherits(cond, "error")
[10:32:57.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:57.204]                   NULL)
[10:32:57.204]                 if (is_error) {
[10:32:57.204]                   sessionInformation <- function() {
[10:32:57.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:57.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:57.204]                       search = base::search(), system = base::Sys.info())
[10:32:57.204]                   }
[10:32:57.204]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:57.204]                     cond$call), session = sessionInformation(), 
[10:32:57.204]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:57.204]                   signalCondition(cond)
[10:32:57.204]                 }
[10:32:57.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:57.204]                 "immediateCondition"))) {
[10:32:57.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:57.204]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:57.204]                   if (TRUE && !signal) {
[10:32:57.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.204]                     {
[10:32:57.204]                       inherits <- base::inherits
[10:32:57.204]                       invokeRestart <- base::invokeRestart
[10:32:57.204]                       is.null <- base::is.null
[10:32:57.204]                       muffled <- FALSE
[10:32:57.204]                       if (inherits(cond, "message")) {
[10:32:57.204]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.204]                         if (muffled) 
[10:32:57.204]                           invokeRestart("muffleMessage")
[10:32:57.204]                       }
[10:32:57.204]                       else if (inherits(cond, "warning")) {
[10:32:57.204]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.204]                         if (muffled) 
[10:32:57.204]                           invokeRestart("muffleWarning")
[10:32:57.204]                       }
[10:32:57.204]                       else if (inherits(cond, "condition")) {
[10:32:57.204]                         if (!is.null(pattern)) {
[10:32:57.204]                           computeRestarts <- base::computeRestarts
[10:32:57.204]                           grepl <- base::grepl
[10:32:57.204]                           restarts <- computeRestarts(cond)
[10:32:57.204]                           for (restart in restarts) {
[10:32:57.204]                             name <- restart$name
[10:32:57.204]                             if (is.null(name)) 
[10:32:57.204]                               next
[10:32:57.204]                             if (!grepl(pattern, name)) 
[10:32:57.204]                               next
[10:32:57.204]                             invokeRestart(restart)
[10:32:57.204]                             muffled <- TRUE
[10:32:57.204]                             break
[10:32:57.204]                           }
[10:32:57.204]                         }
[10:32:57.204]                       }
[10:32:57.204]                       invisible(muffled)
[10:32:57.204]                     }
[10:32:57.204]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.204]                   }
[10:32:57.204]                 }
[10:32:57.204]                 else {
[10:32:57.204]                   if (TRUE) {
[10:32:57.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.204]                     {
[10:32:57.204]                       inherits <- base::inherits
[10:32:57.204]                       invokeRestart <- base::invokeRestart
[10:32:57.204]                       is.null <- base::is.null
[10:32:57.204]                       muffled <- FALSE
[10:32:57.204]                       if (inherits(cond, "message")) {
[10:32:57.204]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.204]                         if (muffled) 
[10:32:57.204]                           invokeRestart("muffleMessage")
[10:32:57.204]                       }
[10:32:57.204]                       else if (inherits(cond, "warning")) {
[10:32:57.204]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.204]                         if (muffled) 
[10:32:57.204]                           invokeRestart("muffleWarning")
[10:32:57.204]                       }
[10:32:57.204]                       else if (inherits(cond, "condition")) {
[10:32:57.204]                         if (!is.null(pattern)) {
[10:32:57.204]                           computeRestarts <- base::computeRestarts
[10:32:57.204]                           grepl <- base::grepl
[10:32:57.204]                           restarts <- computeRestarts(cond)
[10:32:57.204]                           for (restart in restarts) {
[10:32:57.204]                             name <- restart$name
[10:32:57.204]                             if (is.null(name)) 
[10:32:57.204]                               next
[10:32:57.204]                             if (!grepl(pattern, name)) 
[10:32:57.204]                               next
[10:32:57.204]                             invokeRestart(restart)
[10:32:57.204]                             muffled <- TRUE
[10:32:57.204]                             break
[10:32:57.204]                           }
[10:32:57.204]                         }
[10:32:57.204]                       }
[10:32:57.204]                       invisible(muffled)
[10:32:57.204]                     }
[10:32:57.204]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.204]                   }
[10:32:57.204]                 }
[10:32:57.204]             }
[10:32:57.204]         }))
[10:32:57.204]     }, error = function(ex) {
[10:32:57.204]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:57.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.204]                 ...future.rng), started = ...future.startTime, 
[10:32:57.204]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:57.204]             version = "1.8"), class = "FutureResult")
[10:32:57.204]     }, finally = {
[10:32:57.204]         if (!identical(...future.workdir, getwd())) 
[10:32:57.204]             setwd(...future.workdir)
[10:32:57.204]         {
[10:32:57.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:57.204]                 ...future.oldOptions$nwarnings <- NULL
[10:32:57.204]             }
[10:32:57.204]             base::options(...future.oldOptions)
[10:32:57.204]             if (.Platform$OS.type == "windows") {
[10:32:57.204]                 old_names <- names(...future.oldEnvVars)
[10:32:57.204]                 envs <- base::Sys.getenv()
[10:32:57.204]                 names <- names(envs)
[10:32:57.204]                 common <- intersect(names, old_names)
[10:32:57.204]                 added <- setdiff(names, old_names)
[10:32:57.204]                 removed <- setdiff(old_names, names)
[10:32:57.204]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:57.204]                   envs[common]]
[10:32:57.204]                 NAMES <- toupper(changed)
[10:32:57.204]                 args <- list()
[10:32:57.204]                 for (kk in seq_along(NAMES)) {
[10:32:57.204]                   name <- changed[[kk]]
[10:32:57.204]                   NAME <- NAMES[[kk]]
[10:32:57.204]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.204]                     next
[10:32:57.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.204]                 }
[10:32:57.204]                 NAMES <- toupper(added)
[10:32:57.204]                 for (kk in seq_along(NAMES)) {
[10:32:57.204]                   name <- added[[kk]]
[10:32:57.204]                   NAME <- NAMES[[kk]]
[10:32:57.204]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.204]                     next
[10:32:57.204]                   args[[name]] <- ""
[10:32:57.204]                 }
[10:32:57.204]                 NAMES <- toupper(removed)
[10:32:57.204]                 for (kk in seq_along(NAMES)) {
[10:32:57.204]                   name <- removed[[kk]]
[10:32:57.204]                   NAME <- NAMES[[kk]]
[10:32:57.204]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.204]                     next
[10:32:57.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.204]                 }
[10:32:57.204]                 if (length(args) > 0) 
[10:32:57.204]                   base::do.call(base::Sys.setenv, args = args)
[10:32:57.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:57.204]             }
[10:32:57.204]             else {
[10:32:57.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:57.204]             }
[10:32:57.204]             {
[10:32:57.204]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:57.204]                   0L) {
[10:32:57.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:57.204]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:57.204]                   base::options(opts)
[10:32:57.204]                 }
[10:32:57.204]                 {
[10:32:57.204]                   {
[10:32:57.204]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:57.204]                     NULL
[10:32:57.204]                   }
[10:32:57.204]                   options(future.plan = NULL)
[10:32:57.204]                   if (is.na(NA_character_)) 
[10:32:57.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:57.204]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:57.204]                     .init = FALSE)
[10:32:57.204]                 }
[10:32:57.204]             }
[10:32:57.204]         }
[10:32:57.204]     })
[10:32:57.204]     if (TRUE) {
[10:32:57.204]         base::sink(type = "output", split = FALSE)
[10:32:57.204]         if (TRUE) {
[10:32:57.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:57.204]         }
[10:32:57.204]         else {
[10:32:57.204]             ...future.result["stdout"] <- base::list(NULL)
[10:32:57.204]         }
[10:32:57.204]         base::close(...future.stdout)
[10:32:57.204]         ...future.stdout <- NULL
[10:32:57.204]     }
[10:32:57.204]     ...future.result$conditions <- ...future.conditions
[10:32:57.204]     ...future.result$finished <- base::Sys.time()
[10:32:57.204]     ...future.result
[10:32:57.204] }
[10:32:57.206] assign_globals() ...
[10:32:57.207] List of 2
[10:32:57.207]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:32:57.207]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:32:57.207]  - attr(*, "where")=List of 2
[10:32:57.207]   ..$ weight:<environment: R_EmptyEnv> 
[10:32:57.207]   ..$ group :<environment: R_EmptyEnv> 
[10:32:57.207]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:57.207]  - attr(*, "resolved")= logi FALSE
[10:32:57.207]  - attr(*, "total_size")= num 896
[10:32:57.207]  - attr(*, "already-done")= logi TRUE
[10:32:57.210] - copied ‘weight’ to environment
[10:32:57.210] - copied ‘group’ to environment
[10:32:57.210] assign_globals() ... done
[10:32:57.211] requestCore(): workers = 2
[10:32:57.212] MulticoreFuture started
[10:32:57.213] - Launch lazy future ... done
[10:32:57.213] run() for ‘MulticoreFuture’ ... done
[10:32:57.213] result() for MulticoreFuture ...
[10:32:57.214] plan(): Setting new future strategy stack:
[10:32:57.214] List of future strategies:
[10:32:57.214] 1. sequential:
[10:32:57.214]    - args: function (..., envir = parent.frame())
[10:32:57.214]    - tweaked: FALSE
[10:32:57.214]    - call: NULL
[10:32:57.215] plan(): nbrOfWorkers() = 1
[10:32:57.218] plan(): Setting new future strategy stack:
[10:32:57.219] List of future strategies:
[10:32:57.219] 1. multicore:
[10:32:57.219]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:57.219]    - tweaked: FALSE
[10:32:57.219]    - call: plan(strategy)
[10:32:57.223] plan(): nbrOfWorkers() = 2
[10:32:57.226] result() for MulticoreFuture ...
[10:32:57.226] result() for MulticoreFuture ... done
[10:32:57.226] result() for MulticoreFuture ... done
[10:32:57.226] result() for MulticoreFuture ...
[10:32:57.226] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:32:57.229] getGlobalsAndPackages() ...
[10:32:57.229] Searching for globals...
[10:32:57.231] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:32:57.231] Searching for globals ... DONE
[10:32:57.231] Resolving globals: FALSE
[10:32:57.232] The total size of the 2 globals is 896 bytes (896 bytes)
[10:32:57.234] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:32:57.234] - globals: [2] ‘weight’, ‘group’
[10:32:57.235] - packages: [1] ‘stats’
[10:32:57.235] getGlobalsAndPackages() ... DONE
[10:32:57.235] run() for ‘Future’ ...
[10:32:57.235] - state: ‘created’
[10:32:57.236] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:57.240] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:57.240] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:57.240]   - Field: ‘label’
[10:32:57.240]   - Field: ‘local’
[10:32:57.240]   - Field: ‘owner’
[10:32:57.240]   - Field: ‘envir’
[10:32:57.240]   - Field: ‘workers’
[10:32:57.241]   - Field: ‘packages’
[10:32:57.241]   - Field: ‘gc’
[10:32:57.241]   - Field: ‘job’
[10:32:57.241]   - Field: ‘conditions’
[10:32:57.241]   - Field: ‘expr’
[10:32:57.241]   - Field: ‘uuid’
[10:32:57.241]   - Field: ‘seed’
[10:32:57.241]   - Field: ‘version’
[10:32:57.242]   - Field: ‘result’
[10:32:57.242]   - Field: ‘asynchronous’
[10:32:57.242]   - Field: ‘calls’
[10:32:57.242]   - Field: ‘globals’
[10:32:57.242]   - Field: ‘stdout’
[10:32:57.242]   - Field: ‘earlySignal’
[10:32:57.242]   - Field: ‘lazy’
[10:32:57.242]   - Field: ‘state’
[10:32:57.242] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:57.243] - Launch lazy future ...
[10:32:57.243] Packages needed by the future expression (n = 1): ‘stats’
[10:32:57.243] Packages needed by future strategies (n = 0): <none>
[10:32:57.244] {
[10:32:57.244]     {
[10:32:57.244]         {
[10:32:57.244]             ...future.startTime <- base::Sys.time()
[10:32:57.244]             {
[10:32:57.244]                 {
[10:32:57.244]                   {
[10:32:57.244]                     {
[10:32:57.244]                       {
[10:32:57.244]                         base::local({
[10:32:57.244]                           has_future <- base::requireNamespace("future", 
[10:32:57.244]                             quietly = TRUE)
[10:32:57.244]                           if (has_future) {
[10:32:57.244]                             ns <- base::getNamespace("future")
[10:32:57.244]                             version <- ns[[".package"]][["version"]]
[10:32:57.244]                             if (is.null(version)) 
[10:32:57.244]                               version <- utils::packageVersion("future")
[10:32:57.244]                           }
[10:32:57.244]                           else {
[10:32:57.244]                             version <- NULL
[10:32:57.244]                           }
[10:32:57.244]                           if (!has_future || version < "1.8.0") {
[10:32:57.244]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:57.244]                               "", base::R.version$version.string), 
[10:32:57.244]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:57.244]                                 base::R.version$platform, 8 * 
[10:32:57.244]                                   base::.Machine$sizeof.pointer), 
[10:32:57.244]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:57.244]                                 "release", "version")], collapse = " "), 
[10:32:57.244]                               hostname = base::Sys.info()[["nodename"]])
[10:32:57.244]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:57.244]                               info)
[10:32:57.244]                             info <- base::paste(info, collapse = "; ")
[10:32:57.244]                             if (!has_future) {
[10:32:57.244]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:57.244]                                 info)
[10:32:57.244]                             }
[10:32:57.244]                             else {
[10:32:57.244]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:57.244]                                 info, version)
[10:32:57.244]                             }
[10:32:57.244]                             base::stop(msg)
[10:32:57.244]                           }
[10:32:57.244]                         })
[10:32:57.244]                       }
[10:32:57.244]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:57.244]                       base::options(mc.cores = 1L)
[10:32:57.244]                     }
[10:32:57.244]                     base::local({
[10:32:57.244]                       for (pkg in "stats") {
[10:32:57.244]                         base::loadNamespace(pkg)
[10:32:57.244]                         base::library(pkg, character.only = TRUE)
[10:32:57.244]                       }
[10:32:57.244]                     })
[10:32:57.244]                   }
[10:32:57.244]                   ...future.strategy.old <- future::plan("list")
[10:32:57.244]                   options(future.plan = NULL)
[10:32:57.244]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.244]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:57.244]                 }
[10:32:57.244]                 ...future.workdir <- getwd()
[10:32:57.244]             }
[10:32:57.244]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:57.244]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:57.244]         }
[10:32:57.244]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:57.244]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:57.244]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:57.244]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:57.244]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:57.244]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:57.244]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:57.244]             base::names(...future.oldOptions))
[10:32:57.244]     }
[10:32:57.244]     if (FALSE) {
[10:32:57.244]     }
[10:32:57.244]     else {
[10:32:57.244]         if (TRUE) {
[10:32:57.244]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:57.244]                 open = "w")
[10:32:57.244]         }
[10:32:57.244]         else {
[10:32:57.244]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:57.244]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:57.244]         }
[10:32:57.244]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:57.244]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:57.244]             base::sink(type = "output", split = FALSE)
[10:32:57.244]             base::close(...future.stdout)
[10:32:57.244]         }, add = TRUE)
[10:32:57.244]     }
[10:32:57.244]     ...future.frame <- base::sys.nframe()
[10:32:57.244]     ...future.conditions <- base::list()
[10:32:57.244]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:57.244]     if (FALSE) {
[10:32:57.244]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:57.244]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:57.244]     }
[10:32:57.244]     ...future.result <- base::tryCatch({
[10:32:57.244]         base::withCallingHandlers({
[10:32:57.244]             ...future.value <- base::withVisible(base::local({
[10:32:57.244]                 withCallingHandlers({
[10:32:57.244]                   {
[10:32:57.244]                     lm(weight ~ group - 1)
[10:32:57.244]                   }
[10:32:57.244]                 }, immediateCondition = function(cond) {
[10:32:57.244]                   save_rds <- function (object, pathname, ...) 
[10:32:57.244]                   {
[10:32:57.244]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:57.244]                     if (file_test("-f", pathname_tmp)) {
[10:32:57.244]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.244]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:57.244]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.244]                         fi_tmp[["mtime"]])
[10:32:57.244]                     }
[10:32:57.244]                     tryCatch({
[10:32:57.244]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:57.244]                     }, error = function(ex) {
[10:32:57.244]                       msg <- conditionMessage(ex)
[10:32:57.244]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.244]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:57.244]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.244]                         fi_tmp[["mtime"]], msg)
[10:32:57.244]                       ex$message <- msg
[10:32:57.244]                       stop(ex)
[10:32:57.244]                     })
[10:32:57.244]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:57.244]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:57.244]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:57.244]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.244]                       fi <- file.info(pathname)
[10:32:57.244]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:57.244]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.244]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:57.244]                         fi[["size"]], fi[["mtime"]])
[10:32:57.244]                       stop(msg)
[10:32:57.244]                     }
[10:32:57.244]                     invisible(pathname)
[10:32:57.244]                   }
[10:32:57.244]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:57.244]                     rootPath = tempdir()) 
[10:32:57.244]                   {
[10:32:57.244]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:57.244]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:57.244]                       tmpdir = path, fileext = ".rds")
[10:32:57.244]                     save_rds(obj, file)
[10:32:57.244]                   }
[10:32:57.244]                   saveImmediateCondition(cond, path = "/tmp/RtmpZSnOM5/.future/immediateConditions")
[10:32:57.244]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.244]                   {
[10:32:57.244]                     inherits <- base::inherits
[10:32:57.244]                     invokeRestart <- base::invokeRestart
[10:32:57.244]                     is.null <- base::is.null
[10:32:57.244]                     muffled <- FALSE
[10:32:57.244]                     if (inherits(cond, "message")) {
[10:32:57.244]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:57.244]                       if (muffled) 
[10:32:57.244]                         invokeRestart("muffleMessage")
[10:32:57.244]                     }
[10:32:57.244]                     else if (inherits(cond, "warning")) {
[10:32:57.244]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:57.244]                       if (muffled) 
[10:32:57.244]                         invokeRestart("muffleWarning")
[10:32:57.244]                     }
[10:32:57.244]                     else if (inherits(cond, "condition")) {
[10:32:57.244]                       if (!is.null(pattern)) {
[10:32:57.244]                         computeRestarts <- base::computeRestarts
[10:32:57.244]                         grepl <- base::grepl
[10:32:57.244]                         restarts <- computeRestarts(cond)
[10:32:57.244]                         for (restart in restarts) {
[10:32:57.244]                           name <- restart$name
[10:32:57.244]                           if (is.null(name)) 
[10:32:57.244]                             next
[10:32:57.244]                           if (!grepl(pattern, name)) 
[10:32:57.244]                             next
[10:32:57.244]                           invokeRestart(restart)
[10:32:57.244]                           muffled <- TRUE
[10:32:57.244]                           break
[10:32:57.244]                         }
[10:32:57.244]                       }
[10:32:57.244]                     }
[10:32:57.244]                     invisible(muffled)
[10:32:57.244]                   }
[10:32:57.244]                   muffleCondition(cond)
[10:32:57.244]                 })
[10:32:57.244]             }))
[10:32:57.244]             future::FutureResult(value = ...future.value$value, 
[10:32:57.244]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.244]                   ...future.rng), globalenv = if (FALSE) 
[10:32:57.244]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:57.244]                     ...future.globalenv.names))
[10:32:57.244]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:57.244]         }, condition = base::local({
[10:32:57.244]             c <- base::c
[10:32:57.244]             inherits <- base::inherits
[10:32:57.244]             invokeRestart <- base::invokeRestart
[10:32:57.244]             length <- base::length
[10:32:57.244]             list <- base::list
[10:32:57.244]             seq.int <- base::seq.int
[10:32:57.244]             signalCondition <- base::signalCondition
[10:32:57.244]             sys.calls <- base::sys.calls
[10:32:57.244]             `[[` <- base::`[[`
[10:32:57.244]             `+` <- base::`+`
[10:32:57.244]             `<<-` <- base::`<<-`
[10:32:57.244]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:57.244]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:57.244]                   3L)]
[10:32:57.244]             }
[10:32:57.244]             function(cond) {
[10:32:57.244]                 is_error <- inherits(cond, "error")
[10:32:57.244]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:57.244]                   NULL)
[10:32:57.244]                 if (is_error) {
[10:32:57.244]                   sessionInformation <- function() {
[10:32:57.244]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:57.244]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:57.244]                       search = base::search(), system = base::Sys.info())
[10:32:57.244]                   }
[10:32:57.244]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.244]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:57.244]                     cond$call), session = sessionInformation(), 
[10:32:57.244]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:57.244]                   signalCondition(cond)
[10:32:57.244]                 }
[10:32:57.244]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:57.244]                 "immediateCondition"))) {
[10:32:57.244]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:57.244]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.244]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:57.244]                   if (TRUE && !signal) {
[10:32:57.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.244]                     {
[10:32:57.244]                       inherits <- base::inherits
[10:32:57.244]                       invokeRestart <- base::invokeRestart
[10:32:57.244]                       is.null <- base::is.null
[10:32:57.244]                       muffled <- FALSE
[10:32:57.244]                       if (inherits(cond, "message")) {
[10:32:57.244]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.244]                         if (muffled) 
[10:32:57.244]                           invokeRestart("muffleMessage")
[10:32:57.244]                       }
[10:32:57.244]                       else if (inherits(cond, "warning")) {
[10:32:57.244]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.244]                         if (muffled) 
[10:32:57.244]                           invokeRestart("muffleWarning")
[10:32:57.244]                       }
[10:32:57.244]                       else if (inherits(cond, "condition")) {
[10:32:57.244]                         if (!is.null(pattern)) {
[10:32:57.244]                           computeRestarts <- base::computeRestarts
[10:32:57.244]                           grepl <- base::grepl
[10:32:57.244]                           restarts <- computeRestarts(cond)
[10:32:57.244]                           for (restart in restarts) {
[10:32:57.244]                             name <- restart$name
[10:32:57.244]                             if (is.null(name)) 
[10:32:57.244]                               next
[10:32:57.244]                             if (!grepl(pattern, name)) 
[10:32:57.244]                               next
[10:32:57.244]                             invokeRestart(restart)
[10:32:57.244]                             muffled <- TRUE
[10:32:57.244]                             break
[10:32:57.244]                           }
[10:32:57.244]                         }
[10:32:57.244]                       }
[10:32:57.244]                       invisible(muffled)
[10:32:57.244]                     }
[10:32:57.244]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.244]                   }
[10:32:57.244]                 }
[10:32:57.244]                 else {
[10:32:57.244]                   if (TRUE) {
[10:32:57.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.244]                     {
[10:32:57.244]                       inherits <- base::inherits
[10:32:57.244]                       invokeRestart <- base::invokeRestart
[10:32:57.244]                       is.null <- base::is.null
[10:32:57.244]                       muffled <- FALSE
[10:32:57.244]                       if (inherits(cond, "message")) {
[10:32:57.244]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.244]                         if (muffled) 
[10:32:57.244]                           invokeRestart("muffleMessage")
[10:32:57.244]                       }
[10:32:57.244]                       else if (inherits(cond, "warning")) {
[10:32:57.244]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.244]                         if (muffled) 
[10:32:57.244]                           invokeRestart("muffleWarning")
[10:32:57.244]                       }
[10:32:57.244]                       else if (inherits(cond, "condition")) {
[10:32:57.244]                         if (!is.null(pattern)) {
[10:32:57.244]                           computeRestarts <- base::computeRestarts
[10:32:57.244]                           grepl <- base::grepl
[10:32:57.244]                           restarts <- computeRestarts(cond)
[10:32:57.244]                           for (restart in restarts) {
[10:32:57.244]                             name <- restart$name
[10:32:57.244]                             if (is.null(name)) 
[10:32:57.244]                               next
[10:32:57.244]                             if (!grepl(pattern, name)) 
[10:32:57.244]                               next
[10:32:57.244]                             invokeRestart(restart)
[10:32:57.244]                             muffled <- TRUE
[10:32:57.244]                             break
[10:32:57.244]                           }
[10:32:57.244]                         }
[10:32:57.244]                       }
[10:32:57.244]                       invisible(muffled)
[10:32:57.244]                     }
[10:32:57.244]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.244]                   }
[10:32:57.244]                 }
[10:32:57.244]             }
[10:32:57.244]         }))
[10:32:57.244]     }, error = function(ex) {
[10:32:57.244]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:57.244]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.244]                 ...future.rng), started = ...future.startTime, 
[10:32:57.244]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:57.244]             version = "1.8"), class = "FutureResult")
[10:32:57.244]     }, finally = {
[10:32:57.244]         if (!identical(...future.workdir, getwd())) 
[10:32:57.244]             setwd(...future.workdir)
[10:32:57.244]         {
[10:32:57.244]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:57.244]                 ...future.oldOptions$nwarnings <- NULL
[10:32:57.244]             }
[10:32:57.244]             base::options(...future.oldOptions)
[10:32:57.244]             if (.Platform$OS.type == "windows") {
[10:32:57.244]                 old_names <- names(...future.oldEnvVars)
[10:32:57.244]                 envs <- base::Sys.getenv()
[10:32:57.244]                 names <- names(envs)
[10:32:57.244]                 common <- intersect(names, old_names)
[10:32:57.244]                 added <- setdiff(names, old_names)
[10:32:57.244]                 removed <- setdiff(old_names, names)
[10:32:57.244]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:57.244]                   envs[common]]
[10:32:57.244]                 NAMES <- toupper(changed)
[10:32:57.244]                 args <- list()
[10:32:57.244]                 for (kk in seq_along(NAMES)) {
[10:32:57.244]                   name <- changed[[kk]]
[10:32:57.244]                   NAME <- NAMES[[kk]]
[10:32:57.244]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.244]                     next
[10:32:57.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.244]                 }
[10:32:57.244]                 NAMES <- toupper(added)
[10:32:57.244]                 for (kk in seq_along(NAMES)) {
[10:32:57.244]                   name <- added[[kk]]
[10:32:57.244]                   NAME <- NAMES[[kk]]
[10:32:57.244]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.244]                     next
[10:32:57.244]                   args[[name]] <- ""
[10:32:57.244]                 }
[10:32:57.244]                 NAMES <- toupper(removed)
[10:32:57.244]                 for (kk in seq_along(NAMES)) {
[10:32:57.244]                   name <- removed[[kk]]
[10:32:57.244]                   NAME <- NAMES[[kk]]
[10:32:57.244]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.244]                     next
[10:32:57.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.244]                 }
[10:32:57.244]                 if (length(args) > 0) 
[10:32:57.244]                   base::do.call(base::Sys.setenv, args = args)
[10:32:57.244]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:57.244]             }
[10:32:57.244]             else {
[10:32:57.244]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:57.244]             }
[10:32:57.244]             {
[10:32:57.244]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:57.244]                   0L) {
[10:32:57.244]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:57.244]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:57.244]                   base::options(opts)
[10:32:57.244]                 }
[10:32:57.244]                 {
[10:32:57.244]                   {
[10:32:57.244]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:57.244]                     NULL
[10:32:57.244]                   }
[10:32:57.244]                   options(future.plan = NULL)
[10:32:57.244]                   if (is.na(NA_character_)) 
[10:32:57.244]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.244]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:57.244]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:57.244]                     .init = FALSE)
[10:32:57.244]                 }
[10:32:57.244]             }
[10:32:57.244]         }
[10:32:57.244]     })
[10:32:57.244]     if (TRUE) {
[10:32:57.244]         base::sink(type = "output", split = FALSE)
[10:32:57.244]         if (TRUE) {
[10:32:57.244]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:57.244]         }
[10:32:57.244]         else {
[10:32:57.244]             ...future.result["stdout"] <- base::list(NULL)
[10:32:57.244]         }
[10:32:57.244]         base::close(...future.stdout)
[10:32:57.244]         ...future.stdout <- NULL
[10:32:57.244]     }
[10:32:57.244]     ...future.result$conditions <- ...future.conditions
[10:32:57.244]     ...future.result$finished <- base::Sys.time()
[10:32:57.244]     ...future.result
[10:32:57.244] }
[10:32:57.246] assign_globals() ...
[10:32:57.246] List of 2
[10:32:57.246]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:32:57.246]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:32:57.246]  - attr(*, "where")=List of 2
[10:32:57.246]   ..$ weight:<environment: R_EmptyEnv> 
[10:32:57.246]   ..$ group :<environment: R_EmptyEnv> 
[10:32:57.246]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:57.246]  - attr(*, "resolved")= logi FALSE
[10:32:57.246]  - attr(*, "total_size")= num 896
[10:32:57.246]  - attr(*, "already-done")= logi TRUE
[10:32:57.250] - copied ‘weight’ to environment
[10:32:57.250] - copied ‘group’ to environment
[10:32:57.250] assign_globals() ... done
[10:32:57.250] requestCore(): workers = 2
[10:32:57.252] MulticoreFuture started
[10:32:57.252] - Launch lazy future ... done
[10:32:57.252] run() for ‘MulticoreFuture’ ... done
[10:32:57.253] result() for MulticoreFuture ...
[10:32:57.253] plan(): Setting new future strategy stack:
[10:32:57.254] List of future strategies:
[10:32:57.254] 1. sequential:
[10:32:57.254]    - args: function (..., envir = parent.frame())
[10:32:57.254]    - tweaked: FALSE
[10:32:57.254]    - call: NULL
[10:32:57.254] plan(): nbrOfWorkers() = 1
[10:32:57.258] plan(): Setting new future strategy stack:
[10:32:57.258] List of future strategies:
[10:32:57.258] 1. multicore:
[10:32:57.258]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:57.258]    - tweaked: FALSE
[10:32:57.258]    - call: plan(strategy)
[10:32:57.263] plan(): nbrOfWorkers() = 2
[10:32:57.266] result() for MulticoreFuture ...
[10:32:57.266] result() for MulticoreFuture ... done
[10:32:57.266] result() for MulticoreFuture ... done
[10:32:57.266] result() for MulticoreFuture ...
[10:32:57.266] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:32:57.269] getGlobalsAndPackages() ...
[10:32:57.270] Searching for globals...
[10:32:57.272] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:32:57.272] Searching for globals ... DONE
[10:32:57.272] Resolving globals: FALSE
[10:32:57.273] The total size of the 2 globals is 896 bytes (896 bytes)
[10:32:57.273] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:32:57.273] - globals: [2] ‘weight’, ‘group’
[10:32:57.273] - packages: [1] ‘stats’
[10:32:57.274] getGlobalsAndPackages() ... DONE
[10:32:57.274] run() for ‘Future’ ...
[10:32:57.274] - state: ‘created’
[10:32:57.274] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:57.278] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:57.278] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:57.278]   - Field: ‘label’
[10:32:57.279]   - Field: ‘local’
[10:32:57.279]   - Field: ‘owner’
[10:32:57.279]   - Field: ‘envir’
[10:32:57.279]   - Field: ‘workers’
[10:32:57.281]   - Field: ‘packages’
[10:32:57.282]   - Field: ‘gc’
[10:32:57.282]   - Field: ‘job’
[10:32:57.282]   - Field: ‘conditions’
[10:32:57.282]   - Field: ‘expr’
[10:32:57.282]   - Field: ‘uuid’
[10:32:57.282]   - Field: ‘seed’
[10:32:57.282]   - Field: ‘version’
[10:32:57.282]   - Field: ‘result’
[10:32:57.283]   - Field: ‘asynchronous’
[10:32:57.283]   - Field: ‘calls’
[10:32:57.283]   - Field: ‘globals’
[10:32:57.283]   - Field: ‘stdout’
[10:32:57.283]   - Field: ‘earlySignal’
[10:32:57.283]   - Field: ‘lazy’
[10:32:57.283]   - Field: ‘state’
[10:32:57.284] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:57.284] - Launch lazy future ...
[10:32:57.284] Packages needed by the future expression (n = 1): ‘stats’
[10:32:57.284] Packages needed by future strategies (n = 0): <none>
[10:32:57.285] {
[10:32:57.285]     {
[10:32:57.285]         {
[10:32:57.285]             ...future.startTime <- base::Sys.time()
[10:32:57.285]             {
[10:32:57.285]                 {
[10:32:57.285]                   {
[10:32:57.285]                     {
[10:32:57.285]                       {
[10:32:57.285]                         base::local({
[10:32:57.285]                           has_future <- base::requireNamespace("future", 
[10:32:57.285]                             quietly = TRUE)
[10:32:57.285]                           if (has_future) {
[10:32:57.285]                             ns <- base::getNamespace("future")
[10:32:57.285]                             version <- ns[[".package"]][["version"]]
[10:32:57.285]                             if (is.null(version)) 
[10:32:57.285]                               version <- utils::packageVersion("future")
[10:32:57.285]                           }
[10:32:57.285]                           else {
[10:32:57.285]                             version <- NULL
[10:32:57.285]                           }
[10:32:57.285]                           if (!has_future || version < "1.8.0") {
[10:32:57.285]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:57.285]                               "", base::R.version$version.string), 
[10:32:57.285]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:57.285]                                 base::R.version$platform, 8 * 
[10:32:57.285]                                   base::.Machine$sizeof.pointer), 
[10:32:57.285]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:57.285]                                 "release", "version")], collapse = " "), 
[10:32:57.285]                               hostname = base::Sys.info()[["nodename"]])
[10:32:57.285]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:57.285]                               info)
[10:32:57.285]                             info <- base::paste(info, collapse = "; ")
[10:32:57.285]                             if (!has_future) {
[10:32:57.285]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:57.285]                                 info)
[10:32:57.285]                             }
[10:32:57.285]                             else {
[10:32:57.285]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:57.285]                                 info, version)
[10:32:57.285]                             }
[10:32:57.285]                             base::stop(msg)
[10:32:57.285]                           }
[10:32:57.285]                         })
[10:32:57.285]                       }
[10:32:57.285]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:57.285]                       base::options(mc.cores = 1L)
[10:32:57.285]                     }
[10:32:57.285]                     base::local({
[10:32:57.285]                       for (pkg in "stats") {
[10:32:57.285]                         base::loadNamespace(pkg)
[10:32:57.285]                         base::library(pkg, character.only = TRUE)
[10:32:57.285]                       }
[10:32:57.285]                     })
[10:32:57.285]                   }
[10:32:57.285]                   ...future.strategy.old <- future::plan("list")
[10:32:57.285]                   options(future.plan = NULL)
[10:32:57.285]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.285]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:57.285]                 }
[10:32:57.285]                 ...future.workdir <- getwd()
[10:32:57.285]             }
[10:32:57.285]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:57.285]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:57.285]         }
[10:32:57.285]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:57.285]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:57.285]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:57.285]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:57.285]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:57.285]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:57.285]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:57.285]             base::names(...future.oldOptions))
[10:32:57.285]     }
[10:32:57.285]     if (FALSE) {
[10:32:57.285]     }
[10:32:57.285]     else {
[10:32:57.285]         if (TRUE) {
[10:32:57.285]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:57.285]                 open = "w")
[10:32:57.285]         }
[10:32:57.285]         else {
[10:32:57.285]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:57.285]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:57.285]         }
[10:32:57.285]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:57.285]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:57.285]             base::sink(type = "output", split = FALSE)
[10:32:57.285]             base::close(...future.stdout)
[10:32:57.285]         }, add = TRUE)
[10:32:57.285]     }
[10:32:57.285]     ...future.frame <- base::sys.nframe()
[10:32:57.285]     ...future.conditions <- base::list()
[10:32:57.285]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:57.285]     if (FALSE) {
[10:32:57.285]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:57.285]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:57.285]     }
[10:32:57.285]     ...future.result <- base::tryCatch({
[10:32:57.285]         base::withCallingHandlers({
[10:32:57.285]             ...future.value <- base::withVisible(base::local({
[10:32:57.285]                 withCallingHandlers({
[10:32:57.285]                   {
[10:32:57.285]                     lm(weight ~ group - 1)
[10:32:57.285]                   }
[10:32:57.285]                 }, immediateCondition = function(cond) {
[10:32:57.285]                   save_rds <- function (object, pathname, ...) 
[10:32:57.285]                   {
[10:32:57.285]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:57.285]                     if (file_test("-f", pathname_tmp)) {
[10:32:57.285]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.285]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:57.285]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.285]                         fi_tmp[["mtime"]])
[10:32:57.285]                     }
[10:32:57.285]                     tryCatch({
[10:32:57.285]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:57.285]                     }, error = function(ex) {
[10:32:57.285]                       msg <- conditionMessage(ex)
[10:32:57.285]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.285]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:57.285]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.285]                         fi_tmp[["mtime"]], msg)
[10:32:57.285]                       ex$message <- msg
[10:32:57.285]                       stop(ex)
[10:32:57.285]                     })
[10:32:57.285]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:57.285]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:57.285]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:57.285]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.285]                       fi <- file.info(pathname)
[10:32:57.285]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:57.285]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.285]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:57.285]                         fi[["size"]], fi[["mtime"]])
[10:32:57.285]                       stop(msg)
[10:32:57.285]                     }
[10:32:57.285]                     invisible(pathname)
[10:32:57.285]                   }
[10:32:57.285]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:57.285]                     rootPath = tempdir()) 
[10:32:57.285]                   {
[10:32:57.285]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:57.285]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:57.285]                       tmpdir = path, fileext = ".rds")
[10:32:57.285]                     save_rds(obj, file)
[10:32:57.285]                   }
[10:32:57.285]                   saveImmediateCondition(cond, path = "/tmp/RtmpZSnOM5/.future/immediateConditions")
[10:32:57.285]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.285]                   {
[10:32:57.285]                     inherits <- base::inherits
[10:32:57.285]                     invokeRestart <- base::invokeRestart
[10:32:57.285]                     is.null <- base::is.null
[10:32:57.285]                     muffled <- FALSE
[10:32:57.285]                     if (inherits(cond, "message")) {
[10:32:57.285]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:57.285]                       if (muffled) 
[10:32:57.285]                         invokeRestart("muffleMessage")
[10:32:57.285]                     }
[10:32:57.285]                     else if (inherits(cond, "warning")) {
[10:32:57.285]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:57.285]                       if (muffled) 
[10:32:57.285]                         invokeRestart("muffleWarning")
[10:32:57.285]                     }
[10:32:57.285]                     else if (inherits(cond, "condition")) {
[10:32:57.285]                       if (!is.null(pattern)) {
[10:32:57.285]                         computeRestarts <- base::computeRestarts
[10:32:57.285]                         grepl <- base::grepl
[10:32:57.285]                         restarts <- computeRestarts(cond)
[10:32:57.285]                         for (restart in restarts) {
[10:32:57.285]                           name <- restart$name
[10:32:57.285]                           if (is.null(name)) 
[10:32:57.285]                             next
[10:32:57.285]                           if (!grepl(pattern, name)) 
[10:32:57.285]                             next
[10:32:57.285]                           invokeRestart(restart)
[10:32:57.285]                           muffled <- TRUE
[10:32:57.285]                           break
[10:32:57.285]                         }
[10:32:57.285]                       }
[10:32:57.285]                     }
[10:32:57.285]                     invisible(muffled)
[10:32:57.285]                   }
[10:32:57.285]                   muffleCondition(cond)
[10:32:57.285]                 })
[10:32:57.285]             }))
[10:32:57.285]             future::FutureResult(value = ...future.value$value, 
[10:32:57.285]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.285]                   ...future.rng), globalenv = if (FALSE) 
[10:32:57.285]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:57.285]                     ...future.globalenv.names))
[10:32:57.285]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:57.285]         }, condition = base::local({
[10:32:57.285]             c <- base::c
[10:32:57.285]             inherits <- base::inherits
[10:32:57.285]             invokeRestart <- base::invokeRestart
[10:32:57.285]             length <- base::length
[10:32:57.285]             list <- base::list
[10:32:57.285]             seq.int <- base::seq.int
[10:32:57.285]             signalCondition <- base::signalCondition
[10:32:57.285]             sys.calls <- base::sys.calls
[10:32:57.285]             `[[` <- base::`[[`
[10:32:57.285]             `+` <- base::`+`
[10:32:57.285]             `<<-` <- base::`<<-`
[10:32:57.285]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:57.285]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:57.285]                   3L)]
[10:32:57.285]             }
[10:32:57.285]             function(cond) {
[10:32:57.285]                 is_error <- inherits(cond, "error")
[10:32:57.285]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:57.285]                   NULL)
[10:32:57.285]                 if (is_error) {
[10:32:57.285]                   sessionInformation <- function() {
[10:32:57.285]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:57.285]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:57.285]                       search = base::search(), system = base::Sys.info())
[10:32:57.285]                   }
[10:32:57.285]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.285]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:57.285]                     cond$call), session = sessionInformation(), 
[10:32:57.285]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:57.285]                   signalCondition(cond)
[10:32:57.285]                 }
[10:32:57.285]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:57.285]                 "immediateCondition"))) {
[10:32:57.285]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:57.285]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.285]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:57.285]                   if (TRUE && !signal) {
[10:32:57.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.285]                     {
[10:32:57.285]                       inherits <- base::inherits
[10:32:57.285]                       invokeRestart <- base::invokeRestart
[10:32:57.285]                       is.null <- base::is.null
[10:32:57.285]                       muffled <- FALSE
[10:32:57.285]                       if (inherits(cond, "message")) {
[10:32:57.285]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.285]                         if (muffled) 
[10:32:57.285]                           invokeRestart("muffleMessage")
[10:32:57.285]                       }
[10:32:57.285]                       else if (inherits(cond, "warning")) {
[10:32:57.285]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.285]                         if (muffled) 
[10:32:57.285]                           invokeRestart("muffleWarning")
[10:32:57.285]                       }
[10:32:57.285]                       else if (inherits(cond, "condition")) {
[10:32:57.285]                         if (!is.null(pattern)) {
[10:32:57.285]                           computeRestarts <- base::computeRestarts
[10:32:57.285]                           grepl <- base::grepl
[10:32:57.285]                           restarts <- computeRestarts(cond)
[10:32:57.285]                           for (restart in restarts) {
[10:32:57.285]                             name <- restart$name
[10:32:57.285]                             if (is.null(name)) 
[10:32:57.285]                               next
[10:32:57.285]                             if (!grepl(pattern, name)) 
[10:32:57.285]                               next
[10:32:57.285]                             invokeRestart(restart)
[10:32:57.285]                             muffled <- TRUE
[10:32:57.285]                             break
[10:32:57.285]                           }
[10:32:57.285]                         }
[10:32:57.285]                       }
[10:32:57.285]                       invisible(muffled)
[10:32:57.285]                     }
[10:32:57.285]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.285]                   }
[10:32:57.285]                 }
[10:32:57.285]                 else {
[10:32:57.285]                   if (TRUE) {
[10:32:57.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.285]                     {
[10:32:57.285]                       inherits <- base::inherits
[10:32:57.285]                       invokeRestart <- base::invokeRestart
[10:32:57.285]                       is.null <- base::is.null
[10:32:57.285]                       muffled <- FALSE
[10:32:57.285]                       if (inherits(cond, "message")) {
[10:32:57.285]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.285]                         if (muffled) 
[10:32:57.285]                           invokeRestart("muffleMessage")
[10:32:57.285]                       }
[10:32:57.285]                       else if (inherits(cond, "warning")) {
[10:32:57.285]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.285]                         if (muffled) 
[10:32:57.285]                           invokeRestart("muffleWarning")
[10:32:57.285]                       }
[10:32:57.285]                       else if (inherits(cond, "condition")) {
[10:32:57.285]                         if (!is.null(pattern)) {
[10:32:57.285]                           computeRestarts <- base::computeRestarts
[10:32:57.285]                           grepl <- base::grepl
[10:32:57.285]                           restarts <- computeRestarts(cond)
[10:32:57.285]                           for (restart in restarts) {
[10:32:57.285]                             name <- restart$name
[10:32:57.285]                             if (is.null(name)) 
[10:32:57.285]                               next
[10:32:57.285]                             if (!grepl(pattern, name)) 
[10:32:57.285]                               next
[10:32:57.285]                             invokeRestart(restart)
[10:32:57.285]                             muffled <- TRUE
[10:32:57.285]                             break
[10:32:57.285]                           }
[10:32:57.285]                         }
[10:32:57.285]                       }
[10:32:57.285]                       invisible(muffled)
[10:32:57.285]                     }
[10:32:57.285]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.285]                   }
[10:32:57.285]                 }
[10:32:57.285]             }
[10:32:57.285]         }))
[10:32:57.285]     }, error = function(ex) {
[10:32:57.285]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:57.285]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.285]                 ...future.rng), started = ...future.startTime, 
[10:32:57.285]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:57.285]             version = "1.8"), class = "FutureResult")
[10:32:57.285]     }, finally = {
[10:32:57.285]         if (!identical(...future.workdir, getwd())) 
[10:32:57.285]             setwd(...future.workdir)
[10:32:57.285]         {
[10:32:57.285]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:57.285]                 ...future.oldOptions$nwarnings <- NULL
[10:32:57.285]             }
[10:32:57.285]             base::options(...future.oldOptions)
[10:32:57.285]             if (.Platform$OS.type == "windows") {
[10:32:57.285]                 old_names <- names(...future.oldEnvVars)
[10:32:57.285]                 envs <- base::Sys.getenv()
[10:32:57.285]                 names <- names(envs)
[10:32:57.285]                 common <- intersect(names, old_names)
[10:32:57.285]                 added <- setdiff(names, old_names)
[10:32:57.285]                 removed <- setdiff(old_names, names)
[10:32:57.285]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:57.285]                   envs[common]]
[10:32:57.285]                 NAMES <- toupper(changed)
[10:32:57.285]                 args <- list()
[10:32:57.285]                 for (kk in seq_along(NAMES)) {
[10:32:57.285]                   name <- changed[[kk]]
[10:32:57.285]                   NAME <- NAMES[[kk]]
[10:32:57.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.285]                     next
[10:32:57.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.285]                 }
[10:32:57.285]                 NAMES <- toupper(added)
[10:32:57.285]                 for (kk in seq_along(NAMES)) {
[10:32:57.285]                   name <- added[[kk]]
[10:32:57.285]                   NAME <- NAMES[[kk]]
[10:32:57.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.285]                     next
[10:32:57.285]                   args[[name]] <- ""
[10:32:57.285]                 }
[10:32:57.285]                 NAMES <- toupper(removed)
[10:32:57.285]                 for (kk in seq_along(NAMES)) {
[10:32:57.285]                   name <- removed[[kk]]
[10:32:57.285]                   NAME <- NAMES[[kk]]
[10:32:57.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.285]                     next
[10:32:57.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.285]                 }
[10:32:57.285]                 if (length(args) > 0) 
[10:32:57.285]                   base::do.call(base::Sys.setenv, args = args)
[10:32:57.285]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:57.285]             }
[10:32:57.285]             else {
[10:32:57.285]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:57.285]             }
[10:32:57.285]             {
[10:32:57.285]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:57.285]                   0L) {
[10:32:57.285]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:57.285]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:57.285]                   base::options(opts)
[10:32:57.285]                 }
[10:32:57.285]                 {
[10:32:57.285]                   {
[10:32:57.285]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:57.285]                     NULL
[10:32:57.285]                   }
[10:32:57.285]                   options(future.plan = NULL)
[10:32:57.285]                   if (is.na(NA_character_)) 
[10:32:57.285]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.285]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:57.285]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:57.285]                     .init = FALSE)
[10:32:57.285]                 }
[10:32:57.285]             }
[10:32:57.285]         }
[10:32:57.285]     })
[10:32:57.285]     if (TRUE) {
[10:32:57.285]         base::sink(type = "output", split = FALSE)
[10:32:57.285]         if (TRUE) {
[10:32:57.285]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:57.285]         }
[10:32:57.285]         else {
[10:32:57.285]             ...future.result["stdout"] <- base::list(NULL)
[10:32:57.285]         }
[10:32:57.285]         base::close(...future.stdout)
[10:32:57.285]         ...future.stdout <- NULL
[10:32:57.285]     }
[10:32:57.285]     ...future.result$conditions <- ...future.conditions
[10:32:57.285]     ...future.result$finished <- base::Sys.time()
[10:32:57.285]     ...future.result
[10:32:57.285] }
[10:32:57.287] assign_globals() ...
[10:32:57.287] List of 2
[10:32:57.287]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:32:57.287]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:32:57.287]  - attr(*, "where")=List of 2
[10:32:57.287]   ..$ weight:<environment: R_EmptyEnv> 
[10:32:57.287]   ..$ group :<environment: R_EmptyEnv> 
[10:32:57.287]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:57.287]  - attr(*, "resolved")= logi FALSE
[10:32:57.287]  - attr(*, "total_size")= num 896
[10:32:57.287]  - attr(*, "already-done")= logi TRUE
[10:32:57.291] - copied ‘weight’ to environment
[10:32:57.292] - copied ‘group’ to environment
[10:32:57.292] assign_globals() ... done
[10:32:57.292] requestCore(): workers = 2
[10:32:57.294] MulticoreFuture started
[10:32:57.294] - Launch lazy future ... done
[10:32:57.294] run() for ‘MulticoreFuture’ ... done
[10:32:57.294] result() for MulticoreFuture ...
[10:32:57.295] plan(): Setting new future strategy stack:
[10:32:57.295] List of future strategies:
[10:32:57.295] 1. sequential:
[10:32:57.295]    - args: function (..., envir = parent.frame())
[10:32:57.295]    - tweaked: FALSE
[10:32:57.295]    - call: NULL
[10:32:57.296] plan(): nbrOfWorkers() = 1
[10:32:57.300] plan(): Setting new future strategy stack:
[10:32:57.300] List of future strategies:
[10:32:57.300] 1. multicore:
[10:32:57.300]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:57.300]    - tweaked: FALSE
[10:32:57.300]    - call: plan(strategy)
[10:32:57.305] plan(): nbrOfWorkers() = 2
[10:32:57.307] result() for MulticoreFuture ...
[10:32:57.307] result() for MulticoreFuture ... done
[10:32:57.307] result() for MulticoreFuture ... done
[10:32:57.307] result() for MulticoreFuture ...
[10:32:57.307] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[10:32:57.310] getGlobalsAndPackages() ...
[10:32:57.310] Searching for globals...
[10:32:57.311] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[10:32:57.312] Searching for globals ... DONE
[10:32:57.312] Resolving globals: FALSE
[10:32:57.312] The total size of the 1 globals is 96 bytes (96 bytes)
[10:32:57.313] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[10:32:57.313] - globals: [1] ‘x’
[10:32:57.313] - packages: [1] ‘stats’
[10:32:57.313] getGlobalsAndPackages() ... DONE
[10:32:57.314] run() for ‘Future’ ...
[10:32:57.314] - state: ‘created’
[10:32:57.314] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:57.318] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:57.318] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:57.318]   - Field: ‘label’
[10:32:57.318]   - Field: ‘local’
[10:32:57.318]   - Field: ‘owner’
[10:32:57.318]   - Field: ‘envir’
[10:32:57.319]   - Field: ‘workers’
[10:32:57.319]   - Field: ‘packages’
[10:32:57.319]   - Field: ‘gc’
[10:32:57.319]   - Field: ‘job’
[10:32:57.319]   - Field: ‘conditions’
[10:32:57.319]   - Field: ‘expr’
[10:32:57.319]   - Field: ‘uuid’
[10:32:57.319]   - Field: ‘seed’
[10:32:57.319]   - Field: ‘version’
[10:32:57.320]   - Field: ‘result’
[10:32:57.320]   - Field: ‘asynchronous’
[10:32:57.320]   - Field: ‘calls’
[10:32:57.320]   - Field: ‘globals’
[10:32:57.320]   - Field: ‘stdout’
[10:32:57.320]   - Field: ‘earlySignal’
[10:32:57.320]   - Field: ‘lazy’
[10:32:57.320]   - Field: ‘state’
[10:32:57.320] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:57.321] - Launch lazy future ...
[10:32:57.321] Packages needed by the future expression (n = 1): ‘stats’
[10:32:57.321] Packages needed by future strategies (n = 0): <none>
[10:32:57.322] {
[10:32:57.322]     {
[10:32:57.322]         {
[10:32:57.322]             ...future.startTime <- base::Sys.time()
[10:32:57.322]             {
[10:32:57.322]                 {
[10:32:57.322]                   {
[10:32:57.322]                     {
[10:32:57.322]                       {
[10:32:57.322]                         base::local({
[10:32:57.322]                           has_future <- base::requireNamespace("future", 
[10:32:57.322]                             quietly = TRUE)
[10:32:57.322]                           if (has_future) {
[10:32:57.322]                             ns <- base::getNamespace("future")
[10:32:57.322]                             version <- ns[[".package"]][["version"]]
[10:32:57.322]                             if (is.null(version)) 
[10:32:57.322]                               version <- utils::packageVersion("future")
[10:32:57.322]                           }
[10:32:57.322]                           else {
[10:32:57.322]                             version <- NULL
[10:32:57.322]                           }
[10:32:57.322]                           if (!has_future || version < "1.8.0") {
[10:32:57.322]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:57.322]                               "", base::R.version$version.string), 
[10:32:57.322]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:57.322]                                 base::R.version$platform, 8 * 
[10:32:57.322]                                   base::.Machine$sizeof.pointer), 
[10:32:57.322]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:57.322]                                 "release", "version")], collapse = " "), 
[10:32:57.322]                               hostname = base::Sys.info()[["nodename"]])
[10:32:57.322]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:57.322]                               info)
[10:32:57.322]                             info <- base::paste(info, collapse = "; ")
[10:32:57.322]                             if (!has_future) {
[10:32:57.322]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:57.322]                                 info)
[10:32:57.322]                             }
[10:32:57.322]                             else {
[10:32:57.322]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:57.322]                                 info, version)
[10:32:57.322]                             }
[10:32:57.322]                             base::stop(msg)
[10:32:57.322]                           }
[10:32:57.322]                         })
[10:32:57.322]                       }
[10:32:57.322]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:57.322]                       base::options(mc.cores = 1L)
[10:32:57.322]                     }
[10:32:57.322]                     base::local({
[10:32:57.322]                       for (pkg in "stats") {
[10:32:57.322]                         base::loadNamespace(pkg)
[10:32:57.322]                         base::library(pkg, character.only = TRUE)
[10:32:57.322]                       }
[10:32:57.322]                     })
[10:32:57.322]                   }
[10:32:57.322]                   ...future.strategy.old <- future::plan("list")
[10:32:57.322]                   options(future.plan = NULL)
[10:32:57.322]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.322]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:57.322]                 }
[10:32:57.322]                 ...future.workdir <- getwd()
[10:32:57.322]             }
[10:32:57.322]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:57.322]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:57.322]         }
[10:32:57.322]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:57.322]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:57.322]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:57.322]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:57.322]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:57.322]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:57.322]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:57.322]             base::names(...future.oldOptions))
[10:32:57.322]     }
[10:32:57.322]     if (FALSE) {
[10:32:57.322]     }
[10:32:57.322]     else {
[10:32:57.322]         if (TRUE) {
[10:32:57.322]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:57.322]                 open = "w")
[10:32:57.322]         }
[10:32:57.322]         else {
[10:32:57.322]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:57.322]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:57.322]         }
[10:32:57.322]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:57.322]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:57.322]             base::sink(type = "output", split = FALSE)
[10:32:57.322]             base::close(...future.stdout)
[10:32:57.322]         }, add = TRUE)
[10:32:57.322]     }
[10:32:57.322]     ...future.frame <- base::sys.nframe()
[10:32:57.322]     ...future.conditions <- base::list()
[10:32:57.322]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:57.322]     if (FALSE) {
[10:32:57.322]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:57.322]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:57.322]     }
[10:32:57.322]     ...future.result <- base::tryCatch({
[10:32:57.322]         base::withCallingHandlers({
[10:32:57.322]             ...future.value <- base::withVisible(base::local({
[10:32:57.322]                 withCallingHandlers({
[10:32:57.322]                   {
[10:32:57.322]                     xtabs(~x)
[10:32:57.322]                   }
[10:32:57.322]                 }, immediateCondition = function(cond) {
[10:32:57.322]                   save_rds <- function (object, pathname, ...) 
[10:32:57.322]                   {
[10:32:57.322]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:57.322]                     if (file_test("-f", pathname_tmp)) {
[10:32:57.322]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.322]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:57.322]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.322]                         fi_tmp[["mtime"]])
[10:32:57.322]                     }
[10:32:57.322]                     tryCatch({
[10:32:57.322]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:57.322]                     }, error = function(ex) {
[10:32:57.322]                       msg <- conditionMessage(ex)
[10:32:57.322]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.322]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:57.322]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.322]                         fi_tmp[["mtime"]], msg)
[10:32:57.322]                       ex$message <- msg
[10:32:57.322]                       stop(ex)
[10:32:57.322]                     })
[10:32:57.322]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:57.322]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:57.322]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:57.322]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.322]                       fi <- file.info(pathname)
[10:32:57.322]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:57.322]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.322]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:57.322]                         fi[["size"]], fi[["mtime"]])
[10:32:57.322]                       stop(msg)
[10:32:57.322]                     }
[10:32:57.322]                     invisible(pathname)
[10:32:57.322]                   }
[10:32:57.322]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:57.322]                     rootPath = tempdir()) 
[10:32:57.322]                   {
[10:32:57.322]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:57.322]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:57.322]                       tmpdir = path, fileext = ".rds")
[10:32:57.322]                     save_rds(obj, file)
[10:32:57.322]                   }
[10:32:57.322]                   saveImmediateCondition(cond, path = "/tmp/RtmpZSnOM5/.future/immediateConditions")
[10:32:57.322]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.322]                   {
[10:32:57.322]                     inherits <- base::inherits
[10:32:57.322]                     invokeRestart <- base::invokeRestart
[10:32:57.322]                     is.null <- base::is.null
[10:32:57.322]                     muffled <- FALSE
[10:32:57.322]                     if (inherits(cond, "message")) {
[10:32:57.322]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:57.322]                       if (muffled) 
[10:32:57.322]                         invokeRestart("muffleMessage")
[10:32:57.322]                     }
[10:32:57.322]                     else if (inherits(cond, "warning")) {
[10:32:57.322]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:57.322]                       if (muffled) 
[10:32:57.322]                         invokeRestart("muffleWarning")
[10:32:57.322]                     }
[10:32:57.322]                     else if (inherits(cond, "condition")) {
[10:32:57.322]                       if (!is.null(pattern)) {
[10:32:57.322]                         computeRestarts <- base::computeRestarts
[10:32:57.322]                         grepl <- base::grepl
[10:32:57.322]                         restarts <- computeRestarts(cond)
[10:32:57.322]                         for (restart in restarts) {
[10:32:57.322]                           name <- restart$name
[10:32:57.322]                           if (is.null(name)) 
[10:32:57.322]                             next
[10:32:57.322]                           if (!grepl(pattern, name)) 
[10:32:57.322]                             next
[10:32:57.322]                           invokeRestart(restart)
[10:32:57.322]                           muffled <- TRUE
[10:32:57.322]                           break
[10:32:57.322]                         }
[10:32:57.322]                       }
[10:32:57.322]                     }
[10:32:57.322]                     invisible(muffled)
[10:32:57.322]                   }
[10:32:57.322]                   muffleCondition(cond)
[10:32:57.322]                 })
[10:32:57.322]             }))
[10:32:57.322]             future::FutureResult(value = ...future.value$value, 
[10:32:57.322]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.322]                   ...future.rng), globalenv = if (FALSE) 
[10:32:57.322]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:57.322]                     ...future.globalenv.names))
[10:32:57.322]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:57.322]         }, condition = base::local({
[10:32:57.322]             c <- base::c
[10:32:57.322]             inherits <- base::inherits
[10:32:57.322]             invokeRestart <- base::invokeRestart
[10:32:57.322]             length <- base::length
[10:32:57.322]             list <- base::list
[10:32:57.322]             seq.int <- base::seq.int
[10:32:57.322]             signalCondition <- base::signalCondition
[10:32:57.322]             sys.calls <- base::sys.calls
[10:32:57.322]             `[[` <- base::`[[`
[10:32:57.322]             `+` <- base::`+`
[10:32:57.322]             `<<-` <- base::`<<-`
[10:32:57.322]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:57.322]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:57.322]                   3L)]
[10:32:57.322]             }
[10:32:57.322]             function(cond) {
[10:32:57.322]                 is_error <- inherits(cond, "error")
[10:32:57.322]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:57.322]                   NULL)
[10:32:57.322]                 if (is_error) {
[10:32:57.322]                   sessionInformation <- function() {
[10:32:57.322]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:57.322]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:57.322]                       search = base::search(), system = base::Sys.info())
[10:32:57.322]                   }
[10:32:57.322]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.322]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:57.322]                     cond$call), session = sessionInformation(), 
[10:32:57.322]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:57.322]                   signalCondition(cond)
[10:32:57.322]                 }
[10:32:57.322]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:57.322]                 "immediateCondition"))) {
[10:32:57.322]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:57.322]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.322]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:57.322]                   if (TRUE && !signal) {
[10:32:57.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.322]                     {
[10:32:57.322]                       inherits <- base::inherits
[10:32:57.322]                       invokeRestart <- base::invokeRestart
[10:32:57.322]                       is.null <- base::is.null
[10:32:57.322]                       muffled <- FALSE
[10:32:57.322]                       if (inherits(cond, "message")) {
[10:32:57.322]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.322]                         if (muffled) 
[10:32:57.322]                           invokeRestart("muffleMessage")
[10:32:57.322]                       }
[10:32:57.322]                       else if (inherits(cond, "warning")) {
[10:32:57.322]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.322]                         if (muffled) 
[10:32:57.322]                           invokeRestart("muffleWarning")
[10:32:57.322]                       }
[10:32:57.322]                       else if (inherits(cond, "condition")) {
[10:32:57.322]                         if (!is.null(pattern)) {
[10:32:57.322]                           computeRestarts <- base::computeRestarts
[10:32:57.322]                           grepl <- base::grepl
[10:32:57.322]                           restarts <- computeRestarts(cond)
[10:32:57.322]                           for (restart in restarts) {
[10:32:57.322]                             name <- restart$name
[10:32:57.322]                             if (is.null(name)) 
[10:32:57.322]                               next
[10:32:57.322]                             if (!grepl(pattern, name)) 
[10:32:57.322]                               next
[10:32:57.322]                             invokeRestart(restart)
[10:32:57.322]                             muffled <- TRUE
[10:32:57.322]                             break
[10:32:57.322]                           }
[10:32:57.322]                         }
[10:32:57.322]                       }
[10:32:57.322]                       invisible(muffled)
[10:32:57.322]                     }
[10:32:57.322]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.322]                   }
[10:32:57.322]                 }
[10:32:57.322]                 else {
[10:32:57.322]                   if (TRUE) {
[10:32:57.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.322]                     {
[10:32:57.322]                       inherits <- base::inherits
[10:32:57.322]                       invokeRestart <- base::invokeRestart
[10:32:57.322]                       is.null <- base::is.null
[10:32:57.322]                       muffled <- FALSE
[10:32:57.322]                       if (inherits(cond, "message")) {
[10:32:57.322]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.322]                         if (muffled) 
[10:32:57.322]                           invokeRestart("muffleMessage")
[10:32:57.322]                       }
[10:32:57.322]                       else if (inherits(cond, "warning")) {
[10:32:57.322]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.322]                         if (muffled) 
[10:32:57.322]                           invokeRestart("muffleWarning")
[10:32:57.322]                       }
[10:32:57.322]                       else if (inherits(cond, "condition")) {
[10:32:57.322]                         if (!is.null(pattern)) {
[10:32:57.322]                           computeRestarts <- base::computeRestarts
[10:32:57.322]                           grepl <- base::grepl
[10:32:57.322]                           restarts <- computeRestarts(cond)
[10:32:57.322]                           for (restart in restarts) {
[10:32:57.322]                             name <- restart$name
[10:32:57.322]                             if (is.null(name)) 
[10:32:57.322]                               next
[10:32:57.322]                             if (!grepl(pattern, name)) 
[10:32:57.322]                               next
[10:32:57.322]                             invokeRestart(restart)
[10:32:57.322]                             muffled <- TRUE
[10:32:57.322]                             break
[10:32:57.322]                           }
[10:32:57.322]                         }
[10:32:57.322]                       }
[10:32:57.322]                       invisible(muffled)
[10:32:57.322]                     }
[10:32:57.322]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.322]                   }
[10:32:57.322]                 }
[10:32:57.322]             }
[10:32:57.322]         }))
[10:32:57.322]     }, error = function(ex) {
[10:32:57.322]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:57.322]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.322]                 ...future.rng), started = ...future.startTime, 
[10:32:57.322]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:57.322]             version = "1.8"), class = "FutureResult")
[10:32:57.322]     }, finally = {
[10:32:57.322]         if (!identical(...future.workdir, getwd())) 
[10:32:57.322]             setwd(...future.workdir)
[10:32:57.322]         {
[10:32:57.322]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:57.322]                 ...future.oldOptions$nwarnings <- NULL
[10:32:57.322]             }
[10:32:57.322]             base::options(...future.oldOptions)
[10:32:57.322]             if (.Platform$OS.type == "windows") {
[10:32:57.322]                 old_names <- names(...future.oldEnvVars)
[10:32:57.322]                 envs <- base::Sys.getenv()
[10:32:57.322]                 names <- names(envs)
[10:32:57.322]                 common <- intersect(names, old_names)
[10:32:57.322]                 added <- setdiff(names, old_names)
[10:32:57.322]                 removed <- setdiff(old_names, names)
[10:32:57.322]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:57.322]                   envs[common]]
[10:32:57.322]                 NAMES <- toupper(changed)
[10:32:57.322]                 args <- list()
[10:32:57.322]                 for (kk in seq_along(NAMES)) {
[10:32:57.322]                   name <- changed[[kk]]
[10:32:57.322]                   NAME <- NAMES[[kk]]
[10:32:57.322]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.322]                     next
[10:32:57.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.322]                 }
[10:32:57.322]                 NAMES <- toupper(added)
[10:32:57.322]                 for (kk in seq_along(NAMES)) {
[10:32:57.322]                   name <- added[[kk]]
[10:32:57.322]                   NAME <- NAMES[[kk]]
[10:32:57.322]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.322]                     next
[10:32:57.322]                   args[[name]] <- ""
[10:32:57.322]                 }
[10:32:57.322]                 NAMES <- toupper(removed)
[10:32:57.322]                 for (kk in seq_along(NAMES)) {
[10:32:57.322]                   name <- removed[[kk]]
[10:32:57.322]                   NAME <- NAMES[[kk]]
[10:32:57.322]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.322]                     next
[10:32:57.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.322]                 }
[10:32:57.322]                 if (length(args) > 0) 
[10:32:57.322]                   base::do.call(base::Sys.setenv, args = args)
[10:32:57.322]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:57.322]             }
[10:32:57.322]             else {
[10:32:57.322]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:57.322]             }
[10:32:57.322]             {
[10:32:57.322]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:57.322]                   0L) {
[10:32:57.322]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:57.322]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:57.322]                   base::options(opts)
[10:32:57.322]                 }
[10:32:57.322]                 {
[10:32:57.322]                   {
[10:32:57.322]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:57.322]                     NULL
[10:32:57.322]                   }
[10:32:57.322]                   options(future.plan = NULL)
[10:32:57.322]                   if (is.na(NA_character_)) 
[10:32:57.322]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.322]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:57.322]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:57.322]                     .init = FALSE)
[10:32:57.322]                 }
[10:32:57.322]             }
[10:32:57.322]         }
[10:32:57.322]     })
[10:32:57.322]     if (TRUE) {
[10:32:57.322]         base::sink(type = "output", split = FALSE)
[10:32:57.322]         if (TRUE) {
[10:32:57.322]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:57.322]         }
[10:32:57.322]         else {
[10:32:57.322]             ...future.result["stdout"] <- base::list(NULL)
[10:32:57.322]         }
[10:32:57.322]         base::close(...future.stdout)
[10:32:57.322]         ...future.stdout <- NULL
[10:32:57.322]     }
[10:32:57.322]     ...future.result$conditions <- ...future.conditions
[10:32:57.322]     ...future.result$finished <- base::Sys.time()
[10:32:57.322]     ...future.result
[10:32:57.322] }
[10:32:57.324] assign_globals() ...
[10:32:57.324] List of 1
[10:32:57.324]  $ x: num [1:5] 1 1 2 2 2
[10:32:57.324]  - attr(*, "where")=List of 1
[10:32:57.324]   ..$ x:<environment: R_EmptyEnv> 
[10:32:57.324]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:57.324]  - attr(*, "resolved")= logi FALSE
[10:32:57.324]  - attr(*, "total_size")= num 96
[10:32:57.324]  - attr(*, "already-done")= logi TRUE
[10:32:57.330] - copied ‘x’ to environment
[10:32:57.330] assign_globals() ... done
[10:32:57.330] requestCore(): workers = 2
[10:32:57.332] MulticoreFuture started
[10:32:57.332] - Launch lazy future ... done
[10:32:57.333] run() for ‘MulticoreFuture’ ... done
[10:32:57.333] result() for MulticoreFuture ...
[10:32:57.334] plan(): Setting new future strategy stack:
[10:32:57.334] List of future strategies:
[10:32:57.334] 1. sequential:
[10:32:57.334]    - args: function (..., envir = parent.frame())
[10:32:57.334]    - tweaked: FALSE
[10:32:57.334]    - call: NULL
[10:32:57.335] plan(): nbrOfWorkers() = 1
[10:32:57.338] plan(): Setting new future strategy stack:
[10:32:57.338] List of future strategies:
[10:32:57.338] 1. multicore:
[10:32:57.338]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:57.338]    - tweaked: FALSE
[10:32:57.338]    - call: plan(strategy)
[10:32:57.343] plan(): nbrOfWorkers() = 2
[10:32:57.344] result() for MulticoreFuture ...
[10:32:57.344] result() for MulticoreFuture ... done
[10:32:57.345] result() for MulticoreFuture ... done
[10:32:57.345] result() for MulticoreFuture ...
[10:32:57.345] result() for MulticoreFuture ... done
x
1 2 
2 3 
[10:32:57.346] getGlobalsAndPackages() ...
[10:32:57.346] Searching for globals...
[10:32:57.348] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[10:32:57.348] Searching for globals ... DONE
[10:32:57.348] Resolving globals: FALSE
[10:32:57.349] The total size of the 1 globals is 96 bytes (96 bytes)
[10:32:57.349] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[10:32:57.350] - globals: [1] ‘x’
[10:32:57.350] - packages: [1] ‘stats’
[10:32:57.350] getGlobalsAndPackages() ... DONE
[10:32:57.350] run() for ‘Future’ ...
[10:32:57.350] - state: ‘created’
[10:32:57.351] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:57.355] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:57.355] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:57.355]   - Field: ‘label’
[10:32:57.355]   - Field: ‘local’
[10:32:57.355]   - Field: ‘owner’
[10:32:57.356]   - Field: ‘envir’
[10:32:57.356]   - Field: ‘workers’
[10:32:57.356]   - Field: ‘packages’
[10:32:57.356]   - Field: ‘gc’
[10:32:57.356]   - Field: ‘job’
[10:32:57.356]   - Field: ‘conditions’
[10:32:57.356]   - Field: ‘expr’
[10:32:57.356]   - Field: ‘uuid’
[10:32:57.356]   - Field: ‘seed’
[10:32:57.357]   - Field: ‘version’
[10:32:57.357]   - Field: ‘result’
[10:32:57.357]   - Field: ‘asynchronous’
[10:32:57.357]   - Field: ‘calls’
[10:32:57.357]   - Field: ‘globals’
[10:32:57.357]   - Field: ‘stdout’
[10:32:57.357]   - Field: ‘earlySignal’
[10:32:57.357]   - Field: ‘lazy’
[10:32:57.357]   - Field: ‘state’
[10:32:57.358] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:57.358] - Launch lazy future ...
[10:32:57.358] Packages needed by the future expression (n = 1): ‘stats’
[10:32:57.358] Packages needed by future strategies (n = 0): <none>
[10:32:57.359] {
[10:32:57.359]     {
[10:32:57.359]         {
[10:32:57.359]             ...future.startTime <- base::Sys.time()
[10:32:57.359]             {
[10:32:57.359]                 {
[10:32:57.359]                   {
[10:32:57.359]                     {
[10:32:57.359]                       {
[10:32:57.359]                         base::local({
[10:32:57.359]                           has_future <- base::requireNamespace("future", 
[10:32:57.359]                             quietly = TRUE)
[10:32:57.359]                           if (has_future) {
[10:32:57.359]                             ns <- base::getNamespace("future")
[10:32:57.359]                             version <- ns[[".package"]][["version"]]
[10:32:57.359]                             if (is.null(version)) 
[10:32:57.359]                               version <- utils::packageVersion("future")
[10:32:57.359]                           }
[10:32:57.359]                           else {
[10:32:57.359]                             version <- NULL
[10:32:57.359]                           }
[10:32:57.359]                           if (!has_future || version < "1.8.0") {
[10:32:57.359]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:57.359]                               "", base::R.version$version.string), 
[10:32:57.359]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:57.359]                                 base::R.version$platform, 8 * 
[10:32:57.359]                                   base::.Machine$sizeof.pointer), 
[10:32:57.359]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:57.359]                                 "release", "version")], collapse = " "), 
[10:32:57.359]                               hostname = base::Sys.info()[["nodename"]])
[10:32:57.359]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:57.359]                               info)
[10:32:57.359]                             info <- base::paste(info, collapse = "; ")
[10:32:57.359]                             if (!has_future) {
[10:32:57.359]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:57.359]                                 info)
[10:32:57.359]                             }
[10:32:57.359]                             else {
[10:32:57.359]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:57.359]                                 info, version)
[10:32:57.359]                             }
[10:32:57.359]                             base::stop(msg)
[10:32:57.359]                           }
[10:32:57.359]                         })
[10:32:57.359]                       }
[10:32:57.359]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:57.359]                       base::options(mc.cores = 1L)
[10:32:57.359]                     }
[10:32:57.359]                     base::local({
[10:32:57.359]                       for (pkg in "stats") {
[10:32:57.359]                         base::loadNamespace(pkg)
[10:32:57.359]                         base::library(pkg, character.only = TRUE)
[10:32:57.359]                       }
[10:32:57.359]                     })
[10:32:57.359]                   }
[10:32:57.359]                   ...future.strategy.old <- future::plan("list")
[10:32:57.359]                   options(future.plan = NULL)
[10:32:57.359]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.359]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:57.359]                 }
[10:32:57.359]                 ...future.workdir <- getwd()
[10:32:57.359]             }
[10:32:57.359]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:57.359]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:57.359]         }
[10:32:57.359]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:57.359]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:57.359]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:57.359]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:57.359]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:57.359]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:57.359]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:57.359]             base::names(...future.oldOptions))
[10:32:57.359]     }
[10:32:57.359]     if (FALSE) {
[10:32:57.359]     }
[10:32:57.359]     else {
[10:32:57.359]         if (TRUE) {
[10:32:57.359]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:57.359]                 open = "w")
[10:32:57.359]         }
[10:32:57.359]         else {
[10:32:57.359]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:57.359]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:57.359]         }
[10:32:57.359]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:57.359]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:57.359]             base::sink(type = "output", split = FALSE)
[10:32:57.359]             base::close(...future.stdout)
[10:32:57.359]         }, add = TRUE)
[10:32:57.359]     }
[10:32:57.359]     ...future.frame <- base::sys.nframe()
[10:32:57.359]     ...future.conditions <- base::list()
[10:32:57.359]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:57.359]     if (FALSE) {
[10:32:57.359]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:57.359]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:57.359]     }
[10:32:57.359]     ...future.result <- base::tryCatch({
[10:32:57.359]         base::withCallingHandlers({
[10:32:57.359]             ...future.value <- base::withVisible(base::local({
[10:32:57.359]                 withCallingHandlers({
[10:32:57.359]                   {
[10:32:57.359]                     xtabs(~x)
[10:32:57.359]                   }
[10:32:57.359]                 }, immediateCondition = function(cond) {
[10:32:57.359]                   save_rds <- function (object, pathname, ...) 
[10:32:57.359]                   {
[10:32:57.359]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:57.359]                     if (file_test("-f", pathname_tmp)) {
[10:32:57.359]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.359]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:57.359]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.359]                         fi_tmp[["mtime"]])
[10:32:57.359]                     }
[10:32:57.359]                     tryCatch({
[10:32:57.359]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:57.359]                     }, error = function(ex) {
[10:32:57.359]                       msg <- conditionMessage(ex)
[10:32:57.359]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.359]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:57.359]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.359]                         fi_tmp[["mtime"]], msg)
[10:32:57.359]                       ex$message <- msg
[10:32:57.359]                       stop(ex)
[10:32:57.359]                     })
[10:32:57.359]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:57.359]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:57.359]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:57.359]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.359]                       fi <- file.info(pathname)
[10:32:57.359]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:57.359]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.359]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:57.359]                         fi[["size"]], fi[["mtime"]])
[10:32:57.359]                       stop(msg)
[10:32:57.359]                     }
[10:32:57.359]                     invisible(pathname)
[10:32:57.359]                   }
[10:32:57.359]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:57.359]                     rootPath = tempdir()) 
[10:32:57.359]                   {
[10:32:57.359]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:57.359]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:57.359]                       tmpdir = path, fileext = ".rds")
[10:32:57.359]                     save_rds(obj, file)
[10:32:57.359]                   }
[10:32:57.359]                   saveImmediateCondition(cond, path = "/tmp/RtmpZSnOM5/.future/immediateConditions")
[10:32:57.359]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.359]                   {
[10:32:57.359]                     inherits <- base::inherits
[10:32:57.359]                     invokeRestart <- base::invokeRestart
[10:32:57.359]                     is.null <- base::is.null
[10:32:57.359]                     muffled <- FALSE
[10:32:57.359]                     if (inherits(cond, "message")) {
[10:32:57.359]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:57.359]                       if (muffled) 
[10:32:57.359]                         invokeRestart("muffleMessage")
[10:32:57.359]                     }
[10:32:57.359]                     else if (inherits(cond, "warning")) {
[10:32:57.359]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:57.359]                       if (muffled) 
[10:32:57.359]                         invokeRestart("muffleWarning")
[10:32:57.359]                     }
[10:32:57.359]                     else if (inherits(cond, "condition")) {
[10:32:57.359]                       if (!is.null(pattern)) {
[10:32:57.359]                         computeRestarts <- base::computeRestarts
[10:32:57.359]                         grepl <- base::grepl
[10:32:57.359]                         restarts <- computeRestarts(cond)
[10:32:57.359]                         for (restart in restarts) {
[10:32:57.359]                           name <- restart$name
[10:32:57.359]                           if (is.null(name)) 
[10:32:57.359]                             next
[10:32:57.359]                           if (!grepl(pattern, name)) 
[10:32:57.359]                             next
[10:32:57.359]                           invokeRestart(restart)
[10:32:57.359]                           muffled <- TRUE
[10:32:57.359]                           break
[10:32:57.359]                         }
[10:32:57.359]                       }
[10:32:57.359]                     }
[10:32:57.359]                     invisible(muffled)
[10:32:57.359]                   }
[10:32:57.359]                   muffleCondition(cond)
[10:32:57.359]                 })
[10:32:57.359]             }))
[10:32:57.359]             future::FutureResult(value = ...future.value$value, 
[10:32:57.359]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.359]                   ...future.rng), globalenv = if (FALSE) 
[10:32:57.359]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:57.359]                     ...future.globalenv.names))
[10:32:57.359]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:57.359]         }, condition = base::local({
[10:32:57.359]             c <- base::c
[10:32:57.359]             inherits <- base::inherits
[10:32:57.359]             invokeRestart <- base::invokeRestart
[10:32:57.359]             length <- base::length
[10:32:57.359]             list <- base::list
[10:32:57.359]             seq.int <- base::seq.int
[10:32:57.359]             signalCondition <- base::signalCondition
[10:32:57.359]             sys.calls <- base::sys.calls
[10:32:57.359]             `[[` <- base::`[[`
[10:32:57.359]             `+` <- base::`+`
[10:32:57.359]             `<<-` <- base::`<<-`
[10:32:57.359]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:57.359]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:57.359]                   3L)]
[10:32:57.359]             }
[10:32:57.359]             function(cond) {
[10:32:57.359]                 is_error <- inherits(cond, "error")
[10:32:57.359]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:57.359]                   NULL)
[10:32:57.359]                 if (is_error) {
[10:32:57.359]                   sessionInformation <- function() {
[10:32:57.359]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:57.359]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:57.359]                       search = base::search(), system = base::Sys.info())
[10:32:57.359]                   }
[10:32:57.359]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.359]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:57.359]                     cond$call), session = sessionInformation(), 
[10:32:57.359]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:57.359]                   signalCondition(cond)
[10:32:57.359]                 }
[10:32:57.359]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:57.359]                 "immediateCondition"))) {
[10:32:57.359]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:57.359]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.359]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:57.359]                   if (TRUE && !signal) {
[10:32:57.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.359]                     {
[10:32:57.359]                       inherits <- base::inherits
[10:32:57.359]                       invokeRestart <- base::invokeRestart
[10:32:57.359]                       is.null <- base::is.null
[10:32:57.359]                       muffled <- FALSE
[10:32:57.359]                       if (inherits(cond, "message")) {
[10:32:57.359]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.359]                         if (muffled) 
[10:32:57.359]                           invokeRestart("muffleMessage")
[10:32:57.359]                       }
[10:32:57.359]                       else if (inherits(cond, "warning")) {
[10:32:57.359]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.359]                         if (muffled) 
[10:32:57.359]                           invokeRestart("muffleWarning")
[10:32:57.359]                       }
[10:32:57.359]                       else if (inherits(cond, "condition")) {
[10:32:57.359]                         if (!is.null(pattern)) {
[10:32:57.359]                           computeRestarts <- base::computeRestarts
[10:32:57.359]                           grepl <- base::grepl
[10:32:57.359]                           restarts <- computeRestarts(cond)
[10:32:57.359]                           for (restart in restarts) {
[10:32:57.359]                             name <- restart$name
[10:32:57.359]                             if (is.null(name)) 
[10:32:57.359]                               next
[10:32:57.359]                             if (!grepl(pattern, name)) 
[10:32:57.359]                               next
[10:32:57.359]                             invokeRestart(restart)
[10:32:57.359]                             muffled <- TRUE
[10:32:57.359]                             break
[10:32:57.359]                           }
[10:32:57.359]                         }
[10:32:57.359]                       }
[10:32:57.359]                       invisible(muffled)
[10:32:57.359]                     }
[10:32:57.359]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.359]                   }
[10:32:57.359]                 }
[10:32:57.359]                 else {
[10:32:57.359]                   if (TRUE) {
[10:32:57.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.359]                     {
[10:32:57.359]                       inherits <- base::inherits
[10:32:57.359]                       invokeRestart <- base::invokeRestart
[10:32:57.359]                       is.null <- base::is.null
[10:32:57.359]                       muffled <- FALSE
[10:32:57.359]                       if (inherits(cond, "message")) {
[10:32:57.359]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.359]                         if (muffled) 
[10:32:57.359]                           invokeRestart("muffleMessage")
[10:32:57.359]                       }
[10:32:57.359]                       else if (inherits(cond, "warning")) {
[10:32:57.359]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.359]                         if (muffled) 
[10:32:57.359]                           invokeRestart("muffleWarning")
[10:32:57.359]                       }
[10:32:57.359]                       else if (inherits(cond, "condition")) {
[10:32:57.359]                         if (!is.null(pattern)) {
[10:32:57.359]                           computeRestarts <- base::computeRestarts
[10:32:57.359]                           grepl <- base::grepl
[10:32:57.359]                           restarts <- computeRestarts(cond)
[10:32:57.359]                           for (restart in restarts) {
[10:32:57.359]                             name <- restart$name
[10:32:57.359]                             if (is.null(name)) 
[10:32:57.359]                               next
[10:32:57.359]                             if (!grepl(pattern, name)) 
[10:32:57.359]                               next
[10:32:57.359]                             invokeRestart(restart)
[10:32:57.359]                             muffled <- TRUE
[10:32:57.359]                             break
[10:32:57.359]                           }
[10:32:57.359]                         }
[10:32:57.359]                       }
[10:32:57.359]                       invisible(muffled)
[10:32:57.359]                     }
[10:32:57.359]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.359]                   }
[10:32:57.359]                 }
[10:32:57.359]             }
[10:32:57.359]         }))
[10:32:57.359]     }, error = function(ex) {
[10:32:57.359]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:57.359]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.359]                 ...future.rng), started = ...future.startTime, 
[10:32:57.359]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:57.359]             version = "1.8"), class = "FutureResult")
[10:32:57.359]     }, finally = {
[10:32:57.359]         if (!identical(...future.workdir, getwd())) 
[10:32:57.359]             setwd(...future.workdir)
[10:32:57.359]         {
[10:32:57.359]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:57.359]                 ...future.oldOptions$nwarnings <- NULL
[10:32:57.359]             }
[10:32:57.359]             base::options(...future.oldOptions)
[10:32:57.359]             if (.Platform$OS.type == "windows") {
[10:32:57.359]                 old_names <- names(...future.oldEnvVars)
[10:32:57.359]                 envs <- base::Sys.getenv()
[10:32:57.359]                 names <- names(envs)
[10:32:57.359]                 common <- intersect(names, old_names)
[10:32:57.359]                 added <- setdiff(names, old_names)
[10:32:57.359]                 removed <- setdiff(old_names, names)
[10:32:57.359]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:57.359]                   envs[common]]
[10:32:57.359]                 NAMES <- toupper(changed)
[10:32:57.359]                 args <- list()
[10:32:57.359]                 for (kk in seq_along(NAMES)) {
[10:32:57.359]                   name <- changed[[kk]]
[10:32:57.359]                   NAME <- NAMES[[kk]]
[10:32:57.359]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.359]                     next
[10:32:57.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.359]                 }
[10:32:57.359]                 NAMES <- toupper(added)
[10:32:57.359]                 for (kk in seq_along(NAMES)) {
[10:32:57.359]                   name <- added[[kk]]
[10:32:57.359]                   NAME <- NAMES[[kk]]
[10:32:57.359]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.359]                     next
[10:32:57.359]                   args[[name]] <- ""
[10:32:57.359]                 }
[10:32:57.359]                 NAMES <- toupper(removed)
[10:32:57.359]                 for (kk in seq_along(NAMES)) {
[10:32:57.359]                   name <- removed[[kk]]
[10:32:57.359]                   NAME <- NAMES[[kk]]
[10:32:57.359]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.359]                     next
[10:32:57.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.359]                 }
[10:32:57.359]                 if (length(args) > 0) 
[10:32:57.359]                   base::do.call(base::Sys.setenv, args = args)
[10:32:57.359]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:57.359]             }
[10:32:57.359]             else {
[10:32:57.359]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:57.359]             }
[10:32:57.359]             {
[10:32:57.359]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:57.359]                   0L) {
[10:32:57.359]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:57.359]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:57.359]                   base::options(opts)
[10:32:57.359]                 }
[10:32:57.359]                 {
[10:32:57.359]                   {
[10:32:57.359]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:57.359]                     NULL
[10:32:57.359]                   }
[10:32:57.359]                   options(future.plan = NULL)
[10:32:57.359]                   if (is.na(NA_character_)) 
[10:32:57.359]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.359]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:57.359]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:57.359]                     .init = FALSE)
[10:32:57.359]                 }
[10:32:57.359]             }
[10:32:57.359]         }
[10:32:57.359]     })
[10:32:57.359]     if (TRUE) {
[10:32:57.359]         base::sink(type = "output", split = FALSE)
[10:32:57.359]         if (TRUE) {
[10:32:57.359]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:57.359]         }
[10:32:57.359]         else {
[10:32:57.359]             ...future.result["stdout"] <- base::list(NULL)
[10:32:57.359]         }
[10:32:57.359]         base::close(...future.stdout)
[10:32:57.359]         ...future.stdout <- NULL
[10:32:57.359]     }
[10:32:57.359]     ...future.result$conditions <- ...future.conditions
[10:32:57.359]     ...future.result$finished <- base::Sys.time()
[10:32:57.359]     ...future.result
[10:32:57.359] }
[10:32:57.362] assign_globals() ...
[10:32:57.362] List of 1
[10:32:57.362]  $ x: num [1:5] 1 1 2 2 2
[10:32:57.362]  - attr(*, "where")=List of 1
[10:32:57.362]   ..$ x:<environment: R_EmptyEnv> 
[10:32:57.362]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:57.362]  - attr(*, "resolved")= logi FALSE
[10:32:57.362]  - attr(*, "total_size")= num 96
[10:32:57.362]  - attr(*, "already-done")= logi TRUE
[10:32:57.365] - copied ‘x’ to environment
[10:32:57.365] assign_globals() ... done
[10:32:57.365] requestCore(): workers = 2
[10:32:57.367] MulticoreFuture started
[10:32:57.367] - Launch lazy future ... done
[10:32:57.368] run() for ‘MulticoreFuture’ ... done
[10:32:57.368] result() for MulticoreFuture ...
[10:32:57.369] plan(): Setting new future strategy stack:
[10:32:57.369] List of future strategies:
[10:32:57.369] 1. sequential:
[10:32:57.369]    - args: function (..., envir = parent.frame())
[10:32:57.369]    - tweaked: FALSE
[10:32:57.369]    - call: NULL
[10:32:57.370] plan(): nbrOfWorkers() = 1
[10:32:57.373] plan(): Setting new future strategy stack:
[10:32:57.373] List of future strategies:
[10:32:57.373] 1. multicore:
[10:32:57.373]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:57.373]    - tweaked: FALSE
[10:32:57.373]    - call: plan(strategy)
[10:32:57.382] plan(): nbrOfWorkers() = 2
[10:32:57.383] result() for MulticoreFuture ...
[10:32:57.383] result() for MulticoreFuture ... done
[10:32:57.383] result() for MulticoreFuture ... done
[10:32:57.383] result() for MulticoreFuture ...
[10:32:57.383] result() for MulticoreFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[10:32:57.386] getGlobalsAndPackages() ...
[10:32:57.386] Searching for globals...
[10:32:57.391] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[10:32:57.391] Searching for globals ... DONE
[10:32:57.391] Resolving globals: FALSE
[10:32:57.392] 
[10:32:57.392] - packages: [2] ‘stats’, ‘datasets’
[10:32:57.392] getGlobalsAndPackages() ... DONE
[10:32:57.392] run() for ‘Future’ ...
[10:32:57.392] - state: ‘created’
[10:32:57.393] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:57.396] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:57.397] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:57.397]   - Field: ‘label’
[10:32:57.397]   - Field: ‘local’
[10:32:57.397]   - Field: ‘owner’
[10:32:57.397]   - Field: ‘envir’
[10:32:57.397]   - Field: ‘workers’
[10:32:57.397]   - Field: ‘packages’
[10:32:57.398]   - Field: ‘gc’
[10:32:57.398]   - Field: ‘job’
[10:32:57.398]   - Field: ‘conditions’
[10:32:57.398]   - Field: ‘expr’
[10:32:57.398]   - Field: ‘uuid’
[10:32:57.398]   - Field: ‘seed’
[10:32:57.398]   - Field: ‘version’
[10:32:57.398]   - Field: ‘result’
[10:32:57.399]   - Field: ‘asynchronous’
[10:32:57.399]   - Field: ‘calls’
[10:32:57.399]   - Field: ‘globals’
[10:32:57.399]   - Field: ‘stdout’
[10:32:57.399]   - Field: ‘earlySignal’
[10:32:57.399]   - Field: ‘lazy’
[10:32:57.399]   - Field: ‘state’
[10:32:57.399] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:57.399] - Launch lazy future ...
[10:32:57.400] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:32:57.400] Packages needed by future strategies (n = 0): <none>
[10:32:57.401] {
[10:32:57.401]     {
[10:32:57.401]         {
[10:32:57.401]             ...future.startTime <- base::Sys.time()
[10:32:57.401]             {
[10:32:57.401]                 {
[10:32:57.401]                   {
[10:32:57.401]                     {
[10:32:57.401]                       {
[10:32:57.401]                         base::local({
[10:32:57.401]                           has_future <- base::requireNamespace("future", 
[10:32:57.401]                             quietly = TRUE)
[10:32:57.401]                           if (has_future) {
[10:32:57.401]                             ns <- base::getNamespace("future")
[10:32:57.401]                             version <- ns[[".package"]][["version"]]
[10:32:57.401]                             if (is.null(version)) 
[10:32:57.401]                               version <- utils::packageVersion("future")
[10:32:57.401]                           }
[10:32:57.401]                           else {
[10:32:57.401]                             version <- NULL
[10:32:57.401]                           }
[10:32:57.401]                           if (!has_future || version < "1.8.0") {
[10:32:57.401]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:57.401]                               "", base::R.version$version.string), 
[10:32:57.401]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:57.401]                                 base::R.version$platform, 8 * 
[10:32:57.401]                                   base::.Machine$sizeof.pointer), 
[10:32:57.401]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:57.401]                                 "release", "version")], collapse = " "), 
[10:32:57.401]                               hostname = base::Sys.info()[["nodename"]])
[10:32:57.401]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:57.401]                               info)
[10:32:57.401]                             info <- base::paste(info, collapse = "; ")
[10:32:57.401]                             if (!has_future) {
[10:32:57.401]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:57.401]                                 info)
[10:32:57.401]                             }
[10:32:57.401]                             else {
[10:32:57.401]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:57.401]                                 info, version)
[10:32:57.401]                             }
[10:32:57.401]                             base::stop(msg)
[10:32:57.401]                           }
[10:32:57.401]                         })
[10:32:57.401]                       }
[10:32:57.401]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:57.401]                       base::options(mc.cores = 1L)
[10:32:57.401]                     }
[10:32:57.401]                     base::local({
[10:32:57.401]                       for (pkg in c("stats", "datasets")) {
[10:32:57.401]                         base::loadNamespace(pkg)
[10:32:57.401]                         base::library(pkg, character.only = TRUE)
[10:32:57.401]                       }
[10:32:57.401]                     })
[10:32:57.401]                   }
[10:32:57.401]                   ...future.strategy.old <- future::plan("list")
[10:32:57.401]                   options(future.plan = NULL)
[10:32:57.401]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.401]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:57.401]                 }
[10:32:57.401]                 ...future.workdir <- getwd()
[10:32:57.401]             }
[10:32:57.401]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:57.401]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:57.401]         }
[10:32:57.401]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:57.401]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:57.401]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:57.401]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:57.401]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:57.401]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:57.401]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:57.401]             base::names(...future.oldOptions))
[10:32:57.401]     }
[10:32:57.401]     if (FALSE) {
[10:32:57.401]     }
[10:32:57.401]     else {
[10:32:57.401]         if (TRUE) {
[10:32:57.401]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:57.401]                 open = "w")
[10:32:57.401]         }
[10:32:57.401]         else {
[10:32:57.401]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:57.401]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:57.401]         }
[10:32:57.401]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:57.401]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:57.401]             base::sink(type = "output", split = FALSE)
[10:32:57.401]             base::close(...future.stdout)
[10:32:57.401]         }, add = TRUE)
[10:32:57.401]     }
[10:32:57.401]     ...future.frame <- base::sys.nframe()
[10:32:57.401]     ...future.conditions <- base::list()
[10:32:57.401]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:57.401]     if (FALSE) {
[10:32:57.401]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:57.401]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:57.401]     }
[10:32:57.401]     ...future.result <- base::tryCatch({
[10:32:57.401]         base::withCallingHandlers({
[10:32:57.401]             ...future.value <- base::withVisible(base::local({
[10:32:57.401]                 withCallingHandlers({
[10:32:57.401]                   {
[10:32:57.401]                     lm(dist ~ . - 1, data = cars)
[10:32:57.401]                   }
[10:32:57.401]                 }, immediateCondition = function(cond) {
[10:32:57.401]                   save_rds <- function (object, pathname, ...) 
[10:32:57.401]                   {
[10:32:57.401]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:57.401]                     if (file_test("-f", pathname_tmp)) {
[10:32:57.401]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.401]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:57.401]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.401]                         fi_tmp[["mtime"]])
[10:32:57.401]                     }
[10:32:57.401]                     tryCatch({
[10:32:57.401]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:57.401]                     }, error = function(ex) {
[10:32:57.401]                       msg <- conditionMessage(ex)
[10:32:57.401]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.401]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:57.401]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.401]                         fi_tmp[["mtime"]], msg)
[10:32:57.401]                       ex$message <- msg
[10:32:57.401]                       stop(ex)
[10:32:57.401]                     })
[10:32:57.401]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:57.401]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:57.401]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:57.401]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.401]                       fi <- file.info(pathname)
[10:32:57.401]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:57.401]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.401]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:57.401]                         fi[["size"]], fi[["mtime"]])
[10:32:57.401]                       stop(msg)
[10:32:57.401]                     }
[10:32:57.401]                     invisible(pathname)
[10:32:57.401]                   }
[10:32:57.401]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:57.401]                     rootPath = tempdir()) 
[10:32:57.401]                   {
[10:32:57.401]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:57.401]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:57.401]                       tmpdir = path, fileext = ".rds")
[10:32:57.401]                     save_rds(obj, file)
[10:32:57.401]                   }
[10:32:57.401]                   saveImmediateCondition(cond, path = "/tmp/RtmpZSnOM5/.future/immediateConditions")
[10:32:57.401]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.401]                   {
[10:32:57.401]                     inherits <- base::inherits
[10:32:57.401]                     invokeRestart <- base::invokeRestart
[10:32:57.401]                     is.null <- base::is.null
[10:32:57.401]                     muffled <- FALSE
[10:32:57.401]                     if (inherits(cond, "message")) {
[10:32:57.401]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:57.401]                       if (muffled) 
[10:32:57.401]                         invokeRestart("muffleMessage")
[10:32:57.401]                     }
[10:32:57.401]                     else if (inherits(cond, "warning")) {
[10:32:57.401]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:57.401]                       if (muffled) 
[10:32:57.401]                         invokeRestart("muffleWarning")
[10:32:57.401]                     }
[10:32:57.401]                     else if (inherits(cond, "condition")) {
[10:32:57.401]                       if (!is.null(pattern)) {
[10:32:57.401]                         computeRestarts <- base::computeRestarts
[10:32:57.401]                         grepl <- base::grepl
[10:32:57.401]                         restarts <- computeRestarts(cond)
[10:32:57.401]                         for (restart in restarts) {
[10:32:57.401]                           name <- restart$name
[10:32:57.401]                           if (is.null(name)) 
[10:32:57.401]                             next
[10:32:57.401]                           if (!grepl(pattern, name)) 
[10:32:57.401]                             next
[10:32:57.401]                           invokeRestart(restart)
[10:32:57.401]                           muffled <- TRUE
[10:32:57.401]                           break
[10:32:57.401]                         }
[10:32:57.401]                       }
[10:32:57.401]                     }
[10:32:57.401]                     invisible(muffled)
[10:32:57.401]                   }
[10:32:57.401]                   muffleCondition(cond)
[10:32:57.401]                 })
[10:32:57.401]             }))
[10:32:57.401]             future::FutureResult(value = ...future.value$value, 
[10:32:57.401]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.401]                   ...future.rng), globalenv = if (FALSE) 
[10:32:57.401]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:57.401]                     ...future.globalenv.names))
[10:32:57.401]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:57.401]         }, condition = base::local({
[10:32:57.401]             c <- base::c
[10:32:57.401]             inherits <- base::inherits
[10:32:57.401]             invokeRestart <- base::invokeRestart
[10:32:57.401]             length <- base::length
[10:32:57.401]             list <- base::list
[10:32:57.401]             seq.int <- base::seq.int
[10:32:57.401]             signalCondition <- base::signalCondition
[10:32:57.401]             sys.calls <- base::sys.calls
[10:32:57.401]             `[[` <- base::`[[`
[10:32:57.401]             `+` <- base::`+`
[10:32:57.401]             `<<-` <- base::`<<-`
[10:32:57.401]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:57.401]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:57.401]                   3L)]
[10:32:57.401]             }
[10:32:57.401]             function(cond) {
[10:32:57.401]                 is_error <- inherits(cond, "error")
[10:32:57.401]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:57.401]                   NULL)
[10:32:57.401]                 if (is_error) {
[10:32:57.401]                   sessionInformation <- function() {
[10:32:57.401]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:57.401]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:57.401]                       search = base::search(), system = base::Sys.info())
[10:32:57.401]                   }
[10:32:57.401]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.401]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:57.401]                     cond$call), session = sessionInformation(), 
[10:32:57.401]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:57.401]                   signalCondition(cond)
[10:32:57.401]                 }
[10:32:57.401]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:57.401]                 "immediateCondition"))) {
[10:32:57.401]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:57.401]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.401]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:57.401]                   if (TRUE && !signal) {
[10:32:57.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.401]                     {
[10:32:57.401]                       inherits <- base::inherits
[10:32:57.401]                       invokeRestart <- base::invokeRestart
[10:32:57.401]                       is.null <- base::is.null
[10:32:57.401]                       muffled <- FALSE
[10:32:57.401]                       if (inherits(cond, "message")) {
[10:32:57.401]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.401]                         if (muffled) 
[10:32:57.401]                           invokeRestart("muffleMessage")
[10:32:57.401]                       }
[10:32:57.401]                       else if (inherits(cond, "warning")) {
[10:32:57.401]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.401]                         if (muffled) 
[10:32:57.401]                           invokeRestart("muffleWarning")
[10:32:57.401]                       }
[10:32:57.401]                       else if (inherits(cond, "condition")) {
[10:32:57.401]                         if (!is.null(pattern)) {
[10:32:57.401]                           computeRestarts <- base::computeRestarts
[10:32:57.401]                           grepl <- base::grepl
[10:32:57.401]                           restarts <- computeRestarts(cond)
[10:32:57.401]                           for (restart in restarts) {
[10:32:57.401]                             name <- restart$name
[10:32:57.401]                             if (is.null(name)) 
[10:32:57.401]                               next
[10:32:57.401]                             if (!grepl(pattern, name)) 
[10:32:57.401]                               next
[10:32:57.401]                             invokeRestart(restart)
[10:32:57.401]                             muffled <- TRUE
[10:32:57.401]                             break
[10:32:57.401]                           }
[10:32:57.401]                         }
[10:32:57.401]                       }
[10:32:57.401]                       invisible(muffled)
[10:32:57.401]                     }
[10:32:57.401]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.401]                   }
[10:32:57.401]                 }
[10:32:57.401]                 else {
[10:32:57.401]                   if (TRUE) {
[10:32:57.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.401]                     {
[10:32:57.401]                       inherits <- base::inherits
[10:32:57.401]                       invokeRestart <- base::invokeRestart
[10:32:57.401]                       is.null <- base::is.null
[10:32:57.401]                       muffled <- FALSE
[10:32:57.401]                       if (inherits(cond, "message")) {
[10:32:57.401]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.401]                         if (muffled) 
[10:32:57.401]                           invokeRestart("muffleMessage")
[10:32:57.401]                       }
[10:32:57.401]                       else if (inherits(cond, "warning")) {
[10:32:57.401]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.401]                         if (muffled) 
[10:32:57.401]                           invokeRestart("muffleWarning")
[10:32:57.401]                       }
[10:32:57.401]                       else if (inherits(cond, "condition")) {
[10:32:57.401]                         if (!is.null(pattern)) {
[10:32:57.401]                           computeRestarts <- base::computeRestarts
[10:32:57.401]                           grepl <- base::grepl
[10:32:57.401]                           restarts <- computeRestarts(cond)
[10:32:57.401]                           for (restart in restarts) {
[10:32:57.401]                             name <- restart$name
[10:32:57.401]                             if (is.null(name)) 
[10:32:57.401]                               next
[10:32:57.401]                             if (!grepl(pattern, name)) 
[10:32:57.401]                               next
[10:32:57.401]                             invokeRestart(restart)
[10:32:57.401]                             muffled <- TRUE
[10:32:57.401]                             break
[10:32:57.401]                           }
[10:32:57.401]                         }
[10:32:57.401]                       }
[10:32:57.401]                       invisible(muffled)
[10:32:57.401]                     }
[10:32:57.401]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.401]                   }
[10:32:57.401]                 }
[10:32:57.401]             }
[10:32:57.401]         }))
[10:32:57.401]     }, error = function(ex) {
[10:32:57.401]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:57.401]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.401]                 ...future.rng), started = ...future.startTime, 
[10:32:57.401]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:57.401]             version = "1.8"), class = "FutureResult")
[10:32:57.401]     }, finally = {
[10:32:57.401]         if (!identical(...future.workdir, getwd())) 
[10:32:57.401]             setwd(...future.workdir)
[10:32:57.401]         {
[10:32:57.401]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:57.401]                 ...future.oldOptions$nwarnings <- NULL
[10:32:57.401]             }
[10:32:57.401]             base::options(...future.oldOptions)
[10:32:57.401]             if (.Platform$OS.type == "windows") {
[10:32:57.401]                 old_names <- names(...future.oldEnvVars)
[10:32:57.401]                 envs <- base::Sys.getenv()
[10:32:57.401]                 names <- names(envs)
[10:32:57.401]                 common <- intersect(names, old_names)
[10:32:57.401]                 added <- setdiff(names, old_names)
[10:32:57.401]                 removed <- setdiff(old_names, names)
[10:32:57.401]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:57.401]                   envs[common]]
[10:32:57.401]                 NAMES <- toupper(changed)
[10:32:57.401]                 args <- list()
[10:32:57.401]                 for (kk in seq_along(NAMES)) {
[10:32:57.401]                   name <- changed[[kk]]
[10:32:57.401]                   NAME <- NAMES[[kk]]
[10:32:57.401]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.401]                     next
[10:32:57.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.401]                 }
[10:32:57.401]                 NAMES <- toupper(added)
[10:32:57.401]                 for (kk in seq_along(NAMES)) {
[10:32:57.401]                   name <- added[[kk]]
[10:32:57.401]                   NAME <- NAMES[[kk]]
[10:32:57.401]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.401]                     next
[10:32:57.401]                   args[[name]] <- ""
[10:32:57.401]                 }
[10:32:57.401]                 NAMES <- toupper(removed)
[10:32:57.401]                 for (kk in seq_along(NAMES)) {
[10:32:57.401]                   name <- removed[[kk]]
[10:32:57.401]                   NAME <- NAMES[[kk]]
[10:32:57.401]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.401]                     next
[10:32:57.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.401]                 }
[10:32:57.401]                 if (length(args) > 0) 
[10:32:57.401]                   base::do.call(base::Sys.setenv, args = args)
[10:32:57.401]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:57.401]             }
[10:32:57.401]             else {
[10:32:57.401]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:57.401]             }
[10:32:57.401]             {
[10:32:57.401]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:57.401]                   0L) {
[10:32:57.401]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:57.401]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:57.401]                   base::options(opts)
[10:32:57.401]                 }
[10:32:57.401]                 {
[10:32:57.401]                   {
[10:32:57.401]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:57.401]                     NULL
[10:32:57.401]                   }
[10:32:57.401]                   options(future.plan = NULL)
[10:32:57.401]                   if (is.na(NA_character_)) 
[10:32:57.401]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.401]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:57.401]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:57.401]                     .init = FALSE)
[10:32:57.401]                 }
[10:32:57.401]             }
[10:32:57.401]         }
[10:32:57.401]     })
[10:32:57.401]     if (TRUE) {
[10:32:57.401]         base::sink(type = "output", split = FALSE)
[10:32:57.401]         if (TRUE) {
[10:32:57.401]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:57.401]         }
[10:32:57.401]         else {
[10:32:57.401]             ...future.result["stdout"] <- base::list(NULL)
[10:32:57.401]         }
[10:32:57.401]         base::close(...future.stdout)
[10:32:57.401]         ...future.stdout <- NULL
[10:32:57.401]     }
[10:32:57.401]     ...future.result$conditions <- ...future.conditions
[10:32:57.401]     ...future.result$finished <- base::Sys.time()
[10:32:57.401]     ...future.result
[10:32:57.401] }
[10:32:57.403] requestCore(): workers = 2
[10:32:57.405] MulticoreFuture started
[10:32:57.405] - Launch lazy future ... done
[10:32:57.405] run() for ‘MulticoreFuture’ ... done
[10:32:57.406] result() for MulticoreFuture ...
[10:32:57.406] plan(): Setting new future strategy stack:
[10:32:57.406] List of future strategies:
[10:32:57.406] 1. sequential:
[10:32:57.406]    - args: function (..., envir = parent.frame())
[10:32:57.406]    - tweaked: FALSE
[10:32:57.406]    - call: NULL
[10:32:57.407] plan(): nbrOfWorkers() = 1
[10:32:57.411] plan(): Setting new future strategy stack:
[10:32:57.411] List of future strategies:
[10:32:57.411] 1. multicore:
[10:32:57.411]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:57.411]    - tweaked: FALSE
[10:32:57.411]    - call: plan(strategy)
[10:32:57.416] plan(): nbrOfWorkers() = 2
[10:32:57.418] result() for MulticoreFuture ...
[10:32:57.418] result() for MulticoreFuture ... done
[10:32:57.418] result() for MulticoreFuture ... done
[10:32:57.418] result() for MulticoreFuture ...
[10:32:57.419] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[10:32:57.422] getGlobalsAndPackages() ...
[10:32:57.422] Searching for globals...
[10:32:57.424] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[10:32:57.424] Searching for globals ... DONE
[10:32:57.424] Resolving globals: FALSE
[10:32:57.425] 
[10:32:57.425] - packages: [2] ‘stats’, ‘datasets’
[10:32:57.425] getGlobalsAndPackages() ... DONE
[10:32:57.426] run() for ‘Future’ ...
[10:32:57.426] - state: ‘created’
[10:32:57.426] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:57.430] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:57.430] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:57.430]   - Field: ‘label’
[10:32:57.430]   - Field: ‘local’
[10:32:57.431]   - Field: ‘owner’
[10:32:57.431]   - Field: ‘envir’
[10:32:57.431]   - Field: ‘workers’
[10:32:57.431]   - Field: ‘packages’
[10:32:57.431]   - Field: ‘gc’
[10:32:57.431]   - Field: ‘job’
[10:32:57.431]   - Field: ‘conditions’
[10:32:57.431]   - Field: ‘expr’
[10:32:57.431]   - Field: ‘uuid’
[10:32:57.464]   - Field: ‘seed’
[10:32:57.465]   - Field: ‘version’
[10:32:57.465]   - Field: ‘result’
[10:32:57.465]   - Field: ‘asynchronous’
[10:32:57.465]   - Field: ‘calls’
[10:32:57.465]   - Field: ‘globals’
[10:32:57.465]   - Field: ‘stdout’
[10:32:57.465]   - Field: ‘earlySignal’
[10:32:57.465]   - Field: ‘lazy’
[10:32:57.465]   - Field: ‘state’
[10:32:57.466] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:57.466] - Launch lazy future ...
[10:32:57.466] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:32:57.466] Packages needed by future strategies (n = 0): <none>
[10:32:57.467] {
[10:32:57.467]     {
[10:32:57.467]         {
[10:32:57.467]             ...future.startTime <- base::Sys.time()
[10:32:57.467]             {
[10:32:57.467]                 {
[10:32:57.467]                   {
[10:32:57.467]                     {
[10:32:57.467]                       {
[10:32:57.467]                         base::local({
[10:32:57.467]                           has_future <- base::requireNamespace("future", 
[10:32:57.467]                             quietly = TRUE)
[10:32:57.467]                           if (has_future) {
[10:32:57.467]                             ns <- base::getNamespace("future")
[10:32:57.467]                             version <- ns[[".package"]][["version"]]
[10:32:57.467]                             if (is.null(version)) 
[10:32:57.467]                               version <- utils::packageVersion("future")
[10:32:57.467]                           }
[10:32:57.467]                           else {
[10:32:57.467]                             version <- NULL
[10:32:57.467]                           }
[10:32:57.467]                           if (!has_future || version < "1.8.0") {
[10:32:57.467]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:57.467]                               "", base::R.version$version.string), 
[10:32:57.467]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:57.467]                                 base::R.version$platform, 8 * 
[10:32:57.467]                                   base::.Machine$sizeof.pointer), 
[10:32:57.467]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:57.467]                                 "release", "version")], collapse = " "), 
[10:32:57.467]                               hostname = base::Sys.info()[["nodename"]])
[10:32:57.467]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:57.467]                               info)
[10:32:57.467]                             info <- base::paste(info, collapse = "; ")
[10:32:57.467]                             if (!has_future) {
[10:32:57.467]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:57.467]                                 info)
[10:32:57.467]                             }
[10:32:57.467]                             else {
[10:32:57.467]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:57.467]                                 info, version)
[10:32:57.467]                             }
[10:32:57.467]                             base::stop(msg)
[10:32:57.467]                           }
[10:32:57.467]                         })
[10:32:57.467]                       }
[10:32:57.467]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:57.467]                       base::options(mc.cores = 1L)
[10:32:57.467]                     }
[10:32:57.467]                     base::local({
[10:32:57.467]                       for (pkg in c("stats", "datasets")) {
[10:32:57.467]                         base::loadNamespace(pkg)
[10:32:57.467]                         base::library(pkg, character.only = TRUE)
[10:32:57.467]                       }
[10:32:57.467]                     })
[10:32:57.467]                   }
[10:32:57.467]                   ...future.strategy.old <- future::plan("list")
[10:32:57.467]                   options(future.plan = NULL)
[10:32:57.467]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.467]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:57.467]                 }
[10:32:57.467]                 ...future.workdir <- getwd()
[10:32:57.467]             }
[10:32:57.467]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:57.467]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:57.467]         }
[10:32:57.467]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:57.467]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:57.467]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:57.467]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:57.467]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:57.467]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:57.467]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:57.467]             base::names(...future.oldOptions))
[10:32:57.467]     }
[10:32:57.467]     if (FALSE) {
[10:32:57.467]     }
[10:32:57.467]     else {
[10:32:57.467]         if (TRUE) {
[10:32:57.467]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:57.467]                 open = "w")
[10:32:57.467]         }
[10:32:57.467]         else {
[10:32:57.467]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:57.467]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:57.467]         }
[10:32:57.467]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:57.467]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:57.467]             base::sink(type = "output", split = FALSE)
[10:32:57.467]             base::close(...future.stdout)
[10:32:57.467]         }, add = TRUE)
[10:32:57.467]     }
[10:32:57.467]     ...future.frame <- base::sys.nframe()
[10:32:57.467]     ...future.conditions <- base::list()
[10:32:57.467]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:57.467]     if (FALSE) {
[10:32:57.467]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:57.467]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:57.467]     }
[10:32:57.467]     ...future.result <- base::tryCatch({
[10:32:57.467]         base::withCallingHandlers({
[10:32:57.467]             ...future.value <- base::withVisible(base::local({
[10:32:57.467]                 withCallingHandlers({
[10:32:57.467]                   {
[10:32:57.467]                     lm(dist ~ . + 0, data = cars)
[10:32:57.467]                   }
[10:32:57.467]                 }, immediateCondition = function(cond) {
[10:32:57.467]                   save_rds <- function (object, pathname, ...) 
[10:32:57.467]                   {
[10:32:57.467]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:57.467]                     if (file_test("-f", pathname_tmp)) {
[10:32:57.467]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.467]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:57.467]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.467]                         fi_tmp[["mtime"]])
[10:32:57.467]                     }
[10:32:57.467]                     tryCatch({
[10:32:57.467]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:57.467]                     }, error = function(ex) {
[10:32:57.467]                       msg <- conditionMessage(ex)
[10:32:57.467]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.467]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:57.467]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.467]                         fi_tmp[["mtime"]], msg)
[10:32:57.467]                       ex$message <- msg
[10:32:57.467]                       stop(ex)
[10:32:57.467]                     })
[10:32:57.467]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:57.467]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:57.467]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:57.467]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.467]                       fi <- file.info(pathname)
[10:32:57.467]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:57.467]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.467]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:57.467]                         fi[["size"]], fi[["mtime"]])
[10:32:57.467]                       stop(msg)
[10:32:57.467]                     }
[10:32:57.467]                     invisible(pathname)
[10:32:57.467]                   }
[10:32:57.467]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:57.467]                     rootPath = tempdir()) 
[10:32:57.467]                   {
[10:32:57.467]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:57.467]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:57.467]                       tmpdir = path, fileext = ".rds")
[10:32:57.467]                     save_rds(obj, file)
[10:32:57.467]                   }
[10:32:57.467]                   saveImmediateCondition(cond, path = "/tmp/RtmpZSnOM5/.future/immediateConditions")
[10:32:57.467]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.467]                   {
[10:32:57.467]                     inherits <- base::inherits
[10:32:57.467]                     invokeRestart <- base::invokeRestart
[10:32:57.467]                     is.null <- base::is.null
[10:32:57.467]                     muffled <- FALSE
[10:32:57.467]                     if (inherits(cond, "message")) {
[10:32:57.467]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:57.467]                       if (muffled) 
[10:32:57.467]                         invokeRestart("muffleMessage")
[10:32:57.467]                     }
[10:32:57.467]                     else if (inherits(cond, "warning")) {
[10:32:57.467]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:57.467]                       if (muffled) 
[10:32:57.467]                         invokeRestart("muffleWarning")
[10:32:57.467]                     }
[10:32:57.467]                     else if (inherits(cond, "condition")) {
[10:32:57.467]                       if (!is.null(pattern)) {
[10:32:57.467]                         computeRestarts <- base::computeRestarts
[10:32:57.467]                         grepl <- base::grepl
[10:32:57.467]                         restarts <- computeRestarts(cond)
[10:32:57.467]                         for (restart in restarts) {
[10:32:57.467]                           name <- restart$name
[10:32:57.467]                           if (is.null(name)) 
[10:32:57.467]                             next
[10:32:57.467]                           if (!grepl(pattern, name)) 
[10:32:57.467]                             next
[10:32:57.467]                           invokeRestart(restart)
[10:32:57.467]                           muffled <- TRUE
[10:32:57.467]                           break
[10:32:57.467]                         }
[10:32:57.467]                       }
[10:32:57.467]                     }
[10:32:57.467]                     invisible(muffled)
[10:32:57.467]                   }
[10:32:57.467]                   muffleCondition(cond)
[10:32:57.467]                 })
[10:32:57.467]             }))
[10:32:57.467]             future::FutureResult(value = ...future.value$value, 
[10:32:57.467]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.467]                   ...future.rng), globalenv = if (FALSE) 
[10:32:57.467]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:57.467]                     ...future.globalenv.names))
[10:32:57.467]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:57.467]         }, condition = base::local({
[10:32:57.467]             c <- base::c
[10:32:57.467]             inherits <- base::inherits
[10:32:57.467]             invokeRestart <- base::invokeRestart
[10:32:57.467]             length <- base::length
[10:32:57.467]             list <- base::list
[10:32:57.467]             seq.int <- base::seq.int
[10:32:57.467]             signalCondition <- base::signalCondition
[10:32:57.467]             sys.calls <- base::sys.calls
[10:32:57.467]             `[[` <- base::`[[`
[10:32:57.467]             `+` <- base::`+`
[10:32:57.467]             `<<-` <- base::`<<-`
[10:32:57.467]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:57.467]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:57.467]                   3L)]
[10:32:57.467]             }
[10:32:57.467]             function(cond) {
[10:32:57.467]                 is_error <- inherits(cond, "error")
[10:32:57.467]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:57.467]                   NULL)
[10:32:57.467]                 if (is_error) {
[10:32:57.467]                   sessionInformation <- function() {
[10:32:57.467]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:57.467]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:57.467]                       search = base::search(), system = base::Sys.info())
[10:32:57.467]                   }
[10:32:57.467]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.467]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:57.467]                     cond$call), session = sessionInformation(), 
[10:32:57.467]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:57.467]                   signalCondition(cond)
[10:32:57.467]                 }
[10:32:57.467]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:57.467]                 "immediateCondition"))) {
[10:32:57.467]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:57.467]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.467]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:57.467]                   if (TRUE && !signal) {
[10:32:57.467]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.467]                     {
[10:32:57.467]                       inherits <- base::inherits
[10:32:57.467]                       invokeRestart <- base::invokeRestart
[10:32:57.467]                       is.null <- base::is.null
[10:32:57.467]                       muffled <- FALSE
[10:32:57.467]                       if (inherits(cond, "message")) {
[10:32:57.467]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.467]                         if (muffled) 
[10:32:57.467]                           invokeRestart("muffleMessage")
[10:32:57.467]                       }
[10:32:57.467]                       else if (inherits(cond, "warning")) {
[10:32:57.467]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.467]                         if (muffled) 
[10:32:57.467]                           invokeRestart("muffleWarning")
[10:32:57.467]                       }
[10:32:57.467]                       else if (inherits(cond, "condition")) {
[10:32:57.467]                         if (!is.null(pattern)) {
[10:32:57.467]                           computeRestarts <- base::computeRestarts
[10:32:57.467]                           grepl <- base::grepl
[10:32:57.467]                           restarts <- computeRestarts(cond)
[10:32:57.467]                           for (restart in restarts) {
[10:32:57.467]                             name <- restart$name
[10:32:57.467]                             if (is.null(name)) 
[10:32:57.467]                               next
[10:32:57.467]                             if (!grepl(pattern, name)) 
[10:32:57.467]                               next
[10:32:57.467]                             invokeRestart(restart)
[10:32:57.467]                             muffled <- TRUE
[10:32:57.467]                             break
[10:32:57.467]                           }
[10:32:57.467]                         }
[10:32:57.467]                       }
[10:32:57.467]                       invisible(muffled)
[10:32:57.467]                     }
[10:32:57.467]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.467]                   }
[10:32:57.467]                 }
[10:32:57.467]                 else {
[10:32:57.467]                   if (TRUE) {
[10:32:57.467]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.467]                     {
[10:32:57.467]                       inherits <- base::inherits
[10:32:57.467]                       invokeRestart <- base::invokeRestart
[10:32:57.467]                       is.null <- base::is.null
[10:32:57.467]                       muffled <- FALSE
[10:32:57.467]                       if (inherits(cond, "message")) {
[10:32:57.467]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.467]                         if (muffled) 
[10:32:57.467]                           invokeRestart("muffleMessage")
[10:32:57.467]                       }
[10:32:57.467]                       else if (inherits(cond, "warning")) {
[10:32:57.467]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.467]                         if (muffled) 
[10:32:57.467]                           invokeRestart("muffleWarning")
[10:32:57.467]                       }
[10:32:57.467]                       else if (inherits(cond, "condition")) {
[10:32:57.467]                         if (!is.null(pattern)) {
[10:32:57.467]                           computeRestarts <- base::computeRestarts
[10:32:57.467]                           grepl <- base::grepl
[10:32:57.467]                           restarts <- computeRestarts(cond)
[10:32:57.467]                           for (restart in restarts) {
[10:32:57.467]                             name <- restart$name
[10:32:57.467]                             if (is.null(name)) 
[10:32:57.467]                               next
[10:32:57.467]                             if (!grepl(pattern, name)) 
[10:32:57.467]                               next
[10:32:57.467]                             invokeRestart(restart)
[10:32:57.467]                             muffled <- TRUE
[10:32:57.467]                             break
[10:32:57.467]                           }
[10:32:57.467]                         }
[10:32:57.467]                       }
[10:32:57.467]                       invisible(muffled)
[10:32:57.467]                     }
[10:32:57.467]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.467]                   }
[10:32:57.467]                 }
[10:32:57.467]             }
[10:32:57.467]         }))
[10:32:57.467]     }, error = function(ex) {
[10:32:57.467]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:57.467]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.467]                 ...future.rng), started = ...future.startTime, 
[10:32:57.467]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:57.467]             version = "1.8"), class = "FutureResult")
[10:32:57.467]     }, finally = {
[10:32:57.467]         if (!identical(...future.workdir, getwd())) 
[10:32:57.467]             setwd(...future.workdir)
[10:32:57.467]         {
[10:32:57.467]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:57.467]                 ...future.oldOptions$nwarnings <- NULL
[10:32:57.467]             }
[10:32:57.467]             base::options(...future.oldOptions)
[10:32:57.467]             if (.Platform$OS.type == "windows") {
[10:32:57.467]                 old_names <- names(...future.oldEnvVars)
[10:32:57.467]                 envs <- base::Sys.getenv()
[10:32:57.467]                 names <- names(envs)
[10:32:57.467]                 common <- intersect(names, old_names)
[10:32:57.467]                 added <- setdiff(names, old_names)
[10:32:57.467]                 removed <- setdiff(old_names, names)
[10:32:57.467]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:57.467]                   envs[common]]
[10:32:57.467]                 NAMES <- toupper(changed)
[10:32:57.467]                 args <- list()
[10:32:57.467]                 for (kk in seq_along(NAMES)) {
[10:32:57.467]                   name <- changed[[kk]]
[10:32:57.467]                   NAME <- NAMES[[kk]]
[10:32:57.467]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.467]                     next
[10:32:57.467]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.467]                 }
[10:32:57.467]                 NAMES <- toupper(added)
[10:32:57.467]                 for (kk in seq_along(NAMES)) {
[10:32:57.467]                   name <- added[[kk]]
[10:32:57.467]                   NAME <- NAMES[[kk]]
[10:32:57.467]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.467]                     next
[10:32:57.467]                   args[[name]] <- ""
[10:32:57.467]                 }
[10:32:57.467]                 NAMES <- toupper(removed)
[10:32:57.467]                 for (kk in seq_along(NAMES)) {
[10:32:57.467]                   name <- removed[[kk]]
[10:32:57.467]                   NAME <- NAMES[[kk]]
[10:32:57.467]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.467]                     next
[10:32:57.467]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.467]                 }
[10:32:57.467]                 if (length(args) > 0) 
[10:32:57.467]                   base::do.call(base::Sys.setenv, args = args)
[10:32:57.467]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:57.467]             }
[10:32:57.467]             else {
[10:32:57.467]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:57.467]             }
[10:32:57.467]             {
[10:32:57.467]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:57.467]                   0L) {
[10:32:57.467]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:57.467]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:57.467]                   base::options(opts)
[10:32:57.467]                 }
[10:32:57.467]                 {
[10:32:57.467]                   {
[10:32:57.467]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:57.467]                     NULL
[10:32:57.467]                   }
[10:32:57.467]                   options(future.plan = NULL)
[10:32:57.467]                   if (is.na(NA_character_)) 
[10:32:57.467]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.467]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:57.467]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:57.467]                     .init = FALSE)
[10:32:57.467]                 }
[10:32:57.467]             }
[10:32:57.467]         }
[10:32:57.467]     })
[10:32:57.467]     if (TRUE) {
[10:32:57.467]         base::sink(type = "output", split = FALSE)
[10:32:57.467]         if (TRUE) {
[10:32:57.467]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:57.467]         }
[10:32:57.467]         else {
[10:32:57.467]             ...future.result["stdout"] <- base::list(NULL)
[10:32:57.467]         }
[10:32:57.467]         base::close(...future.stdout)
[10:32:57.467]         ...future.stdout <- NULL
[10:32:57.467]     }
[10:32:57.467]     ...future.result$conditions <- ...future.conditions
[10:32:57.467]     ...future.result$finished <- base::Sys.time()
[10:32:57.467]     ...future.result
[10:32:57.467] }
[10:32:57.469] requestCore(): workers = 2
[10:32:57.471] MulticoreFuture started
[10:32:57.472] - Launch lazy future ... done
[10:32:57.472] run() for ‘MulticoreFuture’ ... done
[10:32:57.473] result() for MulticoreFuture ...
[10:32:57.473] plan(): Setting new future strategy stack:
[10:32:57.473] List of future strategies:
[10:32:57.473] 1. sequential:
[10:32:57.473]    - args: function (..., envir = parent.frame())
[10:32:57.473]    - tweaked: FALSE
[10:32:57.473]    - call: NULL
[10:32:57.474] plan(): nbrOfWorkers() = 1
[10:32:57.479] plan(): Setting new future strategy stack:
[10:32:57.479] List of future strategies:
[10:32:57.479] 1. multicore:
[10:32:57.479]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:57.479]    - tweaked: FALSE
[10:32:57.479]    - call: plan(strategy)
[10:32:57.484] plan(): nbrOfWorkers() = 2
[10:32:57.487] result() for MulticoreFuture ...
[10:32:57.487] result() for MulticoreFuture ... done
[10:32:57.487] result() for MulticoreFuture ... done
[10:32:57.487] result() for MulticoreFuture ...
[10:32:57.487] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[10:32:57.491] getGlobalsAndPackages() ...
[10:32:57.491] Searching for globals...
[10:32:57.494] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[10:32:57.494] Searching for globals ... DONE
[10:32:57.494] Resolving globals: FALSE
[10:32:57.495] 
[10:32:57.495] - packages: [2] ‘stats’, ‘datasets’
[10:32:57.495] getGlobalsAndPackages() ... DONE
[10:32:57.495] run() for ‘Future’ ...
[10:32:57.495] - state: ‘created’
[10:32:57.496] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:57.499] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:57.500] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:57.500]   - Field: ‘label’
[10:32:57.500]   - Field: ‘local’
[10:32:57.500]   - Field: ‘owner’
[10:32:57.500]   - Field: ‘envir’
[10:32:57.500]   - Field: ‘workers’
[10:32:57.500]   - Field: ‘packages’
[10:32:57.501]   - Field: ‘gc’
[10:32:57.501]   - Field: ‘job’
[10:32:57.501]   - Field: ‘conditions’
[10:32:57.501]   - Field: ‘expr’
[10:32:57.501]   - Field: ‘uuid’
[10:32:57.501]   - Field: ‘seed’
[10:32:57.501]   - Field: ‘version’
[10:32:57.501]   - Field: ‘result’
[10:32:57.501]   - Field: ‘asynchronous’
[10:32:57.502]   - Field: ‘calls’
[10:32:57.502]   - Field: ‘globals’
[10:32:57.502]   - Field: ‘stdout’
[10:32:57.502]   - Field: ‘earlySignal’
[10:32:57.502]   - Field: ‘lazy’
[10:32:57.502]   - Field: ‘state’
[10:32:57.502] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:57.502] - Launch lazy future ...
[10:32:57.503] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:32:57.503] Packages needed by future strategies (n = 0): <none>
[10:32:57.503] {
[10:32:57.503]     {
[10:32:57.503]         {
[10:32:57.503]             ...future.startTime <- base::Sys.time()
[10:32:57.503]             {
[10:32:57.503]                 {
[10:32:57.503]                   {
[10:32:57.503]                     {
[10:32:57.503]                       {
[10:32:57.503]                         base::local({
[10:32:57.503]                           has_future <- base::requireNamespace("future", 
[10:32:57.503]                             quietly = TRUE)
[10:32:57.503]                           if (has_future) {
[10:32:57.503]                             ns <- base::getNamespace("future")
[10:32:57.503]                             version <- ns[[".package"]][["version"]]
[10:32:57.503]                             if (is.null(version)) 
[10:32:57.503]                               version <- utils::packageVersion("future")
[10:32:57.503]                           }
[10:32:57.503]                           else {
[10:32:57.503]                             version <- NULL
[10:32:57.503]                           }
[10:32:57.503]                           if (!has_future || version < "1.8.0") {
[10:32:57.503]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:57.503]                               "", base::R.version$version.string), 
[10:32:57.503]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:57.503]                                 base::R.version$platform, 8 * 
[10:32:57.503]                                   base::.Machine$sizeof.pointer), 
[10:32:57.503]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:57.503]                                 "release", "version")], collapse = " "), 
[10:32:57.503]                               hostname = base::Sys.info()[["nodename"]])
[10:32:57.503]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:57.503]                               info)
[10:32:57.503]                             info <- base::paste(info, collapse = "; ")
[10:32:57.503]                             if (!has_future) {
[10:32:57.503]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:57.503]                                 info)
[10:32:57.503]                             }
[10:32:57.503]                             else {
[10:32:57.503]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:57.503]                                 info, version)
[10:32:57.503]                             }
[10:32:57.503]                             base::stop(msg)
[10:32:57.503]                           }
[10:32:57.503]                         })
[10:32:57.503]                       }
[10:32:57.503]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:57.503]                       base::options(mc.cores = 1L)
[10:32:57.503]                     }
[10:32:57.503]                     base::local({
[10:32:57.503]                       for (pkg in c("stats", "datasets")) {
[10:32:57.503]                         base::loadNamespace(pkg)
[10:32:57.503]                         base::library(pkg, character.only = TRUE)
[10:32:57.503]                       }
[10:32:57.503]                     })
[10:32:57.503]                   }
[10:32:57.503]                   ...future.strategy.old <- future::plan("list")
[10:32:57.503]                   options(future.plan = NULL)
[10:32:57.503]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.503]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:57.503]                 }
[10:32:57.503]                 ...future.workdir <- getwd()
[10:32:57.503]             }
[10:32:57.503]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:57.503]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:57.503]         }
[10:32:57.503]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:57.503]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:57.503]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:57.503]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:57.503]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:57.503]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:57.503]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:57.503]             base::names(...future.oldOptions))
[10:32:57.503]     }
[10:32:57.503]     if (FALSE) {
[10:32:57.503]     }
[10:32:57.503]     else {
[10:32:57.503]         if (TRUE) {
[10:32:57.503]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:57.503]                 open = "w")
[10:32:57.503]         }
[10:32:57.503]         else {
[10:32:57.503]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:57.503]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:57.503]         }
[10:32:57.503]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:57.503]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:57.503]             base::sink(type = "output", split = FALSE)
[10:32:57.503]             base::close(...future.stdout)
[10:32:57.503]         }, add = TRUE)
[10:32:57.503]     }
[10:32:57.503]     ...future.frame <- base::sys.nframe()
[10:32:57.503]     ...future.conditions <- base::list()
[10:32:57.503]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:57.503]     if (FALSE) {
[10:32:57.503]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:57.503]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:57.503]     }
[10:32:57.503]     ...future.result <- base::tryCatch({
[10:32:57.503]         base::withCallingHandlers({
[10:32:57.503]             ...future.value <- base::withVisible(base::local({
[10:32:57.503]                 withCallingHandlers({
[10:32:57.503]                   {
[10:32:57.503]                     lm(dist ~ speed + speed^2, data = cars)
[10:32:57.503]                   }
[10:32:57.503]                 }, immediateCondition = function(cond) {
[10:32:57.503]                   save_rds <- function (object, pathname, ...) 
[10:32:57.503]                   {
[10:32:57.503]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:57.503]                     if (file_test("-f", pathname_tmp)) {
[10:32:57.503]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.503]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:57.503]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.503]                         fi_tmp[["mtime"]])
[10:32:57.503]                     }
[10:32:57.503]                     tryCatch({
[10:32:57.503]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:57.503]                     }, error = function(ex) {
[10:32:57.503]                       msg <- conditionMessage(ex)
[10:32:57.503]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.503]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:57.503]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.503]                         fi_tmp[["mtime"]], msg)
[10:32:57.503]                       ex$message <- msg
[10:32:57.503]                       stop(ex)
[10:32:57.503]                     })
[10:32:57.503]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:57.503]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:57.503]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:57.503]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.503]                       fi <- file.info(pathname)
[10:32:57.503]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:57.503]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.503]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:57.503]                         fi[["size"]], fi[["mtime"]])
[10:32:57.503]                       stop(msg)
[10:32:57.503]                     }
[10:32:57.503]                     invisible(pathname)
[10:32:57.503]                   }
[10:32:57.503]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:57.503]                     rootPath = tempdir()) 
[10:32:57.503]                   {
[10:32:57.503]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:57.503]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:57.503]                       tmpdir = path, fileext = ".rds")
[10:32:57.503]                     save_rds(obj, file)
[10:32:57.503]                   }
[10:32:57.503]                   saveImmediateCondition(cond, path = "/tmp/RtmpZSnOM5/.future/immediateConditions")
[10:32:57.503]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.503]                   {
[10:32:57.503]                     inherits <- base::inherits
[10:32:57.503]                     invokeRestart <- base::invokeRestart
[10:32:57.503]                     is.null <- base::is.null
[10:32:57.503]                     muffled <- FALSE
[10:32:57.503]                     if (inherits(cond, "message")) {
[10:32:57.503]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:57.503]                       if (muffled) 
[10:32:57.503]                         invokeRestart("muffleMessage")
[10:32:57.503]                     }
[10:32:57.503]                     else if (inherits(cond, "warning")) {
[10:32:57.503]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:57.503]                       if (muffled) 
[10:32:57.503]                         invokeRestart("muffleWarning")
[10:32:57.503]                     }
[10:32:57.503]                     else if (inherits(cond, "condition")) {
[10:32:57.503]                       if (!is.null(pattern)) {
[10:32:57.503]                         computeRestarts <- base::computeRestarts
[10:32:57.503]                         grepl <- base::grepl
[10:32:57.503]                         restarts <- computeRestarts(cond)
[10:32:57.503]                         for (restart in restarts) {
[10:32:57.503]                           name <- restart$name
[10:32:57.503]                           if (is.null(name)) 
[10:32:57.503]                             next
[10:32:57.503]                           if (!grepl(pattern, name)) 
[10:32:57.503]                             next
[10:32:57.503]                           invokeRestart(restart)
[10:32:57.503]                           muffled <- TRUE
[10:32:57.503]                           break
[10:32:57.503]                         }
[10:32:57.503]                       }
[10:32:57.503]                     }
[10:32:57.503]                     invisible(muffled)
[10:32:57.503]                   }
[10:32:57.503]                   muffleCondition(cond)
[10:32:57.503]                 })
[10:32:57.503]             }))
[10:32:57.503]             future::FutureResult(value = ...future.value$value, 
[10:32:57.503]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.503]                   ...future.rng), globalenv = if (FALSE) 
[10:32:57.503]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:57.503]                     ...future.globalenv.names))
[10:32:57.503]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:57.503]         }, condition = base::local({
[10:32:57.503]             c <- base::c
[10:32:57.503]             inherits <- base::inherits
[10:32:57.503]             invokeRestart <- base::invokeRestart
[10:32:57.503]             length <- base::length
[10:32:57.503]             list <- base::list
[10:32:57.503]             seq.int <- base::seq.int
[10:32:57.503]             signalCondition <- base::signalCondition
[10:32:57.503]             sys.calls <- base::sys.calls
[10:32:57.503]             `[[` <- base::`[[`
[10:32:57.503]             `+` <- base::`+`
[10:32:57.503]             `<<-` <- base::`<<-`
[10:32:57.503]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:57.503]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:57.503]                   3L)]
[10:32:57.503]             }
[10:32:57.503]             function(cond) {
[10:32:57.503]                 is_error <- inherits(cond, "error")
[10:32:57.503]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:57.503]                   NULL)
[10:32:57.503]                 if (is_error) {
[10:32:57.503]                   sessionInformation <- function() {
[10:32:57.503]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:57.503]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:57.503]                       search = base::search(), system = base::Sys.info())
[10:32:57.503]                   }
[10:32:57.503]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.503]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:57.503]                     cond$call), session = sessionInformation(), 
[10:32:57.503]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:57.503]                   signalCondition(cond)
[10:32:57.503]                 }
[10:32:57.503]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:57.503]                 "immediateCondition"))) {
[10:32:57.503]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:57.503]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.503]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:57.503]                   if (TRUE && !signal) {
[10:32:57.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.503]                     {
[10:32:57.503]                       inherits <- base::inherits
[10:32:57.503]                       invokeRestart <- base::invokeRestart
[10:32:57.503]                       is.null <- base::is.null
[10:32:57.503]                       muffled <- FALSE
[10:32:57.503]                       if (inherits(cond, "message")) {
[10:32:57.503]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.503]                         if (muffled) 
[10:32:57.503]                           invokeRestart("muffleMessage")
[10:32:57.503]                       }
[10:32:57.503]                       else if (inherits(cond, "warning")) {
[10:32:57.503]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.503]                         if (muffled) 
[10:32:57.503]                           invokeRestart("muffleWarning")
[10:32:57.503]                       }
[10:32:57.503]                       else if (inherits(cond, "condition")) {
[10:32:57.503]                         if (!is.null(pattern)) {
[10:32:57.503]                           computeRestarts <- base::computeRestarts
[10:32:57.503]                           grepl <- base::grepl
[10:32:57.503]                           restarts <- computeRestarts(cond)
[10:32:57.503]                           for (restart in restarts) {
[10:32:57.503]                             name <- restart$name
[10:32:57.503]                             if (is.null(name)) 
[10:32:57.503]                               next
[10:32:57.503]                             if (!grepl(pattern, name)) 
[10:32:57.503]                               next
[10:32:57.503]                             invokeRestart(restart)
[10:32:57.503]                             muffled <- TRUE
[10:32:57.503]                             break
[10:32:57.503]                           }
[10:32:57.503]                         }
[10:32:57.503]                       }
[10:32:57.503]                       invisible(muffled)
[10:32:57.503]                     }
[10:32:57.503]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.503]                   }
[10:32:57.503]                 }
[10:32:57.503]                 else {
[10:32:57.503]                   if (TRUE) {
[10:32:57.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.503]                     {
[10:32:57.503]                       inherits <- base::inherits
[10:32:57.503]                       invokeRestart <- base::invokeRestart
[10:32:57.503]                       is.null <- base::is.null
[10:32:57.503]                       muffled <- FALSE
[10:32:57.503]                       if (inherits(cond, "message")) {
[10:32:57.503]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.503]                         if (muffled) 
[10:32:57.503]                           invokeRestart("muffleMessage")
[10:32:57.503]                       }
[10:32:57.503]                       else if (inherits(cond, "warning")) {
[10:32:57.503]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.503]                         if (muffled) 
[10:32:57.503]                           invokeRestart("muffleWarning")
[10:32:57.503]                       }
[10:32:57.503]                       else if (inherits(cond, "condition")) {
[10:32:57.503]                         if (!is.null(pattern)) {
[10:32:57.503]                           computeRestarts <- base::computeRestarts
[10:32:57.503]                           grepl <- base::grepl
[10:32:57.503]                           restarts <- computeRestarts(cond)
[10:32:57.503]                           for (restart in restarts) {
[10:32:57.503]                             name <- restart$name
[10:32:57.503]                             if (is.null(name)) 
[10:32:57.503]                               next
[10:32:57.503]                             if (!grepl(pattern, name)) 
[10:32:57.503]                               next
[10:32:57.503]                             invokeRestart(restart)
[10:32:57.503]                             muffled <- TRUE
[10:32:57.503]                             break
[10:32:57.503]                           }
[10:32:57.503]                         }
[10:32:57.503]                       }
[10:32:57.503]                       invisible(muffled)
[10:32:57.503]                     }
[10:32:57.503]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.503]                   }
[10:32:57.503]                 }
[10:32:57.503]             }
[10:32:57.503]         }))
[10:32:57.503]     }, error = function(ex) {
[10:32:57.503]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:57.503]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.503]                 ...future.rng), started = ...future.startTime, 
[10:32:57.503]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:57.503]             version = "1.8"), class = "FutureResult")
[10:32:57.503]     }, finally = {
[10:32:57.503]         if (!identical(...future.workdir, getwd())) 
[10:32:57.503]             setwd(...future.workdir)
[10:32:57.503]         {
[10:32:57.503]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:57.503]                 ...future.oldOptions$nwarnings <- NULL
[10:32:57.503]             }
[10:32:57.503]             base::options(...future.oldOptions)
[10:32:57.503]             if (.Platform$OS.type == "windows") {
[10:32:57.503]                 old_names <- names(...future.oldEnvVars)
[10:32:57.503]                 envs <- base::Sys.getenv()
[10:32:57.503]                 names <- names(envs)
[10:32:57.503]                 common <- intersect(names, old_names)
[10:32:57.503]                 added <- setdiff(names, old_names)
[10:32:57.503]                 removed <- setdiff(old_names, names)
[10:32:57.503]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:57.503]                   envs[common]]
[10:32:57.503]                 NAMES <- toupper(changed)
[10:32:57.503]                 args <- list()
[10:32:57.503]                 for (kk in seq_along(NAMES)) {
[10:32:57.503]                   name <- changed[[kk]]
[10:32:57.503]                   NAME <- NAMES[[kk]]
[10:32:57.503]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.503]                     next
[10:32:57.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.503]                 }
[10:32:57.503]                 NAMES <- toupper(added)
[10:32:57.503]                 for (kk in seq_along(NAMES)) {
[10:32:57.503]                   name <- added[[kk]]
[10:32:57.503]                   NAME <- NAMES[[kk]]
[10:32:57.503]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.503]                     next
[10:32:57.503]                   args[[name]] <- ""
[10:32:57.503]                 }
[10:32:57.503]                 NAMES <- toupper(removed)
[10:32:57.503]                 for (kk in seq_along(NAMES)) {
[10:32:57.503]                   name <- removed[[kk]]
[10:32:57.503]                   NAME <- NAMES[[kk]]
[10:32:57.503]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.503]                     next
[10:32:57.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.503]                 }
[10:32:57.503]                 if (length(args) > 0) 
[10:32:57.503]                   base::do.call(base::Sys.setenv, args = args)
[10:32:57.503]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:57.503]             }
[10:32:57.503]             else {
[10:32:57.503]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:57.503]             }
[10:32:57.503]             {
[10:32:57.503]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:57.503]                   0L) {
[10:32:57.503]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:57.503]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:57.503]                   base::options(opts)
[10:32:57.503]                 }
[10:32:57.503]                 {
[10:32:57.503]                   {
[10:32:57.503]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:57.503]                     NULL
[10:32:57.503]                   }
[10:32:57.503]                   options(future.plan = NULL)
[10:32:57.503]                   if (is.na(NA_character_)) 
[10:32:57.503]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.503]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:57.503]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:57.503]                     .init = FALSE)
[10:32:57.503]                 }
[10:32:57.503]             }
[10:32:57.503]         }
[10:32:57.503]     })
[10:32:57.503]     if (TRUE) {
[10:32:57.503]         base::sink(type = "output", split = FALSE)
[10:32:57.503]         if (TRUE) {
[10:32:57.503]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:57.503]         }
[10:32:57.503]         else {
[10:32:57.503]             ...future.result["stdout"] <- base::list(NULL)
[10:32:57.503]         }
[10:32:57.503]         base::close(...future.stdout)
[10:32:57.503]         ...future.stdout <- NULL
[10:32:57.503]     }
[10:32:57.503]     ...future.result$conditions <- ...future.conditions
[10:32:57.503]     ...future.result$finished <- base::Sys.time()
[10:32:57.503]     ...future.result
[10:32:57.503] }
[10:32:57.506] requestCore(): workers = 2
[10:32:57.508] MulticoreFuture started
[10:32:57.508] - Launch lazy future ... done
[10:32:57.509] run() for ‘MulticoreFuture’ ... done
[10:32:57.509] result() for MulticoreFuture ...
[10:32:57.510] plan(): Setting new future strategy stack:
[10:32:57.510] List of future strategies:
[10:32:57.510] 1. sequential:
[10:32:57.510]    - args: function (..., envir = parent.frame())
[10:32:57.510]    - tweaked: FALSE
[10:32:57.510]    - call: NULL
[10:32:57.511] plan(): nbrOfWorkers() = 1
[10:32:57.514] plan(): Setting new future strategy stack:
[10:32:57.514] List of future strategies:
[10:32:57.514] 1. multicore:
[10:32:57.514]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:57.514]    - tweaked: FALSE
[10:32:57.514]    - call: plan(strategy)
[10:32:57.519] plan(): nbrOfWorkers() = 2
[10:32:57.522] result() for MulticoreFuture ...
[10:32:57.522] result() for MulticoreFuture ... done
[10:32:57.522] result() for MulticoreFuture ... done
[10:32:57.522] result() for MulticoreFuture ...
[10:32:57.522] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[10:32:57.526] getGlobalsAndPackages() ...
[10:32:57.526] Searching for globals...
[10:32:57.532] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[10:32:57.532] Searching for globals ... DONE
[10:32:57.532] Resolving globals: FALSE
[10:32:57.533] 
[10:32:57.533] - packages: [2] ‘stats’, ‘datasets’
[10:32:57.534] getGlobalsAndPackages() ... DONE
[10:32:57.534] run() for ‘Future’ ...
[10:32:57.534] - state: ‘created’
[10:32:57.534] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:57.538] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:57.539] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:57.539]   - Field: ‘label’
[10:32:57.539]   - Field: ‘local’
[10:32:57.539]   - Field: ‘owner’
[10:32:57.539]   - Field: ‘envir’
[10:32:57.539]   - Field: ‘workers’
[10:32:57.539]   - Field: ‘packages’
[10:32:57.539]   - Field: ‘gc’
[10:32:57.539]   - Field: ‘job’
[10:32:57.540]   - Field: ‘conditions’
[10:32:57.540]   - Field: ‘expr’
[10:32:57.540]   - Field: ‘uuid’
[10:32:57.540]   - Field: ‘seed’
[10:32:57.540]   - Field: ‘version’
[10:32:57.540]   - Field: ‘result’
[10:32:57.540]   - Field: ‘asynchronous’
[10:32:57.540]   - Field: ‘calls’
[10:32:57.540]   - Field: ‘globals’
[10:32:57.541]   - Field: ‘stdout’
[10:32:57.541]   - Field: ‘earlySignal’
[10:32:57.541]   - Field: ‘lazy’
[10:32:57.541]   - Field: ‘state’
[10:32:57.541] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:57.541] - Launch lazy future ...
[10:32:57.542] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:32:57.542] Packages needed by future strategies (n = 0): <none>
[10:32:57.542] {
[10:32:57.542]     {
[10:32:57.542]         {
[10:32:57.542]             ...future.startTime <- base::Sys.time()
[10:32:57.542]             {
[10:32:57.542]                 {
[10:32:57.542]                   {
[10:32:57.542]                     {
[10:32:57.542]                       {
[10:32:57.542]                         base::local({
[10:32:57.542]                           has_future <- base::requireNamespace("future", 
[10:32:57.542]                             quietly = TRUE)
[10:32:57.542]                           if (has_future) {
[10:32:57.542]                             ns <- base::getNamespace("future")
[10:32:57.542]                             version <- ns[[".package"]][["version"]]
[10:32:57.542]                             if (is.null(version)) 
[10:32:57.542]                               version <- utils::packageVersion("future")
[10:32:57.542]                           }
[10:32:57.542]                           else {
[10:32:57.542]                             version <- NULL
[10:32:57.542]                           }
[10:32:57.542]                           if (!has_future || version < "1.8.0") {
[10:32:57.542]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:57.542]                               "", base::R.version$version.string), 
[10:32:57.542]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:57.542]                                 base::R.version$platform, 8 * 
[10:32:57.542]                                   base::.Machine$sizeof.pointer), 
[10:32:57.542]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:57.542]                                 "release", "version")], collapse = " "), 
[10:32:57.542]                               hostname = base::Sys.info()[["nodename"]])
[10:32:57.542]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:57.542]                               info)
[10:32:57.542]                             info <- base::paste(info, collapse = "; ")
[10:32:57.542]                             if (!has_future) {
[10:32:57.542]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:57.542]                                 info)
[10:32:57.542]                             }
[10:32:57.542]                             else {
[10:32:57.542]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:57.542]                                 info, version)
[10:32:57.542]                             }
[10:32:57.542]                             base::stop(msg)
[10:32:57.542]                           }
[10:32:57.542]                         })
[10:32:57.542]                       }
[10:32:57.542]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:57.542]                       base::options(mc.cores = 1L)
[10:32:57.542]                     }
[10:32:57.542]                     base::local({
[10:32:57.542]                       for (pkg in c("stats", "datasets")) {
[10:32:57.542]                         base::loadNamespace(pkg)
[10:32:57.542]                         base::library(pkg, character.only = TRUE)
[10:32:57.542]                       }
[10:32:57.542]                     })
[10:32:57.542]                   }
[10:32:57.542]                   ...future.strategy.old <- future::plan("list")
[10:32:57.542]                   options(future.plan = NULL)
[10:32:57.542]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.542]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:57.542]                 }
[10:32:57.542]                 ...future.workdir <- getwd()
[10:32:57.542]             }
[10:32:57.542]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:57.542]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:57.542]         }
[10:32:57.542]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:57.542]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:57.542]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:57.542]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:57.542]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:57.542]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:57.542]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:57.542]             base::names(...future.oldOptions))
[10:32:57.542]     }
[10:32:57.542]     if (FALSE) {
[10:32:57.542]     }
[10:32:57.542]     else {
[10:32:57.542]         if (TRUE) {
[10:32:57.542]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:57.542]                 open = "w")
[10:32:57.542]         }
[10:32:57.542]         else {
[10:32:57.542]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:57.542]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:57.542]         }
[10:32:57.542]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:57.542]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:57.542]             base::sink(type = "output", split = FALSE)
[10:32:57.542]             base::close(...future.stdout)
[10:32:57.542]         }, add = TRUE)
[10:32:57.542]     }
[10:32:57.542]     ...future.frame <- base::sys.nframe()
[10:32:57.542]     ...future.conditions <- base::list()
[10:32:57.542]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:57.542]     if (FALSE) {
[10:32:57.542]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:57.542]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:57.542]     }
[10:32:57.542]     ...future.result <- base::tryCatch({
[10:32:57.542]         base::withCallingHandlers({
[10:32:57.542]             ...future.value <- base::withVisible(base::local({
[10:32:57.542]                 withCallingHandlers({
[10:32:57.542]                   {
[10:32:57.542]                     lm(dist ~ speed + I(speed^2), data = cars)
[10:32:57.542]                   }
[10:32:57.542]                 }, immediateCondition = function(cond) {
[10:32:57.542]                   save_rds <- function (object, pathname, ...) 
[10:32:57.542]                   {
[10:32:57.542]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:57.542]                     if (file_test("-f", pathname_tmp)) {
[10:32:57.542]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.542]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:57.542]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.542]                         fi_tmp[["mtime"]])
[10:32:57.542]                     }
[10:32:57.542]                     tryCatch({
[10:32:57.542]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:57.542]                     }, error = function(ex) {
[10:32:57.542]                       msg <- conditionMessage(ex)
[10:32:57.542]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.542]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:57.542]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.542]                         fi_tmp[["mtime"]], msg)
[10:32:57.542]                       ex$message <- msg
[10:32:57.542]                       stop(ex)
[10:32:57.542]                     })
[10:32:57.542]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:57.542]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:57.542]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:57.542]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.542]                       fi <- file.info(pathname)
[10:32:57.542]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:57.542]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.542]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:57.542]                         fi[["size"]], fi[["mtime"]])
[10:32:57.542]                       stop(msg)
[10:32:57.542]                     }
[10:32:57.542]                     invisible(pathname)
[10:32:57.542]                   }
[10:32:57.542]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:57.542]                     rootPath = tempdir()) 
[10:32:57.542]                   {
[10:32:57.542]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:57.542]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:57.542]                       tmpdir = path, fileext = ".rds")
[10:32:57.542]                     save_rds(obj, file)
[10:32:57.542]                   }
[10:32:57.542]                   saveImmediateCondition(cond, path = "/tmp/RtmpZSnOM5/.future/immediateConditions")
[10:32:57.542]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.542]                   {
[10:32:57.542]                     inherits <- base::inherits
[10:32:57.542]                     invokeRestart <- base::invokeRestart
[10:32:57.542]                     is.null <- base::is.null
[10:32:57.542]                     muffled <- FALSE
[10:32:57.542]                     if (inherits(cond, "message")) {
[10:32:57.542]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:57.542]                       if (muffled) 
[10:32:57.542]                         invokeRestart("muffleMessage")
[10:32:57.542]                     }
[10:32:57.542]                     else if (inherits(cond, "warning")) {
[10:32:57.542]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:57.542]                       if (muffled) 
[10:32:57.542]                         invokeRestart("muffleWarning")
[10:32:57.542]                     }
[10:32:57.542]                     else if (inherits(cond, "condition")) {
[10:32:57.542]                       if (!is.null(pattern)) {
[10:32:57.542]                         computeRestarts <- base::computeRestarts
[10:32:57.542]                         grepl <- base::grepl
[10:32:57.542]                         restarts <- computeRestarts(cond)
[10:32:57.542]                         for (restart in restarts) {
[10:32:57.542]                           name <- restart$name
[10:32:57.542]                           if (is.null(name)) 
[10:32:57.542]                             next
[10:32:57.542]                           if (!grepl(pattern, name)) 
[10:32:57.542]                             next
[10:32:57.542]                           invokeRestart(restart)
[10:32:57.542]                           muffled <- TRUE
[10:32:57.542]                           break
[10:32:57.542]                         }
[10:32:57.542]                       }
[10:32:57.542]                     }
[10:32:57.542]                     invisible(muffled)
[10:32:57.542]                   }
[10:32:57.542]                   muffleCondition(cond)
[10:32:57.542]                 })
[10:32:57.542]             }))
[10:32:57.542]             future::FutureResult(value = ...future.value$value, 
[10:32:57.542]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.542]                   ...future.rng), globalenv = if (FALSE) 
[10:32:57.542]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:57.542]                     ...future.globalenv.names))
[10:32:57.542]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:57.542]         }, condition = base::local({
[10:32:57.542]             c <- base::c
[10:32:57.542]             inherits <- base::inherits
[10:32:57.542]             invokeRestart <- base::invokeRestart
[10:32:57.542]             length <- base::length
[10:32:57.542]             list <- base::list
[10:32:57.542]             seq.int <- base::seq.int
[10:32:57.542]             signalCondition <- base::signalCondition
[10:32:57.542]             sys.calls <- base::sys.calls
[10:32:57.542]             `[[` <- base::`[[`
[10:32:57.542]             `+` <- base::`+`
[10:32:57.542]             `<<-` <- base::`<<-`
[10:32:57.542]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:57.542]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:57.542]                   3L)]
[10:32:57.542]             }
[10:32:57.542]             function(cond) {
[10:32:57.542]                 is_error <- inherits(cond, "error")
[10:32:57.542]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:57.542]                   NULL)
[10:32:57.542]                 if (is_error) {
[10:32:57.542]                   sessionInformation <- function() {
[10:32:57.542]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:57.542]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:57.542]                       search = base::search(), system = base::Sys.info())
[10:32:57.542]                   }
[10:32:57.542]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.542]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:57.542]                     cond$call), session = sessionInformation(), 
[10:32:57.542]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:57.542]                   signalCondition(cond)
[10:32:57.542]                 }
[10:32:57.542]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:57.542]                 "immediateCondition"))) {
[10:32:57.542]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:57.542]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.542]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:57.542]                   if (TRUE && !signal) {
[10:32:57.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.542]                     {
[10:32:57.542]                       inherits <- base::inherits
[10:32:57.542]                       invokeRestart <- base::invokeRestart
[10:32:57.542]                       is.null <- base::is.null
[10:32:57.542]                       muffled <- FALSE
[10:32:57.542]                       if (inherits(cond, "message")) {
[10:32:57.542]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.542]                         if (muffled) 
[10:32:57.542]                           invokeRestart("muffleMessage")
[10:32:57.542]                       }
[10:32:57.542]                       else if (inherits(cond, "warning")) {
[10:32:57.542]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.542]                         if (muffled) 
[10:32:57.542]                           invokeRestart("muffleWarning")
[10:32:57.542]                       }
[10:32:57.542]                       else if (inherits(cond, "condition")) {
[10:32:57.542]                         if (!is.null(pattern)) {
[10:32:57.542]                           computeRestarts <- base::computeRestarts
[10:32:57.542]                           grepl <- base::grepl
[10:32:57.542]                           restarts <- computeRestarts(cond)
[10:32:57.542]                           for (restart in restarts) {
[10:32:57.542]                             name <- restart$name
[10:32:57.542]                             if (is.null(name)) 
[10:32:57.542]                               next
[10:32:57.542]                             if (!grepl(pattern, name)) 
[10:32:57.542]                               next
[10:32:57.542]                             invokeRestart(restart)
[10:32:57.542]                             muffled <- TRUE
[10:32:57.542]                             break
[10:32:57.542]                           }
[10:32:57.542]                         }
[10:32:57.542]                       }
[10:32:57.542]                       invisible(muffled)
[10:32:57.542]                     }
[10:32:57.542]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.542]                   }
[10:32:57.542]                 }
[10:32:57.542]                 else {
[10:32:57.542]                   if (TRUE) {
[10:32:57.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.542]                     {
[10:32:57.542]                       inherits <- base::inherits
[10:32:57.542]                       invokeRestart <- base::invokeRestart
[10:32:57.542]                       is.null <- base::is.null
[10:32:57.542]                       muffled <- FALSE
[10:32:57.542]                       if (inherits(cond, "message")) {
[10:32:57.542]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.542]                         if (muffled) 
[10:32:57.542]                           invokeRestart("muffleMessage")
[10:32:57.542]                       }
[10:32:57.542]                       else if (inherits(cond, "warning")) {
[10:32:57.542]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.542]                         if (muffled) 
[10:32:57.542]                           invokeRestart("muffleWarning")
[10:32:57.542]                       }
[10:32:57.542]                       else if (inherits(cond, "condition")) {
[10:32:57.542]                         if (!is.null(pattern)) {
[10:32:57.542]                           computeRestarts <- base::computeRestarts
[10:32:57.542]                           grepl <- base::grepl
[10:32:57.542]                           restarts <- computeRestarts(cond)
[10:32:57.542]                           for (restart in restarts) {
[10:32:57.542]                             name <- restart$name
[10:32:57.542]                             if (is.null(name)) 
[10:32:57.542]                               next
[10:32:57.542]                             if (!grepl(pattern, name)) 
[10:32:57.542]                               next
[10:32:57.542]                             invokeRestart(restart)
[10:32:57.542]                             muffled <- TRUE
[10:32:57.542]                             break
[10:32:57.542]                           }
[10:32:57.542]                         }
[10:32:57.542]                       }
[10:32:57.542]                       invisible(muffled)
[10:32:57.542]                     }
[10:32:57.542]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.542]                   }
[10:32:57.542]                 }
[10:32:57.542]             }
[10:32:57.542]         }))
[10:32:57.542]     }, error = function(ex) {
[10:32:57.542]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:57.542]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.542]                 ...future.rng), started = ...future.startTime, 
[10:32:57.542]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:57.542]             version = "1.8"), class = "FutureResult")
[10:32:57.542]     }, finally = {
[10:32:57.542]         if (!identical(...future.workdir, getwd())) 
[10:32:57.542]             setwd(...future.workdir)
[10:32:57.542]         {
[10:32:57.542]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:57.542]                 ...future.oldOptions$nwarnings <- NULL
[10:32:57.542]             }
[10:32:57.542]             base::options(...future.oldOptions)
[10:32:57.542]             if (.Platform$OS.type == "windows") {
[10:32:57.542]                 old_names <- names(...future.oldEnvVars)
[10:32:57.542]                 envs <- base::Sys.getenv()
[10:32:57.542]                 names <- names(envs)
[10:32:57.542]                 common <- intersect(names, old_names)
[10:32:57.542]                 added <- setdiff(names, old_names)
[10:32:57.542]                 removed <- setdiff(old_names, names)
[10:32:57.542]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:57.542]                   envs[common]]
[10:32:57.542]                 NAMES <- toupper(changed)
[10:32:57.542]                 args <- list()
[10:32:57.542]                 for (kk in seq_along(NAMES)) {
[10:32:57.542]                   name <- changed[[kk]]
[10:32:57.542]                   NAME <- NAMES[[kk]]
[10:32:57.542]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.542]                     next
[10:32:57.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.542]                 }
[10:32:57.542]                 NAMES <- toupper(added)
[10:32:57.542]                 for (kk in seq_along(NAMES)) {
[10:32:57.542]                   name <- added[[kk]]
[10:32:57.542]                   NAME <- NAMES[[kk]]
[10:32:57.542]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.542]                     next
[10:32:57.542]                   args[[name]] <- ""
[10:32:57.542]                 }
[10:32:57.542]                 NAMES <- toupper(removed)
[10:32:57.542]                 for (kk in seq_along(NAMES)) {
[10:32:57.542]                   name <- removed[[kk]]
[10:32:57.542]                   NAME <- NAMES[[kk]]
[10:32:57.542]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.542]                     next
[10:32:57.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.542]                 }
[10:32:57.542]                 if (length(args) > 0) 
[10:32:57.542]                   base::do.call(base::Sys.setenv, args = args)
[10:32:57.542]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:57.542]             }
[10:32:57.542]             else {
[10:32:57.542]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:57.542]             }
[10:32:57.542]             {
[10:32:57.542]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:57.542]                   0L) {
[10:32:57.542]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:57.542]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:57.542]                   base::options(opts)
[10:32:57.542]                 }
[10:32:57.542]                 {
[10:32:57.542]                   {
[10:32:57.542]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:57.542]                     NULL
[10:32:57.542]                   }
[10:32:57.542]                   options(future.plan = NULL)
[10:32:57.542]                   if (is.na(NA_character_)) 
[10:32:57.542]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.542]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:57.542]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:57.542]                     .init = FALSE)
[10:32:57.542]                 }
[10:32:57.542]             }
[10:32:57.542]         }
[10:32:57.542]     })
[10:32:57.542]     if (TRUE) {
[10:32:57.542]         base::sink(type = "output", split = FALSE)
[10:32:57.542]         if (TRUE) {
[10:32:57.542]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:57.542]         }
[10:32:57.542]         else {
[10:32:57.542]             ...future.result["stdout"] <- base::list(NULL)
[10:32:57.542]         }
[10:32:57.542]         base::close(...future.stdout)
[10:32:57.542]         ...future.stdout <- NULL
[10:32:57.542]     }
[10:32:57.542]     ...future.result$conditions <- ...future.conditions
[10:32:57.542]     ...future.result$finished <- base::Sys.time()
[10:32:57.542]     ...future.result
[10:32:57.542] }
[10:32:57.545] requestCore(): workers = 2
[10:32:57.546] MulticoreFuture started
[10:32:57.547] - Launch lazy future ... done
[10:32:57.547] run() for ‘MulticoreFuture’ ... done
[10:32:57.547] result() for MulticoreFuture ...
[10:32:57.548] plan(): Setting new future strategy stack:
[10:32:57.548] List of future strategies:
[10:32:57.548] 1. sequential:
[10:32:57.548]    - args: function (..., envir = parent.frame())
[10:32:57.548]    - tweaked: FALSE
[10:32:57.548]    - call: NULL
[10:32:57.549] plan(): nbrOfWorkers() = 1
[10:32:57.553] plan(): Setting new future strategy stack:
[10:32:57.553] List of future strategies:
[10:32:57.553] 1. multicore:
[10:32:57.553]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:57.553]    - tweaked: FALSE
[10:32:57.553]    - call: plan(strategy)
[10:32:57.558] plan(): nbrOfWorkers() = 2
[10:32:57.561] result() for MulticoreFuture ...
[10:32:57.561] result() for MulticoreFuture ... done
[10:32:57.561] result() for MulticoreFuture ... done
[10:32:57.561] result() for MulticoreFuture ...
[10:32:57.561] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[10:32:57.565] getGlobalsAndPackages() ...
[10:32:57.565] Searching for globals...
[10:32:57.568] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[10:32:57.568] Searching for globals ... DONE
[10:32:57.568] Resolving globals: FALSE
[10:32:57.568] 
[10:32:57.569] - packages: [2] ‘stats’, ‘datasets’
[10:32:57.569] getGlobalsAndPackages() ... DONE
[10:32:57.569] run() for ‘Future’ ...
[10:32:57.569] - state: ‘created’
[10:32:57.569] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:57.573] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:57.573] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:57.574]   - Field: ‘label’
[10:32:57.574]   - Field: ‘local’
[10:32:57.574]   - Field: ‘owner’
[10:32:57.574]   - Field: ‘envir’
[10:32:57.574]   - Field: ‘workers’
[10:32:57.574]   - Field: ‘packages’
[10:32:57.574]   - Field: ‘gc’
[10:32:57.574]   - Field: ‘job’
[10:32:57.575]   - Field: ‘conditions’
[10:32:57.575]   - Field: ‘expr’
[10:32:57.575]   - Field: ‘uuid’
[10:32:57.575]   - Field: ‘seed’
[10:32:57.575]   - Field: ‘version’
[10:32:57.575]   - Field: ‘result’
[10:32:57.575]   - Field: ‘asynchronous’
[10:32:57.575]   - Field: ‘calls’
[10:32:57.575]   - Field: ‘globals’
[10:32:57.576]   - Field: ‘stdout’
[10:32:57.576]   - Field: ‘earlySignal’
[10:32:57.576]   - Field: ‘lazy’
[10:32:57.576]   - Field: ‘state’
[10:32:57.576] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:57.576] - Launch lazy future ...
[10:32:57.576] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:32:57.577] Packages needed by future strategies (n = 0): <none>
[10:32:57.577] {
[10:32:57.577]     {
[10:32:57.577]         {
[10:32:57.577]             ...future.startTime <- base::Sys.time()
[10:32:57.577]             {
[10:32:57.577]                 {
[10:32:57.577]                   {
[10:32:57.577]                     {
[10:32:57.577]                       {
[10:32:57.577]                         base::local({
[10:32:57.577]                           has_future <- base::requireNamespace("future", 
[10:32:57.577]                             quietly = TRUE)
[10:32:57.577]                           if (has_future) {
[10:32:57.577]                             ns <- base::getNamespace("future")
[10:32:57.577]                             version <- ns[[".package"]][["version"]]
[10:32:57.577]                             if (is.null(version)) 
[10:32:57.577]                               version <- utils::packageVersion("future")
[10:32:57.577]                           }
[10:32:57.577]                           else {
[10:32:57.577]                             version <- NULL
[10:32:57.577]                           }
[10:32:57.577]                           if (!has_future || version < "1.8.0") {
[10:32:57.577]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:57.577]                               "", base::R.version$version.string), 
[10:32:57.577]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:57.577]                                 base::R.version$platform, 8 * 
[10:32:57.577]                                   base::.Machine$sizeof.pointer), 
[10:32:57.577]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:57.577]                                 "release", "version")], collapse = " "), 
[10:32:57.577]                               hostname = base::Sys.info()[["nodename"]])
[10:32:57.577]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:57.577]                               info)
[10:32:57.577]                             info <- base::paste(info, collapse = "; ")
[10:32:57.577]                             if (!has_future) {
[10:32:57.577]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:57.577]                                 info)
[10:32:57.577]                             }
[10:32:57.577]                             else {
[10:32:57.577]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:57.577]                                 info, version)
[10:32:57.577]                             }
[10:32:57.577]                             base::stop(msg)
[10:32:57.577]                           }
[10:32:57.577]                         })
[10:32:57.577]                       }
[10:32:57.577]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:57.577]                       base::options(mc.cores = 1L)
[10:32:57.577]                     }
[10:32:57.577]                     base::local({
[10:32:57.577]                       for (pkg in c("stats", "datasets")) {
[10:32:57.577]                         base::loadNamespace(pkg)
[10:32:57.577]                         base::library(pkg, character.only = TRUE)
[10:32:57.577]                       }
[10:32:57.577]                     })
[10:32:57.577]                   }
[10:32:57.577]                   ...future.strategy.old <- future::plan("list")
[10:32:57.577]                   options(future.plan = NULL)
[10:32:57.577]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.577]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:57.577]                 }
[10:32:57.577]                 ...future.workdir <- getwd()
[10:32:57.577]             }
[10:32:57.577]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:57.577]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:57.577]         }
[10:32:57.577]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:57.577]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:57.577]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:57.577]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:57.577]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:57.577]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:57.577]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:57.577]             base::names(...future.oldOptions))
[10:32:57.577]     }
[10:32:57.577]     if (FALSE) {
[10:32:57.577]     }
[10:32:57.577]     else {
[10:32:57.577]         if (TRUE) {
[10:32:57.577]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:57.577]                 open = "w")
[10:32:57.577]         }
[10:32:57.577]         else {
[10:32:57.577]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:57.577]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:57.577]         }
[10:32:57.577]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:57.577]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:57.577]             base::sink(type = "output", split = FALSE)
[10:32:57.577]             base::close(...future.stdout)
[10:32:57.577]         }, add = TRUE)
[10:32:57.577]     }
[10:32:57.577]     ...future.frame <- base::sys.nframe()
[10:32:57.577]     ...future.conditions <- base::list()
[10:32:57.577]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:57.577]     if (FALSE) {
[10:32:57.577]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:57.577]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:57.577]     }
[10:32:57.577]     ...future.result <- base::tryCatch({
[10:32:57.577]         base::withCallingHandlers({
[10:32:57.577]             ...future.value <- base::withVisible(base::local({
[10:32:57.577]                 withCallingHandlers({
[10:32:57.577]                   {
[10:32:57.577]                     lm(dist ~ poly(speed, 2), data = cars)
[10:32:57.577]                   }
[10:32:57.577]                 }, immediateCondition = function(cond) {
[10:32:57.577]                   save_rds <- function (object, pathname, ...) 
[10:32:57.577]                   {
[10:32:57.577]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:57.577]                     if (file_test("-f", pathname_tmp)) {
[10:32:57.577]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.577]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:57.577]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.577]                         fi_tmp[["mtime"]])
[10:32:57.577]                     }
[10:32:57.577]                     tryCatch({
[10:32:57.577]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:57.577]                     }, error = function(ex) {
[10:32:57.577]                       msg <- conditionMessage(ex)
[10:32:57.577]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.577]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:57.577]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.577]                         fi_tmp[["mtime"]], msg)
[10:32:57.577]                       ex$message <- msg
[10:32:57.577]                       stop(ex)
[10:32:57.577]                     })
[10:32:57.577]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:57.577]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:57.577]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:57.577]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.577]                       fi <- file.info(pathname)
[10:32:57.577]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:57.577]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.577]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:57.577]                         fi[["size"]], fi[["mtime"]])
[10:32:57.577]                       stop(msg)
[10:32:57.577]                     }
[10:32:57.577]                     invisible(pathname)
[10:32:57.577]                   }
[10:32:57.577]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:57.577]                     rootPath = tempdir()) 
[10:32:57.577]                   {
[10:32:57.577]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:57.577]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:57.577]                       tmpdir = path, fileext = ".rds")
[10:32:57.577]                     save_rds(obj, file)
[10:32:57.577]                   }
[10:32:57.577]                   saveImmediateCondition(cond, path = "/tmp/RtmpZSnOM5/.future/immediateConditions")
[10:32:57.577]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.577]                   {
[10:32:57.577]                     inherits <- base::inherits
[10:32:57.577]                     invokeRestart <- base::invokeRestart
[10:32:57.577]                     is.null <- base::is.null
[10:32:57.577]                     muffled <- FALSE
[10:32:57.577]                     if (inherits(cond, "message")) {
[10:32:57.577]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:57.577]                       if (muffled) 
[10:32:57.577]                         invokeRestart("muffleMessage")
[10:32:57.577]                     }
[10:32:57.577]                     else if (inherits(cond, "warning")) {
[10:32:57.577]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:57.577]                       if (muffled) 
[10:32:57.577]                         invokeRestart("muffleWarning")
[10:32:57.577]                     }
[10:32:57.577]                     else if (inherits(cond, "condition")) {
[10:32:57.577]                       if (!is.null(pattern)) {
[10:32:57.577]                         computeRestarts <- base::computeRestarts
[10:32:57.577]                         grepl <- base::grepl
[10:32:57.577]                         restarts <- computeRestarts(cond)
[10:32:57.577]                         for (restart in restarts) {
[10:32:57.577]                           name <- restart$name
[10:32:57.577]                           if (is.null(name)) 
[10:32:57.577]                             next
[10:32:57.577]                           if (!grepl(pattern, name)) 
[10:32:57.577]                             next
[10:32:57.577]                           invokeRestart(restart)
[10:32:57.577]                           muffled <- TRUE
[10:32:57.577]                           break
[10:32:57.577]                         }
[10:32:57.577]                       }
[10:32:57.577]                     }
[10:32:57.577]                     invisible(muffled)
[10:32:57.577]                   }
[10:32:57.577]                   muffleCondition(cond)
[10:32:57.577]                 })
[10:32:57.577]             }))
[10:32:57.577]             future::FutureResult(value = ...future.value$value, 
[10:32:57.577]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.577]                   ...future.rng), globalenv = if (FALSE) 
[10:32:57.577]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:57.577]                     ...future.globalenv.names))
[10:32:57.577]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:57.577]         }, condition = base::local({
[10:32:57.577]             c <- base::c
[10:32:57.577]             inherits <- base::inherits
[10:32:57.577]             invokeRestart <- base::invokeRestart
[10:32:57.577]             length <- base::length
[10:32:57.577]             list <- base::list
[10:32:57.577]             seq.int <- base::seq.int
[10:32:57.577]             signalCondition <- base::signalCondition
[10:32:57.577]             sys.calls <- base::sys.calls
[10:32:57.577]             `[[` <- base::`[[`
[10:32:57.577]             `+` <- base::`+`
[10:32:57.577]             `<<-` <- base::`<<-`
[10:32:57.577]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:57.577]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:57.577]                   3L)]
[10:32:57.577]             }
[10:32:57.577]             function(cond) {
[10:32:57.577]                 is_error <- inherits(cond, "error")
[10:32:57.577]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:57.577]                   NULL)
[10:32:57.577]                 if (is_error) {
[10:32:57.577]                   sessionInformation <- function() {
[10:32:57.577]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:57.577]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:57.577]                       search = base::search(), system = base::Sys.info())
[10:32:57.577]                   }
[10:32:57.577]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.577]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:57.577]                     cond$call), session = sessionInformation(), 
[10:32:57.577]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:57.577]                   signalCondition(cond)
[10:32:57.577]                 }
[10:32:57.577]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:57.577]                 "immediateCondition"))) {
[10:32:57.577]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:57.577]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.577]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:57.577]                   if (TRUE && !signal) {
[10:32:57.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.577]                     {
[10:32:57.577]                       inherits <- base::inherits
[10:32:57.577]                       invokeRestart <- base::invokeRestart
[10:32:57.577]                       is.null <- base::is.null
[10:32:57.577]                       muffled <- FALSE
[10:32:57.577]                       if (inherits(cond, "message")) {
[10:32:57.577]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.577]                         if (muffled) 
[10:32:57.577]                           invokeRestart("muffleMessage")
[10:32:57.577]                       }
[10:32:57.577]                       else if (inherits(cond, "warning")) {
[10:32:57.577]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.577]                         if (muffled) 
[10:32:57.577]                           invokeRestart("muffleWarning")
[10:32:57.577]                       }
[10:32:57.577]                       else if (inherits(cond, "condition")) {
[10:32:57.577]                         if (!is.null(pattern)) {
[10:32:57.577]                           computeRestarts <- base::computeRestarts
[10:32:57.577]                           grepl <- base::grepl
[10:32:57.577]                           restarts <- computeRestarts(cond)
[10:32:57.577]                           for (restart in restarts) {
[10:32:57.577]                             name <- restart$name
[10:32:57.577]                             if (is.null(name)) 
[10:32:57.577]                               next
[10:32:57.577]                             if (!grepl(pattern, name)) 
[10:32:57.577]                               next
[10:32:57.577]                             invokeRestart(restart)
[10:32:57.577]                             muffled <- TRUE
[10:32:57.577]                             break
[10:32:57.577]                           }
[10:32:57.577]                         }
[10:32:57.577]                       }
[10:32:57.577]                       invisible(muffled)
[10:32:57.577]                     }
[10:32:57.577]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.577]                   }
[10:32:57.577]                 }
[10:32:57.577]                 else {
[10:32:57.577]                   if (TRUE) {
[10:32:57.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.577]                     {
[10:32:57.577]                       inherits <- base::inherits
[10:32:57.577]                       invokeRestart <- base::invokeRestart
[10:32:57.577]                       is.null <- base::is.null
[10:32:57.577]                       muffled <- FALSE
[10:32:57.577]                       if (inherits(cond, "message")) {
[10:32:57.577]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.577]                         if (muffled) 
[10:32:57.577]                           invokeRestart("muffleMessage")
[10:32:57.577]                       }
[10:32:57.577]                       else if (inherits(cond, "warning")) {
[10:32:57.577]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.577]                         if (muffled) 
[10:32:57.577]                           invokeRestart("muffleWarning")
[10:32:57.577]                       }
[10:32:57.577]                       else if (inherits(cond, "condition")) {
[10:32:57.577]                         if (!is.null(pattern)) {
[10:32:57.577]                           computeRestarts <- base::computeRestarts
[10:32:57.577]                           grepl <- base::grepl
[10:32:57.577]                           restarts <- computeRestarts(cond)
[10:32:57.577]                           for (restart in restarts) {
[10:32:57.577]                             name <- restart$name
[10:32:57.577]                             if (is.null(name)) 
[10:32:57.577]                               next
[10:32:57.577]                             if (!grepl(pattern, name)) 
[10:32:57.577]                               next
[10:32:57.577]                             invokeRestart(restart)
[10:32:57.577]                             muffled <- TRUE
[10:32:57.577]                             break
[10:32:57.577]                           }
[10:32:57.577]                         }
[10:32:57.577]                       }
[10:32:57.577]                       invisible(muffled)
[10:32:57.577]                     }
[10:32:57.577]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.577]                   }
[10:32:57.577]                 }
[10:32:57.577]             }
[10:32:57.577]         }))
[10:32:57.577]     }, error = function(ex) {
[10:32:57.577]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:57.577]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.577]                 ...future.rng), started = ...future.startTime, 
[10:32:57.577]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:57.577]             version = "1.8"), class = "FutureResult")
[10:32:57.577]     }, finally = {
[10:32:57.577]         if (!identical(...future.workdir, getwd())) 
[10:32:57.577]             setwd(...future.workdir)
[10:32:57.577]         {
[10:32:57.577]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:57.577]                 ...future.oldOptions$nwarnings <- NULL
[10:32:57.577]             }
[10:32:57.577]             base::options(...future.oldOptions)
[10:32:57.577]             if (.Platform$OS.type == "windows") {
[10:32:57.577]                 old_names <- names(...future.oldEnvVars)
[10:32:57.577]                 envs <- base::Sys.getenv()
[10:32:57.577]                 names <- names(envs)
[10:32:57.577]                 common <- intersect(names, old_names)
[10:32:57.577]                 added <- setdiff(names, old_names)
[10:32:57.577]                 removed <- setdiff(old_names, names)
[10:32:57.577]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:57.577]                   envs[common]]
[10:32:57.577]                 NAMES <- toupper(changed)
[10:32:57.577]                 args <- list()
[10:32:57.577]                 for (kk in seq_along(NAMES)) {
[10:32:57.577]                   name <- changed[[kk]]
[10:32:57.577]                   NAME <- NAMES[[kk]]
[10:32:57.577]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.577]                     next
[10:32:57.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.577]                 }
[10:32:57.577]                 NAMES <- toupper(added)
[10:32:57.577]                 for (kk in seq_along(NAMES)) {
[10:32:57.577]                   name <- added[[kk]]
[10:32:57.577]                   NAME <- NAMES[[kk]]
[10:32:57.577]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.577]                     next
[10:32:57.577]                   args[[name]] <- ""
[10:32:57.577]                 }
[10:32:57.577]                 NAMES <- toupper(removed)
[10:32:57.577]                 for (kk in seq_along(NAMES)) {
[10:32:57.577]                   name <- removed[[kk]]
[10:32:57.577]                   NAME <- NAMES[[kk]]
[10:32:57.577]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.577]                     next
[10:32:57.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.577]                 }
[10:32:57.577]                 if (length(args) > 0) 
[10:32:57.577]                   base::do.call(base::Sys.setenv, args = args)
[10:32:57.577]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:57.577]             }
[10:32:57.577]             else {
[10:32:57.577]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:57.577]             }
[10:32:57.577]             {
[10:32:57.577]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:57.577]                   0L) {
[10:32:57.577]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:57.577]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:57.577]                   base::options(opts)
[10:32:57.577]                 }
[10:32:57.577]                 {
[10:32:57.577]                   {
[10:32:57.577]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:57.577]                     NULL
[10:32:57.577]                   }
[10:32:57.577]                   options(future.plan = NULL)
[10:32:57.577]                   if (is.na(NA_character_)) 
[10:32:57.577]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.577]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:57.577]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:57.577]                     .init = FALSE)
[10:32:57.577]                 }
[10:32:57.577]             }
[10:32:57.577]         }
[10:32:57.577]     })
[10:32:57.577]     if (TRUE) {
[10:32:57.577]         base::sink(type = "output", split = FALSE)
[10:32:57.577]         if (TRUE) {
[10:32:57.577]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:57.577]         }
[10:32:57.577]         else {
[10:32:57.577]             ...future.result["stdout"] <- base::list(NULL)
[10:32:57.577]         }
[10:32:57.577]         base::close(...future.stdout)
[10:32:57.577]         ...future.stdout <- NULL
[10:32:57.577]     }
[10:32:57.577]     ...future.result$conditions <- ...future.conditions
[10:32:57.577]     ...future.result$finished <- base::Sys.time()
[10:32:57.577]     ...future.result
[10:32:57.577] }
[10:32:57.580] requestCore(): workers = 2
[10:32:57.582] MulticoreFuture started
[10:32:57.582] - Launch lazy future ... done
[10:32:57.582] run() for ‘MulticoreFuture’ ... done
[10:32:57.583] result() for MulticoreFuture ...
[10:32:57.583] plan(): Setting new future strategy stack:
[10:32:57.584] List of future strategies:
[10:32:57.584] 1. sequential:
[10:32:57.584]    - args: function (..., envir = parent.frame())
[10:32:57.584]    - tweaked: FALSE
[10:32:57.584]    - call: NULL
[10:32:57.584] plan(): nbrOfWorkers() = 1
[10:32:57.589] plan(): Setting new future strategy stack:
[10:32:57.593] List of future strategies:
[10:32:57.593] 1. multicore:
[10:32:57.593]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:57.593]    - tweaked: FALSE
[10:32:57.593]    - call: plan(strategy)
[10:32:57.600] plan(): nbrOfWorkers() = 2
[10:32:57.602] result() for MulticoreFuture ...
[10:32:57.603] result() for MulticoreFuture ... done
[10:32:57.603] result() for MulticoreFuture ... done
[10:32:57.603] result() for MulticoreFuture ...
[10:32:57.603] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[10:32:57.609] getGlobalsAndPackages() ...
[10:32:57.610] Searching for globals...
[10:32:57.615] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[10:32:57.616] Searching for globals ... DONE
[10:32:57.616] Resolving globals: FALSE
[10:32:57.617] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[10:32:57.617] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[10:32:57.617] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[10:32:57.617] 
[10:32:57.617] getGlobalsAndPackages() ... DONE
[10:32:57.618] run() for ‘Future’ ...
[10:32:57.618] - state: ‘created’
[10:32:57.618] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:57.622] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:57.622] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:57.622]   - Field: ‘label’
[10:32:57.622]   - Field: ‘local’
[10:32:57.622]   - Field: ‘owner’
[10:32:57.622]   - Field: ‘envir’
[10:32:57.622]   - Field: ‘workers’
[10:32:57.622]   - Field: ‘packages’
[10:32:57.623]   - Field: ‘gc’
[10:32:57.623]   - Field: ‘job’
[10:32:57.623]   - Field: ‘conditions’
[10:32:57.623]   - Field: ‘expr’
[10:32:57.623]   - Field: ‘uuid’
[10:32:57.623]   - Field: ‘seed’
[10:32:57.623]   - Field: ‘version’
[10:32:57.623]   - Field: ‘result’
[10:32:57.623]   - Field: ‘asynchronous’
[10:32:57.624]   - Field: ‘calls’
[10:32:57.624]   - Field: ‘globals’
[10:32:57.624]   - Field: ‘stdout’
[10:32:57.624]   - Field: ‘earlySignal’
[10:32:57.624]   - Field: ‘lazy’
[10:32:57.624]   - Field: ‘state’
[10:32:57.624] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:57.624] - Launch lazy future ...
[10:32:57.625] Packages needed by the future expression (n = 0): <none>
[10:32:57.625] Packages needed by future strategies (n = 0): <none>
[10:32:57.625] {
[10:32:57.625]     {
[10:32:57.625]         {
[10:32:57.625]             ...future.startTime <- base::Sys.time()
[10:32:57.625]             {
[10:32:57.625]                 {
[10:32:57.625]                   {
[10:32:57.625]                     {
[10:32:57.625]                       base::local({
[10:32:57.625]                         has_future <- base::requireNamespace("future", 
[10:32:57.625]                           quietly = TRUE)
[10:32:57.625]                         if (has_future) {
[10:32:57.625]                           ns <- base::getNamespace("future")
[10:32:57.625]                           version <- ns[[".package"]][["version"]]
[10:32:57.625]                           if (is.null(version)) 
[10:32:57.625]                             version <- utils::packageVersion("future")
[10:32:57.625]                         }
[10:32:57.625]                         else {
[10:32:57.625]                           version <- NULL
[10:32:57.625]                         }
[10:32:57.625]                         if (!has_future || version < "1.8.0") {
[10:32:57.625]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:57.625]                             "", base::R.version$version.string), 
[10:32:57.625]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:57.625]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:57.625]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:57.625]                               "release", "version")], collapse = " "), 
[10:32:57.625]                             hostname = base::Sys.info()[["nodename"]])
[10:32:57.625]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:57.625]                             info)
[10:32:57.625]                           info <- base::paste(info, collapse = "; ")
[10:32:57.625]                           if (!has_future) {
[10:32:57.625]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:57.625]                               info)
[10:32:57.625]                           }
[10:32:57.625]                           else {
[10:32:57.625]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:57.625]                               info, version)
[10:32:57.625]                           }
[10:32:57.625]                           base::stop(msg)
[10:32:57.625]                         }
[10:32:57.625]                       })
[10:32:57.625]                     }
[10:32:57.625]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:57.625]                     base::options(mc.cores = 1L)
[10:32:57.625]                   }
[10:32:57.625]                   ...future.strategy.old <- future::plan("list")
[10:32:57.625]                   options(future.plan = NULL)
[10:32:57.625]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.625]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:57.625]                 }
[10:32:57.625]                 ...future.workdir <- getwd()
[10:32:57.625]             }
[10:32:57.625]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:57.625]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:57.625]         }
[10:32:57.625]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:57.625]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:57.625]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:57.625]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:57.625]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:57.625]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:57.625]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:57.625]             base::names(...future.oldOptions))
[10:32:57.625]     }
[10:32:57.625]     if (FALSE) {
[10:32:57.625]     }
[10:32:57.625]     else {
[10:32:57.625]         if (TRUE) {
[10:32:57.625]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:57.625]                 open = "w")
[10:32:57.625]         }
[10:32:57.625]         else {
[10:32:57.625]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:57.625]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:57.625]         }
[10:32:57.625]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:57.625]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:57.625]             base::sink(type = "output", split = FALSE)
[10:32:57.625]             base::close(...future.stdout)
[10:32:57.625]         }, add = TRUE)
[10:32:57.625]     }
[10:32:57.625]     ...future.frame <- base::sys.nframe()
[10:32:57.625]     ...future.conditions <- base::list()
[10:32:57.625]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:57.625]     if (FALSE) {
[10:32:57.625]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:57.625]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:57.625]     }
[10:32:57.625]     ...future.result <- base::tryCatch({
[10:32:57.625]         base::withCallingHandlers({
[10:32:57.625]             ...future.value <- base::withVisible(base::local({
[10:32:57.625]                 withCallingHandlers({
[10:32:57.625]                   {
[10:32:57.625]                     outer_function(1L)
[10:32:57.625]                   }
[10:32:57.625]                 }, immediateCondition = function(cond) {
[10:32:57.625]                   save_rds <- function (object, pathname, ...) 
[10:32:57.625]                   {
[10:32:57.625]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:57.625]                     if (file_test("-f", pathname_tmp)) {
[10:32:57.625]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.625]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:57.625]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.625]                         fi_tmp[["mtime"]])
[10:32:57.625]                     }
[10:32:57.625]                     tryCatch({
[10:32:57.625]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:57.625]                     }, error = function(ex) {
[10:32:57.625]                       msg <- conditionMessage(ex)
[10:32:57.625]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.625]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:57.625]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.625]                         fi_tmp[["mtime"]], msg)
[10:32:57.625]                       ex$message <- msg
[10:32:57.625]                       stop(ex)
[10:32:57.625]                     })
[10:32:57.625]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:57.625]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:57.625]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:57.625]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.625]                       fi <- file.info(pathname)
[10:32:57.625]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:57.625]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.625]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:57.625]                         fi[["size"]], fi[["mtime"]])
[10:32:57.625]                       stop(msg)
[10:32:57.625]                     }
[10:32:57.625]                     invisible(pathname)
[10:32:57.625]                   }
[10:32:57.625]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:57.625]                     rootPath = tempdir()) 
[10:32:57.625]                   {
[10:32:57.625]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:57.625]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:57.625]                       tmpdir = path, fileext = ".rds")
[10:32:57.625]                     save_rds(obj, file)
[10:32:57.625]                   }
[10:32:57.625]                   saveImmediateCondition(cond, path = "/tmp/RtmpZSnOM5/.future/immediateConditions")
[10:32:57.625]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.625]                   {
[10:32:57.625]                     inherits <- base::inherits
[10:32:57.625]                     invokeRestart <- base::invokeRestart
[10:32:57.625]                     is.null <- base::is.null
[10:32:57.625]                     muffled <- FALSE
[10:32:57.625]                     if (inherits(cond, "message")) {
[10:32:57.625]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:57.625]                       if (muffled) 
[10:32:57.625]                         invokeRestart("muffleMessage")
[10:32:57.625]                     }
[10:32:57.625]                     else if (inherits(cond, "warning")) {
[10:32:57.625]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:57.625]                       if (muffled) 
[10:32:57.625]                         invokeRestart("muffleWarning")
[10:32:57.625]                     }
[10:32:57.625]                     else if (inherits(cond, "condition")) {
[10:32:57.625]                       if (!is.null(pattern)) {
[10:32:57.625]                         computeRestarts <- base::computeRestarts
[10:32:57.625]                         grepl <- base::grepl
[10:32:57.625]                         restarts <- computeRestarts(cond)
[10:32:57.625]                         for (restart in restarts) {
[10:32:57.625]                           name <- restart$name
[10:32:57.625]                           if (is.null(name)) 
[10:32:57.625]                             next
[10:32:57.625]                           if (!grepl(pattern, name)) 
[10:32:57.625]                             next
[10:32:57.625]                           invokeRestart(restart)
[10:32:57.625]                           muffled <- TRUE
[10:32:57.625]                           break
[10:32:57.625]                         }
[10:32:57.625]                       }
[10:32:57.625]                     }
[10:32:57.625]                     invisible(muffled)
[10:32:57.625]                   }
[10:32:57.625]                   muffleCondition(cond)
[10:32:57.625]                 })
[10:32:57.625]             }))
[10:32:57.625]             future::FutureResult(value = ...future.value$value, 
[10:32:57.625]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.625]                   ...future.rng), globalenv = if (FALSE) 
[10:32:57.625]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:57.625]                     ...future.globalenv.names))
[10:32:57.625]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:57.625]         }, condition = base::local({
[10:32:57.625]             c <- base::c
[10:32:57.625]             inherits <- base::inherits
[10:32:57.625]             invokeRestart <- base::invokeRestart
[10:32:57.625]             length <- base::length
[10:32:57.625]             list <- base::list
[10:32:57.625]             seq.int <- base::seq.int
[10:32:57.625]             signalCondition <- base::signalCondition
[10:32:57.625]             sys.calls <- base::sys.calls
[10:32:57.625]             `[[` <- base::`[[`
[10:32:57.625]             `+` <- base::`+`
[10:32:57.625]             `<<-` <- base::`<<-`
[10:32:57.625]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:57.625]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:57.625]                   3L)]
[10:32:57.625]             }
[10:32:57.625]             function(cond) {
[10:32:57.625]                 is_error <- inherits(cond, "error")
[10:32:57.625]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:57.625]                   NULL)
[10:32:57.625]                 if (is_error) {
[10:32:57.625]                   sessionInformation <- function() {
[10:32:57.625]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:57.625]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:57.625]                       search = base::search(), system = base::Sys.info())
[10:32:57.625]                   }
[10:32:57.625]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.625]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:57.625]                     cond$call), session = sessionInformation(), 
[10:32:57.625]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:57.625]                   signalCondition(cond)
[10:32:57.625]                 }
[10:32:57.625]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:57.625]                 "immediateCondition"))) {
[10:32:57.625]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:57.625]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.625]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:57.625]                   if (TRUE && !signal) {
[10:32:57.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.625]                     {
[10:32:57.625]                       inherits <- base::inherits
[10:32:57.625]                       invokeRestart <- base::invokeRestart
[10:32:57.625]                       is.null <- base::is.null
[10:32:57.625]                       muffled <- FALSE
[10:32:57.625]                       if (inherits(cond, "message")) {
[10:32:57.625]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.625]                         if (muffled) 
[10:32:57.625]                           invokeRestart("muffleMessage")
[10:32:57.625]                       }
[10:32:57.625]                       else if (inherits(cond, "warning")) {
[10:32:57.625]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.625]                         if (muffled) 
[10:32:57.625]                           invokeRestart("muffleWarning")
[10:32:57.625]                       }
[10:32:57.625]                       else if (inherits(cond, "condition")) {
[10:32:57.625]                         if (!is.null(pattern)) {
[10:32:57.625]                           computeRestarts <- base::computeRestarts
[10:32:57.625]                           grepl <- base::grepl
[10:32:57.625]                           restarts <- computeRestarts(cond)
[10:32:57.625]                           for (restart in restarts) {
[10:32:57.625]                             name <- restart$name
[10:32:57.625]                             if (is.null(name)) 
[10:32:57.625]                               next
[10:32:57.625]                             if (!grepl(pattern, name)) 
[10:32:57.625]                               next
[10:32:57.625]                             invokeRestart(restart)
[10:32:57.625]                             muffled <- TRUE
[10:32:57.625]                             break
[10:32:57.625]                           }
[10:32:57.625]                         }
[10:32:57.625]                       }
[10:32:57.625]                       invisible(muffled)
[10:32:57.625]                     }
[10:32:57.625]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.625]                   }
[10:32:57.625]                 }
[10:32:57.625]                 else {
[10:32:57.625]                   if (TRUE) {
[10:32:57.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.625]                     {
[10:32:57.625]                       inherits <- base::inherits
[10:32:57.625]                       invokeRestart <- base::invokeRestart
[10:32:57.625]                       is.null <- base::is.null
[10:32:57.625]                       muffled <- FALSE
[10:32:57.625]                       if (inherits(cond, "message")) {
[10:32:57.625]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.625]                         if (muffled) 
[10:32:57.625]                           invokeRestart("muffleMessage")
[10:32:57.625]                       }
[10:32:57.625]                       else if (inherits(cond, "warning")) {
[10:32:57.625]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.625]                         if (muffled) 
[10:32:57.625]                           invokeRestart("muffleWarning")
[10:32:57.625]                       }
[10:32:57.625]                       else if (inherits(cond, "condition")) {
[10:32:57.625]                         if (!is.null(pattern)) {
[10:32:57.625]                           computeRestarts <- base::computeRestarts
[10:32:57.625]                           grepl <- base::grepl
[10:32:57.625]                           restarts <- computeRestarts(cond)
[10:32:57.625]                           for (restart in restarts) {
[10:32:57.625]                             name <- restart$name
[10:32:57.625]                             if (is.null(name)) 
[10:32:57.625]                               next
[10:32:57.625]                             if (!grepl(pattern, name)) 
[10:32:57.625]                               next
[10:32:57.625]                             invokeRestart(restart)
[10:32:57.625]                             muffled <- TRUE
[10:32:57.625]                             break
[10:32:57.625]                           }
[10:32:57.625]                         }
[10:32:57.625]                       }
[10:32:57.625]                       invisible(muffled)
[10:32:57.625]                     }
[10:32:57.625]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.625]                   }
[10:32:57.625]                 }
[10:32:57.625]             }
[10:32:57.625]         }))
[10:32:57.625]     }, error = function(ex) {
[10:32:57.625]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:57.625]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.625]                 ...future.rng), started = ...future.startTime, 
[10:32:57.625]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:57.625]             version = "1.8"), class = "FutureResult")
[10:32:57.625]     }, finally = {
[10:32:57.625]         if (!identical(...future.workdir, getwd())) 
[10:32:57.625]             setwd(...future.workdir)
[10:32:57.625]         {
[10:32:57.625]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:57.625]                 ...future.oldOptions$nwarnings <- NULL
[10:32:57.625]             }
[10:32:57.625]             base::options(...future.oldOptions)
[10:32:57.625]             if (.Platform$OS.type == "windows") {
[10:32:57.625]                 old_names <- names(...future.oldEnvVars)
[10:32:57.625]                 envs <- base::Sys.getenv()
[10:32:57.625]                 names <- names(envs)
[10:32:57.625]                 common <- intersect(names, old_names)
[10:32:57.625]                 added <- setdiff(names, old_names)
[10:32:57.625]                 removed <- setdiff(old_names, names)
[10:32:57.625]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:57.625]                   envs[common]]
[10:32:57.625]                 NAMES <- toupper(changed)
[10:32:57.625]                 args <- list()
[10:32:57.625]                 for (kk in seq_along(NAMES)) {
[10:32:57.625]                   name <- changed[[kk]]
[10:32:57.625]                   NAME <- NAMES[[kk]]
[10:32:57.625]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.625]                     next
[10:32:57.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.625]                 }
[10:32:57.625]                 NAMES <- toupper(added)
[10:32:57.625]                 for (kk in seq_along(NAMES)) {
[10:32:57.625]                   name <- added[[kk]]
[10:32:57.625]                   NAME <- NAMES[[kk]]
[10:32:57.625]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.625]                     next
[10:32:57.625]                   args[[name]] <- ""
[10:32:57.625]                 }
[10:32:57.625]                 NAMES <- toupper(removed)
[10:32:57.625]                 for (kk in seq_along(NAMES)) {
[10:32:57.625]                   name <- removed[[kk]]
[10:32:57.625]                   NAME <- NAMES[[kk]]
[10:32:57.625]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.625]                     next
[10:32:57.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.625]                 }
[10:32:57.625]                 if (length(args) > 0) 
[10:32:57.625]                   base::do.call(base::Sys.setenv, args = args)
[10:32:57.625]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:57.625]             }
[10:32:57.625]             else {
[10:32:57.625]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:57.625]             }
[10:32:57.625]             {
[10:32:57.625]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:57.625]                   0L) {
[10:32:57.625]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:57.625]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:57.625]                   base::options(opts)
[10:32:57.625]                 }
[10:32:57.625]                 {
[10:32:57.625]                   {
[10:32:57.625]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:57.625]                     NULL
[10:32:57.625]                   }
[10:32:57.625]                   options(future.plan = NULL)
[10:32:57.625]                   if (is.na(NA_character_)) 
[10:32:57.625]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.625]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:57.625]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:57.625]                     .init = FALSE)
[10:32:57.625]                 }
[10:32:57.625]             }
[10:32:57.625]         }
[10:32:57.625]     })
[10:32:57.625]     if (TRUE) {
[10:32:57.625]         base::sink(type = "output", split = FALSE)
[10:32:57.625]         if (TRUE) {
[10:32:57.625]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:57.625]         }
[10:32:57.625]         else {
[10:32:57.625]             ...future.result["stdout"] <- base::list(NULL)
[10:32:57.625]         }
[10:32:57.625]         base::close(...future.stdout)
[10:32:57.625]         ...future.stdout <- NULL
[10:32:57.625]     }
[10:32:57.625]     ...future.result$conditions <- ...future.conditions
[10:32:57.625]     ...future.result$finished <- base::Sys.time()
[10:32:57.625]     ...future.result
[10:32:57.625] }
[10:32:57.627] assign_globals() ...
[10:32:57.628] List of 3
[10:32:57.628]  $ outer_function:function (x)  
[10:32:57.628]  $ map           :function (.x, .f, ...)  
[10:32:57.628]  $ inner_function:function (x)  
[10:32:57.628]  - attr(*, "where")=List of 3
[10:32:57.628]   ..$ outer_function:<environment: R_EmptyEnv> 
[10:32:57.628]   ..$ map           :<environment: R_EmptyEnv> 
[10:32:57.628]   ..$ inner_function:<environment: R_EmptyEnv> 
[10:32:57.628]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:57.628]  - attr(*, "resolved")= logi FALSE
[10:32:57.628]  - attr(*, "total_size")= num 7704
[10:32:57.628]  - attr(*, "already-done")= logi TRUE
[10:32:57.631] - reassign environment for ‘outer_function’
[10:32:57.631] - copied ‘outer_function’ to environment
[10:32:57.631] - reassign environment for ‘map’
[10:32:57.632] - copied ‘map’ to environment
[10:32:57.632] - reassign environment for ‘inner_function’
[10:32:57.632] - copied ‘inner_function’ to environment
[10:32:57.632] assign_globals() ... done
[10:32:57.632] requestCore(): workers = 2
[10:32:57.634] MulticoreFuture started
[10:32:57.634] - Launch lazy future ... done
[10:32:57.634] run() for ‘MulticoreFuture’ ... done
[10:32:57.635] result() for MulticoreFuture ...
[10:32:57.635] plan(): Setting new future strategy stack:
[10:32:57.635] List of future strategies:
[10:32:57.635] 1. sequential:
[10:32:57.635]    - args: function (..., envir = parent.frame())
[10:32:57.635]    - tweaked: FALSE
[10:32:57.635]    - call: NULL
[10:32:57.636] plan(): nbrOfWorkers() = 1
[10:32:57.638] plan(): Setting new future strategy stack:
[10:32:57.639] List of future strategies:
[10:32:57.639] 1. multicore:
[10:32:57.639]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:57.639]    - tweaked: FALSE
[10:32:57.639]    - call: plan(strategy)
[10:32:57.647] plan(): nbrOfWorkers() = 2
[10:32:57.648] result() for MulticoreFuture ...
[10:32:57.649] result() for MulticoreFuture ... done
[10:32:57.649] result() for MulticoreFuture ... done
[10:32:57.649] result() for MulticoreFuture ...
[10:32:57.649] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[10:32:57.651] getGlobalsAndPackages() ...
[10:32:57.651] Searching for globals...
[10:32:57.660] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[10:32:57.660] Searching for globals ... DONE
[10:32:57.660] Resolving globals: FALSE
[10:32:57.661] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[10:32:57.662] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[10:32:57.662] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[10:32:57.662] 
[10:32:57.662] getGlobalsAndPackages() ... DONE
[10:32:57.662] run() for ‘Future’ ...
[10:32:57.663] - state: ‘created’
[10:32:57.663] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:57.667] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:57.667] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:57.667]   - Field: ‘label’
[10:32:57.667]   - Field: ‘local’
[10:32:57.667]   - Field: ‘owner’
[10:32:57.667]   - Field: ‘envir’
[10:32:57.667]   - Field: ‘workers’
[10:32:57.668]   - Field: ‘packages’
[10:32:57.668]   - Field: ‘gc’
[10:32:57.668]   - Field: ‘job’
[10:32:57.668]   - Field: ‘conditions’
[10:32:57.668]   - Field: ‘expr’
[10:32:57.668]   - Field: ‘uuid’
[10:32:57.668]   - Field: ‘seed’
[10:32:57.668]   - Field: ‘version’
[10:32:57.668]   - Field: ‘result’
[10:32:57.668]   - Field: ‘asynchronous’
[10:32:57.669]   - Field: ‘calls’
[10:32:57.669]   - Field: ‘globals’
[10:32:57.669]   - Field: ‘stdout’
[10:32:57.669]   - Field: ‘earlySignal’
[10:32:57.669]   - Field: ‘lazy’
[10:32:57.669]   - Field: ‘state’
[10:32:57.669] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:57.669] - Launch lazy future ...
[10:32:57.670] Packages needed by the future expression (n = 0): <none>
[10:32:57.670] Packages needed by future strategies (n = 0): <none>
[10:32:57.670] {
[10:32:57.670]     {
[10:32:57.670]         {
[10:32:57.670]             ...future.startTime <- base::Sys.time()
[10:32:57.670]             {
[10:32:57.670]                 {
[10:32:57.670]                   {
[10:32:57.670]                     {
[10:32:57.670]                       base::local({
[10:32:57.670]                         has_future <- base::requireNamespace("future", 
[10:32:57.670]                           quietly = TRUE)
[10:32:57.670]                         if (has_future) {
[10:32:57.670]                           ns <- base::getNamespace("future")
[10:32:57.670]                           version <- ns[[".package"]][["version"]]
[10:32:57.670]                           if (is.null(version)) 
[10:32:57.670]                             version <- utils::packageVersion("future")
[10:32:57.670]                         }
[10:32:57.670]                         else {
[10:32:57.670]                           version <- NULL
[10:32:57.670]                         }
[10:32:57.670]                         if (!has_future || version < "1.8.0") {
[10:32:57.670]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:57.670]                             "", base::R.version$version.string), 
[10:32:57.670]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:57.670]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:57.670]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:57.670]                               "release", "version")], collapse = " "), 
[10:32:57.670]                             hostname = base::Sys.info()[["nodename"]])
[10:32:57.670]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:57.670]                             info)
[10:32:57.670]                           info <- base::paste(info, collapse = "; ")
[10:32:57.670]                           if (!has_future) {
[10:32:57.670]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:57.670]                               info)
[10:32:57.670]                           }
[10:32:57.670]                           else {
[10:32:57.670]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:57.670]                               info, version)
[10:32:57.670]                           }
[10:32:57.670]                           base::stop(msg)
[10:32:57.670]                         }
[10:32:57.670]                       })
[10:32:57.670]                     }
[10:32:57.670]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:57.670]                     base::options(mc.cores = 1L)
[10:32:57.670]                   }
[10:32:57.670]                   ...future.strategy.old <- future::plan("list")
[10:32:57.670]                   options(future.plan = NULL)
[10:32:57.670]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.670]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:57.670]                 }
[10:32:57.670]                 ...future.workdir <- getwd()
[10:32:57.670]             }
[10:32:57.670]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:57.670]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:57.670]         }
[10:32:57.670]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:57.670]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:57.670]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:57.670]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:57.670]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:57.670]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:57.670]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:57.670]             base::names(...future.oldOptions))
[10:32:57.670]     }
[10:32:57.670]     if (FALSE) {
[10:32:57.670]     }
[10:32:57.670]     else {
[10:32:57.670]         if (TRUE) {
[10:32:57.670]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:57.670]                 open = "w")
[10:32:57.670]         }
[10:32:57.670]         else {
[10:32:57.670]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:57.670]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:57.670]         }
[10:32:57.670]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:57.670]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:57.670]             base::sink(type = "output", split = FALSE)
[10:32:57.670]             base::close(...future.stdout)
[10:32:57.670]         }, add = TRUE)
[10:32:57.670]     }
[10:32:57.670]     ...future.frame <- base::sys.nframe()
[10:32:57.670]     ...future.conditions <- base::list()
[10:32:57.670]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:57.670]     if (FALSE) {
[10:32:57.670]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:57.670]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:57.670]     }
[10:32:57.670]     ...future.result <- base::tryCatch({
[10:32:57.670]         base::withCallingHandlers({
[10:32:57.670]             ...future.value <- base::withVisible(base::local({
[10:32:57.670]                 withCallingHandlers({
[10:32:57.670]                   {
[10:32:57.670]                     outer_function(1L)
[10:32:57.670]                   }
[10:32:57.670]                 }, immediateCondition = function(cond) {
[10:32:57.670]                   save_rds <- function (object, pathname, ...) 
[10:32:57.670]                   {
[10:32:57.670]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:57.670]                     if (file_test("-f", pathname_tmp)) {
[10:32:57.670]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.670]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:57.670]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.670]                         fi_tmp[["mtime"]])
[10:32:57.670]                     }
[10:32:57.670]                     tryCatch({
[10:32:57.670]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:57.670]                     }, error = function(ex) {
[10:32:57.670]                       msg <- conditionMessage(ex)
[10:32:57.670]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.670]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:57.670]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.670]                         fi_tmp[["mtime"]], msg)
[10:32:57.670]                       ex$message <- msg
[10:32:57.670]                       stop(ex)
[10:32:57.670]                     })
[10:32:57.670]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:57.670]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:57.670]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:57.670]                       fi_tmp <- file.info(pathname_tmp)
[10:32:57.670]                       fi <- file.info(pathname)
[10:32:57.670]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:57.670]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:57.670]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:57.670]                         fi[["size"]], fi[["mtime"]])
[10:32:57.670]                       stop(msg)
[10:32:57.670]                     }
[10:32:57.670]                     invisible(pathname)
[10:32:57.670]                   }
[10:32:57.670]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:57.670]                     rootPath = tempdir()) 
[10:32:57.670]                   {
[10:32:57.670]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:57.670]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:57.670]                       tmpdir = path, fileext = ".rds")
[10:32:57.670]                     save_rds(obj, file)
[10:32:57.670]                   }
[10:32:57.670]                   saveImmediateCondition(cond, path = "/tmp/RtmpZSnOM5/.future/immediateConditions")
[10:32:57.670]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.670]                   {
[10:32:57.670]                     inherits <- base::inherits
[10:32:57.670]                     invokeRestart <- base::invokeRestart
[10:32:57.670]                     is.null <- base::is.null
[10:32:57.670]                     muffled <- FALSE
[10:32:57.670]                     if (inherits(cond, "message")) {
[10:32:57.670]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:57.670]                       if (muffled) 
[10:32:57.670]                         invokeRestart("muffleMessage")
[10:32:57.670]                     }
[10:32:57.670]                     else if (inherits(cond, "warning")) {
[10:32:57.670]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:57.670]                       if (muffled) 
[10:32:57.670]                         invokeRestart("muffleWarning")
[10:32:57.670]                     }
[10:32:57.670]                     else if (inherits(cond, "condition")) {
[10:32:57.670]                       if (!is.null(pattern)) {
[10:32:57.670]                         computeRestarts <- base::computeRestarts
[10:32:57.670]                         grepl <- base::grepl
[10:32:57.670]                         restarts <- computeRestarts(cond)
[10:32:57.670]                         for (restart in restarts) {
[10:32:57.670]                           name <- restart$name
[10:32:57.670]                           if (is.null(name)) 
[10:32:57.670]                             next
[10:32:57.670]                           if (!grepl(pattern, name)) 
[10:32:57.670]                             next
[10:32:57.670]                           invokeRestart(restart)
[10:32:57.670]                           muffled <- TRUE
[10:32:57.670]                           break
[10:32:57.670]                         }
[10:32:57.670]                       }
[10:32:57.670]                     }
[10:32:57.670]                     invisible(muffled)
[10:32:57.670]                   }
[10:32:57.670]                   muffleCondition(cond)
[10:32:57.670]                 })
[10:32:57.670]             }))
[10:32:57.670]             future::FutureResult(value = ...future.value$value, 
[10:32:57.670]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.670]                   ...future.rng), globalenv = if (FALSE) 
[10:32:57.670]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:57.670]                     ...future.globalenv.names))
[10:32:57.670]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:57.670]         }, condition = base::local({
[10:32:57.670]             c <- base::c
[10:32:57.670]             inherits <- base::inherits
[10:32:57.670]             invokeRestart <- base::invokeRestart
[10:32:57.670]             length <- base::length
[10:32:57.670]             list <- base::list
[10:32:57.670]             seq.int <- base::seq.int
[10:32:57.670]             signalCondition <- base::signalCondition
[10:32:57.670]             sys.calls <- base::sys.calls
[10:32:57.670]             `[[` <- base::`[[`
[10:32:57.670]             `+` <- base::`+`
[10:32:57.670]             `<<-` <- base::`<<-`
[10:32:57.670]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:57.670]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:57.670]                   3L)]
[10:32:57.670]             }
[10:32:57.670]             function(cond) {
[10:32:57.670]                 is_error <- inherits(cond, "error")
[10:32:57.670]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:57.670]                   NULL)
[10:32:57.670]                 if (is_error) {
[10:32:57.670]                   sessionInformation <- function() {
[10:32:57.670]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:57.670]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:57.670]                       search = base::search(), system = base::Sys.info())
[10:32:57.670]                   }
[10:32:57.670]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.670]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:57.670]                     cond$call), session = sessionInformation(), 
[10:32:57.670]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:57.670]                   signalCondition(cond)
[10:32:57.670]                 }
[10:32:57.670]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:57.670]                 "immediateCondition"))) {
[10:32:57.670]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:57.670]                   ...future.conditions[[length(...future.conditions) + 
[10:32:57.670]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:57.670]                   if (TRUE && !signal) {
[10:32:57.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.670]                     {
[10:32:57.670]                       inherits <- base::inherits
[10:32:57.670]                       invokeRestart <- base::invokeRestart
[10:32:57.670]                       is.null <- base::is.null
[10:32:57.670]                       muffled <- FALSE
[10:32:57.670]                       if (inherits(cond, "message")) {
[10:32:57.670]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.670]                         if (muffled) 
[10:32:57.670]                           invokeRestart("muffleMessage")
[10:32:57.670]                       }
[10:32:57.670]                       else if (inherits(cond, "warning")) {
[10:32:57.670]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.670]                         if (muffled) 
[10:32:57.670]                           invokeRestart("muffleWarning")
[10:32:57.670]                       }
[10:32:57.670]                       else if (inherits(cond, "condition")) {
[10:32:57.670]                         if (!is.null(pattern)) {
[10:32:57.670]                           computeRestarts <- base::computeRestarts
[10:32:57.670]                           grepl <- base::grepl
[10:32:57.670]                           restarts <- computeRestarts(cond)
[10:32:57.670]                           for (restart in restarts) {
[10:32:57.670]                             name <- restart$name
[10:32:57.670]                             if (is.null(name)) 
[10:32:57.670]                               next
[10:32:57.670]                             if (!grepl(pattern, name)) 
[10:32:57.670]                               next
[10:32:57.670]                             invokeRestart(restart)
[10:32:57.670]                             muffled <- TRUE
[10:32:57.670]                             break
[10:32:57.670]                           }
[10:32:57.670]                         }
[10:32:57.670]                       }
[10:32:57.670]                       invisible(muffled)
[10:32:57.670]                     }
[10:32:57.670]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.670]                   }
[10:32:57.670]                 }
[10:32:57.670]                 else {
[10:32:57.670]                   if (TRUE) {
[10:32:57.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:57.670]                     {
[10:32:57.670]                       inherits <- base::inherits
[10:32:57.670]                       invokeRestart <- base::invokeRestart
[10:32:57.670]                       is.null <- base::is.null
[10:32:57.670]                       muffled <- FALSE
[10:32:57.670]                       if (inherits(cond, "message")) {
[10:32:57.670]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:57.670]                         if (muffled) 
[10:32:57.670]                           invokeRestart("muffleMessage")
[10:32:57.670]                       }
[10:32:57.670]                       else if (inherits(cond, "warning")) {
[10:32:57.670]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:57.670]                         if (muffled) 
[10:32:57.670]                           invokeRestart("muffleWarning")
[10:32:57.670]                       }
[10:32:57.670]                       else if (inherits(cond, "condition")) {
[10:32:57.670]                         if (!is.null(pattern)) {
[10:32:57.670]                           computeRestarts <- base::computeRestarts
[10:32:57.670]                           grepl <- base::grepl
[10:32:57.670]                           restarts <- computeRestarts(cond)
[10:32:57.670]                           for (restart in restarts) {
[10:32:57.670]                             name <- restart$name
[10:32:57.670]                             if (is.null(name)) 
[10:32:57.670]                               next
[10:32:57.670]                             if (!grepl(pattern, name)) 
[10:32:57.670]                               next
[10:32:57.670]                             invokeRestart(restart)
[10:32:57.670]                             muffled <- TRUE
[10:32:57.670]                             break
[10:32:57.670]                           }
[10:32:57.670]                         }
[10:32:57.670]                       }
[10:32:57.670]                       invisible(muffled)
[10:32:57.670]                     }
[10:32:57.670]                     muffleCondition(cond, pattern = "^muffle")
[10:32:57.670]                   }
[10:32:57.670]                 }
[10:32:57.670]             }
[10:32:57.670]         }))
[10:32:57.670]     }, error = function(ex) {
[10:32:57.670]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:57.670]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:57.670]                 ...future.rng), started = ...future.startTime, 
[10:32:57.670]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:57.670]             version = "1.8"), class = "FutureResult")
[10:32:57.670]     }, finally = {
[10:32:57.670]         if (!identical(...future.workdir, getwd())) 
[10:32:57.670]             setwd(...future.workdir)
[10:32:57.670]         {
[10:32:57.670]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:57.670]                 ...future.oldOptions$nwarnings <- NULL
[10:32:57.670]             }
[10:32:57.670]             base::options(...future.oldOptions)
[10:32:57.670]             if (.Platform$OS.type == "windows") {
[10:32:57.670]                 old_names <- names(...future.oldEnvVars)
[10:32:57.670]                 envs <- base::Sys.getenv()
[10:32:57.670]                 names <- names(envs)
[10:32:57.670]                 common <- intersect(names, old_names)
[10:32:57.670]                 added <- setdiff(names, old_names)
[10:32:57.670]                 removed <- setdiff(old_names, names)
[10:32:57.670]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:57.670]                   envs[common]]
[10:32:57.670]                 NAMES <- toupper(changed)
[10:32:57.670]                 args <- list()
[10:32:57.670]                 for (kk in seq_along(NAMES)) {
[10:32:57.670]                   name <- changed[[kk]]
[10:32:57.670]                   NAME <- NAMES[[kk]]
[10:32:57.670]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.670]                     next
[10:32:57.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.670]                 }
[10:32:57.670]                 NAMES <- toupper(added)
[10:32:57.670]                 for (kk in seq_along(NAMES)) {
[10:32:57.670]                   name <- added[[kk]]
[10:32:57.670]                   NAME <- NAMES[[kk]]
[10:32:57.670]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.670]                     next
[10:32:57.670]                   args[[name]] <- ""
[10:32:57.670]                 }
[10:32:57.670]                 NAMES <- toupper(removed)
[10:32:57.670]                 for (kk in seq_along(NAMES)) {
[10:32:57.670]                   name <- removed[[kk]]
[10:32:57.670]                   NAME <- NAMES[[kk]]
[10:32:57.670]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:57.670]                     next
[10:32:57.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:57.670]                 }
[10:32:57.670]                 if (length(args) > 0) 
[10:32:57.670]                   base::do.call(base::Sys.setenv, args = args)
[10:32:57.670]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:57.670]             }
[10:32:57.670]             else {
[10:32:57.670]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:57.670]             }
[10:32:57.670]             {
[10:32:57.670]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:57.670]                   0L) {
[10:32:57.670]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:57.670]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:57.670]                   base::options(opts)
[10:32:57.670]                 }
[10:32:57.670]                 {
[10:32:57.670]                   {
[10:32:57.670]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:57.670]                     NULL
[10:32:57.670]                   }
[10:32:57.670]                   options(future.plan = NULL)
[10:32:57.670]                   if (is.na(NA_character_)) 
[10:32:57.670]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:57.670]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:57.670]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:57.670]                     .init = FALSE)
[10:32:57.670]                 }
[10:32:57.670]             }
[10:32:57.670]         }
[10:32:57.670]     })
[10:32:57.670]     if (TRUE) {
[10:32:57.670]         base::sink(type = "output", split = FALSE)
[10:32:57.670]         if (TRUE) {
[10:32:57.670]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:57.670]         }
[10:32:57.670]         else {
[10:32:57.670]             ...future.result["stdout"] <- base::list(NULL)
[10:32:57.670]         }
[10:32:57.670]         base::close(...future.stdout)
[10:32:57.670]         ...future.stdout <- NULL
[10:32:57.670]     }
[10:32:57.670]     ...future.result$conditions <- ...future.conditions
[10:32:57.670]     ...future.result$finished <- base::Sys.time()
[10:32:57.670]     ...future.result
[10:32:57.670] }
[10:32:57.673] assign_globals() ...
[10:32:57.673] List of 3
[10:32:57.673]  $ outer_function:function (x)  
[10:32:57.673]  $ map           :function (.x, .f, ...)  
[10:32:57.673]  $ inner_function:function (x)  
[10:32:57.673]  - attr(*, "where")=List of 3
[10:32:57.673]   ..$ outer_function:<environment: R_EmptyEnv> 
[10:32:57.673]   ..$ map           :<environment: R_EmptyEnv> 
[10:32:57.673]   ..$ inner_function:<environment: R_EmptyEnv> 
[10:32:57.673]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:57.673]  - attr(*, "resolved")= logi FALSE
[10:32:57.673]  - attr(*, "total_size")= num 7704
[10:32:57.673]  - attr(*, "already-done")= logi TRUE
[10:32:57.676] - reassign environment for ‘outer_function’
[10:32:57.676] - copied ‘outer_function’ to environment
[10:32:57.676] - reassign environment for ‘map’
[10:32:57.677] - copied ‘map’ to environment
[10:32:57.677] - reassign environment for ‘inner_function’
[10:32:57.677] - copied ‘inner_function’ to environment
[10:32:57.677] assign_globals() ... done
[10:32:57.677] requestCore(): workers = 2
[10:32:57.679] MulticoreFuture started
[10:32:57.679] - Launch lazy future ... done
[10:32:57.680] run() for ‘MulticoreFuture’ ... done
[10:32:57.680] result() for MulticoreFuture ...
[10:32:57.680] plan(): Setting new future strategy stack:
[10:32:57.680] List of future strategies:
[10:32:57.680] 1. sequential:
[10:32:57.680]    - args: function (..., envir = parent.frame())
[10:32:57.680]    - tweaked: FALSE
[10:32:57.680]    - call: NULL
[10:32:57.681] plan(): nbrOfWorkers() = 1
[10:32:57.684] plan(): Setting new future strategy stack:
[10:32:57.684] List of future strategies:
[10:32:57.684] 1. multicore:
[10:32:57.684]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:57.684]    - tweaked: FALSE
[10:32:57.684]    - call: plan(strategy)
[10:32:57.689] plan(): nbrOfWorkers() = 2
[10:32:57.690] result() for MulticoreFuture ...
[10:32:57.690] result() for MulticoreFuture ... done
[10:32:57.690] result() for MulticoreFuture ... done
[10:32:57.690] result() for MulticoreFuture ...
[10:32:57.691] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
- plan('multisession') ...
[10:32:57.693] plan(): Setting new future strategy stack:
[10:32:57.693] List of future strategies:
[10:32:57.693] 1. multisession:
[10:32:57.693]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:32:57.693]    - tweaked: FALSE
[10:32:57.693]    - call: plan(strategy)
[10:32:57.693] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:32:57.693] multisession:
[10:32:57.693] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:32:57.693] - tweaked: FALSE
[10:32:57.693] - call: plan(strategy)
[10:32:57.703] getGlobalsAndPackages() ...
[10:32:57.703] Not searching for globals
[10:32:57.704] - globals: [0] <none>
[10:32:57.704] getGlobalsAndPackages() ... DONE
[10:32:57.704] [local output] makeClusterPSOCK() ...
[10:32:57.746] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:32:57.747] [local output] Base port: 11541
[10:32:57.747] [local output] Getting setup options for 2 cluster nodes ...
[10:32:57.747] [local output]  - Node 1 of 2 ...
[10:32:57.748] [local output] localMachine=TRUE => revtunnel=FALSE

[10:32:57.748] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpZSnOM5/worker.rank=1.parallelly.parent=82426.141fa1e489bc6.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpZSnOM5/worker.rank=1.parallelly.parent=82426.141fa1e489bc6.pid")'’
[10:32:57.936] - Possible to infer worker's PID: TRUE
[10:32:57.937] [local output] Rscript port: 11541

[10:32:57.937] [local output]  - Node 2 of 2 ...
[10:32:57.938] [local output] localMachine=TRUE => revtunnel=FALSE

[10:32:57.938] [local output] Rscript port: 11541

[10:32:57.938] [local output] Getting setup options for 2 cluster nodes ... done
[10:32:57.939] [local output]  - Parallel setup requested for some PSOCK nodes
[10:32:57.939] [local output] Setting up PSOCK nodes in parallel
[10:32:57.939] List of 36
[10:32:57.939]  $ worker          : chr "localhost"
[10:32:57.939]   ..- attr(*, "localhost")= logi TRUE
[10:32:57.939]  $ master          : chr "localhost"
[10:32:57.939]  $ port            : int 11541
[10:32:57.939]  $ connectTimeout  : num 120
[10:32:57.939]  $ timeout         : num 2592000
[10:32:57.939]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:32:57.939]  $ homogeneous     : logi TRUE
[10:32:57.939]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:32:57.939]  $ rscript_envs    : NULL
[10:32:57.939]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:32:57.939]  $ rscript_startup : NULL
[10:32:57.939]  $ rscript_sh      : chr "sh"
[10:32:57.939]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:32:57.939]  $ methods         : logi TRUE
[10:32:57.939]  $ socketOptions   : chr "no-delay"
[10:32:57.939]  $ useXDR          : logi FALSE
[10:32:57.939]  $ outfile         : chr "/dev/null"
[10:32:57.939]  $ renice          : int NA
[10:32:57.939]  $ rshcmd          : NULL
[10:32:57.939]  $ user            : chr(0) 
[10:32:57.939]  $ revtunnel       : logi FALSE
[10:32:57.939]  $ rshlogfile      : NULL
[10:32:57.939]  $ rshopts         : chr(0) 
[10:32:57.939]  $ rank            : int 1
[10:32:57.939]  $ manual          : logi FALSE
[10:32:57.939]  $ dryrun          : logi FALSE
[10:32:57.939]  $ quiet           : logi FALSE
[10:32:57.939]  $ setup_strategy  : chr "parallel"
[10:32:57.939]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:32:57.939]  $ pidfile         : chr "/tmp/RtmpZSnOM5/worker.rank=1.parallelly.parent=82426.141fa1e489bc6.pid"
[10:32:57.939]  $ rshcmd_label    : NULL
[10:32:57.939]  $ rsh_call        : NULL
[10:32:57.939]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:32:57.939]  $ localMachine    : logi TRUE
[10:32:57.939]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:32:57.939]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:32:57.939]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:32:57.939]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:32:57.939]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:32:57.939]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:32:57.939]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:32:57.939]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:32:57.939]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:32:57.939]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:32:57.939]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:32:57.939]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:32:57.939]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:32:57.939]  $ arguments       :List of 28
[10:32:57.939]   ..$ worker          : chr "localhost"
[10:32:57.939]   ..$ master          : NULL
[10:32:57.939]   ..$ port            : int 11541
[10:32:57.939]   ..$ connectTimeout  : num 120
[10:32:57.939]   ..$ timeout         : num 2592000
[10:32:57.939]   ..$ rscript         : NULL
[10:32:57.939]   ..$ homogeneous     : NULL
[10:32:57.939]   ..$ rscript_args    : NULL
[10:32:57.939]   ..$ rscript_envs    : NULL
[10:32:57.939]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:32:57.939]   ..$ rscript_startup : NULL
[10:32:57.939]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:32:57.939]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:32:57.939]   ..$ methods         : logi TRUE
[10:32:57.939]   ..$ socketOptions   : chr "no-delay"
[10:32:57.939]   ..$ useXDR          : logi FALSE
[10:32:57.939]   ..$ outfile         : chr "/dev/null"
[10:32:57.939]   ..$ renice          : int NA
[10:32:57.939]   ..$ rshcmd          : NULL
[10:32:57.939]   ..$ user            : NULL
[10:32:57.939]   ..$ revtunnel       : logi NA
[10:32:57.939]   ..$ rshlogfile      : NULL
[10:32:57.939]   ..$ rshopts         : NULL
[10:32:57.939]   ..$ rank            : int 1
[10:32:57.939]   ..$ manual          : logi FALSE
[10:32:57.939]   ..$ dryrun          : logi FALSE
[10:32:57.939]   ..$ quiet           : logi FALSE
[10:32:57.939]   ..$ setup_strategy  : chr "parallel"
[10:32:57.939]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:32:57.956] [local output] System call to launch all workers:
[10:32:57.956] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpZSnOM5/worker.rank=1.parallelly.parent=82426.141fa1e489bc6.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11541 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:32:57.956] [local output] Starting PSOCK main server
[10:32:57.962] [local output] Workers launched
[10:32:57.962] [local output] Waiting for workers to connect back
[10:32:57.962]  - [local output] 0 workers out of 2 ready
[10:32:58.203]  - [local output] 0 workers out of 2 ready
[10:32:58.203]  - [local output] 1 workers out of 2 ready
[10:32:58.204]  - [local output] 2 workers out of 2 ready
[10:32:58.204] [local output] Launching of workers completed
[10:32:58.204] [local output] Collecting session information from workers
[10:32:58.205] [local output]  - Worker #1 of 2
[10:32:58.205] [local output]  - Worker #2 of 2
[10:32:58.205] [local output] makeClusterPSOCK() ... done
[10:32:58.217] Packages needed by the future expression (n = 0): <none>
[10:32:58.217] Packages needed by future strategies (n = 0): <none>
[10:32:58.218] {
[10:32:58.218]     {
[10:32:58.218]         {
[10:32:58.218]             ...future.startTime <- base::Sys.time()
[10:32:58.218]             {
[10:32:58.218]                 {
[10:32:58.218]                   {
[10:32:58.218]                     {
[10:32:58.218]                       base::local({
[10:32:58.218]                         has_future <- base::requireNamespace("future", 
[10:32:58.218]                           quietly = TRUE)
[10:32:58.218]                         if (has_future) {
[10:32:58.218]                           ns <- base::getNamespace("future")
[10:32:58.218]                           version <- ns[[".package"]][["version"]]
[10:32:58.218]                           if (is.null(version)) 
[10:32:58.218]                             version <- utils::packageVersion("future")
[10:32:58.218]                         }
[10:32:58.218]                         else {
[10:32:58.218]                           version <- NULL
[10:32:58.218]                         }
[10:32:58.218]                         if (!has_future || version < "1.8.0") {
[10:32:58.218]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:58.218]                             "", base::R.version$version.string), 
[10:32:58.218]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:58.218]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:58.218]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:58.218]                               "release", "version")], collapse = " "), 
[10:32:58.218]                             hostname = base::Sys.info()[["nodename"]])
[10:32:58.218]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:58.218]                             info)
[10:32:58.218]                           info <- base::paste(info, collapse = "; ")
[10:32:58.218]                           if (!has_future) {
[10:32:58.218]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:58.218]                               info)
[10:32:58.218]                           }
[10:32:58.218]                           else {
[10:32:58.218]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:58.218]                               info, version)
[10:32:58.218]                           }
[10:32:58.218]                           base::stop(msg)
[10:32:58.218]                         }
[10:32:58.218]                       })
[10:32:58.218]                     }
[10:32:58.218]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:58.218]                     base::options(mc.cores = 1L)
[10:32:58.218]                   }
[10:32:58.218]                   ...future.strategy.old <- future::plan("list")
[10:32:58.218]                   options(future.plan = NULL)
[10:32:58.218]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:58.218]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:58.218]                 }
[10:32:58.218]                 ...future.workdir <- getwd()
[10:32:58.218]             }
[10:32:58.218]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:58.218]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:58.218]         }
[10:32:58.218]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:58.218]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:58.218]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:58.218]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:58.218]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:58.218]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:58.218]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:58.218]             base::names(...future.oldOptions))
[10:32:58.218]     }
[10:32:58.218]     if (FALSE) {
[10:32:58.218]     }
[10:32:58.218]     else {
[10:32:58.218]         if (TRUE) {
[10:32:58.218]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:58.218]                 open = "w")
[10:32:58.218]         }
[10:32:58.218]         else {
[10:32:58.218]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:58.218]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:58.218]         }
[10:32:58.218]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:58.218]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:58.218]             base::sink(type = "output", split = FALSE)
[10:32:58.218]             base::close(...future.stdout)
[10:32:58.218]         }, add = TRUE)
[10:32:58.218]     }
[10:32:58.218]     ...future.frame <- base::sys.nframe()
[10:32:58.218]     ...future.conditions <- base::list()
[10:32:58.218]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:58.218]     if (FALSE) {
[10:32:58.218]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:58.218]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:58.218]     }
[10:32:58.218]     ...future.result <- base::tryCatch({
[10:32:58.218]         base::withCallingHandlers({
[10:32:58.218]             ...future.value <- base::withVisible(base::local({
[10:32:58.218]                 ...future.makeSendCondition <- base::local({
[10:32:58.218]                   sendCondition <- NULL
[10:32:58.218]                   function(frame = 1L) {
[10:32:58.218]                     if (is.function(sendCondition)) 
[10:32:58.218]                       return(sendCondition)
[10:32:58.218]                     ns <- getNamespace("parallel")
[10:32:58.218]                     if (exists("sendData", mode = "function", 
[10:32:58.218]                       envir = ns)) {
[10:32:58.218]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:58.218]                         envir = ns)
[10:32:58.218]                       envir <- sys.frame(frame)
[10:32:58.218]                       master <- NULL
[10:32:58.218]                       while (!identical(envir, .GlobalEnv) && 
[10:32:58.218]                         !identical(envir, emptyenv())) {
[10:32:58.218]                         if (exists("master", mode = "list", envir = envir, 
[10:32:58.218]                           inherits = FALSE)) {
[10:32:58.218]                           master <- get("master", mode = "list", 
[10:32:58.218]                             envir = envir, inherits = FALSE)
[10:32:58.218]                           if (inherits(master, c("SOCKnode", 
[10:32:58.218]                             "SOCK0node"))) {
[10:32:58.218]                             sendCondition <<- function(cond) {
[10:32:58.218]                               data <- list(type = "VALUE", value = cond, 
[10:32:58.218]                                 success = TRUE)
[10:32:58.218]                               parallel_sendData(master, data)
[10:32:58.218]                             }
[10:32:58.218]                             return(sendCondition)
[10:32:58.218]                           }
[10:32:58.218]                         }
[10:32:58.218]                         frame <- frame + 1L
[10:32:58.218]                         envir <- sys.frame(frame)
[10:32:58.218]                       }
[10:32:58.218]                     }
[10:32:58.218]                     sendCondition <<- function(cond) NULL
[10:32:58.218]                   }
[10:32:58.218]                 })
[10:32:58.218]                 withCallingHandlers({
[10:32:58.218]                   NA
[10:32:58.218]                 }, immediateCondition = function(cond) {
[10:32:58.218]                   sendCondition <- ...future.makeSendCondition()
[10:32:58.218]                   sendCondition(cond)
[10:32:58.218]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.218]                   {
[10:32:58.218]                     inherits <- base::inherits
[10:32:58.218]                     invokeRestart <- base::invokeRestart
[10:32:58.218]                     is.null <- base::is.null
[10:32:58.218]                     muffled <- FALSE
[10:32:58.218]                     if (inherits(cond, "message")) {
[10:32:58.218]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:58.218]                       if (muffled) 
[10:32:58.218]                         invokeRestart("muffleMessage")
[10:32:58.218]                     }
[10:32:58.218]                     else if (inherits(cond, "warning")) {
[10:32:58.218]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:58.218]                       if (muffled) 
[10:32:58.218]                         invokeRestart("muffleWarning")
[10:32:58.218]                     }
[10:32:58.218]                     else if (inherits(cond, "condition")) {
[10:32:58.218]                       if (!is.null(pattern)) {
[10:32:58.218]                         computeRestarts <- base::computeRestarts
[10:32:58.218]                         grepl <- base::grepl
[10:32:58.218]                         restarts <- computeRestarts(cond)
[10:32:58.218]                         for (restart in restarts) {
[10:32:58.218]                           name <- restart$name
[10:32:58.218]                           if (is.null(name)) 
[10:32:58.218]                             next
[10:32:58.218]                           if (!grepl(pattern, name)) 
[10:32:58.218]                             next
[10:32:58.218]                           invokeRestart(restart)
[10:32:58.218]                           muffled <- TRUE
[10:32:58.218]                           break
[10:32:58.218]                         }
[10:32:58.218]                       }
[10:32:58.218]                     }
[10:32:58.218]                     invisible(muffled)
[10:32:58.218]                   }
[10:32:58.218]                   muffleCondition(cond)
[10:32:58.218]                 })
[10:32:58.218]             }))
[10:32:58.218]             future::FutureResult(value = ...future.value$value, 
[10:32:58.218]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:58.218]                   ...future.rng), globalenv = if (FALSE) 
[10:32:58.218]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:58.218]                     ...future.globalenv.names))
[10:32:58.218]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:58.218]         }, condition = base::local({
[10:32:58.218]             c <- base::c
[10:32:58.218]             inherits <- base::inherits
[10:32:58.218]             invokeRestart <- base::invokeRestart
[10:32:58.218]             length <- base::length
[10:32:58.218]             list <- base::list
[10:32:58.218]             seq.int <- base::seq.int
[10:32:58.218]             signalCondition <- base::signalCondition
[10:32:58.218]             sys.calls <- base::sys.calls
[10:32:58.218]             `[[` <- base::`[[`
[10:32:58.218]             `+` <- base::`+`
[10:32:58.218]             `<<-` <- base::`<<-`
[10:32:58.218]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:58.218]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:58.218]                   3L)]
[10:32:58.218]             }
[10:32:58.218]             function(cond) {
[10:32:58.218]                 is_error <- inherits(cond, "error")
[10:32:58.218]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:58.218]                   NULL)
[10:32:58.218]                 if (is_error) {
[10:32:58.218]                   sessionInformation <- function() {
[10:32:58.218]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:58.218]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:58.218]                       search = base::search(), system = base::Sys.info())
[10:32:58.218]                   }
[10:32:58.218]                   ...future.conditions[[length(...future.conditions) + 
[10:32:58.218]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:58.218]                     cond$call), session = sessionInformation(), 
[10:32:58.218]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:58.218]                   signalCondition(cond)
[10:32:58.218]                 }
[10:32:58.218]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:58.218]                 "immediateCondition"))) {
[10:32:58.218]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:58.218]                   ...future.conditions[[length(...future.conditions) + 
[10:32:58.218]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:58.218]                   if (TRUE && !signal) {
[10:32:58.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.218]                     {
[10:32:58.218]                       inherits <- base::inherits
[10:32:58.218]                       invokeRestart <- base::invokeRestart
[10:32:58.218]                       is.null <- base::is.null
[10:32:58.218]                       muffled <- FALSE
[10:32:58.218]                       if (inherits(cond, "message")) {
[10:32:58.218]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:58.218]                         if (muffled) 
[10:32:58.218]                           invokeRestart("muffleMessage")
[10:32:58.218]                       }
[10:32:58.218]                       else if (inherits(cond, "warning")) {
[10:32:58.218]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:58.218]                         if (muffled) 
[10:32:58.218]                           invokeRestart("muffleWarning")
[10:32:58.218]                       }
[10:32:58.218]                       else if (inherits(cond, "condition")) {
[10:32:58.218]                         if (!is.null(pattern)) {
[10:32:58.218]                           computeRestarts <- base::computeRestarts
[10:32:58.218]                           grepl <- base::grepl
[10:32:58.218]                           restarts <- computeRestarts(cond)
[10:32:58.218]                           for (restart in restarts) {
[10:32:58.218]                             name <- restart$name
[10:32:58.218]                             if (is.null(name)) 
[10:32:58.218]                               next
[10:32:58.218]                             if (!grepl(pattern, name)) 
[10:32:58.218]                               next
[10:32:58.218]                             invokeRestart(restart)
[10:32:58.218]                             muffled <- TRUE
[10:32:58.218]                             break
[10:32:58.218]                           }
[10:32:58.218]                         }
[10:32:58.218]                       }
[10:32:58.218]                       invisible(muffled)
[10:32:58.218]                     }
[10:32:58.218]                     muffleCondition(cond, pattern = "^muffle")
[10:32:58.218]                   }
[10:32:58.218]                 }
[10:32:58.218]                 else {
[10:32:58.218]                   if (TRUE) {
[10:32:58.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.218]                     {
[10:32:58.218]                       inherits <- base::inherits
[10:32:58.218]                       invokeRestart <- base::invokeRestart
[10:32:58.218]                       is.null <- base::is.null
[10:32:58.218]                       muffled <- FALSE
[10:32:58.218]                       if (inherits(cond, "message")) {
[10:32:58.218]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:58.218]                         if (muffled) 
[10:32:58.218]                           invokeRestart("muffleMessage")
[10:32:58.218]                       }
[10:32:58.218]                       else if (inherits(cond, "warning")) {
[10:32:58.218]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:58.218]                         if (muffled) 
[10:32:58.218]                           invokeRestart("muffleWarning")
[10:32:58.218]                       }
[10:32:58.218]                       else if (inherits(cond, "condition")) {
[10:32:58.218]                         if (!is.null(pattern)) {
[10:32:58.218]                           computeRestarts <- base::computeRestarts
[10:32:58.218]                           grepl <- base::grepl
[10:32:58.218]                           restarts <- computeRestarts(cond)
[10:32:58.218]                           for (restart in restarts) {
[10:32:58.218]                             name <- restart$name
[10:32:58.218]                             if (is.null(name)) 
[10:32:58.218]                               next
[10:32:58.218]                             if (!grepl(pattern, name)) 
[10:32:58.218]                               next
[10:32:58.218]                             invokeRestart(restart)
[10:32:58.218]                             muffled <- TRUE
[10:32:58.218]                             break
[10:32:58.218]                           }
[10:32:58.218]                         }
[10:32:58.218]                       }
[10:32:58.218]                       invisible(muffled)
[10:32:58.218]                     }
[10:32:58.218]                     muffleCondition(cond, pattern = "^muffle")
[10:32:58.218]                   }
[10:32:58.218]                 }
[10:32:58.218]             }
[10:32:58.218]         }))
[10:32:58.218]     }, error = function(ex) {
[10:32:58.218]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:58.218]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:58.218]                 ...future.rng), started = ...future.startTime, 
[10:32:58.218]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:58.218]             version = "1.8"), class = "FutureResult")
[10:32:58.218]     }, finally = {
[10:32:58.218]         if (!identical(...future.workdir, getwd())) 
[10:32:58.218]             setwd(...future.workdir)
[10:32:58.218]         {
[10:32:58.218]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:58.218]                 ...future.oldOptions$nwarnings <- NULL
[10:32:58.218]             }
[10:32:58.218]             base::options(...future.oldOptions)
[10:32:58.218]             if (.Platform$OS.type == "windows") {
[10:32:58.218]                 old_names <- names(...future.oldEnvVars)
[10:32:58.218]                 envs <- base::Sys.getenv()
[10:32:58.218]                 names <- names(envs)
[10:32:58.218]                 common <- intersect(names, old_names)
[10:32:58.218]                 added <- setdiff(names, old_names)
[10:32:58.218]                 removed <- setdiff(old_names, names)
[10:32:58.218]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:58.218]                   envs[common]]
[10:32:58.218]                 NAMES <- toupper(changed)
[10:32:58.218]                 args <- list()
[10:32:58.218]                 for (kk in seq_along(NAMES)) {
[10:32:58.218]                   name <- changed[[kk]]
[10:32:58.218]                   NAME <- NAMES[[kk]]
[10:32:58.218]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.218]                     next
[10:32:58.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:58.218]                 }
[10:32:58.218]                 NAMES <- toupper(added)
[10:32:58.218]                 for (kk in seq_along(NAMES)) {
[10:32:58.218]                   name <- added[[kk]]
[10:32:58.218]                   NAME <- NAMES[[kk]]
[10:32:58.218]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.218]                     next
[10:32:58.218]                   args[[name]] <- ""
[10:32:58.218]                 }
[10:32:58.218]                 NAMES <- toupper(removed)
[10:32:58.218]                 for (kk in seq_along(NAMES)) {
[10:32:58.218]                   name <- removed[[kk]]
[10:32:58.218]                   NAME <- NAMES[[kk]]
[10:32:58.218]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.218]                     next
[10:32:58.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:58.218]                 }
[10:32:58.218]                 if (length(args) > 0) 
[10:32:58.218]                   base::do.call(base::Sys.setenv, args = args)
[10:32:58.218]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:58.218]             }
[10:32:58.218]             else {
[10:32:58.218]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:58.218]             }
[10:32:58.218]             {
[10:32:58.218]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:58.218]                   0L) {
[10:32:58.218]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:58.218]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:58.218]                   base::options(opts)
[10:32:58.218]                 }
[10:32:58.218]                 {
[10:32:58.218]                   {
[10:32:58.218]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:58.218]                     NULL
[10:32:58.218]                   }
[10:32:58.218]                   options(future.plan = NULL)
[10:32:58.218]                   if (is.na(NA_character_)) 
[10:32:58.218]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:58.218]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:58.218]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:58.218]                     .init = FALSE)
[10:32:58.218]                 }
[10:32:58.218]             }
[10:32:58.218]         }
[10:32:58.218]     })
[10:32:58.218]     if (TRUE) {
[10:32:58.218]         base::sink(type = "output", split = FALSE)
[10:32:58.218]         if (TRUE) {
[10:32:58.218]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:58.218]         }
[10:32:58.218]         else {
[10:32:58.218]             ...future.result["stdout"] <- base::list(NULL)
[10:32:58.218]         }
[10:32:58.218]         base::close(...future.stdout)
[10:32:58.218]         ...future.stdout <- NULL
[10:32:58.218]     }
[10:32:58.218]     ...future.result$conditions <- ...future.conditions
[10:32:58.218]     ...future.result$finished <- base::Sys.time()
[10:32:58.218]     ...future.result
[10:32:58.218] }
[10:32:58.270] MultisessionFuture started
[10:32:58.270] result() for ClusterFuture ...
[10:32:58.271] receiveMessageFromWorker() for ClusterFuture ...
[10:32:58.271] - Validating connection of MultisessionFuture
[10:32:58.303] - received message: FutureResult
[10:32:58.303] - Received FutureResult
[10:32:58.303] - Erased future from FutureRegistry
[10:32:58.303] result() for ClusterFuture ...
[10:32:58.304] - result already collected: FutureResult
[10:32:58.304] result() for ClusterFuture ... done
[10:32:58.304] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:58.304] result() for ClusterFuture ... done
[10:32:58.304] result() for ClusterFuture ...
[10:32:58.304] - result already collected: FutureResult
[10:32:58.304] result() for ClusterFuture ... done
[10:32:58.304] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:32:58.308] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[10:32:58.308] getGlobalsAndPackages() ...
[10:32:58.309] Searching for globals...
[10:32:58.311] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:32:58.311] Searching for globals ... DONE
[10:32:58.311] Resolving globals: FALSE
[10:32:58.311] The total size of the 2 globals is 896 bytes (896 bytes)
[10:32:58.312] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:32:58.312] - globals: [2] ‘weight’, ‘group’
[10:32:58.312] - packages: [1] ‘stats’
[10:32:58.312] getGlobalsAndPackages() ... DONE
[10:32:58.313] run() for ‘Future’ ...
[10:32:58.313] - state: ‘created’
[10:32:58.313] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:58.328] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:58.328] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:58.328]   - Field: ‘node’
[10:32:58.328]   - Field: ‘label’
[10:32:58.328]   - Field: ‘local’
[10:32:58.329]   - Field: ‘owner’
[10:32:58.329]   - Field: ‘envir’
[10:32:58.329]   - Field: ‘workers’
[10:32:58.329]   - Field: ‘packages’
[10:32:58.329]   - Field: ‘gc’
[10:32:58.329]   - Field: ‘conditions’
[10:32:58.329]   - Field: ‘persistent’
[10:32:58.329]   - Field: ‘expr’
[10:32:58.329]   - Field: ‘uuid’
[10:32:58.330]   - Field: ‘seed’
[10:32:58.330]   - Field: ‘version’
[10:32:58.330]   - Field: ‘result’
[10:32:58.330]   - Field: ‘asynchronous’
[10:32:58.330]   - Field: ‘calls’
[10:32:58.330]   - Field: ‘globals’
[10:32:58.330]   - Field: ‘stdout’
[10:32:58.330]   - Field: ‘earlySignal’
[10:32:58.330]   - Field: ‘lazy’
[10:32:58.331]   - Field: ‘state’
[10:32:58.331] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:58.331] - Launch lazy future ...
[10:32:58.331] Packages needed by the future expression (n = 1): ‘stats’
[10:32:58.331] Packages needed by future strategies (n = 0): <none>
[10:32:58.332] {
[10:32:58.332]     {
[10:32:58.332]         {
[10:32:58.332]             ...future.startTime <- base::Sys.time()
[10:32:58.332]             {
[10:32:58.332]                 {
[10:32:58.332]                   {
[10:32:58.332]                     {
[10:32:58.332]                       {
[10:32:58.332]                         base::local({
[10:32:58.332]                           has_future <- base::requireNamespace("future", 
[10:32:58.332]                             quietly = TRUE)
[10:32:58.332]                           if (has_future) {
[10:32:58.332]                             ns <- base::getNamespace("future")
[10:32:58.332]                             version <- ns[[".package"]][["version"]]
[10:32:58.332]                             if (is.null(version)) 
[10:32:58.332]                               version <- utils::packageVersion("future")
[10:32:58.332]                           }
[10:32:58.332]                           else {
[10:32:58.332]                             version <- NULL
[10:32:58.332]                           }
[10:32:58.332]                           if (!has_future || version < "1.8.0") {
[10:32:58.332]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:58.332]                               "", base::R.version$version.string), 
[10:32:58.332]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:58.332]                                 base::R.version$platform, 8 * 
[10:32:58.332]                                   base::.Machine$sizeof.pointer), 
[10:32:58.332]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:58.332]                                 "release", "version")], collapse = " "), 
[10:32:58.332]                               hostname = base::Sys.info()[["nodename"]])
[10:32:58.332]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:58.332]                               info)
[10:32:58.332]                             info <- base::paste(info, collapse = "; ")
[10:32:58.332]                             if (!has_future) {
[10:32:58.332]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:58.332]                                 info)
[10:32:58.332]                             }
[10:32:58.332]                             else {
[10:32:58.332]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:58.332]                                 info, version)
[10:32:58.332]                             }
[10:32:58.332]                             base::stop(msg)
[10:32:58.332]                           }
[10:32:58.332]                         })
[10:32:58.332]                       }
[10:32:58.332]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:58.332]                       base::options(mc.cores = 1L)
[10:32:58.332]                     }
[10:32:58.332]                     base::local({
[10:32:58.332]                       for (pkg in "stats") {
[10:32:58.332]                         base::loadNamespace(pkg)
[10:32:58.332]                         base::library(pkg, character.only = TRUE)
[10:32:58.332]                       }
[10:32:58.332]                     })
[10:32:58.332]                   }
[10:32:58.332]                   ...future.strategy.old <- future::plan("list")
[10:32:58.332]                   options(future.plan = NULL)
[10:32:58.332]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:58.332]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:58.332]                 }
[10:32:58.332]                 ...future.workdir <- getwd()
[10:32:58.332]             }
[10:32:58.332]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:58.332]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:58.332]         }
[10:32:58.332]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:58.332]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:58.332]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:58.332]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:58.332]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:58.332]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:58.332]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:58.332]             base::names(...future.oldOptions))
[10:32:58.332]     }
[10:32:58.332]     if (FALSE) {
[10:32:58.332]     }
[10:32:58.332]     else {
[10:32:58.332]         if (TRUE) {
[10:32:58.332]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:58.332]                 open = "w")
[10:32:58.332]         }
[10:32:58.332]         else {
[10:32:58.332]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:58.332]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:58.332]         }
[10:32:58.332]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:58.332]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:58.332]             base::sink(type = "output", split = FALSE)
[10:32:58.332]             base::close(...future.stdout)
[10:32:58.332]         }, add = TRUE)
[10:32:58.332]     }
[10:32:58.332]     ...future.frame <- base::sys.nframe()
[10:32:58.332]     ...future.conditions <- base::list()
[10:32:58.332]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:58.332]     if (FALSE) {
[10:32:58.332]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:58.332]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:58.332]     }
[10:32:58.332]     ...future.result <- base::tryCatch({
[10:32:58.332]         base::withCallingHandlers({
[10:32:58.332]             ...future.value <- base::withVisible(base::local({
[10:32:58.332]                 ...future.makeSendCondition <- base::local({
[10:32:58.332]                   sendCondition <- NULL
[10:32:58.332]                   function(frame = 1L) {
[10:32:58.332]                     if (is.function(sendCondition)) 
[10:32:58.332]                       return(sendCondition)
[10:32:58.332]                     ns <- getNamespace("parallel")
[10:32:58.332]                     if (exists("sendData", mode = "function", 
[10:32:58.332]                       envir = ns)) {
[10:32:58.332]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:58.332]                         envir = ns)
[10:32:58.332]                       envir <- sys.frame(frame)
[10:32:58.332]                       master <- NULL
[10:32:58.332]                       while (!identical(envir, .GlobalEnv) && 
[10:32:58.332]                         !identical(envir, emptyenv())) {
[10:32:58.332]                         if (exists("master", mode = "list", envir = envir, 
[10:32:58.332]                           inherits = FALSE)) {
[10:32:58.332]                           master <- get("master", mode = "list", 
[10:32:58.332]                             envir = envir, inherits = FALSE)
[10:32:58.332]                           if (inherits(master, c("SOCKnode", 
[10:32:58.332]                             "SOCK0node"))) {
[10:32:58.332]                             sendCondition <<- function(cond) {
[10:32:58.332]                               data <- list(type = "VALUE", value = cond, 
[10:32:58.332]                                 success = TRUE)
[10:32:58.332]                               parallel_sendData(master, data)
[10:32:58.332]                             }
[10:32:58.332]                             return(sendCondition)
[10:32:58.332]                           }
[10:32:58.332]                         }
[10:32:58.332]                         frame <- frame + 1L
[10:32:58.332]                         envir <- sys.frame(frame)
[10:32:58.332]                       }
[10:32:58.332]                     }
[10:32:58.332]                     sendCondition <<- function(cond) NULL
[10:32:58.332]                   }
[10:32:58.332]                 })
[10:32:58.332]                 withCallingHandlers({
[10:32:58.332]                   {
[10:32:58.332]                     lm(weight ~ group - 1)
[10:32:58.332]                   }
[10:32:58.332]                 }, immediateCondition = function(cond) {
[10:32:58.332]                   sendCondition <- ...future.makeSendCondition()
[10:32:58.332]                   sendCondition(cond)
[10:32:58.332]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.332]                   {
[10:32:58.332]                     inherits <- base::inherits
[10:32:58.332]                     invokeRestart <- base::invokeRestart
[10:32:58.332]                     is.null <- base::is.null
[10:32:58.332]                     muffled <- FALSE
[10:32:58.332]                     if (inherits(cond, "message")) {
[10:32:58.332]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:58.332]                       if (muffled) 
[10:32:58.332]                         invokeRestart("muffleMessage")
[10:32:58.332]                     }
[10:32:58.332]                     else if (inherits(cond, "warning")) {
[10:32:58.332]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:58.332]                       if (muffled) 
[10:32:58.332]                         invokeRestart("muffleWarning")
[10:32:58.332]                     }
[10:32:58.332]                     else if (inherits(cond, "condition")) {
[10:32:58.332]                       if (!is.null(pattern)) {
[10:32:58.332]                         computeRestarts <- base::computeRestarts
[10:32:58.332]                         grepl <- base::grepl
[10:32:58.332]                         restarts <- computeRestarts(cond)
[10:32:58.332]                         for (restart in restarts) {
[10:32:58.332]                           name <- restart$name
[10:32:58.332]                           if (is.null(name)) 
[10:32:58.332]                             next
[10:32:58.332]                           if (!grepl(pattern, name)) 
[10:32:58.332]                             next
[10:32:58.332]                           invokeRestart(restart)
[10:32:58.332]                           muffled <- TRUE
[10:32:58.332]                           break
[10:32:58.332]                         }
[10:32:58.332]                       }
[10:32:58.332]                     }
[10:32:58.332]                     invisible(muffled)
[10:32:58.332]                   }
[10:32:58.332]                   muffleCondition(cond)
[10:32:58.332]                 })
[10:32:58.332]             }))
[10:32:58.332]             future::FutureResult(value = ...future.value$value, 
[10:32:58.332]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:58.332]                   ...future.rng), globalenv = if (FALSE) 
[10:32:58.332]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:58.332]                     ...future.globalenv.names))
[10:32:58.332]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:58.332]         }, condition = base::local({
[10:32:58.332]             c <- base::c
[10:32:58.332]             inherits <- base::inherits
[10:32:58.332]             invokeRestart <- base::invokeRestart
[10:32:58.332]             length <- base::length
[10:32:58.332]             list <- base::list
[10:32:58.332]             seq.int <- base::seq.int
[10:32:58.332]             signalCondition <- base::signalCondition
[10:32:58.332]             sys.calls <- base::sys.calls
[10:32:58.332]             `[[` <- base::`[[`
[10:32:58.332]             `+` <- base::`+`
[10:32:58.332]             `<<-` <- base::`<<-`
[10:32:58.332]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:58.332]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:58.332]                   3L)]
[10:32:58.332]             }
[10:32:58.332]             function(cond) {
[10:32:58.332]                 is_error <- inherits(cond, "error")
[10:32:58.332]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:58.332]                   NULL)
[10:32:58.332]                 if (is_error) {
[10:32:58.332]                   sessionInformation <- function() {
[10:32:58.332]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:58.332]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:58.332]                       search = base::search(), system = base::Sys.info())
[10:32:58.332]                   }
[10:32:58.332]                   ...future.conditions[[length(...future.conditions) + 
[10:32:58.332]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:58.332]                     cond$call), session = sessionInformation(), 
[10:32:58.332]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:58.332]                   signalCondition(cond)
[10:32:58.332]                 }
[10:32:58.332]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:58.332]                 "immediateCondition"))) {
[10:32:58.332]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:58.332]                   ...future.conditions[[length(...future.conditions) + 
[10:32:58.332]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:58.332]                   if (TRUE && !signal) {
[10:32:58.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.332]                     {
[10:32:58.332]                       inherits <- base::inherits
[10:32:58.332]                       invokeRestart <- base::invokeRestart
[10:32:58.332]                       is.null <- base::is.null
[10:32:58.332]                       muffled <- FALSE
[10:32:58.332]                       if (inherits(cond, "message")) {
[10:32:58.332]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:58.332]                         if (muffled) 
[10:32:58.332]                           invokeRestart("muffleMessage")
[10:32:58.332]                       }
[10:32:58.332]                       else if (inherits(cond, "warning")) {
[10:32:58.332]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:58.332]                         if (muffled) 
[10:32:58.332]                           invokeRestart("muffleWarning")
[10:32:58.332]                       }
[10:32:58.332]                       else if (inherits(cond, "condition")) {
[10:32:58.332]                         if (!is.null(pattern)) {
[10:32:58.332]                           computeRestarts <- base::computeRestarts
[10:32:58.332]                           grepl <- base::grepl
[10:32:58.332]                           restarts <- computeRestarts(cond)
[10:32:58.332]                           for (restart in restarts) {
[10:32:58.332]                             name <- restart$name
[10:32:58.332]                             if (is.null(name)) 
[10:32:58.332]                               next
[10:32:58.332]                             if (!grepl(pattern, name)) 
[10:32:58.332]                               next
[10:32:58.332]                             invokeRestart(restart)
[10:32:58.332]                             muffled <- TRUE
[10:32:58.332]                             break
[10:32:58.332]                           }
[10:32:58.332]                         }
[10:32:58.332]                       }
[10:32:58.332]                       invisible(muffled)
[10:32:58.332]                     }
[10:32:58.332]                     muffleCondition(cond, pattern = "^muffle")
[10:32:58.332]                   }
[10:32:58.332]                 }
[10:32:58.332]                 else {
[10:32:58.332]                   if (TRUE) {
[10:32:58.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.332]                     {
[10:32:58.332]                       inherits <- base::inherits
[10:32:58.332]                       invokeRestart <- base::invokeRestart
[10:32:58.332]                       is.null <- base::is.null
[10:32:58.332]                       muffled <- FALSE
[10:32:58.332]                       if (inherits(cond, "message")) {
[10:32:58.332]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:58.332]                         if (muffled) 
[10:32:58.332]                           invokeRestart("muffleMessage")
[10:32:58.332]                       }
[10:32:58.332]                       else if (inherits(cond, "warning")) {
[10:32:58.332]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:58.332]                         if (muffled) 
[10:32:58.332]                           invokeRestart("muffleWarning")
[10:32:58.332]                       }
[10:32:58.332]                       else if (inherits(cond, "condition")) {
[10:32:58.332]                         if (!is.null(pattern)) {
[10:32:58.332]                           computeRestarts <- base::computeRestarts
[10:32:58.332]                           grepl <- base::grepl
[10:32:58.332]                           restarts <- computeRestarts(cond)
[10:32:58.332]                           for (restart in restarts) {
[10:32:58.332]                             name <- restart$name
[10:32:58.332]                             if (is.null(name)) 
[10:32:58.332]                               next
[10:32:58.332]                             if (!grepl(pattern, name)) 
[10:32:58.332]                               next
[10:32:58.332]                             invokeRestart(restart)
[10:32:58.332]                             muffled <- TRUE
[10:32:58.332]                             break
[10:32:58.332]                           }
[10:32:58.332]                         }
[10:32:58.332]                       }
[10:32:58.332]                       invisible(muffled)
[10:32:58.332]                     }
[10:32:58.332]                     muffleCondition(cond, pattern = "^muffle")
[10:32:58.332]                   }
[10:32:58.332]                 }
[10:32:58.332]             }
[10:32:58.332]         }))
[10:32:58.332]     }, error = function(ex) {
[10:32:58.332]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:58.332]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:58.332]                 ...future.rng), started = ...future.startTime, 
[10:32:58.332]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:58.332]             version = "1.8"), class = "FutureResult")
[10:32:58.332]     }, finally = {
[10:32:58.332]         if (!identical(...future.workdir, getwd())) 
[10:32:58.332]             setwd(...future.workdir)
[10:32:58.332]         {
[10:32:58.332]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:58.332]                 ...future.oldOptions$nwarnings <- NULL
[10:32:58.332]             }
[10:32:58.332]             base::options(...future.oldOptions)
[10:32:58.332]             if (.Platform$OS.type == "windows") {
[10:32:58.332]                 old_names <- names(...future.oldEnvVars)
[10:32:58.332]                 envs <- base::Sys.getenv()
[10:32:58.332]                 names <- names(envs)
[10:32:58.332]                 common <- intersect(names, old_names)
[10:32:58.332]                 added <- setdiff(names, old_names)
[10:32:58.332]                 removed <- setdiff(old_names, names)
[10:32:58.332]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:58.332]                   envs[common]]
[10:32:58.332]                 NAMES <- toupper(changed)
[10:32:58.332]                 args <- list()
[10:32:58.332]                 for (kk in seq_along(NAMES)) {
[10:32:58.332]                   name <- changed[[kk]]
[10:32:58.332]                   NAME <- NAMES[[kk]]
[10:32:58.332]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.332]                     next
[10:32:58.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:58.332]                 }
[10:32:58.332]                 NAMES <- toupper(added)
[10:32:58.332]                 for (kk in seq_along(NAMES)) {
[10:32:58.332]                   name <- added[[kk]]
[10:32:58.332]                   NAME <- NAMES[[kk]]
[10:32:58.332]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.332]                     next
[10:32:58.332]                   args[[name]] <- ""
[10:32:58.332]                 }
[10:32:58.332]                 NAMES <- toupper(removed)
[10:32:58.332]                 for (kk in seq_along(NAMES)) {
[10:32:58.332]                   name <- removed[[kk]]
[10:32:58.332]                   NAME <- NAMES[[kk]]
[10:32:58.332]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.332]                     next
[10:32:58.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:58.332]                 }
[10:32:58.332]                 if (length(args) > 0) 
[10:32:58.332]                   base::do.call(base::Sys.setenv, args = args)
[10:32:58.332]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:58.332]             }
[10:32:58.332]             else {
[10:32:58.332]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:58.332]             }
[10:32:58.332]             {
[10:32:58.332]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:58.332]                   0L) {
[10:32:58.332]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:58.332]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:58.332]                   base::options(opts)
[10:32:58.332]                 }
[10:32:58.332]                 {
[10:32:58.332]                   {
[10:32:58.332]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:58.332]                     NULL
[10:32:58.332]                   }
[10:32:58.332]                   options(future.plan = NULL)
[10:32:58.332]                   if (is.na(NA_character_)) 
[10:32:58.332]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:58.332]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:58.332]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:58.332]                     .init = FALSE)
[10:32:58.332]                 }
[10:32:58.332]             }
[10:32:58.332]         }
[10:32:58.332]     })
[10:32:58.332]     if (TRUE) {
[10:32:58.332]         base::sink(type = "output", split = FALSE)
[10:32:58.332]         if (TRUE) {
[10:32:58.332]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:58.332]         }
[10:32:58.332]         else {
[10:32:58.332]             ...future.result["stdout"] <- base::list(NULL)
[10:32:58.332]         }
[10:32:58.332]         base::close(...future.stdout)
[10:32:58.332]         ...future.stdout <- NULL
[10:32:58.332]     }
[10:32:58.332]     ...future.result$conditions <- ...future.conditions
[10:32:58.332]     ...future.result$finished <- base::Sys.time()
[10:32:58.332]     ...future.result
[10:32:58.332] }
[10:32:58.335] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[10:32:58.335] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[10:32:58.336] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[10:32:58.336] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[10:32:58.336] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[10:32:58.336] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[10:32:58.337] MultisessionFuture started
[10:32:58.337] - Launch lazy future ... done
[10:32:58.337] run() for ‘MultisessionFuture’ ... done
[10:32:58.338] result() for ClusterFuture ...
[10:32:58.338] receiveMessageFromWorker() for ClusterFuture ...
[10:32:58.338] - Validating connection of MultisessionFuture
[10:32:58.389] - received message: FutureResult
[10:32:58.389] - Received FutureResult
[10:32:58.389] - Erased future from FutureRegistry
[10:32:58.389] result() for ClusterFuture ...
[10:32:58.389] - result already collected: FutureResult
[10:32:58.389] result() for ClusterFuture ... done
[10:32:58.390] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:58.390] result() for ClusterFuture ... done
[10:32:58.390] result() for ClusterFuture ...
[10:32:58.390] - result already collected: FutureResult
[10:32:58.390] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:32:58.392] getGlobalsAndPackages() ...
[10:32:58.392] Searching for globals...
[10:32:58.394] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:32:58.394] Searching for globals ... DONE
[10:32:58.395] Resolving globals: FALSE
[10:32:58.395] The total size of the 2 globals is 896 bytes (896 bytes)
[10:32:58.396] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:32:58.396] - globals: [2] ‘weight’, ‘group’
[10:32:58.396] - packages: [1] ‘stats’
[10:32:58.396] getGlobalsAndPackages() ... DONE
[10:32:58.396] run() for ‘Future’ ...
[10:32:58.396] - state: ‘created’
[10:32:58.397] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:58.413] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:58.413] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:58.413]   - Field: ‘node’
[10:32:58.413]   - Field: ‘label’
[10:32:58.413]   - Field: ‘local’
[10:32:58.413]   - Field: ‘owner’
[10:32:58.413]   - Field: ‘envir’
[10:32:58.413]   - Field: ‘workers’
[10:32:58.413]   - Field: ‘packages’
[10:32:58.414]   - Field: ‘gc’
[10:32:58.414]   - Field: ‘conditions’
[10:32:58.414]   - Field: ‘persistent’
[10:32:58.414]   - Field: ‘expr’
[10:32:58.414]   - Field: ‘uuid’
[10:32:58.414]   - Field: ‘seed’
[10:32:58.414]   - Field: ‘version’
[10:32:58.414]   - Field: ‘result’
[10:32:58.414]   - Field: ‘asynchronous’
[10:32:58.415]   - Field: ‘calls’
[10:32:58.415]   - Field: ‘globals’
[10:32:58.415]   - Field: ‘stdout’
[10:32:58.415]   - Field: ‘earlySignal’
[10:32:58.415]   - Field: ‘lazy’
[10:32:58.415]   - Field: ‘state’
[10:32:58.415] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:58.415] - Launch lazy future ...
[10:32:58.416] Packages needed by the future expression (n = 1): ‘stats’
[10:32:58.416] Packages needed by future strategies (n = 0): <none>
[10:32:58.416] {
[10:32:58.416]     {
[10:32:58.416]         {
[10:32:58.416]             ...future.startTime <- base::Sys.time()
[10:32:58.416]             {
[10:32:58.416]                 {
[10:32:58.416]                   {
[10:32:58.416]                     {
[10:32:58.416]                       {
[10:32:58.416]                         base::local({
[10:32:58.416]                           has_future <- base::requireNamespace("future", 
[10:32:58.416]                             quietly = TRUE)
[10:32:58.416]                           if (has_future) {
[10:32:58.416]                             ns <- base::getNamespace("future")
[10:32:58.416]                             version <- ns[[".package"]][["version"]]
[10:32:58.416]                             if (is.null(version)) 
[10:32:58.416]                               version <- utils::packageVersion("future")
[10:32:58.416]                           }
[10:32:58.416]                           else {
[10:32:58.416]                             version <- NULL
[10:32:58.416]                           }
[10:32:58.416]                           if (!has_future || version < "1.8.0") {
[10:32:58.416]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:58.416]                               "", base::R.version$version.string), 
[10:32:58.416]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:58.416]                                 base::R.version$platform, 8 * 
[10:32:58.416]                                   base::.Machine$sizeof.pointer), 
[10:32:58.416]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:58.416]                                 "release", "version")], collapse = " "), 
[10:32:58.416]                               hostname = base::Sys.info()[["nodename"]])
[10:32:58.416]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:58.416]                               info)
[10:32:58.416]                             info <- base::paste(info, collapse = "; ")
[10:32:58.416]                             if (!has_future) {
[10:32:58.416]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:58.416]                                 info)
[10:32:58.416]                             }
[10:32:58.416]                             else {
[10:32:58.416]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:58.416]                                 info, version)
[10:32:58.416]                             }
[10:32:58.416]                             base::stop(msg)
[10:32:58.416]                           }
[10:32:58.416]                         })
[10:32:58.416]                       }
[10:32:58.416]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:58.416]                       base::options(mc.cores = 1L)
[10:32:58.416]                     }
[10:32:58.416]                     base::local({
[10:32:58.416]                       for (pkg in "stats") {
[10:32:58.416]                         base::loadNamespace(pkg)
[10:32:58.416]                         base::library(pkg, character.only = TRUE)
[10:32:58.416]                       }
[10:32:58.416]                     })
[10:32:58.416]                   }
[10:32:58.416]                   ...future.strategy.old <- future::plan("list")
[10:32:58.416]                   options(future.plan = NULL)
[10:32:58.416]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:58.416]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:58.416]                 }
[10:32:58.416]                 ...future.workdir <- getwd()
[10:32:58.416]             }
[10:32:58.416]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:58.416]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:58.416]         }
[10:32:58.416]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:58.416]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:58.416]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:58.416]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:58.416]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:58.416]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:58.416]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:58.416]             base::names(...future.oldOptions))
[10:32:58.416]     }
[10:32:58.416]     if (FALSE) {
[10:32:58.416]     }
[10:32:58.416]     else {
[10:32:58.416]         if (TRUE) {
[10:32:58.416]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:58.416]                 open = "w")
[10:32:58.416]         }
[10:32:58.416]         else {
[10:32:58.416]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:58.416]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:58.416]         }
[10:32:58.416]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:58.416]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:58.416]             base::sink(type = "output", split = FALSE)
[10:32:58.416]             base::close(...future.stdout)
[10:32:58.416]         }, add = TRUE)
[10:32:58.416]     }
[10:32:58.416]     ...future.frame <- base::sys.nframe()
[10:32:58.416]     ...future.conditions <- base::list()
[10:32:58.416]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:58.416]     if (FALSE) {
[10:32:58.416]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:58.416]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:58.416]     }
[10:32:58.416]     ...future.result <- base::tryCatch({
[10:32:58.416]         base::withCallingHandlers({
[10:32:58.416]             ...future.value <- base::withVisible(base::local({
[10:32:58.416]                 ...future.makeSendCondition <- base::local({
[10:32:58.416]                   sendCondition <- NULL
[10:32:58.416]                   function(frame = 1L) {
[10:32:58.416]                     if (is.function(sendCondition)) 
[10:32:58.416]                       return(sendCondition)
[10:32:58.416]                     ns <- getNamespace("parallel")
[10:32:58.416]                     if (exists("sendData", mode = "function", 
[10:32:58.416]                       envir = ns)) {
[10:32:58.416]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:58.416]                         envir = ns)
[10:32:58.416]                       envir <- sys.frame(frame)
[10:32:58.416]                       master <- NULL
[10:32:58.416]                       while (!identical(envir, .GlobalEnv) && 
[10:32:58.416]                         !identical(envir, emptyenv())) {
[10:32:58.416]                         if (exists("master", mode = "list", envir = envir, 
[10:32:58.416]                           inherits = FALSE)) {
[10:32:58.416]                           master <- get("master", mode = "list", 
[10:32:58.416]                             envir = envir, inherits = FALSE)
[10:32:58.416]                           if (inherits(master, c("SOCKnode", 
[10:32:58.416]                             "SOCK0node"))) {
[10:32:58.416]                             sendCondition <<- function(cond) {
[10:32:58.416]                               data <- list(type = "VALUE", value = cond, 
[10:32:58.416]                                 success = TRUE)
[10:32:58.416]                               parallel_sendData(master, data)
[10:32:58.416]                             }
[10:32:58.416]                             return(sendCondition)
[10:32:58.416]                           }
[10:32:58.416]                         }
[10:32:58.416]                         frame <- frame + 1L
[10:32:58.416]                         envir <- sys.frame(frame)
[10:32:58.416]                       }
[10:32:58.416]                     }
[10:32:58.416]                     sendCondition <<- function(cond) NULL
[10:32:58.416]                   }
[10:32:58.416]                 })
[10:32:58.416]                 withCallingHandlers({
[10:32:58.416]                   {
[10:32:58.416]                     lm(weight ~ group - 1)
[10:32:58.416]                   }
[10:32:58.416]                 }, immediateCondition = function(cond) {
[10:32:58.416]                   sendCondition <- ...future.makeSendCondition()
[10:32:58.416]                   sendCondition(cond)
[10:32:58.416]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.416]                   {
[10:32:58.416]                     inherits <- base::inherits
[10:32:58.416]                     invokeRestart <- base::invokeRestart
[10:32:58.416]                     is.null <- base::is.null
[10:32:58.416]                     muffled <- FALSE
[10:32:58.416]                     if (inherits(cond, "message")) {
[10:32:58.416]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:58.416]                       if (muffled) 
[10:32:58.416]                         invokeRestart("muffleMessage")
[10:32:58.416]                     }
[10:32:58.416]                     else if (inherits(cond, "warning")) {
[10:32:58.416]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:58.416]                       if (muffled) 
[10:32:58.416]                         invokeRestart("muffleWarning")
[10:32:58.416]                     }
[10:32:58.416]                     else if (inherits(cond, "condition")) {
[10:32:58.416]                       if (!is.null(pattern)) {
[10:32:58.416]                         computeRestarts <- base::computeRestarts
[10:32:58.416]                         grepl <- base::grepl
[10:32:58.416]                         restarts <- computeRestarts(cond)
[10:32:58.416]                         for (restart in restarts) {
[10:32:58.416]                           name <- restart$name
[10:32:58.416]                           if (is.null(name)) 
[10:32:58.416]                             next
[10:32:58.416]                           if (!grepl(pattern, name)) 
[10:32:58.416]                             next
[10:32:58.416]                           invokeRestart(restart)
[10:32:58.416]                           muffled <- TRUE
[10:32:58.416]                           break
[10:32:58.416]                         }
[10:32:58.416]                       }
[10:32:58.416]                     }
[10:32:58.416]                     invisible(muffled)
[10:32:58.416]                   }
[10:32:58.416]                   muffleCondition(cond)
[10:32:58.416]                 })
[10:32:58.416]             }))
[10:32:58.416]             future::FutureResult(value = ...future.value$value, 
[10:32:58.416]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:58.416]                   ...future.rng), globalenv = if (FALSE) 
[10:32:58.416]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:58.416]                     ...future.globalenv.names))
[10:32:58.416]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:58.416]         }, condition = base::local({
[10:32:58.416]             c <- base::c
[10:32:58.416]             inherits <- base::inherits
[10:32:58.416]             invokeRestart <- base::invokeRestart
[10:32:58.416]             length <- base::length
[10:32:58.416]             list <- base::list
[10:32:58.416]             seq.int <- base::seq.int
[10:32:58.416]             signalCondition <- base::signalCondition
[10:32:58.416]             sys.calls <- base::sys.calls
[10:32:58.416]             `[[` <- base::`[[`
[10:32:58.416]             `+` <- base::`+`
[10:32:58.416]             `<<-` <- base::`<<-`
[10:32:58.416]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:58.416]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:58.416]                   3L)]
[10:32:58.416]             }
[10:32:58.416]             function(cond) {
[10:32:58.416]                 is_error <- inherits(cond, "error")
[10:32:58.416]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:58.416]                   NULL)
[10:32:58.416]                 if (is_error) {
[10:32:58.416]                   sessionInformation <- function() {
[10:32:58.416]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:58.416]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:58.416]                       search = base::search(), system = base::Sys.info())
[10:32:58.416]                   }
[10:32:58.416]                   ...future.conditions[[length(...future.conditions) + 
[10:32:58.416]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:58.416]                     cond$call), session = sessionInformation(), 
[10:32:58.416]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:58.416]                   signalCondition(cond)
[10:32:58.416]                 }
[10:32:58.416]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:58.416]                 "immediateCondition"))) {
[10:32:58.416]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:58.416]                   ...future.conditions[[length(...future.conditions) + 
[10:32:58.416]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:58.416]                   if (TRUE && !signal) {
[10:32:58.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.416]                     {
[10:32:58.416]                       inherits <- base::inherits
[10:32:58.416]                       invokeRestart <- base::invokeRestart
[10:32:58.416]                       is.null <- base::is.null
[10:32:58.416]                       muffled <- FALSE
[10:32:58.416]                       if (inherits(cond, "message")) {
[10:32:58.416]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:58.416]                         if (muffled) 
[10:32:58.416]                           invokeRestart("muffleMessage")
[10:32:58.416]                       }
[10:32:58.416]                       else if (inherits(cond, "warning")) {
[10:32:58.416]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:58.416]                         if (muffled) 
[10:32:58.416]                           invokeRestart("muffleWarning")
[10:32:58.416]                       }
[10:32:58.416]                       else if (inherits(cond, "condition")) {
[10:32:58.416]                         if (!is.null(pattern)) {
[10:32:58.416]                           computeRestarts <- base::computeRestarts
[10:32:58.416]                           grepl <- base::grepl
[10:32:58.416]                           restarts <- computeRestarts(cond)
[10:32:58.416]                           for (restart in restarts) {
[10:32:58.416]                             name <- restart$name
[10:32:58.416]                             if (is.null(name)) 
[10:32:58.416]                               next
[10:32:58.416]                             if (!grepl(pattern, name)) 
[10:32:58.416]                               next
[10:32:58.416]                             invokeRestart(restart)
[10:32:58.416]                             muffled <- TRUE
[10:32:58.416]                             break
[10:32:58.416]                           }
[10:32:58.416]                         }
[10:32:58.416]                       }
[10:32:58.416]                       invisible(muffled)
[10:32:58.416]                     }
[10:32:58.416]                     muffleCondition(cond, pattern = "^muffle")
[10:32:58.416]                   }
[10:32:58.416]                 }
[10:32:58.416]                 else {
[10:32:58.416]                   if (TRUE) {
[10:32:58.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.416]                     {
[10:32:58.416]                       inherits <- base::inherits
[10:32:58.416]                       invokeRestart <- base::invokeRestart
[10:32:58.416]                       is.null <- base::is.null
[10:32:58.416]                       muffled <- FALSE
[10:32:58.416]                       if (inherits(cond, "message")) {
[10:32:58.416]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:58.416]                         if (muffled) 
[10:32:58.416]                           invokeRestart("muffleMessage")
[10:32:58.416]                       }
[10:32:58.416]                       else if (inherits(cond, "warning")) {
[10:32:58.416]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:58.416]                         if (muffled) 
[10:32:58.416]                           invokeRestart("muffleWarning")
[10:32:58.416]                       }
[10:32:58.416]                       else if (inherits(cond, "condition")) {
[10:32:58.416]                         if (!is.null(pattern)) {
[10:32:58.416]                           computeRestarts <- base::computeRestarts
[10:32:58.416]                           grepl <- base::grepl
[10:32:58.416]                           restarts <- computeRestarts(cond)
[10:32:58.416]                           for (restart in restarts) {
[10:32:58.416]                             name <- restart$name
[10:32:58.416]                             if (is.null(name)) 
[10:32:58.416]                               next
[10:32:58.416]                             if (!grepl(pattern, name)) 
[10:32:58.416]                               next
[10:32:58.416]                             invokeRestart(restart)
[10:32:58.416]                             muffled <- TRUE
[10:32:58.416]                             break
[10:32:58.416]                           }
[10:32:58.416]                         }
[10:32:58.416]                       }
[10:32:58.416]                       invisible(muffled)
[10:32:58.416]                     }
[10:32:58.416]                     muffleCondition(cond, pattern = "^muffle")
[10:32:58.416]                   }
[10:32:58.416]                 }
[10:32:58.416]             }
[10:32:58.416]         }))
[10:32:58.416]     }, error = function(ex) {
[10:32:58.416]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:58.416]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:58.416]                 ...future.rng), started = ...future.startTime, 
[10:32:58.416]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:58.416]             version = "1.8"), class = "FutureResult")
[10:32:58.416]     }, finally = {
[10:32:58.416]         if (!identical(...future.workdir, getwd())) 
[10:32:58.416]             setwd(...future.workdir)
[10:32:58.416]         {
[10:32:58.416]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:58.416]                 ...future.oldOptions$nwarnings <- NULL
[10:32:58.416]             }
[10:32:58.416]             base::options(...future.oldOptions)
[10:32:58.416]             if (.Platform$OS.type == "windows") {
[10:32:58.416]                 old_names <- names(...future.oldEnvVars)
[10:32:58.416]                 envs <- base::Sys.getenv()
[10:32:58.416]                 names <- names(envs)
[10:32:58.416]                 common <- intersect(names, old_names)
[10:32:58.416]                 added <- setdiff(names, old_names)
[10:32:58.416]                 removed <- setdiff(old_names, names)
[10:32:58.416]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:58.416]                   envs[common]]
[10:32:58.416]                 NAMES <- toupper(changed)
[10:32:58.416]                 args <- list()
[10:32:58.416]                 for (kk in seq_along(NAMES)) {
[10:32:58.416]                   name <- changed[[kk]]
[10:32:58.416]                   NAME <- NAMES[[kk]]
[10:32:58.416]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.416]                     next
[10:32:58.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:58.416]                 }
[10:32:58.416]                 NAMES <- toupper(added)
[10:32:58.416]                 for (kk in seq_along(NAMES)) {
[10:32:58.416]                   name <- added[[kk]]
[10:32:58.416]                   NAME <- NAMES[[kk]]
[10:32:58.416]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.416]                     next
[10:32:58.416]                   args[[name]] <- ""
[10:32:58.416]                 }
[10:32:58.416]                 NAMES <- toupper(removed)
[10:32:58.416]                 for (kk in seq_along(NAMES)) {
[10:32:58.416]                   name <- removed[[kk]]
[10:32:58.416]                   NAME <- NAMES[[kk]]
[10:32:58.416]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.416]                     next
[10:32:58.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:58.416]                 }
[10:32:58.416]                 if (length(args) > 0) 
[10:32:58.416]                   base::do.call(base::Sys.setenv, args = args)
[10:32:58.416]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:58.416]             }
[10:32:58.416]             else {
[10:32:58.416]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:58.416]             }
[10:32:58.416]             {
[10:32:58.416]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:58.416]                   0L) {
[10:32:58.416]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:58.416]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:58.416]                   base::options(opts)
[10:32:58.416]                 }
[10:32:58.416]                 {
[10:32:58.416]                   {
[10:32:58.416]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:58.416]                     NULL
[10:32:58.416]                   }
[10:32:58.416]                   options(future.plan = NULL)
[10:32:58.416]                   if (is.na(NA_character_)) 
[10:32:58.416]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:58.416]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:58.416]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:58.416]                     .init = FALSE)
[10:32:58.416]                 }
[10:32:58.416]             }
[10:32:58.416]         }
[10:32:58.416]     })
[10:32:58.416]     if (TRUE) {
[10:32:58.416]         base::sink(type = "output", split = FALSE)
[10:32:58.416]         if (TRUE) {
[10:32:58.416]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:58.416]         }
[10:32:58.416]         else {
[10:32:58.416]             ...future.result["stdout"] <- base::list(NULL)
[10:32:58.416]         }
[10:32:58.416]         base::close(...future.stdout)
[10:32:58.416]         ...future.stdout <- NULL
[10:32:58.416]     }
[10:32:58.416]     ...future.result$conditions <- ...future.conditions
[10:32:58.416]     ...future.result$finished <- base::Sys.time()
[10:32:58.416]     ...future.result
[10:32:58.416] }
[10:32:58.419] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[10:32:58.420] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[10:32:58.420] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[10:32:58.420] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[10:32:58.420] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[10:32:58.421] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[10:32:58.421] MultisessionFuture started
[10:32:58.421] - Launch lazy future ... done
[10:32:58.421] run() for ‘MultisessionFuture’ ... done
[10:32:58.422] result() for ClusterFuture ...
[10:32:58.422] receiveMessageFromWorker() for ClusterFuture ...
[10:32:58.422] - Validating connection of MultisessionFuture
[10:32:58.467] - received message: FutureResult
[10:32:58.468] - Received FutureResult
[10:32:58.468] - Erased future from FutureRegistry
[10:32:58.468] result() for ClusterFuture ...
[10:32:58.468] - result already collected: FutureResult
[10:32:58.468] result() for ClusterFuture ... done
[10:32:58.468] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:58.468] result() for ClusterFuture ... done
[10:32:58.469] result() for ClusterFuture ...
[10:32:58.469] - result already collected: FutureResult
[10:32:58.469] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:32:58.471] getGlobalsAndPackages() ...
[10:32:58.471] Searching for globals...
[10:32:58.473] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:32:58.473] Searching for globals ... DONE
[10:32:58.473] Resolving globals: FALSE
[10:32:58.474] The total size of the 2 globals is 896 bytes (896 bytes)
[10:32:58.474] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:32:58.475] - globals: [2] ‘weight’, ‘group’
[10:32:58.475] - packages: [1] ‘stats’
[10:32:58.475] getGlobalsAndPackages() ... DONE
[10:32:58.475] run() for ‘Future’ ...
[10:32:58.475] - state: ‘created’
[10:32:58.475] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:58.490] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:58.490] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:58.490]   - Field: ‘node’
[10:32:58.491]   - Field: ‘label’
[10:32:58.491]   - Field: ‘local’
[10:32:58.491]   - Field: ‘owner’
[10:32:58.491]   - Field: ‘envir’
[10:32:58.491]   - Field: ‘workers’
[10:32:58.491]   - Field: ‘packages’
[10:32:58.491]   - Field: ‘gc’
[10:32:58.491]   - Field: ‘conditions’
[10:32:58.491]   - Field: ‘persistent’
[10:32:58.491]   - Field: ‘expr’
[10:32:58.492]   - Field: ‘uuid’
[10:32:58.492]   - Field: ‘seed’
[10:32:58.492]   - Field: ‘version’
[10:32:58.492]   - Field: ‘result’
[10:32:58.492]   - Field: ‘asynchronous’
[10:32:58.492]   - Field: ‘calls’
[10:32:58.492]   - Field: ‘globals’
[10:32:58.492]   - Field: ‘stdout’
[10:32:58.492]   - Field: ‘earlySignal’
[10:32:58.493]   - Field: ‘lazy’
[10:32:58.493]   - Field: ‘state’
[10:32:58.493] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:58.493] - Launch lazy future ...
[10:32:58.493] Packages needed by the future expression (n = 1): ‘stats’
[10:32:58.493] Packages needed by future strategies (n = 0): <none>
[10:32:58.494] {
[10:32:58.494]     {
[10:32:58.494]         {
[10:32:58.494]             ...future.startTime <- base::Sys.time()
[10:32:58.494]             {
[10:32:58.494]                 {
[10:32:58.494]                   {
[10:32:58.494]                     {
[10:32:58.494]                       {
[10:32:58.494]                         base::local({
[10:32:58.494]                           has_future <- base::requireNamespace("future", 
[10:32:58.494]                             quietly = TRUE)
[10:32:58.494]                           if (has_future) {
[10:32:58.494]                             ns <- base::getNamespace("future")
[10:32:58.494]                             version <- ns[[".package"]][["version"]]
[10:32:58.494]                             if (is.null(version)) 
[10:32:58.494]                               version <- utils::packageVersion("future")
[10:32:58.494]                           }
[10:32:58.494]                           else {
[10:32:58.494]                             version <- NULL
[10:32:58.494]                           }
[10:32:58.494]                           if (!has_future || version < "1.8.0") {
[10:32:58.494]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:58.494]                               "", base::R.version$version.string), 
[10:32:58.494]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:58.494]                                 base::R.version$platform, 8 * 
[10:32:58.494]                                   base::.Machine$sizeof.pointer), 
[10:32:58.494]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:58.494]                                 "release", "version")], collapse = " "), 
[10:32:58.494]                               hostname = base::Sys.info()[["nodename"]])
[10:32:58.494]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:58.494]                               info)
[10:32:58.494]                             info <- base::paste(info, collapse = "; ")
[10:32:58.494]                             if (!has_future) {
[10:32:58.494]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:58.494]                                 info)
[10:32:58.494]                             }
[10:32:58.494]                             else {
[10:32:58.494]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:58.494]                                 info, version)
[10:32:58.494]                             }
[10:32:58.494]                             base::stop(msg)
[10:32:58.494]                           }
[10:32:58.494]                         })
[10:32:58.494]                       }
[10:32:58.494]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:58.494]                       base::options(mc.cores = 1L)
[10:32:58.494]                     }
[10:32:58.494]                     base::local({
[10:32:58.494]                       for (pkg in "stats") {
[10:32:58.494]                         base::loadNamespace(pkg)
[10:32:58.494]                         base::library(pkg, character.only = TRUE)
[10:32:58.494]                       }
[10:32:58.494]                     })
[10:32:58.494]                   }
[10:32:58.494]                   ...future.strategy.old <- future::plan("list")
[10:32:58.494]                   options(future.plan = NULL)
[10:32:58.494]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:58.494]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:58.494]                 }
[10:32:58.494]                 ...future.workdir <- getwd()
[10:32:58.494]             }
[10:32:58.494]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:58.494]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:58.494]         }
[10:32:58.494]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:58.494]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:58.494]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:58.494]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:58.494]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:58.494]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:58.494]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:58.494]             base::names(...future.oldOptions))
[10:32:58.494]     }
[10:32:58.494]     if (FALSE) {
[10:32:58.494]     }
[10:32:58.494]     else {
[10:32:58.494]         if (TRUE) {
[10:32:58.494]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:58.494]                 open = "w")
[10:32:58.494]         }
[10:32:58.494]         else {
[10:32:58.494]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:58.494]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:58.494]         }
[10:32:58.494]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:58.494]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:58.494]             base::sink(type = "output", split = FALSE)
[10:32:58.494]             base::close(...future.stdout)
[10:32:58.494]         }, add = TRUE)
[10:32:58.494]     }
[10:32:58.494]     ...future.frame <- base::sys.nframe()
[10:32:58.494]     ...future.conditions <- base::list()
[10:32:58.494]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:58.494]     if (FALSE) {
[10:32:58.494]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:58.494]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:58.494]     }
[10:32:58.494]     ...future.result <- base::tryCatch({
[10:32:58.494]         base::withCallingHandlers({
[10:32:58.494]             ...future.value <- base::withVisible(base::local({
[10:32:58.494]                 ...future.makeSendCondition <- base::local({
[10:32:58.494]                   sendCondition <- NULL
[10:32:58.494]                   function(frame = 1L) {
[10:32:58.494]                     if (is.function(sendCondition)) 
[10:32:58.494]                       return(sendCondition)
[10:32:58.494]                     ns <- getNamespace("parallel")
[10:32:58.494]                     if (exists("sendData", mode = "function", 
[10:32:58.494]                       envir = ns)) {
[10:32:58.494]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:58.494]                         envir = ns)
[10:32:58.494]                       envir <- sys.frame(frame)
[10:32:58.494]                       master <- NULL
[10:32:58.494]                       while (!identical(envir, .GlobalEnv) && 
[10:32:58.494]                         !identical(envir, emptyenv())) {
[10:32:58.494]                         if (exists("master", mode = "list", envir = envir, 
[10:32:58.494]                           inherits = FALSE)) {
[10:32:58.494]                           master <- get("master", mode = "list", 
[10:32:58.494]                             envir = envir, inherits = FALSE)
[10:32:58.494]                           if (inherits(master, c("SOCKnode", 
[10:32:58.494]                             "SOCK0node"))) {
[10:32:58.494]                             sendCondition <<- function(cond) {
[10:32:58.494]                               data <- list(type = "VALUE", value = cond, 
[10:32:58.494]                                 success = TRUE)
[10:32:58.494]                               parallel_sendData(master, data)
[10:32:58.494]                             }
[10:32:58.494]                             return(sendCondition)
[10:32:58.494]                           }
[10:32:58.494]                         }
[10:32:58.494]                         frame <- frame + 1L
[10:32:58.494]                         envir <- sys.frame(frame)
[10:32:58.494]                       }
[10:32:58.494]                     }
[10:32:58.494]                     sendCondition <<- function(cond) NULL
[10:32:58.494]                   }
[10:32:58.494]                 })
[10:32:58.494]                 withCallingHandlers({
[10:32:58.494]                   {
[10:32:58.494]                     lm(weight ~ group - 1)
[10:32:58.494]                   }
[10:32:58.494]                 }, immediateCondition = function(cond) {
[10:32:58.494]                   sendCondition <- ...future.makeSendCondition()
[10:32:58.494]                   sendCondition(cond)
[10:32:58.494]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.494]                   {
[10:32:58.494]                     inherits <- base::inherits
[10:32:58.494]                     invokeRestart <- base::invokeRestart
[10:32:58.494]                     is.null <- base::is.null
[10:32:58.494]                     muffled <- FALSE
[10:32:58.494]                     if (inherits(cond, "message")) {
[10:32:58.494]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:58.494]                       if (muffled) 
[10:32:58.494]                         invokeRestart("muffleMessage")
[10:32:58.494]                     }
[10:32:58.494]                     else if (inherits(cond, "warning")) {
[10:32:58.494]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:58.494]                       if (muffled) 
[10:32:58.494]                         invokeRestart("muffleWarning")
[10:32:58.494]                     }
[10:32:58.494]                     else if (inherits(cond, "condition")) {
[10:32:58.494]                       if (!is.null(pattern)) {
[10:32:58.494]                         computeRestarts <- base::computeRestarts
[10:32:58.494]                         grepl <- base::grepl
[10:32:58.494]                         restarts <- computeRestarts(cond)
[10:32:58.494]                         for (restart in restarts) {
[10:32:58.494]                           name <- restart$name
[10:32:58.494]                           if (is.null(name)) 
[10:32:58.494]                             next
[10:32:58.494]                           if (!grepl(pattern, name)) 
[10:32:58.494]                             next
[10:32:58.494]                           invokeRestart(restart)
[10:32:58.494]                           muffled <- TRUE
[10:32:58.494]                           break
[10:32:58.494]                         }
[10:32:58.494]                       }
[10:32:58.494]                     }
[10:32:58.494]                     invisible(muffled)
[10:32:58.494]                   }
[10:32:58.494]                   muffleCondition(cond)
[10:32:58.494]                 })
[10:32:58.494]             }))
[10:32:58.494]             future::FutureResult(value = ...future.value$value, 
[10:32:58.494]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:58.494]                   ...future.rng), globalenv = if (FALSE) 
[10:32:58.494]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:58.494]                     ...future.globalenv.names))
[10:32:58.494]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:58.494]         }, condition = base::local({
[10:32:58.494]             c <- base::c
[10:32:58.494]             inherits <- base::inherits
[10:32:58.494]             invokeRestart <- base::invokeRestart
[10:32:58.494]             length <- base::length
[10:32:58.494]             list <- base::list
[10:32:58.494]             seq.int <- base::seq.int
[10:32:58.494]             signalCondition <- base::signalCondition
[10:32:58.494]             sys.calls <- base::sys.calls
[10:32:58.494]             `[[` <- base::`[[`
[10:32:58.494]             `+` <- base::`+`
[10:32:58.494]             `<<-` <- base::`<<-`
[10:32:58.494]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:58.494]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:58.494]                   3L)]
[10:32:58.494]             }
[10:32:58.494]             function(cond) {
[10:32:58.494]                 is_error <- inherits(cond, "error")
[10:32:58.494]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:58.494]                   NULL)
[10:32:58.494]                 if (is_error) {
[10:32:58.494]                   sessionInformation <- function() {
[10:32:58.494]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:58.494]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:58.494]                       search = base::search(), system = base::Sys.info())
[10:32:58.494]                   }
[10:32:58.494]                   ...future.conditions[[length(...future.conditions) + 
[10:32:58.494]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:58.494]                     cond$call), session = sessionInformation(), 
[10:32:58.494]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:58.494]                   signalCondition(cond)
[10:32:58.494]                 }
[10:32:58.494]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:58.494]                 "immediateCondition"))) {
[10:32:58.494]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:58.494]                   ...future.conditions[[length(...future.conditions) + 
[10:32:58.494]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:58.494]                   if (TRUE && !signal) {
[10:32:58.494]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.494]                     {
[10:32:58.494]                       inherits <- base::inherits
[10:32:58.494]                       invokeRestart <- base::invokeRestart
[10:32:58.494]                       is.null <- base::is.null
[10:32:58.494]                       muffled <- FALSE
[10:32:58.494]                       if (inherits(cond, "message")) {
[10:32:58.494]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:58.494]                         if (muffled) 
[10:32:58.494]                           invokeRestart("muffleMessage")
[10:32:58.494]                       }
[10:32:58.494]                       else if (inherits(cond, "warning")) {
[10:32:58.494]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:58.494]                         if (muffled) 
[10:32:58.494]                           invokeRestart("muffleWarning")
[10:32:58.494]                       }
[10:32:58.494]                       else if (inherits(cond, "condition")) {
[10:32:58.494]                         if (!is.null(pattern)) {
[10:32:58.494]                           computeRestarts <- base::computeRestarts
[10:32:58.494]                           grepl <- base::grepl
[10:32:58.494]                           restarts <- computeRestarts(cond)
[10:32:58.494]                           for (restart in restarts) {
[10:32:58.494]                             name <- restart$name
[10:32:58.494]                             if (is.null(name)) 
[10:32:58.494]                               next
[10:32:58.494]                             if (!grepl(pattern, name)) 
[10:32:58.494]                               next
[10:32:58.494]                             invokeRestart(restart)
[10:32:58.494]                             muffled <- TRUE
[10:32:58.494]                             break
[10:32:58.494]                           }
[10:32:58.494]                         }
[10:32:58.494]                       }
[10:32:58.494]                       invisible(muffled)
[10:32:58.494]                     }
[10:32:58.494]                     muffleCondition(cond, pattern = "^muffle")
[10:32:58.494]                   }
[10:32:58.494]                 }
[10:32:58.494]                 else {
[10:32:58.494]                   if (TRUE) {
[10:32:58.494]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.494]                     {
[10:32:58.494]                       inherits <- base::inherits
[10:32:58.494]                       invokeRestart <- base::invokeRestart
[10:32:58.494]                       is.null <- base::is.null
[10:32:58.494]                       muffled <- FALSE
[10:32:58.494]                       if (inherits(cond, "message")) {
[10:32:58.494]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:58.494]                         if (muffled) 
[10:32:58.494]                           invokeRestart("muffleMessage")
[10:32:58.494]                       }
[10:32:58.494]                       else if (inherits(cond, "warning")) {
[10:32:58.494]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:58.494]                         if (muffled) 
[10:32:58.494]                           invokeRestart("muffleWarning")
[10:32:58.494]                       }
[10:32:58.494]                       else if (inherits(cond, "condition")) {
[10:32:58.494]                         if (!is.null(pattern)) {
[10:32:58.494]                           computeRestarts <- base::computeRestarts
[10:32:58.494]                           grepl <- base::grepl
[10:32:58.494]                           restarts <- computeRestarts(cond)
[10:32:58.494]                           for (restart in restarts) {
[10:32:58.494]                             name <- restart$name
[10:32:58.494]                             if (is.null(name)) 
[10:32:58.494]                               next
[10:32:58.494]                             if (!grepl(pattern, name)) 
[10:32:58.494]                               next
[10:32:58.494]                             invokeRestart(restart)
[10:32:58.494]                             muffled <- TRUE
[10:32:58.494]                             break
[10:32:58.494]                           }
[10:32:58.494]                         }
[10:32:58.494]                       }
[10:32:58.494]                       invisible(muffled)
[10:32:58.494]                     }
[10:32:58.494]                     muffleCondition(cond, pattern = "^muffle")
[10:32:58.494]                   }
[10:32:58.494]                 }
[10:32:58.494]             }
[10:32:58.494]         }))
[10:32:58.494]     }, error = function(ex) {
[10:32:58.494]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:58.494]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:58.494]                 ...future.rng), started = ...future.startTime, 
[10:32:58.494]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:58.494]             version = "1.8"), class = "FutureResult")
[10:32:58.494]     }, finally = {
[10:32:58.494]         if (!identical(...future.workdir, getwd())) 
[10:32:58.494]             setwd(...future.workdir)
[10:32:58.494]         {
[10:32:58.494]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:58.494]                 ...future.oldOptions$nwarnings <- NULL
[10:32:58.494]             }
[10:32:58.494]             base::options(...future.oldOptions)
[10:32:58.494]             if (.Platform$OS.type == "windows") {
[10:32:58.494]                 old_names <- names(...future.oldEnvVars)
[10:32:58.494]                 envs <- base::Sys.getenv()
[10:32:58.494]                 names <- names(envs)
[10:32:58.494]                 common <- intersect(names, old_names)
[10:32:58.494]                 added <- setdiff(names, old_names)
[10:32:58.494]                 removed <- setdiff(old_names, names)
[10:32:58.494]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:58.494]                   envs[common]]
[10:32:58.494]                 NAMES <- toupper(changed)
[10:32:58.494]                 args <- list()
[10:32:58.494]                 for (kk in seq_along(NAMES)) {
[10:32:58.494]                   name <- changed[[kk]]
[10:32:58.494]                   NAME <- NAMES[[kk]]
[10:32:58.494]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.494]                     next
[10:32:58.494]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:58.494]                 }
[10:32:58.494]                 NAMES <- toupper(added)
[10:32:58.494]                 for (kk in seq_along(NAMES)) {
[10:32:58.494]                   name <- added[[kk]]
[10:32:58.494]                   NAME <- NAMES[[kk]]
[10:32:58.494]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.494]                     next
[10:32:58.494]                   args[[name]] <- ""
[10:32:58.494]                 }
[10:32:58.494]                 NAMES <- toupper(removed)
[10:32:58.494]                 for (kk in seq_along(NAMES)) {
[10:32:58.494]                   name <- removed[[kk]]
[10:32:58.494]                   NAME <- NAMES[[kk]]
[10:32:58.494]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.494]                     next
[10:32:58.494]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:58.494]                 }
[10:32:58.494]                 if (length(args) > 0) 
[10:32:58.494]                   base::do.call(base::Sys.setenv, args = args)
[10:32:58.494]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:58.494]             }
[10:32:58.494]             else {
[10:32:58.494]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:58.494]             }
[10:32:58.494]             {
[10:32:58.494]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:58.494]                   0L) {
[10:32:58.494]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:58.494]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:58.494]                   base::options(opts)
[10:32:58.494]                 }
[10:32:58.494]                 {
[10:32:58.494]                   {
[10:32:58.494]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:58.494]                     NULL
[10:32:58.494]                   }
[10:32:58.494]                   options(future.plan = NULL)
[10:32:58.494]                   if (is.na(NA_character_)) 
[10:32:58.494]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:58.494]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:58.494]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:58.494]                     .init = FALSE)
[10:32:58.494]                 }
[10:32:58.494]             }
[10:32:58.494]         }
[10:32:58.494]     })
[10:32:58.494]     if (TRUE) {
[10:32:58.494]         base::sink(type = "output", split = FALSE)
[10:32:58.494]         if (TRUE) {
[10:32:58.494]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:58.494]         }
[10:32:58.494]         else {
[10:32:58.494]             ...future.result["stdout"] <- base::list(NULL)
[10:32:58.494]         }
[10:32:58.494]         base::close(...future.stdout)
[10:32:58.494]         ...future.stdout <- NULL
[10:32:58.494]     }
[10:32:58.494]     ...future.result$conditions <- ...future.conditions
[10:32:58.494]     ...future.result$finished <- base::Sys.time()
[10:32:58.494]     ...future.result
[10:32:58.494] }
[10:32:58.497] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[10:32:58.497] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[10:32:58.498] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[10:32:58.498] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[10:32:58.498] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[10:32:58.500] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[10:32:58.501] MultisessionFuture started
[10:32:58.501] - Launch lazy future ... done
[10:32:58.501] run() for ‘MultisessionFuture’ ... done
[10:32:58.501] result() for ClusterFuture ...
[10:32:58.502] receiveMessageFromWorker() for ClusterFuture ...
[10:32:58.502] - Validating connection of MultisessionFuture
[10:32:58.547] - received message: FutureResult
[10:32:58.547] - Received FutureResult
[10:32:58.548] - Erased future from FutureRegistry
[10:32:58.548] result() for ClusterFuture ...
[10:32:58.548] - result already collected: FutureResult
[10:32:58.548] result() for ClusterFuture ... done
[10:32:58.548] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:58.548] result() for ClusterFuture ... done
[10:32:58.548] result() for ClusterFuture ...
[10:32:58.548] - result already collected: FutureResult
[10:32:58.548] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:32:58.550] getGlobalsAndPackages() ...
[10:32:58.550] Searching for globals...
[10:32:58.551] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:32:58.552] Searching for globals ... DONE
[10:32:58.552] Resolving globals: FALSE
[10:32:58.552] The total size of the 2 globals is 896 bytes (896 bytes)
[10:32:58.552] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:32:58.553] - globals: [2] ‘weight’, ‘group’
[10:32:58.553] - packages: [1] ‘stats’
[10:32:58.553] getGlobalsAndPackages() ... DONE
[10:32:58.553] run() for ‘Future’ ...
[10:32:58.553] - state: ‘created’
[10:32:58.553] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:58.567] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:58.567] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:58.567]   - Field: ‘node’
[10:32:58.567]   - Field: ‘label’
[10:32:58.567]   - Field: ‘local’
[10:32:58.568]   - Field: ‘owner’
[10:32:58.568]   - Field: ‘envir’
[10:32:58.568]   - Field: ‘workers’
[10:32:58.568]   - Field: ‘packages’
[10:32:58.568]   - Field: ‘gc’
[10:32:58.568]   - Field: ‘conditions’
[10:32:58.568]   - Field: ‘persistent’
[10:32:58.568]   - Field: ‘expr’
[10:32:58.568]   - Field: ‘uuid’
[10:32:58.568]   - Field: ‘seed’
[10:32:58.568]   - Field: ‘version’
[10:32:58.568]   - Field: ‘result’
[10:32:58.569]   - Field: ‘asynchronous’
[10:32:58.569]   - Field: ‘calls’
[10:32:58.569]   - Field: ‘globals’
[10:32:58.569]   - Field: ‘stdout’
[10:32:58.569]   - Field: ‘earlySignal’
[10:32:58.569]   - Field: ‘lazy’
[10:32:58.569]   - Field: ‘state’
[10:32:58.569] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:58.569] - Launch lazy future ...
[10:32:58.570] Packages needed by the future expression (n = 1): ‘stats’
[10:32:58.570] Packages needed by future strategies (n = 0): <none>
[10:32:58.570] {
[10:32:58.570]     {
[10:32:58.570]         {
[10:32:58.570]             ...future.startTime <- base::Sys.time()
[10:32:58.570]             {
[10:32:58.570]                 {
[10:32:58.570]                   {
[10:32:58.570]                     {
[10:32:58.570]                       {
[10:32:58.570]                         base::local({
[10:32:58.570]                           has_future <- base::requireNamespace("future", 
[10:32:58.570]                             quietly = TRUE)
[10:32:58.570]                           if (has_future) {
[10:32:58.570]                             ns <- base::getNamespace("future")
[10:32:58.570]                             version <- ns[[".package"]][["version"]]
[10:32:58.570]                             if (is.null(version)) 
[10:32:58.570]                               version <- utils::packageVersion("future")
[10:32:58.570]                           }
[10:32:58.570]                           else {
[10:32:58.570]                             version <- NULL
[10:32:58.570]                           }
[10:32:58.570]                           if (!has_future || version < "1.8.0") {
[10:32:58.570]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:58.570]                               "", base::R.version$version.string), 
[10:32:58.570]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:58.570]                                 base::R.version$platform, 8 * 
[10:32:58.570]                                   base::.Machine$sizeof.pointer), 
[10:32:58.570]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:58.570]                                 "release", "version")], collapse = " "), 
[10:32:58.570]                               hostname = base::Sys.info()[["nodename"]])
[10:32:58.570]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:58.570]                               info)
[10:32:58.570]                             info <- base::paste(info, collapse = "; ")
[10:32:58.570]                             if (!has_future) {
[10:32:58.570]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:58.570]                                 info)
[10:32:58.570]                             }
[10:32:58.570]                             else {
[10:32:58.570]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:58.570]                                 info, version)
[10:32:58.570]                             }
[10:32:58.570]                             base::stop(msg)
[10:32:58.570]                           }
[10:32:58.570]                         })
[10:32:58.570]                       }
[10:32:58.570]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:58.570]                       base::options(mc.cores = 1L)
[10:32:58.570]                     }
[10:32:58.570]                     base::local({
[10:32:58.570]                       for (pkg in "stats") {
[10:32:58.570]                         base::loadNamespace(pkg)
[10:32:58.570]                         base::library(pkg, character.only = TRUE)
[10:32:58.570]                       }
[10:32:58.570]                     })
[10:32:58.570]                   }
[10:32:58.570]                   ...future.strategy.old <- future::plan("list")
[10:32:58.570]                   options(future.plan = NULL)
[10:32:58.570]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:58.570]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:58.570]                 }
[10:32:58.570]                 ...future.workdir <- getwd()
[10:32:58.570]             }
[10:32:58.570]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:58.570]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:58.570]         }
[10:32:58.570]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:58.570]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:58.570]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:58.570]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:58.570]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:58.570]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:58.570]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:58.570]             base::names(...future.oldOptions))
[10:32:58.570]     }
[10:32:58.570]     if (FALSE) {
[10:32:58.570]     }
[10:32:58.570]     else {
[10:32:58.570]         if (TRUE) {
[10:32:58.570]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:58.570]                 open = "w")
[10:32:58.570]         }
[10:32:58.570]         else {
[10:32:58.570]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:58.570]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:58.570]         }
[10:32:58.570]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:58.570]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:58.570]             base::sink(type = "output", split = FALSE)
[10:32:58.570]             base::close(...future.stdout)
[10:32:58.570]         }, add = TRUE)
[10:32:58.570]     }
[10:32:58.570]     ...future.frame <- base::sys.nframe()
[10:32:58.570]     ...future.conditions <- base::list()
[10:32:58.570]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:58.570]     if (FALSE) {
[10:32:58.570]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:58.570]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:58.570]     }
[10:32:58.570]     ...future.result <- base::tryCatch({
[10:32:58.570]         base::withCallingHandlers({
[10:32:58.570]             ...future.value <- base::withVisible(base::local({
[10:32:58.570]                 ...future.makeSendCondition <- base::local({
[10:32:58.570]                   sendCondition <- NULL
[10:32:58.570]                   function(frame = 1L) {
[10:32:58.570]                     if (is.function(sendCondition)) 
[10:32:58.570]                       return(sendCondition)
[10:32:58.570]                     ns <- getNamespace("parallel")
[10:32:58.570]                     if (exists("sendData", mode = "function", 
[10:32:58.570]                       envir = ns)) {
[10:32:58.570]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:58.570]                         envir = ns)
[10:32:58.570]                       envir <- sys.frame(frame)
[10:32:58.570]                       master <- NULL
[10:32:58.570]                       while (!identical(envir, .GlobalEnv) && 
[10:32:58.570]                         !identical(envir, emptyenv())) {
[10:32:58.570]                         if (exists("master", mode = "list", envir = envir, 
[10:32:58.570]                           inherits = FALSE)) {
[10:32:58.570]                           master <- get("master", mode = "list", 
[10:32:58.570]                             envir = envir, inherits = FALSE)
[10:32:58.570]                           if (inherits(master, c("SOCKnode", 
[10:32:58.570]                             "SOCK0node"))) {
[10:32:58.570]                             sendCondition <<- function(cond) {
[10:32:58.570]                               data <- list(type = "VALUE", value = cond, 
[10:32:58.570]                                 success = TRUE)
[10:32:58.570]                               parallel_sendData(master, data)
[10:32:58.570]                             }
[10:32:58.570]                             return(sendCondition)
[10:32:58.570]                           }
[10:32:58.570]                         }
[10:32:58.570]                         frame <- frame + 1L
[10:32:58.570]                         envir <- sys.frame(frame)
[10:32:58.570]                       }
[10:32:58.570]                     }
[10:32:58.570]                     sendCondition <<- function(cond) NULL
[10:32:58.570]                   }
[10:32:58.570]                 })
[10:32:58.570]                 withCallingHandlers({
[10:32:58.570]                   {
[10:32:58.570]                     lm(weight ~ group - 1)
[10:32:58.570]                   }
[10:32:58.570]                 }, immediateCondition = function(cond) {
[10:32:58.570]                   sendCondition <- ...future.makeSendCondition()
[10:32:58.570]                   sendCondition(cond)
[10:32:58.570]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.570]                   {
[10:32:58.570]                     inherits <- base::inherits
[10:32:58.570]                     invokeRestart <- base::invokeRestart
[10:32:58.570]                     is.null <- base::is.null
[10:32:58.570]                     muffled <- FALSE
[10:32:58.570]                     if (inherits(cond, "message")) {
[10:32:58.570]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:58.570]                       if (muffled) 
[10:32:58.570]                         invokeRestart("muffleMessage")
[10:32:58.570]                     }
[10:32:58.570]                     else if (inherits(cond, "warning")) {
[10:32:58.570]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:58.570]                       if (muffled) 
[10:32:58.570]                         invokeRestart("muffleWarning")
[10:32:58.570]                     }
[10:32:58.570]                     else if (inherits(cond, "condition")) {
[10:32:58.570]                       if (!is.null(pattern)) {
[10:32:58.570]                         computeRestarts <- base::computeRestarts
[10:32:58.570]                         grepl <- base::grepl
[10:32:58.570]                         restarts <- computeRestarts(cond)
[10:32:58.570]                         for (restart in restarts) {
[10:32:58.570]                           name <- restart$name
[10:32:58.570]                           if (is.null(name)) 
[10:32:58.570]                             next
[10:32:58.570]                           if (!grepl(pattern, name)) 
[10:32:58.570]                             next
[10:32:58.570]                           invokeRestart(restart)
[10:32:58.570]                           muffled <- TRUE
[10:32:58.570]                           break
[10:32:58.570]                         }
[10:32:58.570]                       }
[10:32:58.570]                     }
[10:32:58.570]                     invisible(muffled)
[10:32:58.570]                   }
[10:32:58.570]                   muffleCondition(cond)
[10:32:58.570]                 })
[10:32:58.570]             }))
[10:32:58.570]             future::FutureResult(value = ...future.value$value, 
[10:32:58.570]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:58.570]                   ...future.rng), globalenv = if (FALSE) 
[10:32:58.570]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:58.570]                     ...future.globalenv.names))
[10:32:58.570]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:58.570]         }, condition = base::local({
[10:32:58.570]             c <- base::c
[10:32:58.570]             inherits <- base::inherits
[10:32:58.570]             invokeRestart <- base::invokeRestart
[10:32:58.570]             length <- base::length
[10:32:58.570]             list <- base::list
[10:32:58.570]             seq.int <- base::seq.int
[10:32:58.570]             signalCondition <- base::signalCondition
[10:32:58.570]             sys.calls <- base::sys.calls
[10:32:58.570]             `[[` <- base::`[[`
[10:32:58.570]             `+` <- base::`+`
[10:32:58.570]             `<<-` <- base::`<<-`
[10:32:58.570]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:58.570]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:58.570]                   3L)]
[10:32:58.570]             }
[10:32:58.570]             function(cond) {
[10:32:58.570]                 is_error <- inherits(cond, "error")
[10:32:58.570]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:58.570]                   NULL)
[10:32:58.570]                 if (is_error) {
[10:32:58.570]                   sessionInformation <- function() {
[10:32:58.570]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:58.570]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:58.570]                       search = base::search(), system = base::Sys.info())
[10:32:58.570]                   }
[10:32:58.570]                   ...future.conditions[[length(...future.conditions) + 
[10:32:58.570]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:58.570]                     cond$call), session = sessionInformation(), 
[10:32:58.570]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:58.570]                   signalCondition(cond)
[10:32:58.570]                 }
[10:32:58.570]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:58.570]                 "immediateCondition"))) {
[10:32:58.570]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:58.570]                   ...future.conditions[[length(...future.conditions) + 
[10:32:58.570]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:58.570]                   if (TRUE && !signal) {
[10:32:58.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.570]                     {
[10:32:58.570]                       inherits <- base::inherits
[10:32:58.570]                       invokeRestart <- base::invokeRestart
[10:32:58.570]                       is.null <- base::is.null
[10:32:58.570]                       muffled <- FALSE
[10:32:58.570]                       if (inherits(cond, "message")) {
[10:32:58.570]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:58.570]                         if (muffled) 
[10:32:58.570]                           invokeRestart("muffleMessage")
[10:32:58.570]                       }
[10:32:58.570]                       else if (inherits(cond, "warning")) {
[10:32:58.570]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:58.570]                         if (muffled) 
[10:32:58.570]                           invokeRestart("muffleWarning")
[10:32:58.570]                       }
[10:32:58.570]                       else if (inherits(cond, "condition")) {
[10:32:58.570]                         if (!is.null(pattern)) {
[10:32:58.570]                           computeRestarts <- base::computeRestarts
[10:32:58.570]                           grepl <- base::grepl
[10:32:58.570]                           restarts <- computeRestarts(cond)
[10:32:58.570]                           for (restart in restarts) {
[10:32:58.570]                             name <- restart$name
[10:32:58.570]                             if (is.null(name)) 
[10:32:58.570]                               next
[10:32:58.570]                             if (!grepl(pattern, name)) 
[10:32:58.570]                               next
[10:32:58.570]                             invokeRestart(restart)
[10:32:58.570]                             muffled <- TRUE
[10:32:58.570]                             break
[10:32:58.570]                           }
[10:32:58.570]                         }
[10:32:58.570]                       }
[10:32:58.570]                       invisible(muffled)
[10:32:58.570]                     }
[10:32:58.570]                     muffleCondition(cond, pattern = "^muffle")
[10:32:58.570]                   }
[10:32:58.570]                 }
[10:32:58.570]                 else {
[10:32:58.570]                   if (TRUE) {
[10:32:58.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.570]                     {
[10:32:58.570]                       inherits <- base::inherits
[10:32:58.570]                       invokeRestart <- base::invokeRestart
[10:32:58.570]                       is.null <- base::is.null
[10:32:58.570]                       muffled <- FALSE
[10:32:58.570]                       if (inherits(cond, "message")) {
[10:32:58.570]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:58.570]                         if (muffled) 
[10:32:58.570]                           invokeRestart("muffleMessage")
[10:32:58.570]                       }
[10:32:58.570]                       else if (inherits(cond, "warning")) {
[10:32:58.570]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:58.570]                         if (muffled) 
[10:32:58.570]                           invokeRestart("muffleWarning")
[10:32:58.570]                       }
[10:32:58.570]                       else if (inherits(cond, "condition")) {
[10:32:58.570]                         if (!is.null(pattern)) {
[10:32:58.570]                           computeRestarts <- base::computeRestarts
[10:32:58.570]                           grepl <- base::grepl
[10:32:58.570]                           restarts <- computeRestarts(cond)
[10:32:58.570]                           for (restart in restarts) {
[10:32:58.570]                             name <- restart$name
[10:32:58.570]                             if (is.null(name)) 
[10:32:58.570]                               next
[10:32:58.570]                             if (!grepl(pattern, name)) 
[10:32:58.570]                               next
[10:32:58.570]                             invokeRestart(restart)
[10:32:58.570]                             muffled <- TRUE
[10:32:58.570]                             break
[10:32:58.570]                           }
[10:32:58.570]                         }
[10:32:58.570]                       }
[10:32:58.570]                       invisible(muffled)
[10:32:58.570]                     }
[10:32:58.570]                     muffleCondition(cond, pattern = "^muffle")
[10:32:58.570]                   }
[10:32:58.570]                 }
[10:32:58.570]             }
[10:32:58.570]         }))
[10:32:58.570]     }, error = function(ex) {
[10:32:58.570]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:58.570]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:58.570]                 ...future.rng), started = ...future.startTime, 
[10:32:58.570]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:58.570]             version = "1.8"), class = "FutureResult")
[10:32:58.570]     }, finally = {
[10:32:58.570]         if (!identical(...future.workdir, getwd())) 
[10:32:58.570]             setwd(...future.workdir)
[10:32:58.570]         {
[10:32:58.570]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:58.570]                 ...future.oldOptions$nwarnings <- NULL
[10:32:58.570]             }
[10:32:58.570]             base::options(...future.oldOptions)
[10:32:58.570]             if (.Platform$OS.type == "windows") {
[10:32:58.570]                 old_names <- names(...future.oldEnvVars)
[10:32:58.570]                 envs <- base::Sys.getenv()
[10:32:58.570]                 names <- names(envs)
[10:32:58.570]                 common <- intersect(names, old_names)
[10:32:58.570]                 added <- setdiff(names, old_names)
[10:32:58.570]                 removed <- setdiff(old_names, names)
[10:32:58.570]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:58.570]                   envs[common]]
[10:32:58.570]                 NAMES <- toupper(changed)
[10:32:58.570]                 args <- list()
[10:32:58.570]                 for (kk in seq_along(NAMES)) {
[10:32:58.570]                   name <- changed[[kk]]
[10:32:58.570]                   NAME <- NAMES[[kk]]
[10:32:58.570]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.570]                     next
[10:32:58.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:58.570]                 }
[10:32:58.570]                 NAMES <- toupper(added)
[10:32:58.570]                 for (kk in seq_along(NAMES)) {
[10:32:58.570]                   name <- added[[kk]]
[10:32:58.570]                   NAME <- NAMES[[kk]]
[10:32:58.570]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.570]                     next
[10:32:58.570]                   args[[name]] <- ""
[10:32:58.570]                 }
[10:32:58.570]                 NAMES <- toupper(removed)
[10:32:58.570]                 for (kk in seq_along(NAMES)) {
[10:32:58.570]                   name <- removed[[kk]]
[10:32:58.570]                   NAME <- NAMES[[kk]]
[10:32:58.570]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.570]                     next
[10:32:58.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:58.570]                 }
[10:32:58.570]                 if (length(args) > 0) 
[10:32:58.570]                   base::do.call(base::Sys.setenv, args = args)
[10:32:58.570]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:58.570]             }
[10:32:58.570]             else {
[10:32:58.570]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:58.570]             }
[10:32:58.570]             {
[10:32:58.570]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:58.570]                   0L) {
[10:32:58.570]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:58.570]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:58.570]                   base::options(opts)
[10:32:58.570]                 }
[10:32:58.570]                 {
[10:32:58.570]                   {
[10:32:58.570]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:58.570]                     NULL
[10:32:58.570]                   }
[10:32:58.570]                   options(future.plan = NULL)
[10:32:58.570]                   if (is.na(NA_character_)) 
[10:32:58.570]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:58.570]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:58.570]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:58.570]                     .init = FALSE)
[10:32:58.570]                 }
[10:32:58.570]             }
[10:32:58.570]         }
[10:32:58.570]     })
[10:32:58.570]     if (TRUE) {
[10:32:58.570]         base::sink(type = "output", split = FALSE)
[10:32:58.570]         if (TRUE) {
[10:32:58.570]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:58.570]         }
[10:32:58.570]         else {
[10:32:58.570]             ...future.result["stdout"] <- base::list(NULL)
[10:32:58.570]         }
[10:32:58.570]         base::close(...future.stdout)
[10:32:58.570]         ...future.stdout <- NULL
[10:32:58.570]     }
[10:32:58.570]     ...future.result$conditions <- ...future.conditions
[10:32:58.570]     ...future.result$finished <- base::Sys.time()
[10:32:58.570]     ...future.result
[10:32:58.570] }
[10:32:58.573] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[10:32:58.573] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[10:32:58.573] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[10:32:58.573] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[10:32:58.574] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[10:32:58.574] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[10:32:58.574] MultisessionFuture started
[10:32:58.574] - Launch lazy future ... done
[10:32:58.575] run() for ‘MultisessionFuture’ ... done
[10:32:58.575] result() for ClusterFuture ...
[10:32:58.575] receiveMessageFromWorker() for ClusterFuture ...
[10:32:58.575] - Validating connection of MultisessionFuture
[10:32:58.619] - received message: FutureResult
[10:32:58.619] - Received FutureResult
[10:32:58.619] - Erased future from FutureRegistry
[10:32:58.619] result() for ClusterFuture ...
[10:32:58.619] - result already collected: FutureResult
[10:32:58.620] result() for ClusterFuture ... done
[10:32:58.620] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:58.620] result() for ClusterFuture ... done
[10:32:58.620] result() for ClusterFuture ...
[10:32:58.620] - result already collected: FutureResult
[10:32:58.620] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:32:58.622] getGlobalsAndPackages() ...
[10:32:58.622] Searching for globals...
[10:32:58.623] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:32:58.623] Searching for globals ... DONE
[10:32:58.623] Resolving globals: FALSE
[10:32:58.624] The total size of the 2 globals is 896 bytes (896 bytes)
[10:32:58.624] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:32:58.624] - globals: [2] ‘weight’, ‘group’
[10:32:58.625] - packages: [1] ‘stats’
[10:32:58.625] getGlobalsAndPackages() ... DONE
[10:32:58.625] run() for ‘Future’ ...
[10:32:58.625] - state: ‘created’
[10:32:58.625] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:58.640] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:58.640] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:58.641]   - Field: ‘node’
[10:32:58.641]   - Field: ‘label’
[10:32:58.641]   - Field: ‘local’
[10:32:58.641]   - Field: ‘owner’
[10:32:58.641]   - Field: ‘envir’
[10:32:58.641]   - Field: ‘workers’
[10:32:58.641]   - Field: ‘packages’
[10:32:58.641]   - Field: ‘gc’
[10:32:58.641]   - Field: ‘conditions’
[10:32:58.642]   - Field: ‘persistent’
[10:32:58.642]   - Field: ‘expr’
[10:32:58.642]   - Field: ‘uuid’
[10:32:58.642]   - Field: ‘seed’
[10:32:58.642]   - Field: ‘version’
[10:32:58.642]   - Field: ‘result’
[10:32:58.642]   - Field: ‘asynchronous’
[10:32:58.642]   - Field: ‘calls’
[10:32:58.642]   - Field: ‘globals’
[10:32:58.642]   - Field: ‘stdout’
[10:32:58.642]   - Field: ‘earlySignal’
[10:32:58.643]   - Field: ‘lazy’
[10:32:58.643]   - Field: ‘state’
[10:32:58.643] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:58.643] - Launch lazy future ...
[10:32:58.643] Packages needed by the future expression (n = 1): ‘stats’
[10:32:58.643] Packages needed by future strategies (n = 0): <none>
[10:32:58.644] {
[10:32:58.644]     {
[10:32:58.644]         {
[10:32:58.644]             ...future.startTime <- base::Sys.time()
[10:32:58.644]             {
[10:32:58.644]                 {
[10:32:58.644]                   {
[10:32:58.644]                     {
[10:32:58.644]                       {
[10:32:58.644]                         base::local({
[10:32:58.644]                           has_future <- base::requireNamespace("future", 
[10:32:58.644]                             quietly = TRUE)
[10:32:58.644]                           if (has_future) {
[10:32:58.644]                             ns <- base::getNamespace("future")
[10:32:58.644]                             version <- ns[[".package"]][["version"]]
[10:32:58.644]                             if (is.null(version)) 
[10:32:58.644]                               version <- utils::packageVersion("future")
[10:32:58.644]                           }
[10:32:58.644]                           else {
[10:32:58.644]                             version <- NULL
[10:32:58.644]                           }
[10:32:58.644]                           if (!has_future || version < "1.8.0") {
[10:32:58.644]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:58.644]                               "", base::R.version$version.string), 
[10:32:58.644]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:58.644]                                 base::R.version$platform, 8 * 
[10:32:58.644]                                   base::.Machine$sizeof.pointer), 
[10:32:58.644]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:58.644]                                 "release", "version")], collapse = " "), 
[10:32:58.644]                               hostname = base::Sys.info()[["nodename"]])
[10:32:58.644]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:58.644]                               info)
[10:32:58.644]                             info <- base::paste(info, collapse = "; ")
[10:32:58.644]                             if (!has_future) {
[10:32:58.644]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:58.644]                                 info)
[10:32:58.644]                             }
[10:32:58.644]                             else {
[10:32:58.644]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:58.644]                                 info, version)
[10:32:58.644]                             }
[10:32:58.644]                             base::stop(msg)
[10:32:58.644]                           }
[10:32:58.644]                         })
[10:32:58.644]                       }
[10:32:58.644]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:58.644]                       base::options(mc.cores = 1L)
[10:32:58.644]                     }
[10:32:58.644]                     base::local({
[10:32:58.644]                       for (pkg in "stats") {
[10:32:58.644]                         base::loadNamespace(pkg)
[10:32:58.644]                         base::library(pkg, character.only = TRUE)
[10:32:58.644]                       }
[10:32:58.644]                     })
[10:32:58.644]                   }
[10:32:58.644]                   ...future.strategy.old <- future::plan("list")
[10:32:58.644]                   options(future.plan = NULL)
[10:32:58.644]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:58.644]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:58.644]                 }
[10:32:58.644]                 ...future.workdir <- getwd()
[10:32:58.644]             }
[10:32:58.644]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:58.644]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:58.644]         }
[10:32:58.644]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:58.644]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:58.644]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:58.644]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:58.644]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:58.644]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:58.644]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:58.644]             base::names(...future.oldOptions))
[10:32:58.644]     }
[10:32:58.644]     if (FALSE) {
[10:32:58.644]     }
[10:32:58.644]     else {
[10:32:58.644]         if (TRUE) {
[10:32:58.644]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:58.644]                 open = "w")
[10:32:58.644]         }
[10:32:58.644]         else {
[10:32:58.644]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:58.644]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:58.644]         }
[10:32:58.644]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:58.644]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:58.644]             base::sink(type = "output", split = FALSE)
[10:32:58.644]             base::close(...future.stdout)
[10:32:58.644]         }, add = TRUE)
[10:32:58.644]     }
[10:32:58.644]     ...future.frame <- base::sys.nframe()
[10:32:58.644]     ...future.conditions <- base::list()
[10:32:58.644]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:58.644]     if (FALSE) {
[10:32:58.644]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:58.644]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:58.644]     }
[10:32:58.644]     ...future.result <- base::tryCatch({
[10:32:58.644]         base::withCallingHandlers({
[10:32:58.644]             ...future.value <- base::withVisible(base::local({
[10:32:58.644]                 ...future.makeSendCondition <- base::local({
[10:32:58.644]                   sendCondition <- NULL
[10:32:58.644]                   function(frame = 1L) {
[10:32:58.644]                     if (is.function(sendCondition)) 
[10:32:58.644]                       return(sendCondition)
[10:32:58.644]                     ns <- getNamespace("parallel")
[10:32:58.644]                     if (exists("sendData", mode = "function", 
[10:32:58.644]                       envir = ns)) {
[10:32:58.644]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:58.644]                         envir = ns)
[10:32:58.644]                       envir <- sys.frame(frame)
[10:32:58.644]                       master <- NULL
[10:32:58.644]                       while (!identical(envir, .GlobalEnv) && 
[10:32:58.644]                         !identical(envir, emptyenv())) {
[10:32:58.644]                         if (exists("master", mode = "list", envir = envir, 
[10:32:58.644]                           inherits = FALSE)) {
[10:32:58.644]                           master <- get("master", mode = "list", 
[10:32:58.644]                             envir = envir, inherits = FALSE)
[10:32:58.644]                           if (inherits(master, c("SOCKnode", 
[10:32:58.644]                             "SOCK0node"))) {
[10:32:58.644]                             sendCondition <<- function(cond) {
[10:32:58.644]                               data <- list(type = "VALUE", value = cond, 
[10:32:58.644]                                 success = TRUE)
[10:32:58.644]                               parallel_sendData(master, data)
[10:32:58.644]                             }
[10:32:58.644]                             return(sendCondition)
[10:32:58.644]                           }
[10:32:58.644]                         }
[10:32:58.644]                         frame <- frame + 1L
[10:32:58.644]                         envir <- sys.frame(frame)
[10:32:58.644]                       }
[10:32:58.644]                     }
[10:32:58.644]                     sendCondition <<- function(cond) NULL
[10:32:58.644]                   }
[10:32:58.644]                 })
[10:32:58.644]                 withCallingHandlers({
[10:32:58.644]                   {
[10:32:58.644]                     lm(weight ~ group - 1)
[10:32:58.644]                   }
[10:32:58.644]                 }, immediateCondition = function(cond) {
[10:32:58.644]                   sendCondition <- ...future.makeSendCondition()
[10:32:58.644]                   sendCondition(cond)
[10:32:58.644]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.644]                   {
[10:32:58.644]                     inherits <- base::inherits
[10:32:58.644]                     invokeRestart <- base::invokeRestart
[10:32:58.644]                     is.null <- base::is.null
[10:32:58.644]                     muffled <- FALSE
[10:32:58.644]                     if (inherits(cond, "message")) {
[10:32:58.644]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:58.644]                       if (muffled) 
[10:32:58.644]                         invokeRestart("muffleMessage")
[10:32:58.644]                     }
[10:32:58.644]                     else if (inherits(cond, "warning")) {
[10:32:58.644]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:58.644]                       if (muffled) 
[10:32:58.644]                         invokeRestart("muffleWarning")
[10:32:58.644]                     }
[10:32:58.644]                     else if (inherits(cond, "condition")) {
[10:32:58.644]                       if (!is.null(pattern)) {
[10:32:58.644]                         computeRestarts <- base::computeRestarts
[10:32:58.644]                         grepl <- base::grepl
[10:32:58.644]                         restarts <- computeRestarts(cond)
[10:32:58.644]                         for (restart in restarts) {
[10:32:58.644]                           name <- restart$name
[10:32:58.644]                           if (is.null(name)) 
[10:32:58.644]                             next
[10:32:58.644]                           if (!grepl(pattern, name)) 
[10:32:58.644]                             next
[10:32:58.644]                           invokeRestart(restart)
[10:32:58.644]                           muffled <- TRUE
[10:32:58.644]                           break
[10:32:58.644]                         }
[10:32:58.644]                       }
[10:32:58.644]                     }
[10:32:58.644]                     invisible(muffled)
[10:32:58.644]                   }
[10:32:58.644]                   muffleCondition(cond)
[10:32:58.644]                 })
[10:32:58.644]             }))
[10:32:58.644]             future::FutureResult(value = ...future.value$value, 
[10:32:58.644]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:58.644]                   ...future.rng), globalenv = if (FALSE) 
[10:32:58.644]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:58.644]                     ...future.globalenv.names))
[10:32:58.644]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:58.644]         }, condition = base::local({
[10:32:58.644]             c <- base::c
[10:32:58.644]             inherits <- base::inherits
[10:32:58.644]             invokeRestart <- base::invokeRestart
[10:32:58.644]             length <- base::length
[10:32:58.644]             list <- base::list
[10:32:58.644]             seq.int <- base::seq.int
[10:32:58.644]             signalCondition <- base::signalCondition
[10:32:58.644]             sys.calls <- base::sys.calls
[10:32:58.644]             `[[` <- base::`[[`
[10:32:58.644]             `+` <- base::`+`
[10:32:58.644]             `<<-` <- base::`<<-`
[10:32:58.644]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:58.644]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:58.644]                   3L)]
[10:32:58.644]             }
[10:32:58.644]             function(cond) {
[10:32:58.644]                 is_error <- inherits(cond, "error")
[10:32:58.644]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:58.644]                   NULL)
[10:32:58.644]                 if (is_error) {
[10:32:58.644]                   sessionInformation <- function() {
[10:32:58.644]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:58.644]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:58.644]                       search = base::search(), system = base::Sys.info())
[10:32:58.644]                   }
[10:32:58.644]                   ...future.conditions[[length(...future.conditions) + 
[10:32:58.644]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:58.644]                     cond$call), session = sessionInformation(), 
[10:32:58.644]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:58.644]                   signalCondition(cond)
[10:32:58.644]                 }
[10:32:58.644]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:58.644]                 "immediateCondition"))) {
[10:32:58.644]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:58.644]                   ...future.conditions[[length(...future.conditions) + 
[10:32:58.644]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:58.644]                   if (TRUE && !signal) {
[10:32:58.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.644]                     {
[10:32:58.644]                       inherits <- base::inherits
[10:32:58.644]                       invokeRestart <- base::invokeRestart
[10:32:58.644]                       is.null <- base::is.null
[10:32:58.644]                       muffled <- FALSE
[10:32:58.644]                       if (inherits(cond, "message")) {
[10:32:58.644]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:58.644]                         if (muffled) 
[10:32:58.644]                           invokeRestart("muffleMessage")
[10:32:58.644]                       }
[10:32:58.644]                       else if (inherits(cond, "warning")) {
[10:32:58.644]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:58.644]                         if (muffled) 
[10:32:58.644]                           invokeRestart("muffleWarning")
[10:32:58.644]                       }
[10:32:58.644]                       else if (inherits(cond, "condition")) {
[10:32:58.644]                         if (!is.null(pattern)) {
[10:32:58.644]                           computeRestarts <- base::computeRestarts
[10:32:58.644]                           grepl <- base::grepl
[10:32:58.644]                           restarts <- computeRestarts(cond)
[10:32:58.644]                           for (restart in restarts) {
[10:32:58.644]                             name <- restart$name
[10:32:58.644]                             if (is.null(name)) 
[10:32:58.644]                               next
[10:32:58.644]                             if (!grepl(pattern, name)) 
[10:32:58.644]                               next
[10:32:58.644]                             invokeRestart(restart)
[10:32:58.644]                             muffled <- TRUE
[10:32:58.644]                             break
[10:32:58.644]                           }
[10:32:58.644]                         }
[10:32:58.644]                       }
[10:32:58.644]                       invisible(muffled)
[10:32:58.644]                     }
[10:32:58.644]                     muffleCondition(cond, pattern = "^muffle")
[10:32:58.644]                   }
[10:32:58.644]                 }
[10:32:58.644]                 else {
[10:32:58.644]                   if (TRUE) {
[10:32:58.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.644]                     {
[10:32:58.644]                       inherits <- base::inherits
[10:32:58.644]                       invokeRestart <- base::invokeRestart
[10:32:58.644]                       is.null <- base::is.null
[10:32:58.644]                       muffled <- FALSE
[10:32:58.644]                       if (inherits(cond, "message")) {
[10:32:58.644]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:58.644]                         if (muffled) 
[10:32:58.644]                           invokeRestart("muffleMessage")
[10:32:58.644]                       }
[10:32:58.644]                       else if (inherits(cond, "warning")) {
[10:32:58.644]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:58.644]                         if (muffled) 
[10:32:58.644]                           invokeRestart("muffleWarning")
[10:32:58.644]                       }
[10:32:58.644]                       else if (inherits(cond, "condition")) {
[10:32:58.644]                         if (!is.null(pattern)) {
[10:32:58.644]                           computeRestarts <- base::computeRestarts
[10:32:58.644]                           grepl <- base::grepl
[10:32:58.644]                           restarts <- computeRestarts(cond)
[10:32:58.644]                           for (restart in restarts) {
[10:32:58.644]                             name <- restart$name
[10:32:58.644]                             if (is.null(name)) 
[10:32:58.644]                               next
[10:32:58.644]                             if (!grepl(pattern, name)) 
[10:32:58.644]                               next
[10:32:58.644]                             invokeRestart(restart)
[10:32:58.644]                             muffled <- TRUE
[10:32:58.644]                             break
[10:32:58.644]                           }
[10:32:58.644]                         }
[10:32:58.644]                       }
[10:32:58.644]                       invisible(muffled)
[10:32:58.644]                     }
[10:32:58.644]                     muffleCondition(cond, pattern = "^muffle")
[10:32:58.644]                   }
[10:32:58.644]                 }
[10:32:58.644]             }
[10:32:58.644]         }))
[10:32:58.644]     }, error = function(ex) {
[10:32:58.644]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:58.644]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:58.644]                 ...future.rng), started = ...future.startTime, 
[10:32:58.644]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:58.644]             version = "1.8"), class = "FutureResult")
[10:32:58.644]     }, finally = {
[10:32:58.644]         if (!identical(...future.workdir, getwd())) 
[10:32:58.644]             setwd(...future.workdir)
[10:32:58.644]         {
[10:32:58.644]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:58.644]                 ...future.oldOptions$nwarnings <- NULL
[10:32:58.644]             }
[10:32:58.644]             base::options(...future.oldOptions)
[10:32:58.644]             if (.Platform$OS.type == "windows") {
[10:32:58.644]                 old_names <- names(...future.oldEnvVars)
[10:32:58.644]                 envs <- base::Sys.getenv()
[10:32:58.644]                 names <- names(envs)
[10:32:58.644]                 common <- intersect(names, old_names)
[10:32:58.644]                 added <- setdiff(names, old_names)
[10:32:58.644]                 removed <- setdiff(old_names, names)
[10:32:58.644]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:58.644]                   envs[common]]
[10:32:58.644]                 NAMES <- toupper(changed)
[10:32:58.644]                 args <- list()
[10:32:58.644]                 for (kk in seq_along(NAMES)) {
[10:32:58.644]                   name <- changed[[kk]]
[10:32:58.644]                   NAME <- NAMES[[kk]]
[10:32:58.644]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.644]                     next
[10:32:58.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:58.644]                 }
[10:32:58.644]                 NAMES <- toupper(added)
[10:32:58.644]                 for (kk in seq_along(NAMES)) {
[10:32:58.644]                   name <- added[[kk]]
[10:32:58.644]                   NAME <- NAMES[[kk]]
[10:32:58.644]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.644]                     next
[10:32:58.644]                   args[[name]] <- ""
[10:32:58.644]                 }
[10:32:58.644]                 NAMES <- toupper(removed)
[10:32:58.644]                 for (kk in seq_along(NAMES)) {
[10:32:58.644]                   name <- removed[[kk]]
[10:32:58.644]                   NAME <- NAMES[[kk]]
[10:32:58.644]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.644]                     next
[10:32:58.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:58.644]                 }
[10:32:58.644]                 if (length(args) > 0) 
[10:32:58.644]                   base::do.call(base::Sys.setenv, args = args)
[10:32:58.644]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:58.644]             }
[10:32:58.644]             else {
[10:32:58.644]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:58.644]             }
[10:32:58.644]             {
[10:32:58.644]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:58.644]                   0L) {
[10:32:58.644]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:58.644]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:58.644]                   base::options(opts)
[10:32:58.644]                 }
[10:32:58.644]                 {
[10:32:58.644]                   {
[10:32:58.644]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:58.644]                     NULL
[10:32:58.644]                   }
[10:32:58.644]                   options(future.plan = NULL)
[10:32:58.644]                   if (is.na(NA_character_)) 
[10:32:58.644]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:58.644]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:58.644]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:58.644]                     .init = FALSE)
[10:32:58.644]                 }
[10:32:58.644]             }
[10:32:58.644]         }
[10:32:58.644]     })
[10:32:58.644]     if (TRUE) {
[10:32:58.644]         base::sink(type = "output", split = FALSE)
[10:32:58.644]         if (TRUE) {
[10:32:58.644]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:58.644]         }
[10:32:58.644]         else {
[10:32:58.644]             ...future.result["stdout"] <- base::list(NULL)
[10:32:58.644]         }
[10:32:58.644]         base::close(...future.stdout)
[10:32:58.644]         ...future.stdout <- NULL
[10:32:58.644]     }
[10:32:58.644]     ...future.result$conditions <- ...future.conditions
[10:32:58.644]     ...future.result$finished <- base::Sys.time()
[10:32:58.644]     ...future.result
[10:32:58.644] }
[10:32:58.646] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[10:32:58.646] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[10:32:58.647] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[10:32:58.647] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[10:32:58.647] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[10:32:58.647] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[10:32:58.648] MultisessionFuture started
[10:32:58.648] - Launch lazy future ... done
[10:32:58.648] run() for ‘MultisessionFuture’ ... done
[10:32:58.648] result() for ClusterFuture ...
[10:32:58.648] receiveMessageFromWorker() for ClusterFuture ...
[10:32:58.648] - Validating connection of MultisessionFuture
[10:32:58.691] - received message: FutureResult
[10:32:58.691] - Received FutureResult
[10:32:58.692] - Erased future from FutureRegistry
[10:32:58.692] result() for ClusterFuture ...
[10:32:58.692] - result already collected: FutureResult
[10:32:58.692] result() for ClusterFuture ... done
[10:32:58.692] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:58.692] result() for ClusterFuture ... done
[10:32:58.692] result() for ClusterFuture ...
[10:32:58.692] - result already collected: FutureResult
[10:32:58.692] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[10:32:58.694] getGlobalsAndPackages() ...
[10:32:58.694] Searching for globals...
[10:32:58.695] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[10:32:58.695] Searching for globals ... DONE
[10:32:58.696] Resolving globals: FALSE
[10:32:58.696] The total size of the 1 globals is 96 bytes (96 bytes)
[10:32:58.696] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[10:32:58.696] - globals: [1] ‘x’
[10:32:58.697] - packages: [1] ‘stats’
[10:32:58.697] getGlobalsAndPackages() ... DONE
[10:32:58.697] run() for ‘Future’ ...
[10:32:58.697] - state: ‘created’
[10:32:58.697] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:58.711] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:58.711] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:58.711]   - Field: ‘node’
[10:32:58.711]   - Field: ‘label’
[10:32:58.711]   - Field: ‘local’
[10:32:58.711]   - Field: ‘owner’
[10:32:58.712]   - Field: ‘envir’
[10:32:58.712]   - Field: ‘workers’
[10:32:58.712]   - Field: ‘packages’
[10:32:58.712]   - Field: ‘gc’
[10:32:58.712]   - Field: ‘conditions’
[10:32:58.712]   - Field: ‘persistent’
[10:32:58.712]   - Field: ‘expr’
[10:32:58.712]   - Field: ‘uuid’
[10:32:58.712]   - Field: ‘seed’
[10:32:58.712]   - Field: ‘version’
[10:32:58.712]   - Field: ‘result’
[10:32:58.713]   - Field: ‘asynchronous’
[10:32:58.713]   - Field: ‘calls’
[10:32:58.713]   - Field: ‘globals’
[10:32:58.713]   - Field: ‘stdout’
[10:32:58.713]   - Field: ‘earlySignal’
[10:32:58.713]   - Field: ‘lazy’
[10:32:58.713]   - Field: ‘state’
[10:32:58.713] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:58.713] - Launch lazy future ...
[10:32:58.714] Packages needed by the future expression (n = 1): ‘stats’
[10:32:58.714] Packages needed by future strategies (n = 0): <none>
[10:32:58.714] {
[10:32:58.714]     {
[10:32:58.714]         {
[10:32:58.714]             ...future.startTime <- base::Sys.time()
[10:32:58.714]             {
[10:32:58.714]                 {
[10:32:58.714]                   {
[10:32:58.714]                     {
[10:32:58.714]                       {
[10:32:58.714]                         base::local({
[10:32:58.714]                           has_future <- base::requireNamespace("future", 
[10:32:58.714]                             quietly = TRUE)
[10:32:58.714]                           if (has_future) {
[10:32:58.714]                             ns <- base::getNamespace("future")
[10:32:58.714]                             version <- ns[[".package"]][["version"]]
[10:32:58.714]                             if (is.null(version)) 
[10:32:58.714]                               version <- utils::packageVersion("future")
[10:32:58.714]                           }
[10:32:58.714]                           else {
[10:32:58.714]                             version <- NULL
[10:32:58.714]                           }
[10:32:58.714]                           if (!has_future || version < "1.8.0") {
[10:32:58.714]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:58.714]                               "", base::R.version$version.string), 
[10:32:58.714]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:58.714]                                 base::R.version$platform, 8 * 
[10:32:58.714]                                   base::.Machine$sizeof.pointer), 
[10:32:58.714]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:58.714]                                 "release", "version")], collapse = " "), 
[10:32:58.714]                               hostname = base::Sys.info()[["nodename"]])
[10:32:58.714]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:58.714]                               info)
[10:32:58.714]                             info <- base::paste(info, collapse = "; ")
[10:32:58.714]                             if (!has_future) {
[10:32:58.714]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:58.714]                                 info)
[10:32:58.714]                             }
[10:32:58.714]                             else {
[10:32:58.714]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:58.714]                                 info, version)
[10:32:58.714]                             }
[10:32:58.714]                             base::stop(msg)
[10:32:58.714]                           }
[10:32:58.714]                         })
[10:32:58.714]                       }
[10:32:58.714]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:58.714]                       base::options(mc.cores = 1L)
[10:32:58.714]                     }
[10:32:58.714]                     base::local({
[10:32:58.714]                       for (pkg in "stats") {
[10:32:58.714]                         base::loadNamespace(pkg)
[10:32:58.714]                         base::library(pkg, character.only = TRUE)
[10:32:58.714]                       }
[10:32:58.714]                     })
[10:32:58.714]                   }
[10:32:58.714]                   ...future.strategy.old <- future::plan("list")
[10:32:58.714]                   options(future.plan = NULL)
[10:32:58.714]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:58.714]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:58.714]                 }
[10:32:58.714]                 ...future.workdir <- getwd()
[10:32:58.714]             }
[10:32:58.714]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:58.714]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:58.714]         }
[10:32:58.714]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:58.714]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:58.714]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:58.714]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:58.714]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:58.714]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:58.714]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:58.714]             base::names(...future.oldOptions))
[10:32:58.714]     }
[10:32:58.714]     if (FALSE) {
[10:32:58.714]     }
[10:32:58.714]     else {
[10:32:58.714]         if (TRUE) {
[10:32:58.714]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:58.714]                 open = "w")
[10:32:58.714]         }
[10:32:58.714]         else {
[10:32:58.714]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:58.714]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:58.714]         }
[10:32:58.714]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:58.714]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:58.714]             base::sink(type = "output", split = FALSE)
[10:32:58.714]             base::close(...future.stdout)
[10:32:58.714]         }, add = TRUE)
[10:32:58.714]     }
[10:32:58.714]     ...future.frame <- base::sys.nframe()
[10:32:58.714]     ...future.conditions <- base::list()
[10:32:58.714]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:58.714]     if (FALSE) {
[10:32:58.714]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:58.714]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:58.714]     }
[10:32:58.714]     ...future.result <- base::tryCatch({
[10:32:58.714]         base::withCallingHandlers({
[10:32:58.714]             ...future.value <- base::withVisible(base::local({
[10:32:58.714]                 ...future.makeSendCondition <- base::local({
[10:32:58.714]                   sendCondition <- NULL
[10:32:58.714]                   function(frame = 1L) {
[10:32:58.714]                     if (is.function(sendCondition)) 
[10:32:58.714]                       return(sendCondition)
[10:32:58.714]                     ns <- getNamespace("parallel")
[10:32:58.714]                     if (exists("sendData", mode = "function", 
[10:32:58.714]                       envir = ns)) {
[10:32:58.714]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:58.714]                         envir = ns)
[10:32:58.714]                       envir <- sys.frame(frame)
[10:32:58.714]                       master <- NULL
[10:32:58.714]                       while (!identical(envir, .GlobalEnv) && 
[10:32:58.714]                         !identical(envir, emptyenv())) {
[10:32:58.714]                         if (exists("master", mode = "list", envir = envir, 
[10:32:58.714]                           inherits = FALSE)) {
[10:32:58.714]                           master <- get("master", mode = "list", 
[10:32:58.714]                             envir = envir, inherits = FALSE)
[10:32:58.714]                           if (inherits(master, c("SOCKnode", 
[10:32:58.714]                             "SOCK0node"))) {
[10:32:58.714]                             sendCondition <<- function(cond) {
[10:32:58.714]                               data <- list(type = "VALUE", value = cond, 
[10:32:58.714]                                 success = TRUE)
[10:32:58.714]                               parallel_sendData(master, data)
[10:32:58.714]                             }
[10:32:58.714]                             return(sendCondition)
[10:32:58.714]                           }
[10:32:58.714]                         }
[10:32:58.714]                         frame <- frame + 1L
[10:32:58.714]                         envir <- sys.frame(frame)
[10:32:58.714]                       }
[10:32:58.714]                     }
[10:32:58.714]                     sendCondition <<- function(cond) NULL
[10:32:58.714]                   }
[10:32:58.714]                 })
[10:32:58.714]                 withCallingHandlers({
[10:32:58.714]                   {
[10:32:58.714]                     xtabs(~x)
[10:32:58.714]                   }
[10:32:58.714]                 }, immediateCondition = function(cond) {
[10:32:58.714]                   sendCondition <- ...future.makeSendCondition()
[10:32:58.714]                   sendCondition(cond)
[10:32:58.714]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.714]                   {
[10:32:58.714]                     inherits <- base::inherits
[10:32:58.714]                     invokeRestart <- base::invokeRestart
[10:32:58.714]                     is.null <- base::is.null
[10:32:58.714]                     muffled <- FALSE
[10:32:58.714]                     if (inherits(cond, "message")) {
[10:32:58.714]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:58.714]                       if (muffled) 
[10:32:58.714]                         invokeRestart("muffleMessage")
[10:32:58.714]                     }
[10:32:58.714]                     else if (inherits(cond, "warning")) {
[10:32:58.714]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:58.714]                       if (muffled) 
[10:32:58.714]                         invokeRestart("muffleWarning")
[10:32:58.714]                     }
[10:32:58.714]                     else if (inherits(cond, "condition")) {
[10:32:58.714]                       if (!is.null(pattern)) {
[10:32:58.714]                         computeRestarts <- base::computeRestarts
[10:32:58.714]                         grepl <- base::grepl
[10:32:58.714]                         restarts <- computeRestarts(cond)
[10:32:58.714]                         for (restart in restarts) {
[10:32:58.714]                           name <- restart$name
[10:32:58.714]                           if (is.null(name)) 
[10:32:58.714]                             next
[10:32:58.714]                           if (!grepl(pattern, name)) 
[10:32:58.714]                             next
[10:32:58.714]                           invokeRestart(restart)
[10:32:58.714]                           muffled <- TRUE
[10:32:58.714]                           break
[10:32:58.714]                         }
[10:32:58.714]                       }
[10:32:58.714]                     }
[10:32:58.714]                     invisible(muffled)
[10:32:58.714]                   }
[10:32:58.714]                   muffleCondition(cond)
[10:32:58.714]                 })
[10:32:58.714]             }))
[10:32:58.714]             future::FutureResult(value = ...future.value$value, 
[10:32:58.714]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:58.714]                   ...future.rng), globalenv = if (FALSE) 
[10:32:58.714]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:58.714]                     ...future.globalenv.names))
[10:32:58.714]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:58.714]         }, condition = base::local({
[10:32:58.714]             c <- base::c
[10:32:58.714]             inherits <- base::inherits
[10:32:58.714]             invokeRestart <- base::invokeRestart
[10:32:58.714]             length <- base::length
[10:32:58.714]             list <- base::list
[10:32:58.714]             seq.int <- base::seq.int
[10:32:58.714]             signalCondition <- base::signalCondition
[10:32:58.714]             sys.calls <- base::sys.calls
[10:32:58.714]             `[[` <- base::`[[`
[10:32:58.714]             `+` <- base::`+`
[10:32:58.714]             `<<-` <- base::`<<-`
[10:32:58.714]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:58.714]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:58.714]                   3L)]
[10:32:58.714]             }
[10:32:58.714]             function(cond) {
[10:32:58.714]                 is_error <- inherits(cond, "error")
[10:32:58.714]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:58.714]                   NULL)
[10:32:58.714]                 if (is_error) {
[10:32:58.714]                   sessionInformation <- function() {
[10:32:58.714]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:58.714]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:58.714]                       search = base::search(), system = base::Sys.info())
[10:32:58.714]                   }
[10:32:58.714]                   ...future.conditions[[length(...future.conditions) + 
[10:32:58.714]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:58.714]                     cond$call), session = sessionInformation(), 
[10:32:58.714]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:58.714]                   signalCondition(cond)
[10:32:58.714]                 }
[10:32:58.714]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:58.714]                 "immediateCondition"))) {
[10:32:58.714]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:58.714]                   ...future.conditions[[length(...future.conditions) + 
[10:32:58.714]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:58.714]                   if (TRUE && !signal) {
[10:32:58.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.714]                     {
[10:32:58.714]                       inherits <- base::inherits
[10:32:58.714]                       invokeRestart <- base::invokeRestart
[10:32:58.714]                       is.null <- base::is.null
[10:32:58.714]                       muffled <- FALSE
[10:32:58.714]                       if (inherits(cond, "message")) {
[10:32:58.714]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:58.714]                         if (muffled) 
[10:32:58.714]                           invokeRestart("muffleMessage")
[10:32:58.714]                       }
[10:32:58.714]                       else if (inherits(cond, "warning")) {
[10:32:58.714]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:58.714]                         if (muffled) 
[10:32:58.714]                           invokeRestart("muffleWarning")
[10:32:58.714]                       }
[10:32:58.714]                       else if (inherits(cond, "condition")) {
[10:32:58.714]                         if (!is.null(pattern)) {
[10:32:58.714]                           computeRestarts <- base::computeRestarts
[10:32:58.714]                           grepl <- base::grepl
[10:32:58.714]                           restarts <- computeRestarts(cond)
[10:32:58.714]                           for (restart in restarts) {
[10:32:58.714]                             name <- restart$name
[10:32:58.714]                             if (is.null(name)) 
[10:32:58.714]                               next
[10:32:58.714]                             if (!grepl(pattern, name)) 
[10:32:58.714]                               next
[10:32:58.714]                             invokeRestart(restart)
[10:32:58.714]                             muffled <- TRUE
[10:32:58.714]                             break
[10:32:58.714]                           }
[10:32:58.714]                         }
[10:32:58.714]                       }
[10:32:58.714]                       invisible(muffled)
[10:32:58.714]                     }
[10:32:58.714]                     muffleCondition(cond, pattern = "^muffle")
[10:32:58.714]                   }
[10:32:58.714]                 }
[10:32:58.714]                 else {
[10:32:58.714]                   if (TRUE) {
[10:32:58.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.714]                     {
[10:32:58.714]                       inherits <- base::inherits
[10:32:58.714]                       invokeRestart <- base::invokeRestart
[10:32:58.714]                       is.null <- base::is.null
[10:32:58.714]                       muffled <- FALSE
[10:32:58.714]                       if (inherits(cond, "message")) {
[10:32:58.714]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:58.714]                         if (muffled) 
[10:32:58.714]                           invokeRestart("muffleMessage")
[10:32:58.714]                       }
[10:32:58.714]                       else if (inherits(cond, "warning")) {
[10:32:58.714]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:58.714]                         if (muffled) 
[10:32:58.714]                           invokeRestart("muffleWarning")
[10:32:58.714]                       }
[10:32:58.714]                       else if (inherits(cond, "condition")) {
[10:32:58.714]                         if (!is.null(pattern)) {
[10:32:58.714]                           computeRestarts <- base::computeRestarts
[10:32:58.714]                           grepl <- base::grepl
[10:32:58.714]                           restarts <- computeRestarts(cond)
[10:32:58.714]                           for (restart in restarts) {
[10:32:58.714]                             name <- restart$name
[10:32:58.714]                             if (is.null(name)) 
[10:32:58.714]                               next
[10:32:58.714]                             if (!grepl(pattern, name)) 
[10:32:58.714]                               next
[10:32:58.714]                             invokeRestart(restart)
[10:32:58.714]                             muffled <- TRUE
[10:32:58.714]                             break
[10:32:58.714]                           }
[10:32:58.714]                         }
[10:32:58.714]                       }
[10:32:58.714]                       invisible(muffled)
[10:32:58.714]                     }
[10:32:58.714]                     muffleCondition(cond, pattern = "^muffle")
[10:32:58.714]                   }
[10:32:58.714]                 }
[10:32:58.714]             }
[10:32:58.714]         }))
[10:32:58.714]     }, error = function(ex) {
[10:32:58.714]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:58.714]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:58.714]                 ...future.rng), started = ...future.startTime, 
[10:32:58.714]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:58.714]             version = "1.8"), class = "FutureResult")
[10:32:58.714]     }, finally = {
[10:32:58.714]         if (!identical(...future.workdir, getwd())) 
[10:32:58.714]             setwd(...future.workdir)
[10:32:58.714]         {
[10:32:58.714]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:58.714]                 ...future.oldOptions$nwarnings <- NULL
[10:32:58.714]             }
[10:32:58.714]             base::options(...future.oldOptions)
[10:32:58.714]             if (.Platform$OS.type == "windows") {
[10:32:58.714]                 old_names <- names(...future.oldEnvVars)
[10:32:58.714]                 envs <- base::Sys.getenv()
[10:32:58.714]                 names <- names(envs)
[10:32:58.714]                 common <- intersect(names, old_names)
[10:32:58.714]                 added <- setdiff(names, old_names)
[10:32:58.714]                 removed <- setdiff(old_names, names)
[10:32:58.714]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:58.714]                   envs[common]]
[10:32:58.714]                 NAMES <- toupper(changed)
[10:32:58.714]                 args <- list()
[10:32:58.714]                 for (kk in seq_along(NAMES)) {
[10:32:58.714]                   name <- changed[[kk]]
[10:32:58.714]                   NAME <- NAMES[[kk]]
[10:32:58.714]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.714]                     next
[10:32:58.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:58.714]                 }
[10:32:58.714]                 NAMES <- toupper(added)
[10:32:58.714]                 for (kk in seq_along(NAMES)) {
[10:32:58.714]                   name <- added[[kk]]
[10:32:58.714]                   NAME <- NAMES[[kk]]
[10:32:58.714]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.714]                     next
[10:32:58.714]                   args[[name]] <- ""
[10:32:58.714]                 }
[10:32:58.714]                 NAMES <- toupper(removed)
[10:32:58.714]                 for (kk in seq_along(NAMES)) {
[10:32:58.714]                   name <- removed[[kk]]
[10:32:58.714]                   NAME <- NAMES[[kk]]
[10:32:58.714]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.714]                     next
[10:32:58.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:58.714]                 }
[10:32:58.714]                 if (length(args) > 0) 
[10:32:58.714]                   base::do.call(base::Sys.setenv, args = args)
[10:32:58.714]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:58.714]             }
[10:32:58.714]             else {
[10:32:58.714]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:58.714]             }
[10:32:58.714]             {
[10:32:58.714]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:58.714]                   0L) {
[10:32:58.714]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:58.714]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:58.714]                   base::options(opts)
[10:32:58.714]                 }
[10:32:58.714]                 {
[10:32:58.714]                   {
[10:32:58.714]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:58.714]                     NULL
[10:32:58.714]                   }
[10:32:58.714]                   options(future.plan = NULL)
[10:32:58.714]                   if (is.na(NA_character_)) 
[10:32:58.714]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:58.714]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:58.714]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:58.714]                     .init = FALSE)
[10:32:58.714]                 }
[10:32:58.714]             }
[10:32:58.714]         }
[10:32:58.714]     })
[10:32:58.714]     if (TRUE) {
[10:32:58.714]         base::sink(type = "output", split = FALSE)
[10:32:58.714]         if (TRUE) {
[10:32:58.714]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:58.714]         }
[10:32:58.714]         else {
[10:32:58.714]             ...future.result["stdout"] <- base::list(NULL)
[10:32:58.714]         }
[10:32:58.714]         base::close(...future.stdout)
[10:32:58.714]         ...future.stdout <- NULL
[10:32:58.714]     }
[10:32:58.714]     ...future.result$conditions <- ...future.conditions
[10:32:58.714]     ...future.result$finished <- base::Sys.time()
[10:32:58.714]     ...future.result
[10:32:58.714] }
[10:32:58.717] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[10:32:58.717] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[10:32:58.717] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[10:32:58.717] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[10:32:58.718] MultisessionFuture started
[10:32:58.718] - Launch lazy future ... done
[10:32:58.718] run() for ‘MultisessionFuture’ ... done
[10:32:58.718] result() for ClusterFuture ...
[10:32:58.718] receiveMessageFromWorker() for ClusterFuture ...
[10:32:58.718] - Validating connection of MultisessionFuture
[10:32:58.763] - received message: FutureResult
[10:32:58.764] - Received FutureResult
[10:32:58.764] - Erased future from FutureRegistry
[10:32:58.764] result() for ClusterFuture ...
[10:32:58.764] - result already collected: FutureResult
[10:32:58.764] result() for ClusterFuture ... done
[10:32:58.764] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:58.764] result() for ClusterFuture ... done
[10:32:58.764] result() for ClusterFuture ...
[10:32:58.765] - result already collected: FutureResult
[10:32:58.765] result() for ClusterFuture ... done
x
1 2 
2 3 
[10:32:58.765] getGlobalsAndPackages() ...
[10:32:58.766] Searching for globals...
[10:32:58.767] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[10:32:58.767] Searching for globals ... DONE
[10:32:58.767] Resolving globals: FALSE
[10:32:58.767] The total size of the 1 globals is 96 bytes (96 bytes)
[10:32:58.768] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[10:32:58.768] - globals: [1] ‘x’
[10:32:58.768] - packages: [1] ‘stats’
[10:32:58.768] getGlobalsAndPackages() ... DONE
[10:32:58.768] run() for ‘Future’ ...
[10:32:58.768] - state: ‘created’
[10:32:58.768] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:58.782] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:58.783] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:58.783]   - Field: ‘node’
[10:32:58.783]   - Field: ‘label’
[10:32:58.783]   - Field: ‘local’
[10:32:58.783]   - Field: ‘owner’
[10:32:58.783]   - Field: ‘envir’
[10:32:58.783]   - Field: ‘workers’
[10:32:58.783]   - Field: ‘packages’
[10:32:58.783]   - Field: ‘gc’
[10:32:58.784]   - Field: ‘conditions’
[10:32:58.784]   - Field: ‘persistent’
[10:32:58.784]   - Field: ‘expr’
[10:32:58.784]   - Field: ‘uuid’
[10:32:58.784]   - Field: ‘seed’
[10:32:58.784]   - Field: ‘version’
[10:32:58.784]   - Field: ‘result’
[10:32:58.784]   - Field: ‘asynchronous’
[10:32:58.784]   - Field: ‘calls’
[10:32:58.784]   - Field: ‘globals’
[10:32:58.785]   - Field: ‘stdout’
[10:32:58.785]   - Field: ‘earlySignal’
[10:32:58.785]   - Field: ‘lazy’
[10:32:58.785]   - Field: ‘state’
[10:32:58.785] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:58.785] - Launch lazy future ...
[10:32:58.785] Packages needed by the future expression (n = 1): ‘stats’
[10:32:58.785] Packages needed by future strategies (n = 0): <none>
[10:32:58.786] {
[10:32:58.786]     {
[10:32:58.786]         {
[10:32:58.786]             ...future.startTime <- base::Sys.time()
[10:32:58.786]             {
[10:32:58.786]                 {
[10:32:58.786]                   {
[10:32:58.786]                     {
[10:32:58.786]                       {
[10:32:58.786]                         base::local({
[10:32:58.786]                           has_future <- base::requireNamespace("future", 
[10:32:58.786]                             quietly = TRUE)
[10:32:58.786]                           if (has_future) {
[10:32:58.786]                             ns <- base::getNamespace("future")
[10:32:58.786]                             version <- ns[[".package"]][["version"]]
[10:32:58.786]                             if (is.null(version)) 
[10:32:58.786]                               version <- utils::packageVersion("future")
[10:32:58.786]                           }
[10:32:58.786]                           else {
[10:32:58.786]                             version <- NULL
[10:32:58.786]                           }
[10:32:58.786]                           if (!has_future || version < "1.8.0") {
[10:32:58.786]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:58.786]                               "", base::R.version$version.string), 
[10:32:58.786]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:58.786]                                 base::R.version$platform, 8 * 
[10:32:58.786]                                   base::.Machine$sizeof.pointer), 
[10:32:58.786]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:58.786]                                 "release", "version")], collapse = " "), 
[10:32:58.786]                               hostname = base::Sys.info()[["nodename"]])
[10:32:58.786]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:58.786]                               info)
[10:32:58.786]                             info <- base::paste(info, collapse = "; ")
[10:32:58.786]                             if (!has_future) {
[10:32:58.786]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:58.786]                                 info)
[10:32:58.786]                             }
[10:32:58.786]                             else {
[10:32:58.786]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:58.786]                                 info, version)
[10:32:58.786]                             }
[10:32:58.786]                             base::stop(msg)
[10:32:58.786]                           }
[10:32:58.786]                         })
[10:32:58.786]                       }
[10:32:58.786]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:58.786]                       base::options(mc.cores = 1L)
[10:32:58.786]                     }
[10:32:58.786]                     base::local({
[10:32:58.786]                       for (pkg in "stats") {
[10:32:58.786]                         base::loadNamespace(pkg)
[10:32:58.786]                         base::library(pkg, character.only = TRUE)
[10:32:58.786]                       }
[10:32:58.786]                     })
[10:32:58.786]                   }
[10:32:58.786]                   ...future.strategy.old <- future::plan("list")
[10:32:58.786]                   options(future.plan = NULL)
[10:32:58.786]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:58.786]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:58.786]                 }
[10:32:58.786]                 ...future.workdir <- getwd()
[10:32:58.786]             }
[10:32:58.786]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:58.786]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:58.786]         }
[10:32:58.786]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:58.786]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:58.786]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:58.786]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:58.786]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:58.786]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:58.786]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:58.786]             base::names(...future.oldOptions))
[10:32:58.786]     }
[10:32:58.786]     if (FALSE) {
[10:32:58.786]     }
[10:32:58.786]     else {
[10:32:58.786]         if (TRUE) {
[10:32:58.786]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:58.786]                 open = "w")
[10:32:58.786]         }
[10:32:58.786]         else {
[10:32:58.786]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:58.786]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:58.786]         }
[10:32:58.786]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:58.786]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:58.786]             base::sink(type = "output", split = FALSE)
[10:32:58.786]             base::close(...future.stdout)
[10:32:58.786]         }, add = TRUE)
[10:32:58.786]     }
[10:32:58.786]     ...future.frame <- base::sys.nframe()
[10:32:58.786]     ...future.conditions <- base::list()
[10:32:58.786]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:58.786]     if (FALSE) {
[10:32:58.786]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:58.786]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:58.786]     }
[10:32:58.786]     ...future.result <- base::tryCatch({
[10:32:58.786]         base::withCallingHandlers({
[10:32:58.786]             ...future.value <- base::withVisible(base::local({
[10:32:58.786]                 ...future.makeSendCondition <- base::local({
[10:32:58.786]                   sendCondition <- NULL
[10:32:58.786]                   function(frame = 1L) {
[10:32:58.786]                     if (is.function(sendCondition)) 
[10:32:58.786]                       return(sendCondition)
[10:32:58.786]                     ns <- getNamespace("parallel")
[10:32:58.786]                     if (exists("sendData", mode = "function", 
[10:32:58.786]                       envir = ns)) {
[10:32:58.786]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:58.786]                         envir = ns)
[10:32:58.786]                       envir <- sys.frame(frame)
[10:32:58.786]                       master <- NULL
[10:32:58.786]                       while (!identical(envir, .GlobalEnv) && 
[10:32:58.786]                         !identical(envir, emptyenv())) {
[10:32:58.786]                         if (exists("master", mode = "list", envir = envir, 
[10:32:58.786]                           inherits = FALSE)) {
[10:32:58.786]                           master <- get("master", mode = "list", 
[10:32:58.786]                             envir = envir, inherits = FALSE)
[10:32:58.786]                           if (inherits(master, c("SOCKnode", 
[10:32:58.786]                             "SOCK0node"))) {
[10:32:58.786]                             sendCondition <<- function(cond) {
[10:32:58.786]                               data <- list(type = "VALUE", value = cond, 
[10:32:58.786]                                 success = TRUE)
[10:32:58.786]                               parallel_sendData(master, data)
[10:32:58.786]                             }
[10:32:58.786]                             return(sendCondition)
[10:32:58.786]                           }
[10:32:58.786]                         }
[10:32:58.786]                         frame <- frame + 1L
[10:32:58.786]                         envir <- sys.frame(frame)
[10:32:58.786]                       }
[10:32:58.786]                     }
[10:32:58.786]                     sendCondition <<- function(cond) NULL
[10:32:58.786]                   }
[10:32:58.786]                 })
[10:32:58.786]                 withCallingHandlers({
[10:32:58.786]                   {
[10:32:58.786]                     xtabs(~x)
[10:32:58.786]                   }
[10:32:58.786]                 }, immediateCondition = function(cond) {
[10:32:58.786]                   sendCondition <- ...future.makeSendCondition()
[10:32:58.786]                   sendCondition(cond)
[10:32:58.786]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.786]                   {
[10:32:58.786]                     inherits <- base::inherits
[10:32:58.786]                     invokeRestart <- base::invokeRestart
[10:32:58.786]                     is.null <- base::is.null
[10:32:58.786]                     muffled <- FALSE
[10:32:58.786]                     if (inherits(cond, "message")) {
[10:32:58.786]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:58.786]                       if (muffled) 
[10:32:58.786]                         invokeRestart("muffleMessage")
[10:32:58.786]                     }
[10:32:58.786]                     else if (inherits(cond, "warning")) {
[10:32:58.786]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:58.786]                       if (muffled) 
[10:32:58.786]                         invokeRestart("muffleWarning")
[10:32:58.786]                     }
[10:32:58.786]                     else if (inherits(cond, "condition")) {
[10:32:58.786]                       if (!is.null(pattern)) {
[10:32:58.786]                         computeRestarts <- base::computeRestarts
[10:32:58.786]                         grepl <- base::grepl
[10:32:58.786]                         restarts <- computeRestarts(cond)
[10:32:58.786]                         for (restart in restarts) {
[10:32:58.786]                           name <- restart$name
[10:32:58.786]                           if (is.null(name)) 
[10:32:58.786]                             next
[10:32:58.786]                           if (!grepl(pattern, name)) 
[10:32:58.786]                             next
[10:32:58.786]                           invokeRestart(restart)
[10:32:58.786]                           muffled <- TRUE
[10:32:58.786]                           break
[10:32:58.786]                         }
[10:32:58.786]                       }
[10:32:58.786]                     }
[10:32:58.786]                     invisible(muffled)
[10:32:58.786]                   }
[10:32:58.786]                   muffleCondition(cond)
[10:32:58.786]                 })
[10:32:58.786]             }))
[10:32:58.786]             future::FutureResult(value = ...future.value$value, 
[10:32:58.786]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:58.786]                   ...future.rng), globalenv = if (FALSE) 
[10:32:58.786]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:58.786]                     ...future.globalenv.names))
[10:32:58.786]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:58.786]         }, condition = base::local({
[10:32:58.786]             c <- base::c
[10:32:58.786]             inherits <- base::inherits
[10:32:58.786]             invokeRestart <- base::invokeRestart
[10:32:58.786]             length <- base::length
[10:32:58.786]             list <- base::list
[10:32:58.786]             seq.int <- base::seq.int
[10:32:58.786]             signalCondition <- base::signalCondition
[10:32:58.786]             sys.calls <- base::sys.calls
[10:32:58.786]             `[[` <- base::`[[`
[10:32:58.786]             `+` <- base::`+`
[10:32:58.786]             `<<-` <- base::`<<-`
[10:32:58.786]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:58.786]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:58.786]                   3L)]
[10:32:58.786]             }
[10:32:58.786]             function(cond) {
[10:32:58.786]                 is_error <- inherits(cond, "error")
[10:32:58.786]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:58.786]                   NULL)
[10:32:58.786]                 if (is_error) {
[10:32:58.786]                   sessionInformation <- function() {
[10:32:58.786]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:58.786]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:58.786]                       search = base::search(), system = base::Sys.info())
[10:32:58.786]                   }
[10:32:58.786]                   ...future.conditions[[length(...future.conditions) + 
[10:32:58.786]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:58.786]                     cond$call), session = sessionInformation(), 
[10:32:58.786]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:58.786]                   signalCondition(cond)
[10:32:58.786]                 }
[10:32:58.786]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:58.786]                 "immediateCondition"))) {
[10:32:58.786]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:58.786]                   ...future.conditions[[length(...future.conditions) + 
[10:32:58.786]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:58.786]                   if (TRUE && !signal) {
[10:32:58.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.786]                     {
[10:32:58.786]                       inherits <- base::inherits
[10:32:58.786]                       invokeRestart <- base::invokeRestart
[10:32:58.786]                       is.null <- base::is.null
[10:32:58.786]                       muffled <- FALSE
[10:32:58.786]                       if (inherits(cond, "message")) {
[10:32:58.786]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:58.786]                         if (muffled) 
[10:32:58.786]                           invokeRestart("muffleMessage")
[10:32:58.786]                       }
[10:32:58.786]                       else if (inherits(cond, "warning")) {
[10:32:58.786]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:58.786]                         if (muffled) 
[10:32:58.786]                           invokeRestart("muffleWarning")
[10:32:58.786]                       }
[10:32:58.786]                       else if (inherits(cond, "condition")) {
[10:32:58.786]                         if (!is.null(pattern)) {
[10:32:58.786]                           computeRestarts <- base::computeRestarts
[10:32:58.786]                           grepl <- base::grepl
[10:32:58.786]                           restarts <- computeRestarts(cond)
[10:32:58.786]                           for (restart in restarts) {
[10:32:58.786]                             name <- restart$name
[10:32:58.786]                             if (is.null(name)) 
[10:32:58.786]                               next
[10:32:58.786]                             if (!grepl(pattern, name)) 
[10:32:58.786]                               next
[10:32:58.786]                             invokeRestart(restart)
[10:32:58.786]                             muffled <- TRUE
[10:32:58.786]                             break
[10:32:58.786]                           }
[10:32:58.786]                         }
[10:32:58.786]                       }
[10:32:58.786]                       invisible(muffled)
[10:32:58.786]                     }
[10:32:58.786]                     muffleCondition(cond, pattern = "^muffle")
[10:32:58.786]                   }
[10:32:58.786]                 }
[10:32:58.786]                 else {
[10:32:58.786]                   if (TRUE) {
[10:32:58.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.786]                     {
[10:32:58.786]                       inherits <- base::inherits
[10:32:58.786]                       invokeRestart <- base::invokeRestart
[10:32:58.786]                       is.null <- base::is.null
[10:32:58.786]                       muffled <- FALSE
[10:32:58.786]                       if (inherits(cond, "message")) {
[10:32:58.786]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:58.786]                         if (muffled) 
[10:32:58.786]                           invokeRestart("muffleMessage")
[10:32:58.786]                       }
[10:32:58.786]                       else if (inherits(cond, "warning")) {
[10:32:58.786]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:58.786]                         if (muffled) 
[10:32:58.786]                           invokeRestart("muffleWarning")
[10:32:58.786]                       }
[10:32:58.786]                       else if (inherits(cond, "condition")) {
[10:32:58.786]                         if (!is.null(pattern)) {
[10:32:58.786]                           computeRestarts <- base::computeRestarts
[10:32:58.786]                           grepl <- base::grepl
[10:32:58.786]                           restarts <- computeRestarts(cond)
[10:32:58.786]                           for (restart in restarts) {
[10:32:58.786]                             name <- restart$name
[10:32:58.786]                             if (is.null(name)) 
[10:32:58.786]                               next
[10:32:58.786]                             if (!grepl(pattern, name)) 
[10:32:58.786]                               next
[10:32:58.786]                             invokeRestart(restart)
[10:32:58.786]                             muffled <- TRUE
[10:32:58.786]                             break
[10:32:58.786]                           }
[10:32:58.786]                         }
[10:32:58.786]                       }
[10:32:58.786]                       invisible(muffled)
[10:32:58.786]                     }
[10:32:58.786]                     muffleCondition(cond, pattern = "^muffle")
[10:32:58.786]                   }
[10:32:58.786]                 }
[10:32:58.786]             }
[10:32:58.786]         }))
[10:32:58.786]     }, error = function(ex) {
[10:32:58.786]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:58.786]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:58.786]                 ...future.rng), started = ...future.startTime, 
[10:32:58.786]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:58.786]             version = "1.8"), class = "FutureResult")
[10:32:58.786]     }, finally = {
[10:32:58.786]         if (!identical(...future.workdir, getwd())) 
[10:32:58.786]             setwd(...future.workdir)
[10:32:58.786]         {
[10:32:58.786]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:58.786]                 ...future.oldOptions$nwarnings <- NULL
[10:32:58.786]             }
[10:32:58.786]             base::options(...future.oldOptions)
[10:32:58.786]             if (.Platform$OS.type == "windows") {
[10:32:58.786]                 old_names <- names(...future.oldEnvVars)
[10:32:58.786]                 envs <- base::Sys.getenv()
[10:32:58.786]                 names <- names(envs)
[10:32:58.786]                 common <- intersect(names, old_names)
[10:32:58.786]                 added <- setdiff(names, old_names)
[10:32:58.786]                 removed <- setdiff(old_names, names)
[10:32:58.786]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:58.786]                   envs[common]]
[10:32:58.786]                 NAMES <- toupper(changed)
[10:32:58.786]                 args <- list()
[10:32:58.786]                 for (kk in seq_along(NAMES)) {
[10:32:58.786]                   name <- changed[[kk]]
[10:32:58.786]                   NAME <- NAMES[[kk]]
[10:32:58.786]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.786]                     next
[10:32:58.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:58.786]                 }
[10:32:58.786]                 NAMES <- toupper(added)
[10:32:58.786]                 for (kk in seq_along(NAMES)) {
[10:32:58.786]                   name <- added[[kk]]
[10:32:58.786]                   NAME <- NAMES[[kk]]
[10:32:58.786]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.786]                     next
[10:32:58.786]                   args[[name]] <- ""
[10:32:58.786]                 }
[10:32:58.786]                 NAMES <- toupper(removed)
[10:32:58.786]                 for (kk in seq_along(NAMES)) {
[10:32:58.786]                   name <- removed[[kk]]
[10:32:58.786]                   NAME <- NAMES[[kk]]
[10:32:58.786]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.786]                     next
[10:32:58.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:58.786]                 }
[10:32:58.786]                 if (length(args) > 0) 
[10:32:58.786]                   base::do.call(base::Sys.setenv, args = args)
[10:32:58.786]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:58.786]             }
[10:32:58.786]             else {
[10:32:58.786]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:58.786]             }
[10:32:58.786]             {
[10:32:58.786]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:58.786]                   0L) {
[10:32:58.786]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:58.786]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:58.786]                   base::options(opts)
[10:32:58.786]                 }
[10:32:58.786]                 {
[10:32:58.786]                   {
[10:32:58.786]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:58.786]                     NULL
[10:32:58.786]                   }
[10:32:58.786]                   options(future.plan = NULL)
[10:32:58.786]                   if (is.na(NA_character_)) 
[10:32:58.786]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:58.786]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:58.786]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:58.786]                     .init = FALSE)
[10:32:58.786]                 }
[10:32:58.786]             }
[10:32:58.786]         }
[10:32:58.786]     })
[10:32:58.786]     if (TRUE) {
[10:32:58.786]         base::sink(type = "output", split = FALSE)
[10:32:58.786]         if (TRUE) {
[10:32:58.786]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:58.786]         }
[10:32:58.786]         else {
[10:32:58.786]             ...future.result["stdout"] <- base::list(NULL)
[10:32:58.786]         }
[10:32:58.786]         base::close(...future.stdout)
[10:32:58.786]         ...future.stdout <- NULL
[10:32:58.786]     }
[10:32:58.786]     ...future.result$conditions <- ...future.conditions
[10:32:58.786]     ...future.result$finished <- base::Sys.time()
[10:32:58.786]     ...future.result
[10:32:58.786] }
[10:32:58.788] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[10:32:58.789] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[10:32:58.789] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[10:32:58.789] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[10:32:58.790] MultisessionFuture started
[10:32:58.790] - Launch lazy future ... done
[10:32:58.790] run() for ‘MultisessionFuture’ ... done
[10:32:58.790] result() for ClusterFuture ...
[10:32:58.790] receiveMessageFromWorker() for ClusterFuture ...
[10:32:58.790] - Validating connection of MultisessionFuture
[10:32:58.835] - received message: FutureResult
[10:32:58.835] - Received FutureResult
[10:32:58.835] - Erased future from FutureRegistry
[10:32:58.835] result() for ClusterFuture ...
[10:32:58.835] - result already collected: FutureResult
[10:32:58.835] result() for ClusterFuture ... done
[10:32:58.835] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:58.835] result() for ClusterFuture ... done
[10:32:58.836] result() for ClusterFuture ...
[10:32:58.836] - result already collected: FutureResult
[10:32:58.836] result() for ClusterFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[10:32:58.837] getGlobalsAndPackages() ...
[10:32:58.837] Searching for globals...
[10:32:58.839] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[10:32:58.839] Searching for globals ... DONE
[10:32:58.839] Resolving globals: FALSE
[10:32:58.840] 
[10:32:58.840] - packages: [2] ‘stats’, ‘datasets’
[10:32:58.840] getGlobalsAndPackages() ... DONE
[10:32:58.840] run() for ‘Future’ ...
[10:32:58.840] - state: ‘created’
[10:32:58.840] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:58.854] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:58.854] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:58.854]   - Field: ‘node’
[10:32:58.854]   - Field: ‘label’
[10:32:58.854]   - Field: ‘local’
[10:32:58.855]   - Field: ‘owner’
[10:32:58.855]   - Field: ‘envir’
[10:32:58.855]   - Field: ‘workers’
[10:32:58.855]   - Field: ‘packages’
[10:32:58.855]   - Field: ‘gc’
[10:32:58.855]   - Field: ‘conditions’
[10:32:58.855]   - Field: ‘persistent’
[10:32:58.855]   - Field: ‘expr’
[10:32:58.855]   - Field: ‘uuid’
[10:32:58.855]   - Field: ‘seed’
[10:32:58.855]   - Field: ‘version’
[10:32:58.856]   - Field: ‘result’
[10:32:58.856]   - Field: ‘asynchronous’
[10:32:58.856]   - Field: ‘calls’
[10:32:58.856]   - Field: ‘globals’
[10:32:58.856]   - Field: ‘stdout’
[10:32:58.856]   - Field: ‘earlySignal’
[10:32:58.856]   - Field: ‘lazy’
[10:32:58.856]   - Field: ‘state’
[10:32:58.856] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:58.856] - Launch lazy future ...
[10:32:58.857] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:32:58.857] Packages needed by future strategies (n = 0): <none>
[10:32:58.857] {
[10:32:58.857]     {
[10:32:58.857]         {
[10:32:58.857]             ...future.startTime <- base::Sys.time()
[10:32:58.857]             {
[10:32:58.857]                 {
[10:32:58.857]                   {
[10:32:58.857]                     {
[10:32:58.857]                       {
[10:32:58.857]                         base::local({
[10:32:58.857]                           has_future <- base::requireNamespace("future", 
[10:32:58.857]                             quietly = TRUE)
[10:32:58.857]                           if (has_future) {
[10:32:58.857]                             ns <- base::getNamespace("future")
[10:32:58.857]                             version <- ns[[".package"]][["version"]]
[10:32:58.857]                             if (is.null(version)) 
[10:32:58.857]                               version <- utils::packageVersion("future")
[10:32:58.857]                           }
[10:32:58.857]                           else {
[10:32:58.857]                             version <- NULL
[10:32:58.857]                           }
[10:32:58.857]                           if (!has_future || version < "1.8.0") {
[10:32:58.857]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:58.857]                               "", base::R.version$version.string), 
[10:32:58.857]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:58.857]                                 base::R.version$platform, 8 * 
[10:32:58.857]                                   base::.Machine$sizeof.pointer), 
[10:32:58.857]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:58.857]                                 "release", "version")], collapse = " "), 
[10:32:58.857]                               hostname = base::Sys.info()[["nodename"]])
[10:32:58.857]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:58.857]                               info)
[10:32:58.857]                             info <- base::paste(info, collapse = "; ")
[10:32:58.857]                             if (!has_future) {
[10:32:58.857]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:58.857]                                 info)
[10:32:58.857]                             }
[10:32:58.857]                             else {
[10:32:58.857]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:58.857]                                 info, version)
[10:32:58.857]                             }
[10:32:58.857]                             base::stop(msg)
[10:32:58.857]                           }
[10:32:58.857]                         })
[10:32:58.857]                       }
[10:32:58.857]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:58.857]                       base::options(mc.cores = 1L)
[10:32:58.857]                     }
[10:32:58.857]                     base::local({
[10:32:58.857]                       for (pkg in c("stats", "datasets")) {
[10:32:58.857]                         base::loadNamespace(pkg)
[10:32:58.857]                         base::library(pkg, character.only = TRUE)
[10:32:58.857]                       }
[10:32:58.857]                     })
[10:32:58.857]                   }
[10:32:58.857]                   ...future.strategy.old <- future::plan("list")
[10:32:58.857]                   options(future.plan = NULL)
[10:32:58.857]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:58.857]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:58.857]                 }
[10:32:58.857]                 ...future.workdir <- getwd()
[10:32:58.857]             }
[10:32:58.857]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:58.857]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:58.857]         }
[10:32:58.857]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:58.857]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:58.857]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:58.857]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:58.857]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:58.857]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:58.857]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:58.857]             base::names(...future.oldOptions))
[10:32:58.857]     }
[10:32:58.857]     if (FALSE) {
[10:32:58.857]     }
[10:32:58.857]     else {
[10:32:58.857]         if (TRUE) {
[10:32:58.857]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:58.857]                 open = "w")
[10:32:58.857]         }
[10:32:58.857]         else {
[10:32:58.857]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:58.857]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:58.857]         }
[10:32:58.857]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:58.857]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:58.857]             base::sink(type = "output", split = FALSE)
[10:32:58.857]             base::close(...future.stdout)
[10:32:58.857]         }, add = TRUE)
[10:32:58.857]     }
[10:32:58.857]     ...future.frame <- base::sys.nframe()
[10:32:58.857]     ...future.conditions <- base::list()
[10:32:58.857]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:58.857]     if (FALSE) {
[10:32:58.857]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:58.857]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:58.857]     }
[10:32:58.857]     ...future.result <- base::tryCatch({
[10:32:58.857]         base::withCallingHandlers({
[10:32:58.857]             ...future.value <- base::withVisible(base::local({
[10:32:58.857]                 ...future.makeSendCondition <- base::local({
[10:32:58.857]                   sendCondition <- NULL
[10:32:58.857]                   function(frame = 1L) {
[10:32:58.857]                     if (is.function(sendCondition)) 
[10:32:58.857]                       return(sendCondition)
[10:32:58.857]                     ns <- getNamespace("parallel")
[10:32:58.857]                     if (exists("sendData", mode = "function", 
[10:32:58.857]                       envir = ns)) {
[10:32:58.857]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:58.857]                         envir = ns)
[10:32:58.857]                       envir <- sys.frame(frame)
[10:32:58.857]                       master <- NULL
[10:32:58.857]                       while (!identical(envir, .GlobalEnv) && 
[10:32:58.857]                         !identical(envir, emptyenv())) {
[10:32:58.857]                         if (exists("master", mode = "list", envir = envir, 
[10:32:58.857]                           inherits = FALSE)) {
[10:32:58.857]                           master <- get("master", mode = "list", 
[10:32:58.857]                             envir = envir, inherits = FALSE)
[10:32:58.857]                           if (inherits(master, c("SOCKnode", 
[10:32:58.857]                             "SOCK0node"))) {
[10:32:58.857]                             sendCondition <<- function(cond) {
[10:32:58.857]                               data <- list(type = "VALUE", value = cond, 
[10:32:58.857]                                 success = TRUE)
[10:32:58.857]                               parallel_sendData(master, data)
[10:32:58.857]                             }
[10:32:58.857]                             return(sendCondition)
[10:32:58.857]                           }
[10:32:58.857]                         }
[10:32:58.857]                         frame <- frame + 1L
[10:32:58.857]                         envir <- sys.frame(frame)
[10:32:58.857]                       }
[10:32:58.857]                     }
[10:32:58.857]                     sendCondition <<- function(cond) NULL
[10:32:58.857]                   }
[10:32:58.857]                 })
[10:32:58.857]                 withCallingHandlers({
[10:32:58.857]                   {
[10:32:58.857]                     lm(dist ~ . - 1, data = cars)
[10:32:58.857]                   }
[10:32:58.857]                 }, immediateCondition = function(cond) {
[10:32:58.857]                   sendCondition <- ...future.makeSendCondition()
[10:32:58.857]                   sendCondition(cond)
[10:32:58.857]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.857]                   {
[10:32:58.857]                     inherits <- base::inherits
[10:32:58.857]                     invokeRestart <- base::invokeRestart
[10:32:58.857]                     is.null <- base::is.null
[10:32:58.857]                     muffled <- FALSE
[10:32:58.857]                     if (inherits(cond, "message")) {
[10:32:58.857]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:58.857]                       if (muffled) 
[10:32:58.857]                         invokeRestart("muffleMessage")
[10:32:58.857]                     }
[10:32:58.857]                     else if (inherits(cond, "warning")) {
[10:32:58.857]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:58.857]                       if (muffled) 
[10:32:58.857]                         invokeRestart("muffleWarning")
[10:32:58.857]                     }
[10:32:58.857]                     else if (inherits(cond, "condition")) {
[10:32:58.857]                       if (!is.null(pattern)) {
[10:32:58.857]                         computeRestarts <- base::computeRestarts
[10:32:58.857]                         grepl <- base::grepl
[10:32:58.857]                         restarts <- computeRestarts(cond)
[10:32:58.857]                         for (restart in restarts) {
[10:32:58.857]                           name <- restart$name
[10:32:58.857]                           if (is.null(name)) 
[10:32:58.857]                             next
[10:32:58.857]                           if (!grepl(pattern, name)) 
[10:32:58.857]                             next
[10:32:58.857]                           invokeRestart(restart)
[10:32:58.857]                           muffled <- TRUE
[10:32:58.857]                           break
[10:32:58.857]                         }
[10:32:58.857]                       }
[10:32:58.857]                     }
[10:32:58.857]                     invisible(muffled)
[10:32:58.857]                   }
[10:32:58.857]                   muffleCondition(cond)
[10:32:58.857]                 })
[10:32:58.857]             }))
[10:32:58.857]             future::FutureResult(value = ...future.value$value, 
[10:32:58.857]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:58.857]                   ...future.rng), globalenv = if (FALSE) 
[10:32:58.857]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:58.857]                     ...future.globalenv.names))
[10:32:58.857]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:58.857]         }, condition = base::local({
[10:32:58.857]             c <- base::c
[10:32:58.857]             inherits <- base::inherits
[10:32:58.857]             invokeRestart <- base::invokeRestart
[10:32:58.857]             length <- base::length
[10:32:58.857]             list <- base::list
[10:32:58.857]             seq.int <- base::seq.int
[10:32:58.857]             signalCondition <- base::signalCondition
[10:32:58.857]             sys.calls <- base::sys.calls
[10:32:58.857]             `[[` <- base::`[[`
[10:32:58.857]             `+` <- base::`+`
[10:32:58.857]             `<<-` <- base::`<<-`
[10:32:58.857]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:58.857]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:58.857]                   3L)]
[10:32:58.857]             }
[10:32:58.857]             function(cond) {
[10:32:58.857]                 is_error <- inherits(cond, "error")
[10:32:58.857]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:58.857]                   NULL)
[10:32:58.857]                 if (is_error) {
[10:32:58.857]                   sessionInformation <- function() {
[10:32:58.857]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:58.857]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:58.857]                       search = base::search(), system = base::Sys.info())
[10:32:58.857]                   }
[10:32:58.857]                   ...future.conditions[[length(...future.conditions) + 
[10:32:58.857]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:58.857]                     cond$call), session = sessionInformation(), 
[10:32:58.857]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:58.857]                   signalCondition(cond)
[10:32:58.857]                 }
[10:32:58.857]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:58.857]                 "immediateCondition"))) {
[10:32:58.857]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:58.857]                   ...future.conditions[[length(...future.conditions) + 
[10:32:58.857]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:58.857]                   if (TRUE && !signal) {
[10:32:58.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.857]                     {
[10:32:58.857]                       inherits <- base::inherits
[10:32:58.857]                       invokeRestart <- base::invokeRestart
[10:32:58.857]                       is.null <- base::is.null
[10:32:58.857]                       muffled <- FALSE
[10:32:58.857]                       if (inherits(cond, "message")) {
[10:32:58.857]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:58.857]                         if (muffled) 
[10:32:58.857]                           invokeRestart("muffleMessage")
[10:32:58.857]                       }
[10:32:58.857]                       else if (inherits(cond, "warning")) {
[10:32:58.857]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:58.857]                         if (muffled) 
[10:32:58.857]                           invokeRestart("muffleWarning")
[10:32:58.857]                       }
[10:32:58.857]                       else if (inherits(cond, "condition")) {
[10:32:58.857]                         if (!is.null(pattern)) {
[10:32:58.857]                           computeRestarts <- base::computeRestarts
[10:32:58.857]                           grepl <- base::grepl
[10:32:58.857]                           restarts <- computeRestarts(cond)
[10:32:58.857]                           for (restart in restarts) {
[10:32:58.857]                             name <- restart$name
[10:32:58.857]                             if (is.null(name)) 
[10:32:58.857]                               next
[10:32:58.857]                             if (!grepl(pattern, name)) 
[10:32:58.857]                               next
[10:32:58.857]                             invokeRestart(restart)
[10:32:58.857]                             muffled <- TRUE
[10:32:58.857]                             break
[10:32:58.857]                           }
[10:32:58.857]                         }
[10:32:58.857]                       }
[10:32:58.857]                       invisible(muffled)
[10:32:58.857]                     }
[10:32:58.857]                     muffleCondition(cond, pattern = "^muffle")
[10:32:58.857]                   }
[10:32:58.857]                 }
[10:32:58.857]                 else {
[10:32:58.857]                   if (TRUE) {
[10:32:58.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.857]                     {
[10:32:58.857]                       inherits <- base::inherits
[10:32:58.857]                       invokeRestart <- base::invokeRestart
[10:32:58.857]                       is.null <- base::is.null
[10:32:58.857]                       muffled <- FALSE
[10:32:58.857]                       if (inherits(cond, "message")) {
[10:32:58.857]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:58.857]                         if (muffled) 
[10:32:58.857]                           invokeRestart("muffleMessage")
[10:32:58.857]                       }
[10:32:58.857]                       else if (inherits(cond, "warning")) {
[10:32:58.857]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:58.857]                         if (muffled) 
[10:32:58.857]                           invokeRestart("muffleWarning")
[10:32:58.857]                       }
[10:32:58.857]                       else if (inherits(cond, "condition")) {
[10:32:58.857]                         if (!is.null(pattern)) {
[10:32:58.857]                           computeRestarts <- base::computeRestarts
[10:32:58.857]                           grepl <- base::grepl
[10:32:58.857]                           restarts <- computeRestarts(cond)
[10:32:58.857]                           for (restart in restarts) {
[10:32:58.857]                             name <- restart$name
[10:32:58.857]                             if (is.null(name)) 
[10:32:58.857]                               next
[10:32:58.857]                             if (!grepl(pattern, name)) 
[10:32:58.857]                               next
[10:32:58.857]                             invokeRestart(restart)
[10:32:58.857]                             muffled <- TRUE
[10:32:58.857]                             break
[10:32:58.857]                           }
[10:32:58.857]                         }
[10:32:58.857]                       }
[10:32:58.857]                       invisible(muffled)
[10:32:58.857]                     }
[10:32:58.857]                     muffleCondition(cond, pattern = "^muffle")
[10:32:58.857]                   }
[10:32:58.857]                 }
[10:32:58.857]             }
[10:32:58.857]         }))
[10:32:58.857]     }, error = function(ex) {
[10:32:58.857]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:58.857]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:58.857]                 ...future.rng), started = ...future.startTime, 
[10:32:58.857]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:58.857]             version = "1.8"), class = "FutureResult")
[10:32:58.857]     }, finally = {
[10:32:58.857]         if (!identical(...future.workdir, getwd())) 
[10:32:58.857]             setwd(...future.workdir)
[10:32:58.857]         {
[10:32:58.857]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:58.857]                 ...future.oldOptions$nwarnings <- NULL
[10:32:58.857]             }
[10:32:58.857]             base::options(...future.oldOptions)
[10:32:58.857]             if (.Platform$OS.type == "windows") {
[10:32:58.857]                 old_names <- names(...future.oldEnvVars)
[10:32:58.857]                 envs <- base::Sys.getenv()
[10:32:58.857]                 names <- names(envs)
[10:32:58.857]                 common <- intersect(names, old_names)
[10:32:58.857]                 added <- setdiff(names, old_names)
[10:32:58.857]                 removed <- setdiff(old_names, names)
[10:32:58.857]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:58.857]                   envs[common]]
[10:32:58.857]                 NAMES <- toupper(changed)
[10:32:58.857]                 args <- list()
[10:32:58.857]                 for (kk in seq_along(NAMES)) {
[10:32:58.857]                   name <- changed[[kk]]
[10:32:58.857]                   NAME <- NAMES[[kk]]
[10:32:58.857]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.857]                     next
[10:32:58.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:58.857]                 }
[10:32:58.857]                 NAMES <- toupper(added)
[10:32:58.857]                 for (kk in seq_along(NAMES)) {
[10:32:58.857]                   name <- added[[kk]]
[10:32:58.857]                   NAME <- NAMES[[kk]]
[10:32:58.857]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.857]                     next
[10:32:58.857]                   args[[name]] <- ""
[10:32:58.857]                 }
[10:32:58.857]                 NAMES <- toupper(removed)
[10:32:58.857]                 for (kk in seq_along(NAMES)) {
[10:32:58.857]                   name <- removed[[kk]]
[10:32:58.857]                   NAME <- NAMES[[kk]]
[10:32:58.857]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.857]                     next
[10:32:58.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:58.857]                 }
[10:32:58.857]                 if (length(args) > 0) 
[10:32:58.857]                   base::do.call(base::Sys.setenv, args = args)
[10:32:58.857]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:58.857]             }
[10:32:58.857]             else {
[10:32:58.857]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:58.857]             }
[10:32:58.857]             {
[10:32:58.857]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:58.857]                   0L) {
[10:32:58.857]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:58.857]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:58.857]                   base::options(opts)
[10:32:58.857]                 }
[10:32:58.857]                 {
[10:32:58.857]                   {
[10:32:58.857]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:58.857]                     NULL
[10:32:58.857]                   }
[10:32:58.857]                   options(future.plan = NULL)
[10:32:58.857]                   if (is.na(NA_character_)) 
[10:32:58.857]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:58.857]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:58.857]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:58.857]                     .init = FALSE)
[10:32:58.857]                 }
[10:32:58.857]             }
[10:32:58.857]         }
[10:32:58.857]     })
[10:32:58.857]     if (TRUE) {
[10:32:58.857]         base::sink(type = "output", split = FALSE)
[10:32:58.857]         if (TRUE) {
[10:32:58.857]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:58.857]         }
[10:32:58.857]         else {
[10:32:58.857]             ...future.result["stdout"] <- base::list(NULL)
[10:32:58.857]         }
[10:32:58.857]         base::close(...future.stdout)
[10:32:58.857]         ...future.stdout <- NULL
[10:32:58.857]     }
[10:32:58.857]     ...future.result$conditions <- ...future.conditions
[10:32:58.857]     ...future.result$finished <- base::Sys.time()
[10:32:58.857]     ...future.result
[10:32:58.857] }
[10:32:58.860] MultisessionFuture started
[10:32:58.860] - Launch lazy future ... done
[10:32:58.860] run() for ‘MultisessionFuture’ ... done
[10:32:58.861] result() for ClusterFuture ...
[10:32:58.861] receiveMessageFromWorker() for ClusterFuture ...
[10:32:58.861] - Validating connection of MultisessionFuture
[10:32:58.863] - received message: FutureResult
[10:32:58.863] - Received FutureResult
[10:32:58.863] - Erased future from FutureRegistry
[10:32:58.863] result() for ClusterFuture ...
[10:32:58.863] - result already collected: FutureResult
[10:32:58.863] result() for ClusterFuture ... done
[10:32:58.864] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:58.864] result() for ClusterFuture ... done
[10:32:58.864] result() for ClusterFuture ...
[10:32:58.864] - result already collected: FutureResult
[10:32:58.864] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[10:32:58.868] getGlobalsAndPackages() ...
[10:32:58.868] Searching for globals...
[10:32:58.870] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[10:32:58.870] Searching for globals ... DONE
[10:32:58.870] Resolving globals: FALSE
[10:32:58.870] 
[10:32:58.870] - packages: [2] ‘stats’, ‘datasets’
[10:32:58.871] getGlobalsAndPackages() ... DONE
[10:32:58.871] run() for ‘Future’ ...
[10:32:58.871] - state: ‘created’
[10:32:58.871] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:58.886] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:58.886] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:58.886]   - Field: ‘node’
[10:32:58.886]   - Field: ‘label’
[10:32:58.886]   - Field: ‘local’
[10:32:58.886]   - Field: ‘owner’
[10:32:58.886]   - Field: ‘envir’
[10:32:58.886]   - Field: ‘workers’
[10:32:58.886]   - Field: ‘packages’
[10:32:58.886]   - Field: ‘gc’
[10:32:58.887]   - Field: ‘conditions’
[10:32:58.887]   - Field: ‘persistent’
[10:32:58.887]   - Field: ‘expr’
[10:32:58.887]   - Field: ‘uuid’
[10:32:58.887]   - Field: ‘seed’
[10:32:58.887]   - Field: ‘version’
[10:32:58.887]   - Field: ‘result’
[10:32:58.887]   - Field: ‘asynchronous’
[10:32:58.887]   - Field: ‘calls’
[10:32:58.887]   - Field: ‘globals’
[10:32:58.887]   - Field: ‘stdout’
[10:32:58.888]   - Field: ‘earlySignal’
[10:32:58.888]   - Field: ‘lazy’
[10:32:58.888]   - Field: ‘state’
[10:32:58.888] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:58.888] - Launch lazy future ...
[10:32:58.888] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:32:58.888] Packages needed by future strategies (n = 0): <none>
[10:32:58.889] {
[10:32:58.889]     {
[10:32:58.889]         {
[10:32:58.889]             ...future.startTime <- base::Sys.time()
[10:32:58.889]             {
[10:32:58.889]                 {
[10:32:58.889]                   {
[10:32:58.889]                     {
[10:32:58.889]                       {
[10:32:58.889]                         base::local({
[10:32:58.889]                           has_future <- base::requireNamespace("future", 
[10:32:58.889]                             quietly = TRUE)
[10:32:58.889]                           if (has_future) {
[10:32:58.889]                             ns <- base::getNamespace("future")
[10:32:58.889]                             version <- ns[[".package"]][["version"]]
[10:32:58.889]                             if (is.null(version)) 
[10:32:58.889]                               version <- utils::packageVersion("future")
[10:32:58.889]                           }
[10:32:58.889]                           else {
[10:32:58.889]                             version <- NULL
[10:32:58.889]                           }
[10:32:58.889]                           if (!has_future || version < "1.8.0") {
[10:32:58.889]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:58.889]                               "", base::R.version$version.string), 
[10:32:58.889]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:58.889]                                 base::R.version$platform, 8 * 
[10:32:58.889]                                   base::.Machine$sizeof.pointer), 
[10:32:58.889]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:58.889]                                 "release", "version")], collapse = " "), 
[10:32:58.889]                               hostname = base::Sys.info()[["nodename"]])
[10:32:58.889]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:58.889]                               info)
[10:32:58.889]                             info <- base::paste(info, collapse = "; ")
[10:32:58.889]                             if (!has_future) {
[10:32:58.889]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:58.889]                                 info)
[10:32:58.889]                             }
[10:32:58.889]                             else {
[10:32:58.889]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:58.889]                                 info, version)
[10:32:58.889]                             }
[10:32:58.889]                             base::stop(msg)
[10:32:58.889]                           }
[10:32:58.889]                         })
[10:32:58.889]                       }
[10:32:58.889]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:58.889]                       base::options(mc.cores = 1L)
[10:32:58.889]                     }
[10:32:58.889]                     base::local({
[10:32:58.889]                       for (pkg in c("stats", "datasets")) {
[10:32:58.889]                         base::loadNamespace(pkg)
[10:32:58.889]                         base::library(pkg, character.only = TRUE)
[10:32:58.889]                       }
[10:32:58.889]                     })
[10:32:58.889]                   }
[10:32:58.889]                   ...future.strategy.old <- future::plan("list")
[10:32:58.889]                   options(future.plan = NULL)
[10:32:58.889]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:58.889]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:58.889]                 }
[10:32:58.889]                 ...future.workdir <- getwd()
[10:32:58.889]             }
[10:32:58.889]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:58.889]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:58.889]         }
[10:32:58.889]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:58.889]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:58.889]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:58.889]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:58.889]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:58.889]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:58.889]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:58.889]             base::names(...future.oldOptions))
[10:32:58.889]     }
[10:32:58.889]     if (FALSE) {
[10:32:58.889]     }
[10:32:58.889]     else {
[10:32:58.889]         if (TRUE) {
[10:32:58.889]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:58.889]                 open = "w")
[10:32:58.889]         }
[10:32:58.889]         else {
[10:32:58.889]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:58.889]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:58.889]         }
[10:32:58.889]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:58.889]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:58.889]             base::sink(type = "output", split = FALSE)
[10:32:58.889]             base::close(...future.stdout)
[10:32:58.889]         }, add = TRUE)
[10:32:58.889]     }
[10:32:58.889]     ...future.frame <- base::sys.nframe()
[10:32:58.889]     ...future.conditions <- base::list()
[10:32:58.889]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:58.889]     if (FALSE) {
[10:32:58.889]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:58.889]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:58.889]     }
[10:32:58.889]     ...future.result <- base::tryCatch({
[10:32:58.889]         base::withCallingHandlers({
[10:32:58.889]             ...future.value <- base::withVisible(base::local({
[10:32:58.889]                 ...future.makeSendCondition <- base::local({
[10:32:58.889]                   sendCondition <- NULL
[10:32:58.889]                   function(frame = 1L) {
[10:32:58.889]                     if (is.function(sendCondition)) 
[10:32:58.889]                       return(sendCondition)
[10:32:58.889]                     ns <- getNamespace("parallel")
[10:32:58.889]                     if (exists("sendData", mode = "function", 
[10:32:58.889]                       envir = ns)) {
[10:32:58.889]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:58.889]                         envir = ns)
[10:32:58.889]                       envir <- sys.frame(frame)
[10:32:58.889]                       master <- NULL
[10:32:58.889]                       while (!identical(envir, .GlobalEnv) && 
[10:32:58.889]                         !identical(envir, emptyenv())) {
[10:32:58.889]                         if (exists("master", mode = "list", envir = envir, 
[10:32:58.889]                           inherits = FALSE)) {
[10:32:58.889]                           master <- get("master", mode = "list", 
[10:32:58.889]                             envir = envir, inherits = FALSE)
[10:32:58.889]                           if (inherits(master, c("SOCKnode", 
[10:32:58.889]                             "SOCK0node"))) {
[10:32:58.889]                             sendCondition <<- function(cond) {
[10:32:58.889]                               data <- list(type = "VALUE", value = cond, 
[10:32:58.889]                                 success = TRUE)
[10:32:58.889]                               parallel_sendData(master, data)
[10:32:58.889]                             }
[10:32:58.889]                             return(sendCondition)
[10:32:58.889]                           }
[10:32:58.889]                         }
[10:32:58.889]                         frame <- frame + 1L
[10:32:58.889]                         envir <- sys.frame(frame)
[10:32:58.889]                       }
[10:32:58.889]                     }
[10:32:58.889]                     sendCondition <<- function(cond) NULL
[10:32:58.889]                   }
[10:32:58.889]                 })
[10:32:58.889]                 withCallingHandlers({
[10:32:58.889]                   {
[10:32:58.889]                     lm(dist ~ . + 0, data = cars)
[10:32:58.889]                   }
[10:32:58.889]                 }, immediateCondition = function(cond) {
[10:32:58.889]                   sendCondition <- ...future.makeSendCondition()
[10:32:58.889]                   sendCondition(cond)
[10:32:58.889]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.889]                   {
[10:32:58.889]                     inherits <- base::inherits
[10:32:58.889]                     invokeRestart <- base::invokeRestart
[10:32:58.889]                     is.null <- base::is.null
[10:32:58.889]                     muffled <- FALSE
[10:32:58.889]                     if (inherits(cond, "message")) {
[10:32:58.889]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:58.889]                       if (muffled) 
[10:32:58.889]                         invokeRestart("muffleMessage")
[10:32:58.889]                     }
[10:32:58.889]                     else if (inherits(cond, "warning")) {
[10:32:58.889]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:58.889]                       if (muffled) 
[10:32:58.889]                         invokeRestart("muffleWarning")
[10:32:58.889]                     }
[10:32:58.889]                     else if (inherits(cond, "condition")) {
[10:32:58.889]                       if (!is.null(pattern)) {
[10:32:58.889]                         computeRestarts <- base::computeRestarts
[10:32:58.889]                         grepl <- base::grepl
[10:32:58.889]                         restarts <- computeRestarts(cond)
[10:32:58.889]                         for (restart in restarts) {
[10:32:58.889]                           name <- restart$name
[10:32:58.889]                           if (is.null(name)) 
[10:32:58.889]                             next
[10:32:58.889]                           if (!grepl(pattern, name)) 
[10:32:58.889]                             next
[10:32:58.889]                           invokeRestart(restart)
[10:32:58.889]                           muffled <- TRUE
[10:32:58.889]                           break
[10:32:58.889]                         }
[10:32:58.889]                       }
[10:32:58.889]                     }
[10:32:58.889]                     invisible(muffled)
[10:32:58.889]                   }
[10:32:58.889]                   muffleCondition(cond)
[10:32:58.889]                 })
[10:32:58.889]             }))
[10:32:58.889]             future::FutureResult(value = ...future.value$value, 
[10:32:58.889]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:58.889]                   ...future.rng), globalenv = if (FALSE) 
[10:32:58.889]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:58.889]                     ...future.globalenv.names))
[10:32:58.889]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:58.889]         }, condition = base::local({
[10:32:58.889]             c <- base::c
[10:32:58.889]             inherits <- base::inherits
[10:32:58.889]             invokeRestart <- base::invokeRestart
[10:32:58.889]             length <- base::length
[10:32:58.889]             list <- base::list
[10:32:58.889]             seq.int <- base::seq.int
[10:32:58.889]             signalCondition <- base::signalCondition
[10:32:58.889]             sys.calls <- base::sys.calls
[10:32:58.889]             `[[` <- base::`[[`
[10:32:58.889]             `+` <- base::`+`
[10:32:58.889]             `<<-` <- base::`<<-`
[10:32:58.889]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:58.889]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:58.889]                   3L)]
[10:32:58.889]             }
[10:32:58.889]             function(cond) {
[10:32:58.889]                 is_error <- inherits(cond, "error")
[10:32:58.889]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:58.889]                   NULL)
[10:32:58.889]                 if (is_error) {
[10:32:58.889]                   sessionInformation <- function() {
[10:32:58.889]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:58.889]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:58.889]                       search = base::search(), system = base::Sys.info())
[10:32:58.889]                   }
[10:32:58.889]                   ...future.conditions[[length(...future.conditions) + 
[10:32:58.889]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:58.889]                     cond$call), session = sessionInformation(), 
[10:32:58.889]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:58.889]                   signalCondition(cond)
[10:32:58.889]                 }
[10:32:58.889]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:58.889]                 "immediateCondition"))) {
[10:32:58.889]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:58.889]                   ...future.conditions[[length(...future.conditions) + 
[10:32:58.889]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:58.889]                   if (TRUE && !signal) {
[10:32:58.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.889]                     {
[10:32:58.889]                       inherits <- base::inherits
[10:32:58.889]                       invokeRestart <- base::invokeRestart
[10:32:58.889]                       is.null <- base::is.null
[10:32:58.889]                       muffled <- FALSE
[10:32:58.889]                       if (inherits(cond, "message")) {
[10:32:58.889]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:58.889]                         if (muffled) 
[10:32:58.889]                           invokeRestart("muffleMessage")
[10:32:58.889]                       }
[10:32:58.889]                       else if (inherits(cond, "warning")) {
[10:32:58.889]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:58.889]                         if (muffled) 
[10:32:58.889]                           invokeRestart("muffleWarning")
[10:32:58.889]                       }
[10:32:58.889]                       else if (inherits(cond, "condition")) {
[10:32:58.889]                         if (!is.null(pattern)) {
[10:32:58.889]                           computeRestarts <- base::computeRestarts
[10:32:58.889]                           grepl <- base::grepl
[10:32:58.889]                           restarts <- computeRestarts(cond)
[10:32:58.889]                           for (restart in restarts) {
[10:32:58.889]                             name <- restart$name
[10:32:58.889]                             if (is.null(name)) 
[10:32:58.889]                               next
[10:32:58.889]                             if (!grepl(pattern, name)) 
[10:32:58.889]                               next
[10:32:58.889]                             invokeRestart(restart)
[10:32:58.889]                             muffled <- TRUE
[10:32:58.889]                             break
[10:32:58.889]                           }
[10:32:58.889]                         }
[10:32:58.889]                       }
[10:32:58.889]                       invisible(muffled)
[10:32:58.889]                     }
[10:32:58.889]                     muffleCondition(cond, pattern = "^muffle")
[10:32:58.889]                   }
[10:32:58.889]                 }
[10:32:58.889]                 else {
[10:32:58.889]                   if (TRUE) {
[10:32:58.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.889]                     {
[10:32:58.889]                       inherits <- base::inherits
[10:32:58.889]                       invokeRestart <- base::invokeRestart
[10:32:58.889]                       is.null <- base::is.null
[10:32:58.889]                       muffled <- FALSE
[10:32:58.889]                       if (inherits(cond, "message")) {
[10:32:58.889]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:58.889]                         if (muffled) 
[10:32:58.889]                           invokeRestart("muffleMessage")
[10:32:58.889]                       }
[10:32:58.889]                       else if (inherits(cond, "warning")) {
[10:32:58.889]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:58.889]                         if (muffled) 
[10:32:58.889]                           invokeRestart("muffleWarning")
[10:32:58.889]                       }
[10:32:58.889]                       else if (inherits(cond, "condition")) {
[10:32:58.889]                         if (!is.null(pattern)) {
[10:32:58.889]                           computeRestarts <- base::computeRestarts
[10:32:58.889]                           grepl <- base::grepl
[10:32:58.889]                           restarts <- computeRestarts(cond)
[10:32:58.889]                           for (restart in restarts) {
[10:32:58.889]                             name <- restart$name
[10:32:58.889]                             if (is.null(name)) 
[10:32:58.889]                               next
[10:32:58.889]                             if (!grepl(pattern, name)) 
[10:32:58.889]                               next
[10:32:58.889]                             invokeRestart(restart)
[10:32:58.889]                             muffled <- TRUE
[10:32:58.889]                             break
[10:32:58.889]                           }
[10:32:58.889]                         }
[10:32:58.889]                       }
[10:32:58.889]                       invisible(muffled)
[10:32:58.889]                     }
[10:32:58.889]                     muffleCondition(cond, pattern = "^muffle")
[10:32:58.889]                   }
[10:32:58.889]                 }
[10:32:58.889]             }
[10:32:58.889]         }))
[10:32:58.889]     }, error = function(ex) {
[10:32:58.889]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:58.889]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:58.889]                 ...future.rng), started = ...future.startTime, 
[10:32:58.889]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:58.889]             version = "1.8"), class = "FutureResult")
[10:32:58.889]     }, finally = {
[10:32:58.889]         if (!identical(...future.workdir, getwd())) 
[10:32:58.889]             setwd(...future.workdir)
[10:32:58.889]         {
[10:32:58.889]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:58.889]                 ...future.oldOptions$nwarnings <- NULL
[10:32:58.889]             }
[10:32:58.889]             base::options(...future.oldOptions)
[10:32:58.889]             if (.Platform$OS.type == "windows") {
[10:32:58.889]                 old_names <- names(...future.oldEnvVars)
[10:32:58.889]                 envs <- base::Sys.getenv()
[10:32:58.889]                 names <- names(envs)
[10:32:58.889]                 common <- intersect(names, old_names)
[10:32:58.889]                 added <- setdiff(names, old_names)
[10:32:58.889]                 removed <- setdiff(old_names, names)
[10:32:58.889]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:58.889]                   envs[common]]
[10:32:58.889]                 NAMES <- toupper(changed)
[10:32:58.889]                 args <- list()
[10:32:58.889]                 for (kk in seq_along(NAMES)) {
[10:32:58.889]                   name <- changed[[kk]]
[10:32:58.889]                   NAME <- NAMES[[kk]]
[10:32:58.889]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.889]                     next
[10:32:58.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:58.889]                 }
[10:32:58.889]                 NAMES <- toupper(added)
[10:32:58.889]                 for (kk in seq_along(NAMES)) {
[10:32:58.889]                   name <- added[[kk]]
[10:32:58.889]                   NAME <- NAMES[[kk]]
[10:32:58.889]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.889]                     next
[10:32:58.889]                   args[[name]] <- ""
[10:32:58.889]                 }
[10:32:58.889]                 NAMES <- toupper(removed)
[10:32:58.889]                 for (kk in seq_along(NAMES)) {
[10:32:58.889]                   name <- removed[[kk]]
[10:32:58.889]                   NAME <- NAMES[[kk]]
[10:32:58.889]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.889]                     next
[10:32:58.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:58.889]                 }
[10:32:58.889]                 if (length(args) > 0) 
[10:32:58.889]                   base::do.call(base::Sys.setenv, args = args)
[10:32:58.889]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:58.889]             }
[10:32:58.889]             else {
[10:32:58.889]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:58.889]             }
[10:32:58.889]             {
[10:32:58.889]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:58.889]                   0L) {
[10:32:58.889]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:58.889]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:58.889]                   base::options(opts)
[10:32:58.889]                 }
[10:32:58.889]                 {
[10:32:58.889]                   {
[10:32:58.889]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:58.889]                     NULL
[10:32:58.889]                   }
[10:32:58.889]                   options(future.plan = NULL)
[10:32:58.889]                   if (is.na(NA_character_)) 
[10:32:58.889]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:58.889]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:58.889]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:58.889]                     .init = FALSE)
[10:32:58.889]                 }
[10:32:58.889]             }
[10:32:58.889]         }
[10:32:58.889]     })
[10:32:58.889]     if (TRUE) {
[10:32:58.889]         base::sink(type = "output", split = FALSE)
[10:32:58.889]         if (TRUE) {
[10:32:58.889]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:58.889]         }
[10:32:58.889]         else {
[10:32:58.889]             ...future.result["stdout"] <- base::list(NULL)
[10:32:58.889]         }
[10:32:58.889]         base::close(...future.stdout)
[10:32:58.889]         ...future.stdout <- NULL
[10:32:58.889]     }
[10:32:58.889]     ...future.result$conditions <- ...future.conditions
[10:32:58.889]     ...future.result$finished <- base::Sys.time()
[10:32:58.889]     ...future.result
[10:32:58.889] }
[10:32:58.892] MultisessionFuture started
[10:32:58.892] - Launch lazy future ... done
[10:32:58.892] run() for ‘MultisessionFuture’ ... done
[10:32:58.892] result() for ClusterFuture ...
[10:32:58.892] receiveMessageFromWorker() for ClusterFuture ...
[10:32:58.892] - Validating connection of MultisessionFuture
[10:32:58.935] - received message: FutureResult
[10:32:58.935] - Received FutureResult
[10:32:58.936] - Erased future from FutureRegistry
[10:32:58.936] result() for ClusterFuture ...
[10:32:58.936] - result already collected: FutureResult
[10:32:58.936] result() for ClusterFuture ... done
[10:32:58.936] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:58.936] result() for ClusterFuture ... done
[10:32:58.936] result() for ClusterFuture ...
[10:32:58.936] - result already collected: FutureResult
[10:32:58.936] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[10:32:58.939] getGlobalsAndPackages() ...
[10:32:58.939] Searching for globals...
[10:32:58.941] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[10:32:58.941] Searching for globals ... DONE
[10:32:58.941] Resolving globals: FALSE
[10:32:58.941] 
[10:32:58.941] - packages: [2] ‘stats’, ‘datasets’
[10:32:58.942] getGlobalsAndPackages() ... DONE
[10:32:58.942] run() for ‘Future’ ...
[10:32:58.942] - state: ‘created’
[10:32:58.942] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:58.957] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:58.957] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:58.957]   - Field: ‘node’
[10:32:58.957]   - Field: ‘label’
[10:32:58.957]   - Field: ‘local’
[10:32:58.957]   - Field: ‘owner’
[10:32:58.957]   - Field: ‘envir’
[10:32:58.957]   - Field: ‘workers’
[10:32:58.957]   - Field: ‘packages’
[10:32:58.958]   - Field: ‘gc’
[10:32:58.958]   - Field: ‘conditions’
[10:32:58.958]   - Field: ‘persistent’
[10:32:58.958]   - Field: ‘expr’
[10:32:58.958]   - Field: ‘uuid’
[10:32:58.958]   - Field: ‘seed’
[10:32:58.958]   - Field: ‘version’
[10:32:58.958]   - Field: ‘result’
[10:32:58.958]   - Field: ‘asynchronous’
[10:32:58.958]   - Field: ‘calls’
[10:32:58.958]   - Field: ‘globals’
[10:32:58.959]   - Field: ‘stdout’
[10:32:58.959]   - Field: ‘earlySignal’
[10:32:58.959]   - Field: ‘lazy’
[10:32:58.959]   - Field: ‘state’
[10:32:58.959] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:58.959] - Launch lazy future ...
[10:32:58.959] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:32:58.959] Packages needed by future strategies (n = 0): <none>
[10:32:58.960] {
[10:32:58.960]     {
[10:32:58.960]         {
[10:32:58.960]             ...future.startTime <- base::Sys.time()
[10:32:58.960]             {
[10:32:58.960]                 {
[10:32:58.960]                   {
[10:32:58.960]                     {
[10:32:58.960]                       {
[10:32:58.960]                         base::local({
[10:32:58.960]                           has_future <- base::requireNamespace("future", 
[10:32:58.960]                             quietly = TRUE)
[10:32:58.960]                           if (has_future) {
[10:32:58.960]                             ns <- base::getNamespace("future")
[10:32:58.960]                             version <- ns[[".package"]][["version"]]
[10:32:58.960]                             if (is.null(version)) 
[10:32:58.960]                               version <- utils::packageVersion("future")
[10:32:58.960]                           }
[10:32:58.960]                           else {
[10:32:58.960]                             version <- NULL
[10:32:58.960]                           }
[10:32:58.960]                           if (!has_future || version < "1.8.0") {
[10:32:58.960]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:58.960]                               "", base::R.version$version.string), 
[10:32:58.960]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:58.960]                                 base::R.version$platform, 8 * 
[10:32:58.960]                                   base::.Machine$sizeof.pointer), 
[10:32:58.960]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:58.960]                                 "release", "version")], collapse = " "), 
[10:32:58.960]                               hostname = base::Sys.info()[["nodename"]])
[10:32:58.960]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:58.960]                               info)
[10:32:58.960]                             info <- base::paste(info, collapse = "; ")
[10:32:58.960]                             if (!has_future) {
[10:32:58.960]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:58.960]                                 info)
[10:32:58.960]                             }
[10:32:58.960]                             else {
[10:32:58.960]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:58.960]                                 info, version)
[10:32:58.960]                             }
[10:32:58.960]                             base::stop(msg)
[10:32:58.960]                           }
[10:32:58.960]                         })
[10:32:58.960]                       }
[10:32:58.960]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:58.960]                       base::options(mc.cores = 1L)
[10:32:58.960]                     }
[10:32:58.960]                     base::local({
[10:32:58.960]                       for (pkg in c("stats", "datasets")) {
[10:32:58.960]                         base::loadNamespace(pkg)
[10:32:58.960]                         base::library(pkg, character.only = TRUE)
[10:32:58.960]                       }
[10:32:58.960]                     })
[10:32:58.960]                   }
[10:32:58.960]                   ...future.strategy.old <- future::plan("list")
[10:32:58.960]                   options(future.plan = NULL)
[10:32:58.960]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:58.960]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:58.960]                 }
[10:32:58.960]                 ...future.workdir <- getwd()
[10:32:58.960]             }
[10:32:58.960]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:58.960]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:58.960]         }
[10:32:58.960]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:58.960]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:58.960]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:58.960]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:58.960]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:58.960]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:58.960]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:58.960]             base::names(...future.oldOptions))
[10:32:58.960]     }
[10:32:58.960]     if (FALSE) {
[10:32:58.960]     }
[10:32:58.960]     else {
[10:32:58.960]         if (TRUE) {
[10:32:58.960]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:58.960]                 open = "w")
[10:32:58.960]         }
[10:32:58.960]         else {
[10:32:58.960]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:58.960]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:58.960]         }
[10:32:58.960]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:58.960]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:58.960]             base::sink(type = "output", split = FALSE)
[10:32:58.960]             base::close(...future.stdout)
[10:32:58.960]         }, add = TRUE)
[10:32:58.960]     }
[10:32:58.960]     ...future.frame <- base::sys.nframe()
[10:32:58.960]     ...future.conditions <- base::list()
[10:32:58.960]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:58.960]     if (FALSE) {
[10:32:58.960]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:58.960]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:58.960]     }
[10:32:58.960]     ...future.result <- base::tryCatch({
[10:32:58.960]         base::withCallingHandlers({
[10:32:58.960]             ...future.value <- base::withVisible(base::local({
[10:32:58.960]                 ...future.makeSendCondition <- base::local({
[10:32:58.960]                   sendCondition <- NULL
[10:32:58.960]                   function(frame = 1L) {
[10:32:58.960]                     if (is.function(sendCondition)) 
[10:32:58.960]                       return(sendCondition)
[10:32:58.960]                     ns <- getNamespace("parallel")
[10:32:58.960]                     if (exists("sendData", mode = "function", 
[10:32:58.960]                       envir = ns)) {
[10:32:58.960]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:58.960]                         envir = ns)
[10:32:58.960]                       envir <- sys.frame(frame)
[10:32:58.960]                       master <- NULL
[10:32:58.960]                       while (!identical(envir, .GlobalEnv) && 
[10:32:58.960]                         !identical(envir, emptyenv())) {
[10:32:58.960]                         if (exists("master", mode = "list", envir = envir, 
[10:32:58.960]                           inherits = FALSE)) {
[10:32:58.960]                           master <- get("master", mode = "list", 
[10:32:58.960]                             envir = envir, inherits = FALSE)
[10:32:58.960]                           if (inherits(master, c("SOCKnode", 
[10:32:58.960]                             "SOCK0node"))) {
[10:32:58.960]                             sendCondition <<- function(cond) {
[10:32:58.960]                               data <- list(type = "VALUE", value = cond, 
[10:32:58.960]                                 success = TRUE)
[10:32:58.960]                               parallel_sendData(master, data)
[10:32:58.960]                             }
[10:32:58.960]                             return(sendCondition)
[10:32:58.960]                           }
[10:32:58.960]                         }
[10:32:58.960]                         frame <- frame + 1L
[10:32:58.960]                         envir <- sys.frame(frame)
[10:32:58.960]                       }
[10:32:58.960]                     }
[10:32:58.960]                     sendCondition <<- function(cond) NULL
[10:32:58.960]                   }
[10:32:58.960]                 })
[10:32:58.960]                 withCallingHandlers({
[10:32:58.960]                   {
[10:32:58.960]                     lm(dist ~ speed + speed^2, data = cars)
[10:32:58.960]                   }
[10:32:58.960]                 }, immediateCondition = function(cond) {
[10:32:58.960]                   sendCondition <- ...future.makeSendCondition()
[10:32:58.960]                   sendCondition(cond)
[10:32:58.960]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.960]                   {
[10:32:58.960]                     inherits <- base::inherits
[10:32:58.960]                     invokeRestart <- base::invokeRestart
[10:32:58.960]                     is.null <- base::is.null
[10:32:58.960]                     muffled <- FALSE
[10:32:58.960]                     if (inherits(cond, "message")) {
[10:32:58.960]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:58.960]                       if (muffled) 
[10:32:58.960]                         invokeRestart("muffleMessage")
[10:32:58.960]                     }
[10:32:58.960]                     else if (inherits(cond, "warning")) {
[10:32:58.960]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:58.960]                       if (muffled) 
[10:32:58.960]                         invokeRestart("muffleWarning")
[10:32:58.960]                     }
[10:32:58.960]                     else if (inherits(cond, "condition")) {
[10:32:58.960]                       if (!is.null(pattern)) {
[10:32:58.960]                         computeRestarts <- base::computeRestarts
[10:32:58.960]                         grepl <- base::grepl
[10:32:58.960]                         restarts <- computeRestarts(cond)
[10:32:58.960]                         for (restart in restarts) {
[10:32:58.960]                           name <- restart$name
[10:32:58.960]                           if (is.null(name)) 
[10:32:58.960]                             next
[10:32:58.960]                           if (!grepl(pattern, name)) 
[10:32:58.960]                             next
[10:32:58.960]                           invokeRestart(restart)
[10:32:58.960]                           muffled <- TRUE
[10:32:58.960]                           break
[10:32:58.960]                         }
[10:32:58.960]                       }
[10:32:58.960]                     }
[10:32:58.960]                     invisible(muffled)
[10:32:58.960]                   }
[10:32:58.960]                   muffleCondition(cond)
[10:32:58.960]                 })
[10:32:58.960]             }))
[10:32:58.960]             future::FutureResult(value = ...future.value$value, 
[10:32:58.960]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:58.960]                   ...future.rng), globalenv = if (FALSE) 
[10:32:58.960]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:58.960]                     ...future.globalenv.names))
[10:32:58.960]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:58.960]         }, condition = base::local({
[10:32:58.960]             c <- base::c
[10:32:58.960]             inherits <- base::inherits
[10:32:58.960]             invokeRestart <- base::invokeRestart
[10:32:58.960]             length <- base::length
[10:32:58.960]             list <- base::list
[10:32:58.960]             seq.int <- base::seq.int
[10:32:58.960]             signalCondition <- base::signalCondition
[10:32:58.960]             sys.calls <- base::sys.calls
[10:32:58.960]             `[[` <- base::`[[`
[10:32:58.960]             `+` <- base::`+`
[10:32:58.960]             `<<-` <- base::`<<-`
[10:32:58.960]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:58.960]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:58.960]                   3L)]
[10:32:58.960]             }
[10:32:58.960]             function(cond) {
[10:32:58.960]                 is_error <- inherits(cond, "error")
[10:32:58.960]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:58.960]                   NULL)
[10:32:58.960]                 if (is_error) {
[10:32:58.960]                   sessionInformation <- function() {
[10:32:58.960]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:58.960]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:58.960]                       search = base::search(), system = base::Sys.info())
[10:32:58.960]                   }
[10:32:58.960]                   ...future.conditions[[length(...future.conditions) + 
[10:32:58.960]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:58.960]                     cond$call), session = sessionInformation(), 
[10:32:58.960]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:58.960]                   signalCondition(cond)
[10:32:58.960]                 }
[10:32:58.960]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:58.960]                 "immediateCondition"))) {
[10:32:58.960]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:58.960]                   ...future.conditions[[length(...future.conditions) + 
[10:32:58.960]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:58.960]                   if (TRUE && !signal) {
[10:32:58.960]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.960]                     {
[10:32:58.960]                       inherits <- base::inherits
[10:32:58.960]                       invokeRestart <- base::invokeRestart
[10:32:58.960]                       is.null <- base::is.null
[10:32:58.960]                       muffled <- FALSE
[10:32:58.960]                       if (inherits(cond, "message")) {
[10:32:58.960]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:58.960]                         if (muffled) 
[10:32:58.960]                           invokeRestart("muffleMessage")
[10:32:58.960]                       }
[10:32:58.960]                       else if (inherits(cond, "warning")) {
[10:32:58.960]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:58.960]                         if (muffled) 
[10:32:58.960]                           invokeRestart("muffleWarning")
[10:32:58.960]                       }
[10:32:58.960]                       else if (inherits(cond, "condition")) {
[10:32:58.960]                         if (!is.null(pattern)) {
[10:32:58.960]                           computeRestarts <- base::computeRestarts
[10:32:58.960]                           grepl <- base::grepl
[10:32:58.960]                           restarts <- computeRestarts(cond)
[10:32:58.960]                           for (restart in restarts) {
[10:32:58.960]                             name <- restart$name
[10:32:58.960]                             if (is.null(name)) 
[10:32:58.960]                               next
[10:32:58.960]                             if (!grepl(pattern, name)) 
[10:32:58.960]                               next
[10:32:58.960]                             invokeRestart(restart)
[10:32:58.960]                             muffled <- TRUE
[10:32:58.960]                             break
[10:32:58.960]                           }
[10:32:58.960]                         }
[10:32:58.960]                       }
[10:32:58.960]                       invisible(muffled)
[10:32:58.960]                     }
[10:32:58.960]                     muffleCondition(cond, pattern = "^muffle")
[10:32:58.960]                   }
[10:32:58.960]                 }
[10:32:58.960]                 else {
[10:32:58.960]                   if (TRUE) {
[10:32:58.960]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:58.960]                     {
[10:32:58.960]                       inherits <- base::inherits
[10:32:58.960]                       invokeRestart <- base::invokeRestart
[10:32:58.960]                       is.null <- base::is.null
[10:32:58.960]                       muffled <- FALSE
[10:32:58.960]                       if (inherits(cond, "message")) {
[10:32:58.960]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:58.960]                         if (muffled) 
[10:32:58.960]                           invokeRestart("muffleMessage")
[10:32:58.960]                       }
[10:32:58.960]                       else if (inherits(cond, "warning")) {
[10:32:58.960]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:58.960]                         if (muffled) 
[10:32:58.960]                           invokeRestart("muffleWarning")
[10:32:58.960]                       }
[10:32:58.960]                       else if (inherits(cond, "condition")) {
[10:32:58.960]                         if (!is.null(pattern)) {
[10:32:58.960]                           computeRestarts <- base::computeRestarts
[10:32:58.960]                           grepl <- base::grepl
[10:32:58.960]                           restarts <- computeRestarts(cond)
[10:32:58.960]                           for (restart in restarts) {
[10:32:58.960]                             name <- restart$name
[10:32:58.960]                             if (is.null(name)) 
[10:32:58.960]                               next
[10:32:58.960]                             if (!grepl(pattern, name)) 
[10:32:58.960]                               next
[10:32:58.960]                             invokeRestart(restart)
[10:32:58.960]                             muffled <- TRUE
[10:32:58.960]                             break
[10:32:58.960]                           }
[10:32:58.960]                         }
[10:32:58.960]                       }
[10:32:58.960]                       invisible(muffled)
[10:32:58.960]                     }
[10:32:58.960]                     muffleCondition(cond, pattern = "^muffle")
[10:32:58.960]                   }
[10:32:58.960]                 }
[10:32:58.960]             }
[10:32:58.960]         }))
[10:32:58.960]     }, error = function(ex) {
[10:32:58.960]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:58.960]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:58.960]                 ...future.rng), started = ...future.startTime, 
[10:32:58.960]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:58.960]             version = "1.8"), class = "FutureResult")
[10:32:58.960]     }, finally = {
[10:32:58.960]         if (!identical(...future.workdir, getwd())) 
[10:32:58.960]             setwd(...future.workdir)
[10:32:58.960]         {
[10:32:58.960]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:58.960]                 ...future.oldOptions$nwarnings <- NULL
[10:32:58.960]             }
[10:32:58.960]             base::options(...future.oldOptions)
[10:32:58.960]             if (.Platform$OS.type == "windows") {
[10:32:58.960]                 old_names <- names(...future.oldEnvVars)
[10:32:58.960]                 envs <- base::Sys.getenv()
[10:32:58.960]                 names <- names(envs)
[10:32:58.960]                 common <- intersect(names, old_names)
[10:32:58.960]                 added <- setdiff(names, old_names)
[10:32:58.960]                 removed <- setdiff(old_names, names)
[10:32:58.960]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:58.960]                   envs[common]]
[10:32:58.960]                 NAMES <- toupper(changed)
[10:32:58.960]                 args <- list()
[10:32:58.960]                 for (kk in seq_along(NAMES)) {
[10:32:58.960]                   name <- changed[[kk]]
[10:32:58.960]                   NAME <- NAMES[[kk]]
[10:32:58.960]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.960]                     next
[10:32:58.960]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:58.960]                 }
[10:32:58.960]                 NAMES <- toupper(added)
[10:32:58.960]                 for (kk in seq_along(NAMES)) {
[10:32:58.960]                   name <- added[[kk]]
[10:32:58.960]                   NAME <- NAMES[[kk]]
[10:32:58.960]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.960]                     next
[10:32:58.960]                   args[[name]] <- ""
[10:32:58.960]                 }
[10:32:58.960]                 NAMES <- toupper(removed)
[10:32:58.960]                 for (kk in seq_along(NAMES)) {
[10:32:58.960]                   name <- removed[[kk]]
[10:32:58.960]                   NAME <- NAMES[[kk]]
[10:32:58.960]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:58.960]                     next
[10:32:58.960]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:58.960]                 }
[10:32:58.960]                 if (length(args) > 0) 
[10:32:58.960]                   base::do.call(base::Sys.setenv, args = args)
[10:32:58.960]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:58.960]             }
[10:32:58.960]             else {
[10:32:58.960]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:58.960]             }
[10:32:58.960]             {
[10:32:58.960]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:58.960]                   0L) {
[10:32:58.960]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:58.960]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:58.960]                   base::options(opts)
[10:32:58.960]                 }
[10:32:58.960]                 {
[10:32:58.960]                   {
[10:32:58.960]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:58.960]                     NULL
[10:32:58.960]                   }
[10:32:58.960]                   options(future.plan = NULL)
[10:32:58.960]                   if (is.na(NA_character_)) 
[10:32:58.960]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:58.960]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:58.960]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:58.960]                     .init = FALSE)
[10:32:58.960]                 }
[10:32:58.960]             }
[10:32:58.960]         }
[10:32:58.960]     })
[10:32:58.960]     if (TRUE) {
[10:32:58.960]         base::sink(type = "output", split = FALSE)
[10:32:58.960]         if (TRUE) {
[10:32:58.960]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:58.960]         }
[10:32:58.960]         else {
[10:32:58.960]             ...future.result["stdout"] <- base::list(NULL)
[10:32:58.960]         }
[10:32:58.960]         base::close(...future.stdout)
[10:32:58.960]         ...future.stdout <- NULL
[10:32:58.960]     }
[10:32:58.960]     ...future.result$conditions <- ...future.conditions
[10:32:58.960]     ...future.result$finished <- base::Sys.time()
[10:32:58.960]     ...future.result
[10:32:58.960] }
[10:32:58.963] MultisessionFuture started
[10:32:58.963] - Launch lazy future ... done
[10:32:58.963] run() for ‘MultisessionFuture’ ... done
[10:32:58.963] result() for ClusterFuture ...
[10:32:58.963] receiveMessageFromWorker() for ClusterFuture ...
[10:32:58.963] - Validating connection of MultisessionFuture
[10:32:59.007] - received message: FutureResult
[10:32:59.007] - Received FutureResult
[10:32:59.007] - Erased future from FutureRegistry
[10:32:59.008] result() for ClusterFuture ...
[10:32:59.008] - result already collected: FutureResult
[10:32:59.008] result() for ClusterFuture ... done
[10:32:59.008] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:59.008] result() for ClusterFuture ... done
[10:32:59.008] result() for ClusterFuture ...
[10:32:59.008] - result already collected: FutureResult
[10:32:59.008] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[10:32:59.011] getGlobalsAndPackages() ...
[10:32:59.011] Searching for globals...
[10:32:59.013] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[10:32:59.013] Searching for globals ... DONE
[10:32:59.013] Resolving globals: FALSE
[10:32:59.013] 
[10:32:59.013] - packages: [2] ‘stats’, ‘datasets’
[10:32:59.014] getGlobalsAndPackages() ... DONE
[10:32:59.014] run() for ‘Future’ ...
[10:32:59.014] - state: ‘created’
[10:32:59.014] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:59.028] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:59.028] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:59.028]   - Field: ‘node’
[10:32:59.028]   - Field: ‘label’
[10:32:59.028]   - Field: ‘local’
[10:32:59.028]   - Field: ‘owner’
[10:32:59.028]   - Field: ‘envir’
[10:32:59.028]   - Field: ‘workers’
[10:32:59.028]   - Field: ‘packages’
[10:32:59.028]   - Field: ‘gc’
[10:32:59.029]   - Field: ‘conditions’
[10:32:59.029]   - Field: ‘persistent’
[10:32:59.029]   - Field: ‘expr’
[10:32:59.029]   - Field: ‘uuid’
[10:32:59.029]   - Field: ‘seed’
[10:32:59.029]   - Field: ‘version’
[10:32:59.029]   - Field: ‘result’
[10:32:59.029]   - Field: ‘asynchronous’
[10:32:59.029]   - Field: ‘calls’
[10:32:59.029]   - Field: ‘globals’
[10:32:59.030]   - Field: ‘stdout’
[10:32:59.030]   - Field: ‘earlySignal’
[10:32:59.030]   - Field: ‘lazy’
[10:32:59.030]   - Field: ‘state’
[10:32:59.030] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:59.030] - Launch lazy future ...
[10:32:59.030] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:32:59.030] Packages needed by future strategies (n = 0): <none>
[10:32:59.031] {
[10:32:59.031]     {
[10:32:59.031]         {
[10:32:59.031]             ...future.startTime <- base::Sys.time()
[10:32:59.031]             {
[10:32:59.031]                 {
[10:32:59.031]                   {
[10:32:59.031]                     {
[10:32:59.031]                       {
[10:32:59.031]                         base::local({
[10:32:59.031]                           has_future <- base::requireNamespace("future", 
[10:32:59.031]                             quietly = TRUE)
[10:32:59.031]                           if (has_future) {
[10:32:59.031]                             ns <- base::getNamespace("future")
[10:32:59.031]                             version <- ns[[".package"]][["version"]]
[10:32:59.031]                             if (is.null(version)) 
[10:32:59.031]                               version <- utils::packageVersion("future")
[10:32:59.031]                           }
[10:32:59.031]                           else {
[10:32:59.031]                             version <- NULL
[10:32:59.031]                           }
[10:32:59.031]                           if (!has_future || version < "1.8.0") {
[10:32:59.031]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:59.031]                               "", base::R.version$version.string), 
[10:32:59.031]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:59.031]                                 base::R.version$platform, 8 * 
[10:32:59.031]                                   base::.Machine$sizeof.pointer), 
[10:32:59.031]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:59.031]                                 "release", "version")], collapse = " "), 
[10:32:59.031]                               hostname = base::Sys.info()[["nodename"]])
[10:32:59.031]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:59.031]                               info)
[10:32:59.031]                             info <- base::paste(info, collapse = "; ")
[10:32:59.031]                             if (!has_future) {
[10:32:59.031]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:59.031]                                 info)
[10:32:59.031]                             }
[10:32:59.031]                             else {
[10:32:59.031]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:59.031]                                 info, version)
[10:32:59.031]                             }
[10:32:59.031]                             base::stop(msg)
[10:32:59.031]                           }
[10:32:59.031]                         })
[10:32:59.031]                       }
[10:32:59.031]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:59.031]                       base::options(mc.cores = 1L)
[10:32:59.031]                     }
[10:32:59.031]                     base::local({
[10:32:59.031]                       for (pkg in c("stats", "datasets")) {
[10:32:59.031]                         base::loadNamespace(pkg)
[10:32:59.031]                         base::library(pkg, character.only = TRUE)
[10:32:59.031]                       }
[10:32:59.031]                     })
[10:32:59.031]                   }
[10:32:59.031]                   ...future.strategy.old <- future::plan("list")
[10:32:59.031]                   options(future.plan = NULL)
[10:32:59.031]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:59.031]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:59.031]                 }
[10:32:59.031]                 ...future.workdir <- getwd()
[10:32:59.031]             }
[10:32:59.031]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:59.031]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:59.031]         }
[10:32:59.031]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:59.031]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:59.031]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:59.031]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:59.031]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:59.031]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:59.031]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:59.031]             base::names(...future.oldOptions))
[10:32:59.031]     }
[10:32:59.031]     if (FALSE) {
[10:32:59.031]     }
[10:32:59.031]     else {
[10:32:59.031]         if (TRUE) {
[10:32:59.031]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:59.031]                 open = "w")
[10:32:59.031]         }
[10:32:59.031]         else {
[10:32:59.031]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:59.031]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:59.031]         }
[10:32:59.031]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:59.031]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:59.031]             base::sink(type = "output", split = FALSE)
[10:32:59.031]             base::close(...future.stdout)
[10:32:59.031]         }, add = TRUE)
[10:32:59.031]     }
[10:32:59.031]     ...future.frame <- base::sys.nframe()
[10:32:59.031]     ...future.conditions <- base::list()
[10:32:59.031]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:59.031]     if (FALSE) {
[10:32:59.031]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:59.031]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:59.031]     }
[10:32:59.031]     ...future.result <- base::tryCatch({
[10:32:59.031]         base::withCallingHandlers({
[10:32:59.031]             ...future.value <- base::withVisible(base::local({
[10:32:59.031]                 ...future.makeSendCondition <- base::local({
[10:32:59.031]                   sendCondition <- NULL
[10:32:59.031]                   function(frame = 1L) {
[10:32:59.031]                     if (is.function(sendCondition)) 
[10:32:59.031]                       return(sendCondition)
[10:32:59.031]                     ns <- getNamespace("parallel")
[10:32:59.031]                     if (exists("sendData", mode = "function", 
[10:32:59.031]                       envir = ns)) {
[10:32:59.031]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:59.031]                         envir = ns)
[10:32:59.031]                       envir <- sys.frame(frame)
[10:32:59.031]                       master <- NULL
[10:32:59.031]                       while (!identical(envir, .GlobalEnv) && 
[10:32:59.031]                         !identical(envir, emptyenv())) {
[10:32:59.031]                         if (exists("master", mode = "list", envir = envir, 
[10:32:59.031]                           inherits = FALSE)) {
[10:32:59.031]                           master <- get("master", mode = "list", 
[10:32:59.031]                             envir = envir, inherits = FALSE)
[10:32:59.031]                           if (inherits(master, c("SOCKnode", 
[10:32:59.031]                             "SOCK0node"))) {
[10:32:59.031]                             sendCondition <<- function(cond) {
[10:32:59.031]                               data <- list(type = "VALUE", value = cond, 
[10:32:59.031]                                 success = TRUE)
[10:32:59.031]                               parallel_sendData(master, data)
[10:32:59.031]                             }
[10:32:59.031]                             return(sendCondition)
[10:32:59.031]                           }
[10:32:59.031]                         }
[10:32:59.031]                         frame <- frame + 1L
[10:32:59.031]                         envir <- sys.frame(frame)
[10:32:59.031]                       }
[10:32:59.031]                     }
[10:32:59.031]                     sendCondition <<- function(cond) NULL
[10:32:59.031]                   }
[10:32:59.031]                 })
[10:32:59.031]                 withCallingHandlers({
[10:32:59.031]                   {
[10:32:59.031]                     lm(dist ~ speed + I(speed^2), data = cars)
[10:32:59.031]                   }
[10:32:59.031]                 }, immediateCondition = function(cond) {
[10:32:59.031]                   sendCondition <- ...future.makeSendCondition()
[10:32:59.031]                   sendCondition(cond)
[10:32:59.031]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:59.031]                   {
[10:32:59.031]                     inherits <- base::inherits
[10:32:59.031]                     invokeRestart <- base::invokeRestart
[10:32:59.031]                     is.null <- base::is.null
[10:32:59.031]                     muffled <- FALSE
[10:32:59.031]                     if (inherits(cond, "message")) {
[10:32:59.031]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:59.031]                       if (muffled) 
[10:32:59.031]                         invokeRestart("muffleMessage")
[10:32:59.031]                     }
[10:32:59.031]                     else if (inherits(cond, "warning")) {
[10:32:59.031]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:59.031]                       if (muffled) 
[10:32:59.031]                         invokeRestart("muffleWarning")
[10:32:59.031]                     }
[10:32:59.031]                     else if (inherits(cond, "condition")) {
[10:32:59.031]                       if (!is.null(pattern)) {
[10:32:59.031]                         computeRestarts <- base::computeRestarts
[10:32:59.031]                         grepl <- base::grepl
[10:32:59.031]                         restarts <- computeRestarts(cond)
[10:32:59.031]                         for (restart in restarts) {
[10:32:59.031]                           name <- restart$name
[10:32:59.031]                           if (is.null(name)) 
[10:32:59.031]                             next
[10:32:59.031]                           if (!grepl(pattern, name)) 
[10:32:59.031]                             next
[10:32:59.031]                           invokeRestart(restart)
[10:32:59.031]                           muffled <- TRUE
[10:32:59.031]                           break
[10:32:59.031]                         }
[10:32:59.031]                       }
[10:32:59.031]                     }
[10:32:59.031]                     invisible(muffled)
[10:32:59.031]                   }
[10:32:59.031]                   muffleCondition(cond)
[10:32:59.031]                 })
[10:32:59.031]             }))
[10:32:59.031]             future::FutureResult(value = ...future.value$value, 
[10:32:59.031]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:59.031]                   ...future.rng), globalenv = if (FALSE) 
[10:32:59.031]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:59.031]                     ...future.globalenv.names))
[10:32:59.031]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:59.031]         }, condition = base::local({
[10:32:59.031]             c <- base::c
[10:32:59.031]             inherits <- base::inherits
[10:32:59.031]             invokeRestart <- base::invokeRestart
[10:32:59.031]             length <- base::length
[10:32:59.031]             list <- base::list
[10:32:59.031]             seq.int <- base::seq.int
[10:32:59.031]             signalCondition <- base::signalCondition
[10:32:59.031]             sys.calls <- base::sys.calls
[10:32:59.031]             `[[` <- base::`[[`
[10:32:59.031]             `+` <- base::`+`
[10:32:59.031]             `<<-` <- base::`<<-`
[10:32:59.031]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:59.031]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:59.031]                   3L)]
[10:32:59.031]             }
[10:32:59.031]             function(cond) {
[10:32:59.031]                 is_error <- inherits(cond, "error")
[10:32:59.031]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:59.031]                   NULL)
[10:32:59.031]                 if (is_error) {
[10:32:59.031]                   sessionInformation <- function() {
[10:32:59.031]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:59.031]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:59.031]                       search = base::search(), system = base::Sys.info())
[10:32:59.031]                   }
[10:32:59.031]                   ...future.conditions[[length(...future.conditions) + 
[10:32:59.031]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:59.031]                     cond$call), session = sessionInformation(), 
[10:32:59.031]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:59.031]                   signalCondition(cond)
[10:32:59.031]                 }
[10:32:59.031]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:59.031]                 "immediateCondition"))) {
[10:32:59.031]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:59.031]                   ...future.conditions[[length(...future.conditions) + 
[10:32:59.031]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:59.031]                   if (TRUE && !signal) {
[10:32:59.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:59.031]                     {
[10:32:59.031]                       inherits <- base::inherits
[10:32:59.031]                       invokeRestart <- base::invokeRestart
[10:32:59.031]                       is.null <- base::is.null
[10:32:59.031]                       muffled <- FALSE
[10:32:59.031]                       if (inherits(cond, "message")) {
[10:32:59.031]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:59.031]                         if (muffled) 
[10:32:59.031]                           invokeRestart("muffleMessage")
[10:32:59.031]                       }
[10:32:59.031]                       else if (inherits(cond, "warning")) {
[10:32:59.031]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:59.031]                         if (muffled) 
[10:32:59.031]                           invokeRestart("muffleWarning")
[10:32:59.031]                       }
[10:32:59.031]                       else if (inherits(cond, "condition")) {
[10:32:59.031]                         if (!is.null(pattern)) {
[10:32:59.031]                           computeRestarts <- base::computeRestarts
[10:32:59.031]                           grepl <- base::grepl
[10:32:59.031]                           restarts <- computeRestarts(cond)
[10:32:59.031]                           for (restart in restarts) {
[10:32:59.031]                             name <- restart$name
[10:32:59.031]                             if (is.null(name)) 
[10:32:59.031]                               next
[10:32:59.031]                             if (!grepl(pattern, name)) 
[10:32:59.031]                               next
[10:32:59.031]                             invokeRestart(restart)
[10:32:59.031]                             muffled <- TRUE
[10:32:59.031]                             break
[10:32:59.031]                           }
[10:32:59.031]                         }
[10:32:59.031]                       }
[10:32:59.031]                       invisible(muffled)
[10:32:59.031]                     }
[10:32:59.031]                     muffleCondition(cond, pattern = "^muffle")
[10:32:59.031]                   }
[10:32:59.031]                 }
[10:32:59.031]                 else {
[10:32:59.031]                   if (TRUE) {
[10:32:59.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:59.031]                     {
[10:32:59.031]                       inherits <- base::inherits
[10:32:59.031]                       invokeRestart <- base::invokeRestart
[10:32:59.031]                       is.null <- base::is.null
[10:32:59.031]                       muffled <- FALSE
[10:32:59.031]                       if (inherits(cond, "message")) {
[10:32:59.031]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:59.031]                         if (muffled) 
[10:32:59.031]                           invokeRestart("muffleMessage")
[10:32:59.031]                       }
[10:32:59.031]                       else if (inherits(cond, "warning")) {
[10:32:59.031]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:59.031]                         if (muffled) 
[10:32:59.031]                           invokeRestart("muffleWarning")
[10:32:59.031]                       }
[10:32:59.031]                       else if (inherits(cond, "condition")) {
[10:32:59.031]                         if (!is.null(pattern)) {
[10:32:59.031]                           computeRestarts <- base::computeRestarts
[10:32:59.031]                           grepl <- base::grepl
[10:32:59.031]                           restarts <- computeRestarts(cond)
[10:32:59.031]                           for (restart in restarts) {
[10:32:59.031]                             name <- restart$name
[10:32:59.031]                             if (is.null(name)) 
[10:32:59.031]                               next
[10:32:59.031]                             if (!grepl(pattern, name)) 
[10:32:59.031]                               next
[10:32:59.031]                             invokeRestart(restart)
[10:32:59.031]                             muffled <- TRUE
[10:32:59.031]                             break
[10:32:59.031]                           }
[10:32:59.031]                         }
[10:32:59.031]                       }
[10:32:59.031]                       invisible(muffled)
[10:32:59.031]                     }
[10:32:59.031]                     muffleCondition(cond, pattern = "^muffle")
[10:32:59.031]                   }
[10:32:59.031]                 }
[10:32:59.031]             }
[10:32:59.031]         }))
[10:32:59.031]     }, error = function(ex) {
[10:32:59.031]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:59.031]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:59.031]                 ...future.rng), started = ...future.startTime, 
[10:32:59.031]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:59.031]             version = "1.8"), class = "FutureResult")
[10:32:59.031]     }, finally = {
[10:32:59.031]         if (!identical(...future.workdir, getwd())) 
[10:32:59.031]             setwd(...future.workdir)
[10:32:59.031]         {
[10:32:59.031]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:59.031]                 ...future.oldOptions$nwarnings <- NULL
[10:32:59.031]             }
[10:32:59.031]             base::options(...future.oldOptions)
[10:32:59.031]             if (.Platform$OS.type == "windows") {
[10:32:59.031]                 old_names <- names(...future.oldEnvVars)
[10:32:59.031]                 envs <- base::Sys.getenv()
[10:32:59.031]                 names <- names(envs)
[10:32:59.031]                 common <- intersect(names, old_names)
[10:32:59.031]                 added <- setdiff(names, old_names)
[10:32:59.031]                 removed <- setdiff(old_names, names)
[10:32:59.031]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:59.031]                   envs[common]]
[10:32:59.031]                 NAMES <- toupper(changed)
[10:32:59.031]                 args <- list()
[10:32:59.031]                 for (kk in seq_along(NAMES)) {
[10:32:59.031]                   name <- changed[[kk]]
[10:32:59.031]                   NAME <- NAMES[[kk]]
[10:32:59.031]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:59.031]                     next
[10:32:59.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:59.031]                 }
[10:32:59.031]                 NAMES <- toupper(added)
[10:32:59.031]                 for (kk in seq_along(NAMES)) {
[10:32:59.031]                   name <- added[[kk]]
[10:32:59.031]                   NAME <- NAMES[[kk]]
[10:32:59.031]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:59.031]                     next
[10:32:59.031]                   args[[name]] <- ""
[10:32:59.031]                 }
[10:32:59.031]                 NAMES <- toupper(removed)
[10:32:59.031]                 for (kk in seq_along(NAMES)) {
[10:32:59.031]                   name <- removed[[kk]]
[10:32:59.031]                   NAME <- NAMES[[kk]]
[10:32:59.031]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:59.031]                     next
[10:32:59.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:59.031]                 }
[10:32:59.031]                 if (length(args) > 0) 
[10:32:59.031]                   base::do.call(base::Sys.setenv, args = args)
[10:32:59.031]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:59.031]             }
[10:32:59.031]             else {
[10:32:59.031]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:59.031]             }
[10:32:59.031]             {
[10:32:59.031]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:59.031]                   0L) {
[10:32:59.031]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:59.031]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:59.031]                   base::options(opts)
[10:32:59.031]                 }
[10:32:59.031]                 {
[10:32:59.031]                   {
[10:32:59.031]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:59.031]                     NULL
[10:32:59.031]                   }
[10:32:59.031]                   options(future.plan = NULL)
[10:32:59.031]                   if (is.na(NA_character_)) 
[10:32:59.031]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:59.031]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:59.031]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:59.031]                     .init = FALSE)
[10:32:59.031]                 }
[10:32:59.031]             }
[10:32:59.031]         }
[10:32:59.031]     })
[10:32:59.031]     if (TRUE) {
[10:32:59.031]         base::sink(type = "output", split = FALSE)
[10:32:59.031]         if (TRUE) {
[10:32:59.031]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:59.031]         }
[10:32:59.031]         else {
[10:32:59.031]             ...future.result["stdout"] <- base::list(NULL)
[10:32:59.031]         }
[10:32:59.031]         base::close(...future.stdout)
[10:32:59.031]         ...future.stdout <- NULL
[10:32:59.031]     }
[10:32:59.031]     ...future.result$conditions <- ...future.conditions
[10:32:59.031]     ...future.result$finished <- base::Sys.time()
[10:32:59.031]     ...future.result
[10:32:59.031] }
[10:32:59.034] MultisessionFuture started
[10:32:59.034] - Launch lazy future ... done
[10:32:59.034] run() for ‘MultisessionFuture’ ... done
[10:32:59.034] result() for ClusterFuture ...
[10:32:59.034] receiveMessageFromWorker() for ClusterFuture ...
[10:32:59.034] - Validating connection of MultisessionFuture
[10:32:59.036] - received message: FutureResult
[10:32:59.036] - Received FutureResult
[10:32:59.037] - Erased future from FutureRegistry
[10:32:59.037] result() for ClusterFuture ...
[10:32:59.037] - result already collected: FutureResult
[10:32:59.037] result() for ClusterFuture ... done
[10:32:59.037] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:59.037] result() for ClusterFuture ... done
[10:32:59.037] result() for ClusterFuture ...
[10:32:59.037] - result already collected: FutureResult
[10:32:59.037] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[10:32:59.040] getGlobalsAndPackages() ...
[10:32:59.040] Searching for globals...
[10:32:59.041] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[10:32:59.042] Searching for globals ... DONE
[10:32:59.042] Resolving globals: FALSE
[10:32:59.042] 
[10:32:59.042] - packages: [2] ‘stats’, ‘datasets’
[10:32:59.042] getGlobalsAndPackages() ... DONE
[10:32:59.043] run() for ‘Future’ ...
[10:32:59.043] - state: ‘created’
[10:32:59.043] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:59.056] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:59.057] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:59.057]   - Field: ‘node’
[10:32:59.057]   - Field: ‘label’
[10:32:59.057]   - Field: ‘local’
[10:32:59.057]   - Field: ‘owner’
[10:32:59.057]   - Field: ‘envir’
[10:32:59.057]   - Field: ‘workers’
[10:32:59.057]   - Field: ‘packages’
[10:32:59.057]   - Field: ‘gc’
[10:32:59.057]   - Field: ‘conditions’
[10:32:59.058]   - Field: ‘persistent’
[10:32:59.058]   - Field: ‘expr’
[10:32:59.058]   - Field: ‘uuid’
[10:32:59.058]   - Field: ‘seed’
[10:32:59.058]   - Field: ‘version’
[10:32:59.058]   - Field: ‘result’
[10:32:59.058]   - Field: ‘asynchronous’
[10:32:59.058]   - Field: ‘calls’
[10:32:59.058]   - Field: ‘globals’
[10:32:59.058]   - Field: ‘stdout’
[10:32:59.058]   - Field: ‘earlySignal’
[10:32:59.058]   - Field: ‘lazy’
[10:32:59.059]   - Field: ‘state’
[10:32:59.059] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:59.059] - Launch lazy future ...
[10:32:59.059] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:32:59.059] Packages needed by future strategies (n = 0): <none>
[10:32:59.060] {
[10:32:59.060]     {
[10:32:59.060]         {
[10:32:59.060]             ...future.startTime <- base::Sys.time()
[10:32:59.060]             {
[10:32:59.060]                 {
[10:32:59.060]                   {
[10:32:59.060]                     {
[10:32:59.060]                       {
[10:32:59.060]                         base::local({
[10:32:59.060]                           has_future <- base::requireNamespace("future", 
[10:32:59.060]                             quietly = TRUE)
[10:32:59.060]                           if (has_future) {
[10:32:59.060]                             ns <- base::getNamespace("future")
[10:32:59.060]                             version <- ns[[".package"]][["version"]]
[10:32:59.060]                             if (is.null(version)) 
[10:32:59.060]                               version <- utils::packageVersion("future")
[10:32:59.060]                           }
[10:32:59.060]                           else {
[10:32:59.060]                             version <- NULL
[10:32:59.060]                           }
[10:32:59.060]                           if (!has_future || version < "1.8.0") {
[10:32:59.060]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:59.060]                               "", base::R.version$version.string), 
[10:32:59.060]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:59.060]                                 base::R.version$platform, 8 * 
[10:32:59.060]                                   base::.Machine$sizeof.pointer), 
[10:32:59.060]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:59.060]                                 "release", "version")], collapse = " "), 
[10:32:59.060]                               hostname = base::Sys.info()[["nodename"]])
[10:32:59.060]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:59.060]                               info)
[10:32:59.060]                             info <- base::paste(info, collapse = "; ")
[10:32:59.060]                             if (!has_future) {
[10:32:59.060]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:59.060]                                 info)
[10:32:59.060]                             }
[10:32:59.060]                             else {
[10:32:59.060]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:59.060]                                 info, version)
[10:32:59.060]                             }
[10:32:59.060]                             base::stop(msg)
[10:32:59.060]                           }
[10:32:59.060]                         })
[10:32:59.060]                       }
[10:32:59.060]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:59.060]                       base::options(mc.cores = 1L)
[10:32:59.060]                     }
[10:32:59.060]                     base::local({
[10:32:59.060]                       for (pkg in c("stats", "datasets")) {
[10:32:59.060]                         base::loadNamespace(pkg)
[10:32:59.060]                         base::library(pkg, character.only = TRUE)
[10:32:59.060]                       }
[10:32:59.060]                     })
[10:32:59.060]                   }
[10:32:59.060]                   ...future.strategy.old <- future::plan("list")
[10:32:59.060]                   options(future.plan = NULL)
[10:32:59.060]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:59.060]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:59.060]                 }
[10:32:59.060]                 ...future.workdir <- getwd()
[10:32:59.060]             }
[10:32:59.060]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:59.060]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:59.060]         }
[10:32:59.060]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:59.060]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:59.060]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:59.060]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:59.060]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:59.060]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:59.060]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:59.060]             base::names(...future.oldOptions))
[10:32:59.060]     }
[10:32:59.060]     if (FALSE) {
[10:32:59.060]     }
[10:32:59.060]     else {
[10:32:59.060]         if (TRUE) {
[10:32:59.060]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:59.060]                 open = "w")
[10:32:59.060]         }
[10:32:59.060]         else {
[10:32:59.060]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:59.060]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:59.060]         }
[10:32:59.060]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:59.060]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:59.060]             base::sink(type = "output", split = FALSE)
[10:32:59.060]             base::close(...future.stdout)
[10:32:59.060]         }, add = TRUE)
[10:32:59.060]     }
[10:32:59.060]     ...future.frame <- base::sys.nframe()
[10:32:59.060]     ...future.conditions <- base::list()
[10:32:59.060]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:59.060]     if (FALSE) {
[10:32:59.060]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:59.060]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:59.060]     }
[10:32:59.060]     ...future.result <- base::tryCatch({
[10:32:59.060]         base::withCallingHandlers({
[10:32:59.060]             ...future.value <- base::withVisible(base::local({
[10:32:59.060]                 ...future.makeSendCondition <- base::local({
[10:32:59.060]                   sendCondition <- NULL
[10:32:59.060]                   function(frame = 1L) {
[10:32:59.060]                     if (is.function(sendCondition)) 
[10:32:59.060]                       return(sendCondition)
[10:32:59.060]                     ns <- getNamespace("parallel")
[10:32:59.060]                     if (exists("sendData", mode = "function", 
[10:32:59.060]                       envir = ns)) {
[10:32:59.060]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:59.060]                         envir = ns)
[10:32:59.060]                       envir <- sys.frame(frame)
[10:32:59.060]                       master <- NULL
[10:32:59.060]                       while (!identical(envir, .GlobalEnv) && 
[10:32:59.060]                         !identical(envir, emptyenv())) {
[10:32:59.060]                         if (exists("master", mode = "list", envir = envir, 
[10:32:59.060]                           inherits = FALSE)) {
[10:32:59.060]                           master <- get("master", mode = "list", 
[10:32:59.060]                             envir = envir, inherits = FALSE)
[10:32:59.060]                           if (inherits(master, c("SOCKnode", 
[10:32:59.060]                             "SOCK0node"))) {
[10:32:59.060]                             sendCondition <<- function(cond) {
[10:32:59.060]                               data <- list(type = "VALUE", value = cond, 
[10:32:59.060]                                 success = TRUE)
[10:32:59.060]                               parallel_sendData(master, data)
[10:32:59.060]                             }
[10:32:59.060]                             return(sendCondition)
[10:32:59.060]                           }
[10:32:59.060]                         }
[10:32:59.060]                         frame <- frame + 1L
[10:32:59.060]                         envir <- sys.frame(frame)
[10:32:59.060]                       }
[10:32:59.060]                     }
[10:32:59.060]                     sendCondition <<- function(cond) NULL
[10:32:59.060]                   }
[10:32:59.060]                 })
[10:32:59.060]                 withCallingHandlers({
[10:32:59.060]                   {
[10:32:59.060]                     lm(dist ~ poly(speed, 2), data = cars)
[10:32:59.060]                   }
[10:32:59.060]                 }, immediateCondition = function(cond) {
[10:32:59.060]                   sendCondition <- ...future.makeSendCondition()
[10:32:59.060]                   sendCondition(cond)
[10:32:59.060]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:59.060]                   {
[10:32:59.060]                     inherits <- base::inherits
[10:32:59.060]                     invokeRestart <- base::invokeRestart
[10:32:59.060]                     is.null <- base::is.null
[10:32:59.060]                     muffled <- FALSE
[10:32:59.060]                     if (inherits(cond, "message")) {
[10:32:59.060]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:59.060]                       if (muffled) 
[10:32:59.060]                         invokeRestart("muffleMessage")
[10:32:59.060]                     }
[10:32:59.060]                     else if (inherits(cond, "warning")) {
[10:32:59.060]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:59.060]                       if (muffled) 
[10:32:59.060]                         invokeRestart("muffleWarning")
[10:32:59.060]                     }
[10:32:59.060]                     else if (inherits(cond, "condition")) {
[10:32:59.060]                       if (!is.null(pattern)) {
[10:32:59.060]                         computeRestarts <- base::computeRestarts
[10:32:59.060]                         grepl <- base::grepl
[10:32:59.060]                         restarts <- computeRestarts(cond)
[10:32:59.060]                         for (restart in restarts) {
[10:32:59.060]                           name <- restart$name
[10:32:59.060]                           if (is.null(name)) 
[10:32:59.060]                             next
[10:32:59.060]                           if (!grepl(pattern, name)) 
[10:32:59.060]                             next
[10:32:59.060]                           invokeRestart(restart)
[10:32:59.060]                           muffled <- TRUE
[10:32:59.060]                           break
[10:32:59.060]                         }
[10:32:59.060]                       }
[10:32:59.060]                     }
[10:32:59.060]                     invisible(muffled)
[10:32:59.060]                   }
[10:32:59.060]                   muffleCondition(cond)
[10:32:59.060]                 })
[10:32:59.060]             }))
[10:32:59.060]             future::FutureResult(value = ...future.value$value, 
[10:32:59.060]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:59.060]                   ...future.rng), globalenv = if (FALSE) 
[10:32:59.060]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:59.060]                     ...future.globalenv.names))
[10:32:59.060]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:59.060]         }, condition = base::local({
[10:32:59.060]             c <- base::c
[10:32:59.060]             inherits <- base::inherits
[10:32:59.060]             invokeRestart <- base::invokeRestart
[10:32:59.060]             length <- base::length
[10:32:59.060]             list <- base::list
[10:32:59.060]             seq.int <- base::seq.int
[10:32:59.060]             signalCondition <- base::signalCondition
[10:32:59.060]             sys.calls <- base::sys.calls
[10:32:59.060]             `[[` <- base::`[[`
[10:32:59.060]             `+` <- base::`+`
[10:32:59.060]             `<<-` <- base::`<<-`
[10:32:59.060]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:59.060]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:59.060]                   3L)]
[10:32:59.060]             }
[10:32:59.060]             function(cond) {
[10:32:59.060]                 is_error <- inherits(cond, "error")
[10:32:59.060]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:59.060]                   NULL)
[10:32:59.060]                 if (is_error) {
[10:32:59.060]                   sessionInformation <- function() {
[10:32:59.060]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:59.060]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:59.060]                       search = base::search(), system = base::Sys.info())
[10:32:59.060]                   }
[10:32:59.060]                   ...future.conditions[[length(...future.conditions) + 
[10:32:59.060]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:59.060]                     cond$call), session = sessionInformation(), 
[10:32:59.060]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:59.060]                   signalCondition(cond)
[10:32:59.060]                 }
[10:32:59.060]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:59.060]                 "immediateCondition"))) {
[10:32:59.060]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:59.060]                   ...future.conditions[[length(...future.conditions) + 
[10:32:59.060]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:59.060]                   if (TRUE && !signal) {
[10:32:59.060]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:59.060]                     {
[10:32:59.060]                       inherits <- base::inherits
[10:32:59.060]                       invokeRestart <- base::invokeRestart
[10:32:59.060]                       is.null <- base::is.null
[10:32:59.060]                       muffled <- FALSE
[10:32:59.060]                       if (inherits(cond, "message")) {
[10:32:59.060]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:59.060]                         if (muffled) 
[10:32:59.060]                           invokeRestart("muffleMessage")
[10:32:59.060]                       }
[10:32:59.060]                       else if (inherits(cond, "warning")) {
[10:32:59.060]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:59.060]                         if (muffled) 
[10:32:59.060]                           invokeRestart("muffleWarning")
[10:32:59.060]                       }
[10:32:59.060]                       else if (inherits(cond, "condition")) {
[10:32:59.060]                         if (!is.null(pattern)) {
[10:32:59.060]                           computeRestarts <- base::computeRestarts
[10:32:59.060]                           grepl <- base::grepl
[10:32:59.060]                           restarts <- computeRestarts(cond)
[10:32:59.060]                           for (restart in restarts) {
[10:32:59.060]                             name <- restart$name
[10:32:59.060]                             if (is.null(name)) 
[10:32:59.060]                               next
[10:32:59.060]                             if (!grepl(pattern, name)) 
[10:32:59.060]                               next
[10:32:59.060]                             invokeRestart(restart)
[10:32:59.060]                             muffled <- TRUE
[10:32:59.060]                             break
[10:32:59.060]                           }
[10:32:59.060]                         }
[10:32:59.060]                       }
[10:32:59.060]                       invisible(muffled)
[10:32:59.060]                     }
[10:32:59.060]                     muffleCondition(cond, pattern = "^muffle")
[10:32:59.060]                   }
[10:32:59.060]                 }
[10:32:59.060]                 else {
[10:32:59.060]                   if (TRUE) {
[10:32:59.060]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:59.060]                     {
[10:32:59.060]                       inherits <- base::inherits
[10:32:59.060]                       invokeRestart <- base::invokeRestart
[10:32:59.060]                       is.null <- base::is.null
[10:32:59.060]                       muffled <- FALSE
[10:32:59.060]                       if (inherits(cond, "message")) {
[10:32:59.060]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:59.060]                         if (muffled) 
[10:32:59.060]                           invokeRestart("muffleMessage")
[10:32:59.060]                       }
[10:32:59.060]                       else if (inherits(cond, "warning")) {
[10:32:59.060]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:59.060]                         if (muffled) 
[10:32:59.060]                           invokeRestart("muffleWarning")
[10:32:59.060]                       }
[10:32:59.060]                       else if (inherits(cond, "condition")) {
[10:32:59.060]                         if (!is.null(pattern)) {
[10:32:59.060]                           computeRestarts <- base::computeRestarts
[10:32:59.060]                           grepl <- base::grepl
[10:32:59.060]                           restarts <- computeRestarts(cond)
[10:32:59.060]                           for (restart in restarts) {
[10:32:59.060]                             name <- restart$name
[10:32:59.060]                             if (is.null(name)) 
[10:32:59.060]                               next
[10:32:59.060]                             if (!grepl(pattern, name)) 
[10:32:59.060]                               next
[10:32:59.060]                             invokeRestart(restart)
[10:32:59.060]                             muffled <- TRUE
[10:32:59.060]                             break
[10:32:59.060]                           }
[10:32:59.060]                         }
[10:32:59.060]                       }
[10:32:59.060]                       invisible(muffled)
[10:32:59.060]                     }
[10:32:59.060]                     muffleCondition(cond, pattern = "^muffle")
[10:32:59.060]                   }
[10:32:59.060]                 }
[10:32:59.060]             }
[10:32:59.060]         }))
[10:32:59.060]     }, error = function(ex) {
[10:32:59.060]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:59.060]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:59.060]                 ...future.rng), started = ...future.startTime, 
[10:32:59.060]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:59.060]             version = "1.8"), class = "FutureResult")
[10:32:59.060]     }, finally = {
[10:32:59.060]         if (!identical(...future.workdir, getwd())) 
[10:32:59.060]             setwd(...future.workdir)
[10:32:59.060]         {
[10:32:59.060]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:59.060]                 ...future.oldOptions$nwarnings <- NULL
[10:32:59.060]             }
[10:32:59.060]             base::options(...future.oldOptions)
[10:32:59.060]             if (.Platform$OS.type == "windows") {
[10:32:59.060]                 old_names <- names(...future.oldEnvVars)
[10:32:59.060]                 envs <- base::Sys.getenv()
[10:32:59.060]                 names <- names(envs)
[10:32:59.060]                 common <- intersect(names, old_names)
[10:32:59.060]                 added <- setdiff(names, old_names)
[10:32:59.060]                 removed <- setdiff(old_names, names)
[10:32:59.060]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:59.060]                   envs[common]]
[10:32:59.060]                 NAMES <- toupper(changed)
[10:32:59.060]                 args <- list()
[10:32:59.060]                 for (kk in seq_along(NAMES)) {
[10:32:59.060]                   name <- changed[[kk]]
[10:32:59.060]                   NAME <- NAMES[[kk]]
[10:32:59.060]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:59.060]                     next
[10:32:59.060]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:59.060]                 }
[10:32:59.060]                 NAMES <- toupper(added)
[10:32:59.060]                 for (kk in seq_along(NAMES)) {
[10:32:59.060]                   name <- added[[kk]]
[10:32:59.060]                   NAME <- NAMES[[kk]]
[10:32:59.060]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:59.060]                     next
[10:32:59.060]                   args[[name]] <- ""
[10:32:59.060]                 }
[10:32:59.060]                 NAMES <- toupper(removed)
[10:32:59.060]                 for (kk in seq_along(NAMES)) {
[10:32:59.060]                   name <- removed[[kk]]
[10:32:59.060]                   NAME <- NAMES[[kk]]
[10:32:59.060]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:59.060]                     next
[10:32:59.060]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:59.060]                 }
[10:32:59.060]                 if (length(args) > 0) 
[10:32:59.060]                   base::do.call(base::Sys.setenv, args = args)
[10:32:59.060]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:59.060]             }
[10:32:59.060]             else {
[10:32:59.060]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:59.060]             }
[10:32:59.060]             {
[10:32:59.060]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:59.060]                   0L) {
[10:32:59.060]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:59.060]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:59.060]                   base::options(opts)
[10:32:59.060]                 }
[10:32:59.060]                 {
[10:32:59.060]                   {
[10:32:59.060]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:59.060]                     NULL
[10:32:59.060]                   }
[10:32:59.060]                   options(future.plan = NULL)
[10:32:59.060]                   if (is.na(NA_character_)) 
[10:32:59.060]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:59.060]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:59.060]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:59.060]                     .init = FALSE)
[10:32:59.060]                 }
[10:32:59.060]             }
[10:32:59.060]         }
[10:32:59.060]     })
[10:32:59.060]     if (TRUE) {
[10:32:59.060]         base::sink(type = "output", split = FALSE)
[10:32:59.060]         if (TRUE) {
[10:32:59.060]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:59.060]         }
[10:32:59.060]         else {
[10:32:59.060]             ...future.result["stdout"] <- base::list(NULL)
[10:32:59.060]         }
[10:32:59.060]         base::close(...future.stdout)
[10:32:59.060]         ...future.stdout <- NULL
[10:32:59.060]     }
[10:32:59.060]     ...future.result$conditions <- ...future.conditions
[10:32:59.060]     ...future.result$finished <- base::Sys.time()
[10:32:59.060]     ...future.result
[10:32:59.060] }
[10:32:59.062] MultisessionFuture started
[10:32:59.062] - Launch lazy future ... done
[10:32:59.063] run() for ‘MultisessionFuture’ ... done
[10:32:59.063] result() for ClusterFuture ...
[10:32:59.063] receiveMessageFromWorker() for ClusterFuture ...
[10:32:59.063] - Validating connection of MultisessionFuture
[10:32:59.108] - received message: FutureResult
[10:32:59.109] - Received FutureResult
[10:32:59.109] - Erased future from FutureRegistry
[10:32:59.109] result() for ClusterFuture ...
[10:32:59.109] - result already collected: FutureResult
[10:32:59.109] result() for ClusterFuture ... done
[10:32:59.109] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:59.109] result() for ClusterFuture ... done
[10:32:59.109] result() for ClusterFuture ...
[10:32:59.109] - result already collected: FutureResult
[10:32:59.109] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[10:32:59.111] getGlobalsAndPackages() ...
[10:32:59.111] Searching for globals...
[10:32:59.115] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[10:32:59.116] Searching for globals ... DONE
[10:32:59.116] Resolving globals: FALSE
[10:32:59.116] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[10:32:59.117] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[10:32:59.117] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[10:32:59.117] 
[10:32:59.117] getGlobalsAndPackages() ... DONE
[10:32:59.117] run() for ‘Future’ ...
[10:32:59.118] - state: ‘created’
[10:32:59.118] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:59.131] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:59.131] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:59.132]   - Field: ‘node’
[10:32:59.132]   - Field: ‘label’
[10:32:59.132]   - Field: ‘local’
[10:32:59.132]   - Field: ‘owner’
[10:32:59.132]   - Field: ‘envir’
[10:32:59.132]   - Field: ‘workers’
[10:32:59.132]   - Field: ‘packages’
[10:32:59.132]   - Field: ‘gc’
[10:32:59.132]   - Field: ‘conditions’
[10:32:59.132]   - Field: ‘persistent’
[10:32:59.133]   - Field: ‘expr’
[10:32:59.133]   - Field: ‘uuid’
[10:32:59.133]   - Field: ‘seed’
[10:32:59.133]   - Field: ‘version’
[10:32:59.135]   - Field: ‘result’
[10:32:59.135]   - Field: ‘asynchronous’
[10:32:59.135]   - Field: ‘calls’
[10:32:59.135]   - Field: ‘globals’
[10:32:59.135]   - Field: ‘stdout’
[10:32:59.135]   - Field: ‘earlySignal’
[10:32:59.135]   - Field: ‘lazy’
[10:32:59.135]   - Field: ‘state’
[10:32:59.136] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:59.136] - Launch lazy future ...
[10:32:59.136] Packages needed by the future expression (n = 0): <none>
[10:32:59.136] Packages needed by future strategies (n = 0): <none>
[10:32:59.136] {
[10:32:59.136]     {
[10:32:59.136]         {
[10:32:59.136]             ...future.startTime <- base::Sys.time()
[10:32:59.136]             {
[10:32:59.136]                 {
[10:32:59.136]                   {
[10:32:59.136]                     {
[10:32:59.136]                       base::local({
[10:32:59.136]                         has_future <- base::requireNamespace("future", 
[10:32:59.136]                           quietly = TRUE)
[10:32:59.136]                         if (has_future) {
[10:32:59.136]                           ns <- base::getNamespace("future")
[10:32:59.136]                           version <- ns[[".package"]][["version"]]
[10:32:59.136]                           if (is.null(version)) 
[10:32:59.136]                             version <- utils::packageVersion("future")
[10:32:59.136]                         }
[10:32:59.136]                         else {
[10:32:59.136]                           version <- NULL
[10:32:59.136]                         }
[10:32:59.136]                         if (!has_future || version < "1.8.0") {
[10:32:59.136]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:59.136]                             "", base::R.version$version.string), 
[10:32:59.136]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:59.136]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:59.136]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:59.136]                               "release", "version")], collapse = " "), 
[10:32:59.136]                             hostname = base::Sys.info()[["nodename"]])
[10:32:59.136]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:59.136]                             info)
[10:32:59.136]                           info <- base::paste(info, collapse = "; ")
[10:32:59.136]                           if (!has_future) {
[10:32:59.136]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:59.136]                               info)
[10:32:59.136]                           }
[10:32:59.136]                           else {
[10:32:59.136]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:59.136]                               info, version)
[10:32:59.136]                           }
[10:32:59.136]                           base::stop(msg)
[10:32:59.136]                         }
[10:32:59.136]                       })
[10:32:59.136]                     }
[10:32:59.136]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:59.136]                     base::options(mc.cores = 1L)
[10:32:59.136]                   }
[10:32:59.136]                   ...future.strategy.old <- future::plan("list")
[10:32:59.136]                   options(future.plan = NULL)
[10:32:59.136]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:59.136]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:59.136]                 }
[10:32:59.136]                 ...future.workdir <- getwd()
[10:32:59.136]             }
[10:32:59.136]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:59.136]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:59.136]         }
[10:32:59.136]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:59.136]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:59.136]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:59.136]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:59.136]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:59.136]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:59.136]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:59.136]             base::names(...future.oldOptions))
[10:32:59.136]     }
[10:32:59.136]     if (FALSE) {
[10:32:59.136]     }
[10:32:59.136]     else {
[10:32:59.136]         if (TRUE) {
[10:32:59.136]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:59.136]                 open = "w")
[10:32:59.136]         }
[10:32:59.136]         else {
[10:32:59.136]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:59.136]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:59.136]         }
[10:32:59.136]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:59.136]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:59.136]             base::sink(type = "output", split = FALSE)
[10:32:59.136]             base::close(...future.stdout)
[10:32:59.136]         }, add = TRUE)
[10:32:59.136]     }
[10:32:59.136]     ...future.frame <- base::sys.nframe()
[10:32:59.136]     ...future.conditions <- base::list()
[10:32:59.136]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:59.136]     if (FALSE) {
[10:32:59.136]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:59.136]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:59.136]     }
[10:32:59.136]     ...future.result <- base::tryCatch({
[10:32:59.136]         base::withCallingHandlers({
[10:32:59.136]             ...future.value <- base::withVisible(base::local({
[10:32:59.136]                 ...future.makeSendCondition <- base::local({
[10:32:59.136]                   sendCondition <- NULL
[10:32:59.136]                   function(frame = 1L) {
[10:32:59.136]                     if (is.function(sendCondition)) 
[10:32:59.136]                       return(sendCondition)
[10:32:59.136]                     ns <- getNamespace("parallel")
[10:32:59.136]                     if (exists("sendData", mode = "function", 
[10:32:59.136]                       envir = ns)) {
[10:32:59.136]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:59.136]                         envir = ns)
[10:32:59.136]                       envir <- sys.frame(frame)
[10:32:59.136]                       master <- NULL
[10:32:59.136]                       while (!identical(envir, .GlobalEnv) && 
[10:32:59.136]                         !identical(envir, emptyenv())) {
[10:32:59.136]                         if (exists("master", mode = "list", envir = envir, 
[10:32:59.136]                           inherits = FALSE)) {
[10:32:59.136]                           master <- get("master", mode = "list", 
[10:32:59.136]                             envir = envir, inherits = FALSE)
[10:32:59.136]                           if (inherits(master, c("SOCKnode", 
[10:32:59.136]                             "SOCK0node"))) {
[10:32:59.136]                             sendCondition <<- function(cond) {
[10:32:59.136]                               data <- list(type = "VALUE", value = cond, 
[10:32:59.136]                                 success = TRUE)
[10:32:59.136]                               parallel_sendData(master, data)
[10:32:59.136]                             }
[10:32:59.136]                             return(sendCondition)
[10:32:59.136]                           }
[10:32:59.136]                         }
[10:32:59.136]                         frame <- frame + 1L
[10:32:59.136]                         envir <- sys.frame(frame)
[10:32:59.136]                       }
[10:32:59.136]                     }
[10:32:59.136]                     sendCondition <<- function(cond) NULL
[10:32:59.136]                   }
[10:32:59.136]                 })
[10:32:59.136]                 withCallingHandlers({
[10:32:59.136]                   {
[10:32:59.136]                     outer_function(1L)
[10:32:59.136]                   }
[10:32:59.136]                 }, immediateCondition = function(cond) {
[10:32:59.136]                   sendCondition <- ...future.makeSendCondition()
[10:32:59.136]                   sendCondition(cond)
[10:32:59.136]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:59.136]                   {
[10:32:59.136]                     inherits <- base::inherits
[10:32:59.136]                     invokeRestart <- base::invokeRestart
[10:32:59.136]                     is.null <- base::is.null
[10:32:59.136]                     muffled <- FALSE
[10:32:59.136]                     if (inherits(cond, "message")) {
[10:32:59.136]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:59.136]                       if (muffled) 
[10:32:59.136]                         invokeRestart("muffleMessage")
[10:32:59.136]                     }
[10:32:59.136]                     else if (inherits(cond, "warning")) {
[10:32:59.136]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:59.136]                       if (muffled) 
[10:32:59.136]                         invokeRestart("muffleWarning")
[10:32:59.136]                     }
[10:32:59.136]                     else if (inherits(cond, "condition")) {
[10:32:59.136]                       if (!is.null(pattern)) {
[10:32:59.136]                         computeRestarts <- base::computeRestarts
[10:32:59.136]                         grepl <- base::grepl
[10:32:59.136]                         restarts <- computeRestarts(cond)
[10:32:59.136]                         for (restart in restarts) {
[10:32:59.136]                           name <- restart$name
[10:32:59.136]                           if (is.null(name)) 
[10:32:59.136]                             next
[10:32:59.136]                           if (!grepl(pattern, name)) 
[10:32:59.136]                             next
[10:32:59.136]                           invokeRestart(restart)
[10:32:59.136]                           muffled <- TRUE
[10:32:59.136]                           break
[10:32:59.136]                         }
[10:32:59.136]                       }
[10:32:59.136]                     }
[10:32:59.136]                     invisible(muffled)
[10:32:59.136]                   }
[10:32:59.136]                   muffleCondition(cond)
[10:32:59.136]                 })
[10:32:59.136]             }))
[10:32:59.136]             future::FutureResult(value = ...future.value$value, 
[10:32:59.136]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:59.136]                   ...future.rng), globalenv = if (FALSE) 
[10:32:59.136]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:59.136]                     ...future.globalenv.names))
[10:32:59.136]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:59.136]         }, condition = base::local({
[10:32:59.136]             c <- base::c
[10:32:59.136]             inherits <- base::inherits
[10:32:59.136]             invokeRestart <- base::invokeRestart
[10:32:59.136]             length <- base::length
[10:32:59.136]             list <- base::list
[10:32:59.136]             seq.int <- base::seq.int
[10:32:59.136]             signalCondition <- base::signalCondition
[10:32:59.136]             sys.calls <- base::sys.calls
[10:32:59.136]             `[[` <- base::`[[`
[10:32:59.136]             `+` <- base::`+`
[10:32:59.136]             `<<-` <- base::`<<-`
[10:32:59.136]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:59.136]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:59.136]                   3L)]
[10:32:59.136]             }
[10:32:59.136]             function(cond) {
[10:32:59.136]                 is_error <- inherits(cond, "error")
[10:32:59.136]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:59.136]                   NULL)
[10:32:59.136]                 if (is_error) {
[10:32:59.136]                   sessionInformation <- function() {
[10:32:59.136]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:59.136]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:59.136]                       search = base::search(), system = base::Sys.info())
[10:32:59.136]                   }
[10:32:59.136]                   ...future.conditions[[length(...future.conditions) + 
[10:32:59.136]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:59.136]                     cond$call), session = sessionInformation(), 
[10:32:59.136]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:59.136]                   signalCondition(cond)
[10:32:59.136]                 }
[10:32:59.136]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:59.136]                 "immediateCondition"))) {
[10:32:59.136]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:59.136]                   ...future.conditions[[length(...future.conditions) + 
[10:32:59.136]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:59.136]                   if (TRUE && !signal) {
[10:32:59.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:59.136]                     {
[10:32:59.136]                       inherits <- base::inherits
[10:32:59.136]                       invokeRestart <- base::invokeRestart
[10:32:59.136]                       is.null <- base::is.null
[10:32:59.136]                       muffled <- FALSE
[10:32:59.136]                       if (inherits(cond, "message")) {
[10:32:59.136]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:59.136]                         if (muffled) 
[10:32:59.136]                           invokeRestart("muffleMessage")
[10:32:59.136]                       }
[10:32:59.136]                       else if (inherits(cond, "warning")) {
[10:32:59.136]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:59.136]                         if (muffled) 
[10:32:59.136]                           invokeRestart("muffleWarning")
[10:32:59.136]                       }
[10:32:59.136]                       else if (inherits(cond, "condition")) {
[10:32:59.136]                         if (!is.null(pattern)) {
[10:32:59.136]                           computeRestarts <- base::computeRestarts
[10:32:59.136]                           grepl <- base::grepl
[10:32:59.136]                           restarts <- computeRestarts(cond)
[10:32:59.136]                           for (restart in restarts) {
[10:32:59.136]                             name <- restart$name
[10:32:59.136]                             if (is.null(name)) 
[10:32:59.136]                               next
[10:32:59.136]                             if (!grepl(pattern, name)) 
[10:32:59.136]                               next
[10:32:59.136]                             invokeRestart(restart)
[10:32:59.136]                             muffled <- TRUE
[10:32:59.136]                             break
[10:32:59.136]                           }
[10:32:59.136]                         }
[10:32:59.136]                       }
[10:32:59.136]                       invisible(muffled)
[10:32:59.136]                     }
[10:32:59.136]                     muffleCondition(cond, pattern = "^muffle")
[10:32:59.136]                   }
[10:32:59.136]                 }
[10:32:59.136]                 else {
[10:32:59.136]                   if (TRUE) {
[10:32:59.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:59.136]                     {
[10:32:59.136]                       inherits <- base::inherits
[10:32:59.136]                       invokeRestart <- base::invokeRestart
[10:32:59.136]                       is.null <- base::is.null
[10:32:59.136]                       muffled <- FALSE
[10:32:59.136]                       if (inherits(cond, "message")) {
[10:32:59.136]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:59.136]                         if (muffled) 
[10:32:59.136]                           invokeRestart("muffleMessage")
[10:32:59.136]                       }
[10:32:59.136]                       else if (inherits(cond, "warning")) {
[10:32:59.136]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:59.136]                         if (muffled) 
[10:32:59.136]                           invokeRestart("muffleWarning")
[10:32:59.136]                       }
[10:32:59.136]                       else if (inherits(cond, "condition")) {
[10:32:59.136]                         if (!is.null(pattern)) {
[10:32:59.136]                           computeRestarts <- base::computeRestarts
[10:32:59.136]                           grepl <- base::grepl
[10:32:59.136]                           restarts <- computeRestarts(cond)
[10:32:59.136]                           for (restart in restarts) {
[10:32:59.136]                             name <- restart$name
[10:32:59.136]                             if (is.null(name)) 
[10:32:59.136]                               next
[10:32:59.136]                             if (!grepl(pattern, name)) 
[10:32:59.136]                               next
[10:32:59.136]                             invokeRestart(restart)
[10:32:59.136]                             muffled <- TRUE
[10:32:59.136]                             break
[10:32:59.136]                           }
[10:32:59.136]                         }
[10:32:59.136]                       }
[10:32:59.136]                       invisible(muffled)
[10:32:59.136]                     }
[10:32:59.136]                     muffleCondition(cond, pattern = "^muffle")
[10:32:59.136]                   }
[10:32:59.136]                 }
[10:32:59.136]             }
[10:32:59.136]         }))
[10:32:59.136]     }, error = function(ex) {
[10:32:59.136]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:59.136]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:59.136]                 ...future.rng), started = ...future.startTime, 
[10:32:59.136]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:59.136]             version = "1.8"), class = "FutureResult")
[10:32:59.136]     }, finally = {
[10:32:59.136]         if (!identical(...future.workdir, getwd())) 
[10:32:59.136]             setwd(...future.workdir)
[10:32:59.136]         {
[10:32:59.136]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:59.136]                 ...future.oldOptions$nwarnings <- NULL
[10:32:59.136]             }
[10:32:59.136]             base::options(...future.oldOptions)
[10:32:59.136]             if (.Platform$OS.type == "windows") {
[10:32:59.136]                 old_names <- names(...future.oldEnvVars)
[10:32:59.136]                 envs <- base::Sys.getenv()
[10:32:59.136]                 names <- names(envs)
[10:32:59.136]                 common <- intersect(names, old_names)
[10:32:59.136]                 added <- setdiff(names, old_names)
[10:32:59.136]                 removed <- setdiff(old_names, names)
[10:32:59.136]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:59.136]                   envs[common]]
[10:32:59.136]                 NAMES <- toupper(changed)
[10:32:59.136]                 args <- list()
[10:32:59.136]                 for (kk in seq_along(NAMES)) {
[10:32:59.136]                   name <- changed[[kk]]
[10:32:59.136]                   NAME <- NAMES[[kk]]
[10:32:59.136]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:59.136]                     next
[10:32:59.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:59.136]                 }
[10:32:59.136]                 NAMES <- toupper(added)
[10:32:59.136]                 for (kk in seq_along(NAMES)) {
[10:32:59.136]                   name <- added[[kk]]
[10:32:59.136]                   NAME <- NAMES[[kk]]
[10:32:59.136]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:59.136]                     next
[10:32:59.136]                   args[[name]] <- ""
[10:32:59.136]                 }
[10:32:59.136]                 NAMES <- toupper(removed)
[10:32:59.136]                 for (kk in seq_along(NAMES)) {
[10:32:59.136]                   name <- removed[[kk]]
[10:32:59.136]                   NAME <- NAMES[[kk]]
[10:32:59.136]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:59.136]                     next
[10:32:59.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:59.136]                 }
[10:32:59.136]                 if (length(args) > 0) 
[10:32:59.136]                   base::do.call(base::Sys.setenv, args = args)
[10:32:59.136]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:59.136]             }
[10:32:59.136]             else {
[10:32:59.136]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:59.136]             }
[10:32:59.136]             {
[10:32:59.136]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:59.136]                   0L) {
[10:32:59.136]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:59.136]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:59.136]                   base::options(opts)
[10:32:59.136]                 }
[10:32:59.136]                 {
[10:32:59.136]                   {
[10:32:59.136]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:59.136]                     NULL
[10:32:59.136]                   }
[10:32:59.136]                   options(future.plan = NULL)
[10:32:59.136]                   if (is.na(NA_character_)) 
[10:32:59.136]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:59.136]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:59.136]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:59.136]                     .init = FALSE)
[10:32:59.136]                 }
[10:32:59.136]             }
[10:32:59.136]         }
[10:32:59.136]     })
[10:32:59.136]     if (TRUE) {
[10:32:59.136]         base::sink(type = "output", split = FALSE)
[10:32:59.136]         if (TRUE) {
[10:32:59.136]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:59.136]         }
[10:32:59.136]         else {
[10:32:59.136]             ...future.result["stdout"] <- base::list(NULL)
[10:32:59.136]         }
[10:32:59.136]         base::close(...future.stdout)
[10:32:59.136]         ...future.stdout <- NULL
[10:32:59.136]     }
[10:32:59.136]     ...future.result$conditions <- ...future.conditions
[10:32:59.136]     ...future.result$finished <- base::Sys.time()
[10:32:59.136]     ...future.result
[10:32:59.136] }
[10:32:59.139] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[10:32:59.139] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[10:32:59.139] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[10:32:59.139] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[10:32:59.140] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[10:32:59.140] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[10:32:59.140] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[10:32:59.140] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[10:32:59.141] MultisessionFuture started
[10:32:59.141] - Launch lazy future ... done
[10:32:59.141] run() for ‘MultisessionFuture’ ... done
[10:32:59.141] result() for ClusterFuture ...
[10:32:59.141] receiveMessageFromWorker() for ClusterFuture ...
[10:32:59.141] - Validating connection of MultisessionFuture
[10:32:59.147] - received message: FutureResult
[10:32:59.147] - Received FutureResult
[10:32:59.147] - Erased future from FutureRegistry
[10:32:59.147] result() for ClusterFuture ...
[10:32:59.147] - result already collected: FutureResult
[10:32:59.147] result() for ClusterFuture ... done
[10:32:59.147] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:59.147] result() for ClusterFuture ... done
[10:32:59.147] result() for ClusterFuture ...
[10:32:59.148] - result already collected: FutureResult
[10:32:59.148] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[10:32:59.149] getGlobalsAndPackages() ...
[10:32:59.149] Searching for globals...
[10:32:59.153] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[10:32:59.153] Searching for globals ... DONE
[10:32:59.153] Resolving globals: FALSE
[10:32:59.154] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[10:32:59.154] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[10:32:59.154] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[10:32:59.154] 
[10:32:59.154] getGlobalsAndPackages() ... DONE
[10:32:59.155] run() for ‘Future’ ...
[10:32:59.155] - state: ‘created’
[10:32:59.155] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:59.169] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:59.169] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:59.169]   - Field: ‘node’
[10:32:59.169]   - Field: ‘label’
[10:32:59.169]   - Field: ‘local’
[10:32:59.169]   - Field: ‘owner’
[10:32:59.169]   - Field: ‘envir’
[10:32:59.169]   - Field: ‘workers’
[10:32:59.169]   - Field: ‘packages’
[10:32:59.169]   - Field: ‘gc’
[10:32:59.170]   - Field: ‘conditions’
[10:32:59.170]   - Field: ‘persistent’
[10:32:59.170]   - Field: ‘expr’
[10:32:59.170]   - Field: ‘uuid’
[10:32:59.170]   - Field: ‘seed’
[10:32:59.170]   - Field: ‘version’
[10:32:59.170]   - Field: ‘result’
[10:32:59.170]   - Field: ‘asynchronous’
[10:32:59.170]   - Field: ‘calls’
[10:32:59.170]   - Field: ‘globals’
[10:32:59.170]   - Field: ‘stdout’
[10:32:59.171]   - Field: ‘earlySignal’
[10:32:59.171]   - Field: ‘lazy’
[10:32:59.171]   - Field: ‘state’
[10:32:59.171] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:59.171] - Launch lazy future ...
[10:32:59.171] Packages needed by the future expression (n = 0): <none>
[10:32:59.171] Packages needed by future strategies (n = 0): <none>
[10:32:59.172] {
[10:32:59.172]     {
[10:32:59.172]         {
[10:32:59.172]             ...future.startTime <- base::Sys.time()
[10:32:59.172]             {
[10:32:59.172]                 {
[10:32:59.172]                   {
[10:32:59.172]                     {
[10:32:59.172]                       base::local({
[10:32:59.172]                         has_future <- base::requireNamespace("future", 
[10:32:59.172]                           quietly = TRUE)
[10:32:59.172]                         if (has_future) {
[10:32:59.172]                           ns <- base::getNamespace("future")
[10:32:59.172]                           version <- ns[[".package"]][["version"]]
[10:32:59.172]                           if (is.null(version)) 
[10:32:59.172]                             version <- utils::packageVersion("future")
[10:32:59.172]                         }
[10:32:59.172]                         else {
[10:32:59.172]                           version <- NULL
[10:32:59.172]                         }
[10:32:59.172]                         if (!has_future || version < "1.8.0") {
[10:32:59.172]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:59.172]                             "", base::R.version$version.string), 
[10:32:59.172]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:59.172]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:59.172]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:59.172]                               "release", "version")], collapse = " "), 
[10:32:59.172]                             hostname = base::Sys.info()[["nodename"]])
[10:32:59.172]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:59.172]                             info)
[10:32:59.172]                           info <- base::paste(info, collapse = "; ")
[10:32:59.172]                           if (!has_future) {
[10:32:59.172]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:59.172]                               info)
[10:32:59.172]                           }
[10:32:59.172]                           else {
[10:32:59.172]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:59.172]                               info, version)
[10:32:59.172]                           }
[10:32:59.172]                           base::stop(msg)
[10:32:59.172]                         }
[10:32:59.172]                       })
[10:32:59.172]                     }
[10:32:59.172]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:59.172]                     base::options(mc.cores = 1L)
[10:32:59.172]                   }
[10:32:59.172]                   ...future.strategy.old <- future::plan("list")
[10:32:59.172]                   options(future.plan = NULL)
[10:32:59.172]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:59.172]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:59.172]                 }
[10:32:59.172]                 ...future.workdir <- getwd()
[10:32:59.172]             }
[10:32:59.172]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:59.172]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:59.172]         }
[10:32:59.172]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:59.172]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:59.172]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:59.172]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:59.172]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:59.172]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:59.172]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:59.172]             base::names(...future.oldOptions))
[10:32:59.172]     }
[10:32:59.172]     if (FALSE) {
[10:32:59.172]     }
[10:32:59.172]     else {
[10:32:59.172]         if (TRUE) {
[10:32:59.172]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:59.172]                 open = "w")
[10:32:59.172]         }
[10:32:59.172]         else {
[10:32:59.172]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:59.172]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:59.172]         }
[10:32:59.172]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:59.172]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:59.172]             base::sink(type = "output", split = FALSE)
[10:32:59.172]             base::close(...future.stdout)
[10:32:59.172]         }, add = TRUE)
[10:32:59.172]     }
[10:32:59.172]     ...future.frame <- base::sys.nframe()
[10:32:59.172]     ...future.conditions <- base::list()
[10:32:59.172]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:59.172]     if (FALSE) {
[10:32:59.172]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:59.172]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:59.172]     }
[10:32:59.172]     ...future.result <- base::tryCatch({
[10:32:59.172]         base::withCallingHandlers({
[10:32:59.172]             ...future.value <- base::withVisible(base::local({
[10:32:59.172]                 ...future.makeSendCondition <- base::local({
[10:32:59.172]                   sendCondition <- NULL
[10:32:59.172]                   function(frame = 1L) {
[10:32:59.172]                     if (is.function(sendCondition)) 
[10:32:59.172]                       return(sendCondition)
[10:32:59.172]                     ns <- getNamespace("parallel")
[10:32:59.172]                     if (exists("sendData", mode = "function", 
[10:32:59.172]                       envir = ns)) {
[10:32:59.172]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:59.172]                         envir = ns)
[10:32:59.172]                       envir <- sys.frame(frame)
[10:32:59.172]                       master <- NULL
[10:32:59.172]                       while (!identical(envir, .GlobalEnv) && 
[10:32:59.172]                         !identical(envir, emptyenv())) {
[10:32:59.172]                         if (exists("master", mode = "list", envir = envir, 
[10:32:59.172]                           inherits = FALSE)) {
[10:32:59.172]                           master <- get("master", mode = "list", 
[10:32:59.172]                             envir = envir, inherits = FALSE)
[10:32:59.172]                           if (inherits(master, c("SOCKnode", 
[10:32:59.172]                             "SOCK0node"))) {
[10:32:59.172]                             sendCondition <<- function(cond) {
[10:32:59.172]                               data <- list(type = "VALUE", value = cond, 
[10:32:59.172]                                 success = TRUE)
[10:32:59.172]                               parallel_sendData(master, data)
[10:32:59.172]                             }
[10:32:59.172]                             return(sendCondition)
[10:32:59.172]                           }
[10:32:59.172]                         }
[10:32:59.172]                         frame <- frame + 1L
[10:32:59.172]                         envir <- sys.frame(frame)
[10:32:59.172]                       }
[10:32:59.172]                     }
[10:32:59.172]                     sendCondition <<- function(cond) NULL
[10:32:59.172]                   }
[10:32:59.172]                 })
[10:32:59.172]                 withCallingHandlers({
[10:32:59.172]                   {
[10:32:59.172]                     outer_function(1L)
[10:32:59.172]                   }
[10:32:59.172]                 }, immediateCondition = function(cond) {
[10:32:59.172]                   sendCondition <- ...future.makeSendCondition()
[10:32:59.172]                   sendCondition(cond)
[10:32:59.172]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:59.172]                   {
[10:32:59.172]                     inherits <- base::inherits
[10:32:59.172]                     invokeRestart <- base::invokeRestart
[10:32:59.172]                     is.null <- base::is.null
[10:32:59.172]                     muffled <- FALSE
[10:32:59.172]                     if (inherits(cond, "message")) {
[10:32:59.172]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:59.172]                       if (muffled) 
[10:32:59.172]                         invokeRestart("muffleMessage")
[10:32:59.172]                     }
[10:32:59.172]                     else if (inherits(cond, "warning")) {
[10:32:59.172]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:59.172]                       if (muffled) 
[10:32:59.172]                         invokeRestart("muffleWarning")
[10:32:59.172]                     }
[10:32:59.172]                     else if (inherits(cond, "condition")) {
[10:32:59.172]                       if (!is.null(pattern)) {
[10:32:59.172]                         computeRestarts <- base::computeRestarts
[10:32:59.172]                         grepl <- base::grepl
[10:32:59.172]                         restarts <- computeRestarts(cond)
[10:32:59.172]                         for (restart in restarts) {
[10:32:59.172]                           name <- restart$name
[10:32:59.172]                           if (is.null(name)) 
[10:32:59.172]                             next
[10:32:59.172]                           if (!grepl(pattern, name)) 
[10:32:59.172]                             next
[10:32:59.172]                           invokeRestart(restart)
[10:32:59.172]                           muffled <- TRUE
[10:32:59.172]                           break
[10:32:59.172]                         }
[10:32:59.172]                       }
[10:32:59.172]                     }
[10:32:59.172]                     invisible(muffled)
[10:32:59.172]                   }
[10:32:59.172]                   muffleCondition(cond)
[10:32:59.172]                 })
[10:32:59.172]             }))
[10:32:59.172]             future::FutureResult(value = ...future.value$value, 
[10:32:59.172]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:59.172]                   ...future.rng), globalenv = if (FALSE) 
[10:32:59.172]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:59.172]                     ...future.globalenv.names))
[10:32:59.172]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:59.172]         }, condition = base::local({
[10:32:59.172]             c <- base::c
[10:32:59.172]             inherits <- base::inherits
[10:32:59.172]             invokeRestart <- base::invokeRestart
[10:32:59.172]             length <- base::length
[10:32:59.172]             list <- base::list
[10:32:59.172]             seq.int <- base::seq.int
[10:32:59.172]             signalCondition <- base::signalCondition
[10:32:59.172]             sys.calls <- base::sys.calls
[10:32:59.172]             `[[` <- base::`[[`
[10:32:59.172]             `+` <- base::`+`
[10:32:59.172]             `<<-` <- base::`<<-`
[10:32:59.172]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:59.172]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:59.172]                   3L)]
[10:32:59.172]             }
[10:32:59.172]             function(cond) {
[10:32:59.172]                 is_error <- inherits(cond, "error")
[10:32:59.172]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:59.172]                   NULL)
[10:32:59.172]                 if (is_error) {
[10:32:59.172]                   sessionInformation <- function() {
[10:32:59.172]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:59.172]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:59.172]                       search = base::search(), system = base::Sys.info())
[10:32:59.172]                   }
[10:32:59.172]                   ...future.conditions[[length(...future.conditions) + 
[10:32:59.172]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:59.172]                     cond$call), session = sessionInformation(), 
[10:32:59.172]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:59.172]                   signalCondition(cond)
[10:32:59.172]                 }
[10:32:59.172]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:59.172]                 "immediateCondition"))) {
[10:32:59.172]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:59.172]                   ...future.conditions[[length(...future.conditions) + 
[10:32:59.172]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:59.172]                   if (TRUE && !signal) {
[10:32:59.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:59.172]                     {
[10:32:59.172]                       inherits <- base::inherits
[10:32:59.172]                       invokeRestart <- base::invokeRestart
[10:32:59.172]                       is.null <- base::is.null
[10:32:59.172]                       muffled <- FALSE
[10:32:59.172]                       if (inherits(cond, "message")) {
[10:32:59.172]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:59.172]                         if (muffled) 
[10:32:59.172]                           invokeRestart("muffleMessage")
[10:32:59.172]                       }
[10:32:59.172]                       else if (inherits(cond, "warning")) {
[10:32:59.172]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:59.172]                         if (muffled) 
[10:32:59.172]                           invokeRestart("muffleWarning")
[10:32:59.172]                       }
[10:32:59.172]                       else if (inherits(cond, "condition")) {
[10:32:59.172]                         if (!is.null(pattern)) {
[10:32:59.172]                           computeRestarts <- base::computeRestarts
[10:32:59.172]                           grepl <- base::grepl
[10:32:59.172]                           restarts <- computeRestarts(cond)
[10:32:59.172]                           for (restart in restarts) {
[10:32:59.172]                             name <- restart$name
[10:32:59.172]                             if (is.null(name)) 
[10:32:59.172]                               next
[10:32:59.172]                             if (!grepl(pattern, name)) 
[10:32:59.172]                               next
[10:32:59.172]                             invokeRestart(restart)
[10:32:59.172]                             muffled <- TRUE
[10:32:59.172]                             break
[10:32:59.172]                           }
[10:32:59.172]                         }
[10:32:59.172]                       }
[10:32:59.172]                       invisible(muffled)
[10:32:59.172]                     }
[10:32:59.172]                     muffleCondition(cond, pattern = "^muffle")
[10:32:59.172]                   }
[10:32:59.172]                 }
[10:32:59.172]                 else {
[10:32:59.172]                   if (TRUE) {
[10:32:59.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:59.172]                     {
[10:32:59.172]                       inherits <- base::inherits
[10:32:59.172]                       invokeRestart <- base::invokeRestart
[10:32:59.172]                       is.null <- base::is.null
[10:32:59.172]                       muffled <- FALSE
[10:32:59.172]                       if (inherits(cond, "message")) {
[10:32:59.172]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:59.172]                         if (muffled) 
[10:32:59.172]                           invokeRestart("muffleMessage")
[10:32:59.172]                       }
[10:32:59.172]                       else if (inherits(cond, "warning")) {
[10:32:59.172]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:59.172]                         if (muffled) 
[10:32:59.172]                           invokeRestart("muffleWarning")
[10:32:59.172]                       }
[10:32:59.172]                       else if (inherits(cond, "condition")) {
[10:32:59.172]                         if (!is.null(pattern)) {
[10:32:59.172]                           computeRestarts <- base::computeRestarts
[10:32:59.172]                           grepl <- base::grepl
[10:32:59.172]                           restarts <- computeRestarts(cond)
[10:32:59.172]                           for (restart in restarts) {
[10:32:59.172]                             name <- restart$name
[10:32:59.172]                             if (is.null(name)) 
[10:32:59.172]                               next
[10:32:59.172]                             if (!grepl(pattern, name)) 
[10:32:59.172]                               next
[10:32:59.172]                             invokeRestart(restart)
[10:32:59.172]                             muffled <- TRUE
[10:32:59.172]                             break
[10:32:59.172]                           }
[10:32:59.172]                         }
[10:32:59.172]                       }
[10:32:59.172]                       invisible(muffled)
[10:32:59.172]                     }
[10:32:59.172]                     muffleCondition(cond, pattern = "^muffle")
[10:32:59.172]                   }
[10:32:59.172]                 }
[10:32:59.172]             }
[10:32:59.172]         }))
[10:32:59.172]     }, error = function(ex) {
[10:32:59.172]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:59.172]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:59.172]                 ...future.rng), started = ...future.startTime, 
[10:32:59.172]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:59.172]             version = "1.8"), class = "FutureResult")
[10:32:59.172]     }, finally = {
[10:32:59.172]         if (!identical(...future.workdir, getwd())) 
[10:32:59.172]             setwd(...future.workdir)
[10:32:59.172]         {
[10:32:59.172]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:59.172]                 ...future.oldOptions$nwarnings <- NULL
[10:32:59.172]             }
[10:32:59.172]             base::options(...future.oldOptions)
[10:32:59.172]             if (.Platform$OS.type == "windows") {
[10:32:59.172]                 old_names <- names(...future.oldEnvVars)
[10:32:59.172]                 envs <- base::Sys.getenv()
[10:32:59.172]                 names <- names(envs)
[10:32:59.172]                 common <- intersect(names, old_names)
[10:32:59.172]                 added <- setdiff(names, old_names)
[10:32:59.172]                 removed <- setdiff(old_names, names)
[10:32:59.172]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:59.172]                   envs[common]]
[10:32:59.172]                 NAMES <- toupper(changed)
[10:32:59.172]                 args <- list()
[10:32:59.172]                 for (kk in seq_along(NAMES)) {
[10:32:59.172]                   name <- changed[[kk]]
[10:32:59.172]                   NAME <- NAMES[[kk]]
[10:32:59.172]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:59.172]                     next
[10:32:59.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:59.172]                 }
[10:32:59.172]                 NAMES <- toupper(added)
[10:32:59.172]                 for (kk in seq_along(NAMES)) {
[10:32:59.172]                   name <- added[[kk]]
[10:32:59.172]                   NAME <- NAMES[[kk]]
[10:32:59.172]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:59.172]                     next
[10:32:59.172]                   args[[name]] <- ""
[10:32:59.172]                 }
[10:32:59.172]                 NAMES <- toupper(removed)
[10:32:59.172]                 for (kk in seq_along(NAMES)) {
[10:32:59.172]                   name <- removed[[kk]]
[10:32:59.172]                   NAME <- NAMES[[kk]]
[10:32:59.172]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:59.172]                     next
[10:32:59.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:59.172]                 }
[10:32:59.172]                 if (length(args) > 0) 
[10:32:59.172]                   base::do.call(base::Sys.setenv, args = args)
[10:32:59.172]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:59.172]             }
[10:32:59.172]             else {
[10:32:59.172]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:59.172]             }
[10:32:59.172]             {
[10:32:59.172]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:59.172]                   0L) {
[10:32:59.172]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:59.172]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:59.172]                   base::options(opts)
[10:32:59.172]                 }
[10:32:59.172]                 {
[10:32:59.172]                   {
[10:32:59.172]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:59.172]                     NULL
[10:32:59.172]                   }
[10:32:59.172]                   options(future.plan = NULL)
[10:32:59.172]                   if (is.na(NA_character_)) 
[10:32:59.172]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:59.172]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:59.172]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:59.172]                     .init = FALSE)
[10:32:59.172]                 }
[10:32:59.172]             }
[10:32:59.172]         }
[10:32:59.172]     })
[10:32:59.172]     if (TRUE) {
[10:32:59.172]         base::sink(type = "output", split = FALSE)
[10:32:59.172]         if (TRUE) {
[10:32:59.172]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:59.172]         }
[10:32:59.172]         else {
[10:32:59.172]             ...future.result["stdout"] <- base::list(NULL)
[10:32:59.172]         }
[10:32:59.172]         base::close(...future.stdout)
[10:32:59.172]         ...future.stdout <- NULL
[10:32:59.172]     }
[10:32:59.172]     ...future.result$conditions <- ...future.conditions
[10:32:59.172]     ...future.result$finished <- base::Sys.time()
[10:32:59.172]     ...future.result
[10:32:59.172] }
[10:32:59.174] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[10:32:59.174] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[10:32:59.175] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[10:32:59.175] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[10:32:59.175] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[10:32:59.175] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[10:32:59.175] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[10:32:59.176] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[10:32:59.176] MultisessionFuture started
[10:32:59.176] - Launch lazy future ... done
[10:32:59.176] run() for ‘MultisessionFuture’ ... done
[10:32:59.176] result() for ClusterFuture ...
[10:32:59.176] receiveMessageFromWorker() for ClusterFuture ...
[10:32:59.177] - Validating connection of MultisessionFuture
[10:32:59.180] - received message: FutureResult
[10:32:59.180] - Received FutureResult
[10:32:59.180] - Erased future from FutureRegistry
[10:32:59.180] result() for ClusterFuture ...
[10:32:59.180] - result already collected: FutureResult
[10:32:59.180] result() for ClusterFuture ... done
[10:32:59.180] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:59.180] result() for ClusterFuture ... done
[10:32:59.181] result() for ClusterFuture ...
[10:32:59.181] - result already collected: FutureResult
[10:32:59.181] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 2 cores ... DONE
> 
> message("*** Globals - formulas ... DONE")
*** Globals - formulas ... DONE
> 
> source("incl/end.R")
[10:32:59.182] plan(): Setting new future strategy stack:
[10:32:59.182] List of future strategies:
[10:32:59.182] 1. FutureStrategy:
[10:32:59.182]    - args: function (..., envir = parent.frame())
[10:32:59.182]    - tweaked: FALSE
[10:32:59.182]    - call: future::plan(oplan)
[10:32:59.183] plan(): nbrOfWorkers() = 1
> 
