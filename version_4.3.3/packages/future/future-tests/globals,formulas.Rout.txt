
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:36:40.644] plan(): Setting new future strategy stack:
[13:36:40.645] List of future strategies:
[13:36:40.645] 1. sequential:
[13:36:40.645]    - args: function (..., envir = parent.frame())
[13:36:40.645]    - tweaked: FALSE
[13:36:40.645]    - call: future::plan("sequential")
[13:36:40.658] plan(): nbrOfWorkers() = 1
> 
> library("datasets") ## cars data set
> library("stats")    ## lm(), poly(), xtabs()
> 
> message("*** Globals - formulas ...")
*** Globals - formulas ...
> 
> ## (i) lm(<formula>):
> ## From example("lm", package = "stats")
> ctl <- c(4.17, 5.58, 5.18, 6.11, 4.50, 4.61, 5.17, 4.53, 5.33, 5.14)
> trt <- c(4.81, 4.17, 4.41, 3.59, 5.87, 3.83, 6.03, 4.89, 4.32, 4.69)
> group <- gl(2, 10, 20, labels = c("Ctl", "Trt"))
> weight <- c(ctl, trt)
> ctl <- trt <- NULL
> ## Truth:
> fit_i <- lm(weight ~ group - 1)
> print(fit_i)

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

> 
> ## (ii) xtabs(~ x):
> x <- c(1, 1, 2, 2, 2)
> ## Truth:
> tbl_ii <- xtabs(~ x)
> print(tbl_ii)
x
1 2 
2 3 
> 
> ## (iii) lm(<formula>, data = cars):
> exprs <- list(
+   # "remove-intercept-term" form of no-intercept
+   a = substitute({ lm(dist ~ . -1, data = cars) }),
+   # "make-intercept-zero" form of no-intercept
+   b = substitute({ lm(dist ~ . +0, data = cars) }),
+   # doesn't do what we want here
+   c = substitute({ lm(dist ~ speed + speed ^ 2, data = cars) }),
+   # gets us a quadratic term
+   d = substitute({ lm(dist ~ speed + I(speed ^ 2), data = cars) }),
+   # avoid potential multicollinearity
+   e = substitute({ lm(dist ~ poly(speed, 2), data = cars) })
+ )
> 
> ## (iv) Globals - map(x, ~ expr):
> ## A fake purrr::map() function with limited functionality
> map <- function(.x, .f, ...) {
+   if (inherits(.f, "formula")) {
+     expr <- .f[[-1]]
+     .f <- eval(bquote(function(...) {
+       .(expr)
+     }))
+   }
+   eval(lapply(.x, FUN = .f, ...))
+ }
> 
> inner_function <- function(x) { x + 1 }
> 
> outer_function <- function(x) {
+   map(1:2, ~ inner_function(.x))
+ }
> 
> y_iv <- outer_function(1L)
> str(y_iv)
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
> 
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     message("- lm(<formula>) ...")
+     
+     ## Explicit future
+     f <- future({ lm(weight ~ group - 1) })
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Explicit future (lazy)
+     f <- future({ lm(weight ~ group - 1) }, lazy = TRUE)
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment
+     fit %<-% { lm(weight ~ group - 1) }
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (non-lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% FALSE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% TRUE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     message("- Globals - one-side formulas, e.g. xtabs(~ x) ...")
+     ## Explicit future
+     f <- future({ xtabs(~ x) })
+     tbl <- value(f)
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     ## Future assignment
+     tbl %<-% { xtabs(~ x) }
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     message("- Globals - lm(<formula>, data = cars) ...")
+     for (kk in seq_along(exprs)) {
+       expr <- exprs[[kk]]
+       name <- names(exprs)[kk]
+       message(sprintf("- Globals - lm(<formula #%d (%s)>, data = cars) ...",
+                       kk, sQuote(name)))
+     
+       fit_iii <- eval(expr)
+       print(fit_iii)
+     
+       f <- future(expr, substitute = FALSE)
+       fit <- value(f)
+       print(fit)
+     
+       stopifnot(all.equal(fit, fit_iii))
+     } ## for (kk ...)
+ 
+     message("- Globals - map(x, ~ expr) ...")
+     f <- future({ outer_function(1L) })
+     y <- value(f)
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+ 
+     y %<-% { outer_function(1L) }
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+   } ## for (strategy ...)
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[13:36:40.713] plan(): Setting new future strategy stack:
[13:36:40.713] List of future strategies:
[13:36:40.713] 1. sequential:
[13:36:40.713]    - args: function (..., envir = parent.frame())
[13:36:40.713]    - tweaked: FALSE
[13:36:40.713]    - call: plan(strategy)
[13:36:40.725] plan(): nbrOfWorkers() = 1
- lm(<formula>) ...
[13:36:40.726] getGlobalsAndPackages() ...
[13:36:40.726] Searching for globals...
[13:36:40.732] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:36:40.733] Searching for globals ... DONE
[13:36:40.733] Resolving globals: FALSE
[13:36:40.734] The total size of the 2 globals is 896 bytes (896 bytes)
[13:36:40.734] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:36:40.734] - globals: [2] ‘weight’, ‘group’
[13:36:40.735] - packages: [1] ‘stats’
[13:36:40.735] getGlobalsAndPackages() ... DONE
[13:36:40.735] run() for ‘Future’ ...
[13:36:40.736] - state: ‘created’
[13:36:40.736] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:40.736] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:40.736] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:40.736]   - Field: ‘label’
[13:36:40.736]   - Field: ‘local’
[13:36:40.736]   - Field: ‘owner’
[13:36:40.737]   - Field: ‘envir’
[13:36:40.737]   - Field: ‘packages’
[13:36:40.737]   - Field: ‘gc’
[13:36:40.737]   - Field: ‘conditions’
[13:36:40.737]   - Field: ‘expr’
[13:36:40.737]   - Field: ‘uuid’
[13:36:40.737]   - Field: ‘seed’
[13:36:40.737]   - Field: ‘version’
[13:36:40.737]   - Field: ‘result’
[13:36:40.737]   - Field: ‘asynchronous’
[13:36:40.737]   - Field: ‘calls’
[13:36:40.738]   - Field: ‘globals’
[13:36:40.738]   - Field: ‘stdout’
[13:36:40.738]   - Field: ‘earlySignal’
[13:36:40.738]   - Field: ‘lazy’
[13:36:40.738]   - Field: ‘state’
[13:36:40.738] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:40.738] - Launch lazy future ...
[13:36:40.739] Packages needed by the future expression (n = 1): ‘stats’
[13:36:40.739] Packages needed by future strategies (n = 0): <none>
[13:36:40.740] {
[13:36:40.740]     {
[13:36:40.740]         {
[13:36:40.740]             ...future.startTime <- base::Sys.time()
[13:36:40.740]             {
[13:36:40.740]                 {
[13:36:40.740]                   {
[13:36:40.740]                     {
[13:36:40.740]                       base::local({
[13:36:40.740]                         has_future <- base::requireNamespace("future", 
[13:36:40.740]                           quietly = TRUE)
[13:36:40.740]                         if (has_future) {
[13:36:40.740]                           ns <- base::getNamespace("future")
[13:36:40.740]                           version <- ns[[".package"]][["version"]]
[13:36:40.740]                           if (is.null(version)) 
[13:36:40.740]                             version <- utils::packageVersion("future")
[13:36:40.740]                         }
[13:36:40.740]                         else {
[13:36:40.740]                           version <- NULL
[13:36:40.740]                         }
[13:36:40.740]                         if (!has_future || version < "1.8.0") {
[13:36:40.740]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:40.740]                             "", base::R.version$version.string), 
[13:36:40.740]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:40.740]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:40.740]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:40.740]                               "release", "version")], collapse = " "), 
[13:36:40.740]                             hostname = base::Sys.info()[["nodename"]])
[13:36:40.740]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:40.740]                             info)
[13:36:40.740]                           info <- base::paste(info, collapse = "; ")
[13:36:40.740]                           if (!has_future) {
[13:36:40.740]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:40.740]                               info)
[13:36:40.740]                           }
[13:36:40.740]                           else {
[13:36:40.740]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:40.740]                               info, version)
[13:36:40.740]                           }
[13:36:40.740]                           base::stop(msg)
[13:36:40.740]                         }
[13:36:40.740]                       })
[13:36:40.740]                     }
[13:36:40.740]                     base::local({
[13:36:40.740]                       for (pkg in "stats") {
[13:36:40.740]                         base::loadNamespace(pkg)
[13:36:40.740]                         base::library(pkg, character.only = TRUE)
[13:36:40.740]                       }
[13:36:40.740]                     })
[13:36:40.740]                   }
[13:36:40.740]                   ...future.strategy.old <- future::plan("list")
[13:36:40.740]                   options(future.plan = NULL)
[13:36:40.740]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.740]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:40.740]                 }
[13:36:40.740]                 ...future.workdir <- getwd()
[13:36:40.740]             }
[13:36:40.740]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:40.740]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:40.740]         }
[13:36:40.740]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:40.740]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:40.740]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:40.740]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:40.740]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:40.740]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:40.740]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:40.740]             base::names(...future.oldOptions))
[13:36:40.740]     }
[13:36:40.740]     if (FALSE) {
[13:36:40.740]     }
[13:36:40.740]     else {
[13:36:40.740]         if (TRUE) {
[13:36:40.740]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:40.740]                 open = "w")
[13:36:40.740]         }
[13:36:40.740]         else {
[13:36:40.740]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:40.740]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:40.740]         }
[13:36:40.740]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:40.740]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:40.740]             base::sink(type = "output", split = FALSE)
[13:36:40.740]             base::close(...future.stdout)
[13:36:40.740]         }, add = TRUE)
[13:36:40.740]     }
[13:36:40.740]     ...future.frame <- base::sys.nframe()
[13:36:40.740]     ...future.conditions <- base::list()
[13:36:40.740]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:40.740]     if (FALSE) {
[13:36:40.740]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:40.740]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:40.740]     }
[13:36:40.740]     ...future.result <- base::tryCatch({
[13:36:40.740]         base::withCallingHandlers({
[13:36:40.740]             ...future.value <- base::withVisible(base::local({
[13:36:40.740]                 lm(weight ~ group - 1)
[13:36:40.740]             }))
[13:36:40.740]             future::FutureResult(value = ...future.value$value, 
[13:36:40.740]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.740]                   ...future.rng), globalenv = if (FALSE) 
[13:36:40.740]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:40.740]                     ...future.globalenv.names))
[13:36:40.740]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:40.740]         }, condition = base::local({
[13:36:40.740]             c <- base::c
[13:36:40.740]             inherits <- base::inherits
[13:36:40.740]             invokeRestart <- base::invokeRestart
[13:36:40.740]             length <- base::length
[13:36:40.740]             list <- base::list
[13:36:40.740]             seq.int <- base::seq.int
[13:36:40.740]             signalCondition <- base::signalCondition
[13:36:40.740]             sys.calls <- base::sys.calls
[13:36:40.740]             `[[` <- base::`[[`
[13:36:40.740]             `+` <- base::`+`
[13:36:40.740]             `<<-` <- base::`<<-`
[13:36:40.740]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:40.740]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:40.740]                   3L)]
[13:36:40.740]             }
[13:36:40.740]             function(cond) {
[13:36:40.740]                 is_error <- inherits(cond, "error")
[13:36:40.740]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:40.740]                   NULL)
[13:36:40.740]                 if (is_error) {
[13:36:40.740]                   sessionInformation <- function() {
[13:36:40.740]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:40.740]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:40.740]                       search = base::search(), system = base::Sys.info())
[13:36:40.740]                   }
[13:36:40.740]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.740]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:40.740]                     cond$call), session = sessionInformation(), 
[13:36:40.740]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:40.740]                   signalCondition(cond)
[13:36:40.740]                 }
[13:36:40.740]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:40.740]                 "immediateCondition"))) {
[13:36:40.740]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:40.740]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.740]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:40.740]                   if (TRUE && !signal) {
[13:36:40.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.740]                     {
[13:36:40.740]                       inherits <- base::inherits
[13:36:40.740]                       invokeRestart <- base::invokeRestart
[13:36:40.740]                       is.null <- base::is.null
[13:36:40.740]                       muffled <- FALSE
[13:36:40.740]                       if (inherits(cond, "message")) {
[13:36:40.740]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.740]                         if (muffled) 
[13:36:40.740]                           invokeRestart("muffleMessage")
[13:36:40.740]                       }
[13:36:40.740]                       else if (inherits(cond, "warning")) {
[13:36:40.740]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.740]                         if (muffled) 
[13:36:40.740]                           invokeRestart("muffleWarning")
[13:36:40.740]                       }
[13:36:40.740]                       else if (inherits(cond, "condition")) {
[13:36:40.740]                         if (!is.null(pattern)) {
[13:36:40.740]                           computeRestarts <- base::computeRestarts
[13:36:40.740]                           grepl <- base::grepl
[13:36:40.740]                           restarts <- computeRestarts(cond)
[13:36:40.740]                           for (restart in restarts) {
[13:36:40.740]                             name <- restart$name
[13:36:40.740]                             if (is.null(name)) 
[13:36:40.740]                               next
[13:36:40.740]                             if (!grepl(pattern, name)) 
[13:36:40.740]                               next
[13:36:40.740]                             invokeRestart(restart)
[13:36:40.740]                             muffled <- TRUE
[13:36:40.740]                             break
[13:36:40.740]                           }
[13:36:40.740]                         }
[13:36:40.740]                       }
[13:36:40.740]                       invisible(muffled)
[13:36:40.740]                     }
[13:36:40.740]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.740]                   }
[13:36:40.740]                 }
[13:36:40.740]                 else {
[13:36:40.740]                   if (TRUE) {
[13:36:40.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.740]                     {
[13:36:40.740]                       inherits <- base::inherits
[13:36:40.740]                       invokeRestart <- base::invokeRestart
[13:36:40.740]                       is.null <- base::is.null
[13:36:40.740]                       muffled <- FALSE
[13:36:40.740]                       if (inherits(cond, "message")) {
[13:36:40.740]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.740]                         if (muffled) 
[13:36:40.740]                           invokeRestart("muffleMessage")
[13:36:40.740]                       }
[13:36:40.740]                       else if (inherits(cond, "warning")) {
[13:36:40.740]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.740]                         if (muffled) 
[13:36:40.740]                           invokeRestart("muffleWarning")
[13:36:40.740]                       }
[13:36:40.740]                       else if (inherits(cond, "condition")) {
[13:36:40.740]                         if (!is.null(pattern)) {
[13:36:40.740]                           computeRestarts <- base::computeRestarts
[13:36:40.740]                           grepl <- base::grepl
[13:36:40.740]                           restarts <- computeRestarts(cond)
[13:36:40.740]                           for (restart in restarts) {
[13:36:40.740]                             name <- restart$name
[13:36:40.740]                             if (is.null(name)) 
[13:36:40.740]                               next
[13:36:40.740]                             if (!grepl(pattern, name)) 
[13:36:40.740]                               next
[13:36:40.740]                             invokeRestart(restart)
[13:36:40.740]                             muffled <- TRUE
[13:36:40.740]                             break
[13:36:40.740]                           }
[13:36:40.740]                         }
[13:36:40.740]                       }
[13:36:40.740]                       invisible(muffled)
[13:36:40.740]                     }
[13:36:40.740]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.740]                   }
[13:36:40.740]                 }
[13:36:40.740]             }
[13:36:40.740]         }))
[13:36:40.740]     }, error = function(ex) {
[13:36:40.740]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:40.740]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.740]                 ...future.rng), started = ...future.startTime, 
[13:36:40.740]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:40.740]             version = "1.8"), class = "FutureResult")
[13:36:40.740]     }, finally = {
[13:36:40.740]         if (!identical(...future.workdir, getwd())) 
[13:36:40.740]             setwd(...future.workdir)
[13:36:40.740]         {
[13:36:40.740]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:40.740]                 ...future.oldOptions$nwarnings <- NULL
[13:36:40.740]             }
[13:36:40.740]             base::options(...future.oldOptions)
[13:36:40.740]             if (.Platform$OS.type == "windows") {
[13:36:40.740]                 old_names <- names(...future.oldEnvVars)
[13:36:40.740]                 envs <- base::Sys.getenv()
[13:36:40.740]                 names <- names(envs)
[13:36:40.740]                 common <- intersect(names, old_names)
[13:36:40.740]                 added <- setdiff(names, old_names)
[13:36:40.740]                 removed <- setdiff(old_names, names)
[13:36:40.740]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:40.740]                   envs[common]]
[13:36:40.740]                 NAMES <- toupper(changed)
[13:36:40.740]                 args <- list()
[13:36:40.740]                 for (kk in seq_along(NAMES)) {
[13:36:40.740]                   name <- changed[[kk]]
[13:36:40.740]                   NAME <- NAMES[[kk]]
[13:36:40.740]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.740]                     next
[13:36:40.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.740]                 }
[13:36:40.740]                 NAMES <- toupper(added)
[13:36:40.740]                 for (kk in seq_along(NAMES)) {
[13:36:40.740]                   name <- added[[kk]]
[13:36:40.740]                   NAME <- NAMES[[kk]]
[13:36:40.740]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.740]                     next
[13:36:40.740]                   args[[name]] <- ""
[13:36:40.740]                 }
[13:36:40.740]                 NAMES <- toupper(removed)
[13:36:40.740]                 for (kk in seq_along(NAMES)) {
[13:36:40.740]                   name <- removed[[kk]]
[13:36:40.740]                   NAME <- NAMES[[kk]]
[13:36:40.740]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.740]                     next
[13:36:40.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.740]                 }
[13:36:40.740]                 if (length(args) > 0) 
[13:36:40.740]                   base::do.call(base::Sys.setenv, args = args)
[13:36:40.740]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:40.740]             }
[13:36:40.740]             else {
[13:36:40.740]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:40.740]             }
[13:36:40.740]             {
[13:36:40.740]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:40.740]                   0L) {
[13:36:40.740]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:40.740]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:40.740]                   base::options(opts)
[13:36:40.740]                 }
[13:36:40.740]                 {
[13:36:40.740]                   {
[13:36:40.740]                     NULL
[13:36:40.740]                     RNGkind("Mersenne-Twister")
[13:36:40.740]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:40.740]                       inherits = FALSE)
[13:36:40.740]                   }
[13:36:40.740]                   options(future.plan = NULL)
[13:36:40.740]                   if (is.na(NA_character_)) 
[13:36:40.740]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.740]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:40.740]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:40.740]                     .init = FALSE)
[13:36:40.740]                 }
[13:36:40.740]             }
[13:36:40.740]         }
[13:36:40.740]     })
[13:36:40.740]     if (TRUE) {
[13:36:40.740]         base::sink(type = "output", split = FALSE)
[13:36:40.740]         if (TRUE) {
[13:36:40.740]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:40.740]         }
[13:36:40.740]         else {
[13:36:40.740]             ...future.result["stdout"] <- base::list(NULL)
[13:36:40.740]         }
[13:36:40.740]         base::close(...future.stdout)
[13:36:40.740]         ...future.stdout <- NULL
[13:36:40.740]     }
[13:36:40.740]     ...future.result$conditions <- ...future.conditions
[13:36:40.740]     ...future.result$finished <- base::Sys.time()
[13:36:40.740]     ...future.result
[13:36:40.740] }
[13:36:40.742] assign_globals() ...
[13:36:40.742] List of 2
[13:36:40.742]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:36:40.742]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:36:40.742]  - attr(*, "where")=List of 2
[13:36:40.742]   ..$ weight:<environment: R_EmptyEnv> 
[13:36:40.742]   ..$ group :<environment: R_EmptyEnv> 
[13:36:40.742]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:40.742]  - attr(*, "resolved")= logi FALSE
[13:36:40.742]  - attr(*, "total_size")= num 896
[13:36:40.742]  - attr(*, "already-done")= logi TRUE
[13:36:40.745] - copied ‘weight’ to environment
[13:36:40.745] - copied ‘group’ to environment
[13:36:40.745] assign_globals() ... done
[13:36:40.745] plan(): Setting new future strategy stack:
[13:36:40.746] List of future strategies:
[13:36:40.746] 1. sequential:
[13:36:40.746]    - args: function (..., envir = parent.frame())
[13:36:40.746]    - tweaked: FALSE
[13:36:40.746]    - call: NULL
[13:36:40.746] plan(): nbrOfWorkers() = 1
[13:36:40.748] plan(): Setting new future strategy stack:
[13:36:40.748] List of future strategies:
[13:36:40.748] 1. sequential:
[13:36:40.748]    - args: function (..., envir = parent.frame())
[13:36:40.748]    - tweaked: FALSE
[13:36:40.748]    - call: plan(strategy)
[13:36:40.748] plan(): nbrOfWorkers() = 1
[13:36:40.748] SequentialFuture started (and completed)
[13:36:40.749] - Launch lazy future ... done
[13:36:40.749] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:36:40.753] getGlobalsAndPackages() ...
[13:36:40.754] Searching for globals...
[13:36:40.755] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:36:40.755] Searching for globals ... DONE
[13:36:40.755] Resolving globals: FALSE
[13:36:40.756] The total size of the 2 globals is 896 bytes (896 bytes)
[13:36:40.756] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:36:40.756] - globals: [2] ‘weight’, ‘group’
[13:36:40.756] - packages: [1] ‘stats’
[13:36:40.756] getGlobalsAndPackages() ... DONE
[13:36:40.757] run() for ‘Future’ ...
[13:36:40.757] - state: ‘created’
[13:36:40.757] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:40.757] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:40.757] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:40.757]   - Field: ‘label’
[13:36:40.757]   - Field: ‘local’
[13:36:40.757]   - Field: ‘owner’
[13:36:40.757]   - Field: ‘envir’
[13:36:40.758]   - Field: ‘packages’
[13:36:40.758]   - Field: ‘gc’
[13:36:40.758]   - Field: ‘conditions’
[13:36:40.758]   - Field: ‘expr’
[13:36:40.758]   - Field: ‘uuid’
[13:36:40.758]   - Field: ‘seed’
[13:36:40.758]   - Field: ‘version’
[13:36:40.758]   - Field: ‘result’
[13:36:40.758]   - Field: ‘asynchronous’
[13:36:40.758]   - Field: ‘calls’
[13:36:40.759]   - Field: ‘globals’
[13:36:40.759]   - Field: ‘stdout’
[13:36:40.759]   - Field: ‘earlySignal’
[13:36:40.759]   - Field: ‘lazy’
[13:36:40.759]   - Field: ‘state’
[13:36:40.759] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:40.759] - Launch lazy future ...
[13:36:40.759] Packages needed by the future expression (n = 1): ‘stats’
[13:36:40.759] Packages needed by future strategies (n = 0): <none>
[13:36:40.760] {
[13:36:40.760]     {
[13:36:40.760]         {
[13:36:40.760]             ...future.startTime <- base::Sys.time()
[13:36:40.760]             {
[13:36:40.760]                 {
[13:36:40.760]                   {
[13:36:40.760]                     {
[13:36:40.760]                       base::local({
[13:36:40.760]                         has_future <- base::requireNamespace("future", 
[13:36:40.760]                           quietly = TRUE)
[13:36:40.760]                         if (has_future) {
[13:36:40.760]                           ns <- base::getNamespace("future")
[13:36:40.760]                           version <- ns[[".package"]][["version"]]
[13:36:40.760]                           if (is.null(version)) 
[13:36:40.760]                             version <- utils::packageVersion("future")
[13:36:40.760]                         }
[13:36:40.760]                         else {
[13:36:40.760]                           version <- NULL
[13:36:40.760]                         }
[13:36:40.760]                         if (!has_future || version < "1.8.0") {
[13:36:40.760]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:40.760]                             "", base::R.version$version.string), 
[13:36:40.760]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:40.760]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:40.760]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:40.760]                               "release", "version")], collapse = " "), 
[13:36:40.760]                             hostname = base::Sys.info()[["nodename"]])
[13:36:40.760]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:40.760]                             info)
[13:36:40.760]                           info <- base::paste(info, collapse = "; ")
[13:36:40.760]                           if (!has_future) {
[13:36:40.760]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:40.760]                               info)
[13:36:40.760]                           }
[13:36:40.760]                           else {
[13:36:40.760]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:40.760]                               info, version)
[13:36:40.760]                           }
[13:36:40.760]                           base::stop(msg)
[13:36:40.760]                         }
[13:36:40.760]                       })
[13:36:40.760]                     }
[13:36:40.760]                     base::local({
[13:36:40.760]                       for (pkg in "stats") {
[13:36:40.760]                         base::loadNamespace(pkg)
[13:36:40.760]                         base::library(pkg, character.only = TRUE)
[13:36:40.760]                       }
[13:36:40.760]                     })
[13:36:40.760]                   }
[13:36:40.760]                   ...future.strategy.old <- future::plan("list")
[13:36:40.760]                   options(future.plan = NULL)
[13:36:40.760]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.760]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:40.760]                 }
[13:36:40.760]                 ...future.workdir <- getwd()
[13:36:40.760]             }
[13:36:40.760]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:40.760]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:40.760]         }
[13:36:40.760]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:40.760]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:40.760]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:40.760]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:40.760]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:40.760]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:40.760]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:40.760]             base::names(...future.oldOptions))
[13:36:40.760]     }
[13:36:40.760]     if (FALSE) {
[13:36:40.760]     }
[13:36:40.760]     else {
[13:36:40.760]         if (TRUE) {
[13:36:40.760]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:40.760]                 open = "w")
[13:36:40.760]         }
[13:36:40.760]         else {
[13:36:40.760]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:40.760]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:40.760]         }
[13:36:40.760]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:40.760]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:40.760]             base::sink(type = "output", split = FALSE)
[13:36:40.760]             base::close(...future.stdout)
[13:36:40.760]         }, add = TRUE)
[13:36:40.760]     }
[13:36:40.760]     ...future.frame <- base::sys.nframe()
[13:36:40.760]     ...future.conditions <- base::list()
[13:36:40.760]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:40.760]     if (FALSE) {
[13:36:40.760]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:40.760]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:40.760]     }
[13:36:40.760]     ...future.result <- base::tryCatch({
[13:36:40.760]         base::withCallingHandlers({
[13:36:40.760]             ...future.value <- base::withVisible(base::local({
[13:36:40.760]                 lm(weight ~ group - 1)
[13:36:40.760]             }))
[13:36:40.760]             future::FutureResult(value = ...future.value$value, 
[13:36:40.760]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.760]                   ...future.rng), globalenv = if (FALSE) 
[13:36:40.760]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:40.760]                     ...future.globalenv.names))
[13:36:40.760]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:40.760]         }, condition = base::local({
[13:36:40.760]             c <- base::c
[13:36:40.760]             inherits <- base::inherits
[13:36:40.760]             invokeRestart <- base::invokeRestart
[13:36:40.760]             length <- base::length
[13:36:40.760]             list <- base::list
[13:36:40.760]             seq.int <- base::seq.int
[13:36:40.760]             signalCondition <- base::signalCondition
[13:36:40.760]             sys.calls <- base::sys.calls
[13:36:40.760]             `[[` <- base::`[[`
[13:36:40.760]             `+` <- base::`+`
[13:36:40.760]             `<<-` <- base::`<<-`
[13:36:40.760]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:40.760]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:40.760]                   3L)]
[13:36:40.760]             }
[13:36:40.760]             function(cond) {
[13:36:40.760]                 is_error <- inherits(cond, "error")
[13:36:40.760]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:40.760]                   NULL)
[13:36:40.760]                 if (is_error) {
[13:36:40.760]                   sessionInformation <- function() {
[13:36:40.760]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:40.760]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:40.760]                       search = base::search(), system = base::Sys.info())
[13:36:40.760]                   }
[13:36:40.760]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.760]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:40.760]                     cond$call), session = sessionInformation(), 
[13:36:40.760]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:40.760]                   signalCondition(cond)
[13:36:40.760]                 }
[13:36:40.760]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:40.760]                 "immediateCondition"))) {
[13:36:40.760]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:40.760]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.760]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:40.760]                   if (TRUE && !signal) {
[13:36:40.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.760]                     {
[13:36:40.760]                       inherits <- base::inherits
[13:36:40.760]                       invokeRestart <- base::invokeRestart
[13:36:40.760]                       is.null <- base::is.null
[13:36:40.760]                       muffled <- FALSE
[13:36:40.760]                       if (inherits(cond, "message")) {
[13:36:40.760]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.760]                         if (muffled) 
[13:36:40.760]                           invokeRestart("muffleMessage")
[13:36:40.760]                       }
[13:36:40.760]                       else if (inherits(cond, "warning")) {
[13:36:40.760]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.760]                         if (muffled) 
[13:36:40.760]                           invokeRestart("muffleWarning")
[13:36:40.760]                       }
[13:36:40.760]                       else if (inherits(cond, "condition")) {
[13:36:40.760]                         if (!is.null(pattern)) {
[13:36:40.760]                           computeRestarts <- base::computeRestarts
[13:36:40.760]                           grepl <- base::grepl
[13:36:40.760]                           restarts <- computeRestarts(cond)
[13:36:40.760]                           for (restart in restarts) {
[13:36:40.760]                             name <- restart$name
[13:36:40.760]                             if (is.null(name)) 
[13:36:40.760]                               next
[13:36:40.760]                             if (!grepl(pattern, name)) 
[13:36:40.760]                               next
[13:36:40.760]                             invokeRestart(restart)
[13:36:40.760]                             muffled <- TRUE
[13:36:40.760]                             break
[13:36:40.760]                           }
[13:36:40.760]                         }
[13:36:40.760]                       }
[13:36:40.760]                       invisible(muffled)
[13:36:40.760]                     }
[13:36:40.760]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.760]                   }
[13:36:40.760]                 }
[13:36:40.760]                 else {
[13:36:40.760]                   if (TRUE) {
[13:36:40.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.760]                     {
[13:36:40.760]                       inherits <- base::inherits
[13:36:40.760]                       invokeRestart <- base::invokeRestart
[13:36:40.760]                       is.null <- base::is.null
[13:36:40.760]                       muffled <- FALSE
[13:36:40.760]                       if (inherits(cond, "message")) {
[13:36:40.760]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.760]                         if (muffled) 
[13:36:40.760]                           invokeRestart("muffleMessage")
[13:36:40.760]                       }
[13:36:40.760]                       else if (inherits(cond, "warning")) {
[13:36:40.760]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.760]                         if (muffled) 
[13:36:40.760]                           invokeRestart("muffleWarning")
[13:36:40.760]                       }
[13:36:40.760]                       else if (inherits(cond, "condition")) {
[13:36:40.760]                         if (!is.null(pattern)) {
[13:36:40.760]                           computeRestarts <- base::computeRestarts
[13:36:40.760]                           grepl <- base::grepl
[13:36:40.760]                           restarts <- computeRestarts(cond)
[13:36:40.760]                           for (restart in restarts) {
[13:36:40.760]                             name <- restart$name
[13:36:40.760]                             if (is.null(name)) 
[13:36:40.760]                               next
[13:36:40.760]                             if (!grepl(pattern, name)) 
[13:36:40.760]                               next
[13:36:40.760]                             invokeRestart(restart)
[13:36:40.760]                             muffled <- TRUE
[13:36:40.760]                             break
[13:36:40.760]                           }
[13:36:40.760]                         }
[13:36:40.760]                       }
[13:36:40.760]                       invisible(muffled)
[13:36:40.760]                     }
[13:36:40.760]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.760]                   }
[13:36:40.760]                 }
[13:36:40.760]             }
[13:36:40.760]         }))
[13:36:40.760]     }, error = function(ex) {
[13:36:40.760]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:40.760]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.760]                 ...future.rng), started = ...future.startTime, 
[13:36:40.760]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:40.760]             version = "1.8"), class = "FutureResult")
[13:36:40.760]     }, finally = {
[13:36:40.760]         if (!identical(...future.workdir, getwd())) 
[13:36:40.760]             setwd(...future.workdir)
[13:36:40.760]         {
[13:36:40.760]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:40.760]                 ...future.oldOptions$nwarnings <- NULL
[13:36:40.760]             }
[13:36:40.760]             base::options(...future.oldOptions)
[13:36:40.760]             if (.Platform$OS.type == "windows") {
[13:36:40.760]                 old_names <- names(...future.oldEnvVars)
[13:36:40.760]                 envs <- base::Sys.getenv()
[13:36:40.760]                 names <- names(envs)
[13:36:40.760]                 common <- intersect(names, old_names)
[13:36:40.760]                 added <- setdiff(names, old_names)
[13:36:40.760]                 removed <- setdiff(old_names, names)
[13:36:40.760]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:40.760]                   envs[common]]
[13:36:40.760]                 NAMES <- toupper(changed)
[13:36:40.760]                 args <- list()
[13:36:40.760]                 for (kk in seq_along(NAMES)) {
[13:36:40.760]                   name <- changed[[kk]]
[13:36:40.760]                   NAME <- NAMES[[kk]]
[13:36:40.760]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.760]                     next
[13:36:40.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.760]                 }
[13:36:40.760]                 NAMES <- toupper(added)
[13:36:40.760]                 for (kk in seq_along(NAMES)) {
[13:36:40.760]                   name <- added[[kk]]
[13:36:40.760]                   NAME <- NAMES[[kk]]
[13:36:40.760]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.760]                     next
[13:36:40.760]                   args[[name]] <- ""
[13:36:40.760]                 }
[13:36:40.760]                 NAMES <- toupper(removed)
[13:36:40.760]                 for (kk in seq_along(NAMES)) {
[13:36:40.760]                   name <- removed[[kk]]
[13:36:40.760]                   NAME <- NAMES[[kk]]
[13:36:40.760]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.760]                     next
[13:36:40.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.760]                 }
[13:36:40.760]                 if (length(args) > 0) 
[13:36:40.760]                   base::do.call(base::Sys.setenv, args = args)
[13:36:40.760]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:40.760]             }
[13:36:40.760]             else {
[13:36:40.760]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:40.760]             }
[13:36:40.760]             {
[13:36:40.760]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:40.760]                   0L) {
[13:36:40.760]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:40.760]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:40.760]                   base::options(opts)
[13:36:40.760]                 }
[13:36:40.760]                 {
[13:36:40.760]                   {
[13:36:40.760]                     NULL
[13:36:40.760]                     RNGkind("Mersenne-Twister")
[13:36:40.760]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:40.760]                       inherits = FALSE)
[13:36:40.760]                   }
[13:36:40.760]                   options(future.plan = NULL)
[13:36:40.760]                   if (is.na(NA_character_)) 
[13:36:40.760]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.760]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:40.760]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:40.760]                     .init = FALSE)
[13:36:40.760]                 }
[13:36:40.760]             }
[13:36:40.760]         }
[13:36:40.760]     })
[13:36:40.760]     if (TRUE) {
[13:36:40.760]         base::sink(type = "output", split = FALSE)
[13:36:40.760]         if (TRUE) {
[13:36:40.760]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:40.760]         }
[13:36:40.760]         else {
[13:36:40.760]             ...future.result["stdout"] <- base::list(NULL)
[13:36:40.760]         }
[13:36:40.760]         base::close(...future.stdout)
[13:36:40.760]         ...future.stdout <- NULL
[13:36:40.760]     }
[13:36:40.760]     ...future.result$conditions <- ...future.conditions
[13:36:40.760]     ...future.result$finished <- base::Sys.time()
[13:36:40.760]     ...future.result
[13:36:40.760] }
[13:36:40.761] assign_globals() ...
[13:36:40.761] List of 2
[13:36:40.761]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:36:40.761]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:36:40.761]  - attr(*, "where")=List of 2
[13:36:40.761]   ..$ weight:<environment: R_EmptyEnv> 
[13:36:40.761]   ..$ group :<environment: R_EmptyEnv> 
[13:36:40.761]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:40.761]  - attr(*, "resolved")= logi FALSE
[13:36:40.761]  - attr(*, "total_size")= num 896
[13:36:40.761]  - attr(*, "already-done")= logi TRUE
[13:36:40.764] - copied ‘weight’ to environment
[13:36:40.764] - copied ‘group’ to environment
[13:36:40.765] assign_globals() ... done
[13:36:40.765] plan(): Setting new future strategy stack:
[13:36:40.765] List of future strategies:
[13:36:40.765] 1. sequential:
[13:36:40.765]    - args: function (..., envir = parent.frame())
[13:36:40.765]    - tweaked: FALSE
[13:36:40.765]    - call: NULL
[13:36:40.765] plan(): nbrOfWorkers() = 1
[13:36:40.767] plan(): Setting new future strategy stack:
[13:36:40.767] List of future strategies:
[13:36:40.767] 1. sequential:
[13:36:40.767]    - args: function (..., envir = parent.frame())
[13:36:40.767]    - tweaked: FALSE
[13:36:40.767]    - call: plan(strategy)
[13:36:40.767] plan(): nbrOfWorkers() = 1
[13:36:40.767] SequentialFuture started (and completed)
[13:36:40.767] - Launch lazy future ... done
[13:36:40.767] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:36:40.770] getGlobalsAndPackages() ...
[13:36:40.770] Searching for globals...
[13:36:40.771] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:36:40.771] Searching for globals ... DONE
[13:36:40.771] Resolving globals: FALSE
[13:36:40.772] The total size of the 2 globals is 896 bytes (896 bytes)
[13:36:40.772] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:36:40.772] - globals: [2] ‘weight’, ‘group’
[13:36:40.772] - packages: [1] ‘stats’
[13:36:40.773] getGlobalsAndPackages() ... DONE
[13:36:40.773] run() for ‘Future’ ...
[13:36:40.773] - state: ‘created’
[13:36:40.773] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:40.773] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:40.773] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:40.773]   - Field: ‘label’
[13:36:40.774]   - Field: ‘local’
[13:36:40.774]   - Field: ‘owner’
[13:36:40.774]   - Field: ‘envir’
[13:36:40.774]   - Field: ‘packages’
[13:36:40.774]   - Field: ‘gc’
[13:36:40.774]   - Field: ‘conditions’
[13:36:40.774]   - Field: ‘expr’
[13:36:40.774]   - Field: ‘uuid’
[13:36:40.774]   - Field: ‘seed’
[13:36:40.774]   - Field: ‘version’
[13:36:40.774]   - Field: ‘result’
[13:36:40.775]   - Field: ‘asynchronous’
[13:36:40.775]   - Field: ‘calls’
[13:36:40.775]   - Field: ‘globals’
[13:36:40.775]   - Field: ‘stdout’
[13:36:40.775]   - Field: ‘earlySignal’
[13:36:40.775]   - Field: ‘lazy’
[13:36:40.775]   - Field: ‘state’
[13:36:40.775] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:40.775] - Launch lazy future ...
[13:36:40.775] Packages needed by the future expression (n = 1): ‘stats’
[13:36:40.776] Packages needed by future strategies (n = 0): <none>
[13:36:40.777] {
[13:36:40.777]     {
[13:36:40.777]         {
[13:36:40.777]             ...future.startTime <- base::Sys.time()
[13:36:40.777]             {
[13:36:40.777]                 {
[13:36:40.777]                   {
[13:36:40.777]                     {
[13:36:40.777]                       base::local({
[13:36:40.777]                         has_future <- base::requireNamespace("future", 
[13:36:40.777]                           quietly = TRUE)
[13:36:40.777]                         if (has_future) {
[13:36:40.777]                           ns <- base::getNamespace("future")
[13:36:40.777]                           version <- ns[[".package"]][["version"]]
[13:36:40.777]                           if (is.null(version)) 
[13:36:40.777]                             version <- utils::packageVersion("future")
[13:36:40.777]                         }
[13:36:40.777]                         else {
[13:36:40.777]                           version <- NULL
[13:36:40.777]                         }
[13:36:40.777]                         if (!has_future || version < "1.8.0") {
[13:36:40.777]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:40.777]                             "", base::R.version$version.string), 
[13:36:40.777]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:40.777]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:40.777]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:40.777]                               "release", "version")], collapse = " "), 
[13:36:40.777]                             hostname = base::Sys.info()[["nodename"]])
[13:36:40.777]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:40.777]                             info)
[13:36:40.777]                           info <- base::paste(info, collapse = "; ")
[13:36:40.777]                           if (!has_future) {
[13:36:40.777]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:40.777]                               info)
[13:36:40.777]                           }
[13:36:40.777]                           else {
[13:36:40.777]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:40.777]                               info, version)
[13:36:40.777]                           }
[13:36:40.777]                           base::stop(msg)
[13:36:40.777]                         }
[13:36:40.777]                       })
[13:36:40.777]                     }
[13:36:40.777]                     base::local({
[13:36:40.777]                       for (pkg in "stats") {
[13:36:40.777]                         base::loadNamespace(pkg)
[13:36:40.777]                         base::library(pkg, character.only = TRUE)
[13:36:40.777]                       }
[13:36:40.777]                     })
[13:36:40.777]                   }
[13:36:40.777]                   ...future.strategy.old <- future::plan("list")
[13:36:40.777]                   options(future.plan = NULL)
[13:36:40.777]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.777]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:40.777]                 }
[13:36:40.777]                 ...future.workdir <- getwd()
[13:36:40.777]             }
[13:36:40.777]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:40.777]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:40.777]         }
[13:36:40.777]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:40.777]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:40.777]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:40.777]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:40.777]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:40.777]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:40.777]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:40.777]             base::names(...future.oldOptions))
[13:36:40.777]     }
[13:36:40.777]     if (FALSE) {
[13:36:40.777]     }
[13:36:40.777]     else {
[13:36:40.777]         if (TRUE) {
[13:36:40.777]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:40.777]                 open = "w")
[13:36:40.777]         }
[13:36:40.777]         else {
[13:36:40.777]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:40.777]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:40.777]         }
[13:36:40.777]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:40.777]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:40.777]             base::sink(type = "output", split = FALSE)
[13:36:40.777]             base::close(...future.stdout)
[13:36:40.777]         }, add = TRUE)
[13:36:40.777]     }
[13:36:40.777]     ...future.frame <- base::sys.nframe()
[13:36:40.777]     ...future.conditions <- base::list()
[13:36:40.777]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:40.777]     if (FALSE) {
[13:36:40.777]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:40.777]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:40.777]     }
[13:36:40.777]     ...future.result <- base::tryCatch({
[13:36:40.777]         base::withCallingHandlers({
[13:36:40.777]             ...future.value <- base::withVisible(base::local({
[13:36:40.777]                 lm(weight ~ group - 1)
[13:36:40.777]             }))
[13:36:40.777]             future::FutureResult(value = ...future.value$value, 
[13:36:40.777]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.777]                   ...future.rng), globalenv = if (FALSE) 
[13:36:40.777]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:40.777]                     ...future.globalenv.names))
[13:36:40.777]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:40.777]         }, condition = base::local({
[13:36:40.777]             c <- base::c
[13:36:40.777]             inherits <- base::inherits
[13:36:40.777]             invokeRestart <- base::invokeRestart
[13:36:40.777]             length <- base::length
[13:36:40.777]             list <- base::list
[13:36:40.777]             seq.int <- base::seq.int
[13:36:40.777]             signalCondition <- base::signalCondition
[13:36:40.777]             sys.calls <- base::sys.calls
[13:36:40.777]             `[[` <- base::`[[`
[13:36:40.777]             `+` <- base::`+`
[13:36:40.777]             `<<-` <- base::`<<-`
[13:36:40.777]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:40.777]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:40.777]                   3L)]
[13:36:40.777]             }
[13:36:40.777]             function(cond) {
[13:36:40.777]                 is_error <- inherits(cond, "error")
[13:36:40.777]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:40.777]                   NULL)
[13:36:40.777]                 if (is_error) {
[13:36:40.777]                   sessionInformation <- function() {
[13:36:40.777]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:40.777]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:40.777]                       search = base::search(), system = base::Sys.info())
[13:36:40.777]                   }
[13:36:40.777]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.777]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:40.777]                     cond$call), session = sessionInformation(), 
[13:36:40.777]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:40.777]                   signalCondition(cond)
[13:36:40.777]                 }
[13:36:40.777]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:40.777]                 "immediateCondition"))) {
[13:36:40.777]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:40.777]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.777]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:40.777]                   if (TRUE && !signal) {
[13:36:40.777]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.777]                     {
[13:36:40.777]                       inherits <- base::inherits
[13:36:40.777]                       invokeRestart <- base::invokeRestart
[13:36:40.777]                       is.null <- base::is.null
[13:36:40.777]                       muffled <- FALSE
[13:36:40.777]                       if (inherits(cond, "message")) {
[13:36:40.777]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.777]                         if (muffled) 
[13:36:40.777]                           invokeRestart("muffleMessage")
[13:36:40.777]                       }
[13:36:40.777]                       else if (inherits(cond, "warning")) {
[13:36:40.777]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.777]                         if (muffled) 
[13:36:40.777]                           invokeRestart("muffleWarning")
[13:36:40.777]                       }
[13:36:40.777]                       else if (inherits(cond, "condition")) {
[13:36:40.777]                         if (!is.null(pattern)) {
[13:36:40.777]                           computeRestarts <- base::computeRestarts
[13:36:40.777]                           grepl <- base::grepl
[13:36:40.777]                           restarts <- computeRestarts(cond)
[13:36:40.777]                           for (restart in restarts) {
[13:36:40.777]                             name <- restart$name
[13:36:40.777]                             if (is.null(name)) 
[13:36:40.777]                               next
[13:36:40.777]                             if (!grepl(pattern, name)) 
[13:36:40.777]                               next
[13:36:40.777]                             invokeRestart(restart)
[13:36:40.777]                             muffled <- TRUE
[13:36:40.777]                             break
[13:36:40.777]                           }
[13:36:40.777]                         }
[13:36:40.777]                       }
[13:36:40.777]                       invisible(muffled)
[13:36:40.777]                     }
[13:36:40.777]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.777]                   }
[13:36:40.777]                 }
[13:36:40.777]                 else {
[13:36:40.777]                   if (TRUE) {
[13:36:40.777]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.777]                     {
[13:36:40.777]                       inherits <- base::inherits
[13:36:40.777]                       invokeRestart <- base::invokeRestart
[13:36:40.777]                       is.null <- base::is.null
[13:36:40.777]                       muffled <- FALSE
[13:36:40.777]                       if (inherits(cond, "message")) {
[13:36:40.777]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.777]                         if (muffled) 
[13:36:40.777]                           invokeRestart("muffleMessage")
[13:36:40.777]                       }
[13:36:40.777]                       else if (inherits(cond, "warning")) {
[13:36:40.777]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.777]                         if (muffled) 
[13:36:40.777]                           invokeRestart("muffleWarning")
[13:36:40.777]                       }
[13:36:40.777]                       else if (inherits(cond, "condition")) {
[13:36:40.777]                         if (!is.null(pattern)) {
[13:36:40.777]                           computeRestarts <- base::computeRestarts
[13:36:40.777]                           grepl <- base::grepl
[13:36:40.777]                           restarts <- computeRestarts(cond)
[13:36:40.777]                           for (restart in restarts) {
[13:36:40.777]                             name <- restart$name
[13:36:40.777]                             if (is.null(name)) 
[13:36:40.777]                               next
[13:36:40.777]                             if (!grepl(pattern, name)) 
[13:36:40.777]                               next
[13:36:40.777]                             invokeRestart(restart)
[13:36:40.777]                             muffled <- TRUE
[13:36:40.777]                             break
[13:36:40.777]                           }
[13:36:40.777]                         }
[13:36:40.777]                       }
[13:36:40.777]                       invisible(muffled)
[13:36:40.777]                     }
[13:36:40.777]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.777]                   }
[13:36:40.777]                 }
[13:36:40.777]             }
[13:36:40.777]         }))
[13:36:40.777]     }, error = function(ex) {
[13:36:40.777]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:40.777]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.777]                 ...future.rng), started = ...future.startTime, 
[13:36:40.777]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:40.777]             version = "1.8"), class = "FutureResult")
[13:36:40.777]     }, finally = {
[13:36:40.777]         if (!identical(...future.workdir, getwd())) 
[13:36:40.777]             setwd(...future.workdir)
[13:36:40.777]         {
[13:36:40.777]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:40.777]                 ...future.oldOptions$nwarnings <- NULL
[13:36:40.777]             }
[13:36:40.777]             base::options(...future.oldOptions)
[13:36:40.777]             if (.Platform$OS.type == "windows") {
[13:36:40.777]                 old_names <- names(...future.oldEnvVars)
[13:36:40.777]                 envs <- base::Sys.getenv()
[13:36:40.777]                 names <- names(envs)
[13:36:40.777]                 common <- intersect(names, old_names)
[13:36:40.777]                 added <- setdiff(names, old_names)
[13:36:40.777]                 removed <- setdiff(old_names, names)
[13:36:40.777]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:40.777]                   envs[common]]
[13:36:40.777]                 NAMES <- toupper(changed)
[13:36:40.777]                 args <- list()
[13:36:40.777]                 for (kk in seq_along(NAMES)) {
[13:36:40.777]                   name <- changed[[kk]]
[13:36:40.777]                   NAME <- NAMES[[kk]]
[13:36:40.777]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.777]                     next
[13:36:40.777]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.777]                 }
[13:36:40.777]                 NAMES <- toupper(added)
[13:36:40.777]                 for (kk in seq_along(NAMES)) {
[13:36:40.777]                   name <- added[[kk]]
[13:36:40.777]                   NAME <- NAMES[[kk]]
[13:36:40.777]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.777]                     next
[13:36:40.777]                   args[[name]] <- ""
[13:36:40.777]                 }
[13:36:40.777]                 NAMES <- toupper(removed)
[13:36:40.777]                 for (kk in seq_along(NAMES)) {
[13:36:40.777]                   name <- removed[[kk]]
[13:36:40.777]                   NAME <- NAMES[[kk]]
[13:36:40.777]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.777]                     next
[13:36:40.777]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.777]                 }
[13:36:40.777]                 if (length(args) > 0) 
[13:36:40.777]                   base::do.call(base::Sys.setenv, args = args)
[13:36:40.777]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:40.777]             }
[13:36:40.777]             else {
[13:36:40.777]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:40.777]             }
[13:36:40.777]             {
[13:36:40.777]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:40.777]                   0L) {
[13:36:40.777]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:40.777]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:40.777]                   base::options(opts)
[13:36:40.777]                 }
[13:36:40.777]                 {
[13:36:40.777]                   {
[13:36:40.777]                     NULL
[13:36:40.777]                     RNGkind("Mersenne-Twister")
[13:36:40.777]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:40.777]                       inherits = FALSE)
[13:36:40.777]                   }
[13:36:40.777]                   options(future.plan = NULL)
[13:36:40.777]                   if (is.na(NA_character_)) 
[13:36:40.777]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.777]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:40.777]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:40.777]                     .init = FALSE)
[13:36:40.777]                 }
[13:36:40.777]             }
[13:36:40.777]         }
[13:36:40.777]     })
[13:36:40.777]     if (TRUE) {
[13:36:40.777]         base::sink(type = "output", split = FALSE)
[13:36:40.777]         if (TRUE) {
[13:36:40.777]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:40.777]         }
[13:36:40.777]         else {
[13:36:40.777]             ...future.result["stdout"] <- base::list(NULL)
[13:36:40.777]         }
[13:36:40.777]         base::close(...future.stdout)
[13:36:40.777]         ...future.stdout <- NULL
[13:36:40.777]     }
[13:36:40.777]     ...future.result$conditions <- ...future.conditions
[13:36:40.777]     ...future.result$finished <- base::Sys.time()
[13:36:40.777]     ...future.result
[13:36:40.777] }
[13:36:40.779] assign_globals() ...
[13:36:40.779] List of 2
[13:36:40.779]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:36:40.779]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:36:40.779]  - attr(*, "where")=List of 2
[13:36:40.779]   ..$ weight:<environment: R_EmptyEnv> 
[13:36:40.779]   ..$ group :<environment: R_EmptyEnv> 
[13:36:40.779]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:40.779]  - attr(*, "resolved")= logi FALSE
[13:36:40.779]  - attr(*, "total_size")= num 896
[13:36:40.779]  - attr(*, "already-done")= logi TRUE
[13:36:40.782] - copied ‘weight’ to environment
[13:36:40.782] - copied ‘group’ to environment
[13:36:40.782] assign_globals() ... done
[13:36:40.782] plan(): Setting new future strategy stack:
[13:36:40.782] List of future strategies:
[13:36:40.782] 1. sequential:
[13:36:40.782]    - args: function (..., envir = parent.frame())
[13:36:40.782]    - tweaked: FALSE
[13:36:40.782]    - call: NULL
[13:36:40.783] plan(): nbrOfWorkers() = 1
[13:36:40.784] plan(): Setting new future strategy stack:
[13:36:40.784] List of future strategies:
[13:36:40.784] 1. sequential:
[13:36:40.784]    - args: function (..., envir = parent.frame())
[13:36:40.784]    - tweaked: FALSE
[13:36:40.784]    - call: plan(strategy)
[13:36:40.784] plan(): nbrOfWorkers() = 1
[13:36:40.785] SequentialFuture started (and completed)
[13:36:40.785] - Launch lazy future ... done
[13:36:40.785] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:36:40.786] getGlobalsAndPackages() ...
[13:36:40.787] Searching for globals...
[13:36:40.788] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:36:40.788] Searching for globals ... DONE
[13:36:40.788] Resolving globals: FALSE
[13:36:40.788] The total size of the 2 globals is 896 bytes (896 bytes)
[13:36:40.789] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:36:40.789] - globals: [2] ‘weight’, ‘group’
[13:36:40.789] - packages: [1] ‘stats’
[13:36:40.789] getGlobalsAndPackages() ... DONE
[13:36:40.789] run() for ‘Future’ ...
[13:36:40.790] - state: ‘created’
[13:36:40.790] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:40.790] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:40.790] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:40.790]   - Field: ‘label’
[13:36:40.790]   - Field: ‘local’
[13:36:40.790]   - Field: ‘owner’
[13:36:40.790]   - Field: ‘envir’
[13:36:40.790]   - Field: ‘packages’
[13:36:40.791]   - Field: ‘gc’
[13:36:40.791]   - Field: ‘conditions’
[13:36:40.791]   - Field: ‘expr’
[13:36:40.791]   - Field: ‘uuid’
[13:36:40.791]   - Field: ‘seed’
[13:36:40.791]   - Field: ‘version’
[13:36:40.791]   - Field: ‘result’
[13:36:40.791]   - Field: ‘asynchronous’
[13:36:40.791]   - Field: ‘calls’
[13:36:40.791]   - Field: ‘globals’
[13:36:40.791]   - Field: ‘stdout’
[13:36:40.792]   - Field: ‘earlySignal’
[13:36:40.792]   - Field: ‘lazy’
[13:36:40.792]   - Field: ‘state’
[13:36:40.792] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:40.792] - Launch lazy future ...
[13:36:40.792] Packages needed by the future expression (n = 1): ‘stats’
[13:36:40.792] Packages needed by future strategies (n = 0): <none>
[13:36:40.793] {
[13:36:40.793]     {
[13:36:40.793]         {
[13:36:40.793]             ...future.startTime <- base::Sys.time()
[13:36:40.793]             {
[13:36:40.793]                 {
[13:36:40.793]                   {
[13:36:40.793]                     {
[13:36:40.793]                       base::local({
[13:36:40.793]                         has_future <- base::requireNamespace("future", 
[13:36:40.793]                           quietly = TRUE)
[13:36:40.793]                         if (has_future) {
[13:36:40.793]                           ns <- base::getNamespace("future")
[13:36:40.793]                           version <- ns[[".package"]][["version"]]
[13:36:40.793]                           if (is.null(version)) 
[13:36:40.793]                             version <- utils::packageVersion("future")
[13:36:40.793]                         }
[13:36:40.793]                         else {
[13:36:40.793]                           version <- NULL
[13:36:40.793]                         }
[13:36:40.793]                         if (!has_future || version < "1.8.0") {
[13:36:40.793]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:40.793]                             "", base::R.version$version.string), 
[13:36:40.793]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:40.793]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:40.793]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:40.793]                               "release", "version")], collapse = " "), 
[13:36:40.793]                             hostname = base::Sys.info()[["nodename"]])
[13:36:40.793]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:40.793]                             info)
[13:36:40.793]                           info <- base::paste(info, collapse = "; ")
[13:36:40.793]                           if (!has_future) {
[13:36:40.793]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:40.793]                               info)
[13:36:40.793]                           }
[13:36:40.793]                           else {
[13:36:40.793]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:40.793]                               info, version)
[13:36:40.793]                           }
[13:36:40.793]                           base::stop(msg)
[13:36:40.793]                         }
[13:36:40.793]                       })
[13:36:40.793]                     }
[13:36:40.793]                     base::local({
[13:36:40.793]                       for (pkg in "stats") {
[13:36:40.793]                         base::loadNamespace(pkg)
[13:36:40.793]                         base::library(pkg, character.only = TRUE)
[13:36:40.793]                       }
[13:36:40.793]                     })
[13:36:40.793]                   }
[13:36:40.793]                   ...future.strategy.old <- future::plan("list")
[13:36:40.793]                   options(future.plan = NULL)
[13:36:40.793]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.793]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:40.793]                 }
[13:36:40.793]                 ...future.workdir <- getwd()
[13:36:40.793]             }
[13:36:40.793]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:40.793]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:40.793]         }
[13:36:40.793]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:40.793]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:40.793]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:40.793]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:40.793]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:40.793]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:40.793]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:40.793]             base::names(...future.oldOptions))
[13:36:40.793]     }
[13:36:40.793]     if (FALSE) {
[13:36:40.793]     }
[13:36:40.793]     else {
[13:36:40.793]         if (TRUE) {
[13:36:40.793]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:40.793]                 open = "w")
[13:36:40.793]         }
[13:36:40.793]         else {
[13:36:40.793]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:40.793]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:40.793]         }
[13:36:40.793]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:40.793]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:40.793]             base::sink(type = "output", split = FALSE)
[13:36:40.793]             base::close(...future.stdout)
[13:36:40.793]         }, add = TRUE)
[13:36:40.793]     }
[13:36:40.793]     ...future.frame <- base::sys.nframe()
[13:36:40.793]     ...future.conditions <- base::list()
[13:36:40.793]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:40.793]     if (FALSE) {
[13:36:40.793]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:40.793]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:40.793]     }
[13:36:40.793]     ...future.result <- base::tryCatch({
[13:36:40.793]         base::withCallingHandlers({
[13:36:40.793]             ...future.value <- base::withVisible(base::local({
[13:36:40.793]                 lm(weight ~ group - 1)
[13:36:40.793]             }))
[13:36:40.793]             future::FutureResult(value = ...future.value$value, 
[13:36:40.793]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.793]                   ...future.rng), globalenv = if (FALSE) 
[13:36:40.793]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:40.793]                     ...future.globalenv.names))
[13:36:40.793]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:40.793]         }, condition = base::local({
[13:36:40.793]             c <- base::c
[13:36:40.793]             inherits <- base::inherits
[13:36:40.793]             invokeRestart <- base::invokeRestart
[13:36:40.793]             length <- base::length
[13:36:40.793]             list <- base::list
[13:36:40.793]             seq.int <- base::seq.int
[13:36:40.793]             signalCondition <- base::signalCondition
[13:36:40.793]             sys.calls <- base::sys.calls
[13:36:40.793]             `[[` <- base::`[[`
[13:36:40.793]             `+` <- base::`+`
[13:36:40.793]             `<<-` <- base::`<<-`
[13:36:40.793]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:40.793]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:40.793]                   3L)]
[13:36:40.793]             }
[13:36:40.793]             function(cond) {
[13:36:40.793]                 is_error <- inherits(cond, "error")
[13:36:40.793]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:40.793]                   NULL)
[13:36:40.793]                 if (is_error) {
[13:36:40.793]                   sessionInformation <- function() {
[13:36:40.793]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:40.793]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:40.793]                       search = base::search(), system = base::Sys.info())
[13:36:40.793]                   }
[13:36:40.793]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.793]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:40.793]                     cond$call), session = sessionInformation(), 
[13:36:40.793]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:40.793]                   signalCondition(cond)
[13:36:40.793]                 }
[13:36:40.793]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:40.793]                 "immediateCondition"))) {
[13:36:40.793]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:40.793]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.793]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:40.793]                   if (TRUE && !signal) {
[13:36:40.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.793]                     {
[13:36:40.793]                       inherits <- base::inherits
[13:36:40.793]                       invokeRestart <- base::invokeRestart
[13:36:40.793]                       is.null <- base::is.null
[13:36:40.793]                       muffled <- FALSE
[13:36:40.793]                       if (inherits(cond, "message")) {
[13:36:40.793]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.793]                         if (muffled) 
[13:36:40.793]                           invokeRestart("muffleMessage")
[13:36:40.793]                       }
[13:36:40.793]                       else if (inherits(cond, "warning")) {
[13:36:40.793]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.793]                         if (muffled) 
[13:36:40.793]                           invokeRestart("muffleWarning")
[13:36:40.793]                       }
[13:36:40.793]                       else if (inherits(cond, "condition")) {
[13:36:40.793]                         if (!is.null(pattern)) {
[13:36:40.793]                           computeRestarts <- base::computeRestarts
[13:36:40.793]                           grepl <- base::grepl
[13:36:40.793]                           restarts <- computeRestarts(cond)
[13:36:40.793]                           for (restart in restarts) {
[13:36:40.793]                             name <- restart$name
[13:36:40.793]                             if (is.null(name)) 
[13:36:40.793]                               next
[13:36:40.793]                             if (!grepl(pattern, name)) 
[13:36:40.793]                               next
[13:36:40.793]                             invokeRestart(restart)
[13:36:40.793]                             muffled <- TRUE
[13:36:40.793]                             break
[13:36:40.793]                           }
[13:36:40.793]                         }
[13:36:40.793]                       }
[13:36:40.793]                       invisible(muffled)
[13:36:40.793]                     }
[13:36:40.793]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.793]                   }
[13:36:40.793]                 }
[13:36:40.793]                 else {
[13:36:40.793]                   if (TRUE) {
[13:36:40.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.793]                     {
[13:36:40.793]                       inherits <- base::inherits
[13:36:40.793]                       invokeRestart <- base::invokeRestart
[13:36:40.793]                       is.null <- base::is.null
[13:36:40.793]                       muffled <- FALSE
[13:36:40.793]                       if (inherits(cond, "message")) {
[13:36:40.793]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.793]                         if (muffled) 
[13:36:40.793]                           invokeRestart("muffleMessage")
[13:36:40.793]                       }
[13:36:40.793]                       else if (inherits(cond, "warning")) {
[13:36:40.793]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.793]                         if (muffled) 
[13:36:40.793]                           invokeRestart("muffleWarning")
[13:36:40.793]                       }
[13:36:40.793]                       else if (inherits(cond, "condition")) {
[13:36:40.793]                         if (!is.null(pattern)) {
[13:36:40.793]                           computeRestarts <- base::computeRestarts
[13:36:40.793]                           grepl <- base::grepl
[13:36:40.793]                           restarts <- computeRestarts(cond)
[13:36:40.793]                           for (restart in restarts) {
[13:36:40.793]                             name <- restart$name
[13:36:40.793]                             if (is.null(name)) 
[13:36:40.793]                               next
[13:36:40.793]                             if (!grepl(pattern, name)) 
[13:36:40.793]                               next
[13:36:40.793]                             invokeRestart(restart)
[13:36:40.793]                             muffled <- TRUE
[13:36:40.793]                             break
[13:36:40.793]                           }
[13:36:40.793]                         }
[13:36:40.793]                       }
[13:36:40.793]                       invisible(muffled)
[13:36:40.793]                     }
[13:36:40.793]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.793]                   }
[13:36:40.793]                 }
[13:36:40.793]             }
[13:36:40.793]         }))
[13:36:40.793]     }, error = function(ex) {
[13:36:40.793]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:40.793]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.793]                 ...future.rng), started = ...future.startTime, 
[13:36:40.793]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:40.793]             version = "1.8"), class = "FutureResult")
[13:36:40.793]     }, finally = {
[13:36:40.793]         if (!identical(...future.workdir, getwd())) 
[13:36:40.793]             setwd(...future.workdir)
[13:36:40.793]         {
[13:36:40.793]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:40.793]                 ...future.oldOptions$nwarnings <- NULL
[13:36:40.793]             }
[13:36:40.793]             base::options(...future.oldOptions)
[13:36:40.793]             if (.Platform$OS.type == "windows") {
[13:36:40.793]                 old_names <- names(...future.oldEnvVars)
[13:36:40.793]                 envs <- base::Sys.getenv()
[13:36:40.793]                 names <- names(envs)
[13:36:40.793]                 common <- intersect(names, old_names)
[13:36:40.793]                 added <- setdiff(names, old_names)
[13:36:40.793]                 removed <- setdiff(old_names, names)
[13:36:40.793]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:40.793]                   envs[common]]
[13:36:40.793]                 NAMES <- toupper(changed)
[13:36:40.793]                 args <- list()
[13:36:40.793]                 for (kk in seq_along(NAMES)) {
[13:36:40.793]                   name <- changed[[kk]]
[13:36:40.793]                   NAME <- NAMES[[kk]]
[13:36:40.793]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.793]                     next
[13:36:40.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.793]                 }
[13:36:40.793]                 NAMES <- toupper(added)
[13:36:40.793]                 for (kk in seq_along(NAMES)) {
[13:36:40.793]                   name <- added[[kk]]
[13:36:40.793]                   NAME <- NAMES[[kk]]
[13:36:40.793]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.793]                     next
[13:36:40.793]                   args[[name]] <- ""
[13:36:40.793]                 }
[13:36:40.793]                 NAMES <- toupper(removed)
[13:36:40.793]                 for (kk in seq_along(NAMES)) {
[13:36:40.793]                   name <- removed[[kk]]
[13:36:40.793]                   NAME <- NAMES[[kk]]
[13:36:40.793]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.793]                     next
[13:36:40.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.793]                 }
[13:36:40.793]                 if (length(args) > 0) 
[13:36:40.793]                   base::do.call(base::Sys.setenv, args = args)
[13:36:40.793]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:40.793]             }
[13:36:40.793]             else {
[13:36:40.793]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:40.793]             }
[13:36:40.793]             {
[13:36:40.793]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:40.793]                   0L) {
[13:36:40.793]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:40.793]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:40.793]                   base::options(opts)
[13:36:40.793]                 }
[13:36:40.793]                 {
[13:36:40.793]                   {
[13:36:40.793]                     NULL
[13:36:40.793]                     RNGkind("Mersenne-Twister")
[13:36:40.793]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:40.793]                       inherits = FALSE)
[13:36:40.793]                   }
[13:36:40.793]                   options(future.plan = NULL)
[13:36:40.793]                   if (is.na(NA_character_)) 
[13:36:40.793]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.793]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:40.793]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:40.793]                     .init = FALSE)
[13:36:40.793]                 }
[13:36:40.793]             }
[13:36:40.793]         }
[13:36:40.793]     })
[13:36:40.793]     if (TRUE) {
[13:36:40.793]         base::sink(type = "output", split = FALSE)
[13:36:40.793]         if (TRUE) {
[13:36:40.793]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:40.793]         }
[13:36:40.793]         else {
[13:36:40.793]             ...future.result["stdout"] <- base::list(NULL)
[13:36:40.793]         }
[13:36:40.793]         base::close(...future.stdout)
[13:36:40.793]         ...future.stdout <- NULL
[13:36:40.793]     }
[13:36:40.793]     ...future.result$conditions <- ...future.conditions
[13:36:40.793]     ...future.result$finished <- base::Sys.time()
[13:36:40.793]     ...future.result
[13:36:40.793] }
[13:36:40.794] assign_globals() ...
[13:36:40.794] List of 2
[13:36:40.794]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:36:40.794]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:36:40.794]  - attr(*, "where")=List of 2
[13:36:40.794]   ..$ weight:<environment: R_EmptyEnv> 
[13:36:40.794]   ..$ group :<environment: R_EmptyEnv> 
[13:36:40.794]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:40.794]  - attr(*, "resolved")= logi FALSE
[13:36:40.794]  - attr(*, "total_size")= num 896
[13:36:40.794]  - attr(*, "already-done")= logi TRUE
[13:36:40.797] - copied ‘weight’ to environment
[13:36:40.797] - copied ‘group’ to environment
[13:36:40.797] assign_globals() ... done
[13:36:40.798] plan(): Setting new future strategy stack:
[13:36:40.798] List of future strategies:
[13:36:40.798] 1. sequential:
[13:36:40.798]    - args: function (..., envir = parent.frame())
[13:36:40.798]    - tweaked: FALSE
[13:36:40.798]    - call: NULL
[13:36:40.798] plan(): nbrOfWorkers() = 1
[13:36:40.799] plan(): Setting new future strategy stack:
[13:36:40.800] List of future strategies:
[13:36:40.800] 1. sequential:
[13:36:40.800]    - args: function (..., envir = parent.frame())
[13:36:40.800]    - tweaked: FALSE
[13:36:40.800]    - call: plan(strategy)
[13:36:40.800] plan(): nbrOfWorkers() = 1
[13:36:40.800] SequentialFuture started (and completed)
[13:36:40.800] - Launch lazy future ... done
[13:36:40.800] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:36:40.803] getGlobalsAndPackages() ...
[13:36:40.803] Searching for globals...
[13:36:40.804] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:36:40.805] Searching for globals ... DONE
[13:36:40.805] Resolving globals: FALSE
[13:36:40.805] The total size of the 2 globals is 896 bytes (896 bytes)
[13:36:40.805] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:36:40.806] - globals: [2] ‘weight’, ‘group’
[13:36:40.806] - packages: [1] ‘stats’
[13:36:40.806] getGlobalsAndPackages() ... DONE
[13:36:40.806] run() for ‘Future’ ...
[13:36:40.806] - state: ‘created’
[13:36:40.806] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:40.806] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:40.807] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:40.807]   - Field: ‘label’
[13:36:40.807]   - Field: ‘local’
[13:36:40.807]   - Field: ‘owner’
[13:36:40.807]   - Field: ‘envir’
[13:36:40.807]   - Field: ‘packages’
[13:36:40.807]   - Field: ‘gc’
[13:36:40.807]   - Field: ‘conditions’
[13:36:40.807]   - Field: ‘expr’
[13:36:40.807]   - Field: ‘uuid’
[13:36:40.808]   - Field: ‘seed’
[13:36:40.808]   - Field: ‘version’
[13:36:40.808]   - Field: ‘result’
[13:36:40.808]   - Field: ‘asynchronous’
[13:36:40.808]   - Field: ‘calls’
[13:36:40.808]   - Field: ‘globals’
[13:36:40.808]   - Field: ‘stdout’
[13:36:40.808]   - Field: ‘earlySignal’
[13:36:40.808]   - Field: ‘lazy’
[13:36:40.808]   - Field: ‘state’
[13:36:40.808] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:40.808] - Launch lazy future ...
[13:36:40.809] Packages needed by the future expression (n = 1): ‘stats’
[13:36:40.809] Packages needed by future strategies (n = 0): <none>
[13:36:40.809] {
[13:36:40.809]     {
[13:36:40.809]         {
[13:36:40.809]             ...future.startTime <- base::Sys.time()
[13:36:40.809]             {
[13:36:40.809]                 {
[13:36:40.809]                   {
[13:36:40.809]                     {
[13:36:40.809]                       base::local({
[13:36:40.809]                         has_future <- base::requireNamespace("future", 
[13:36:40.809]                           quietly = TRUE)
[13:36:40.809]                         if (has_future) {
[13:36:40.809]                           ns <- base::getNamespace("future")
[13:36:40.809]                           version <- ns[[".package"]][["version"]]
[13:36:40.809]                           if (is.null(version)) 
[13:36:40.809]                             version <- utils::packageVersion("future")
[13:36:40.809]                         }
[13:36:40.809]                         else {
[13:36:40.809]                           version <- NULL
[13:36:40.809]                         }
[13:36:40.809]                         if (!has_future || version < "1.8.0") {
[13:36:40.809]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:40.809]                             "", base::R.version$version.string), 
[13:36:40.809]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:40.809]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:40.809]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:40.809]                               "release", "version")], collapse = " "), 
[13:36:40.809]                             hostname = base::Sys.info()[["nodename"]])
[13:36:40.809]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:40.809]                             info)
[13:36:40.809]                           info <- base::paste(info, collapse = "; ")
[13:36:40.809]                           if (!has_future) {
[13:36:40.809]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:40.809]                               info)
[13:36:40.809]                           }
[13:36:40.809]                           else {
[13:36:40.809]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:40.809]                               info, version)
[13:36:40.809]                           }
[13:36:40.809]                           base::stop(msg)
[13:36:40.809]                         }
[13:36:40.809]                       })
[13:36:40.809]                     }
[13:36:40.809]                     base::local({
[13:36:40.809]                       for (pkg in "stats") {
[13:36:40.809]                         base::loadNamespace(pkg)
[13:36:40.809]                         base::library(pkg, character.only = TRUE)
[13:36:40.809]                       }
[13:36:40.809]                     })
[13:36:40.809]                   }
[13:36:40.809]                   ...future.strategy.old <- future::plan("list")
[13:36:40.809]                   options(future.plan = NULL)
[13:36:40.809]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.809]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:40.809]                 }
[13:36:40.809]                 ...future.workdir <- getwd()
[13:36:40.809]             }
[13:36:40.809]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:40.809]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:40.809]         }
[13:36:40.809]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:40.809]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:40.809]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:40.809]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:40.809]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:40.809]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:40.809]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:40.809]             base::names(...future.oldOptions))
[13:36:40.809]     }
[13:36:40.809]     if (FALSE) {
[13:36:40.809]     }
[13:36:40.809]     else {
[13:36:40.809]         if (TRUE) {
[13:36:40.809]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:40.809]                 open = "w")
[13:36:40.809]         }
[13:36:40.809]         else {
[13:36:40.809]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:40.809]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:40.809]         }
[13:36:40.809]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:40.809]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:40.809]             base::sink(type = "output", split = FALSE)
[13:36:40.809]             base::close(...future.stdout)
[13:36:40.809]         }, add = TRUE)
[13:36:40.809]     }
[13:36:40.809]     ...future.frame <- base::sys.nframe()
[13:36:40.809]     ...future.conditions <- base::list()
[13:36:40.809]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:40.809]     if (FALSE) {
[13:36:40.809]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:40.809]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:40.809]     }
[13:36:40.809]     ...future.result <- base::tryCatch({
[13:36:40.809]         base::withCallingHandlers({
[13:36:40.809]             ...future.value <- base::withVisible(base::local({
[13:36:40.809]                 lm(weight ~ group - 1)
[13:36:40.809]             }))
[13:36:40.809]             future::FutureResult(value = ...future.value$value, 
[13:36:40.809]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.809]                   ...future.rng), globalenv = if (FALSE) 
[13:36:40.809]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:40.809]                     ...future.globalenv.names))
[13:36:40.809]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:40.809]         }, condition = base::local({
[13:36:40.809]             c <- base::c
[13:36:40.809]             inherits <- base::inherits
[13:36:40.809]             invokeRestart <- base::invokeRestart
[13:36:40.809]             length <- base::length
[13:36:40.809]             list <- base::list
[13:36:40.809]             seq.int <- base::seq.int
[13:36:40.809]             signalCondition <- base::signalCondition
[13:36:40.809]             sys.calls <- base::sys.calls
[13:36:40.809]             `[[` <- base::`[[`
[13:36:40.809]             `+` <- base::`+`
[13:36:40.809]             `<<-` <- base::`<<-`
[13:36:40.809]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:40.809]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:40.809]                   3L)]
[13:36:40.809]             }
[13:36:40.809]             function(cond) {
[13:36:40.809]                 is_error <- inherits(cond, "error")
[13:36:40.809]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:40.809]                   NULL)
[13:36:40.809]                 if (is_error) {
[13:36:40.809]                   sessionInformation <- function() {
[13:36:40.809]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:40.809]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:40.809]                       search = base::search(), system = base::Sys.info())
[13:36:40.809]                   }
[13:36:40.809]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.809]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:40.809]                     cond$call), session = sessionInformation(), 
[13:36:40.809]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:40.809]                   signalCondition(cond)
[13:36:40.809]                 }
[13:36:40.809]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:40.809]                 "immediateCondition"))) {
[13:36:40.809]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:40.809]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.809]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:40.809]                   if (TRUE && !signal) {
[13:36:40.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.809]                     {
[13:36:40.809]                       inherits <- base::inherits
[13:36:40.809]                       invokeRestart <- base::invokeRestart
[13:36:40.809]                       is.null <- base::is.null
[13:36:40.809]                       muffled <- FALSE
[13:36:40.809]                       if (inherits(cond, "message")) {
[13:36:40.809]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.809]                         if (muffled) 
[13:36:40.809]                           invokeRestart("muffleMessage")
[13:36:40.809]                       }
[13:36:40.809]                       else if (inherits(cond, "warning")) {
[13:36:40.809]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.809]                         if (muffled) 
[13:36:40.809]                           invokeRestart("muffleWarning")
[13:36:40.809]                       }
[13:36:40.809]                       else if (inherits(cond, "condition")) {
[13:36:40.809]                         if (!is.null(pattern)) {
[13:36:40.809]                           computeRestarts <- base::computeRestarts
[13:36:40.809]                           grepl <- base::grepl
[13:36:40.809]                           restarts <- computeRestarts(cond)
[13:36:40.809]                           for (restart in restarts) {
[13:36:40.809]                             name <- restart$name
[13:36:40.809]                             if (is.null(name)) 
[13:36:40.809]                               next
[13:36:40.809]                             if (!grepl(pattern, name)) 
[13:36:40.809]                               next
[13:36:40.809]                             invokeRestart(restart)
[13:36:40.809]                             muffled <- TRUE
[13:36:40.809]                             break
[13:36:40.809]                           }
[13:36:40.809]                         }
[13:36:40.809]                       }
[13:36:40.809]                       invisible(muffled)
[13:36:40.809]                     }
[13:36:40.809]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.809]                   }
[13:36:40.809]                 }
[13:36:40.809]                 else {
[13:36:40.809]                   if (TRUE) {
[13:36:40.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.809]                     {
[13:36:40.809]                       inherits <- base::inherits
[13:36:40.809]                       invokeRestart <- base::invokeRestart
[13:36:40.809]                       is.null <- base::is.null
[13:36:40.809]                       muffled <- FALSE
[13:36:40.809]                       if (inherits(cond, "message")) {
[13:36:40.809]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.809]                         if (muffled) 
[13:36:40.809]                           invokeRestart("muffleMessage")
[13:36:40.809]                       }
[13:36:40.809]                       else if (inherits(cond, "warning")) {
[13:36:40.809]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.809]                         if (muffled) 
[13:36:40.809]                           invokeRestart("muffleWarning")
[13:36:40.809]                       }
[13:36:40.809]                       else if (inherits(cond, "condition")) {
[13:36:40.809]                         if (!is.null(pattern)) {
[13:36:40.809]                           computeRestarts <- base::computeRestarts
[13:36:40.809]                           grepl <- base::grepl
[13:36:40.809]                           restarts <- computeRestarts(cond)
[13:36:40.809]                           for (restart in restarts) {
[13:36:40.809]                             name <- restart$name
[13:36:40.809]                             if (is.null(name)) 
[13:36:40.809]                               next
[13:36:40.809]                             if (!grepl(pattern, name)) 
[13:36:40.809]                               next
[13:36:40.809]                             invokeRestart(restart)
[13:36:40.809]                             muffled <- TRUE
[13:36:40.809]                             break
[13:36:40.809]                           }
[13:36:40.809]                         }
[13:36:40.809]                       }
[13:36:40.809]                       invisible(muffled)
[13:36:40.809]                     }
[13:36:40.809]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.809]                   }
[13:36:40.809]                 }
[13:36:40.809]             }
[13:36:40.809]         }))
[13:36:40.809]     }, error = function(ex) {
[13:36:40.809]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:40.809]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.809]                 ...future.rng), started = ...future.startTime, 
[13:36:40.809]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:40.809]             version = "1.8"), class = "FutureResult")
[13:36:40.809]     }, finally = {
[13:36:40.809]         if (!identical(...future.workdir, getwd())) 
[13:36:40.809]             setwd(...future.workdir)
[13:36:40.809]         {
[13:36:40.809]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:40.809]                 ...future.oldOptions$nwarnings <- NULL
[13:36:40.809]             }
[13:36:40.809]             base::options(...future.oldOptions)
[13:36:40.809]             if (.Platform$OS.type == "windows") {
[13:36:40.809]                 old_names <- names(...future.oldEnvVars)
[13:36:40.809]                 envs <- base::Sys.getenv()
[13:36:40.809]                 names <- names(envs)
[13:36:40.809]                 common <- intersect(names, old_names)
[13:36:40.809]                 added <- setdiff(names, old_names)
[13:36:40.809]                 removed <- setdiff(old_names, names)
[13:36:40.809]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:40.809]                   envs[common]]
[13:36:40.809]                 NAMES <- toupper(changed)
[13:36:40.809]                 args <- list()
[13:36:40.809]                 for (kk in seq_along(NAMES)) {
[13:36:40.809]                   name <- changed[[kk]]
[13:36:40.809]                   NAME <- NAMES[[kk]]
[13:36:40.809]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.809]                     next
[13:36:40.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.809]                 }
[13:36:40.809]                 NAMES <- toupper(added)
[13:36:40.809]                 for (kk in seq_along(NAMES)) {
[13:36:40.809]                   name <- added[[kk]]
[13:36:40.809]                   NAME <- NAMES[[kk]]
[13:36:40.809]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.809]                     next
[13:36:40.809]                   args[[name]] <- ""
[13:36:40.809]                 }
[13:36:40.809]                 NAMES <- toupper(removed)
[13:36:40.809]                 for (kk in seq_along(NAMES)) {
[13:36:40.809]                   name <- removed[[kk]]
[13:36:40.809]                   NAME <- NAMES[[kk]]
[13:36:40.809]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.809]                     next
[13:36:40.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.809]                 }
[13:36:40.809]                 if (length(args) > 0) 
[13:36:40.809]                   base::do.call(base::Sys.setenv, args = args)
[13:36:40.809]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:40.809]             }
[13:36:40.809]             else {
[13:36:40.809]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:40.809]             }
[13:36:40.809]             {
[13:36:40.809]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:40.809]                   0L) {
[13:36:40.809]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:40.809]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:40.809]                   base::options(opts)
[13:36:40.809]                 }
[13:36:40.809]                 {
[13:36:40.809]                   {
[13:36:40.809]                     NULL
[13:36:40.809]                     RNGkind("Mersenne-Twister")
[13:36:40.809]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:40.809]                       inherits = FALSE)
[13:36:40.809]                   }
[13:36:40.809]                   options(future.plan = NULL)
[13:36:40.809]                   if (is.na(NA_character_)) 
[13:36:40.809]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.809]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:40.809]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:40.809]                     .init = FALSE)
[13:36:40.809]                 }
[13:36:40.809]             }
[13:36:40.809]         }
[13:36:40.809]     })
[13:36:40.809]     if (TRUE) {
[13:36:40.809]         base::sink(type = "output", split = FALSE)
[13:36:40.809]         if (TRUE) {
[13:36:40.809]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:40.809]         }
[13:36:40.809]         else {
[13:36:40.809]             ...future.result["stdout"] <- base::list(NULL)
[13:36:40.809]         }
[13:36:40.809]         base::close(...future.stdout)
[13:36:40.809]         ...future.stdout <- NULL
[13:36:40.809]     }
[13:36:40.809]     ...future.result$conditions <- ...future.conditions
[13:36:40.809]     ...future.result$finished <- base::Sys.time()
[13:36:40.809]     ...future.result
[13:36:40.809] }
[13:36:40.811] assign_globals() ...
[13:36:40.811] List of 2
[13:36:40.811]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:36:40.811]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:36:40.811]  - attr(*, "where")=List of 2
[13:36:40.811]   ..$ weight:<environment: R_EmptyEnv> 
[13:36:40.811]   ..$ group :<environment: R_EmptyEnv> 
[13:36:40.811]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:40.811]  - attr(*, "resolved")= logi FALSE
[13:36:40.811]  - attr(*, "total_size")= num 896
[13:36:40.811]  - attr(*, "already-done")= logi TRUE
[13:36:40.814] - copied ‘weight’ to environment
[13:36:40.814] - copied ‘group’ to environment
[13:36:40.814] assign_globals() ... done
[13:36:40.814] plan(): Setting new future strategy stack:
[13:36:40.814] List of future strategies:
[13:36:40.814] 1. sequential:
[13:36:40.814]    - args: function (..., envir = parent.frame())
[13:36:40.814]    - tweaked: FALSE
[13:36:40.814]    - call: NULL
[13:36:40.815] plan(): nbrOfWorkers() = 1
[13:36:40.816] plan(): Setting new future strategy stack:
[13:36:40.816] List of future strategies:
[13:36:40.816] 1. sequential:
[13:36:40.816]    - args: function (..., envir = parent.frame())
[13:36:40.816]    - tweaked: FALSE
[13:36:40.816]    - call: plan(strategy)
[13:36:40.816] plan(): nbrOfWorkers() = 1
[13:36:40.817] SequentialFuture started (and completed)
[13:36:40.817] - Launch lazy future ... done
[13:36:40.817] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[13:36:40.818] getGlobalsAndPackages() ...
[13:36:40.818] Searching for globals...
[13:36:40.819] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[13:36:40.820] Searching for globals ... DONE
[13:36:40.820] Resolving globals: FALSE
[13:36:40.820] The total size of the 1 globals is 96 bytes (96 bytes)
[13:36:40.820] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[13:36:40.820] - globals: [1] ‘x’
[13:36:40.821] - packages: [1] ‘stats’
[13:36:40.821] getGlobalsAndPackages() ... DONE
[13:36:40.821] run() for ‘Future’ ...
[13:36:40.821] - state: ‘created’
[13:36:40.821] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:40.821] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:40.821] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:40.822]   - Field: ‘label’
[13:36:40.822]   - Field: ‘local’
[13:36:40.822]   - Field: ‘owner’
[13:36:40.822]   - Field: ‘envir’
[13:36:40.822]   - Field: ‘packages’
[13:36:40.822]   - Field: ‘gc’
[13:36:40.822]   - Field: ‘conditions’
[13:36:40.822]   - Field: ‘expr’
[13:36:40.822]   - Field: ‘uuid’
[13:36:40.822]   - Field: ‘seed’
[13:36:40.823]   - Field: ‘version’
[13:36:40.823]   - Field: ‘result’
[13:36:40.824]   - Field: ‘asynchronous’
[13:36:40.824]   - Field: ‘calls’
[13:36:40.824]   - Field: ‘globals’
[13:36:40.824]   - Field: ‘stdout’
[13:36:40.824]   - Field: ‘earlySignal’
[13:36:40.824]   - Field: ‘lazy’
[13:36:40.824]   - Field: ‘state’
[13:36:40.824] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:40.824] - Launch lazy future ...
[13:36:40.824] Packages needed by the future expression (n = 1): ‘stats’
[13:36:40.825] Packages needed by future strategies (n = 0): <none>
[13:36:40.825] {
[13:36:40.825]     {
[13:36:40.825]         {
[13:36:40.825]             ...future.startTime <- base::Sys.time()
[13:36:40.825]             {
[13:36:40.825]                 {
[13:36:40.825]                   {
[13:36:40.825]                     {
[13:36:40.825]                       base::local({
[13:36:40.825]                         has_future <- base::requireNamespace("future", 
[13:36:40.825]                           quietly = TRUE)
[13:36:40.825]                         if (has_future) {
[13:36:40.825]                           ns <- base::getNamespace("future")
[13:36:40.825]                           version <- ns[[".package"]][["version"]]
[13:36:40.825]                           if (is.null(version)) 
[13:36:40.825]                             version <- utils::packageVersion("future")
[13:36:40.825]                         }
[13:36:40.825]                         else {
[13:36:40.825]                           version <- NULL
[13:36:40.825]                         }
[13:36:40.825]                         if (!has_future || version < "1.8.0") {
[13:36:40.825]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:40.825]                             "", base::R.version$version.string), 
[13:36:40.825]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:40.825]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:40.825]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:40.825]                               "release", "version")], collapse = " "), 
[13:36:40.825]                             hostname = base::Sys.info()[["nodename"]])
[13:36:40.825]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:40.825]                             info)
[13:36:40.825]                           info <- base::paste(info, collapse = "; ")
[13:36:40.825]                           if (!has_future) {
[13:36:40.825]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:40.825]                               info)
[13:36:40.825]                           }
[13:36:40.825]                           else {
[13:36:40.825]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:40.825]                               info, version)
[13:36:40.825]                           }
[13:36:40.825]                           base::stop(msg)
[13:36:40.825]                         }
[13:36:40.825]                       })
[13:36:40.825]                     }
[13:36:40.825]                     base::local({
[13:36:40.825]                       for (pkg in "stats") {
[13:36:40.825]                         base::loadNamespace(pkg)
[13:36:40.825]                         base::library(pkg, character.only = TRUE)
[13:36:40.825]                       }
[13:36:40.825]                     })
[13:36:40.825]                   }
[13:36:40.825]                   ...future.strategy.old <- future::plan("list")
[13:36:40.825]                   options(future.plan = NULL)
[13:36:40.825]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.825]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:40.825]                 }
[13:36:40.825]                 ...future.workdir <- getwd()
[13:36:40.825]             }
[13:36:40.825]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:40.825]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:40.825]         }
[13:36:40.825]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:40.825]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:40.825]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:40.825]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:40.825]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:40.825]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:40.825]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:40.825]             base::names(...future.oldOptions))
[13:36:40.825]     }
[13:36:40.825]     if (FALSE) {
[13:36:40.825]     }
[13:36:40.825]     else {
[13:36:40.825]         if (TRUE) {
[13:36:40.825]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:40.825]                 open = "w")
[13:36:40.825]         }
[13:36:40.825]         else {
[13:36:40.825]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:40.825]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:40.825]         }
[13:36:40.825]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:40.825]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:40.825]             base::sink(type = "output", split = FALSE)
[13:36:40.825]             base::close(...future.stdout)
[13:36:40.825]         }, add = TRUE)
[13:36:40.825]     }
[13:36:40.825]     ...future.frame <- base::sys.nframe()
[13:36:40.825]     ...future.conditions <- base::list()
[13:36:40.825]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:40.825]     if (FALSE) {
[13:36:40.825]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:40.825]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:40.825]     }
[13:36:40.825]     ...future.result <- base::tryCatch({
[13:36:40.825]         base::withCallingHandlers({
[13:36:40.825]             ...future.value <- base::withVisible(base::local({
[13:36:40.825]                 xtabs(~x)
[13:36:40.825]             }))
[13:36:40.825]             future::FutureResult(value = ...future.value$value, 
[13:36:40.825]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.825]                   ...future.rng), globalenv = if (FALSE) 
[13:36:40.825]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:40.825]                     ...future.globalenv.names))
[13:36:40.825]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:40.825]         }, condition = base::local({
[13:36:40.825]             c <- base::c
[13:36:40.825]             inherits <- base::inherits
[13:36:40.825]             invokeRestart <- base::invokeRestart
[13:36:40.825]             length <- base::length
[13:36:40.825]             list <- base::list
[13:36:40.825]             seq.int <- base::seq.int
[13:36:40.825]             signalCondition <- base::signalCondition
[13:36:40.825]             sys.calls <- base::sys.calls
[13:36:40.825]             `[[` <- base::`[[`
[13:36:40.825]             `+` <- base::`+`
[13:36:40.825]             `<<-` <- base::`<<-`
[13:36:40.825]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:40.825]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:40.825]                   3L)]
[13:36:40.825]             }
[13:36:40.825]             function(cond) {
[13:36:40.825]                 is_error <- inherits(cond, "error")
[13:36:40.825]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:40.825]                   NULL)
[13:36:40.825]                 if (is_error) {
[13:36:40.825]                   sessionInformation <- function() {
[13:36:40.825]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:40.825]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:40.825]                       search = base::search(), system = base::Sys.info())
[13:36:40.825]                   }
[13:36:40.825]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.825]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:40.825]                     cond$call), session = sessionInformation(), 
[13:36:40.825]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:40.825]                   signalCondition(cond)
[13:36:40.825]                 }
[13:36:40.825]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:40.825]                 "immediateCondition"))) {
[13:36:40.825]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:40.825]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.825]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:40.825]                   if (TRUE && !signal) {
[13:36:40.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.825]                     {
[13:36:40.825]                       inherits <- base::inherits
[13:36:40.825]                       invokeRestart <- base::invokeRestart
[13:36:40.825]                       is.null <- base::is.null
[13:36:40.825]                       muffled <- FALSE
[13:36:40.825]                       if (inherits(cond, "message")) {
[13:36:40.825]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.825]                         if (muffled) 
[13:36:40.825]                           invokeRestart("muffleMessage")
[13:36:40.825]                       }
[13:36:40.825]                       else if (inherits(cond, "warning")) {
[13:36:40.825]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.825]                         if (muffled) 
[13:36:40.825]                           invokeRestart("muffleWarning")
[13:36:40.825]                       }
[13:36:40.825]                       else if (inherits(cond, "condition")) {
[13:36:40.825]                         if (!is.null(pattern)) {
[13:36:40.825]                           computeRestarts <- base::computeRestarts
[13:36:40.825]                           grepl <- base::grepl
[13:36:40.825]                           restarts <- computeRestarts(cond)
[13:36:40.825]                           for (restart in restarts) {
[13:36:40.825]                             name <- restart$name
[13:36:40.825]                             if (is.null(name)) 
[13:36:40.825]                               next
[13:36:40.825]                             if (!grepl(pattern, name)) 
[13:36:40.825]                               next
[13:36:40.825]                             invokeRestart(restart)
[13:36:40.825]                             muffled <- TRUE
[13:36:40.825]                             break
[13:36:40.825]                           }
[13:36:40.825]                         }
[13:36:40.825]                       }
[13:36:40.825]                       invisible(muffled)
[13:36:40.825]                     }
[13:36:40.825]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.825]                   }
[13:36:40.825]                 }
[13:36:40.825]                 else {
[13:36:40.825]                   if (TRUE) {
[13:36:40.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.825]                     {
[13:36:40.825]                       inherits <- base::inherits
[13:36:40.825]                       invokeRestart <- base::invokeRestart
[13:36:40.825]                       is.null <- base::is.null
[13:36:40.825]                       muffled <- FALSE
[13:36:40.825]                       if (inherits(cond, "message")) {
[13:36:40.825]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.825]                         if (muffled) 
[13:36:40.825]                           invokeRestart("muffleMessage")
[13:36:40.825]                       }
[13:36:40.825]                       else if (inherits(cond, "warning")) {
[13:36:40.825]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.825]                         if (muffled) 
[13:36:40.825]                           invokeRestart("muffleWarning")
[13:36:40.825]                       }
[13:36:40.825]                       else if (inherits(cond, "condition")) {
[13:36:40.825]                         if (!is.null(pattern)) {
[13:36:40.825]                           computeRestarts <- base::computeRestarts
[13:36:40.825]                           grepl <- base::grepl
[13:36:40.825]                           restarts <- computeRestarts(cond)
[13:36:40.825]                           for (restart in restarts) {
[13:36:40.825]                             name <- restart$name
[13:36:40.825]                             if (is.null(name)) 
[13:36:40.825]                               next
[13:36:40.825]                             if (!grepl(pattern, name)) 
[13:36:40.825]                               next
[13:36:40.825]                             invokeRestart(restart)
[13:36:40.825]                             muffled <- TRUE
[13:36:40.825]                             break
[13:36:40.825]                           }
[13:36:40.825]                         }
[13:36:40.825]                       }
[13:36:40.825]                       invisible(muffled)
[13:36:40.825]                     }
[13:36:40.825]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.825]                   }
[13:36:40.825]                 }
[13:36:40.825]             }
[13:36:40.825]         }))
[13:36:40.825]     }, error = function(ex) {
[13:36:40.825]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:40.825]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.825]                 ...future.rng), started = ...future.startTime, 
[13:36:40.825]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:40.825]             version = "1.8"), class = "FutureResult")
[13:36:40.825]     }, finally = {
[13:36:40.825]         if (!identical(...future.workdir, getwd())) 
[13:36:40.825]             setwd(...future.workdir)
[13:36:40.825]         {
[13:36:40.825]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:40.825]                 ...future.oldOptions$nwarnings <- NULL
[13:36:40.825]             }
[13:36:40.825]             base::options(...future.oldOptions)
[13:36:40.825]             if (.Platform$OS.type == "windows") {
[13:36:40.825]                 old_names <- names(...future.oldEnvVars)
[13:36:40.825]                 envs <- base::Sys.getenv()
[13:36:40.825]                 names <- names(envs)
[13:36:40.825]                 common <- intersect(names, old_names)
[13:36:40.825]                 added <- setdiff(names, old_names)
[13:36:40.825]                 removed <- setdiff(old_names, names)
[13:36:40.825]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:40.825]                   envs[common]]
[13:36:40.825]                 NAMES <- toupper(changed)
[13:36:40.825]                 args <- list()
[13:36:40.825]                 for (kk in seq_along(NAMES)) {
[13:36:40.825]                   name <- changed[[kk]]
[13:36:40.825]                   NAME <- NAMES[[kk]]
[13:36:40.825]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.825]                     next
[13:36:40.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.825]                 }
[13:36:40.825]                 NAMES <- toupper(added)
[13:36:40.825]                 for (kk in seq_along(NAMES)) {
[13:36:40.825]                   name <- added[[kk]]
[13:36:40.825]                   NAME <- NAMES[[kk]]
[13:36:40.825]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.825]                     next
[13:36:40.825]                   args[[name]] <- ""
[13:36:40.825]                 }
[13:36:40.825]                 NAMES <- toupper(removed)
[13:36:40.825]                 for (kk in seq_along(NAMES)) {
[13:36:40.825]                   name <- removed[[kk]]
[13:36:40.825]                   NAME <- NAMES[[kk]]
[13:36:40.825]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.825]                     next
[13:36:40.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.825]                 }
[13:36:40.825]                 if (length(args) > 0) 
[13:36:40.825]                   base::do.call(base::Sys.setenv, args = args)
[13:36:40.825]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:40.825]             }
[13:36:40.825]             else {
[13:36:40.825]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:40.825]             }
[13:36:40.825]             {
[13:36:40.825]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:40.825]                   0L) {
[13:36:40.825]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:40.825]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:40.825]                   base::options(opts)
[13:36:40.825]                 }
[13:36:40.825]                 {
[13:36:40.825]                   {
[13:36:40.825]                     NULL
[13:36:40.825]                     RNGkind("Mersenne-Twister")
[13:36:40.825]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:40.825]                       inherits = FALSE)
[13:36:40.825]                   }
[13:36:40.825]                   options(future.plan = NULL)
[13:36:40.825]                   if (is.na(NA_character_)) 
[13:36:40.825]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.825]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:40.825]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:40.825]                     .init = FALSE)
[13:36:40.825]                 }
[13:36:40.825]             }
[13:36:40.825]         }
[13:36:40.825]     })
[13:36:40.825]     if (TRUE) {
[13:36:40.825]         base::sink(type = "output", split = FALSE)
[13:36:40.825]         if (TRUE) {
[13:36:40.825]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:40.825]         }
[13:36:40.825]         else {
[13:36:40.825]             ...future.result["stdout"] <- base::list(NULL)
[13:36:40.825]         }
[13:36:40.825]         base::close(...future.stdout)
[13:36:40.825]         ...future.stdout <- NULL
[13:36:40.825]     }
[13:36:40.825]     ...future.result$conditions <- ...future.conditions
[13:36:40.825]     ...future.result$finished <- base::Sys.time()
[13:36:40.825]     ...future.result
[13:36:40.825] }
[13:36:40.827] assign_globals() ...
[13:36:40.827] List of 1
[13:36:40.827]  $ x: num [1:5] 1 1 2 2 2
[13:36:40.827]  - attr(*, "where")=List of 1
[13:36:40.827]   ..$ x:<environment: R_EmptyEnv> 
[13:36:40.827]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:40.827]  - attr(*, "resolved")= logi FALSE
[13:36:40.827]  - attr(*, "total_size")= num 96
[13:36:40.827]  - attr(*, "already-done")= logi TRUE
[13:36:40.829] - copied ‘x’ to environment
[13:36:40.829] assign_globals() ... done
[13:36:40.829] plan(): Setting new future strategy stack:
[13:36:40.829] List of future strategies:
[13:36:40.829] 1. sequential:
[13:36:40.829]    - args: function (..., envir = parent.frame())
[13:36:40.829]    - tweaked: FALSE
[13:36:40.829]    - call: NULL
[13:36:40.830] plan(): nbrOfWorkers() = 1
[13:36:40.831] plan(): Setting new future strategy stack:
[13:36:40.831] List of future strategies:
[13:36:40.831] 1. sequential:
[13:36:40.831]    - args: function (..., envir = parent.frame())
[13:36:40.831]    - tweaked: FALSE
[13:36:40.831]    - call: plan(strategy)
[13:36:40.831] plan(): nbrOfWorkers() = 1
[13:36:40.831] SequentialFuture started (and completed)
[13:36:40.831] - Launch lazy future ... done
[13:36:40.832] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
[13:36:40.832] getGlobalsAndPackages() ...
[13:36:40.832] Searching for globals...
[13:36:40.833] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[13:36:40.833] Searching for globals ... DONE
[13:36:40.833] Resolving globals: FALSE
[13:36:40.834] The total size of the 1 globals is 96 bytes (96 bytes)
[13:36:40.834] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[13:36:40.834] - globals: [1] ‘x’
[13:36:40.834] - packages: [1] ‘stats’
[13:36:40.834] getGlobalsAndPackages() ... DONE
[13:36:40.835] run() for ‘Future’ ...
[13:36:40.835] - state: ‘created’
[13:36:40.835] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:40.835] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:40.835] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:40.835]   - Field: ‘label’
[13:36:40.835]   - Field: ‘local’
[13:36:40.836]   - Field: ‘owner’
[13:36:40.836]   - Field: ‘envir’
[13:36:40.836]   - Field: ‘packages’
[13:36:40.836]   - Field: ‘gc’
[13:36:40.836]   - Field: ‘conditions’
[13:36:40.836]   - Field: ‘expr’
[13:36:40.836]   - Field: ‘uuid’
[13:36:40.836]   - Field: ‘seed’
[13:36:40.836]   - Field: ‘version’
[13:36:40.836]   - Field: ‘result’
[13:36:40.836]   - Field: ‘asynchronous’
[13:36:40.837]   - Field: ‘calls’
[13:36:40.837]   - Field: ‘globals’
[13:36:40.837]   - Field: ‘stdout’
[13:36:40.837]   - Field: ‘earlySignal’
[13:36:40.837]   - Field: ‘lazy’
[13:36:40.837]   - Field: ‘state’
[13:36:40.837] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:40.837] - Launch lazy future ...
[13:36:40.837] Packages needed by the future expression (n = 1): ‘stats’
[13:36:40.837] Packages needed by future strategies (n = 0): <none>
[13:36:40.838] {
[13:36:40.838]     {
[13:36:40.838]         {
[13:36:40.838]             ...future.startTime <- base::Sys.time()
[13:36:40.838]             {
[13:36:40.838]                 {
[13:36:40.838]                   {
[13:36:40.838]                     {
[13:36:40.838]                       base::local({
[13:36:40.838]                         has_future <- base::requireNamespace("future", 
[13:36:40.838]                           quietly = TRUE)
[13:36:40.838]                         if (has_future) {
[13:36:40.838]                           ns <- base::getNamespace("future")
[13:36:40.838]                           version <- ns[[".package"]][["version"]]
[13:36:40.838]                           if (is.null(version)) 
[13:36:40.838]                             version <- utils::packageVersion("future")
[13:36:40.838]                         }
[13:36:40.838]                         else {
[13:36:40.838]                           version <- NULL
[13:36:40.838]                         }
[13:36:40.838]                         if (!has_future || version < "1.8.0") {
[13:36:40.838]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:40.838]                             "", base::R.version$version.string), 
[13:36:40.838]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:40.838]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:40.838]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:40.838]                               "release", "version")], collapse = " "), 
[13:36:40.838]                             hostname = base::Sys.info()[["nodename"]])
[13:36:40.838]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:40.838]                             info)
[13:36:40.838]                           info <- base::paste(info, collapse = "; ")
[13:36:40.838]                           if (!has_future) {
[13:36:40.838]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:40.838]                               info)
[13:36:40.838]                           }
[13:36:40.838]                           else {
[13:36:40.838]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:40.838]                               info, version)
[13:36:40.838]                           }
[13:36:40.838]                           base::stop(msg)
[13:36:40.838]                         }
[13:36:40.838]                       })
[13:36:40.838]                     }
[13:36:40.838]                     base::local({
[13:36:40.838]                       for (pkg in "stats") {
[13:36:40.838]                         base::loadNamespace(pkg)
[13:36:40.838]                         base::library(pkg, character.only = TRUE)
[13:36:40.838]                       }
[13:36:40.838]                     })
[13:36:40.838]                   }
[13:36:40.838]                   ...future.strategy.old <- future::plan("list")
[13:36:40.838]                   options(future.plan = NULL)
[13:36:40.838]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.838]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:40.838]                 }
[13:36:40.838]                 ...future.workdir <- getwd()
[13:36:40.838]             }
[13:36:40.838]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:40.838]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:40.838]         }
[13:36:40.838]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:40.838]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:40.838]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:40.838]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:40.838]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:40.838]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:40.838]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:40.838]             base::names(...future.oldOptions))
[13:36:40.838]     }
[13:36:40.838]     if (FALSE) {
[13:36:40.838]     }
[13:36:40.838]     else {
[13:36:40.838]         if (TRUE) {
[13:36:40.838]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:40.838]                 open = "w")
[13:36:40.838]         }
[13:36:40.838]         else {
[13:36:40.838]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:40.838]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:40.838]         }
[13:36:40.838]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:40.838]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:40.838]             base::sink(type = "output", split = FALSE)
[13:36:40.838]             base::close(...future.stdout)
[13:36:40.838]         }, add = TRUE)
[13:36:40.838]     }
[13:36:40.838]     ...future.frame <- base::sys.nframe()
[13:36:40.838]     ...future.conditions <- base::list()
[13:36:40.838]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:40.838]     if (FALSE) {
[13:36:40.838]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:40.838]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:40.838]     }
[13:36:40.838]     ...future.result <- base::tryCatch({
[13:36:40.838]         base::withCallingHandlers({
[13:36:40.838]             ...future.value <- base::withVisible(base::local({
[13:36:40.838]                 xtabs(~x)
[13:36:40.838]             }))
[13:36:40.838]             future::FutureResult(value = ...future.value$value, 
[13:36:40.838]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.838]                   ...future.rng), globalenv = if (FALSE) 
[13:36:40.838]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:40.838]                     ...future.globalenv.names))
[13:36:40.838]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:40.838]         }, condition = base::local({
[13:36:40.838]             c <- base::c
[13:36:40.838]             inherits <- base::inherits
[13:36:40.838]             invokeRestart <- base::invokeRestart
[13:36:40.838]             length <- base::length
[13:36:40.838]             list <- base::list
[13:36:40.838]             seq.int <- base::seq.int
[13:36:40.838]             signalCondition <- base::signalCondition
[13:36:40.838]             sys.calls <- base::sys.calls
[13:36:40.838]             `[[` <- base::`[[`
[13:36:40.838]             `+` <- base::`+`
[13:36:40.838]             `<<-` <- base::`<<-`
[13:36:40.838]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:40.838]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:40.838]                   3L)]
[13:36:40.838]             }
[13:36:40.838]             function(cond) {
[13:36:40.838]                 is_error <- inherits(cond, "error")
[13:36:40.838]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:40.838]                   NULL)
[13:36:40.838]                 if (is_error) {
[13:36:40.838]                   sessionInformation <- function() {
[13:36:40.838]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:40.838]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:40.838]                       search = base::search(), system = base::Sys.info())
[13:36:40.838]                   }
[13:36:40.838]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.838]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:40.838]                     cond$call), session = sessionInformation(), 
[13:36:40.838]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:40.838]                   signalCondition(cond)
[13:36:40.838]                 }
[13:36:40.838]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:40.838]                 "immediateCondition"))) {
[13:36:40.838]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:40.838]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.838]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:40.838]                   if (TRUE && !signal) {
[13:36:40.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.838]                     {
[13:36:40.838]                       inherits <- base::inherits
[13:36:40.838]                       invokeRestart <- base::invokeRestart
[13:36:40.838]                       is.null <- base::is.null
[13:36:40.838]                       muffled <- FALSE
[13:36:40.838]                       if (inherits(cond, "message")) {
[13:36:40.838]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.838]                         if (muffled) 
[13:36:40.838]                           invokeRestart("muffleMessage")
[13:36:40.838]                       }
[13:36:40.838]                       else if (inherits(cond, "warning")) {
[13:36:40.838]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.838]                         if (muffled) 
[13:36:40.838]                           invokeRestart("muffleWarning")
[13:36:40.838]                       }
[13:36:40.838]                       else if (inherits(cond, "condition")) {
[13:36:40.838]                         if (!is.null(pattern)) {
[13:36:40.838]                           computeRestarts <- base::computeRestarts
[13:36:40.838]                           grepl <- base::grepl
[13:36:40.838]                           restarts <- computeRestarts(cond)
[13:36:40.838]                           for (restart in restarts) {
[13:36:40.838]                             name <- restart$name
[13:36:40.838]                             if (is.null(name)) 
[13:36:40.838]                               next
[13:36:40.838]                             if (!grepl(pattern, name)) 
[13:36:40.838]                               next
[13:36:40.838]                             invokeRestart(restart)
[13:36:40.838]                             muffled <- TRUE
[13:36:40.838]                             break
[13:36:40.838]                           }
[13:36:40.838]                         }
[13:36:40.838]                       }
[13:36:40.838]                       invisible(muffled)
[13:36:40.838]                     }
[13:36:40.838]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.838]                   }
[13:36:40.838]                 }
[13:36:40.838]                 else {
[13:36:40.838]                   if (TRUE) {
[13:36:40.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.838]                     {
[13:36:40.838]                       inherits <- base::inherits
[13:36:40.838]                       invokeRestart <- base::invokeRestart
[13:36:40.838]                       is.null <- base::is.null
[13:36:40.838]                       muffled <- FALSE
[13:36:40.838]                       if (inherits(cond, "message")) {
[13:36:40.838]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.838]                         if (muffled) 
[13:36:40.838]                           invokeRestart("muffleMessage")
[13:36:40.838]                       }
[13:36:40.838]                       else if (inherits(cond, "warning")) {
[13:36:40.838]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.838]                         if (muffled) 
[13:36:40.838]                           invokeRestart("muffleWarning")
[13:36:40.838]                       }
[13:36:40.838]                       else if (inherits(cond, "condition")) {
[13:36:40.838]                         if (!is.null(pattern)) {
[13:36:40.838]                           computeRestarts <- base::computeRestarts
[13:36:40.838]                           grepl <- base::grepl
[13:36:40.838]                           restarts <- computeRestarts(cond)
[13:36:40.838]                           for (restart in restarts) {
[13:36:40.838]                             name <- restart$name
[13:36:40.838]                             if (is.null(name)) 
[13:36:40.838]                               next
[13:36:40.838]                             if (!grepl(pattern, name)) 
[13:36:40.838]                               next
[13:36:40.838]                             invokeRestart(restart)
[13:36:40.838]                             muffled <- TRUE
[13:36:40.838]                             break
[13:36:40.838]                           }
[13:36:40.838]                         }
[13:36:40.838]                       }
[13:36:40.838]                       invisible(muffled)
[13:36:40.838]                     }
[13:36:40.838]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.838]                   }
[13:36:40.838]                 }
[13:36:40.838]             }
[13:36:40.838]         }))
[13:36:40.838]     }, error = function(ex) {
[13:36:40.838]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:40.838]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.838]                 ...future.rng), started = ...future.startTime, 
[13:36:40.838]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:40.838]             version = "1.8"), class = "FutureResult")
[13:36:40.838]     }, finally = {
[13:36:40.838]         if (!identical(...future.workdir, getwd())) 
[13:36:40.838]             setwd(...future.workdir)
[13:36:40.838]         {
[13:36:40.838]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:40.838]                 ...future.oldOptions$nwarnings <- NULL
[13:36:40.838]             }
[13:36:40.838]             base::options(...future.oldOptions)
[13:36:40.838]             if (.Platform$OS.type == "windows") {
[13:36:40.838]                 old_names <- names(...future.oldEnvVars)
[13:36:40.838]                 envs <- base::Sys.getenv()
[13:36:40.838]                 names <- names(envs)
[13:36:40.838]                 common <- intersect(names, old_names)
[13:36:40.838]                 added <- setdiff(names, old_names)
[13:36:40.838]                 removed <- setdiff(old_names, names)
[13:36:40.838]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:40.838]                   envs[common]]
[13:36:40.838]                 NAMES <- toupper(changed)
[13:36:40.838]                 args <- list()
[13:36:40.838]                 for (kk in seq_along(NAMES)) {
[13:36:40.838]                   name <- changed[[kk]]
[13:36:40.838]                   NAME <- NAMES[[kk]]
[13:36:40.838]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.838]                     next
[13:36:40.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.838]                 }
[13:36:40.838]                 NAMES <- toupper(added)
[13:36:40.838]                 for (kk in seq_along(NAMES)) {
[13:36:40.838]                   name <- added[[kk]]
[13:36:40.838]                   NAME <- NAMES[[kk]]
[13:36:40.838]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.838]                     next
[13:36:40.838]                   args[[name]] <- ""
[13:36:40.838]                 }
[13:36:40.838]                 NAMES <- toupper(removed)
[13:36:40.838]                 for (kk in seq_along(NAMES)) {
[13:36:40.838]                   name <- removed[[kk]]
[13:36:40.838]                   NAME <- NAMES[[kk]]
[13:36:40.838]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.838]                     next
[13:36:40.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.838]                 }
[13:36:40.838]                 if (length(args) > 0) 
[13:36:40.838]                   base::do.call(base::Sys.setenv, args = args)
[13:36:40.838]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:40.838]             }
[13:36:40.838]             else {
[13:36:40.838]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:40.838]             }
[13:36:40.838]             {
[13:36:40.838]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:40.838]                   0L) {
[13:36:40.838]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:40.838]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:40.838]                   base::options(opts)
[13:36:40.838]                 }
[13:36:40.838]                 {
[13:36:40.838]                   {
[13:36:40.838]                     NULL
[13:36:40.838]                     RNGkind("Mersenne-Twister")
[13:36:40.838]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:40.838]                       inherits = FALSE)
[13:36:40.838]                   }
[13:36:40.838]                   options(future.plan = NULL)
[13:36:40.838]                   if (is.na(NA_character_)) 
[13:36:40.838]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.838]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:40.838]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:40.838]                     .init = FALSE)
[13:36:40.838]                 }
[13:36:40.838]             }
[13:36:40.838]         }
[13:36:40.838]     })
[13:36:40.838]     if (TRUE) {
[13:36:40.838]         base::sink(type = "output", split = FALSE)
[13:36:40.838]         if (TRUE) {
[13:36:40.838]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:40.838]         }
[13:36:40.838]         else {
[13:36:40.838]             ...future.result["stdout"] <- base::list(NULL)
[13:36:40.838]         }
[13:36:40.838]         base::close(...future.stdout)
[13:36:40.838]         ...future.stdout <- NULL
[13:36:40.838]     }
[13:36:40.838]     ...future.result$conditions <- ...future.conditions
[13:36:40.838]     ...future.result$finished <- base::Sys.time()
[13:36:40.838]     ...future.result
[13:36:40.838] }
[13:36:40.839] assign_globals() ...
[13:36:40.840] List of 1
[13:36:40.840]  $ x: num [1:5] 1 1 2 2 2
[13:36:40.840]  - attr(*, "where")=List of 1
[13:36:40.840]   ..$ x:<environment: R_EmptyEnv> 
[13:36:40.840]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:40.840]  - attr(*, "resolved")= logi FALSE
[13:36:40.840]  - attr(*, "total_size")= num 96
[13:36:40.840]  - attr(*, "already-done")= logi TRUE
[13:36:40.842] - copied ‘x’ to environment
[13:36:40.842] assign_globals() ... done
[13:36:40.842] plan(): Setting new future strategy stack:
[13:36:40.842] List of future strategies:
[13:36:40.842] 1. sequential:
[13:36:40.842]    - args: function (..., envir = parent.frame())
[13:36:40.842]    - tweaked: FALSE
[13:36:40.842]    - call: NULL
[13:36:40.843] plan(): nbrOfWorkers() = 1
[13:36:40.844] plan(): Setting new future strategy stack:
[13:36:40.844] List of future strategies:
[13:36:40.844] 1. sequential:
[13:36:40.844]    - args: function (..., envir = parent.frame())
[13:36:40.844]    - tweaked: FALSE
[13:36:40.844]    - call: plan(strategy)
[13:36:40.844] plan(): nbrOfWorkers() = 1
[13:36:40.844] SequentialFuture started (and completed)
[13:36:40.844] - Launch lazy future ... done
[13:36:40.844] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[13:36:40.846] getGlobalsAndPackages() ...
[13:36:40.846] Searching for globals...
[13:36:40.849] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[13:36:40.849] Searching for globals ... DONE
[13:36:40.849] Resolving globals: FALSE
[13:36:40.849] 
[13:36:40.850] - packages: [2] ‘stats’, ‘datasets’
[13:36:40.850] getGlobalsAndPackages() ... DONE
[13:36:40.850] run() for ‘Future’ ...
[13:36:40.850] - state: ‘created’
[13:36:40.850] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:40.850] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:40.850] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:40.851]   - Field: ‘label’
[13:36:40.851]   - Field: ‘local’
[13:36:40.851]   - Field: ‘owner’
[13:36:40.851]   - Field: ‘envir’
[13:36:40.851]   - Field: ‘packages’
[13:36:40.851]   - Field: ‘gc’
[13:36:40.851]   - Field: ‘conditions’
[13:36:40.851]   - Field: ‘expr’
[13:36:40.851]   - Field: ‘uuid’
[13:36:40.851]   - Field: ‘seed’
[13:36:40.851]   - Field: ‘version’
[13:36:40.852]   - Field: ‘result’
[13:36:40.852]   - Field: ‘asynchronous’
[13:36:40.852]   - Field: ‘calls’
[13:36:40.852]   - Field: ‘globals’
[13:36:40.852]   - Field: ‘stdout’
[13:36:40.852]   - Field: ‘earlySignal’
[13:36:40.852]   - Field: ‘lazy’
[13:36:40.852]   - Field: ‘state’
[13:36:40.852] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:40.852] - Launch lazy future ...
[13:36:40.853] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:36:40.853] Packages needed by future strategies (n = 0): <none>
[13:36:40.853] {
[13:36:40.853]     {
[13:36:40.853]         {
[13:36:40.853]             ...future.startTime <- base::Sys.time()
[13:36:40.853]             {
[13:36:40.853]                 {
[13:36:40.853]                   {
[13:36:40.853]                     {
[13:36:40.853]                       base::local({
[13:36:40.853]                         has_future <- base::requireNamespace("future", 
[13:36:40.853]                           quietly = TRUE)
[13:36:40.853]                         if (has_future) {
[13:36:40.853]                           ns <- base::getNamespace("future")
[13:36:40.853]                           version <- ns[[".package"]][["version"]]
[13:36:40.853]                           if (is.null(version)) 
[13:36:40.853]                             version <- utils::packageVersion("future")
[13:36:40.853]                         }
[13:36:40.853]                         else {
[13:36:40.853]                           version <- NULL
[13:36:40.853]                         }
[13:36:40.853]                         if (!has_future || version < "1.8.0") {
[13:36:40.853]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:40.853]                             "", base::R.version$version.string), 
[13:36:40.853]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:40.853]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:40.853]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:40.853]                               "release", "version")], collapse = " "), 
[13:36:40.853]                             hostname = base::Sys.info()[["nodename"]])
[13:36:40.853]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:40.853]                             info)
[13:36:40.853]                           info <- base::paste(info, collapse = "; ")
[13:36:40.853]                           if (!has_future) {
[13:36:40.853]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:40.853]                               info)
[13:36:40.853]                           }
[13:36:40.853]                           else {
[13:36:40.853]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:40.853]                               info, version)
[13:36:40.853]                           }
[13:36:40.853]                           base::stop(msg)
[13:36:40.853]                         }
[13:36:40.853]                       })
[13:36:40.853]                     }
[13:36:40.853]                     base::local({
[13:36:40.853]                       for (pkg in c("stats", "datasets")) {
[13:36:40.853]                         base::loadNamespace(pkg)
[13:36:40.853]                         base::library(pkg, character.only = TRUE)
[13:36:40.853]                       }
[13:36:40.853]                     })
[13:36:40.853]                   }
[13:36:40.853]                   ...future.strategy.old <- future::plan("list")
[13:36:40.853]                   options(future.plan = NULL)
[13:36:40.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.853]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:40.853]                 }
[13:36:40.853]                 ...future.workdir <- getwd()
[13:36:40.853]             }
[13:36:40.853]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:40.853]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:40.853]         }
[13:36:40.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:40.853]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:40.853]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:40.853]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:40.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:40.853]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:40.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:40.853]             base::names(...future.oldOptions))
[13:36:40.853]     }
[13:36:40.853]     if (FALSE) {
[13:36:40.853]     }
[13:36:40.853]     else {
[13:36:40.853]         if (TRUE) {
[13:36:40.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:40.853]                 open = "w")
[13:36:40.853]         }
[13:36:40.853]         else {
[13:36:40.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:40.853]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:40.853]         }
[13:36:40.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:40.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:40.853]             base::sink(type = "output", split = FALSE)
[13:36:40.853]             base::close(...future.stdout)
[13:36:40.853]         }, add = TRUE)
[13:36:40.853]     }
[13:36:40.853]     ...future.frame <- base::sys.nframe()
[13:36:40.853]     ...future.conditions <- base::list()
[13:36:40.853]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:40.853]     if (FALSE) {
[13:36:40.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:40.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:40.853]     }
[13:36:40.853]     ...future.result <- base::tryCatch({
[13:36:40.853]         base::withCallingHandlers({
[13:36:40.853]             ...future.value <- base::withVisible(base::local({
[13:36:40.853]                 lm(dist ~ . - 1, data = cars)
[13:36:40.853]             }))
[13:36:40.853]             future::FutureResult(value = ...future.value$value, 
[13:36:40.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.853]                   ...future.rng), globalenv = if (FALSE) 
[13:36:40.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:40.853]                     ...future.globalenv.names))
[13:36:40.853]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:40.853]         }, condition = base::local({
[13:36:40.853]             c <- base::c
[13:36:40.853]             inherits <- base::inherits
[13:36:40.853]             invokeRestart <- base::invokeRestart
[13:36:40.853]             length <- base::length
[13:36:40.853]             list <- base::list
[13:36:40.853]             seq.int <- base::seq.int
[13:36:40.853]             signalCondition <- base::signalCondition
[13:36:40.853]             sys.calls <- base::sys.calls
[13:36:40.853]             `[[` <- base::`[[`
[13:36:40.853]             `+` <- base::`+`
[13:36:40.853]             `<<-` <- base::`<<-`
[13:36:40.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:40.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:40.853]                   3L)]
[13:36:40.853]             }
[13:36:40.853]             function(cond) {
[13:36:40.853]                 is_error <- inherits(cond, "error")
[13:36:40.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:40.853]                   NULL)
[13:36:40.853]                 if (is_error) {
[13:36:40.853]                   sessionInformation <- function() {
[13:36:40.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:40.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:40.853]                       search = base::search(), system = base::Sys.info())
[13:36:40.853]                   }
[13:36:40.853]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:40.853]                     cond$call), session = sessionInformation(), 
[13:36:40.853]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:40.853]                   signalCondition(cond)
[13:36:40.853]                 }
[13:36:40.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:40.853]                 "immediateCondition"))) {
[13:36:40.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:40.853]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:40.853]                   if (TRUE && !signal) {
[13:36:40.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.853]                     {
[13:36:40.853]                       inherits <- base::inherits
[13:36:40.853]                       invokeRestart <- base::invokeRestart
[13:36:40.853]                       is.null <- base::is.null
[13:36:40.853]                       muffled <- FALSE
[13:36:40.853]                       if (inherits(cond, "message")) {
[13:36:40.853]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.853]                         if (muffled) 
[13:36:40.853]                           invokeRestart("muffleMessage")
[13:36:40.853]                       }
[13:36:40.853]                       else if (inherits(cond, "warning")) {
[13:36:40.853]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.853]                         if (muffled) 
[13:36:40.853]                           invokeRestart("muffleWarning")
[13:36:40.853]                       }
[13:36:40.853]                       else if (inherits(cond, "condition")) {
[13:36:40.853]                         if (!is.null(pattern)) {
[13:36:40.853]                           computeRestarts <- base::computeRestarts
[13:36:40.853]                           grepl <- base::grepl
[13:36:40.853]                           restarts <- computeRestarts(cond)
[13:36:40.853]                           for (restart in restarts) {
[13:36:40.853]                             name <- restart$name
[13:36:40.853]                             if (is.null(name)) 
[13:36:40.853]                               next
[13:36:40.853]                             if (!grepl(pattern, name)) 
[13:36:40.853]                               next
[13:36:40.853]                             invokeRestart(restart)
[13:36:40.853]                             muffled <- TRUE
[13:36:40.853]                             break
[13:36:40.853]                           }
[13:36:40.853]                         }
[13:36:40.853]                       }
[13:36:40.853]                       invisible(muffled)
[13:36:40.853]                     }
[13:36:40.853]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.853]                   }
[13:36:40.853]                 }
[13:36:40.853]                 else {
[13:36:40.853]                   if (TRUE) {
[13:36:40.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.853]                     {
[13:36:40.853]                       inherits <- base::inherits
[13:36:40.853]                       invokeRestart <- base::invokeRestart
[13:36:40.853]                       is.null <- base::is.null
[13:36:40.853]                       muffled <- FALSE
[13:36:40.853]                       if (inherits(cond, "message")) {
[13:36:40.853]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.853]                         if (muffled) 
[13:36:40.853]                           invokeRestart("muffleMessage")
[13:36:40.853]                       }
[13:36:40.853]                       else if (inherits(cond, "warning")) {
[13:36:40.853]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.853]                         if (muffled) 
[13:36:40.853]                           invokeRestart("muffleWarning")
[13:36:40.853]                       }
[13:36:40.853]                       else if (inherits(cond, "condition")) {
[13:36:40.853]                         if (!is.null(pattern)) {
[13:36:40.853]                           computeRestarts <- base::computeRestarts
[13:36:40.853]                           grepl <- base::grepl
[13:36:40.853]                           restarts <- computeRestarts(cond)
[13:36:40.853]                           for (restart in restarts) {
[13:36:40.853]                             name <- restart$name
[13:36:40.853]                             if (is.null(name)) 
[13:36:40.853]                               next
[13:36:40.853]                             if (!grepl(pattern, name)) 
[13:36:40.853]                               next
[13:36:40.853]                             invokeRestart(restart)
[13:36:40.853]                             muffled <- TRUE
[13:36:40.853]                             break
[13:36:40.853]                           }
[13:36:40.853]                         }
[13:36:40.853]                       }
[13:36:40.853]                       invisible(muffled)
[13:36:40.853]                     }
[13:36:40.853]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.853]                   }
[13:36:40.853]                 }
[13:36:40.853]             }
[13:36:40.853]         }))
[13:36:40.853]     }, error = function(ex) {
[13:36:40.853]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:40.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.853]                 ...future.rng), started = ...future.startTime, 
[13:36:40.853]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:40.853]             version = "1.8"), class = "FutureResult")
[13:36:40.853]     }, finally = {
[13:36:40.853]         if (!identical(...future.workdir, getwd())) 
[13:36:40.853]             setwd(...future.workdir)
[13:36:40.853]         {
[13:36:40.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:40.853]                 ...future.oldOptions$nwarnings <- NULL
[13:36:40.853]             }
[13:36:40.853]             base::options(...future.oldOptions)
[13:36:40.853]             if (.Platform$OS.type == "windows") {
[13:36:40.853]                 old_names <- names(...future.oldEnvVars)
[13:36:40.853]                 envs <- base::Sys.getenv()
[13:36:40.853]                 names <- names(envs)
[13:36:40.853]                 common <- intersect(names, old_names)
[13:36:40.853]                 added <- setdiff(names, old_names)
[13:36:40.853]                 removed <- setdiff(old_names, names)
[13:36:40.853]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:40.853]                   envs[common]]
[13:36:40.853]                 NAMES <- toupper(changed)
[13:36:40.853]                 args <- list()
[13:36:40.853]                 for (kk in seq_along(NAMES)) {
[13:36:40.853]                   name <- changed[[kk]]
[13:36:40.853]                   NAME <- NAMES[[kk]]
[13:36:40.853]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.853]                     next
[13:36:40.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.853]                 }
[13:36:40.853]                 NAMES <- toupper(added)
[13:36:40.853]                 for (kk in seq_along(NAMES)) {
[13:36:40.853]                   name <- added[[kk]]
[13:36:40.853]                   NAME <- NAMES[[kk]]
[13:36:40.853]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.853]                     next
[13:36:40.853]                   args[[name]] <- ""
[13:36:40.853]                 }
[13:36:40.853]                 NAMES <- toupper(removed)
[13:36:40.853]                 for (kk in seq_along(NAMES)) {
[13:36:40.853]                   name <- removed[[kk]]
[13:36:40.853]                   NAME <- NAMES[[kk]]
[13:36:40.853]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.853]                     next
[13:36:40.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.853]                 }
[13:36:40.853]                 if (length(args) > 0) 
[13:36:40.853]                   base::do.call(base::Sys.setenv, args = args)
[13:36:40.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:40.853]             }
[13:36:40.853]             else {
[13:36:40.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:40.853]             }
[13:36:40.853]             {
[13:36:40.853]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:40.853]                   0L) {
[13:36:40.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:40.853]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:40.853]                   base::options(opts)
[13:36:40.853]                 }
[13:36:40.853]                 {
[13:36:40.853]                   {
[13:36:40.853]                     NULL
[13:36:40.853]                     RNGkind("Mersenne-Twister")
[13:36:40.853]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:40.853]                       inherits = FALSE)
[13:36:40.853]                   }
[13:36:40.853]                   options(future.plan = NULL)
[13:36:40.853]                   if (is.na(NA_character_)) 
[13:36:40.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:40.853]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:40.853]                     .init = FALSE)
[13:36:40.853]                 }
[13:36:40.853]             }
[13:36:40.853]         }
[13:36:40.853]     })
[13:36:40.853]     if (TRUE) {
[13:36:40.853]         base::sink(type = "output", split = FALSE)
[13:36:40.853]         if (TRUE) {
[13:36:40.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:40.853]         }
[13:36:40.853]         else {
[13:36:40.853]             ...future.result["stdout"] <- base::list(NULL)
[13:36:40.853]         }
[13:36:40.853]         base::close(...future.stdout)
[13:36:40.853]         ...future.stdout <- NULL
[13:36:40.853]     }
[13:36:40.853]     ...future.result$conditions <- ...future.conditions
[13:36:40.853]     ...future.result$finished <- base::Sys.time()
[13:36:40.853]     ...future.result
[13:36:40.853] }
[13:36:40.855] plan(): Setting new future strategy stack:
[13:36:40.855] List of future strategies:
[13:36:40.855] 1. sequential:
[13:36:40.855]    - args: function (..., envir = parent.frame())
[13:36:40.855]    - tweaked: FALSE
[13:36:40.855]    - call: NULL
[13:36:40.855] plan(): nbrOfWorkers() = 1
[13:36:40.857] plan(): Setting new future strategy stack:
[13:36:40.857] List of future strategies:
[13:36:40.857] 1. sequential:
[13:36:40.857]    - args: function (..., envir = parent.frame())
[13:36:40.857]    - tweaked: FALSE
[13:36:40.857]    - call: plan(strategy)
[13:36:40.857] plan(): nbrOfWorkers() = 1
[13:36:40.857] SequentialFuture started (and completed)
[13:36:40.857] - Launch lazy future ... done
[13:36:40.857] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[13:36:40.860] getGlobalsAndPackages() ...
[13:36:40.860] Searching for globals...
[13:36:40.861] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[13:36:40.861] Searching for globals ... DONE
[13:36:40.861] Resolving globals: FALSE
[13:36:40.862] 
[13:36:40.862] - packages: [2] ‘stats’, ‘datasets’
[13:36:40.862] getGlobalsAndPackages() ... DONE
[13:36:40.862] run() for ‘Future’ ...
[13:36:40.862] - state: ‘created’
[13:36:40.862] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:40.863] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:40.863] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:40.863]   - Field: ‘label’
[13:36:40.863]   - Field: ‘local’
[13:36:40.863]   - Field: ‘owner’
[13:36:40.863]   - Field: ‘envir’
[13:36:40.863]   - Field: ‘packages’
[13:36:40.863]   - Field: ‘gc’
[13:36:40.863]   - Field: ‘conditions’
[13:36:40.863]   - Field: ‘expr’
[13:36:40.863]   - Field: ‘uuid’
[13:36:40.863]   - Field: ‘seed’
[13:36:40.864]   - Field: ‘version’
[13:36:40.864]   - Field: ‘result’
[13:36:40.864]   - Field: ‘asynchronous’
[13:36:40.864]   - Field: ‘calls’
[13:36:40.864]   - Field: ‘globals’
[13:36:40.864]   - Field: ‘stdout’
[13:36:40.864]   - Field: ‘earlySignal’
[13:36:40.864]   - Field: ‘lazy’
[13:36:40.864]   - Field: ‘state’
[13:36:40.864] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:40.864] - Launch lazy future ...
[13:36:40.865] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:36:40.865] Packages needed by future strategies (n = 0): <none>
[13:36:40.865] {
[13:36:40.865]     {
[13:36:40.865]         {
[13:36:40.865]             ...future.startTime <- base::Sys.time()
[13:36:40.865]             {
[13:36:40.865]                 {
[13:36:40.865]                   {
[13:36:40.865]                     {
[13:36:40.865]                       base::local({
[13:36:40.865]                         has_future <- base::requireNamespace("future", 
[13:36:40.865]                           quietly = TRUE)
[13:36:40.865]                         if (has_future) {
[13:36:40.865]                           ns <- base::getNamespace("future")
[13:36:40.865]                           version <- ns[[".package"]][["version"]]
[13:36:40.865]                           if (is.null(version)) 
[13:36:40.865]                             version <- utils::packageVersion("future")
[13:36:40.865]                         }
[13:36:40.865]                         else {
[13:36:40.865]                           version <- NULL
[13:36:40.865]                         }
[13:36:40.865]                         if (!has_future || version < "1.8.0") {
[13:36:40.865]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:40.865]                             "", base::R.version$version.string), 
[13:36:40.865]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:40.865]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:40.865]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:40.865]                               "release", "version")], collapse = " "), 
[13:36:40.865]                             hostname = base::Sys.info()[["nodename"]])
[13:36:40.865]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:40.865]                             info)
[13:36:40.865]                           info <- base::paste(info, collapse = "; ")
[13:36:40.865]                           if (!has_future) {
[13:36:40.865]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:40.865]                               info)
[13:36:40.865]                           }
[13:36:40.865]                           else {
[13:36:40.865]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:40.865]                               info, version)
[13:36:40.865]                           }
[13:36:40.865]                           base::stop(msg)
[13:36:40.865]                         }
[13:36:40.865]                       })
[13:36:40.865]                     }
[13:36:40.865]                     base::local({
[13:36:40.865]                       for (pkg in c("stats", "datasets")) {
[13:36:40.865]                         base::loadNamespace(pkg)
[13:36:40.865]                         base::library(pkg, character.only = TRUE)
[13:36:40.865]                       }
[13:36:40.865]                     })
[13:36:40.865]                   }
[13:36:40.865]                   ...future.strategy.old <- future::plan("list")
[13:36:40.865]                   options(future.plan = NULL)
[13:36:40.865]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.865]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:40.865]                 }
[13:36:40.865]                 ...future.workdir <- getwd()
[13:36:40.865]             }
[13:36:40.865]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:40.865]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:40.865]         }
[13:36:40.865]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:40.865]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:40.865]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:40.865]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:40.865]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:40.865]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:40.865]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:40.865]             base::names(...future.oldOptions))
[13:36:40.865]     }
[13:36:40.865]     if (FALSE) {
[13:36:40.865]     }
[13:36:40.865]     else {
[13:36:40.865]         if (TRUE) {
[13:36:40.865]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:40.865]                 open = "w")
[13:36:40.865]         }
[13:36:40.865]         else {
[13:36:40.865]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:40.865]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:40.865]         }
[13:36:40.865]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:40.865]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:40.865]             base::sink(type = "output", split = FALSE)
[13:36:40.865]             base::close(...future.stdout)
[13:36:40.865]         }, add = TRUE)
[13:36:40.865]     }
[13:36:40.865]     ...future.frame <- base::sys.nframe()
[13:36:40.865]     ...future.conditions <- base::list()
[13:36:40.865]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:40.865]     if (FALSE) {
[13:36:40.865]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:40.865]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:40.865]     }
[13:36:40.865]     ...future.result <- base::tryCatch({
[13:36:40.865]         base::withCallingHandlers({
[13:36:40.865]             ...future.value <- base::withVisible(base::local({
[13:36:40.865]                 lm(dist ~ . + 0, data = cars)
[13:36:40.865]             }))
[13:36:40.865]             future::FutureResult(value = ...future.value$value, 
[13:36:40.865]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.865]                   ...future.rng), globalenv = if (FALSE) 
[13:36:40.865]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:40.865]                     ...future.globalenv.names))
[13:36:40.865]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:40.865]         }, condition = base::local({
[13:36:40.865]             c <- base::c
[13:36:40.865]             inherits <- base::inherits
[13:36:40.865]             invokeRestart <- base::invokeRestart
[13:36:40.865]             length <- base::length
[13:36:40.865]             list <- base::list
[13:36:40.865]             seq.int <- base::seq.int
[13:36:40.865]             signalCondition <- base::signalCondition
[13:36:40.865]             sys.calls <- base::sys.calls
[13:36:40.865]             `[[` <- base::`[[`
[13:36:40.865]             `+` <- base::`+`
[13:36:40.865]             `<<-` <- base::`<<-`
[13:36:40.865]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:40.865]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:40.865]                   3L)]
[13:36:40.865]             }
[13:36:40.865]             function(cond) {
[13:36:40.865]                 is_error <- inherits(cond, "error")
[13:36:40.865]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:40.865]                   NULL)
[13:36:40.865]                 if (is_error) {
[13:36:40.865]                   sessionInformation <- function() {
[13:36:40.865]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:40.865]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:40.865]                       search = base::search(), system = base::Sys.info())
[13:36:40.865]                   }
[13:36:40.865]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.865]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:40.865]                     cond$call), session = sessionInformation(), 
[13:36:40.865]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:40.865]                   signalCondition(cond)
[13:36:40.865]                 }
[13:36:40.865]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:40.865]                 "immediateCondition"))) {
[13:36:40.865]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:40.865]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.865]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:40.865]                   if (TRUE && !signal) {
[13:36:40.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.865]                     {
[13:36:40.865]                       inherits <- base::inherits
[13:36:40.865]                       invokeRestart <- base::invokeRestart
[13:36:40.865]                       is.null <- base::is.null
[13:36:40.865]                       muffled <- FALSE
[13:36:40.865]                       if (inherits(cond, "message")) {
[13:36:40.865]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.865]                         if (muffled) 
[13:36:40.865]                           invokeRestart("muffleMessage")
[13:36:40.865]                       }
[13:36:40.865]                       else if (inherits(cond, "warning")) {
[13:36:40.865]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.865]                         if (muffled) 
[13:36:40.865]                           invokeRestart("muffleWarning")
[13:36:40.865]                       }
[13:36:40.865]                       else if (inherits(cond, "condition")) {
[13:36:40.865]                         if (!is.null(pattern)) {
[13:36:40.865]                           computeRestarts <- base::computeRestarts
[13:36:40.865]                           grepl <- base::grepl
[13:36:40.865]                           restarts <- computeRestarts(cond)
[13:36:40.865]                           for (restart in restarts) {
[13:36:40.865]                             name <- restart$name
[13:36:40.865]                             if (is.null(name)) 
[13:36:40.865]                               next
[13:36:40.865]                             if (!grepl(pattern, name)) 
[13:36:40.865]                               next
[13:36:40.865]                             invokeRestart(restart)
[13:36:40.865]                             muffled <- TRUE
[13:36:40.865]                             break
[13:36:40.865]                           }
[13:36:40.865]                         }
[13:36:40.865]                       }
[13:36:40.865]                       invisible(muffled)
[13:36:40.865]                     }
[13:36:40.865]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.865]                   }
[13:36:40.865]                 }
[13:36:40.865]                 else {
[13:36:40.865]                   if (TRUE) {
[13:36:40.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.865]                     {
[13:36:40.865]                       inherits <- base::inherits
[13:36:40.865]                       invokeRestart <- base::invokeRestart
[13:36:40.865]                       is.null <- base::is.null
[13:36:40.865]                       muffled <- FALSE
[13:36:40.865]                       if (inherits(cond, "message")) {
[13:36:40.865]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.865]                         if (muffled) 
[13:36:40.865]                           invokeRestart("muffleMessage")
[13:36:40.865]                       }
[13:36:40.865]                       else if (inherits(cond, "warning")) {
[13:36:40.865]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.865]                         if (muffled) 
[13:36:40.865]                           invokeRestart("muffleWarning")
[13:36:40.865]                       }
[13:36:40.865]                       else if (inherits(cond, "condition")) {
[13:36:40.865]                         if (!is.null(pattern)) {
[13:36:40.865]                           computeRestarts <- base::computeRestarts
[13:36:40.865]                           grepl <- base::grepl
[13:36:40.865]                           restarts <- computeRestarts(cond)
[13:36:40.865]                           for (restart in restarts) {
[13:36:40.865]                             name <- restart$name
[13:36:40.865]                             if (is.null(name)) 
[13:36:40.865]                               next
[13:36:40.865]                             if (!grepl(pattern, name)) 
[13:36:40.865]                               next
[13:36:40.865]                             invokeRestart(restart)
[13:36:40.865]                             muffled <- TRUE
[13:36:40.865]                             break
[13:36:40.865]                           }
[13:36:40.865]                         }
[13:36:40.865]                       }
[13:36:40.865]                       invisible(muffled)
[13:36:40.865]                     }
[13:36:40.865]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.865]                   }
[13:36:40.865]                 }
[13:36:40.865]             }
[13:36:40.865]         }))
[13:36:40.865]     }, error = function(ex) {
[13:36:40.865]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:40.865]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.865]                 ...future.rng), started = ...future.startTime, 
[13:36:40.865]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:40.865]             version = "1.8"), class = "FutureResult")
[13:36:40.865]     }, finally = {
[13:36:40.865]         if (!identical(...future.workdir, getwd())) 
[13:36:40.865]             setwd(...future.workdir)
[13:36:40.865]         {
[13:36:40.865]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:40.865]                 ...future.oldOptions$nwarnings <- NULL
[13:36:40.865]             }
[13:36:40.865]             base::options(...future.oldOptions)
[13:36:40.865]             if (.Platform$OS.type == "windows") {
[13:36:40.865]                 old_names <- names(...future.oldEnvVars)
[13:36:40.865]                 envs <- base::Sys.getenv()
[13:36:40.865]                 names <- names(envs)
[13:36:40.865]                 common <- intersect(names, old_names)
[13:36:40.865]                 added <- setdiff(names, old_names)
[13:36:40.865]                 removed <- setdiff(old_names, names)
[13:36:40.865]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:40.865]                   envs[common]]
[13:36:40.865]                 NAMES <- toupper(changed)
[13:36:40.865]                 args <- list()
[13:36:40.865]                 for (kk in seq_along(NAMES)) {
[13:36:40.865]                   name <- changed[[kk]]
[13:36:40.865]                   NAME <- NAMES[[kk]]
[13:36:40.865]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.865]                     next
[13:36:40.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.865]                 }
[13:36:40.865]                 NAMES <- toupper(added)
[13:36:40.865]                 for (kk in seq_along(NAMES)) {
[13:36:40.865]                   name <- added[[kk]]
[13:36:40.865]                   NAME <- NAMES[[kk]]
[13:36:40.865]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.865]                     next
[13:36:40.865]                   args[[name]] <- ""
[13:36:40.865]                 }
[13:36:40.865]                 NAMES <- toupper(removed)
[13:36:40.865]                 for (kk in seq_along(NAMES)) {
[13:36:40.865]                   name <- removed[[kk]]
[13:36:40.865]                   NAME <- NAMES[[kk]]
[13:36:40.865]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.865]                     next
[13:36:40.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.865]                 }
[13:36:40.865]                 if (length(args) > 0) 
[13:36:40.865]                   base::do.call(base::Sys.setenv, args = args)
[13:36:40.865]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:40.865]             }
[13:36:40.865]             else {
[13:36:40.865]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:40.865]             }
[13:36:40.865]             {
[13:36:40.865]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:40.865]                   0L) {
[13:36:40.865]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:40.865]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:40.865]                   base::options(opts)
[13:36:40.865]                 }
[13:36:40.865]                 {
[13:36:40.865]                   {
[13:36:40.865]                     NULL
[13:36:40.865]                     RNGkind("Mersenne-Twister")
[13:36:40.865]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:40.865]                       inherits = FALSE)
[13:36:40.865]                   }
[13:36:40.865]                   options(future.plan = NULL)
[13:36:40.865]                   if (is.na(NA_character_)) 
[13:36:40.865]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.865]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:40.865]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:40.865]                     .init = FALSE)
[13:36:40.865]                 }
[13:36:40.865]             }
[13:36:40.865]         }
[13:36:40.865]     })
[13:36:40.865]     if (TRUE) {
[13:36:40.865]         base::sink(type = "output", split = FALSE)
[13:36:40.865]         if (TRUE) {
[13:36:40.865]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:40.865]         }
[13:36:40.865]         else {
[13:36:40.865]             ...future.result["stdout"] <- base::list(NULL)
[13:36:40.865]         }
[13:36:40.865]         base::close(...future.stdout)
[13:36:40.865]         ...future.stdout <- NULL
[13:36:40.865]     }
[13:36:40.865]     ...future.result$conditions <- ...future.conditions
[13:36:40.865]     ...future.result$finished <- base::Sys.time()
[13:36:40.865]     ...future.result
[13:36:40.865] }
[13:36:40.867] plan(): Setting new future strategy stack:
[13:36:40.867] List of future strategies:
[13:36:40.867] 1. sequential:
[13:36:40.867]    - args: function (..., envir = parent.frame())
[13:36:40.867]    - tweaked: FALSE
[13:36:40.867]    - call: NULL
[13:36:40.867] plan(): nbrOfWorkers() = 1
[13:36:40.869] plan(): Setting new future strategy stack:
[13:36:40.869] List of future strategies:
[13:36:40.869] 1. sequential:
[13:36:40.869]    - args: function (..., envir = parent.frame())
[13:36:40.869]    - tweaked: FALSE
[13:36:40.869]    - call: plan(strategy)
[13:36:40.869] plan(): nbrOfWorkers() = 1
[13:36:40.869] SequentialFuture started (and completed)
[13:36:40.869] - Launch lazy future ... done
[13:36:40.869] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[13:36:40.872] getGlobalsAndPackages() ...
[13:36:40.873] Searching for globals...
[13:36:40.874] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[13:36:40.874] Searching for globals ... DONE
[13:36:40.874] Resolving globals: FALSE
[13:36:40.875] 
[13:36:40.875] - packages: [2] ‘stats’, ‘datasets’
[13:36:40.875] getGlobalsAndPackages() ... DONE
[13:36:40.875] run() for ‘Future’ ...
[13:36:40.875] - state: ‘created’
[13:36:40.875] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:40.876] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:40.876] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:40.876]   - Field: ‘label’
[13:36:40.876]   - Field: ‘local’
[13:36:40.876]   - Field: ‘owner’
[13:36:40.876]   - Field: ‘envir’
[13:36:40.876]   - Field: ‘packages’
[13:36:40.876]   - Field: ‘gc’
[13:36:40.876]   - Field: ‘conditions’
[13:36:40.877]   - Field: ‘expr’
[13:36:40.877]   - Field: ‘uuid’
[13:36:40.877]   - Field: ‘seed’
[13:36:40.877]   - Field: ‘version’
[13:36:40.877]   - Field: ‘result’
[13:36:40.877]   - Field: ‘asynchronous’
[13:36:40.877]   - Field: ‘calls’
[13:36:40.877]   - Field: ‘globals’
[13:36:40.877]   - Field: ‘stdout’
[13:36:40.877]   - Field: ‘earlySignal’
[13:36:40.877]   - Field: ‘lazy’
[13:36:40.877]   - Field: ‘state’
[13:36:40.878] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:40.878] - Launch lazy future ...
[13:36:40.878] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:36:40.878] Packages needed by future strategies (n = 0): <none>
[13:36:40.878] {
[13:36:40.878]     {
[13:36:40.878]         {
[13:36:40.878]             ...future.startTime <- base::Sys.time()
[13:36:40.878]             {
[13:36:40.878]                 {
[13:36:40.878]                   {
[13:36:40.878]                     {
[13:36:40.878]                       base::local({
[13:36:40.878]                         has_future <- base::requireNamespace("future", 
[13:36:40.878]                           quietly = TRUE)
[13:36:40.878]                         if (has_future) {
[13:36:40.878]                           ns <- base::getNamespace("future")
[13:36:40.878]                           version <- ns[[".package"]][["version"]]
[13:36:40.878]                           if (is.null(version)) 
[13:36:40.878]                             version <- utils::packageVersion("future")
[13:36:40.878]                         }
[13:36:40.878]                         else {
[13:36:40.878]                           version <- NULL
[13:36:40.878]                         }
[13:36:40.878]                         if (!has_future || version < "1.8.0") {
[13:36:40.878]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:40.878]                             "", base::R.version$version.string), 
[13:36:40.878]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:40.878]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:40.878]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:40.878]                               "release", "version")], collapse = " "), 
[13:36:40.878]                             hostname = base::Sys.info()[["nodename"]])
[13:36:40.878]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:40.878]                             info)
[13:36:40.878]                           info <- base::paste(info, collapse = "; ")
[13:36:40.878]                           if (!has_future) {
[13:36:40.878]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:40.878]                               info)
[13:36:40.878]                           }
[13:36:40.878]                           else {
[13:36:40.878]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:40.878]                               info, version)
[13:36:40.878]                           }
[13:36:40.878]                           base::stop(msg)
[13:36:40.878]                         }
[13:36:40.878]                       })
[13:36:40.878]                     }
[13:36:40.878]                     base::local({
[13:36:40.878]                       for (pkg in c("stats", "datasets")) {
[13:36:40.878]                         base::loadNamespace(pkg)
[13:36:40.878]                         base::library(pkg, character.only = TRUE)
[13:36:40.878]                       }
[13:36:40.878]                     })
[13:36:40.878]                   }
[13:36:40.878]                   ...future.strategy.old <- future::plan("list")
[13:36:40.878]                   options(future.plan = NULL)
[13:36:40.878]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.878]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:40.878]                 }
[13:36:40.878]                 ...future.workdir <- getwd()
[13:36:40.878]             }
[13:36:40.878]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:40.878]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:40.878]         }
[13:36:40.878]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:40.878]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:40.878]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:40.878]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:40.878]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:40.878]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:40.878]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:40.878]             base::names(...future.oldOptions))
[13:36:40.878]     }
[13:36:40.878]     if (FALSE) {
[13:36:40.878]     }
[13:36:40.878]     else {
[13:36:40.878]         if (TRUE) {
[13:36:40.878]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:40.878]                 open = "w")
[13:36:40.878]         }
[13:36:40.878]         else {
[13:36:40.878]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:40.878]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:40.878]         }
[13:36:40.878]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:40.878]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:40.878]             base::sink(type = "output", split = FALSE)
[13:36:40.878]             base::close(...future.stdout)
[13:36:40.878]         }, add = TRUE)
[13:36:40.878]     }
[13:36:40.878]     ...future.frame <- base::sys.nframe()
[13:36:40.878]     ...future.conditions <- base::list()
[13:36:40.878]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:40.878]     if (FALSE) {
[13:36:40.878]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:40.878]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:40.878]     }
[13:36:40.878]     ...future.result <- base::tryCatch({
[13:36:40.878]         base::withCallingHandlers({
[13:36:40.878]             ...future.value <- base::withVisible(base::local({
[13:36:40.878]                 lm(dist ~ speed + speed^2, data = cars)
[13:36:40.878]             }))
[13:36:40.878]             future::FutureResult(value = ...future.value$value, 
[13:36:40.878]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.878]                   ...future.rng), globalenv = if (FALSE) 
[13:36:40.878]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:40.878]                     ...future.globalenv.names))
[13:36:40.878]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:40.878]         }, condition = base::local({
[13:36:40.878]             c <- base::c
[13:36:40.878]             inherits <- base::inherits
[13:36:40.878]             invokeRestart <- base::invokeRestart
[13:36:40.878]             length <- base::length
[13:36:40.878]             list <- base::list
[13:36:40.878]             seq.int <- base::seq.int
[13:36:40.878]             signalCondition <- base::signalCondition
[13:36:40.878]             sys.calls <- base::sys.calls
[13:36:40.878]             `[[` <- base::`[[`
[13:36:40.878]             `+` <- base::`+`
[13:36:40.878]             `<<-` <- base::`<<-`
[13:36:40.878]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:40.878]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:40.878]                   3L)]
[13:36:40.878]             }
[13:36:40.878]             function(cond) {
[13:36:40.878]                 is_error <- inherits(cond, "error")
[13:36:40.878]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:40.878]                   NULL)
[13:36:40.878]                 if (is_error) {
[13:36:40.878]                   sessionInformation <- function() {
[13:36:40.878]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:40.878]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:40.878]                       search = base::search(), system = base::Sys.info())
[13:36:40.878]                   }
[13:36:40.878]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.878]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:40.878]                     cond$call), session = sessionInformation(), 
[13:36:40.878]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:40.878]                   signalCondition(cond)
[13:36:40.878]                 }
[13:36:40.878]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:40.878]                 "immediateCondition"))) {
[13:36:40.878]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:40.878]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.878]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:40.878]                   if (TRUE && !signal) {
[13:36:40.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.878]                     {
[13:36:40.878]                       inherits <- base::inherits
[13:36:40.878]                       invokeRestart <- base::invokeRestart
[13:36:40.878]                       is.null <- base::is.null
[13:36:40.878]                       muffled <- FALSE
[13:36:40.878]                       if (inherits(cond, "message")) {
[13:36:40.878]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.878]                         if (muffled) 
[13:36:40.878]                           invokeRestart("muffleMessage")
[13:36:40.878]                       }
[13:36:40.878]                       else if (inherits(cond, "warning")) {
[13:36:40.878]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.878]                         if (muffled) 
[13:36:40.878]                           invokeRestart("muffleWarning")
[13:36:40.878]                       }
[13:36:40.878]                       else if (inherits(cond, "condition")) {
[13:36:40.878]                         if (!is.null(pattern)) {
[13:36:40.878]                           computeRestarts <- base::computeRestarts
[13:36:40.878]                           grepl <- base::grepl
[13:36:40.878]                           restarts <- computeRestarts(cond)
[13:36:40.878]                           for (restart in restarts) {
[13:36:40.878]                             name <- restart$name
[13:36:40.878]                             if (is.null(name)) 
[13:36:40.878]                               next
[13:36:40.878]                             if (!grepl(pattern, name)) 
[13:36:40.878]                               next
[13:36:40.878]                             invokeRestart(restart)
[13:36:40.878]                             muffled <- TRUE
[13:36:40.878]                             break
[13:36:40.878]                           }
[13:36:40.878]                         }
[13:36:40.878]                       }
[13:36:40.878]                       invisible(muffled)
[13:36:40.878]                     }
[13:36:40.878]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.878]                   }
[13:36:40.878]                 }
[13:36:40.878]                 else {
[13:36:40.878]                   if (TRUE) {
[13:36:40.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.878]                     {
[13:36:40.878]                       inherits <- base::inherits
[13:36:40.878]                       invokeRestart <- base::invokeRestart
[13:36:40.878]                       is.null <- base::is.null
[13:36:40.878]                       muffled <- FALSE
[13:36:40.878]                       if (inherits(cond, "message")) {
[13:36:40.878]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.878]                         if (muffled) 
[13:36:40.878]                           invokeRestart("muffleMessage")
[13:36:40.878]                       }
[13:36:40.878]                       else if (inherits(cond, "warning")) {
[13:36:40.878]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.878]                         if (muffled) 
[13:36:40.878]                           invokeRestart("muffleWarning")
[13:36:40.878]                       }
[13:36:40.878]                       else if (inherits(cond, "condition")) {
[13:36:40.878]                         if (!is.null(pattern)) {
[13:36:40.878]                           computeRestarts <- base::computeRestarts
[13:36:40.878]                           grepl <- base::grepl
[13:36:40.878]                           restarts <- computeRestarts(cond)
[13:36:40.878]                           for (restart in restarts) {
[13:36:40.878]                             name <- restart$name
[13:36:40.878]                             if (is.null(name)) 
[13:36:40.878]                               next
[13:36:40.878]                             if (!grepl(pattern, name)) 
[13:36:40.878]                               next
[13:36:40.878]                             invokeRestart(restart)
[13:36:40.878]                             muffled <- TRUE
[13:36:40.878]                             break
[13:36:40.878]                           }
[13:36:40.878]                         }
[13:36:40.878]                       }
[13:36:40.878]                       invisible(muffled)
[13:36:40.878]                     }
[13:36:40.878]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.878]                   }
[13:36:40.878]                 }
[13:36:40.878]             }
[13:36:40.878]         }))
[13:36:40.878]     }, error = function(ex) {
[13:36:40.878]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:40.878]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.878]                 ...future.rng), started = ...future.startTime, 
[13:36:40.878]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:40.878]             version = "1.8"), class = "FutureResult")
[13:36:40.878]     }, finally = {
[13:36:40.878]         if (!identical(...future.workdir, getwd())) 
[13:36:40.878]             setwd(...future.workdir)
[13:36:40.878]         {
[13:36:40.878]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:40.878]                 ...future.oldOptions$nwarnings <- NULL
[13:36:40.878]             }
[13:36:40.878]             base::options(...future.oldOptions)
[13:36:40.878]             if (.Platform$OS.type == "windows") {
[13:36:40.878]                 old_names <- names(...future.oldEnvVars)
[13:36:40.878]                 envs <- base::Sys.getenv()
[13:36:40.878]                 names <- names(envs)
[13:36:40.878]                 common <- intersect(names, old_names)
[13:36:40.878]                 added <- setdiff(names, old_names)
[13:36:40.878]                 removed <- setdiff(old_names, names)
[13:36:40.878]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:40.878]                   envs[common]]
[13:36:40.878]                 NAMES <- toupper(changed)
[13:36:40.878]                 args <- list()
[13:36:40.878]                 for (kk in seq_along(NAMES)) {
[13:36:40.878]                   name <- changed[[kk]]
[13:36:40.878]                   NAME <- NAMES[[kk]]
[13:36:40.878]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.878]                     next
[13:36:40.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.878]                 }
[13:36:40.878]                 NAMES <- toupper(added)
[13:36:40.878]                 for (kk in seq_along(NAMES)) {
[13:36:40.878]                   name <- added[[kk]]
[13:36:40.878]                   NAME <- NAMES[[kk]]
[13:36:40.878]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.878]                     next
[13:36:40.878]                   args[[name]] <- ""
[13:36:40.878]                 }
[13:36:40.878]                 NAMES <- toupper(removed)
[13:36:40.878]                 for (kk in seq_along(NAMES)) {
[13:36:40.878]                   name <- removed[[kk]]
[13:36:40.878]                   NAME <- NAMES[[kk]]
[13:36:40.878]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.878]                     next
[13:36:40.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.878]                 }
[13:36:40.878]                 if (length(args) > 0) 
[13:36:40.878]                   base::do.call(base::Sys.setenv, args = args)
[13:36:40.878]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:40.878]             }
[13:36:40.878]             else {
[13:36:40.878]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:40.878]             }
[13:36:40.878]             {
[13:36:40.878]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:40.878]                   0L) {
[13:36:40.878]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:40.878]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:40.878]                   base::options(opts)
[13:36:40.878]                 }
[13:36:40.878]                 {
[13:36:40.878]                   {
[13:36:40.878]                     NULL
[13:36:40.878]                     RNGkind("Mersenne-Twister")
[13:36:40.878]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:40.878]                       inherits = FALSE)
[13:36:40.878]                   }
[13:36:40.878]                   options(future.plan = NULL)
[13:36:40.878]                   if (is.na(NA_character_)) 
[13:36:40.878]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.878]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:40.878]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:40.878]                     .init = FALSE)
[13:36:40.878]                 }
[13:36:40.878]             }
[13:36:40.878]         }
[13:36:40.878]     })
[13:36:40.878]     if (TRUE) {
[13:36:40.878]         base::sink(type = "output", split = FALSE)
[13:36:40.878]         if (TRUE) {
[13:36:40.878]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:40.878]         }
[13:36:40.878]         else {
[13:36:40.878]             ...future.result["stdout"] <- base::list(NULL)
[13:36:40.878]         }
[13:36:40.878]         base::close(...future.stdout)
[13:36:40.878]         ...future.stdout <- NULL
[13:36:40.878]     }
[13:36:40.878]     ...future.result$conditions <- ...future.conditions
[13:36:40.878]     ...future.result$finished <- base::Sys.time()
[13:36:40.878]     ...future.result
[13:36:40.878] }
[13:36:40.880] plan(): Setting new future strategy stack:
[13:36:40.880] List of future strategies:
[13:36:40.880] 1. sequential:
[13:36:40.880]    - args: function (..., envir = parent.frame())
[13:36:40.880]    - tweaked: FALSE
[13:36:40.880]    - call: NULL
[13:36:40.881] plan(): nbrOfWorkers() = 1
[13:36:40.882] plan(): Setting new future strategy stack:
[13:36:40.882] List of future strategies:
[13:36:40.882] 1. sequential:
[13:36:40.882]    - args: function (..., envir = parent.frame())
[13:36:40.882]    - tweaked: FALSE
[13:36:40.882]    - call: plan(strategy)
[13:36:40.882] plan(): nbrOfWorkers() = 1
[13:36:40.882] SequentialFuture started (and completed)
[13:36:40.883] - Launch lazy future ... done
[13:36:40.883] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[13:36:40.885] getGlobalsAndPackages() ...
[13:36:40.885] Searching for globals...
[13:36:40.887] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[13:36:40.887] Searching for globals ... DONE
[13:36:40.887] Resolving globals: FALSE
[13:36:40.887] 
[13:36:40.887] - packages: [2] ‘stats’, ‘datasets’
[13:36:40.888] getGlobalsAndPackages() ... DONE
[13:36:40.888] run() for ‘Future’ ...
[13:36:40.888] - state: ‘created’
[13:36:40.888] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:40.888] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:40.888] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:40.888]   - Field: ‘label’
[13:36:40.889]   - Field: ‘local’
[13:36:40.889]   - Field: ‘owner’
[13:36:40.889]   - Field: ‘envir’
[13:36:40.889]   - Field: ‘packages’
[13:36:40.889]   - Field: ‘gc’
[13:36:40.889]   - Field: ‘conditions’
[13:36:40.889]   - Field: ‘expr’
[13:36:40.889]   - Field: ‘uuid’
[13:36:40.889]   - Field: ‘seed’
[13:36:40.889]   - Field: ‘version’
[13:36:40.889]   - Field: ‘result’
[13:36:40.890]   - Field: ‘asynchronous’
[13:36:40.890]   - Field: ‘calls’
[13:36:40.890]   - Field: ‘globals’
[13:36:40.890]   - Field: ‘stdout’
[13:36:40.890]   - Field: ‘earlySignal’
[13:36:40.890]   - Field: ‘lazy’
[13:36:40.890]   - Field: ‘state’
[13:36:40.890] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:40.890] - Launch lazy future ...
[13:36:40.890] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:36:40.891] Packages needed by future strategies (n = 0): <none>
[13:36:40.891] {
[13:36:40.891]     {
[13:36:40.891]         {
[13:36:40.891]             ...future.startTime <- base::Sys.time()
[13:36:40.891]             {
[13:36:40.891]                 {
[13:36:40.891]                   {
[13:36:40.891]                     {
[13:36:40.891]                       base::local({
[13:36:40.891]                         has_future <- base::requireNamespace("future", 
[13:36:40.891]                           quietly = TRUE)
[13:36:40.891]                         if (has_future) {
[13:36:40.891]                           ns <- base::getNamespace("future")
[13:36:40.891]                           version <- ns[[".package"]][["version"]]
[13:36:40.891]                           if (is.null(version)) 
[13:36:40.891]                             version <- utils::packageVersion("future")
[13:36:40.891]                         }
[13:36:40.891]                         else {
[13:36:40.891]                           version <- NULL
[13:36:40.891]                         }
[13:36:40.891]                         if (!has_future || version < "1.8.0") {
[13:36:40.891]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:40.891]                             "", base::R.version$version.string), 
[13:36:40.891]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:40.891]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:40.891]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:40.891]                               "release", "version")], collapse = " "), 
[13:36:40.891]                             hostname = base::Sys.info()[["nodename"]])
[13:36:40.891]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:40.891]                             info)
[13:36:40.891]                           info <- base::paste(info, collapse = "; ")
[13:36:40.891]                           if (!has_future) {
[13:36:40.891]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:40.891]                               info)
[13:36:40.891]                           }
[13:36:40.891]                           else {
[13:36:40.891]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:40.891]                               info, version)
[13:36:40.891]                           }
[13:36:40.891]                           base::stop(msg)
[13:36:40.891]                         }
[13:36:40.891]                       })
[13:36:40.891]                     }
[13:36:40.891]                     base::local({
[13:36:40.891]                       for (pkg in c("stats", "datasets")) {
[13:36:40.891]                         base::loadNamespace(pkg)
[13:36:40.891]                         base::library(pkg, character.only = TRUE)
[13:36:40.891]                       }
[13:36:40.891]                     })
[13:36:40.891]                   }
[13:36:40.891]                   ...future.strategy.old <- future::plan("list")
[13:36:40.891]                   options(future.plan = NULL)
[13:36:40.891]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.891]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:40.891]                 }
[13:36:40.891]                 ...future.workdir <- getwd()
[13:36:40.891]             }
[13:36:40.891]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:40.891]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:40.891]         }
[13:36:40.891]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:40.891]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:40.891]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:40.891]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:40.891]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:40.891]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:40.891]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:40.891]             base::names(...future.oldOptions))
[13:36:40.891]     }
[13:36:40.891]     if (FALSE) {
[13:36:40.891]     }
[13:36:40.891]     else {
[13:36:40.891]         if (TRUE) {
[13:36:40.891]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:40.891]                 open = "w")
[13:36:40.891]         }
[13:36:40.891]         else {
[13:36:40.891]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:40.891]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:40.891]         }
[13:36:40.891]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:40.891]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:40.891]             base::sink(type = "output", split = FALSE)
[13:36:40.891]             base::close(...future.stdout)
[13:36:40.891]         }, add = TRUE)
[13:36:40.891]     }
[13:36:40.891]     ...future.frame <- base::sys.nframe()
[13:36:40.891]     ...future.conditions <- base::list()
[13:36:40.891]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:40.891]     if (FALSE) {
[13:36:40.891]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:40.891]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:40.891]     }
[13:36:40.891]     ...future.result <- base::tryCatch({
[13:36:40.891]         base::withCallingHandlers({
[13:36:40.891]             ...future.value <- base::withVisible(base::local({
[13:36:40.891]                 lm(dist ~ speed + I(speed^2), data = cars)
[13:36:40.891]             }))
[13:36:40.891]             future::FutureResult(value = ...future.value$value, 
[13:36:40.891]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.891]                   ...future.rng), globalenv = if (FALSE) 
[13:36:40.891]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:40.891]                     ...future.globalenv.names))
[13:36:40.891]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:40.891]         }, condition = base::local({
[13:36:40.891]             c <- base::c
[13:36:40.891]             inherits <- base::inherits
[13:36:40.891]             invokeRestart <- base::invokeRestart
[13:36:40.891]             length <- base::length
[13:36:40.891]             list <- base::list
[13:36:40.891]             seq.int <- base::seq.int
[13:36:40.891]             signalCondition <- base::signalCondition
[13:36:40.891]             sys.calls <- base::sys.calls
[13:36:40.891]             `[[` <- base::`[[`
[13:36:40.891]             `+` <- base::`+`
[13:36:40.891]             `<<-` <- base::`<<-`
[13:36:40.891]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:40.891]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:40.891]                   3L)]
[13:36:40.891]             }
[13:36:40.891]             function(cond) {
[13:36:40.891]                 is_error <- inherits(cond, "error")
[13:36:40.891]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:40.891]                   NULL)
[13:36:40.891]                 if (is_error) {
[13:36:40.891]                   sessionInformation <- function() {
[13:36:40.891]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:40.891]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:40.891]                       search = base::search(), system = base::Sys.info())
[13:36:40.891]                   }
[13:36:40.891]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.891]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:40.891]                     cond$call), session = sessionInformation(), 
[13:36:40.891]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:40.891]                   signalCondition(cond)
[13:36:40.891]                 }
[13:36:40.891]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:40.891]                 "immediateCondition"))) {
[13:36:40.891]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:40.891]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.891]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:40.891]                   if (TRUE && !signal) {
[13:36:40.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.891]                     {
[13:36:40.891]                       inherits <- base::inherits
[13:36:40.891]                       invokeRestart <- base::invokeRestart
[13:36:40.891]                       is.null <- base::is.null
[13:36:40.891]                       muffled <- FALSE
[13:36:40.891]                       if (inherits(cond, "message")) {
[13:36:40.891]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.891]                         if (muffled) 
[13:36:40.891]                           invokeRestart("muffleMessage")
[13:36:40.891]                       }
[13:36:40.891]                       else if (inherits(cond, "warning")) {
[13:36:40.891]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.891]                         if (muffled) 
[13:36:40.891]                           invokeRestart("muffleWarning")
[13:36:40.891]                       }
[13:36:40.891]                       else if (inherits(cond, "condition")) {
[13:36:40.891]                         if (!is.null(pattern)) {
[13:36:40.891]                           computeRestarts <- base::computeRestarts
[13:36:40.891]                           grepl <- base::grepl
[13:36:40.891]                           restarts <- computeRestarts(cond)
[13:36:40.891]                           for (restart in restarts) {
[13:36:40.891]                             name <- restart$name
[13:36:40.891]                             if (is.null(name)) 
[13:36:40.891]                               next
[13:36:40.891]                             if (!grepl(pattern, name)) 
[13:36:40.891]                               next
[13:36:40.891]                             invokeRestart(restart)
[13:36:40.891]                             muffled <- TRUE
[13:36:40.891]                             break
[13:36:40.891]                           }
[13:36:40.891]                         }
[13:36:40.891]                       }
[13:36:40.891]                       invisible(muffled)
[13:36:40.891]                     }
[13:36:40.891]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.891]                   }
[13:36:40.891]                 }
[13:36:40.891]                 else {
[13:36:40.891]                   if (TRUE) {
[13:36:40.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.891]                     {
[13:36:40.891]                       inherits <- base::inherits
[13:36:40.891]                       invokeRestart <- base::invokeRestart
[13:36:40.891]                       is.null <- base::is.null
[13:36:40.891]                       muffled <- FALSE
[13:36:40.891]                       if (inherits(cond, "message")) {
[13:36:40.891]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.891]                         if (muffled) 
[13:36:40.891]                           invokeRestart("muffleMessage")
[13:36:40.891]                       }
[13:36:40.891]                       else if (inherits(cond, "warning")) {
[13:36:40.891]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.891]                         if (muffled) 
[13:36:40.891]                           invokeRestart("muffleWarning")
[13:36:40.891]                       }
[13:36:40.891]                       else if (inherits(cond, "condition")) {
[13:36:40.891]                         if (!is.null(pattern)) {
[13:36:40.891]                           computeRestarts <- base::computeRestarts
[13:36:40.891]                           grepl <- base::grepl
[13:36:40.891]                           restarts <- computeRestarts(cond)
[13:36:40.891]                           for (restart in restarts) {
[13:36:40.891]                             name <- restart$name
[13:36:40.891]                             if (is.null(name)) 
[13:36:40.891]                               next
[13:36:40.891]                             if (!grepl(pattern, name)) 
[13:36:40.891]                               next
[13:36:40.891]                             invokeRestart(restart)
[13:36:40.891]                             muffled <- TRUE
[13:36:40.891]                             break
[13:36:40.891]                           }
[13:36:40.891]                         }
[13:36:40.891]                       }
[13:36:40.891]                       invisible(muffled)
[13:36:40.891]                     }
[13:36:40.891]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.891]                   }
[13:36:40.891]                 }
[13:36:40.891]             }
[13:36:40.891]         }))
[13:36:40.891]     }, error = function(ex) {
[13:36:40.891]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:40.891]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.891]                 ...future.rng), started = ...future.startTime, 
[13:36:40.891]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:40.891]             version = "1.8"), class = "FutureResult")
[13:36:40.891]     }, finally = {
[13:36:40.891]         if (!identical(...future.workdir, getwd())) 
[13:36:40.891]             setwd(...future.workdir)
[13:36:40.891]         {
[13:36:40.891]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:40.891]                 ...future.oldOptions$nwarnings <- NULL
[13:36:40.891]             }
[13:36:40.891]             base::options(...future.oldOptions)
[13:36:40.891]             if (.Platform$OS.type == "windows") {
[13:36:40.891]                 old_names <- names(...future.oldEnvVars)
[13:36:40.891]                 envs <- base::Sys.getenv()
[13:36:40.891]                 names <- names(envs)
[13:36:40.891]                 common <- intersect(names, old_names)
[13:36:40.891]                 added <- setdiff(names, old_names)
[13:36:40.891]                 removed <- setdiff(old_names, names)
[13:36:40.891]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:40.891]                   envs[common]]
[13:36:40.891]                 NAMES <- toupper(changed)
[13:36:40.891]                 args <- list()
[13:36:40.891]                 for (kk in seq_along(NAMES)) {
[13:36:40.891]                   name <- changed[[kk]]
[13:36:40.891]                   NAME <- NAMES[[kk]]
[13:36:40.891]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.891]                     next
[13:36:40.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.891]                 }
[13:36:40.891]                 NAMES <- toupper(added)
[13:36:40.891]                 for (kk in seq_along(NAMES)) {
[13:36:40.891]                   name <- added[[kk]]
[13:36:40.891]                   NAME <- NAMES[[kk]]
[13:36:40.891]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.891]                     next
[13:36:40.891]                   args[[name]] <- ""
[13:36:40.891]                 }
[13:36:40.891]                 NAMES <- toupper(removed)
[13:36:40.891]                 for (kk in seq_along(NAMES)) {
[13:36:40.891]                   name <- removed[[kk]]
[13:36:40.891]                   NAME <- NAMES[[kk]]
[13:36:40.891]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.891]                     next
[13:36:40.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.891]                 }
[13:36:40.891]                 if (length(args) > 0) 
[13:36:40.891]                   base::do.call(base::Sys.setenv, args = args)
[13:36:40.891]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:40.891]             }
[13:36:40.891]             else {
[13:36:40.891]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:40.891]             }
[13:36:40.891]             {
[13:36:40.891]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:40.891]                   0L) {
[13:36:40.891]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:40.891]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:40.891]                   base::options(opts)
[13:36:40.891]                 }
[13:36:40.891]                 {
[13:36:40.891]                   {
[13:36:40.891]                     NULL
[13:36:40.891]                     RNGkind("Mersenne-Twister")
[13:36:40.891]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:40.891]                       inherits = FALSE)
[13:36:40.891]                   }
[13:36:40.891]                   options(future.plan = NULL)
[13:36:40.891]                   if (is.na(NA_character_)) 
[13:36:40.891]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.891]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:40.891]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:40.891]                     .init = FALSE)
[13:36:40.891]                 }
[13:36:40.891]             }
[13:36:40.891]         }
[13:36:40.891]     })
[13:36:40.891]     if (TRUE) {
[13:36:40.891]         base::sink(type = "output", split = FALSE)
[13:36:40.891]         if (TRUE) {
[13:36:40.891]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:40.891]         }
[13:36:40.891]         else {
[13:36:40.891]             ...future.result["stdout"] <- base::list(NULL)
[13:36:40.891]         }
[13:36:40.891]         base::close(...future.stdout)
[13:36:40.891]         ...future.stdout <- NULL
[13:36:40.891]     }
[13:36:40.891]     ...future.result$conditions <- ...future.conditions
[13:36:40.891]     ...future.result$finished <- base::Sys.time()
[13:36:40.891]     ...future.result
[13:36:40.891] }
[13:36:40.893] plan(): Setting new future strategy stack:
[13:36:40.893] List of future strategies:
[13:36:40.893] 1. sequential:
[13:36:40.893]    - args: function (..., envir = parent.frame())
[13:36:40.893]    - tweaked: FALSE
[13:36:40.893]    - call: NULL
[13:36:40.894] plan(): nbrOfWorkers() = 1
[13:36:40.895] plan(): Setting new future strategy stack:
[13:36:40.896] List of future strategies:
[13:36:40.896] 1. sequential:
[13:36:40.896]    - args: function (..., envir = parent.frame())
[13:36:40.896]    - tweaked: FALSE
[13:36:40.896]    - call: plan(strategy)
[13:36:40.896] plan(): nbrOfWorkers() = 1
[13:36:40.896] SequentialFuture started (and completed)
[13:36:40.896] - Launch lazy future ... done
[13:36:40.896] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[13:36:40.899] getGlobalsAndPackages() ...
[13:36:40.900] Searching for globals...
[13:36:40.901] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[13:36:40.901] Searching for globals ... DONE
[13:36:40.901] Resolving globals: FALSE
[13:36:40.901] 
[13:36:40.902] - packages: [2] ‘stats’, ‘datasets’
[13:36:40.902] getGlobalsAndPackages() ... DONE
[13:36:40.902] run() for ‘Future’ ...
[13:36:40.902] - state: ‘created’
[13:36:40.902] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:40.902] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:40.903] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:40.903]   - Field: ‘label’
[13:36:40.903]   - Field: ‘local’
[13:36:40.903]   - Field: ‘owner’
[13:36:40.903]   - Field: ‘envir’
[13:36:40.903]   - Field: ‘packages’
[13:36:40.903]   - Field: ‘gc’
[13:36:40.903]   - Field: ‘conditions’
[13:36:40.903]   - Field: ‘expr’
[13:36:40.903]   - Field: ‘uuid’
[13:36:40.903]   - Field: ‘seed’
[13:36:40.903]   - Field: ‘version’
[13:36:40.904]   - Field: ‘result’
[13:36:40.904]   - Field: ‘asynchronous’
[13:36:40.904]   - Field: ‘calls’
[13:36:40.904]   - Field: ‘globals’
[13:36:40.904]   - Field: ‘stdout’
[13:36:40.904]   - Field: ‘earlySignal’
[13:36:40.904]   - Field: ‘lazy’
[13:36:40.904]   - Field: ‘state’
[13:36:40.904] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:40.904] - Launch lazy future ...
[13:36:40.904] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:36:40.905] Packages needed by future strategies (n = 0): <none>
[13:36:40.905] {
[13:36:40.905]     {
[13:36:40.905]         {
[13:36:40.905]             ...future.startTime <- base::Sys.time()
[13:36:40.905]             {
[13:36:40.905]                 {
[13:36:40.905]                   {
[13:36:40.905]                     {
[13:36:40.905]                       base::local({
[13:36:40.905]                         has_future <- base::requireNamespace("future", 
[13:36:40.905]                           quietly = TRUE)
[13:36:40.905]                         if (has_future) {
[13:36:40.905]                           ns <- base::getNamespace("future")
[13:36:40.905]                           version <- ns[[".package"]][["version"]]
[13:36:40.905]                           if (is.null(version)) 
[13:36:40.905]                             version <- utils::packageVersion("future")
[13:36:40.905]                         }
[13:36:40.905]                         else {
[13:36:40.905]                           version <- NULL
[13:36:40.905]                         }
[13:36:40.905]                         if (!has_future || version < "1.8.0") {
[13:36:40.905]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:40.905]                             "", base::R.version$version.string), 
[13:36:40.905]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:40.905]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:40.905]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:40.905]                               "release", "version")], collapse = " "), 
[13:36:40.905]                             hostname = base::Sys.info()[["nodename"]])
[13:36:40.905]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:40.905]                             info)
[13:36:40.905]                           info <- base::paste(info, collapse = "; ")
[13:36:40.905]                           if (!has_future) {
[13:36:40.905]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:40.905]                               info)
[13:36:40.905]                           }
[13:36:40.905]                           else {
[13:36:40.905]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:40.905]                               info, version)
[13:36:40.905]                           }
[13:36:40.905]                           base::stop(msg)
[13:36:40.905]                         }
[13:36:40.905]                       })
[13:36:40.905]                     }
[13:36:40.905]                     base::local({
[13:36:40.905]                       for (pkg in c("stats", "datasets")) {
[13:36:40.905]                         base::loadNamespace(pkg)
[13:36:40.905]                         base::library(pkg, character.only = TRUE)
[13:36:40.905]                       }
[13:36:40.905]                     })
[13:36:40.905]                   }
[13:36:40.905]                   ...future.strategy.old <- future::plan("list")
[13:36:40.905]                   options(future.plan = NULL)
[13:36:40.905]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.905]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:40.905]                 }
[13:36:40.905]                 ...future.workdir <- getwd()
[13:36:40.905]             }
[13:36:40.905]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:40.905]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:40.905]         }
[13:36:40.905]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:40.905]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:40.905]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:40.905]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:40.905]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:40.905]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:40.905]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:40.905]             base::names(...future.oldOptions))
[13:36:40.905]     }
[13:36:40.905]     if (FALSE) {
[13:36:40.905]     }
[13:36:40.905]     else {
[13:36:40.905]         if (TRUE) {
[13:36:40.905]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:40.905]                 open = "w")
[13:36:40.905]         }
[13:36:40.905]         else {
[13:36:40.905]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:40.905]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:40.905]         }
[13:36:40.905]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:40.905]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:40.905]             base::sink(type = "output", split = FALSE)
[13:36:40.905]             base::close(...future.stdout)
[13:36:40.905]         }, add = TRUE)
[13:36:40.905]     }
[13:36:40.905]     ...future.frame <- base::sys.nframe()
[13:36:40.905]     ...future.conditions <- base::list()
[13:36:40.905]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:40.905]     if (FALSE) {
[13:36:40.905]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:40.905]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:40.905]     }
[13:36:40.905]     ...future.result <- base::tryCatch({
[13:36:40.905]         base::withCallingHandlers({
[13:36:40.905]             ...future.value <- base::withVisible(base::local({
[13:36:40.905]                 lm(dist ~ poly(speed, 2), data = cars)
[13:36:40.905]             }))
[13:36:40.905]             future::FutureResult(value = ...future.value$value, 
[13:36:40.905]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.905]                   ...future.rng), globalenv = if (FALSE) 
[13:36:40.905]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:40.905]                     ...future.globalenv.names))
[13:36:40.905]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:40.905]         }, condition = base::local({
[13:36:40.905]             c <- base::c
[13:36:40.905]             inherits <- base::inherits
[13:36:40.905]             invokeRestart <- base::invokeRestart
[13:36:40.905]             length <- base::length
[13:36:40.905]             list <- base::list
[13:36:40.905]             seq.int <- base::seq.int
[13:36:40.905]             signalCondition <- base::signalCondition
[13:36:40.905]             sys.calls <- base::sys.calls
[13:36:40.905]             `[[` <- base::`[[`
[13:36:40.905]             `+` <- base::`+`
[13:36:40.905]             `<<-` <- base::`<<-`
[13:36:40.905]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:40.905]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:40.905]                   3L)]
[13:36:40.905]             }
[13:36:40.905]             function(cond) {
[13:36:40.905]                 is_error <- inherits(cond, "error")
[13:36:40.905]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:40.905]                   NULL)
[13:36:40.905]                 if (is_error) {
[13:36:40.905]                   sessionInformation <- function() {
[13:36:40.905]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:40.905]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:40.905]                       search = base::search(), system = base::Sys.info())
[13:36:40.905]                   }
[13:36:40.905]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.905]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:40.905]                     cond$call), session = sessionInformation(), 
[13:36:40.905]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:40.905]                   signalCondition(cond)
[13:36:40.905]                 }
[13:36:40.905]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:40.905]                 "immediateCondition"))) {
[13:36:40.905]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:40.905]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.905]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:40.905]                   if (TRUE && !signal) {
[13:36:40.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.905]                     {
[13:36:40.905]                       inherits <- base::inherits
[13:36:40.905]                       invokeRestart <- base::invokeRestart
[13:36:40.905]                       is.null <- base::is.null
[13:36:40.905]                       muffled <- FALSE
[13:36:40.905]                       if (inherits(cond, "message")) {
[13:36:40.905]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.905]                         if (muffled) 
[13:36:40.905]                           invokeRestart("muffleMessage")
[13:36:40.905]                       }
[13:36:40.905]                       else if (inherits(cond, "warning")) {
[13:36:40.905]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.905]                         if (muffled) 
[13:36:40.905]                           invokeRestart("muffleWarning")
[13:36:40.905]                       }
[13:36:40.905]                       else if (inherits(cond, "condition")) {
[13:36:40.905]                         if (!is.null(pattern)) {
[13:36:40.905]                           computeRestarts <- base::computeRestarts
[13:36:40.905]                           grepl <- base::grepl
[13:36:40.905]                           restarts <- computeRestarts(cond)
[13:36:40.905]                           for (restart in restarts) {
[13:36:40.905]                             name <- restart$name
[13:36:40.905]                             if (is.null(name)) 
[13:36:40.905]                               next
[13:36:40.905]                             if (!grepl(pattern, name)) 
[13:36:40.905]                               next
[13:36:40.905]                             invokeRestart(restart)
[13:36:40.905]                             muffled <- TRUE
[13:36:40.905]                             break
[13:36:40.905]                           }
[13:36:40.905]                         }
[13:36:40.905]                       }
[13:36:40.905]                       invisible(muffled)
[13:36:40.905]                     }
[13:36:40.905]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.905]                   }
[13:36:40.905]                 }
[13:36:40.905]                 else {
[13:36:40.905]                   if (TRUE) {
[13:36:40.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.905]                     {
[13:36:40.905]                       inherits <- base::inherits
[13:36:40.905]                       invokeRestart <- base::invokeRestart
[13:36:40.905]                       is.null <- base::is.null
[13:36:40.905]                       muffled <- FALSE
[13:36:40.905]                       if (inherits(cond, "message")) {
[13:36:40.905]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.905]                         if (muffled) 
[13:36:40.905]                           invokeRestart("muffleMessage")
[13:36:40.905]                       }
[13:36:40.905]                       else if (inherits(cond, "warning")) {
[13:36:40.905]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.905]                         if (muffled) 
[13:36:40.905]                           invokeRestart("muffleWarning")
[13:36:40.905]                       }
[13:36:40.905]                       else if (inherits(cond, "condition")) {
[13:36:40.905]                         if (!is.null(pattern)) {
[13:36:40.905]                           computeRestarts <- base::computeRestarts
[13:36:40.905]                           grepl <- base::grepl
[13:36:40.905]                           restarts <- computeRestarts(cond)
[13:36:40.905]                           for (restart in restarts) {
[13:36:40.905]                             name <- restart$name
[13:36:40.905]                             if (is.null(name)) 
[13:36:40.905]                               next
[13:36:40.905]                             if (!grepl(pattern, name)) 
[13:36:40.905]                               next
[13:36:40.905]                             invokeRestart(restart)
[13:36:40.905]                             muffled <- TRUE
[13:36:40.905]                             break
[13:36:40.905]                           }
[13:36:40.905]                         }
[13:36:40.905]                       }
[13:36:40.905]                       invisible(muffled)
[13:36:40.905]                     }
[13:36:40.905]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.905]                   }
[13:36:40.905]                 }
[13:36:40.905]             }
[13:36:40.905]         }))
[13:36:40.905]     }, error = function(ex) {
[13:36:40.905]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:40.905]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.905]                 ...future.rng), started = ...future.startTime, 
[13:36:40.905]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:40.905]             version = "1.8"), class = "FutureResult")
[13:36:40.905]     }, finally = {
[13:36:40.905]         if (!identical(...future.workdir, getwd())) 
[13:36:40.905]             setwd(...future.workdir)
[13:36:40.905]         {
[13:36:40.905]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:40.905]                 ...future.oldOptions$nwarnings <- NULL
[13:36:40.905]             }
[13:36:40.905]             base::options(...future.oldOptions)
[13:36:40.905]             if (.Platform$OS.type == "windows") {
[13:36:40.905]                 old_names <- names(...future.oldEnvVars)
[13:36:40.905]                 envs <- base::Sys.getenv()
[13:36:40.905]                 names <- names(envs)
[13:36:40.905]                 common <- intersect(names, old_names)
[13:36:40.905]                 added <- setdiff(names, old_names)
[13:36:40.905]                 removed <- setdiff(old_names, names)
[13:36:40.905]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:40.905]                   envs[common]]
[13:36:40.905]                 NAMES <- toupper(changed)
[13:36:40.905]                 args <- list()
[13:36:40.905]                 for (kk in seq_along(NAMES)) {
[13:36:40.905]                   name <- changed[[kk]]
[13:36:40.905]                   NAME <- NAMES[[kk]]
[13:36:40.905]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.905]                     next
[13:36:40.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.905]                 }
[13:36:40.905]                 NAMES <- toupper(added)
[13:36:40.905]                 for (kk in seq_along(NAMES)) {
[13:36:40.905]                   name <- added[[kk]]
[13:36:40.905]                   NAME <- NAMES[[kk]]
[13:36:40.905]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.905]                     next
[13:36:40.905]                   args[[name]] <- ""
[13:36:40.905]                 }
[13:36:40.905]                 NAMES <- toupper(removed)
[13:36:40.905]                 for (kk in seq_along(NAMES)) {
[13:36:40.905]                   name <- removed[[kk]]
[13:36:40.905]                   NAME <- NAMES[[kk]]
[13:36:40.905]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.905]                     next
[13:36:40.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.905]                 }
[13:36:40.905]                 if (length(args) > 0) 
[13:36:40.905]                   base::do.call(base::Sys.setenv, args = args)
[13:36:40.905]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:40.905]             }
[13:36:40.905]             else {
[13:36:40.905]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:40.905]             }
[13:36:40.905]             {
[13:36:40.905]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:40.905]                   0L) {
[13:36:40.905]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:40.905]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:40.905]                   base::options(opts)
[13:36:40.905]                 }
[13:36:40.905]                 {
[13:36:40.905]                   {
[13:36:40.905]                     NULL
[13:36:40.905]                     RNGkind("Mersenne-Twister")
[13:36:40.905]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:40.905]                       inherits = FALSE)
[13:36:40.905]                   }
[13:36:40.905]                   options(future.plan = NULL)
[13:36:40.905]                   if (is.na(NA_character_)) 
[13:36:40.905]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.905]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:40.905]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:40.905]                     .init = FALSE)
[13:36:40.905]                 }
[13:36:40.905]             }
[13:36:40.905]         }
[13:36:40.905]     })
[13:36:40.905]     if (TRUE) {
[13:36:40.905]         base::sink(type = "output", split = FALSE)
[13:36:40.905]         if (TRUE) {
[13:36:40.905]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:40.905]         }
[13:36:40.905]         else {
[13:36:40.905]             ...future.result["stdout"] <- base::list(NULL)
[13:36:40.905]         }
[13:36:40.905]         base::close(...future.stdout)
[13:36:40.905]         ...future.stdout <- NULL
[13:36:40.905]     }
[13:36:40.905]     ...future.result$conditions <- ...future.conditions
[13:36:40.905]     ...future.result$finished <- base::Sys.time()
[13:36:40.905]     ...future.result
[13:36:40.905] }
[13:36:40.907] plan(): Setting new future strategy stack:
[13:36:40.907] List of future strategies:
[13:36:40.907] 1. sequential:
[13:36:40.907]    - args: function (..., envir = parent.frame())
[13:36:40.907]    - tweaked: FALSE
[13:36:40.907]    - call: NULL
[13:36:40.907] plan(): nbrOfWorkers() = 1
[13:36:40.909] plan(): Setting new future strategy stack:
[13:36:40.909] List of future strategies:
[13:36:40.909] 1. sequential:
[13:36:40.909]    - args: function (..., envir = parent.frame())
[13:36:40.909]    - tweaked: FALSE
[13:36:40.909]    - call: plan(strategy)
[13:36:40.909] plan(): nbrOfWorkers() = 1
[13:36:40.909] SequentialFuture started (and completed)
[13:36:40.909] - Launch lazy future ... done
[13:36:40.909] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[13:36:40.911] getGlobalsAndPackages() ...
[13:36:40.911] Searching for globals...
[13:36:40.917] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[13:36:40.917] Searching for globals ... DONE
[13:36:40.917] Resolving globals: FALSE
[13:36:40.918] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[13:36:40.918] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[13:36:40.918] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[13:36:40.918] 
[13:36:40.919] getGlobalsAndPackages() ... DONE
[13:36:40.919] run() for ‘Future’ ...
[13:36:40.919] - state: ‘created’
[13:36:40.919] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:40.919] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:40.919] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:40.919]   - Field: ‘label’
[13:36:40.919]   - Field: ‘local’
[13:36:40.920]   - Field: ‘owner’
[13:36:40.920]   - Field: ‘envir’
[13:36:40.920]   - Field: ‘packages’
[13:36:40.920]   - Field: ‘gc’
[13:36:40.920]   - Field: ‘conditions’
[13:36:40.920]   - Field: ‘expr’
[13:36:40.920]   - Field: ‘uuid’
[13:36:40.920]   - Field: ‘seed’
[13:36:40.920]   - Field: ‘version’
[13:36:40.920]   - Field: ‘result’
[13:36:40.920]   - Field: ‘asynchronous’
[13:36:40.921]   - Field: ‘calls’
[13:36:40.921]   - Field: ‘globals’
[13:36:40.921]   - Field: ‘stdout’
[13:36:40.921]   - Field: ‘earlySignal’
[13:36:40.921]   - Field: ‘lazy’
[13:36:40.921]   - Field: ‘state’
[13:36:40.921] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:40.921] - Launch lazy future ...
[13:36:40.921] Packages needed by the future expression (n = 0): <none>
[13:36:40.921] Packages needed by future strategies (n = 0): <none>
[13:36:40.922] {
[13:36:40.922]     {
[13:36:40.922]         {
[13:36:40.922]             ...future.startTime <- base::Sys.time()
[13:36:40.922]             {
[13:36:40.922]                 {
[13:36:40.922]                   {
[13:36:40.922]                     base::local({
[13:36:40.922]                       has_future <- base::requireNamespace("future", 
[13:36:40.922]                         quietly = TRUE)
[13:36:40.922]                       if (has_future) {
[13:36:40.922]                         ns <- base::getNamespace("future")
[13:36:40.922]                         version <- ns[[".package"]][["version"]]
[13:36:40.922]                         if (is.null(version)) 
[13:36:40.922]                           version <- utils::packageVersion("future")
[13:36:40.922]                       }
[13:36:40.922]                       else {
[13:36:40.922]                         version <- NULL
[13:36:40.922]                       }
[13:36:40.922]                       if (!has_future || version < "1.8.0") {
[13:36:40.922]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:40.922]                           "", base::R.version$version.string), 
[13:36:40.922]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:40.922]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:40.922]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:40.922]                             "release", "version")], collapse = " "), 
[13:36:40.922]                           hostname = base::Sys.info()[["nodename"]])
[13:36:40.922]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:40.922]                           info)
[13:36:40.922]                         info <- base::paste(info, collapse = "; ")
[13:36:40.922]                         if (!has_future) {
[13:36:40.922]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:40.922]                             info)
[13:36:40.922]                         }
[13:36:40.922]                         else {
[13:36:40.922]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:40.922]                             info, version)
[13:36:40.922]                         }
[13:36:40.922]                         base::stop(msg)
[13:36:40.922]                       }
[13:36:40.922]                     })
[13:36:40.922]                   }
[13:36:40.922]                   ...future.strategy.old <- future::plan("list")
[13:36:40.922]                   options(future.plan = NULL)
[13:36:40.922]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.922]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:40.922]                 }
[13:36:40.922]                 ...future.workdir <- getwd()
[13:36:40.922]             }
[13:36:40.922]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:40.922]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:40.922]         }
[13:36:40.922]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:40.922]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:40.922]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:40.922]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:40.922]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:40.922]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:40.922]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:40.922]             base::names(...future.oldOptions))
[13:36:40.922]     }
[13:36:40.922]     if (FALSE) {
[13:36:40.922]     }
[13:36:40.922]     else {
[13:36:40.922]         if (TRUE) {
[13:36:40.922]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:40.922]                 open = "w")
[13:36:40.922]         }
[13:36:40.922]         else {
[13:36:40.922]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:40.922]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:40.922]         }
[13:36:40.922]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:40.922]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:40.922]             base::sink(type = "output", split = FALSE)
[13:36:40.922]             base::close(...future.stdout)
[13:36:40.922]         }, add = TRUE)
[13:36:40.922]     }
[13:36:40.922]     ...future.frame <- base::sys.nframe()
[13:36:40.922]     ...future.conditions <- base::list()
[13:36:40.922]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:40.922]     if (FALSE) {
[13:36:40.922]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:40.922]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:40.922]     }
[13:36:40.922]     ...future.result <- base::tryCatch({
[13:36:40.922]         base::withCallingHandlers({
[13:36:40.922]             ...future.value <- base::withVisible(base::local({
[13:36:40.922]                 outer_function(1L)
[13:36:40.922]             }))
[13:36:40.922]             future::FutureResult(value = ...future.value$value, 
[13:36:40.922]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.922]                   ...future.rng), globalenv = if (FALSE) 
[13:36:40.922]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:40.922]                     ...future.globalenv.names))
[13:36:40.922]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:40.922]         }, condition = base::local({
[13:36:40.922]             c <- base::c
[13:36:40.922]             inherits <- base::inherits
[13:36:40.922]             invokeRestart <- base::invokeRestart
[13:36:40.922]             length <- base::length
[13:36:40.922]             list <- base::list
[13:36:40.922]             seq.int <- base::seq.int
[13:36:40.922]             signalCondition <- base::signalCondition
[13:36:40.922]             sys.calls <- base::sys.calls
[13:36:40.922]             `[[` <- base::`[[`
[13:36:40.922]             `+` <- base::`+`
[13:36:40.922]             `<<-` <- base::`<<-`
[13:36:40.922]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:40.922]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:40.922]                   3L)]
[13:36:40.922]             }
[13:36:40.922]             function(cond) {
[13:36:40.922]                 is_error <- inherits(cond, "error")
[13:36:40.922]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:40.922]                   NULL)
[13:36:40.922]                 if (is_error) {
[13:36:40.922]                   sessionInformation <- function() {
[13:36:40.922]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:40.922]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:40.922]                       search = base::search(), system = base::Sys.info())
[13:36:40.922]                   }
[13:36:40.922]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.922]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:40.922]                     cond$call), session = sessionInformation(), 
[13:36:40.922]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:40.922]                   signalCondition(cond)
[13:36:40.922]                 }
[13:36:40.922]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:40.922]                 "immediateCondition"))) {
[13:36:40.922]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:40.922]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.922]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:40.922]                   if (TRUE && !signal) {
[13:36:40.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.922]                     {
[13:36:40.922]                       inherits <- base::inherits
[13:36:40.922]                       invokeRestart <- base::invokeRestart
[13:36:40.922]                       is.null <- base::is.null
[13:36:40.922]                       muffled <- FALSE
[13:36:40.922]                       if (inherits(cond, "message")) {
[13:36:40.922]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.922]                         if (muffled) 
[13:36:40.922]                           invokeRestart("muffleMessage")
[13:36:40.922]                       }
[13:36:40.922]                       else if (inherits(cond, "warning")) {
[13:36:40.922]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.922]                         if (muffled) 
[13:36:40.922]                           invokeRestart("muffleWarning")
[13:36:40.922]                       }
[13:36:40.922]                       else if (inherits(cond, "condition")) {
[13:36:40.922]                         if (!is.null(pattern)) {
[13:36:40.922]                           computeRestarts <- base::computeRestarts
[13:36:40.922]                           grepl <- base::grepl
[13:36:40.922]                           restarts <- computeRestarts(cond)
[13:36:40.922]                           for (restart in restarts) {
[13:36:40.922]                             name <- restart$name
[13:36:40.922]                             if (is.null(name)) 
[13:36:40.922]                               next
[13:36:40.922]                             if (!grepl(pattern, name)) 
[13:36:40.922]                               next
[13:36:40.922]                             invokeRestart(restart)
[13:36:40.922]                             muffled <- TRUE
[13:36:40.922]                             break
[13:36:40.922]                           }
[13:36:40.922]                         }
[13:36:40.922]                       }
[13:36:40.922]                       invisible(muffled)
[13:36:40.922]                     }
[13:36:40.922]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.922]                   }
[13:36:40.922]                 }
[13:36:40.922]                 else {
[13:36:40.922]                   if (TRUE) {
[13:36:40.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.922]                     {
[13:36:40.922]                       inherits <- base::inherits
[13:36:40.922]                       invokeRestart <- base::invokeRestart
[13:36:40.922]                       is.null <- base::is.null
[13:36:40.922]                       muffled <- FALSE
[13:36:40.922]                       if (inherits(cond, "message")) {
[13:36:40.922]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.922]                         if (muffled) 
[13:36:40.922]                           invokeRestart("muffleMessage")
[13:36:40.922]                       }
[13:36:40.922]                       else if (inherits(cond, "warning")) {
[13:36:40.922]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.922]                         if (muffled) 
[13:36:40.922]                           invokeRestart("muffleWarning")
[13:36:40.922]                       }
[13:36:40.922]                       else if (inherits(cond, "condition")) {
[13:36:40.922]                         if (!is.null(pattern)) {
[13:36:40.922]                           computeRestarts <- base::computeRestarts
[13:36:40.922]                           grepl <- base::grepl
[13:36:40.922]                           restarts <- computeRestarts(cond)
[13:36:40.922]                           for (restart in restarts) {
[13:36:40.922]                             name <- restart$name
[13:36:40.922]                             if (is.null(name)) 
[13:36:40.922]                               next
[13:36:40.922]                             if (!grepl(pattern, name)) 
[13:36:40.922]                               next
[13:36:40.922]                             invokeRestart(restart)
[13:36:40.922]                             muffled <- TRUE
[13:36:40.922]                             break
[13:36:40.922]                           }
[13:36:40.922]                         }
[13:36:40.922]                       }
[13:36:40.922]                       invisible(muffled)
[13:36:40.922]                     }
[13:36:40.922]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.922]                   }
[13:36:40.922]                 }
[13:36:40.922]             }
[13:36:40.922]         }))
[13:36:40.922]     }, error = function(ex) {
[13:36:40.922]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:40.922]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.922]                 ...future.rng), started = ...future.startTime, 
[13:36:40.922]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:40.922]             version = "1.8"), class = "FutureResult")
[13:36:40.922]     }, finally = {
[13:36:40.922]         if (!identical(...future.workdir, getwd())) 
[13:36:40.922]             setwd(...future.workdir)
[13:36:40.922]         {
[13:36:40.922]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:40.922]                 ...future.oldOptions$nwarnings <- NULL
[13:36:40.922]             }
[13:36:40.922]             base::options(...future.oldOptions)
[13:36:40.922]             if (.Platform$OS.type == "windows") {
[13:36:40.922]                 old_names <- names(...future.oldEnvVars)
[13:36:40.922]                 envs <- base::Sys.getenv()
[13:36:40.922]                 names <- names(envs)
[13:36:40.922]                 common <- intersect(names, old_names)
[13:36:40.922]                 added <- setdiff(names, old_names)
[13:36:40.922]                 removed <- setdiff(old_names, names)
[13:36:40.922]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:40.922]                   envs[common]]
[13:36:40.922]                 NAMES <- toupper(changed)
[13:36:40.922]                 args <- list()
[13:36:40.922]                 for (kk in seq_along(NAMES)) {
[13:36:40.922]                   name <- changed[[kk]]
[13:36:40.922]                   NAME <- NAMES[[kk]]
[13:36:40.922]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.922]                     next
[13:36:40.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.922]                 }
[13:36:40.922]                 NAMES <- toupper(added)
[13:36:40.922]                 for (kk in seq_along(NAMES)) {
[13:36:40.922]                   name <- added[[kk]]
[13:36:40.922]                   NAME <- NAMES[[kk]]
[13:36:40.922]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.922]                     next
[13:36:40.922]                   args[[name]] <- ""
[13:36:40.922]                 }
[13:36:40.922]                 NAMES <- toupper(removed)
[13:36:40.922]                 for (kk in seq_along(NAMES)) {
[13:36:40.922]                   name <- removed[[kk]]
[13:36:40.922]                   NAME <- NAMES[[kk]]
[13:36:40.922]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.922]                     next
[13:36:40.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.922]                 }
[13:36:40.922]                 if (length(args) > 0) 
[13:36:40.922]                   base::do.call(base::Sys.setenv, args = args)
[13:36:40.922]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:40.922]             }
[13:36:40.922]             else {
[13:36:40.922]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:40.922]             }
[13:36:40.922]             {
[13:36:40.922]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:40.922]                   0L) {
[13:36:40.922]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:40.922]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:40.922]                   base::options(opts)
[13:36:40.922]                 }
[13:36:40.922]                 {
[13:36:40.922]                   {
[13:36:40.922]                     NULL
[13:36:40.922]                     RNGkind("Mersenne-Twister")
[13:36:40.922]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:40.922]                       inherits = FALSE)
[13:36:40.922]                   }
[13:36:40.922]                   options(future.plan = NULL)
[13:36:40.922]                   if (is.na(NA_character_)) 
[13:36:40.922]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.922]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:40.922]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:40.922]                     .init = FALSE)
[13:36:40.922]                 }
[13:36:40.922]             }
[13:36:40.922]         }
[13:36:40.922]     })
[13:36:40.922]     if (TRUE) {
[13:36:40.922]         base::sink(type = "output", split = FALSE)
[13:36:40.922]         if (TRUE) {
[13:36:40.922]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:40.922]         }
[13:36:40.922]         else {
[13:36:40.922]             ...future.result["stdout"] <- base::list(NULL)
[13:36:40.922]         }
[13:36:40.922]         base::close(...future.stdout)
[13:36:40.922]         ...future.stdout <- NULL
[13:36:40.922]     }
[13:36:40.922]     ...future.result$conditions <- ...future.conditions
[13:36:40.922]     ...future.result$finished <- base::Sys.time()
[13:36:40.922]     ...future.result
[13:36:40.922] }
[13:36:40.923] assign_globals() ...
[13:36:40.923] List of 3
[13:36:40.923]  $ outer_function:function (x)  
[13:36:40.923]  $ map           :function (.x, .f, ...)  
[13:36:40.923]  $ inner_function:function (x)  
[13:36:40.923]  - attr(*, "where")=List of 3
[13:36:40.923]   ..$ outer_function:<environment: R_EmptyEnv> 
[13:36:40.923]   ..$ map           :<environment: R_EmptyEnv> 
[13:36:40.923]   ..$ inner_function:<environment: R_EmptyEnv> 
[13:36:40.923]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:40.923]  - attr(*, "resolved")= logi FALSE
[13:36:40.923]  - attr(*, "total_size")= num 7704
[13:36:40.923]  - attr(*, "already-done")= logi TRUE
[13:36:40.927] - reassign environment for ‘outer_function’
[13:36:40.927] - copied ‘outer_function’ to environment
[13:36:40.927] - reassign environment for ‘map’
[13:36:40.927] - copied ‘map’ to environment
[13:36:40.927] - reassign environment for ‘inner_function’
[13:36:40.927] - copied ‘inner_function’ to environment
[13:36:40.927] assign_globals() ... done
[13:36:40.927] plan(): Setting new future strategy stack:
[13:36:40.927] List of future strategies:
[13:36:40.927] 1. sequential:
[13:36:40.927]    - args: function (..., envir = parent.frame())
[13:36:40.927]    - tweaked: FALSE
[13:36:40.927]    - call: NULL
[13:36:40.928] plan(): nbrOfWorkers() = 1
[13:36:40.933] plan(): Setting new future strategy stack:
[13:36:40.933] List of future strategies:
[13:36:40.933] 1. sequential:
[13:36:40.933]    - args: function (..., envir = parent.frame())
[13:36:40.933]    - tweaked: FALSE
[13:36:40.933]    - call: plan(strategy)
[13:36:40.933] plan(): nbrOfWorkers() = 1
[13:36:40.933] SequentialFuture started (and completed)
[13:36:40.933] - Launch lazy future ... done
[13:36:40.933] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[13:36:40.935] getGlobalsAndPackages() ...
[13:36:40.935] Searching for globals...
[13:36:40.940] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[13:36:40.940] Searching for globals ... DONE
[13:36:40.940] Resolving globals: FALSE
[13:36:40.941] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[13:36:40.941] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[13:36:40.942] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[13:36:40.942] 
[13:36:40.942] getGlobalsAndPackages() ... DONE
[13:36:40.942] run() for ‘Future’ ...
[13:36:40.942] - state: ‘created’
[13:36:40.942] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:40.943] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:40.943] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:40.943]   - Field: ‘label’
[13:36:40.943]   - Field: ‘local’
[13:36:40.943]   - Field: ‘owner’
[13:36:40.943]   - Field: ‘envir’
[13:36:40.943]   - Field: ‘packages’
[13:36:40.943]   - Field: ‘gc’
[13:36:40.943]   - Field: ‘conditions’
[13:36:40.943]   - Field: ‘expr’
[13:36:40.943]   - Field: ‘uuid’
[13:36:40.944]   - Field: ‘seed’
[13:36:40.944]   - Field: ‘version’
[13:36:40.944]   - Field: ‘result’
[13:36:40.944]   - Field: ‘asynchronous’
[13:36:40.944]   - Field: ‘calls’
[13:36:40.944]   - Field: ‘globals’
[13:36:40.944]   - Field: ‘stdout’
[13:36:40.944]   - Field: ‘earlySignal’
[13:36:40.944]   - Field: ‘lazy’
[13:36:40.944]   - Field: ‘state’
[13:36:40.944] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:40.945] - Launch lazy future ...
[13:36:40.945] Packages needed by the future expression (n = 0): <none>
[13:36:40.945] Packages needed by future strategies (n = 0): <none>
[13:36:40.945] {
[13:36:40.945]     {
[13:36:40.945]         {
[13:36:40.945]             ...future.startTime <- base::Sys.time()
[13:36:40.945]             {
[13:36:40.945]                 {
[13:36:40.945]                   {
[13:36:40.945]                     base::local({
[13:36:40.945]                       has_future <- base::requireNamespace("future", 
[13:36:40.945]                         quietly = TRUE)
[13:36:40.945]                       if (has_future) {
[13:36:40.945]                         ns <- base::getNamespace("future")
[13:36:40.945]                         version <- ns[[".package"]][["version"]]
[13:36:40.945]                         if (is.null(version)) 
[13:36:40.945]                           version <- utils::packageVersion("future")
[13:36:40.945]                       }
[13:36:40.945]                       else {
[13:36:40.945]                         version <- NULL
[13:36:40.945]                       }
[13:36:40.945]                       if (!has_future || version < "1.8.0") {
[13:36:40.945]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:40.945]                           "", base::R.version$version.string), 
[13:36:40.945]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:40.945]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:40.945]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:40.945]                             "release", "version")], collapse = " "), 
[13:36:40.945]                           hostname = base::Sys.info()[["nodename"]])
[13:36:40.945]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:40.945]                           info)
[13:36:40.945]                         info <- base::paste(info, collapse = "; ")
[13:36:40.945]                         if (!has_future) {
[13:36:40.945]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:40.945]                             info)
[13:36:40.945]                         }
[13:36:40.945]                         else {
[13:36:40.945]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:40.945]                             info, version)
[13:36:40.945]                         }
[13:36:40.945]                         base::stop(msg)
[13:36:40.945]                       }
[13:36:40.945]                     })
[13:36:40.945]                   }
[13:36:40.945]                   ...future.strategy.old <- future::plan("list")
[13:36:40.945]                   options(future.plan = NULL)
[13:36:40.945]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.945]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:40.945]                 }
[13:36:40.945]                 ...future.workdir <- getwd()
[13:36:40.945]             }
[13:36:40.945]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:40.945]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:40.945]         }
[13:36:40.945]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:40.945]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:40.945]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:40.945]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:40.945]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:40.945]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:40.945]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:40.945]             base::names(...future.oldOptions))
[13:36:40.945]     }
[13:36:40.945]     if (FALSE) {
[13:36:40.945]     }
[13:36:40.945]     else {
[13:36:40.945]         if (TRUE) {
[13:36:40.945]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:40.945]                 open = "w")
[13:36:40.945]         }
[13:36:40.945]         else {
[13:36:40.945]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:40.945]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:40.945]         }
[13:36:40.945]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:40.945]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:40.945]             base::sink(type = "output", split = FALSE)
[13:36:40.945]             base::close(...future.stdout)
[13:36:40.945]         }, add = TRUE)
[13:36:40.945]     }
[13:36:40.945]     ...future.frame <- base::sys.nframe()
[13:36:40.945]     ...future.conditions <- base::list()
[13:36:40.945]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:40.945]     if (FALSE) {
[13:36:40.945]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:40.945]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:40.945]     }
[13:36:40.945]     ...future.result <- base::tryCatch({
[13:36:40.945]         base::withCallingHandlers({
[13:36:40.945]             ...future.value <- base::withVisible(base::local({
[13:36:40.945]                 outer_function(1L)
[13:36:40.945]             }))
[13:36:40.945]             future::FutureResult(value = ...future.value$value, 
[13:36:40.945]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.945]                   ...future.rng), globalenv = if (FALSE) 
[13:36:40.945]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:40.945]                     ...future.globalenv.names))
[13:36:40.945]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:40.945]         }, condition = base::local({
[13:36:40.945]             c <- base::c
[13:36:40.945]             inherits <- base::inherits
[13:36:40.945]             invokeRestart <- base::invokeRestart
[13:36:40.945]             length <- base::length
[13:36:40.945]             list <- base::list
[13:36:40.945]             seq.int <- base::seq.int
[13:36:40.945]             signalCondition <- base::signalCondition
[13:36:40.945]             sys.calls <- base::sys.calls
[13:36:40.945]             `[[` <- base::`[[`
[13:36:40.945]             `+` <- base::`+`
[13:36:40.945]             `<<-` <- base::`<<-`
[13:36:40.945]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:40.945]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:40.945]                   3L)]
[13:36:40.945]             }
[13:36:40.945]             function(cond) {
[13:36:40.945]                 is_error <- inherits(cond, "error")
[13:36:40.945]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:40.945]                   NULL)
[13:36:40.945]                 if (is_error) {
[13:36:40.945]                   sessionInformation <- function() {
[13:36:40.945]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:40.945]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:40.945]                       search = base::search(), system = base::Sys.info())
[13:36:40.945]                   }
[13:36:40.945]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.945]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:40.945]                     cond$call), session = sessionInformation(), 
[13:36:40.945]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:40.945]                   signalCondition(cond)
[13:36:40.945]                 }
[13:36:40.945]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:40.945]                 "immediateCondition"))) {
[13:36:40.945]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:40.945]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.945]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:40.945]                   if (TRUE && !signal) {
[13:36:40.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.945]                     {
[13:36:40.945]                       inherits <- base::inherits
[13:36:40.945]                       invokeRestart <- base::invokeRestart
[13:36:40.945]                       is.null <- base::is.null
[13:36:40.945]                       muffled <- FALSE
[13:36:40.945]                       if (inherits(cond, "message")) {
[13:36:40.945]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.945]                         if (muffled) 
[13:36:40.945]                           invokeRestart("muffleMessage")
[13:36:40.945]                       }
[13:36:40.945]                       else if (inherits(cond, "warning")) {
[13:36:40.945]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.945]                         if (muffled) 
[13:36:40.945]                           invokeRestart("muffleWarning")
[13:36:40.945]                       }
[13:36:40.945]                       else if (inherits(cond, "condition")) {
[13:36:40.945]                         if (!is.null(pattern)) {
[13:36:40.945]                           computeRestarts <- base::computeRestarts
[13:36:40.945]                           grepl <- base::grepl
[13:36:40.945]                           restarts <- computeRestarts(cond)
[13:36:40.945]                           for (restart in restarts) {
[13:36:40.945]                             name <- restart$name
[13:36:40.945]                             if (is.null(name)) 
[13:36:40.945]                               next
[13:36:40.945]                             if (!grepl(pattern, name)) 
[13:36:40.945]                               next
[13:36:40.945]                             invokeRestart(restart)
[13:36:40.945]                             muffled <- TRUE
[13:36:40.945]                             break
[13:36:40.945]                           }
[13:36:40.945]                         }
[13:36:40.945]                       }
[13:36:40.945]                       invisible(muffled)
[13:36:40.945]                     }
[13:36:40.945]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.945]                   }
[13:36:40.945]                 }
[13:36:40.945]                 else {
[13:36:40.945]                   if (TRUE) {
[13:36:40.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.945]                     {
[13:36:40.945]                       inherits <- base::inherits
[13:36:40.945]                       invokeRestart <- base::invokeRestart
[13:36:40.945]                       is.null <- base::is.null
[13:36:40.945]                       muffled <- FALSE
[13:36:40.945]                       if (inherits(cond, "message")) {
[13:36:40.945]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.945]                         if (muffled) 
[13:36:40.945]                           invokeRestart("muffleMessage")
[13:36:40.945]                       }
[13:36:40.945]                       else if (inherits(cond, "warning")) {
[13:36:40.945]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.945]                         if (muffled) 
[13:36:40.945]                           invokeRestart("muffleWarning")
[13:36:40.945]                       }
[13:36:40.945]                       else if (inherits(cond, "condition")) {
[13:36:40.945]                         if (!is.null(pattern)) {
[13:36:40.945]                           computeRestarts <- base::computeRestarts
[13:36:40.945]                           grepl <- base::grepl
[13:36:40.945]                           restarts <- computeRestarts(cond)
[13:36:40.945]                           for (restart in restarts) {
[13:36:40.945]                             name <- restart$name
[13:36:40.945]                             if (is.null(name)) 
[13:36:40.945]                               next
[13:36:40.945]                             if (!grepl(pattern, name)) 
[13:36:40.945]                               next
[13:36:40.945]                             invokeRestart(restart)
[13:36:40.945]                             muffled <- TRUE
[13:36:40.945]                             break
[13:36:40.945]                           }
[13:36:40.945]                         }
[13:36:40.945]                       }
[13:36:40.945]                       invisible(muffled)
[13:36:40.945]                     }
[13:36:40.945]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.945]                   }
[13:36:40.945]                 }
[13:36:40.945]             }
[13:36:40.945]         }))
[13:36:40.945]     }, error = function(ex) {
[13:36:40.945]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:40.945]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.945]                 ...future.rng), started = ...future.startTime, 
[13:36:40.945]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:40.945]             version = "1.8"), class = "FutureResult")
[13:36:40.945]     }, finally = {
[13:36:40.945]         if (!identical(...future.workdir, getwd())) 
[13:36:40.945]             setwd(...future.workdir)
[13:36:40.945]         {
[13:36:40.945]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:40.945]                 ...future.oldOptions$nwarnings <- NULL
[13:36:40.945]             }
[13:36:40.945]             base::options(...future.oldOptions)
[13:36:40.945]             if (.Platform$OS.type == "windows") {
[13:36:40.945]                 old_names <- names(...future.oldEnvVars)
[13:36:40.945]                 envs <- base::Sys.getenv()
[13:36:40.945]                 names <- names(envs)
[13:36:40.945]                 common <- intersect(names, old_names)
[13:36:40.945]                 added <- setdiff(names, old_names)
[13:36:40.945]                 removed <- setdiff(old_names, names)
[13:36:40.945]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:40.945]                   envs[common]]
[13:36:40.945]                 NAMES <- toupper(changed)
[13:36:40.945]                 args <- list()
[13:36:40.945]                 for (kk in seq_along(NAMES)) {
[13:36:40.945]                   name <- changed[[kk]]
[13:36:40.945]                   NAME <- NAMES[[kk]]
[13:36:40.945]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.945]                     next
[13:36:40.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.945]                 }
[13:36:40.945]                 NAMES <- toupper(added)
[13:36:40.945]                 for (kk in seq_along(NAMES)) {
[13:36:40.945]                   name <- added[[kk]]
[13:36:40.945]                   NAME <- NAMES[[kk]]
[13:36:40.945]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.945]                     next
[13:36:40.945]                   args[[name]] <- ""
[13:36:40.945]                 }
[13:36:40.945]                 NAMES <- toupper(removed)
[13:36:40.945]                 for (kk in seq_along(NAMES)) {
[13:36:40.945]                   name <- removed[[kk]]
[13:36:40.945]                   NAME <- NAMES[[kk]]
[13:36:40.945]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.945]                     next
[13:36:40.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.945]                 }
[13:36:40.945]                 if (length(args) > 0) 
[13:36:40.945]                   base::do.call(base::Sys.setenv, args = args)
[13:36:40.945]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:40.945]             }
[13:36:40.945]             else {
[13:36:40.945]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:40.945]             }
[13:36:40.945]             {
[13:36:40.945]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:40.945]                   0L) {
[13:36:40.945]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:40.945]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:40.945]                   base::options(opts)
[13:36:40.945]                 }
[13:36:40.945]                 {
[13:36:40.945]                   {
[13:36:40.945]                     NULL
[13:36:40.945]                     RNGkind("Mersenne-Twister")
[13:36:40.945]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:40.945]                       inherits = FALSE)
[13:36:40.945]                   }
[13:36:40.945]                   options(future.plan = NULL)
[13:36:40.945]                   if (is.na(NA_character_)) 
[13:36:40.945]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.945]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:40.945]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:40.945]                     .init = FALSE)
[13:36:40.945]                 }
[13:36:40.945]             }
[13:36:40.945]         }
[13:36:40.945]     })
[13:36:40.945]     if (TRUE) {
[13:36:40.945]         base::sink(type = "output", split = FALSE)
[13:36:40.945]         if (TRUE) {
[13:36:40.945]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:40.945]         }
[13:36:40.945]         else {
[13:36:40.945]             ...future.result["stdout"] <- base::list(NULL)
[13:36:40.945]         }
[13:36:40.945]         base::close(...future.stdout)
[13:36:40.945]         ...future.stdout <- NULL
[13:36:40.945]     }
[13:36:40.945]     ...future.result$conditions <- ...future.conditions
[13:36:40.945]     ...future.result$finished <- base::Sys.time()
[13:36:40.945]     ...future.result
[13:36:40.945] }
[13:36:40.947] assign_globals() ...
[13:36:40.947] List of 3
[13:36:40.947]  $ outer_function:function (x)  
[13:36:40.947]  $ map           :function (.x, .f, ...)  
[13:36:40.947]  $ inner_function:function (x)  
[13:36:40.947]  - attr(*, "where")=List of 3
[13:36:40.947]   ..$ outer_function:<environment: R_EmptyEnv> 
[13:36:40.947]   ..$ map           :<environment: R_EmptyEnv> 
[13:36:40.947]   ..$ inner_function:<environment: R_EmptyEnv> 
[13:36:40.947]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:40.947]  - attr(*, "resolved")= logi FALSE
[13:36:40.947]  - attr(*, "total_size")= num 7704
[13:36:40.947]  - attr(*, "already-done")= logi TRUE
[13:36:40.950] - reassign environment for ‘outer_function’
[13:36:40.950] - copied ‘outer_function’ to environment
[13:36:40.950] - reassign environment for ‘map’
[13:36:40.950] - copied ‘map’ to environment
[13:36:40.950] - reassign environment for ‘inner_function’
[13:36:40.950] - copied ‘inner_function’ to environment
[13:36:40.950] assign_globals() ... done
[13:36:40.951] plan(): Setting new future strategy stack:
[13:36:40.951] List of future strategies:
[13:36:40.951] 1. sequential:
[13:36:40.951]    - args: function (..., envir = parent.frame())
[13:36:40.951]    - tweaked: FALSE
[13:36:40.951]    - call: NULL
[13:36:40.951] plan(): nbrOfWorkers() = 1
[13:36:40.952] plan(): Setting new future strategy stack:
[13:36:40.952] List of future strategies:
[13:36:40.952] 1. sequential:
[13:36:40.952]    - args: function (..., envir = parent.frame())
[13:36:40.952]    - tweaked: FALSE
[13:36:40.952]    - call: plan(strategy)
[13:36:40.952] plan(): nbrOfWorkers() = 1
[13:36:40.952] SequentialFuture started (and completed)
[13:36:40.953] - Launch lazy future ... done
[13:36:40.953] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[13:36:40.963] plan(): Setting new future strategy stack:
[13:36:40.963] List of future strategies:
[13:36:40.963] 1. multicore:
[13:36:40.963]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:40.963]    - tweaked: FALSE
[13:36:40.963]    - call: plan(strategy)
[13:36:40.967] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[13:36:40.967] getGlobalsAndPackages() ...
[13:36:40.967] Searching for globals...
[13:36:40.968] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:36:40.969] Searching for globals ... DONE
[13:36:40.969] Resolving globals: FALSE
[13:36:40.969] The total size of the 2 globals is 896 bytes (896 bytes)
[13:36:40.969] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:36:40.970] - globals: [2] ‘weight’, ‘group’
[13:36:40.970] - packages: [1] ‘stats’
[13:36:40.970] getGlobalsAndPackages() ... DONE
[13:36:40.970] run() for ‘Future’ ...
[13:36:40.970] - state: ‘created’
[13:36:40.970] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:40.974] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:40.974] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:40.974]   - Field: ‘label’
[13:36:40.974]   - Field: ‘local’
[13:36:40.974]   - Field: ‘owner’
[13:36:40.974]   - Field: ‘envir’
[13:36:40.974]   - Field: ‘workers’
[13:36:40.974]   - Field: ‘packages’
[13:36:40.974]   - Field: ‘gc’
[13:36:40.975]   - Field: ‘job’
[13:36:40.975]   - Field: ‘conditions’
[13:36:40.975]   - Field: ‘expr’
[13:36:40.975]   - Field: ‘uuid’
[13:36:40.975]   - Field: ‘seed’
[13:36:40.975]   - Field: ‘version’
[13:36:40.975]   - Field: ‘result’
[13:36:40.975]   - Field: ‘asynchronous’
[13:36:40.975]   - Field: ‘calls’
[13:36:40.975]   - Field: ‘globals’
[13:36:40.975]   - Field: ‘stdout’
[13:36:40.976]   - Field: ‘earlySignal’
[13:36:40.976]   - Field: ‘lazy’
[13:36:40.976]   - Field: ‘state’
[13:36:40.976] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:40.976] - Launch lazy future ...
[13:36:40.977] Packages needed by the future expression (n = 1): ‘stats’
[13:36:40.977] Packages needed by future strategies (n = 0): <none>
[13:36:40.977] {
[13:36:40.977]     {
[13:36:40.977]         {
[13:36:40.977]             ...future.startTime <- base::Sys.time()
[13:36:40.977]             {
[13:36:40.977]                 {
[13:36:40.977]                   {
[13:36:40.977]                     {
[13:36:40.977]                       {
[13:36:40.977]                         base::local({
[13:36:40.977]                           has_future <- base::requireNamespace("future", 
[13:36:40.977]                             quietly = TRUE)
[13:36:40.977]                           if (has_future) {
[13:36:40.977]                             ns <- base::getNamespace("future")
[13:36:40.977]                             version <- ns[[".package"]][["version"]]
[13:36:40.977]                             if (is.null(version)) 
[13:36:40.977]                               version <- utils::packageVersion("future")
[13:36:40.977]                           }
[13:36:40.977]                           else {
[13:36:40.977]                             version <- NULL
[13:36:40.977]                           }
[13:36:40.977]                           if (!has_future || version < "1.8.0") {
[13:36:40.977]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:40.977]                               "", base::R.version$version.string), 
[13:36:40.977]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:40.977]                                 base::R.version$platform, 8 * 
[13:36:40.977]                                   base::.Machine$sizeof.pointer), 
[13:36:40.977]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:40.977]                                 "release", "version")], collapse = " "), 
[13:36:40.977]                               hostname = base::Sys.info()[["nodename"]])
[13:36:40.977]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:40.977]                               info)
[13:36:40.977]                             info <- base::paste(info, collapse = "; ")
[13:36:40.977]                             if (!has_future) {
[13:36:40.977]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:40.977]                                 info)
[13:36:40.977]                             }
[13:36:40.977]                             else {
[13:36:40.977]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:40.977]                                 info, version)
[13:36:40.977]                             }
[13:36:40.977]                             base::stop(msg)
[13:36:40.977]                           }
[13:36:40.977]                         })
[13:36:40.977]                       }
[13:36:40.977]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:40.977]                       base::options(mc.cores = 1L)
[13:36:40.977]                     }
[13:36:40.977]                     base::local({
[13:36:40.977]                       for (pkg in "stats") {
[13:36:40.977]                         base::loadNamespace(pkg)
[13:36:40.977]                         base::library(pkg, character.only = TRUE)
[13:36:40.977]                       }
[13:36:40.977]                     })
[13:36:40.977]                   }
[13:36:40.977]                   ...future.strategy.old <- future::plan("list")
[13:36:40.977]                   options(future.plan = NULL)
[13:36:40.977]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.977]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:40.977]                 }
[13:36:40.977]                 ...future.workdir <- getwd()
[13:36:40.977]             }
[13:36:40.977]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:40.977]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:40.977]         }
[13:36:40.977]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:40.977]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:40.977]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:40.977]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:40.977]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:40.977]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:40.977]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:40.977]             base::names(...future.oldOptions))
[13:36:40.977]     }
[13:36:40.977]     if (FALSE) {
[13:36:40.977]     }
[13:36:40.977]     else {
[13:36:40.977]         if (TRUE) {
[13:36:40.977]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:40.977]                 open = "w")
[13:36:40.977]         }
[13:36:40.977]         else {
[13:36:40.977]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:40.977]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:40.977]         }
[13:36:40.977]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:40.977]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:40.977]             base::sink(type = "output", split = FALSE)
[13:36:40.977]             base::close(...future.stdout)
[13:36:40.977]         }, add = TRUE)
[13:36:40.977]     }
[13:36:40.977]     ...future.frame <- base::sys.nframe()
[13:36:40.977]     ...future.conditions <- base::list()
[13:36:40.977]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:40.977]     if (FALSE) {
[13:36:40.977]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:40.977]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:40.977]     }
[13:36:40.977]     ...future.result <- base::tryCatch({
[13:36:40.977]         base::withCallingHandlers({
[13:36:40.977]             ...future.value <- base::withVisible(base::local({
[13:36:40.977]                 withCallingHandlers({
[13:36:40.977]                   {
[13:36:40.977]                     lm(weight ~ group - 1)
[13:36:40.977]                   }
[13:36:40.977]                 }, immediateCondition = function(cond) {
[13:36:40.977]                   save_rds <- function (object, pathname, ...) 
[13:36:40.977]                   {
[13:36:40.977]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:40.977]                     if (file_test("-f", pathname_tmp)) {
[13:36:40.977]                       fi_tmp <- file.info(pathname_tmp)
[13:36:40.977]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:40.977]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:40.977]                         fi_tmp[["mtime"]])
[13:36:40.977]                     }
[13:36:40.977]                     tryCatch({
[13:36:40.977]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:40.977]                     }, error = function(ex) {
[13:36:40.977]                       msg <- conditionMessage(ex)
[13:36:40.977]                       fi_tmp <- file.info(pathname_tmp)
[13:36:40.977]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:40.977]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:40.977]                         fi_tmp[["mtime"]], msg)
[13:36:40.977]                       ex$message <- msg
[13:36:40.977]                       stop(ex)
[13:36:40.977]                     })
[13:36:40.977]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:40.977]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:40.977]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:40.977]                       fi_tmp <- file.info(pathname_tmp)
[13:36:40.977]                       fi <- file.info(pathname)
[13:36:40.977]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:40.977]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:40.977]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:40.977]                         fi[["size"]], fi[["mtime"]])
[13:36:40.977]                       stop(msg)
[13:36:40.977]                     }
[13:36:40.977]                     invisible(pathname)
[13:36:40.977]                   }
[13:36:40.977]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:40.977]                     rootPath = tempdir()) 
[13:36:40.977]                   {
[13:36:40.977]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:40.977]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:40.977]                       tmpdir = path, fileext = ".rds")
[13:36:40.977]                     save_rds(obj, file)
[13:36:40.977]                   }
[13:36:40.977]                   saveImmediateCondition(cond, path = "/tmp/RtmphVqFyZ/.future/immediateConditions")
[13:36:40.977]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.977]                   {
[13:36:40.977]                     inherits <- base::inherits
[13:36:40.977]                     invokeRestart <- base::invokeRestart
[13:36:40.977]                     is.null <- base::is.null
[13:36:40.977]                     muffled <- FALSE
[13:36:40.977]                     if (inherits(cond, "message")) {
[13:36:40.977]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:40.977]                       if (muffled) 
[13:36:40.977]                         invokeRestart("muffleMessage")
[13:36:40.977]                     }
[13:36:40.977]                     else if (inherits(cond, "warning")) {
[13:36:40.977]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:40.977]                       if (muffled) 
[13:36:40.977]                         invokeRestart("muffleWarning")
[13:36:40.977]                     }
[13:36:40.977]                     else if (inherits(cond, "condition")) {
[13:36:40.977]                       if (!is.null(pattern)) {
[13:36:40.977]                         computeRestarts <- base::computeRestarts
[13:36:40.977]                         grepl <- base::grepl
[13:36:40.977]                         restarts <- computeRestarts(cond)
[13:36:40.977]                         for (restart in restarts) {
[13:36:40.977]                           name <- restart$name
[13:36:40.977]                           if (is.null(name)) 
[13:36:40.977]                             next
[13:36:40.977]                           if (!grepl(pattern, name)) 
[13:36:40.977]                             next
[13:36:40.977]                           invokeRestart(restart)
[13:36:40.977]                           muffled <- TRUE
[13:36:40.977]                           break
[13:36:40.977]                         }
[13:36:40.977]                       }
[13:36:40.977]                     }
[13:36:40.977]                     invisible(muffled)
[13:36:40.977]                   }
[13:36:40.977]                   muffleCondition(cond)
[13:36:40.977]                 })
[13:36:40.977]             }))
[13:36:40.977]             future::FutureResult(value = ...future.value$value, 
[13:36:40.977]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.977]                   ...future.rng), globalenv = if (FALSE) 
[13:36:40.977]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:40.977]                     ...future.globalenv.names))
[13:36:40.977]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:40.977]         }, condition = base::local({
[13:36:40.977]             c <- base::c
[13:36:40.977]             inherits <- base::inherits
[13:36:40.977]             invokeRestart <- base::invokeRestart
[13:36:40.977]             length <- base::length
[13:36:40.977]             list <- base::list
[13:36:40.977]             seq.int <- base::seq.int
[13:36:40.977]             signalCondition <- base::signalCondition
[13:36:40.977]             sys.calls <- base::sys.calls
[13:36:40.977]             `[[` <- base::`[[`
[13:36:40.977]             `+` <- base::`+`
[13:36:40.977]             `<<-` <- base::`<<-`
[13:36:40.977]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:40.977]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:40.977]                   3L)]
[13:36:40.977]             }
[13:36:40.977]             function(cond) {
[13:36:40.977]                 is_error <- inherits(cond, "error")
[13:36:40.977]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:40.977]                   NULL)
[13:36:40.977]                 if (is_error) {
[13:36:40.977]                   sessionInformation <- function() {
[13:36:40.977]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:40.977]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:40.977]                       search = base::search(), system = base::Sys.info())
[13:36:40.977]                   }
[13:36:40.977]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.977]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:40.977]                     cond$call), session = sessionInformation(), 
[13:36:40.977]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:40.977]                   signalCondition(cond)
[13:36:40.977]                 }
[13:36:40.977]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:40.977]                 "immediateCondition"))) {
[13:36:40.977]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:40.977]                   ...future.conditions[[length(...future.conditions) + 
[13:36:40.977]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:40.977]                   if (TRUE && !signal) {
[13:36:40.977]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.977]                     {
[13:36:40.977]                       inherits <- base::inherits
[13:36:40.977]                       invokeRestart <- base::invokeRestart
[13:36:40.977]                       is.null <- base::is.null
[13:36:40.977]                       muffled <- FALSE
[13:36:40.977]                       if (inherits(cond, "message")) {
[13:36:40.977]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.977]                         if (muffled) 
[13:36:40.977]                           invokeRestart("muffleMessage")
[13:36:40.977]                       }
[13:36:40.977]                       else if (inherits(cond, "warning")) {
[13:36:40.977]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.977]                         if (muffled) 
[13:36:40.977]                           invokeRestart("muffleWarning")
[13:36:40.977]                       }
[13:36:40.977]                       else if (inherits(cond, "condition")) {
[13:36:40.977]                         if (!is.null(pattern)) {
[13:36:40.977]                           computeRestarts <- base::computeRestarts
[13:36:40.977]                           grepl <- base::grepl
[13:36:40.977]                           restarts <- computeRestarts(cond)
[13:36:40.977]                           for (restart in restarts) {
[13:36:40.977]                             name <- restart$name
[13:36:40.977]                             if (is.null(name)) 
[13:36:40.977]                               next
[13:36:40.977]                             if (!grepl(pattern, name)) 
[13:36:40.977]                               next
[13:36:40.977]                             invokeRestart(restart)
[13:36:40.977]                             muffled <- TRUE
[13:36:40.977]                             break
[13:36:40.977]                           }
[13:36:40.977]                         }
[13:36:40.977]                       }
[13:36:40.977]                       invisible(muffled)
[13:36:40.977]                     }
[13:36:40.977]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.977]                   }
[13:36:40.977]                 }
[13:36:40.977]                 else {
[13:36:40.977]                   if (TRUE) {
[13:36:40.977]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:40.977]                     {
[13:36:40.977]                       inherits <- base::inherits
[13:36:40.977]                       invokeRestart <- base::invokeRestart
[13:36:40.977]                       is.null <- base::is.null
[13:36:40.977]                       muffled <- FALSE
[13:36:40.977]                       if (inherits(cond, "message")) {
[13:36:40.977]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:40.977]                         if (muffled) 
[13:36:40.977]                           invokeRestart("muffleMessage")
[13:36:40.977]                       }
[13:36:40.977]                       else if (inherits(cond, "warning")) {
[13:36:40.977]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:40.977]                         if (muffled) 
[13:36:40.977]                           invokeRestart("muffleWarning")
[13:36:40.977]                       }
[13:36:40.977]                       else if (inherits(cond, "condition")) {
[13:36:40.977]                         if (!is.null(pattern)) {
[13:36:40.977]                           computeRestarts <- base::computeRestarts
[13:36:40.977]                           grepl <- base::grepl
[13:36:40.977]                           restarts <- computeRestarts(cond)
[13:36:40.977]                           for (restart in restarts) {
[13:36:40.977]                             name <- restart$name
[13:36:40.977]                             if (is.null(name)) 
[13:36:40.977]                               next
[13:36:40.977]                             if (!grepl(pattern, name)) 
[13:36:40.977]                               next
[13:36:40.977]                             invokeRestart(restart)
[13:36:40.977]                             muffled <- TRUE
[13:36:40.977]                             break
[13:36:40.977]                           }
[13:36:40.977]                         }
[13:36:40.977]                       }
[13:36:40.977]                       invisible(muffled)
[13:36:40.977]                     }
[13:36:40.977]                     muffleCondition(cond, pattern = "^muffle")
[13:36:40.977]                   }
[13:36:40.977]                 }
[13:36:40.977]             }
[13:36:40.977]         }))
[13:36:40.977]     }, error = function(ex) {
[13:36:40.977]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:40.977]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:40.977]                 ...future.rng), started = ...future.startTime, 
[13:36:40.977]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:40.977]             version = "1.8"), class = "FutureResult")
[13:36:40.977]     }, finally = {
[13:36:40.977]         if (!identical(...future.workdir, getwd())) 
[13:36:40.977]             setwd(...future.workdir)
[13:36:40.977]         {
[13:36:40.977]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:40.977]                 ...future.oldOptions$nwarnings <- NULL
[13:36:40.977]             }
[13:36:40.977]             base::options(...future.oldOptions)
[13:36:40.977]             if (.Platform$OS.type == "windows") {
[13:36:40.977]                 old_names <- names(...future.oldEnvVars)
[13:36:40.977]                 envs <- base::Sys.getenv()
[13:36:40.977]                 names <- names(envs)
[13:36:40.977]                 common <- intersect(names, old_names)
[13:36:40.977]                 added <- setdiff(names, old_names)
[13:36:40.977]                 removed <- setdiff(old_names, names)
[13:36:40.977]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:40.977]                   envs[common]]
[13:36:40.977]                 NAMES <- toupper(changed)
[13:36:40.977]                 args <- list()
[13:36:40.977]                 for (kk in seq_along(NAMES)) {
[13:36:40.977]                   name <- changed[[kk]]
[13:36:40.977]                   NAME <- NAMES[[kk]]
[13:36:40.977]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.977]                     next
[13:36:40.977]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.977]                 }
[13:36:40.977]                 NAMES <- toupper(added)
[13:36:40.977]                 for (kk in seq_along(NAMES)) {
[13:36:40.977]                   name <- added[[kk]]
[13:36:40.977]                   NAME <- NAMES[[kk]]
[13:36:40.977]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.977]                     next
[13:36:40.977]                   args[[name]] <- ""
[13:36:40.977]                 }
[13:36:40.977]                 NAMES <- toupper(removed)
[13:36:40.977]                 for (kk in seq_along(NAMES)) {
[13:36:40.977]                   name <- removed[[kk]]
[13:36:40.977]                   NAME <- NAMES[[kk]]
[13:36:40.977]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:40.977]                     next
[13:36:40.977]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:40.977]                 }
[13:36:40.977]                 if (length(args) > 0) 
[13:36:40.977]                   base::do.call(base::Sys.setenv, args = args)
[13:36:40.977]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:40.977]             }
[13:36:40.977]             else {
[13:36:40.977]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:40.977]             }
[13:36:40.977]             {
[13:36:40.977]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:40.977]                   0L) {
[13:36:40.977]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:40.977]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:40.977]                   base::options(opts)
[13:36:40.977]                 }
[13:36:40.977]                 {
[13:36:40.977]                   {
[13:36:40.977]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:40.977]                     NULL
[13:36:40.977]                   }
[13:36:40.977]                   options(future.plan = NULL)
[13:36:40.977]                   if (is.na(NA_character_)) 
[13:36:40.977]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:40.977]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:40.977]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:40.977]                     .init = FALSE)
[13:36:40.977]                 }
[13:36:40.977]             }
[13:36:40.977]         }
[13:36:40.977]     })
[13:36:40.977]     if (TRUE) {
[13:36:40.977]         base::sink(type = "output", split = FALSE)
[13:36:40.977]         if (TRUE) {
[13:36:40.977]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:40.977]         }
[13:36:40.977]         else {
[13:36:40.977]             ...future.result["stdout"] <- base::list(NULL)
[13:36:40.977]         }
[13:36:40.977]         base::close(...future.stdout)
[13:36:40.977]         ...future.stdout <- NULL
[13:36:40.977]     }
[13:36:40.977]     ...future.result$conditions <- ...future.conditions
[13:36:40.977]     ...future.result$finished <- base::Sys.time()
[13:36:40.977]     ...future.result
[13:36:40.977] }
[13:36:40.980] assign_globals() ...
[13:36:40.980] List of 2
[13:36:40.980]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:36:40.980]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:36:40.980]  - attr(*, "where")=List of 2
[13:36:40.980]   ..$ weight:<environment: R_EmptyEnv> 
[13:36:40.980]   ..$ group :<environment: R_EmptyEnv> 
[13:36:40.980]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:40.980]  - attr(*, "resolved")= logi FALSE
[13:36:40.980]  - attr(*, "total_size")= num 896
[13:36:40.980]  - attr(*, "already-done")= logi TRUE
[13:36:40.983] - copied ‘weight’ to environment
[13:36:40.983] - copied ‘group’ to environment
[13:36:40.983] assign_globals() ... done
[13:36:40.983] requestCore(): workers = 2
[13:36:40.986] MulticoreFuture started
[13:36:40.986] - Launch lazy future ... done
[13:36:40.986] run() for ‘MulticoreFuture’ ... done
[13:36:40.987] plan(): Setting new future strategy stack:
[13:36:40.988] result() for MulticoreFuture ...
[13:36:40.987] List of future strategies:
[13:36:40.987] 1. sequential:
[13:36:40.987]    - args: function (..., envir = parent.frame())
[13:36:40.987]    - tweaked: FALSE
[13:36:40.987]    - call: NULL
[13:36:40.988] plan(): nbrOfWorkers() = 1
[13:36:40.991] plan(): Setting new future strategy stack:
[13:36:40.991] List of future strategies:
[13:36:40.991] 1. multicore:
[13:36:40.991]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:40.991]    - tweaked: FALSE
[13:36:40.991]    - call: plan(strategy)
[13:36:41.000] plan(): nbrOfWorkers() = 2
[13:36:41.009] result() for MulticoreFuture ...
[13:36:41.009] result() for MulticoreFuture ... done
[13:36:41.009] result() for MulticoreFuture ... done
[13:36:41.010] result() for MulticoreFuture ...
[13:36:41.010] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:36:41.012] getGlobalsAndPackages() ...
[13:36:41.012] Searching for globals...
[13:36:41.014] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:36:41.014] Searching for globals ... DONE
[13:36:41.014] Resolving globals: FALSE
[13:36:41.015] The total size of the 2 globals is 896 bytes (896 bytes)
[13:36:41.015] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:36:41.016] - globals: [2] ‘weight’, ‘group’
[13:36:41.016] - packages: [1] ‘stats’
[13:36:41.016] getGlobalsAndPackages() ... DONE
[13:36:41.016] run() for ‘Future’ ...
[13:36:41.016] - state: ‘created’
[13:36:41.017] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:41.020] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:41.021] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:41.021]   - Field: ‘label’
[13:36:41.021]   - Field: ‘local’
[13:36:41.021]   - Field: ‘owner’
[13:36:41.021]   - Field: ‘envir’
[13:36:41.021]   - Field: ‘workers’
[13:36:41.021]   - Field: ‘packages’
[13:36:41.021]   - Field: ‘gc’
[13:36:41.021]   - Field: ‘job’
[13:36:41.022]   - Field: ‘conditions’
[13:36:41.022]   - Field: ‘expr’
[13:36:41.022]   - Field: ‘uuid’
[13:36:41.022]   - Field: ‘seed’
[13:36:41.022]   - Field: ‘version’
[13:36:41.022]   - Field: ‘result’
[13:36:41.022]   - Field: ‘asynchronous’
[13:36:41.022]   - Field: ‘calls’
[13:36:41.022]   - Field: ‘globals’
[13:36:41.023]   - Field: ‘stdout’
[13:36:41.023]   - Field: ‘earlySignal’
[13:36:41.023]   - Field: ‘lazy’
[13:36:41.023]   - Field: ‘state’
[13:36:41.023] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:41.023] - Launch lazy future ...
[13:36:41.023] Packages needed by the future expression (n = 1): ‘stats’
[13:36:41.024] Packages needed by future strategies (n = 0): <none>
[13:36:41.024] {
[13:36:41.024]     {
[13:36:41.024]         {
[13:36:41.024]             ...future.startTime <- base::Sys.time()
[13:36:41.024]             {
[13:36:41.024]                 {
[13:36:41.024]                   {
[13:36:41.024]                     {
[13:36:41.024]                       {
[13:36:41.024]                         base::local({
[13:36:41.024]                           has_future <- base::requireNamespace("future", 
[13:36:41.024]                             quietly = TRUE)
[13:36:41.024]                           if (has_future) {
[13:36:41.024]                             ns <- base::getNamespace("future")
[13:36:41.024]                             version <- ns[[".package"]][["version"]]
[13:36:41.024]                             if (is.null(version)) 
[13:36:41.024]                               version <- utils::packageVersion("future")
[13:36:41.024]                           }
[13:36:41.024]                           else {
[13:36:41.024]                             version <- NULL
[13:36:41.024]                           }
[13:36:41.024]                           if (!has_future || version < "1.8.0") {
[13:36:41.024]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:41.024]                               "", base::R.version$version.string), 
[13:36:41.024]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:41.024]                                 base::R.version$platform, 8 * 
[13:36:41.024]                                   base::.Machine$sizeof.pointer), 
[13:36:41.024]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:41.024]                                 "release", "version")], collapse = " "), 
[13:36:41.024]                               hostname = base::Sys.info()[["nodename"]])
[13:36:41.024]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:41.024]                               info)
[13:36:41.024]                             info <- base::paste(info, collapse = "; ")
[13:36:41.024]                             if (!has_future) {
[13:36:41.024]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:41.024]                                 info)
[13:36:41.024]                             }
[13:36:41.024]                             else {
[13:36:41.024]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:41.024]                                 info, version)
[13:36:41.024]                             }
[13:36:41.024]                             base::stop(msg)
[13:36:41.024]                           }
[13:36:41.024]                         })
[13:36:41.024]                       }
[13:36:41.024]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:41.024]                       base::options(mc.cores = 1L)
[13:36:41.024]                     }
[13:36:41.024]                     base::local({
[13:36:41.024]                       for (pkg in "stats") {
[13:36:41.024]                         base::loadNamespace(pkg)
[13:36:41.024]                         base::library(pkg, character.only = TRUE)
[13:36:41.024]                       }
[13:36:41.024]                     })
[13:36:41.024]                   }
[13:36:41.024]                   ...future.strategy.old <- future::plan("list")
[13:36:41.024]                   options(future.plan = NULL)
[13:36:41.024]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.024]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:41.024]                 }
[13:36:41.024]                 ...future.workdir <- getwd()
[13:36:41.024]             }
[13:36:41.024]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:41.024]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:41.024]         }
[13:36:41.024]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:41.024]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:41.024]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:41.024]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:41.024]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:41.024]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:41.024]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:41.024]             base::names(...future.oldOptions))
[13:36:41.024]     }
[13:36:41.024]     if (FALSE) {
[13:36:41.024]     }
[13:36:41.024]     else {
[13:36:41.024]         if (TRUE) {
[13:36:41.024]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:41.024]                 open = "w")
[13:36:41.024]         }
[13:36:41.024]         else {
[13:36:41.024]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:41.024]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:41.024]         }
[13:36:41.024]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:41.024]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:41.024]             base::sink(type = "output", split = FALSE)
[13:36:41.024]             base::close(...future.stdout)
[13:36:41.024]         }, add = TRUE)
[13:36:41.024]     }
[13:36:41.024]     ...future.frame <- base::sys.nframe()
[13:36:41.024]     ...future.conditions <- base::list()
[13:36:41.024]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:41.024]     if (FALSE) {
[13:36:41.024]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:41.024]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:41.024]     }
[13:36:41.024]     ...future.result <- base::tryCatch({
[13:36:41.024]         base::withCallingHandlers({
[13:36:41.024]             ...future.value <- base::withVisible(base::local({
[13:36:41.024]                 withCallingHandlers({
[13:36:41.024]                   {
[13:36:41.024]                     lm(weight ~ group - 1)
[13:36:41.024]                   }
[13:36:41.024]                 }, immediateCondition = function(cond) {
[13:36:41.024]                   save_rds <- function (object, pathname, ...) 
[13:36:41.024]                   {
[13:36:41.024]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:41.024]                     if (file_test("-f", pathname_tmp)) {
[13:36:41.024]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.024]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:41.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.024]                         fi_tmp[["mtime"]])
[13:36:41.024]                     }
[13:36:41.024]                     tryCatch({
[13:36:41.024]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:41.024]                     }, error = function(ex) {
[13:36:41.024]                       msg <- conditionMessage(ex)
[13:36:41.024]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.024]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:41.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.024]                         fi_tmp[["mtime"]], msg)
[13:36:41.024]                       ex$message <- msg
[13:36:41.024]                       stop(ex)
[13:36:41.024]                     })
[13:36:41.024]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:41.024]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:41.024]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:41.024]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.024]                       fi <- file.info(pathname)
[13:36:41.024]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:41.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.024]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:41.024]                         fi[["size"]], fi[["mtime"]])
[13:36:41.024]                       stop(msg)
[13:36:41.024]                     }
[13:36:41.024]                     invisible(pathname)
[13:36:41.024]                   }
[13:36:41.024]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:41.024]                     rootPath = tempdir()) 
[13:36:41.024]                   {
[13:36:41.024]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:41.024]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:41.024]                       tmpdir = path, fileext = ".rds")
[13:36:41.024]                     save_rds(obj, file)
[13:36:41.024]                   }
[13:36:41.024]                   saveImmediateCondition(cond, path = "/tmp/RtmphVqFyZ/.future/immediateConditions")
[13:36:41.024]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.024]                   {
[13:36:41.024]                     inherits <- base::inherits
[13:36:41.024]                     invokeRestart <- base::invokeRestart
[13:36:41.024]                     is.null <- base::is.null
[13:36:41.024]                     muffled <- FALSE
[13:36:41.024]                     if (inherits(cond, "message")) {
[13:36:41.024]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:41.024]                       if (muffled) 
[13:36:41.024]                         invokeRestart("muffleMessage")
[13:36:41.024]                     }
[13:36:41.024]                     else if (inherits(cond, "warning")) {
[13:36:41.024]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:41.024]                       if (muffled) 
[13:36:41.024]                         invokeRestart("muffleWarning")
[13:36:41.024]                     }
[13:36:41.024]                     else if (inherits(cond, "condition")) {
[13:36:41.024]                       if (!is.null(pattern)) {
[13:36:41.024]                         computeRestarts <- base::computeRestarts
[13:36:41.024]                         grepl <- base::grepl
[13:36:41.024]                         restarts <- computeRestarts(cond)
[13:36:41.024]                         for (restart in restarts) {
[13:36:41.024]                           name <- restart$name
[13:36:41.024]                           if (is.null(name)) 
[13:36:41.024]                             next
[13:36:41.024]                           if (!grepl(pattern, name)) 
[13:36:41.024]                             next
[13:36:41.024]                           invokeRestart(restart)
[13:36:41.024]                           muffled <- TRUE
[13:36:41.024]                           break
[13:36:41.024]                         }
[13:36:41.024]                       }
[13:36:41.024]                     }
[13:36:41.024]                     invisible(muffled)
[13:36:41.024]                   }
[13:36:41.024]                   muffleCondition(cond)
[13:36:41.024]                 })
[13:36:41.024]             }))
[13:36:41.024]             future::FutureResult(value = ...future.value$value, 
[13:36:41.024]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.024]                   ...future.rng), globalenv = if (FALSE) 
[13:36:41.024]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:41.024]                     ...future.globalenv.names))
[13:36:41.024]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:41.024]         }, condition = base::local({
[13:36:41.024]             c <- base::c
[13:36:41.024]             inherits <- base::inherits
[13:36:41.024]             invokeRestart <- base::invokeRestart
[13:36:41.024]             length <- base::length
[13:36:41.024]             list <- base::list
[13:36:41.024]             seq.int <- base::seq.int
[13:36:41.024]             signalCondition <- base::signalCondition
[13:36:41.024]             sys.calls <- base::sys.calls
[13:36:41.024]             `[[` <- base::`[[`
[13:36:41.024]             `+` <- base::`+`
[13:36:41.024]             `<<-` <- base::`<<-`
[13:36:41.024]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:41.024]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:41.024]                   3L)]
[13:36:41.024]             }
[13:36:41.024]             function(cond) {
[13:36:41.024]                 is_error <- inherits(cond, "error")
[13:36:41.024]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:41.024]                   NULL)
[13:36:41.024]                 if (is_error) {
[13:36:41.024]                   sessionInformation <- function() {
[13:36:41.024]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:41.024]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:41.024]                       search = base::search(), system = base::Sys.info())
[13:36:41.024]                   }
[13:36:41.024]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.024]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:41.024]                     cond$call), session = sessionInformation(), 
[13:36:41.024]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:41.024]                   signalCondition(cond)
[13:36:41.024]                 }
[13:36:41.024]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:41.024]                 "immediateCondition"))) {
[13:36:41.024]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:41.024]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.024]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:41.024]                   if (TRUE && !signal) {
[13:36:41.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.024]                     {
[13:36:41.024]                       inherits <- base::inherits
[13:36:41.024]                       invokeRestart <- base::invokeRestart
[13:36:41.024]                       is.null <- base::is.null
[13:36:41.024]                       muffled <- FALSE
[13:36:41.024]                       if (inherits(cond, "message")) {
[13:36:41.024]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.024]                         if (muffled) 
[13:36:41.024]                           invokeRestart("muffleMessage")
[13:36:41.024]                       }
[13:36:41.024]                       else if (inherits(cond, "warning")) {
[13:36:41.024]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.024]                         if (muffled) 
[13:36:41.024]                           invokeRestart("muffleWarning")
[13:36:41.024]                       }
[13:36:41.024]                       else if (inherits(cond, "condition")) {
[13:36:41.024]                         if (!is.null(pattern)) {
[13:36:41.024]                           computeRestarts <- base::computeRestarts
[13:36:41.024]                           grepl <- base::grepl
[13:36:41.024]                           restarts <- computeRestarts(cond)
[13:36:41.024]                           for (restart in restarts) {
[13:36:41.024]                             name <- restart$name
[13:36:41.024]                             if (is.null(name)) 
[13:36:41.024]                               next
[13:36:41.024]                             if (!grepl(pattern, name)) 
[13:36:41.024]                               next
[13:36:41.024]                             invokeRestart(restart)
[13:36:41.024]                             muffled <- TRUE
[13:36:41.024]                             break
[13:36:41.024]                           }
[13:36:41.024]                         }
[13:36:41.024]                       }
[13:36:41.024]                       invisible(muffled)
[13:36:41.024]                     }
[13:36:41.024]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.024]                   }
[13:36:41.024]                 }
[13:36:41.024]                 else {
[13:36:41.024]                   if (TRUE) {
[13:36:41.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.024]                     {
[13:36:41.024]                       inherits <- base::inherits
[13:36:41.024]                       invokeRestart <- base::invokeRestart
[13:36:41.024]                       is.null <- base::is.null
[13:36:41.024]                       muffled <- FALSE
[13:36:41.024]                       if (inherits(cond, "message")) {
[13:36:41.024]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.024]                         if (muffled) 
[13:36:41.024]                           invokeRestart("muffleMessage")
[13:36:41.024]                       }
[13:36:41.024]                       else if (inherits(cond, "warning")) {
[13:36:41.024]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.024]                         if (muffled) 
[13:36:41.024]                           invokeRestart("muffleWarning")
[13:36:41.024]                       }
[13:36:41.024]                       else if (inherits(cond, "condition")) {
[13:36:41.024]                         if (!is.null(pattern)) {
[13:36:41.024]                           computeRestarts <- base::computeRestarts
[13:36:41.024]                           grepl <- base::grepl
[13:36:41.024]                           restarts <- computeRestarts(cond)
[13:36:41.024]                           for (restart in restarts) {
[13:36:41.024]                             name <- restart$name
[13:36:41.024]                             if (is.null(name)) 
[13:36:41.024]                               next
[13:36:41.024]                             if (!grepl(pattern, name)) 
[13:36:41.024]                               next
[13:36:41.024]                             invokeRestart(restart)
[13:36:41.024]                             muffled <- TRUE
[13:36:41.024]                             break
[13:36:41.024]                           }
[13:36:41.024]                         }
[13:36:41.024]                       }
[13:36:41.024]                       invisible(muffled)
[13:36:41.024]                     }
[13:36:41.024]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.024]                   }
[13:36:41.024]                 }
[13:36:41.024]             }
[13:36:41.024]         }))
[13:36:41.024]     }, error = function(ex) {
[13:36:41.024]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:41.024]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.024]                 ...future.rng), started = ...future.startTime, 
[13:36:41.024]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:41.024]             version = "1.8"), class = "FutureResult")
[13:36:41.024]     }, finally = {
[13:36:41.024]         if (!identical(...future.workdir, getwd())) 
[13:36:41.024]             setwd(...future.workdir)
[13:36:41.024]         {
[13:36:41.024]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:41.024]                 ...future.oldOptions$nwarnings <- NULL
[13:36:41.024]             }
[13:36:41.024]             base::options(...future.oldOptions)
[13:36:41.024]             if (.Platform$OS.type == "windows") {
[13:36:41.024]                 old_names <- names(...future.oldEnvVars)
[13:36:41.024]                 envs <- base::Sys.getenv()
[13:36:41.024]                 names <- names(envs)
[13:36:41.024]                 common <- intersect(names, old_names)
[13:36:41.024]                 added <- setdiff(names, old_names)
[13:36:41.024]                 removed <- setdiff(old_names, names)
[13:36:41.024]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:41.024]                   envs[common]]
[13:36:41.024]                 NAMES <- toupper(changed)
[13:36:41.024]                 args <- list()
[13:36:41.024]                 for (kk in seq_along(NAMES)) {
[13:36:41.024]                   name <- changed[[kk]]
[13:36:41.024]                   NAME <- NAMES[[kk]]
[13:36:41.024]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.024]                     next
[13:36:41.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.024]                 }
[13:36:41.024]                 NAMES <- toupper(added)
[13:36:41.024]                 for (kk in seq_along(NAMES)) {
[13:36:41.024]                   name <- added[[kk]]
[13:36:41.024]                   NAME <- NAMES[[kk]]
[13:36:41.024]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.024]                     next
[13:36:41.024]                   args[[name]] <- ""
[13:36:41.024]                 }
[13:36:41.024]                 NAMES <- toupper(removed)
[13:36:41.024]                 for (kk in seq_along(NAMES)) {
[13:36:41.024]                   name <- removed[[kk]]
[13:36:41.024]                   NAME <- NAMES[[kk]]
[13:36:41.024]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.024]                     next
[13:36:41.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.024]                 }
[13:36:41.024]                 if (length(args) > 0) 
[13:36:41.024]                   base::do.call(base::Sys.setenv, args = args)
[13:36:41.024]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:41.024]             }
[13:36:41.024]             else {
[13:36:41.024]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:41.024]             }
[13:36:41.024]             {
[13:36:41.024]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:41.024]                   0L) {
[13:36:41.024]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:41.024]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:41.024]                   base::options(opts)
[13:36:41.024]                 }
[13:36:41.024]                 {
[13:36:41.024]                   {
[13:36:41.024]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:41.024]                     NULL
[13:36:41.024]                   }
[13:36:41.024]                   options(future.plan = NULL)
[13:36:41.024]                   if (is.na(NA_character_)) 
[13:36:41.024]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.024]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:41.024]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:41.024]                     .init = FALSE)
[13:36:41.024]                 }
[13:36:41.024]             }
[13:36:41.024]         }
[13:36:41.024]     })
[13:36:41.024]     if (TRUE) {
[13:36:41.024]         base::sink(type = "output", split = FALSE)
[13:36:41.024]         if (TRUE) {
[13:36:41.024]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:41.024]         }
[13:36:41.024]         else {
[13:36:41.024]             ...future.result["stdout"] <- base::list(NULL)
[13:36:41.024]         }
[13:36:41.024]         base::close(...future.stdout)
[13:36:41.024]         ...future.stdout <- NULL
[13:36:41.024]     }
[13:36:41.024]     ...future.result$conditions <- ...future.conditions
[13:36:41.024]     ...future.result$finished <- base::Sys.time()
[13:36:41.024]     ...future.result
[13:36:41.024] }
[13:36:41.026] assign_globals() ...
[13:36:41.027] List of 2
[13:36:41.027]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:36:41.027]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:36:41.027]  - attr(*, "where")=List of 2
[13:36:41.027]   ..$ weight:<environment: R_EmptyEnv> 
[13:36:41.027]   ..$ group :<environment: R_EmptyEnv> 
[13:36:41.027]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:41.027]  - attr(*, "resolved")= logi FALSE
[13:36:41.027]  - attr(*, "total_size")= num 896
[13:36:41.027]  - attr(*, "already-done")= logi TRUE
[13:36:41.030] - copied ‘weight’ to environment
[13:36:41.030] - copied ‘group’ to environment
[13:36:41.030] assign_globals() ... done
[13:36:41.031] requestCore(): workers = 2
[13:36:41.032] MulticoreFuture started
[13:36:41.033] - Launch lazy future ... done
[13:36:41.033] run() for ‘MulticoreFuture’ ... done
[13:36:41.033] result() for MulticoreFuture ...
[13:36:41.034] plan(): Setting new future strategy stack:
[13:36:41.034] List of future strategies:
[13:36:41.034] 1. sequential:
[13:36:41.034]    - args: function (..., envir = parent.frame())
[13:36:41.034]    - tweaked: FALSE
[13:36:41.034]    - call: NULL
[13:36:41.035] plan(): nbrOfWorkers() = 1
[13:36:41.038] plan(): Setting new future strategy stack:
[13:36:41.039] List of future strategies:
[13:36:41.039] 1. multicore:
[13:36:41.039]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:41.039]    - tweaked: FALSE
[13:36:41.039]    - call: plan(strategy)
[13:36:41.047] plan(): nbrOfWorkers() = 2
[13:36:41.049] result() for MulticoreFuture ...
[13:36:41.049] result() for MulticoreFuture ... done
[13:36:41.049] result() for MulticoreFuture ... done
[13:36:41.050] result() for MulticoreFuture ...
[13:36:41.050] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:36:41.055] getGlobalsAndPackages() ...
[13:36:41.055] Searching for globals...
[13:36:41.057] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:36:41.057] Searching for globals ... DONE
[13:36:41.057] Resolving globals: FALSE
[13:36:41.058] The total size of the 2 globals is 896 bytes (896 bytes)
[13:36:41.059] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:36:41.059] - globals: [2] ‘weight’, ‘group’
[13:36:41.059] - packages: [1] ‘stats’
[13:36:41.059] getGlobalsAndPackages() ... DONE
[13:36:41.059] run() for ‘Future’ ...
[13:36:41.060] - state: ‘created’
[13:36:41.060] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:41.064] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:41.064] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:41.064]   - Field: ‘label’
[13:36:41.064]   - Field: ‘local’
[13:36:41.064]   - Field: ‘owner’
[13:36:41.064]   - Field: ‘envir’
[13:36:41.065]   - Field: ‘workers’
[13:36:41.065]   - Field: ‘packages’
[13:36:41.065]   - Field: ‘gc’
[13:36:41.065]   - Field: ‘job’
[13:36:41.065]   - Field: ‘conditions’
[13:36:41.065]   - Field: ‘expr’
[13:36:41.065]   - Field: ‘uuid’
[13:36:41.065]   - Field: ‘seed’
[13:36:41.065]   - Field: ‘version’
[13:36:41.065]   - Field: ‘result’
[13:36:41.066]   - Field: ‘asynchronous’
[13:36:41.066]   - Field: ‘calls’
[13:36:41.066]   - Field: ‘globals’
[13:36:41.066]   - Field: ‘stdout’
[13:36:41.066]   - Field: ‘earlySignal’
[13:36:41.066]   - Field: ‘lazy’
[13:36:41.066]   - Field: ‘state’
[13:36:41.066] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:41.067] - Launch lazy future ...
[13:36:41.067] Packages needed by the future expression (n = 1): ‘stats’
[13:36:41.067] Packages needed by future strategies (n = 0): <none>
[13:36:41.068] {
[13:36:41.068]     {
[13:36:41.068]         {
[13:36:41.068]             ...future.startTime <- base::Sys.time()
[13:36:41.068]             {
[13:36:41.068]                 {
[13:36:41.068]                   {
[13:36:41.068]                     {
[13:36:41.068]                       {
[13:36:41.068]                         base::local({
[13:36:41.068]                           has_future <- base::requireNamespace("future", 
[13:36:41.068]                             quietly = TRUE)
[13:36:41.068]                           if (has_future) {
[13:36:41.068]                             ns <- base::getNamespace("future")
[13:36:41.068]                             version <- ns[[".package"]][["version"]]
[13:36:41.068]                             if (is.null(version)) 
[13:36:41.068]                               version <- utils::packageVersion("future")
[13:36:41.068]                           }
[13:36:41.068]                           else {
[13:36:41.068]                             version <- NULL
[13:36:41.068]                           }
[13:36:41.068]                           if (!has_future || version < "1.8.0") {
[13:36:41.068]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:41.068]                               "", base::R.version$version.string), 
[13:36:41.068]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:41.068]                                 base::R.version$platform, 8 * 
[13:36:41.068]                                   base::.Machine$sizeof.pointer), 
[13:36:41.068]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:41.068]                                 "release", "version")], collapse = " "), 
[13:36:41.068]                               hostname = base::Sys.info()[["nodename"]])
[13:36:41.068]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:41.068]                               info)
[13:36:41.068]                             info <- base::paste(info, collapse = "; ")
[13:36:41.068]                             if (!has_future) {
[13:36:41.068]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:41.068]                                 info)
[13:36:41.068]                             }
[13:36:41.068]                             else {
[13:36:41.068]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:41.068]                                 info, version)
[13:36:41.068]                             }
[13:36:41.068]                             base::stop(msg)
[13:36:41.068]                           }
[13:36:41.068]                         })
[13:36:41.068]                       }
[13:36:41.068]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:41.068]                       base::options(mc.cores = 1L)
[13:36:41.068]                     }
[13:36:41.068]                     base::local({
[13:36:41.068]                       for (pkg in "stats") {
[13:36:41.068]                         base::loadNamespace(pkg)
[13:36:41.068]                         base::library(pkg, character.only = TRUE)
[13:36:41.068]                       }
[13:36:41.068]                     })
[13:36:41.068]                   }
[13:36:41.068]                   ...future.strategy.old <- future::plan("list")
[13:36:41.068]                   options(future.plan = NULL)
[13:36:41.068]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.068]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:41.068]                 }
[13:36:41.068]                 ...future.workdir <- getwd()
[13:36:41.068]             }
[13:36:41.068]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:41.068]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:41.068]         }
[13:36:41.068]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:41.068]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:41.068]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:41.068]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:41.068]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:41.068]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:41.068]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:41.068]             base::names(...future.oldOptions))
[13:36:41.068]     }
[13:36:41.068]     if (FALSE) {
[13:36:41.068]     }
[13:36:41.068]     else {
[13:36:41.068]         if (TRUE) {
[13:36:41.068]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:41.068]                 open = "w")
[13:36:41.068]         }
[13:36:41.068]         else {
[13:36:41.068]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:41.068]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:41.068]         }
[13:36:41.068]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:41.068]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:41.068]             base::sink(type = "output", split = FALSE)
[13:36:41.068]             base::close(...future.stdout)
[13:36:41.068]         }, add = TRUE)
[13:36:41.068]     }
[13:36:41.068]     ...future.frame <- base::sys.nframe()
[13:36:41.068]     ...future.conditions <- base::list()
[13:36:41.068]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:41.068]     if (FALSE) {
[13:36:41.068]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:41.068]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:41.068]     }
[13:36:41.068]     ...future.result <- base::tryCatch({
[13:36:41.068]         base::withCallingHandlers({
[13:36:41.068]             ...future.value <- base::withVisible(base::local({
[13:36:41.068]                 withCallingHandlers({
[13:36:41.068]                   {
[13:36:41.068]                     lm(weight ~ group - 1)
[13:36:41.068]                   }
[13:36:41.068]                 }, immediateCondition = function(cond) {
[13:36:41.068]                   save_rds <- function (object, pathname, ...) 
[13:36:41.068]                   {
[13:36:41.068]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:41.068]                     if (file_test("-f", pathname_tmp)) {
[13:36:41.068]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.068]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:41.068]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.068]                         fi_tmp[["mtime"]])
[13:36:41.068]                     }
[13:36:41.068]                     tryCatch({
[13:36:41.068]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:41.068]                     }, error = function(ex) {
[13:36:41.068]                       msg <- conditionMessage(ex)
[13:36:41.068]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.068]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:41.068]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.068]                         fi_tmp[["mtime"]], msg)
[13:36:41.068]                       ex$message <- msg
[13:36:41.068]                       stop(ex)
[13:36:41.068]                     })
[13:36:41.068]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:41.068]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:41.068]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:41.068]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.068]                       fi <- file.info(pathname)
[13:36:41.068]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:41.068]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.068]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:41.068]                         fi[["size"]], fi[["mtime"]])
[13:36:41.068]                       stop(msg)
[13:36:41.068]                     }
[13:36:41.068]                     invisible(pathname)
[13:36:41.068]                   }
[13:36:41.068]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:41.068]                     rootPath = tempdir()) 
[13:36:41.068]                   {
[13:36:41.068]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:41.068]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:41.068]                       tmpdir = path, fileext = ".rds")
[13:36:41.068]                     save_rds(obj, file)
[13:36:41.068]                   }
[13:36:41.068]                   saveImmediateCondition(cond, path = "/tmp/RtmphVqFyZ/.future/immediateConditions")
[13:36:41.068]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.068]                   {
[13:36:41.068]                     inherits <- base::inherits
[13:36:41.068]                     invokeRestart <- base::invokeRestart
[13:36:41.068]                     is.null <- base::is.null
[13:36:41.068]                     muffled <- FALSE
[13:36:41.068]                     if (inherits(cond, "message")) {
[13:36:41.068]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:41.068]                       if (muffled) 
[13:36:41.068]                         invokeRestart("muffleMessage")
[13:36:41.068]                     }
[13:36:41.068]                     else if (inherits(cond, "warning")) {
[13:36:41.068]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:41.068]                       if (muffled) 
[13:36:41.068]                         invokeRestart("muffleWarning")
[13:36:41.068]                     }
[13:36:41.068]                     else if (inherits(cond, "condition")) {
[13:36:41.068]                       if (!is.null(pattern)) {
[13:36:41.068]                         computeRestarts <- base::computeRestarts
[13:36:41.068]                         grepl <- base::grepl
[13:36:41.068]                         restarts <- computeRestarts(cond)
[13:36:41.068]                         for (restart in restarts) {
[13:36:41.068]                           name <- restart$name
[13:36:41.068]                           if (is.null(name)) 
[13:36:41.068]                             next
[13:36:41.068]                           if (!grepl(pattern, name)) 
[13:36:41.068]                             next
[13:36:41.068]                           invokeRestart(restart)
[13:36:41.068]                           muffled <- TRUE
[13:36:41.068]                           break
[13:36:41.068]                         }
[13:36:41.068]                       }
[13:36:41.068]                     }
[13:36:41.068]                     invisible(muffled)
[13:36:41.068]                   }
[13:36:41.068]                   muffleCondition(cond)
[13:36:41.068]                 })
[13:36:41.068]             }))
[13:36:41.068]             future::FutureResult(value = ...future.value$value, 
[13:36:41.068]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.068]                   ...future.rng), globalenv = if (FALSE) 
[13:36:41.068]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:41.068]                     ...future.globalenv.names))
[13:36:41.068]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:41.068]         }, condition = base::local({
[13:36:41.068]             c <- base::c
[13:36:41.068]             inherits <- base::inherits
[13:36:41.068]             invokeRestart <- base::invokeRestart
[13:36:41.068]             length <- base::length
[13:36:41.068]             list <- base::list
[13:36:41.068]             seq.int <- base::seq.int
[13:36:41.068]             signalCondition <- base::signalCondition
[13:36:41.068]             sys.calls <- base::sys.calls
[13:36:41.068]             `[[` <- base::`[[`
[13:36:41.068]             `+` <- base::`+`
[13:36:41.068]             `<<-` <- base::`<<-`
[13:36:41.068]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:41.068]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:41.068]                   3L)]
[13:36:41.068]             }
[13:36:41.068]             function(cond) {
[13:36:41.068]                 is_error <- inherits(cond, "error")
[13:36:41.068]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:41.068]                   NULL)
[13:36:41.068]                 if (is_error) {
[13:36:41.068]                   sessionInformation <- function() {
[13:36:41.068]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:41.068]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:41.068]                       search = base::search(), system = base::Sys.info())
[13:36:41.068]                   }
[13:36:41.068]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.068]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:41.068]                     cond$call), session = sessionInformation(), 
[13:36:41.068]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:41.068]                   signalCondition(cond)
[13:36:41.068]                 }
[13:36:41.068]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:41.068]                 "immediateCondition"))) {
[13:36:41.068]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:41.068]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.068]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:41.068]                   if (TRUE && !signal) {
[13:36:41.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.068]                     {
[13:36:41.068]                       inherits <- base::inherits
[13:36:41.068]                       invokeRestart <- base::invokeRestart
[13:36:41.068]                       is.null <- base::is.null
[13:36:41.068]                       muffled <- FALSE
[13:36:41.068]                       if (inherits(cond, "message")) {
[13:36:41.068]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.068]                         if (muffled) 
[13:36:41.068]                           invokeRestart("muffleMessage")
[13:36:41.068]                       }
[13:36:41.068]                       else if (inherits(cond, "warning")) {
[13:36:41.068]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.068]                         if (muffled) 
[13:36:41.068]                           invokeRestart("muffleWarning")
[13:36:41.068]                       }
[13:36:41.068]                       else if (inherits(cond, "condition")) {
[13:36:41.068]                         if (!is.null(pattern)) {
[13:36:41.068]                           computeRestarts <- base::computeRestarts
[13:36:41.068]                           grepl <- base::grepl
[13:36:41.068]                           restarts <- computeRestarts(cond)
[13:36:41.068]                           for (restart in restarts) {
[13:36:41.068]                             name <- restart$name
[13:36:41.068]                             if (is.null(name)) 
[13:36:41.068]                               next
[13:36:41.068]                             if (!grepl(pattern, name)) 
[13:36:41.068]                               next
[13:36:41.068]                             invokeRestart(restart)
[13:36:41.068]                             muffled <- TRUE
[13:36:41.068]                             break
[13:36:41.068]                           }
[13:36:41.068]                         }
[13:36:41.068]                       }
[13:36:41.068]                       invisible(muffled)
[13:36:41.068]                     }
[13:36:41.068]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.068]                   }
[13:36:41.068]                 }
[13:36:41.068]                 else {
[13:36:41.068]                   if (TRUE) {
[13:36:41.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.068]                     {
[13:36:41.068]                       inherits <- base::inherits
[13:36:41.068]                       invokeRestart <- base::invokeRestart
[13:36:41.068]                       is.null <- base::is.null
[13:36:41.068]                       muffled <- FALSE
[13:36:41.068]                       if (inherits(cond, "message")) {
[13:36:41.068]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.068]                         if (muffled) 
[13:36:41.068]                           invokeRestart("muffleMessage")
[13:36:41.068]                       }
[13:36:41.068]                       else if (inherits(cond, "warning")) {
[13:36:41.068]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.068]                         if (muffled) 
[13:36:41.068]                           invokeRestart("muffleWarning")
[13:36:41.068]                       }
[13:36:41.068]                       else if (inherits(cond, "condition")) {
[13:36:41.068]                         if (!is.null(pattern)) {
[13:36:41.068]                           computeRestarts <- base::computeRestarts
[13:36:41.068]                           grepl <- base::grepl
[13:36:41.068]                           restarts <- computeRestarts(cond)
[13:36:41.068]                           for (restart in restarts) {
[13:36:41.068]                             name <- restart$name
[13:36:41.068]                             if (is.null(name)) 
[13:36:41.068]                               next
[13:36:41.068]                             if (!grepl(pattern, name)) 
[13:36:41.068]                               next
[13:36:41.068]                             invokeRestart(restart)
[13:36:41.068]                             muffled <- TRUE
[13:36:41.068]                             break
[13:36:41.068]                           }
[13:36:41.068]                         }
[13:36:41.068]                       }
[13:36:41.068]                       invisible(muffled)
[13:36:41.068]                     }
[13:36:41.068]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.068]                   }
[13:36:41.068]                 }
[13:36:41.068]             }
[13:36:41.068]         }))
[13:36:41.068]     }, error = function(ex) {
[13:36:41.068]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:41.068]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.068]                 ...future.rng), started = ...future.startTime, 
[13:36:41.068]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:41.068]             version = "1.8"), class = "FutureResult")
[13:36:41.068]     }, finally = {
[13:36:41.068]         if (!identical(...future.workdir, getwd())) 
[13:36:41.068]             setwd(...future.workdir)
[13:36:41.068]         {
[13:36:41.068]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:41.068]                 ...future.oldOptions$nwarnings <- NULL
[13:36:41.068]             }
[13:36:41.068]             base::options(...future.oldOptions)
[13:36:41.068]             if (.Platform$OS.type == "windows") {
[13:36:41.068]                 old_names <- names(...future.oldEnvVars)
[13:36:41.068]                 envs <- base::Sys.getenv()
[13:36:41.068]                 names <- names(envs)
[13:36:41.068]                 common <- intersect(names, old_names)
[13:36:41.068]                 added <- setdiff(names, old_names)
[13:36:41.068]                 removed <- setdiff(old_names, names)
[13:36:41.068]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:41.068]                   envs[common]]
[13:36:41.068]                 NAMES <- toupper(changed)
[13:36:41.068]                 args <- list()
[13:36:41.068]                 for (kk in seq_along(NAMES)) {
[13:36:41.068]                   name <- changed[[kk]]
[13:36:41.068]                   NAME <- NAMES[[kk]]
[13:36:41.068]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.068]                     next
[13:36:41.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.068]                 }
[13:36:41.068]                 NAMES <- toupper(added)
[13:36:41.068]                 for (kk in seq_along(NAMES)) {
[13:36:41.068]                   name <- added[[kk]]
[13:36:41.068]                   NAME <- NAMES[[kk]]
[13:36:41.068]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.068]                     next
[13:36:41.068]                   args[[name]] <- ""
[13:36:41.068]                 }
[13:36:41.068]                 NAMES <- toupper(removed)
[13:36:41.068]                 for (kk in seq_along(NAMES)) {
[13:36:41.068]                   name <- removed[[kk]]
[13:36:41.068]                   NAME <- NAMES[[kk]]
[13:36:41.068]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.068]                     next
[13:36:41.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.068]                 }
[13:36:41.068]                 if (length(args) > 0) 
[13:36:41.068]                   base::do.call(base::Sys.setenv, args = args)
[13:36:41.068]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:41.068]             }
[13:36:41.068]             else {
[13:36:41.068]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:41.068]             }
[13:36:41.068]             {
[13:36:41.068]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:41.068]                   0L) {
[13:36:41.068]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:41.068]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:41.068]                   base::options(opts)
[13:36:41.068]                 }
[13:36:41.068]                 {
[13:36:41.068]                   {
[13:36:41.068]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:41.068]                     NULL
[13:36:41.068]                   }
[13:36:41.068]                   options(future.plan = NULL)
[13:36:41.068]                   if (is.na(NA_character_)) 
[13:36:41.068]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.068]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:41.068]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:41.068]                     .init = FALSE)
[13:36:41.068]                 }
[13:36:41.068]             }
[13:36:41.068]         }
[13:36:41.068]     })
[13:36:41.068]     if (TRUE) {
[13:36:41.068]         base::sink(type = "output", split = FALSE)
[13:36:41.068]         if (TRUE) {
[13:36:41.068]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:41.068]         }
[13:36:41.068]         else {
[13:36:41.068]             ...future.result["stdout"] <- base::list(NULL)
[13:36:41.068]         }
[13:36:41.068]         base::close(...future.stdout)
[13:36:41.068]         ...future.stdout <- NULL
[13:36:41.068]     }
[13:36:41.068]     ...future.result$conditions <- ...future.conditions
[13:36:41.068]     ...future.result$finished <- base::Sys.time()
[13:36:41.068]     ...future.result
[13:36:41.068] }
[13:36:41.070] assign_globals() ...
[13:36:41.070] List of 2
[13:36:41.070]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:36:41.070]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:36:41.070]  - attr(*, "where")=List of 2
[13:36:41.070]   ..$ weight:<environment: R_EmptyEnv> 
[13:36:41.070]   ..$ group :<environment: R_EmptyEnv> 
[13:36:41.070]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:41.070]  - attr(*, "resolved")= logi FALSE
[13:36:41.070]  - attr(*, "total_size")= num 896
[13:36:41.070]  - attr(*, "already-done")= logi TRUE
[13:36:41.074] - copied ‘weight’ to environment
[13:36:41.074] - copied ‘group’ to environment
[13:36:41.074] assign_globals() ... done
[13:36:41.074] requestCore(): workers = 2
[13:36:41.076] MulticoreFuture started
[13:36:41.076] - Launch lazy future ... done
[13:36:41.076] run() for ‘MulticoreFuture’ ... done
[13:36:41.077] result() for MulticoreFuture ...
[13:36:41.077] plan(): Setting new future strategy stack:
[13:36:41.077] List of future strategies:
[13:36:41.077] 1. sequential:
[13:36:41.077]    - args: function (..., envir = parent.frame())
[13:36:41.077]    - tweaked: FALSE
[13:36:41.077]    - call: NULL
[13:36:41.078] plan(): nbrOfWorkers() = 1
[13:36:41.082] plan(): Setting new future strategy stack:
[13:36:41.082] List of future strategies:
[13:36:41.082] 1. multicore:
[13:36:41.082]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:41.082]    - tweaked: FALSE
[13:36:41.082]    - call: plan(strategy)
[13:36:41.087] plan(): nbrOfWorkers() = 2
[13:36:41.089] result() for MulticoreFuture ...
[13:36:41.089] result() for MulticoreFuture ... done
[13:36:41.089] result() for MulticoreFuture ... done
[13:36:41.089] result() for MulticoreFuture ...
[13:36:41.089] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:36:41.092] getGlobalsAndPackages() ...
[13:36:41.092] Searching for globals...
[13:36:41.094] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:36:41.094] Searching for globals ... DONE
[13:36:41.094] Resolving globals: FALSE
[13:36:41.095] The total size of the 2 globals is 896 bytes (896 bytes)
[13:36:41.097] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:36:41.098] - globals: [2] ‘weight’, ‘group’
[13:36:41.098] - packages: [1] ‘stats’
[13:36:41.098] getGlobalsAndPackages() ... DONE
[13:36:41.098] run() for ‘Future’ ...
[13:36:41.098] - state: ‘created’
[13:36:41.099] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:41.103] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:41.103] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:41.103]   - Field: ‘label’
[13:36:41.103]   - Field: ‘local’
[13:36:41.103]   - Field: ‘owner’
[13:36:41.103]   - Field: ‘envir’
[13:36:41.103]   - Field: ‘workers’
[13:36:41.104]   - Field: ‘packages’
[13:36:41.104]   - Field: ‘gc’
[13:36:41.104]   - Field: ‘job’
[13:36:41.104]   - Field: ‘conditions’
[13:36:41.104]   - Field: ‘expr’
[13:36:41.104]   - Field: ‘uuid’
[13:36:41.104]   - Field: ‘seed’
[13:36:41.104]   - Field: ‘version’
[13:36:41.105]   - Field: ‘result’
[13:36:41.105]   - Field: ‘asynchronous’
[13:36:41.105]   - Field: ‘calls’
[13:36:41.105]   - Field: ‘globals’
[13:36:41.105]   - Field: ‘stdout’
[13:36:41.105]   - Field: ‘earlySignal’
[13:36:41.105]   - Field: ‘lazy’
[13:36:41.105]   - Field: ‘state’
[13:36:41.105] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:41.106] - Launch lazy future ...
[13:36:41.106] Packages needed by the future expression (n = 1): ‘stats’
[13:36:41.106] Packages needed by future strategies (n = 0): <none>
[13:36:41.107] {
[13:36:41.107]     {
[13:36:41.107]         {
[13:36:41.107]             ...future.startTime <- base::Sys.time()
[13:36:41.107]             {
[13:36:41.107]                 {
[13:36:41.107]                   {
[13:36:41.107]                     {
[13:36:41.107]                       {
[13:36:41.107]                         base::local({
[13:36:41.107]                           has_future <- base::requireNamespace("future", 
[13:36:41.107]                             quietly = TRUE)
[13:36:41.107]                           if (has_future) {
[13:36:41.107]                             ns <- base::getNamespace("future")
[13:36:41.107]                             version <- ns[[".package"]][["version"]]
[13:36:41.107]                             if (is.null(version)) 
[13:36:41.107]                               version <- utils::packageVersion("future")
[13:36:41.107]                           }
[13:36:41.107]                           else {
[13:36:41.107]                             version <- NULL
[13:36:41.107]                           }
[13:36:41.107]                           if (!has_future || version < "1.8.0") {
[13:36:41.107]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:41.107]                               "", base::R.version$version.string), 
[13:36:41.107]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:41.107]                                 base::R.version$platform, 8 * 
[13:36:41.107]                                   base::.Machine$sizeof.pointer), 
[13:36:41.107]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:41.107]                                 "release", "version")], collapse = " "), 
[13:36:41.107]                               hostname = base::Sys.info()[["nodename"]])
[13:36:41.107]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:41.107]                               info)
[13:36:41.107]                             info <- base::paste(info, collapse = "; ")
[13:36:41.107]                             if (!has_future) {
[13:36:41.107]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:41.107]                                 info)
[13:36:41.107]                             }
[13:36:41.107]                             else {
[13:36:41.107]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:41.107]                                 info, version)
[13:36:41.107]                             }
[13:36:41.107]                             base::stop(msg)
[13:36:41.107]                           }
[13:36:41.107]                         })
[13:36:41.107]                       }
[13:36:41.107]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:41.107]                       base::options(mc.cores = 1L)
[13:36:41.107]                     }
[13:36:41.107]                     base::local({
[13:36:41.107]                       for (pkg in "stats") {
[13:36:41.107]                         base::loadNamespace(pkg)
[13:36:41.107]                         base::library(pkg, character.only = TRUE)
[13:36:41.107]                       }
[13:36:41.107]                     })
[13:36:41.107]                   }
[13:36:41.107]                   ...future.strategy.old <- future::plan("list")
[13:36:41.107]                   options(future.plan = NULL)
[13:36:41.107]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.107]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:41.107]                 }
[13:36:41.107]                 ...future.workdir <- getwd()
[13:36:41.107]             }
[13:36:41.107]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:41.107]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:41.107]         }
[13:36:41.107]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:41.107]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:41.107]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:41.107]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:41.107]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:41.107]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:41.107]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:41.107]             base::names(...future.oldOptions))
[13:36:41.107]     }
[13:36:41.107]     if (FALSE) {
[13:36:41.107]     }
[13:36:41.107]     else {
[13:36:41.107]         if (TRUE) {
[13:36:41.107]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:41.107]                 open = "w")
[13:36:41.107]         }
[13:36:41.107]         else {
[13:36:41.107]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:41.107]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:41.107]         }
[13:36:41.107]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:41.107]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:41.107]             base::sink(type = "output", split = FALSE)
[13:36:41.107]             base::close(...future.stdout)
[13:36:41.107]         }, add = TRUE)
[13:36:41.107]     }
[13:36:41.107]     ...future.frame <- base::sys.nframe()
[13:36:41.107]     ...future.conditions <- base::list()
[13:36:41.107]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:41.107]     if (FALSE) {
[13:36:41.107]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:41.107]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:41.107]     }
[13:36:41.107]     ...future.result <- base::tryCatch({
[13:36:41.107]         base::withCallingHandlers({
[13:36:41.107]             ...future.value <- base::withVisible(base::local({
[13:36:41.107]                 withCallingHandlers({
[13:36:41.107]                   {
[13:36:41.107]                     lm(weight ~ group - 1)
[13:36:41.107]                   }
[13:36:41.107]                 }, immediateCondition = function(cond) {
[13:36:41.107]                   save_rds <- function (object, pathname, ...) 
[13:36:41.107]                   {
[13:36:41.107]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:41.107]                     if (file_test("-f", pathname_tmp)) {
[13:36:41.107]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.107]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:41.107]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.107]                         fi_tmp[["mtime"]])
[13:36:41.107]                     }
[13:36:41.107]                     tryCatch({
[13:36:41.107]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:41.107]                     }, error = function(ex) {
[13:36:41.107]                       msg <- conditionMessage(ex)
[13:36:41.107]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.107]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:41.107]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.107]                         fi_tmp[["mtime"]], msg)
[13:36:41.107]                       ex$message <- msg
[13:36:41.107]                       stop(ex)
[13:36:41.107]                     })
[13:36:41.107]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:41.107]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:41.107]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:41.107]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.107]                       fi <- file.info(pathname)
[13:36:41.107]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:41.107]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.107]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:41.107]                         fi[["size"]], fi[["mtime"]])
[13:36:41.107]                       stop(msg)
[13:36:41.107]                     }
[13:36:41.107]                     invisible(pathname)
[13:36:41.107]                   }
[13:36:41.107]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:41.107]                     rootPath = tempdir()) 
[13:36:41.107]                   {
[13:36:41.107]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:41.107]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:41.107]                       tmpdir = path, fileext = ".rds")
[13:36:41.107]                     save_rds(obj, file)
[13:36:41.107]                   }
[13:36:41.107]                   saveImmediateCondition(cond, path = "/tmp/RtmphVqFyZ/.future/immediateConditions")
[13:36:41.107]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.107]                   {
[13:36:41.107]                     inherits <- base::inherits
[13:36:41.107]                     invokeRestart <- base::invokeRestart
[13:36:41.107]                     is.null <- base::is.null
[13:36:41.107]                     muffled <- FALSE
[13:36:41.107]                     if (inherits(cond, "message")) {
[13:36:41.107]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:41.107]                       if (muffled) 
[13:36:41.107]                         invokeRestart("muffleMessage")
[13:36:41.107]                     }
[13:36:41.107]                     else if (inherits(cond, "warning")) {
[13:36:41.107]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:41.107]                       if (muffled) 
[13:36:41.107]                         invokeRestart("muffleWarning")
[13:36:41.107]                     }
[13:36:41.107]                     else if (inherits(cond, "condition")) {
[13:36:41.107]                       if (!is.null(pattern)) {
[13:36:41.107]                         computeRestarts <- base::computeRestarts
[13:36:41.107]                         grepl <- base::grepl
[13:36:41.107]                         restarts <- computeRestarts(cond)
[13:36:41.107]                         for (restart in restarts) {
[13:36:41.107]                           name <- restart$name
[13:36:41.107]                           if (is.null(name)) 
[13:36:41.107]                             next
[13:36:41.107]                           if (!grepl(pattern, name)) 
[13:36:41.107]                             next
[13:36:41.107]                           invokeRestart(restart)
[13:36:41.107]                           muffled <- TRUE
[13:36:41.107]                           break
[13:36:41.107]                         }
[13:36:41.107]                       }
[13:36:41.107]                     }
[13:36:41.107]                     invisible(muffled)
[13:36:41.107]                   }
[13:36:41.107]                   muffleCondition(cond)
[13:36:41.107]                 })
[13:36:41.107]             }))
[13:36:41.107]             future::FutureResult(value = ...future.value$value, 
[13:36:41.107]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.107]                   ...future.rng), globalenv = if (FALSE) 
[13:36:41.107]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:41.107]                     ...future.globalenv.names))
[13:36:41.107]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:41.107]         }, condition = base::local({
[13:36:41.107]             c <- base::c
[13:36:41.107]             inherits <- base::inherits
[13:36:41.107]             invokeRestart <- base::invokeRestart
[13:36:41.107]             length <- base::length
[13:36:41.107]             list <- base::list
[13:36:41.107]             seq.int <- base::seq.int
[13:36:41.107]             signalCondition <- base::signalCondition
[13:36:41.107]             sys.calls <- base::sys.calls
[13:36:41.107]             `[[` <- base::`[[`
[13:36:41.107]             `+` <- base::`+`
[13:36:41.107]             `<<-` <- base::`<<-`
[13:36:41.107]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:41.107]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:41.107]                   3L)]
[13:36:41.107]             }
[13:36:41.107]             function(cond) {
[13:36:41.107]                 is_error <- inherits(cond, "error")
[13:36:41.107]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:41.107]                   NULL)
[13:36:41.107]                 if (is_error) {
[13:36:41.107]                   sessionInformation <- function() {
[13:36:41.107]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:41.107]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:41.107]                       search = base::search(), system = base::Sys.info())
[13:36:41.107]                   }
[13:36:41.107]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.107]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:41.107]                     cond$call), session = sessionInformation(), 
[13:36:41.107]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:41.107]                   signalCondition(cond)
[13:36:41.107]                 }
[13:36:41.107]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:41.107]                 "immediateCondition"))) {
[13:36:41.107]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:41.107]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.107]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:41.107]                   if (TRUE && !signal) {
[13:36:41.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.107]                     {
[13:36:41.107]                       inherits <- base::inherits
[13:36:41.107]                       invokeRestart <- base::invokeRestart
[13:36:41.107]                       is.null <- base::is.null
[13:36:41.107]                       muffled <- FALSE
[13:36:41.107]                       if (inherits(cond, "message")) {
[13:36:41.107]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.107]                         if (muffled) 
[13:36:41.107]                           invokeRestart("muffleMessage")
[13:36:41.107]                       }
[13:36:41.107]                       else if (inherits(cond, "warning")) {
[13:36:41.107]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.107]                         if (muffled) 
[13:36:41.107]                           invokeRestart("muffleWarning")
[13:36:41.107]                       }
[13:36:41.107]                       else if (inherits(cond, "condition")) {
[13:36:41.107]                         if (!is.null(pattern)) {
[13:36:41.107]                           computeRestarts <- base::computeRestarts
[13:36:41.107]                           grepl <- base::grepl
[13:36:41.107]                           restarts <- computeRestarts(cond)
[13:36:41.107]                           for (restart in restarts) {
[13:36:41.107]                             name <- restart$name
[13:36:41.107]                             if (is.null(name)) 
[13:36:41.107]                               next
[13:36:41.107]                             if (!grepl(pattern, name)) 
[13:36:41.107]                               next
[13:36:41.107]                             invokeRestart(restart)
[13:36:41.107]                             muffled <- TRUE
[13:36:41.107]                             break
[13:36:41.107]                           }
[13:36:41.107]                         }
[13:36:41.107]                       }
[13:36:41.107]                       invisible(muffled)
[13:36:41.107]                     }
[13:36:41.107]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.107]                   }
[13:36:41.107]                 }
[13:36:41.107]                 else {
[13:36:41.107]                   if (TRUE) {
[13:36:41.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.107]                     {
[13:36:41.107]                       inherits <- base::inherits
[13:36:41.107]                       invokeRestart <- base::invokeRestart
[13:36:41.107]                       is.null <- base::is.null
[13:36:41.107]                       muffled <- FALSE
[13:36:41.107]                       if (inherits(cond, "message")) {
[13:36:41.107]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.107]                         if (muffled) 
[13:36:41.107]                           invokeRestart("muffleMessage")
[13:36:41.107]                       }
[13:36:41.107]                       else if (inherits(cond, "warning")) {
[13:36:41.107]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.107]                         if (muffled) 
[13:36:41.107]                           invokeRestart("muffleWarning")
[13:36:41.107]                       }
[13:36:41.107]                       else if (inherits(cond, "condition")) {
[13:36:41.107]                         if (!is.null(pattern)) {
[13:36:41.107]                           computeRestarts <- base::computeRestarts
[13:36:41.107]                           grepl <- base::grepl
[13:36:41.107]                           restarts <- computeRestarts(cond)
[13:36:41.107]                           for (restart in restarts) {
[13:36:41.107]                             name <- restart$name
[13:36:41.107]                             if (is.null(name)) 
[13:36:41.107]                               next
[13:36:41.107]                             if (!grepl(pattern, name)) 
[13:36:41.107]                               next
[13:36:41.107]                             invokeRestart(restart)
[13:36:41.107]                             muffled <- TRUE
[13:36:41.107]                             break
[13:36:41.107]                           }
[13:36:41.107]                         }
[13:36:41.107]                       }
[13:36:41.107]                       invisible(muffled)
[13:36:41.107]                     }
[13:36:41.107]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.107]                   }
[13:36:41.107]                 }
[13:36:41.107]             }
[13:36:41.107]         }))
[13:36:41.107]     }, error = function(ex) {
[13:36:41.107]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:41.107]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.107]                 ...future.rng), started = ...future.startTime, 
[13:36:41.107]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:41.107]             version = "1.8"), class = "FutureResult")
[13:36:41.107]     }, finally = {
[13:36:41.107]         if (!identical(...future.workdir, getwd())) 
[13:36:41.107]             setwd(...future.workdir)
[13:36:41.107]         {
[13:36:41.107]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:41.107]                 ...future.oldOptions$nwarnings <- NULL
[13:36:41.107]             }
[13:36:41.107]             base::options(...future.oldOptions)
[13:36:41.107]             if (.Platform$OS.type == "windows") {
[13:36:41.107]                 old_names <- names(...future.oldEnvVars)
[13:36:41.107]                 envs <- base::Sys.getenv()
[13:36:41.107]                 names <- names(envs)
[13:36:41.107]                 common <- intersect(names, old_names)
[13:36:41.107]                 added <- setdiff(names, old_names)
[13:36:41.107]                 removed <- setdiff(old_names, names)
[13:36:41.107]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:41.107]                   envs[common]]
[13:36:41.107]                 NAMES <- toupper(changed)
[13:36:41.107]                 args <- list()
[13:36:41.107]                 for (kk in seq_along(NAMES)) {
[13:36:41.107]                   name <- changed[[kk]]
[13:36:41.107]                   NAME <- NAMES[[kk]]
[13:36:41.107]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.107]                     next
[13:36:41.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.107]                 }
[13:36:41.107]                 NAMES <- toupper(added)
[13:36:41.107]                 for (kk in seq_along(NAMES)) {
[13:36:41.107]                   name <- added[[kk]]
[13:36:41.107]                   NAME <- NAMES[[kk]]
[13:36:41.107]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.107]                     next
[13:36:41.107]                   args[[name]] <- ""
[13:36:41.107]                 }
[13:36:41.107]                 NAMES <- toupper(removed)
[13:36:41.107]                 for (kk in seq_along(NAMES)) {
[13:36:41.107]                   name <- removed[[kk]]
[13:36:41.107]                   NAME <- NAMES[[kk]]
[13:36:41.107]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.107]                     next
[13:36:41.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.107]                 }
[13:36:41.107]                 if (length(args) > 0) 
[13:36:41.107]                   base::do.call(base::Sys.setenv, args = args)
[13:36:41.107]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:41.107]             }
[13:36:41.107]             else {
[13:36:41.107]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:41.107]             }
[13:36:41.107]             {
[13:36:41.107]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:41.107]                   0L) {
[13:36:41.107]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:41.107]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:41.107]                   base::options(opts)
[13:36:41.107]                 }
[13:36:41.107]                 {
[13:36:41.107]                   {
[13:36:41.107]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:41.107]                     NULL
[13:36:41.107]                   }
[13:36:41.107]                   options(future.plan = NULL)
[13:36:41.107]                   if (is.na(NA_character_)) 
[13:36:41.107]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.107]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:41.107]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:41.107]                     .init = FALSE)
[13:36:41.107]                 }
[13:36:41.107]             }
[13:36:41.107]         }
[13:36:41.107]     })
[13:36:41.107]     if (TRUE) {
[13:36:41.107]         base::sink(type = "output", split = FALSE)
[13:36:41.107]         if (TRUE) {
[13:36:41.107]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:41.107]         }
[13:36:41.107]         else {
[13:36:41.107]             ...future.result["stdout"] <- base::list(NULL)
[13:36:41.107]         }
[13:36:41.107]         base::close(...future.stdout)
[13:36:41.107]         ...future.stdout <- NULL
[13:36:41.107]     }
[13:36:41.107]     ...future.result$conditions <- ...future.conditions
[13:36:41.107]     ...future.result$finished <- base::Sys.time()
[13:36:41.107]     ...future.result
[13:36:41.107] }
[13:36:41.109] assign_globals() ...
[13:36:41.109] List of 2
[13:36:41.109]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:36:41.109]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:36:41.109]  - attr(*, "where")=List of 2
[13:36:41.109]   ..$ weight:<environment: R_EmptyEnv> 
[13:36:41.109]   ..$ group :<environment: R_EmptyEnv> 
[13:36:41.109]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:41.109]  - attr(*, "resolved")= logi FALSE
[13:36:41.109]  - attr(*, "total_size")= num 896
[13:36:41.109]  - attr(*, "already-done")= logi TRUE
[13:36:41.113] - copied ‘weight’ to environment
[13:36:41.113] - copied ‘group’ to environment
[13:36:41.113] assign_globals() ... done
[13:36:41.113] requestCore(): workers = 2
[13:36:41.115] MulticoreFuture started
[13:36:41.115] - Launch lazy future ... done
[13:36:41.115] run() for ‘MulticoreFuture’ ... done
[13:36:41.116] result() for MulticoreFuture ...
[13:36:41.116] plan(): Setting new future strategy stack:
[13:36:41.117] List of future strategies:
[13:36:41.117] 1. sequential:
[13:36:41.117]    - args: function (..., envir = parent.frame())
[13:36:41.117]    - tweaked: FALSE
[13:36:41.117]    - call: NULL
[13:36:41.117] plan(): nbrOfWorkers() = 1
[13:36:41.121] plan(): Setting new future strategy stack:
[13:36:41.121] List of future strategies:
[13:36:41.121] 1. multicore:
[13:36:41.121]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:41.121]    - tweaked: FALSE
[13:36:41.121]    - call: plan(strategy)
[13:36:41.126] plan(): nbrOfWorkers() = 2
[13:36:41.128] result() for MulticoreFuture ...
[13:36:41.128] result() for MulticoreFuture ... done
[13:36:41.128] result() for MulticoreFuture ... done
[13:36:41.129] result() for MulticoreFuture ...
[13:36:41.129] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:36:41.131] getGlobalsAndPackages() ...
[13:36:41.131] Searching for globals...
[13:36:41.133] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:36:41.133] Searching for globals ... DONE
[13:36:41.133] Resolving globals: FALSE
[13:36:41.134] The total size of the 2 globals is 896 bytes (896 bytes)
[13:36:41.135] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:36:41.135] - globals: [2] ‘weight’, ‘group’
[13:36:41.135] - packages: [1] ‘stats’
[13:36:41.135] getGlobalsAndPackages() ... DONE
[13:36:41.135] run() for ‘Future’ ...
[13:36:41.136] - state: ‘created’
[13:36:41.136] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:41.140] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:41.140] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:41.140]   - Field: ‘label’
[13:36:41.140]   - Field: ‘local’
[13:36:41.140]   - Field: ‘owner’
[13:36:41.140]   - Field: ‘envir’
[13:36:41.140]   - Field: ‘workers’
[13:36:41.142]   - Field: ‘packages’
[13:36:41.143]   - Field: ‘gc’
[13:36:41.143]   - Field: ‘job’
[13:36:41.143]   - Field: ‘conditions’
[13:36:41.143]   - Field: ‘expr’
[13:36:41.143]   - Field: ‘uuid’
[13:36:41.143]   - Field: ‘seed’
[13:36:41.143]   - Field: ‘version’
[13:36:41.144]   - Field: ‘result’
[13:36:41.144]   - Field: ‘asynchronous’
[13:36:41.144]   - Field: ‘calls’
[13:36:41.144]   - Field: ‘globals’
[13:36:41.144]   - Field: ‘stdout’
[13:36:41.144]   - Field: ‘earlySignal’
[13:36:41.144]   - Field: ‘lazy’
[13:36:41.144]   - Field: ‘state’
[13:36:41.145] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:41.145] - Launch lazy future ...
[13:36:41.145] Packages needed by the future expression (n = 1): ‘stats’
[13:36:41.145] Packages needed by future strategies (n = 0): <none>
[13:36:41.146] {
[13:36:41.146]     {
[13:36:41.146]         {
[13:36:41.146]             ...future.startTime <- base::Sys.time()
[13:36:41.146]             {
[13:36:41.146]                 {
[13:36:41.146]                   {
[13:36:41.146]                     {
[13:36:41.146]                       {
[13:36:41.146]                         base::local({
[13:36:41.146]                           has_future <- base::requireNamespace("future", 
[13:36:41.146]                             quietly = TRUE)
[13:36:41.146]                           if (has_future) {
[13:36:41.146]                             ns <- base::getNamespace("future")
[13:36:41.146]                             version <- ns[[".package"]][["version"]]
[13:36:41.146]                             if (is.null(version)) 
[13:36:41.146]                               version <- utils::packageVersion("future")
[13:36:41.146]                           }
[13:36:41.146]                           else {
[13:36:41.146]                             version <- NULL
[13:36:41.146]                           }
[13:36:41.146]                           if (!has_future || version < "1.8.0") {
[13:36:41.146]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:41.146]                               "", base::R.version$version.string), 
[13:36:41.146]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:41.146]                                 base::R.version$platform, 8 * 
[13:36:41.146]                                   base::.Machine$sizeof.pointer), 
[13:36:41.146]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:41.146]                                 "release", "version")], collapse = " "), 
[13:36:41.146]                               hostname = base::Sys.info()[["nodename"]])
[13:36:41.146]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:41.146]                               info)
[13:36:41.146]                             info <- base::paste(info, collapse = "; ")
[13:36:41.146]                             if (!has_future) {
[13:36:41.146]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:41.146]                                 info)
[13:36:41.146]                             }
[13:36:41.146]                             else {
[13:36:41.146]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:41.146]                                 info, version)
[13:36:41.146]                             }
[13:36:41.146]                             base::stop(msg)
[13:36:41.146]                           }
[13:36:41.146]                         })
[13:36:41.146]                       }
[13:36:41.146]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:41.146]                       base::options(mc.cores = 1L)
[13:36:41.146]                     }
[13:36:41.146]                     base::local({
[13:36:41.146]                       for (pkg in "stats") {
[13:36:41.146]                         base::loadNamespace(pkg)
[13:36:41.146]                         base::library(pkg, character.only = TRUE)
[13:36:41.146]                       }
[13:36:41.146]                     })
[13:36:41.146]                   }
[13:36:41.146]                   ...future.strategy.old <- future::plan("list")
[13:36:41.146]                   options(future.plan = NULL)
[13:36:41.146]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.146]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:41.146]                 }
[13:36:41.146]                 ...future.workdir <- getwd()
[13:36:41.146]             }
[13:36:41.146]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:41.146]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:41.146]         }
[13:36:41.146]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:41.146]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:41.146]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:41.146]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:41.146]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:41.146]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:41.146]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:41.146]             base::names(...future.oldOptions))
[13:36:41.146]     }
[13:36:41.146]     if (FALSE) {
[13:36:41.146]     }
[13:36:41.146]     else {
[13:36:41.146]         if (TRUE) {
[13:36:41.146]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:41.146]                 open = "w")
[13:36:41.146]         }
[13:36:41.146]         else {
[13:36:41.146]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:41.146]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:41.146]         }
[13:36:41.146]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:41.146]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:41.146]             base::sink(type = "output", split = FALSE)
[13:36:41.146]             base::close(...future.stdout)
[13:36:41.146]         }, add = TRUE)
[13:36:41.146]     }
[13:36:41.146]     ...future.frame <- base::sys.nframe()
[13:36:41.146]     ...future.conditions <- base::list()
[13:36:41.146]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:41.146]     if (FALSE) {
[13:36:41.146]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:41.146]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:41.146]     }
[13:36:41.146]     ...future.result <- base::tryCatch({
[13:36:41.146]         base::withCallingHandlers({
[13:36:41.146]             ...future.value <- base::withVisible(base::local({
[13:36:41.146]                 withCallingHandlers({
[13:36:41.146]                   {
[13:36:41.146]                     lm(weight ~ group - 1)
[13:36:41.146]                   }
[13:36:41.146]                 }, immediateCondition = function(cond) {
[13:36:41.146]                   save_rds <- function (object, pathname, ...) 
[13:36:41.146]                   {
[13:36:41.146]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:41.146]                     if (file_test("-f", pathname_tmp)) {
[13:36:41.146]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.146]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:41.146]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.146]                         fi_tmp[["mtime"]])
[13:36:41.146]                     }
[13:36:41.146]                     tryCatch({
[13:36:41.146]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:41.146]                     }, error = function(ex) {
[13:36:41.146]                       msg <- conditionMessage(ex)
[13:36:41.146]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.146]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:41.146]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.146]                         fi_tmp[["mtime"]], msg)
[13:36:41.146]                       ex$message <- msg
[13:36:41.146]                       stop(ex)
[13:36:41.146]                     })
[13:36:41.146]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:41.146]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:41.146]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:41.146]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.146]                       fi <- file.info(pathname)
[13:36:41.146]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:41.146]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.146]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:41.146]                         fi[["size"]], fi[["mtime"]])
[13:36:41.146]                       stop(msg)
[13:36:41.146]                     }
[13:36:41.146]                     invisible(pathname)
[13:36:41.146]                   }
[13:36:41.146]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:41.146]                     rootPath = tempdir()) 
[13:36:41.146]                   {
[13:36:41.146]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:41.146]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:41.146]                       tmpdir = path, fileext = ".rds")
[13:36:41.146]                     save_rds(obj, file)
[13:36:41.146]                   }
[13:36:41.146]                   saveImmediateCondition(cond, path = "/tmp/RtmphVqFyZ/.future/immediateConditions")
[13:36:41.146]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.146]                   {
[13:36:41.146]                     inherits <- base::inherits
[13:36:41.146]                     invokeRestart <- base::invokeRestart
[13:36:41.146]                     is.null <- base::is.null
[13:36:41.146]                     muffled <- FALSE
[13:36:41.146]                     if (inherits(cond, "message")) {
[13:36:41.146]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:41.146]                       if (muffled) 
[13:36:41.146]                         invokeRestart("muffleMessage")
[13:36:41.146]                     }
[13:36:41.146]                     else if (inherits(cond, "warning")) {
[13:36:41.146]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:41.146]                       if (muffled) 
[13:36:41.146]                         invokeRestart("muffleWarning")
[13:36:41.146]                     }
[13:36:41.146]                     else if (inherits(cond, "condition")) {
[13:36:41.146]                       if (!is.null(pattern)) {
[13:36:41.146]                         computeRestarts <- base::computeRestarts
[13:36:41.146]                         grepl <- base::grepl
[13:36:41.146]                         restarts <- computeRestarts(cond)
[13:36:41.146]                         for (restart in restarts) {
[13:36:41.146]                           name <- restart$name
[13:36:41.146]                           if (is.null(name)) 
[13:36:41.146]                             next
[13:36:41.146]                           if (!grepl(pattern, name)) 
[13:36:41.146]                             next
[13:36:41.146]                           invokeRestart(restart)
[13:36:41.146]                           muffled <- TRUE
[13:36:41.146]                           break
[13:36:41.146]                         }
[13:36:41.146]                       }
[13:36:41.146]                     }
[13:36:41.146]                     invisible(muffled)
[13:36:41.146]                   }
[13:36:41.146]                   muffleCondition(cond)
[13:36:41.146]                 })
[13:36:41.146]             }))
[13:36:41.146]             future::FutureResult(value = ...future.value$value, 
[13:36:41.146]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.146]                   ...future.rng), globalenv = if (FALSE) 
[13:36:41.146]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:41.146]                     ...future.globalenv.names))
[13:36:41.146]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:41.146]         }, condition = base::local({
[13:36:41.146]             c <- base::c
[13:36:41.146]             inherits <- base::inherits
[13:36:41.146]             invokeRestart <- base::invokeRestart
[13:36:41.146]             length <- base::length
[13:36:41.146]             list <- base::list
[13:36:41.146]             seq.int <- base::seq.int
[13:36:41.146]             signalCondition <- base::signalCondition
[13:36:41.146]             sys.calls <- base::sys.calls
[13:36:41.146]             `[[` <- base::`[[`
[13:36:41.146]             `+` <- base::`+`
[13:36:41.146]             `<<-` <- base::`<<-`
[13:36:41.146]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:41.146]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:41.146]                   3L)]
[13:36:41.146]             }
[13:36:41.146]             function(cond) {
[13:36:41.146]                 is_error <- inherits(cond, "error")
[13:36:41.146]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:41.146]                   NULL)
[13:36:41.146]                 if (is_error) {
[13:36:41.146]                   sessionInformation <- function() {
[13:36:41.146]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:41.146]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:41.146]                       search = base::search(), system = base::Sys.info())
[13:36:41.146]                   }
[13:36:41.146]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.146]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:41.146]                     cond$call), session = sessionInformation(), 
[13:36:41.146]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:41.146]                   signalCondition(cond)
[13:36:41.146]                 }
[13:36:41.146]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:41.146]                 "immediateCondition"))) {
[13:36:41.146]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:41.146]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.146]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:41.146]                   if (TRUE && !signal) {
[13:36:41.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.146]                     {
[13:36:41.146]                       inherits <- base::inherits
[13:36:41.146]                       invokeRestart <- base::invokeRestart
[13:36:41.146]                       is.null <- base::is.null
[13:36:41.146]                       muffled <- FALSE
[13:36:41.146]                       if (inherits(cond, "message")) {
[13:36:41.146]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.146]                         if (muffled) 
[13:36:41.146]                           invokeRestart("muffleMessage")
[13:36:41.146]                       }
[13:36:41.146]                       else if (inherits(cond, "warning")) {
[13:36:41.146]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.146]                         if (muffled) 
[13:36:41.146]                           invokeRestart("muffleWarning")
[13:36:41.146]                       }
[13:36:41.146]                       else if (inherits(cond, "condition")) {
[13:36:41.146]                         if (!is.null(pattern)) {
[13:36:41.146]                           computeRestarts <- base::computeRestarts
[13:36:41.146]                           grepl <- base::grepl
[13:36:41.146]                           restarts <- computeRestarts(cond)
[13:36:41.146]                           for (restart in restarts) {
[13:36:41.146]                             name <- restart$name
[13:36:41.146]                             if (is.null(name)) 
[13:36:41.146]                               next
[13:36:41.146]                             if (!grepl(pattern, name)) 
[13:36:41.146]                               next
[13:36:41.146]                             invokeRestart(restart)
[13:36:41.146]                             muffled <- TRUE
[13:36:41.146]                             break
[13:36:41.146]                           }
[13:36:41.146]                         }
[13:36:41.146]                       }
[13:36:41.146]                       invisible(muffled)
[13:36:41.146]                     }
[13:36:41.146]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.146]                   }
[13:36:41.146]                 }
[13:36:41.146]                 else {
[13:36:41.146]                   if (TRUE) {
[13:36:41.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.146]                     {
[13:36:41.146]                       inherits <- base::inherits
[13:36:41.146]                       invokeRestart <- base::invokeRestart
[13:36:41.146]                       is.null <- base::is.null
[13:36:41.146]                       muffled <- FALSE
[13:36:41.146]                       if (inherits(cond, "message")) {
[13:36:41.146]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.146]                         if (muffled) 
[13:36:41.146]                           invokeRestart("muffleMessage")
[13:36:41.146]                       }
[13:36:41.146]                       else if (inherits(cond, "warning")) {
[13:36:41.146]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.146]                         if (muffled) 
[13:36:41.146]                           invokeRestart("muffleWarning")
[13:36:41.146]                       }
[13:36:41.146]                       else if (inherits(cond, "condition")) {
[13:36:41.146]                         if (!is.null(pattern)) {
[13:36:41.146]                           computeRestarts <- base::computeRestarts
[13:36:41.146]                           grepl <- base::grepl
[13:36:41.146]                           restarts <- computeRestarts(cond)
[13:36:41.146]                           for (restart in restarts) {
[13:36:41.146]                             name <- restart$name
[13:36:41.146]                             if (is.null(name)) 
[13:36:41.146]                               next
[13:36:41.146]                             if (!grepl(pattern, name)) 
[13:36:41.146]                               next
[13:36:41.146]                             invokeRestart(restart)
[13:36:41.146]                             muffled <- TRUE
[13:36:41.146]                             break
[13:36:41.146]                           }
[13:36:41.146]                         }
[13:36:41.146]                       }
[13:36:41.146]                       invisible(muffled)
[13:36:41.146]                     }
[13:36:41.146]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.146]                   }
[13:36:41.146]                 }
[13:36:41.146]             }
[13:36:41.146]         }))
[13:36:41.146]     }, error = function(ex) {
[13:36:41.146]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:41.146]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.146]                 ...future.rng), started = ...future.startTime, 
[13:36:41.146]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:41.146]             version = "1.8"), class = "FutureResult")
[13:36:41.146]     }, finally = {
[13:36:41.146]         if (!identical(...future.workdir, getwd())) 
[13:36:41.146]             setwd(...future.workdir)
[13:36:41.146]         {
[13:36:41.146]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:41.146]                 ...future.oldOptions$nwarnings <- NULL
[13:36:41.146]             }
[13:36:41.146]             base::options(...future.oldOptions)
[13:36:41.146]             if (.Platform$OS.type == "windows") {
[13:36:41.146]                 old_names <- names(...future.oldEnvVars)
[13:36:41.146]                 envs <- base::Sys.getenv()
[13:36:41.146]                 names <- names(envs)
[13:36:41.146]                 common <- intersect(names, old_names)
[13:36:41.146]                 added <- setdiff(names, old_names)
[13:36:41.146]                 removed <- setdiff(old_names, names)
[13:36:41.146]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:41.146]                   envs[common]]
[13:36:41.146]                 NAMES <- toupper(changed)
[13:36:41.146]                 args <- list()
[13:36:41.146]                 for (kk in seq_along(NAMES)) {
[13:36:41.146]                   name <- changed[[kk]]
[13:36:41.146]                   NAME <- NAMES[[kk]]
[13:36:41.146]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.146]                     next
[13:36:41.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.146]                 }
[13:36:41.146]                 NAMES <- toupper(added)
[13:36:41.146]                 for (kk in seq_along(NAMES)) {
[13:36:41.146]                   name <- added[[kk]]
[13:36:41.146]                   NAME <- NAMES[[kk]]
[13:36:41.146]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.146]                     next
[13:36:41.146]                   args[[name]] <- ""
[13:36:41.146]                 }
[13:36:41.146]                 NAMES <- toupper(removed)
[13:36:41.146]                 for (kk in seq_along(NAMES)) {
[13:36:41.146]                   name <- removed[[kk]]
[13:36:41.146]                   NAME <- NAMES[[kk]]
[13:36:41.146]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.146]                     next
[13:36:41.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.146]                 }
[13:36:41.146]                 if (length(args) > 0) 
[13:36:41.146]                   base::do.call(base::Sys.setenv, args = args)
[13:36:41.146]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:41.146]             }
[13:36:41.146]             else {
[13:36:41.146]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:41.146]             }
[13:36:41.146]             {
[13:36:41.146]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:41.146]                   0L) {
[13:36:41.146]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:41.146]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:41.146]                   base::options(opts)
[13:36:41.146]                 }
[13:36:41.146]                 {
[13:36:41.146]                   {
[13:36:41.146]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:41.146]                     NULL
[13:36:41.146]                   }
[13:36:41.146]                   options(future.plan = NULL)
[13:36:41.146]                   if (is.na(NA_character_)) 
[13:36:41.146]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.146]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:41.146]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:41.146]                     .init = FALSE)
[13:36:41.146]                 }
[13:36:41.146]             }
[13:36:41.146]         }
[13:36:41.146]     })
[13:36:41.146]     if (TRUE) {
[13:36:41.146]         base::sink(type = "output", split = FALSE)
[13:36:41.146]         if (TRUE) {
[13:36:41.146]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:41.146]         }
[13:36:41.146]         else {
[13:36:41.146]             ...future.result["stdout"] <- base::list(NULL)
[13:36:41.146]         }
[13:36:41.146]         base::close(...future.stdout)
[13:36:41.146]         ...future.stdout <- NULL
[13:36:41.146]     }
[13:36:41.146]     ...future.result$conditions <- ...future.conditions
[13:36:41.146]     ...future.result$finished <- base::Sys.time()
[13:36:41.146]     ...future.result
[13:36:41.146] }
[13:36:41.148] assign_globals() ...
[13:36:41.148] List of 2
[13:36:41.148]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:36:41.148]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:36:41.148]  - attr(*, "where")=List of 2
[13:36:41.148]   ..$ weight:<environment: R_EmptyEnv> 
[13:36:41.148]   ..$ group :<environment: R_EmptyEnv> 
[13:36:41.148]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:41.148]  - attr(*, "resolved")= logi FALSE
[13:36:41.148]  - attr(*, "total_size")= num 896
[13:36:41.148]  - attr(*, "already-done")= logi TRUE
[13:36:41.152] - copied ‘weight’ to environment
[13:36:41.152] - copied ‘group’ to environment
[13:36:41.152] assign_globals() ... done
[13:36:41.153] requestCore(): workers = 2
[13:36:41.154] MulticoreFuture started
[13:36:41.155] - Launch lazy future ... done
[13:36:41.155] run() for ‘MulticoreFuture’ ... done
[13:36:41.155] result() for MulticoreFuture ...
[13:36:41.156] plan(): Setting new future strategy stack:
[13:36:41.156] List of future strategies:
[13:36:41.156] 1. sequential:
[13:36:41.156]    - args: function (..., envir = parent.frame())
[13:36:41.156]    - tweaked: FALSE
[13:36:41.156]    - call: NULL
[13:36:41.157] plan(): nbrOfWorkers() = 1
[13:36:41.160] plan(): Setting new future strategy stack:
[13:36:41.160] List of future strategies:
[13:36:41.160] 1. multicore:
[13:36:41.160]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:41.160]    - tweaked: FALSE
[13:36:41.160]    - call: plan(strategy)
[13:36:41.165] plan(): nbrOfWorkers() = 2
[13:36:41.168] result() for MulticoreFuture ...
[13:36:41.168] result() for MulticoreFuture ... done
[13:36:41.168] result() for MulticoreFuture ... done
[13:36:41.168] result() for MulticoreFuture ...
[13:36:41.168] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[13:36:41.171] getGlobalsAndPackages() ...
[13:36:41.171] Searching for globals...
[13:36:41.172] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[13:36:41.173] Searching for globals ... DONE
[13:36:41.173] Resolving globals: FALSE
[13:36:41.173] The total size of the 1 globals is 96 bytes (96 bytes)
[13:36:41.174] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[13:36:41.174] - globals: [1] ‘x’
[13:36:41.174] - packages: [1] ‘stats’
[13:36:41.174] getGlobalsAndPackages() ... DONE
[13:36:41.175] run() for ‘Future’ ...
[13:36:41.175] - state: ‘created’
[13:36:41.175] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:41.179] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:41.179] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:41.179]   - Field: ‘label’
[13:36:41.179]   - Field: ‘local’
[13:36:41.179]   - Field: ‘owner’
[13:36:41.179]   - Field: ‘envir’
[13:36:41.179]   - Field: ‘workers’
[13:36:41.180]   - Field: ‘packages’
[13:36:41.180]   - Field: ‘gc’
[13:36:41.180]   - Field: ‘job’
[13:36:41.180]   - Field: ‘conditions’
[13:36:41.180]   - Field: ‘expr’
[13:36:41.180]   - Field: ‘uuid’
[13:36:41.180]   - Field: ‘seed’
[13:36:41.180]   - Field: ‘version’
[13:36:41.180]   - Field: ‘result’
[13:36:41.181]   - Field: ‘asynchronous’
[13:36:41.181]   - Field: ‘calls’
[13:36:41.181]   - Field: ‘globals’
[13:36:41.181]   - Field: ‘stdout’
[13:36:41.181]   - Field: ‘earlySignal’
[13:36:41.181]   - Field: ‘lazy’
[13:36:41.181]   - Field: ‘state’
[13:36:41.181] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:41.181] - Launch lazy future ...
[13:36:41.182] Packages needed by the future expression (n = 1): ‘stats’
[13:36:41.182] Packages needed by future strategies (n = 0): <none>
[13:36:41.183] {
[13:36:41.183]     {
[13:36:41.183]         {
[13:36:41.183]             ...future.startTime <- base::Sys.time()
[13:36:41.183]             {
[13:36:41.183]                 {
[13:36:41.183]                   {
[13:36:41.183]                     {
[13:36:41.183]                       {
[13:36:41.183]                         base::local({
[13:36:41.183]                           has_future <- base::requireNamespace("future", 
[13:36:41.183]                             quietly = TRUE)
[13:36:41.183]                           if (has_future) {
[13:36:41.183]                             ns <- base::getNamespace("future")
[13:36:41.183]                             version <- ns[[".package"]][["version"]]
[13:36:41.183]                             if (is.null(version)) 
[13:36:41.183]                               version <- utils::packageVersion("future")
[13:36:41.183]                           }
[13:36:41.183]                           else {
[13:36:41.183]                             version <- NULL
[13:36:41.183]                           }
[13:36:41.183]                           if (!has_future || version < "1.8.0") {
[13:36:41.183]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:41.183]                               "", base::R.version$version.string), 
[13:36:41.183]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:41.183]                                 base::R.version$platform, 8 * 
[13:36:41.183]                                   base::.Machine$sizeof.pointer), 
[13:36:41.183]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:41.183]                                 "release", "version")], collapse = " "), 
[13:36:41.183]                               hostname = base::Sys.info()[["nodename"]])
[13:36:41.183]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:41.183]                               info)
[13:36:41.183]                             info <- base::paste(info, collapse = "; ")
[13:36:41.183]                             if (!has_future) {
[13:36:41.183]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:41.183]                                 info)
[13:36:41.183]                             }
[13:36:41.183]                             else {
[13:36:41.183]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:41.183]                                 info, version)
[13:36:41.183]                             }
[13:36:41.183]                             base::stop(msg)
[13:36:41.183]                           }
[13:36:41.183]                         })
[13:36:41.183]                       }
[13:36:41.183]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:41.183]                       base::options(mc.cores = 1L)
[13:36:41.183]                     }
[13:36:41.183]                     base::local({
[13:36:41.183]                       for (pkg in "stats") {
[13:36:41.183]                         base::loadNamespace(pkg)
[13:36:41.183]                         base::library(pkg, character.only = TRUE)
[13:36:41.183]                       }
[13:36:41.183]                     })
[13:36:41.183]                   }
[13:36:41.183]                   ...future.strategy.old <- future::plan("list")
[13:36:41.183]                   options(future.plan = NULL)
[13:36:41.183]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.183]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:41.183]                 }
[13:36:41.183]                 ...future.workdir <- getwd()
[13:36:41.183]             }
[13:36:41.183]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:41.183]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:41.183]         }
[13:36:41.183]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:41.183]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:41.183]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:41.183]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:41.183]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:41.183]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:41.183]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:41.183]             base::names(...future.oldOptions))
[13:36:41.183]     }
[13:36:41.183]     if (FALSE) {
[13:36:41.183]     }
[13:36:41.183]     else {
[13:36:41.183]         if (TRUE) {
[13:36:41.183]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:41.183]                 open = "w")
[13:36:41.183]         }
[13:36:41.183]         else {
[13:36:41.183]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:41.183]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:41.183]         }
[13:36:41.183]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:41.183]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:41.183]             base::sink(type = "output", split = FALSE)
[13:36:41.183]             base::close(...future.stdout)
[13:36:41.183]         }, add = TRUE)
[13:36:41.183]     }
[13:36:41.183]     ...future.frame <- base::sys.nframe()
[13:36:41.183]     ...future.conditions <- base::list()
[13:36:41.183]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:41.183]     if (FALSE) {
[13:36:41.183]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:41.183]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:41.183]     }
[13:36:41.183]     ...future.result <- base::tryCatch({
[13:36:41.183]         base::withCallingHandlers({
[13:36:41.183]             ...future.value <- base::withVisible(base::local({
[13:36:41.183]                 withCallingHandlers({
[13:36:41.183]                   {
[13:36:41.183]                     xtabs(~x)
[13:36:41.183]                   }
[13:36:41.183]                 }, immediateCondition = function(cond) {
[13:36:41.183]                   save_rds <- function (object, pathname, ...) 
[13:36:41.183]                   {
[13:36:41.183]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:41.183]                     if (file_test("-f", pathname_tmp)) {
[13:36:41.183]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.183]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:41.183]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.183]                         fi_tmp[["mtime"]])
[13:36:41.183]                     }
[13:36:41.183]                     tryCatch({
[13:36:41.183]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:41.183]                     }, error = function(ex) {
[13:36:41.183]                       msg <- conditionMessage(ex)
[13:36:41.183]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.183]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:41.183]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.183]                         fi_tmp[["mtime"]], msg)
[13:36:41.183]                       ex$message <- msg
[13:36:41.183]                       stop(ex)
[13:36:41.183]                     })
[13:36:41.183]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:41.183]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:41.183]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:41.183]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.183]                       fi <- file.info(pathname)
[13:36:41.183]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:41.183]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.183]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:41.183]                         fi[["size"]], fi[["mtime"]])
[13:36:41.183]                       stop(msg)
[13:36:41.183]                     }
[13:36:41.183]                     invisible(pathname)
[13:36:41.183]                   }
[13:36:41.183]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:41.183]                     rootPath = tempdir()) 
[13:36:41.183]                   {
[13:36:41.183]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:41.183]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:41.183]                       tmpdir = path, fileext = ".rds")
[13:36:41.183]                     save_rds(obj, file)
[13:36:41.183]                   }
[13:36:41.183]                   saveImmediateCondition(cond, path = "/tmp/RtmphVqFyZ/.future/immediateConditions")
[13:36:41.183]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.183]                   {
[13:36:41.183]                     inherits <- base::inherits
[13:36:41.183]                     invokeRestart <- base::invokeRestart
[13:36:41.183]                     is.null <- base::is.null
[13:36:41.183]                     muffled <- FALSE
[13:36:41.183]                     if (inherits(cond, "message")) {
[13:36:41.183]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:41.183]                       if (muffled) 
[13:36:41.183]                         invokeRestart("muffleMessage")
[13:36:41.183]                     }
[13:36:41.183]                     else if (inherits(cond, "warning")) {
[13:36:41.183]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:41.183]                       if (muffled) 
[13:36:41.183]                         invokeRestart("muffleWarning")
[13:36:41.183]                     }
[13:36:41.183]                     else if (inherits(cond, "condition")) {
[13:36:41.183]                       if (!is.null(pattern)) {
[13:36:41.183]                         computeRestarts <- base::computeRestarts
[13:36:41.183]                         grepl <- base::grepl
[13:36:41.183]                         restarts <- computeRestarts(cond)
[13:36:41.183]                         for (restart in restarts) {
[13:36:41.183]                           name <- restart$name
[13:36:41.183]                           if (is.null(name)) 
[13:36:41.183]                             next
[13:36:41.183]                           if (!grepl(pattern, name)) 
[13:36:41.183]                             next
[13:36:41.183]                           invokeRestart(restart)
[13:36:41.183]                           muffled <- TRUE
[13:36:41.183]                           break
[13:36:41.183]                         }
[13:36:41.183]                       }
[13:36:41.183]                     }
[13:36:41.183]                     invisible(muffled)
[13:36:41.183]                   }
[13:36:41.183]                   muffleCondition(cond)
[13:36:41.183]                 })
[13:36:41.183]             }))
[13:36:41.183]             future::FutureResult(value = ...future.value$value, 
[13:36:41.183]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.183]                   ...future.rng), globalenv = if (FALSE) 
[13:36:41.183]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:41.183]                     ...future.globalenv.names))
[13:36:41.183]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:41.183]         }, condition = base::local({
[13:36:41.183]             c <- base::c
[13:36:41.183]             inherits <- base::inherits
[13:36:41.183]             invokeRestart <- base::invokeRestart
[13:36:41.183]             length <- base::length
[13:36:41.183]             list <- base::list
[13:36:41.183]             seq.int <- base::seq.int
[13:36:41.183]             signalCondition <- base::signalCondition
[13:36:41.183]             sys.calls <- base::sys.calls
[13:36:41.183]             `[[` <- base::`[[`
[13:36:41.183]             `+` <- base::`+`
[13:36:41.183]             `<<-` <- base::`<<-`
[13:36:41.183]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:41.183]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:41.183]                   3L)]
[13:36:41.183]             }
[13:36:41.183]             function(cond) {
[13:36:41.183]                 is_error <- inherits(cond, "error")
[13:36:41.183]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:41.183]                   NULL)
[13:36:41.183]                 if (is_error) {
[13:36:41.183]                   sessionInformation <- function() {
[13:36:41.183]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:41.183]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:41.183]                       search = base::search(), system = base::Sys.info())
[13:36:41.183]                   }
[13:36:41.183]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.183]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:41.183]                     cond$call), session = sessionInformation(), 
[13:36:41.183]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:41.183]                   signalCondition(cond)
[13:36:41.183]                 }
[13:36:41.183]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:41.183]                 "immediateCondition"))) {
[13:36:41.183]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:41.183]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.183]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:41.183]                   if (TRUE && !signal) {
[13:36:41.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.183]                     {
[13:36:41.183]                       inherits <- base::inherits
[13:36:41.183]                       invokeRestart <- base::invokeRestart
[13:36:41.183]                       is.null <- base::is.null
[13:36:41.183]                       muffled <- FALSE
[13:36:41.183]                       if (inherits(cond, "message")) {
[13:36:41.183]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.183]                         if (muffled) 
[13:36:41.183]                           invokeRestart("muffleMessage")
[13:36:41.183]                       }
[13:36:41.183]                       else if (inherits(cond, "warning")) {
[13:36:41.183]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.183]                         if (muffled) 
[13:36:41.183]                           invokeRestart("muffleWarning")
[13:36:41.183]                       }
[13:36:41.183]                       else if (inherits(cond, "condition")) {
[13:36:41.183]                         if (!is.null(pattern)) {
[13:36:41.183]                           computeRestarts <- base::computeRestarts
[13:36:41.183]                           grepl <- base::grepl
[13:36:41.183]                           restarts <- computeRestarts(cond)
[13:36:41.183]                           for (restart in restarts) {
[13:36:41.183]                             name <- restart$name
[13:36:41.183]                             if (is.null(name)) 
[13:36:41.183]                               next
[13:36:41.183]                             if (!grepl(pattern, name)) 
[13:36:41.183]                               next
[13:36:41.183]                             invokeRestart(restart)
[13:36:41.183]                             muffled <- TRUE
[13:36:41.183]                             break
[13:36:41.183]                           }
[13:36:41.183]                         }
[13:36:41.183]                       }
[13:36:41.183]                       invisible(muffled)
[13:36:41.183]                     }
[13:36:41.183]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.183]                   }
[13:36:41.183]                 }
[13:36:41.183]                 else {
[13:36:41.183]                   if (TRUE) {
[13:36:41.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.183]                     {
[13:36:41.183]                       inherits <- base::inherits
[13:36:41.183]                       invokeRestart <- base::invokeRestart
[13:36:41.183]                       is.null <- base::is.null
[13:36:41.183]                       muffled <- FALSE
[13:36:41.183]                       if (inherits(cond, "message")) {
[13:36:41.183]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.183]                         if (muffled) 
[13:36:41.183]                           invokeRestart("muffleMessage")
[13:36:41.183]                       }
[13:36:41.183]                       else if (inherits(cond, "warning")) {
[13:36:41.183]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.183]                         if (muffled) 
[13:36:41.183]                           invokeRestart("muffleWarning")
[13:36:41.183]                       }
[13:36:41.183]                       else if (inherits(cond, "condition")) {
[13:36:41.183]                         if (!is.null(pattern)) {
[13:36:41.183]                           computeRestarts <- base::computeRestarts
[13:36:41.183]                           grepl <- base::grepl
[13:36:41.183]                           restarts <- computeRestarts(cond)
[13:36:41.183]                           for (restart in restarts) {
[13:36:41.183]                             name <- restart$name
[13:36:41.183]                             if (is.null(name)) 
[13:36:41.183]                               next
[13:36:41.183]                             if (!grepl(pattern, name)) 
[13:36:41.183]                               next
[13:36:41.183]                             invokeRestart(restart)
[13:36:41.183]                             muffled <- TRUE
[13:36:41.183]                             break
[13:36:41.183]                           }
[13:36:41.183]                         }
[13:36:41.183]                       }
[13:36:41.183]                       invisible(muffled)
[13:36:41.183]                     }
[13:36:41.183]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.183]                   }
[13:36:41.183]                 }
[13:36:41.183]             }
[13:36:41.183]         }))
[13:36:41.183]     }, error = function(ex) {
[13:36:41.183]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:41.183]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.183]                 ...future.rng), started = ...future.startTime, 
[13:36:41.183]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:41.183]             version = "1.8"), class = "FutureResult")
[13:36:41.183]     }, finally = {
[13:36:41.183]         if (!identical(...future.workdir, getwd())) 
[13:36:41.183]             setwd(...future.workdir)
[13:36:41.183]         {
[13:36:41.183]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:41.183]                 ...future.oldOptions$nwarnings <- NULL
[13:36:41.183]             }
[13:36:41.183]             base::options(...future.oldOptions)
[13:36:41.183]             if (.Platform$OS.type == "windows") {
[13:36:41.183]                 old_names <- names(...future.oldEnvVars)
[13:36:41.183]                 envs <- base::Sys.getenv()
[13:36:41.183]                 names <- names(envs)
[13:36:41.183]                 common <- intersect(names, old_names)
[13:36:41.183]                 added <- setdiff(names, old_names)
[13:36:41.183]                 removed <- setdiff(old_names, names)
[13:36:41.183]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:41.183]                   envs[common]]
[13:36:41.183]                 NAMES <- toupper(changed)
[13:36:41.183]                 args <- list()
[13:36:41.183]                 for (kk in seq_along(NAMES)) {
[13:36:41.183]                   name <- changed[[kk]]
[13:36:41.183]                   NAME <- NAMES[[kk]]
[13:36:41.183]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.183]                     next
[13:36:41.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.183]                 }
[13:36:41.183]                 NAMES <- toupper(added)
[13:36:41.183]                 for (kk in seq_along(NAMES)) {
[13:36:41.183]                   name <- added[[kk]]
[13:36:41.183]                   NAME <- NAMES[[kk]]
[13:36:41.183]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.183]                     next
[13:36:41.183]                   args[[name]] <- ""
[13:36:41.183]                 }
[13:36:41.183]                 NAMES <- toupper(removed)
[13:36:41.183]                 for (kk in seq_along(NAMES)) {
[13:36:41.183]                   name <- removed[[kk]]
[13:36:41.183]                   NAME <- NAMES[[kk]]
[13:36:41.183]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.183]                     next
[13:36:41.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.183]                 }
[13:36:41.183]                 if (length(args) > 0) 
[13:36:41.183]                   base::do.call(base::Sys.setenv, args = args)
[13:36:41.183]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:41.183]             }
[13:36:41.183]             else {
[13:36:41.183]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:41.183]             }
[13:36:41.183]             {
[13:36:41.183]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:41.183]                   0L) {
[13:36:41.183]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:41.183]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:41.183]                   base::options(opts)
[13:36:41.183]                 }
[13:36:41.183]                 {
[13:36:41.183]                   {
[13:36:41.183]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:41.183]                     NULL
[13:36:41.183]                   }
[13:36:41.183]                   options(future.plan = NULL)
[13:36:41.183]                   if (is.na(NA_character_)) 
[13:36:41.183]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.183]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:41.183]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:41.183]                     .init = FALSE)
[13:36:41.183]                 }
[13:36:41.183]             }
[13:36:41.183]         }
[13:36:41.183]     })
[13:36:41.183]     if (TRUE) {
[13:36:41.183]         base::sink(type = "output", split = FALSE)
[13:36:41.183]         if (TRUE) {
[13:36:41.183]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:41.183]         }
[13:36:41.183]         else {
[13:36:41.183]             ...future.result["stdout"] <- base::list(NULL)
[13:36:41.183]         }
[13:36:41.183]         base::close(...future.stdout)
[13:36:41.183]         ...future.stdout <- NULL
[13:36:41.183]     }
[13:36:41.183]     ...future.result$conditions <- ...future.conditions
[13:36:41.183]     ...future.result$finished <- base::Sys.time()
[13:36:41.183]     ...future.result
[13:36:41.183] }
[13:36:41.185] assign_globals() ...
[13:36:41.185] List of 1
[13:36:41.185]  $ x: num [1:5] 1 1 2 2 2
[13:36:41.185]  - attr(*, "where")=List of 1
[13:36:41.185]   ..$ x:<environment: R_EmptyEnv> 
[13:36:41.185]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:41.185]  - attr(*, "resolved")= logi FALSE
[13:36:41.185]  - attr(*, "total_size")= num 96
[13:36:41.185]  - attr(*, "already-done")= logi TRUE
[13:36:41.191] - copied ‘x’ to environment
[13:36:41.191] assign_globals() ... done
[13:36:41.191] requestCore(): workers = 2
[13:36:41.193] MulticoreFuture started
[13:36:41.193] - Launch lazy future ... done
[13:36:41.194] run() for ‘MulticoreFuture’ ... done
[13:36:41.194] result() for MulticoreFuture ...
[13:36:41.195] plan(): Setting new future strategy stack:
[13:36:41.195] List of future strategies:
[13:36:41.195] 1. sequential:
[13:36:41.195]    - args: function (..., envir = parent.frame())
[13:36:41.195]    - tweaked: FALSE
[13:36:41.195]    - call: NULL
[13:36:41.196] plan(): nbrOfWorkers() = 1
[13:36:41.199] plan(): Setting new future strategy stack:
[13:36:41.199] List of future strategies:
[13:36:41.199] 1. multicore:
[13:36:41.199]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:41.199]    - tweaked: FALSE
[13:36:41.199]    - call: plan(strategy)
[13:36:41.204] plan(): nbrOfWorkers() = 2
[13:36:41.205] result() for MulticoreFuture ...
[13:36:41.205] result() for MulticoreFuture ... done
[13:36:41.205] result() for MulticoreFuture ... done
[13:36:41.206] result() for MulticoreFuture ...
[13:36:41.206] result() for MulticoreFuture ... done
x
1 2 
2 3 
[13:36:41.207] getGlobalsAndPackages() ...
[13:36:41.207] Searching for globals...
[13:36:41.209] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[13:36:41.209] Searching for globals ... DONE
[13:36:41.209] Resolving globals: FALSE
[13:36:41.209] The total size of the 1 globals is 96 bytes (96 bytes)
[13:36:41.210] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[13:36:41.210] - globals: [1] ‘x’
[13:36:41.210] - packages: [1] ‘stats’
[13:36:41.210] getGlobalsAndPackages() ... DONE
[13:36:41.211] run() for ‘Future’ ...
[13:36:41.211] - state: ‘created’
[13:36:41.211] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:41.215] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:41.215] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:41.215]   - Field: ‘label’
[13:36:41.215]   - Field: ‘local’
[13:36:41.215]   - Field: ‘owner’
[13:36:41.216]   - Field: ‘envir’
[13:36:41.216]   - Field: ‘workers’
[13:36:41.216]   - Field: ‘packages’
[13:36:41.216]   - Field: ‘gc’
[13:36:41.216]   - Field: ‘job’
[13:36:41.216]   - Field: ‘conditions’
[13:36:41.216]   - Field: ‘expr’
[13:36:41.216]   - Field: ‘uuid’
[13:36:41.216]   - Field: ‘seed’
[13:36:41.217]   - Field: ‘version’
[13:36:41.217]   - Field: ‘result’
[13:36:41.217]   - Field: ‘asynchronous’
[13:36:41.217]   - Field: ‘calls’
[13:36:41.217]   - Field: ‘globals’
[13:36:41.217]   - Field: ‘stdout’
[13:36:41.217]   - Field: ‘earlySignal’
[13:36:41.217]   - Field: ‘lazy’
[13:36:41.217]   - Field: ‘state’
[13:36:41.218] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:41.218] - Launch lazy future ...
[13:36:41.218] Packages needed by the future expression (n = 1): ‘stats’
[13:36:41.218] Packages needed by future strategies (n = 0): <none>
[13:36:41.219] {
[13:36:41.219]     {
[13:36:41.219]         {
[13:36:41.219]             ...future.startTime <- base::Sys.time()
[13:36:41.219]             {
[13:36:41.219]                 {
[13:36:41.219]                   {
[13:36:41.219]                     {
[13:36:41.219]                       {
[13:36:41.219]                         base::local({
[13:36:41.219]                           has_future <- base::requireNamespace("future", 
[13:36:41.219]                             quietly = TRUE)
[13:36:41.219]                           if (has_future) {
[13:36:41.219]                             ns <- base::getNamespace("future")
[13:36:41.219]                             version <- ns[[".package"]][["version"]]
[13:36:41.219]                             if (is.null(version)) 
[13:36:41.219]                               version <- utils::packageVersion("future")
[13:36:41.219]                           }
[13:36:41.219]                           else {
[13:36:41.219]                             version <- NULL
[13:36:41.219]                           }
[13:36:41.219]                           if (!has_future || version < "1.8.0") {
[13:36:41.219]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:41.219]                               "", base::R.version$version.string), 
[13:36:41.219]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:41.219]                                 base::R.version$platform, 8 * 
[13:36:41.219]                                   base::.Machine$sizeof.pointer), 
[13:36:41.219]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:41.219]                                 "release", "version")], collapse = " "), 
[13:36:41.219]                               hostname = base::Sys.info()[["nodename"]])
[13:36:41.219]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:41.219]                               info)
[13:36:41.219]                             info <- base::paste(info, collapse = "; ")
[13:36:41.219]                             if (!has_future) {
[13:36:41.219]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:41.219]                                 info)
[13:36:41.219]                             }
[13:36:41.219]                             else {
[13:36:41.219]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:41.219]                                 info, version)
[13:36:41.219]                             }
[13:36:41.219]                             base::stop(msg)
[13:36:41.219]                           }
[13:36:41.219]                         })
[13:36:41.219]                       }
[13:36:41.219]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:41.219]                       base::options(mc.cores = 1L)
[13:36:41.219]                     }
[13:36:41.219]                     base::local({
[13:36:41.219]                       for (pkg in "stats") {
[13:36:41.219]                         base::loadNamespace(pkg)
[13:36:41.219]                         base::library(pkg, character.only = TRUE)
[13:36:41.219]                       }
[13:36:41.219]                     })
[13:36:41.219]                   }
[13:36:41.219]                   ...future.strategy.old <- future::plan("list")
[13:36:41.219]                   options(future.plan = NULL)
[13:36:41.219]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.219]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:41.219]                 }
[13:36:41.219]                 ...future.workdir <- getwd()
[13:36:41.219]             }
[13:36:41.219]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:41.219]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:41.219]         }
[13:36:41.219]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:41.219]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:41.219]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:41.219]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:41.219]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:41.219]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:41.219]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:41.219]             base::names(...future.oldOptions))
[13:36:41.219]     }
[13:36:41.219]     if (FALSE) {
[13:36:41.219]     }
[13:36:41.219]     else {
[13:36:41.219]         if (TRUE) {
[13:36:41.219]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:41.219]                 open = "w")
[13:36:41.219]         }
[13:36:41.219]         else {
[13:36:41.219]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:41.219]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:41.219]         }
[13:36:41.219]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:41.219]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:41.219]             base::sink(type = "output", split = FALSE)
[13:36:41.219]             base::close(...future.stdout)
[13:36:41.219]         }, add = TRUE)
[13:36:41.219]     }
[13:36:41.219]     ...future.frame <- base::sys.nframe()
[13:36:41.219]     ...future.conditions <- base::list()
[13:36:41.219]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:41.219]     if (FALSE) {
[13:36:41.219]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:41.219]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:41.219]     }
[13:36:41.219]     ...future.result <- base::tryCatch({
[13:36:41.219]         base::withCallingHandlers({
[13:36:41.219]             ...future.value <- base::withVisible(base::local({
[13:36:41.219]                 withCallingHandlers({
[13:36:41.219]                   {
[13:36:41.219]                     xtabs(~x)
[13:36:41.219]                   }
[13:36:41.219]                 }, immediateCondition = function(cond) {
[13:36:41.219]                   save_rds <- function (object, pathname, ...) 
[13:36:41.219]                   {
[13:36:41.219]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:41.219]                     if (file_test("-f", pathname_tmp)) {
[13:36:41.219]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.219]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:41.219]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.219]                         fi_tmp[["mtime"]])
[13:36:41.219]                     }
[13:36:41.219]                     tryCatch({
[13:36:41.219]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:41.219]                     }, error = function(ex) {
[13:36:41.219]                       msg <- conditionMessage(ex)
[13:36:41.219]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.219]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:41.219]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.219]                         fi_tmp[["mtime"]], msg)
[13:36:41.219]                       ex$message <- msg
[13:36:41.219]                       stop(ex)
[13:36:41.219]                     })
[13:36:41.219]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:41.219]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:41.219]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:41.219]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.219]                       fi <- file.info(pathname)
[13:36:41.219]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:41.219]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.219]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:41.219]                         fi[["size"]], fi[["mtime"]])
[13:36:41.219]                       stop(msg)
[13:36:41.219]                     }
[13:36:41.219]                     invisible(pathname)
[13:36:41.219]                   }
[13:36:41.219]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:41.219]                     rootPath = tempdir()) 
[13:36:41.219]                   {
[13:36:41.219]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:41.219]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:41.219]                       tmpdir = path, fileext = ".rds")
[13:36:41.219]                     save_rds(obj, file)
[13:36:41.219]                   }
[13:36:41.219]                   saveImmediateCondition(cond, path = "/tmp/RtmphVqFyZ/.future/immediateConditions")
[13:36:41.219]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.219]                   {
[13:36:41.219]                     inherits <- base::inherits
[13:36:41.219]                     invokeRestart <- base::invokeRestart
[13:36:41.219]                     is.null <- base::is.null
[13:36:41.219]                     muffled <- FALSE
[13:36:41.219]                     if (inherits(cond, "message")) {
[13:36:41.219]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:41.219]                       if (muffled) 
[13:36:41.219]                         invokeRestart("muffleMessage")
[13:36:41.219]                     }
[13:36:41.219]                     else if (inherits(cond, "warning")) {
[13:36:41.219]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:41.219]                       if (muffled) 
[13:36:41.219]                         invokeRestart("muffleWarning")
[13:36:41.219]                     }
[13:36:41.219]                     else if (inherits(cond, "condition")) {
[13:36:41.219]                       if (!is.null(pattern)) {
[13:36:41.219]                         computeRestarts <- base::computeRestarts
[13:36:41.219]                         grepl <- base::grepl
[13:36:41.219]                         restarts <- computeRestarts(cond)
[13:36:41.219]                         for (restart in restarts) {
[13:36:41.219]                           name <- restart$name
[13:36:41.219]                           if (is.null(name)) 
[13:36:41.219]                             next
[13:36:41.219]                           if (!grepl(pattern, name)) 
[13:36:41.219]                             next
[13:36:41.219]                           invokeRestart(restart)
[13:36:41.219]                           muffled <- TRUE
[13:36:41.219]                           break
[13:36:41.219]                         }
[13:36:41.219]                       }
[13:36:41.219]                     }
[13:36:41.219]                     invisible(muffled)
[13:36:41.219]                   }
[13:36:41.219]                   muffleCondition(cond)
[13:36:41.219]                 })
[13:36:41.219]             }))
[13:36:41.219]             future::FutureResult(value = ...future.value$value, 
[13:36:41.219]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.219]                   ...future.rng), globalenv = if (FALSE) 
[13:36:41.219]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:41.219]                     ...future.globalenv.names))
[13:36:41.219]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:41.219]         }, condition = base::local({
[13:36:41.219]             c <- base::c
[13:36:41.219]             inherits <- base::inherits
[13:36:41.219]             invokeRestart <- base::invokeRestart
[13:36:41.219]             length <- base::length
[13:36:41.219]             list <- base::list
[13:36:41.219]             seq.int <- base::seq.int
[13:36:41.219]             signalCondition <- base::signalCondition
[13:36:41.219]             sys.calls <- base::sys.calls
[13:36:41.219]             `[[` <- base::`[[`
[13:36:41.219]             `+` <- base::`+`
[13:36:41.219]             `<<-` <- base::`<<-`
[13:36:41.219]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:41.219]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:41.219]                   3L)]
[13:36:41.219]             }
[13:36:41.219]             function(cond) {
[13:36:41.219]                 is_error <- inherits(cond, "error")
[13:36:41.219]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:41.219]                   NULL)
[13:36:41.219]                 if (is_error) {
[13:36:41.219]                   sessionInformation <- function() {
[13:36:41.219]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:41.219]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:41.219]                       search = base::search(), system = base::Sys.info())
[13:36:41.219]                   }
[13:36:41.219]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.219]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:41.219]                     cond$call), session = sessionInformation(), 
[13:36:41.219]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:41.219]                   signalCondition(cond)
[13:36:41.219]                 }
[13:36:41.219]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:41.219]                 "immediateCondition"))) {
[13:36:41.219]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:41.219]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.219]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:41.219]                   if (TRUE && !signal) {
[13:36:41.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.219]                     {
[13:36:41.219]                       inherits <- base::inherits
[13:36:41.219]                       invokeRestart <- base::invokeRestart
[13:36:41.219]                       is.null <- base::is.null
[13:36:41.219]                       muffled <- FALSE
[13:36:41.219]                       if (inherits(cond, "message")) {
[13:36:41.219]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.219]                         if (muffled) 
[13:36:41.219]                           invokeRestart("muffleMessage")
[13:36:41.219]                       }
[13:36:41.219]                       else if (inherits(cond, "warning")) {
[13:36:41.219]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.219]                         if (muffled) 
[13:36:41.219]                           invokeRestart("muffleWarning")
[13:36:41.219]                       }
[13:36:41.219]                       else if (inherits(cond, "condition")) {
[13:36:41.219]                         if (!is.null(pattern)) {
[13:36:41.219]                           computeRestarts <- base::computeRestarts
[13:36:41.219]                           grepl <- base::grepl
[13:36:41.219]                           restarts <- computeRestarts(cond)
[13:36:41.219]                           for (restart in restarts) {
[13:36:41.219]                             name <- restart$name
[13:36:41.219]                             if (is.null(name)) 
[13:36:41.219]                               next
[13:36:41.219]                             if (!grepl(pattern, name)) 
[13:36:41.219]                               next
[13:36:41.219]                             invokeRestart(restart)
[13:36:41.219]                             muffled <- TRUE
[13:36:41.219]                             break
[13:36:41.219]                           }
[13:36:41.219]                         }
[13:36:41.219]                       }
[13:36:41.219]                       invisible(muffled)
[13:36:41.219]                     }
[13:36:41.219]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.219]                   }
[13:36:41.219]                 }
[13:36:41.219]                 else {
[13:36:41.219]                   if (TRUE) {
[13:36:41.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.219]                     {
[13:36:41.219]                       inherits <- base::inherits
[13:36:41.219]                       invokeRestart <- base::invokeRestart
[13:36:41.219]                       is.null <- base::is.null
[13:36:41.219]                       muffled <- FALSE
[13:36:41.219]                       if (inherits(cond, "message")) {
[13:36:41.219]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.219]                         if (muffled) 
[13:36:41.219]                           invokeRestart("muffleMessage")
[13:36:41.219]                       }
[13:36:41.219]                       else if (inherits(cond, "warning")) {
[13:36:41.219]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.219]                         if (muffled) 
[13:36:41.219]                           invokeRestart("muffleWarning")
[13:36:41.219]                       }
[13:36:41.219]                       else if (inherits(cond, "condition")) {
[13:36:41.219]                         if (!is.null(pattern)) {
[13:36:41.219]                           computeRestarts <- base::computeRestarts
[13:36:41.219]                           grepl <- base::grepl
[13:36:41.219]                           restarts <- computeRestarts(cond)
[13:36:41.219]                           for (restart in restarts) {
[13:36:41.219]                             name <- restart$name
[13:36:41.219]                             if (is.null(name)) 
[13:36:41.219]                               next
[13:36:41.219]                             if (!grepl(pattern, name)) 
[13:36:41.219]                               next
[13:36:41.219]                             invokeRestart(restart)
[13:36:41.219]                             muffled <- TRUE
[13:36:41.219]                             break
[13:36:41.219]                           }
[13:36:41.219]                         }
[13:36:41.219]                       }
[13:36:41.219]                       invisible(muffled)
[13:36:41.219]                     }
[13:36:41.219]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.219]                   }
[13:36:41.219]                 }
[13:36:41.219]             }
[13:36:41.219]         }))
[13:36:41.219]     }, error = function(ex) {
[13:36:41.219]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:41.219]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.219]                 ...future.rng), started = ...future.startTime, 
[13:36:41.219]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:41.219]             version = "1.8"), class = "FutureResult")
[13:36:41.219]     }, finally = {
[13:36:41.219]         if (!identical(...future.workdir, getwd())) 
[13:36:41.219]             setwd(...future.workdir)
[13:36:41.219]         {
[13:36:41.219]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:41.219]                 ...future.oldOptions$nwarnings <- NULL
[13:36:41.219]             }
[13:36:41.219]             base::options(...future.oldOptions)
[13:36:41.219]             if (.Platform$OS.type == "windows") {
[13:36:41.219]                 old_names <- names(...future.oldEnvVars)
[13:36:41.219]                 envs <- base::Sys.getenv()
[13:36:41.219]                 names <- names(envs)
[13:36:41.219]                 common <- intersect(names, old_names)
[13:36:41.219]                 added <- setdiff(names, old_names)
[13:36:41.219]                 removed <- setdiff(old_names, names)
[13:36:41.219]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:41.219]                   envs[common]]
[13:36:41.219]                 NAMES <- toupper(changed)
[13:36:41.219]                 args <- list()
[13:36:41.219]                 for (kk in seq_along(NAMES)) {
[13:36:41.219]                   name <- changed[[kk]]
[13:36:41.219]                   NAME <- NAMES[[kk]]
[13:36:41.219]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.219]                     next
[13:36:41.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.219]                 }
[13:36:41.219]                 NAMES <- toupper(added)
[13:36:41.219]                 for (kk in seq_along(NAMES)) {
[13:36:41.219]                   name <- added[[kk]]
[13:36:41.219]                   NAME <- NAMES[[kk]]
[13:36:41.219]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.219]                     next
[13:36:41.219]                   args[[name]] <- ""
[13:36:41.219]                 }
[13:36:41.219]                 NAMES <- toupper(removed)
[13:36:41.219]                 for (kk in seq_along(NAMES)) {
[13:36:41.219]                   name <- removed[[kk]]
[13:36:41.219]                   NAME <- NAMES[[kk]]
[13:36:41.219]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.219]                     next
[13:36:41.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.219]                 }
[13:36:41.219]                 if (length(args) > 0) 
[13:36:41.219]                   base::do.call(base::Sys.setenv, args = args)
[13:36:41.219]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:41.219]             }
[13:36:41.219]             else {
[13:36:41.219]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:41.219]             }
[13:36:41.219]             {
[13:36:41.219]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:41.219]                   0L) {
[13:36:41.219]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:41.219]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:41.219]                   base::options(opts)
[13:36:41.219]                 }
[13:36:41.219]                 {
[13:36:41.219]                   {
[13:36:41.219]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:41.219]                     NULL
[13:36:41.219]                   }
[13:36:41.219]                   options(future.plan = NULL)
[13:36:41.219]                   if (is.na(NA_character_)) 
[13:36:41.219]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.219]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:41.219]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:41.219]                     .init = FALSE)
[13:36:41.219]                 }
[13:36:41.219]             }
[13:36:41.219]         }
[13:36:41.219]     })
[13:36:41.219]     if (TRUE) {
[13:36:41.219]         base::sink(type = "output", split = FALSE)
[13:36:41.219]         if (TRUE) {
[13:36:41.219]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:41.219]         }
[13:36:41.219]         else {
[13:36:41.219]             ...future.result["stdout"] <- base::list(NULL)
[13:36:41.219]         }
[13:36:41.219]         base::close(...future.stdout)
[13:36:41.219]         ...future.stdout <- NULL
[13:36:41.219]     }
[13:36:41.219]     ...future.result$conditions <- ...future.conditions
[13:36:41.219]     ...future.result$finished <- base::Sys.time()
[13:36:41.219]     ...future.result
[13:36:41.219] }
[13:36:41.221] assign_globals() ...
[13:36:41.221] List of 1
[13:36:41.221]  $ x: num [1:5] 1 1 2 2 2
[13:36:41.221]  - attr(*, "where")=List of 1
[13:36:41.221]   ..$ x:<environment: R_EmptyEnv> 
[13:36:41.221]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:41.221]  - attr(*, "resolved")= logi FALSE
[13:36:41.221]  - attr(*, "total_size")= num 96
[13:36:41.221]  - attr(*, "already-done")= logi TRUE
[13:36:41.224] - copied ‘x’ to environment
[13:36:41.224] assign_globals() ... done
[13:36:41.225] requestCore(): workers = 2
[13:36:41.226] MulticoreFuture started
[13:36:41.227] - Launch lazy future ... done
[13:36:41.227] run() for ‘MulticoreFuture’ ... done
[13:36:41.227] result() for MulticoreFuture ...
[13:36:41.228] plan(): Setting new future strategy stack:
[13:36:41.228] List of future strategies:
[13:36:41.228] 1. sequential:
[13:36:41.228]    - args: function (..., envir = parent.frame())
[13:36:41.228]    - tweaked: FALSE
[13:36:41.228]    - call: NULL
[13:36:41.229] plan(): nbrOfWorkers() = 1
[13:36:41.232] plan(): Setting new future strategy stack:
[13:36:41.232] List of future strategies:
[13:36:41.232] 1. multicore:
[13:36:41.232]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:41.232]    - tweaked: FALSE
[13:36:41.232]    - call: plan(strategy)
[13:36:41.240] plan(): nbrOfWorkers() = 2
[13:36:41.241] result() for MulticoreFuture ...
[13:36:41.241] result() for MulticoreFuture ... done
[13:36:41.241] result() for MulticoreFuture ... done
[13:36:41.241] result() for MulticoreFuture ...
[13:36:41.242] result() for MulticoreFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[13:36:41.244] getGlobalsAndPackages() ...
[13:36:41.244] Searching for globals...
[13:36:41.249] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[13:36:41.249] Searching for globals ... DONE
[13:36:41.249] Resolving globals: FALSE
[13:36:41.250] 
[13:36:41.250] - packages: [2] ‘stats’, ‘datasets’
[13:36:41.250] getGlobalsAndPackages() ... DONE
[13:36:41.250] run() for ‘Future’ ...
[13:36:41.250] - state: ‘created’
[13:36:41.251] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:41.254] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:41.255] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:41.255]   - Field: ‘label’
[13:36:41.255]   - Field: ‘local’
[13:36:41.255]   - Field: ‘owner’
[13:36:41.255]   - Field: ‘envir’
[13:36:41.255]   - Field: ‘workers’
[13:36:41.255]   - Field: ‘packages’
[13:36:41.255]   - Field: ‘gc’
[13:36:41.256]   - Field: ‘job’
[13:36:41.256]   - Field: ‘conditions’
[13:36:41.256]   - Field: ‘expr’
[13:36:41.256]   - Field: ‘uuid’
[13:36:41.256]   - Field: ‘seed’
[13:36:41.256]   - Field: ‘version’
[13:36:41.256]   - Field: ‘result’
[13:36:41.256]   - Field: ‘asynchronous’
[13:36:41.256]   - Field: ‘calls’
[13:36:41.257]   - Field: ‘globals’
[13:36:41.257]   - Field: ‘stdout’
[13:36:41.257]   - Field: ‘earlySignal’
[13:36:41.257]   - Field: ‘lazy’
[13:36:41.257]   - Field: ‘state’
[13:36:41.257] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:41.257] - Launch lazy future ...
[13:36:41.258] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:36:41.258] Packages needed by future strategies (n = 0): <none>
[13:36:41.258] {
[13:36:41.258]     {
[13:36:41.258]         {
[13:36:41.258]             ...future.startTime <- base::Sys.time()
[13:36:41.258]             {
[13:36:41.258]                 {
[13:36:41.258]                   {
[13:36:41.258]                     {
[13:36:41.258]                       {
[13:36:41.258]                         base::local({
[13:36:41.258]                           has_future <- base::requireNamespace("future", 
[13:36:41.258]                             quietly = TRUE)
[13:36:41.258]                           if (has_future) {
[13:36:41.258]                             ns <- base::getNamespace("future")
[13:36:41.258]                             version <- ns[[".package"]][["version"]]
[13:36:41.258]                             if (is.null(version)) 
[13:36:41.258]                               version <- utils::packageVersion("future")
[13:36:41.258]                           }
[13:36:41.258]                           else {
[13:36:41.258]                             version <- NULL
[13:36:41.258]                           }
[13:36:41.258]                           if (!has_future || version < "1.8.0") {
[13:36:41.258]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:41.258]                               "", base::R.version$version.string), 
[13:36:41.258]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:41.258]                                 base::R.version$platform, 8 * 
[13:36:41.258]                                   base::.Machine$sizeof.pointer), 
[13:36:41.258]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:41.258]                                 "release", "version")], collapse = " "), 
[13:36:41.258]                               hostname = base::Sys.info()[["nodename"]])
[13:36:41.258]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:41.258]                               info)
[13:36:41.258]                             info <- base::paste(info, collapse = "; ")
[13:36:41.258]                             if (!has_future) {
[13:36:41.258]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:41.258]                                 info)
[13:36:41.258]                             }
[13:36:41.258]                             else {
[13:36:41.258]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:41.258]                                 info, version)
[13:36:41.258]                             }
[13:36:41.258]                             base::stop(msg)
[13:36:41.258]                           }
[13:36:41.258]                         })
[13:36:41.258]                       }
[13:36:41.258]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:41.258]                       base::options(mc.cores = 1L)
[13:36:41.258]                     }
[13:36:41.258]                     base::local({
[13:36:41.258]                       for (pkg in c("stats", "datasets")) {
[13:36:41.258]                         base::loadNamespace(pkg)
[13:36:41.258]                         base::library(pkg, character.only = TRUE)
[13:36:41.258]                       }
[13:36:41.258]                     })
[13:36:41.258]                   }
[13:36:41.258]                   ...future.strategy.old <- future::plan("list")
[13:36:41.258]                   options(future.plan = NULL)
[13:36:41.258]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.258]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:41.258]                 }
[13:36:41.258]                 ...future.workdir <- getwd()
[13:36:41.258]             }
[13:36:41.258]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:41.258]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:41.258]         }
[13:36:41.258]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:41.258]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:41.258]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:41.258]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:41.258]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:41.258]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:41.258]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:41.258]             base::names(...future.oldOptions))
[13:36:41.258]     }
[13:36:41.258]     if (FALSE) {
[13:36:41.258]     }
[13:36:41.258]     else {
[13:36:41.258]         if (TRUE) {
[13:36:41.258]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:41.258]                 open = "w")
[13:36:41.258]         }
[13:36:41.258]         else {
[13:36:41.258]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:41.258]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:41.258]         }
[13:36:41.258]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:41.258]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:41.258]             base::sink(type = "output", split = FALSE)
[13:36:41.258]             base::close(...future.stdout)
[13:36:41.258]         }, add = TRUE)
[13:36:41.258]     }
[13:36:41.258]     ...future.frame <- base::sys.nframe()
[13:36:41.258]     ...future.conditions <- base::list()
[13:36:41.258]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:41.258]     if (FALSE) {
[13:36:41.258]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:41.258]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:41.258]     }
[13:36:41.258]     ...future.result <- base::tryCatch({
[13:36:41.258]         base::withCallingHandlers({
[13:36:41.258]             ...future.value <- base::withVisible(base::local({
[13:36:41.258]                 withCallingHandlers({
[13:36:41.258]                   {
[13:36:41.258]                     lm(dist ~ . - 1, data = cars)
[13:36:41.258]                   }
[13:36:41.258]                 }, immediateCondition = function(cond) {
[13:36:41.258]                   save_rds <- function (object, pathname, ...) 
[13:36:41.258]                   {
[13:36:41.258]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:41.258]                     if (file_test("-f", pathname_tmp)) {
[13:36:41.258]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.258]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:41.258]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.258]                         fi_tmp[["mtime"]])
[13:36:41.258]                     }
[13:36:41.258]                     tryCatch({
[13:36:41.258]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:41.258]                     }, error = function(ex) {
[13:36:41.258]                       msg <- conditionMessage(ex)
[13:36:41.258]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.258]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:41.258]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.258]                         fi_tmp[["mtime"]], msg)
[13:36:41.258]                       ex$message <- msg
[13:36:41.258]                       stop(ex)
[13:36:41.258]                     })
[13:36:41.258]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:41.258]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:41.258]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:41.258]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.258]                       fi <- file.info(pathname)
[13:36:41.258]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:41.258]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.258]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:41.258]                         fi[["size"]], fi[["mtime"]])
[13:36:41.258]                       stop(msg)
[13:36:41.258]                     }
[13:36:41.258]                     invisible(pathname)
[13:36:41.258]                   }
[13:36:41.258]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:41.258]                     rootPath = tempdir()) 
[13:36:41.258]                   {
[13:36:41.258]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:41.258]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:41.258]                       tmpdir = path, fileext = ".rds")
[13:36:41.258]                     save_rds(obj, file)
[13:36:41.258]                   }
[13:36:41.258]                   saveImmediateCondition(cond, path = "/tmp/RtmphVqFyZ/.future/immediateConditions")
[13:36:41.258]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.258]                   {
[13:36:41.258]                     inherits <- base::inherits
[13:36:41.258]                     invokeRestart <- base::invokeRestart
[13:36:41.258]                     is.null <- base::is.null
[13:36:41.258]                     muffled <- FALSE
[13:36:41.258]                     if (inherits(cond, "message")) {
[13:36:41.258]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:41.258]                       if (muffled) 
[13:36:41.258]                         invokeRestart("muffleMessage")
[13:36:41.258]                     }
[13:36:41.258]                     else if (inherits(cond, "warning")) {
[13:36:41.258]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:41.258]                       if (muffled) 
[13:36:41.258]                         invokeRestart("muffleWarning")
[13:36:41.258]                     }
[13:36:41.258]                     else if (inherits(cond, "condition")) {
[13:36:41.258]                       if (!is.null(pattern)) {
[13:36:41.258]                         computeRestarts <- base::computeRestarts
[13:36:41.258]                         grepl <- base::grepl
[13:36:41.258]                         restarts <- computeRestarts(cond)
[13:36:41.258]                         for (restart in restarts) {
[13:36:41.258]                           name <- restart$name
[13:36:41.258]                           if (is.null(name)) 
[13:36:41.258]                             next
[13:36:41.258]                           if (!grepl(pattern, name)) 
[13:36:41.258]                             next
[13:36:41.258]                           invokeRestart(restart)
[13:36:41.258]                           muffled <- TRUE
[13:36:41.258]                           break
[13:36:41.258]                         }
[13:36:41.258]                       }
[13:36:41.258]                     }
[13:36:41.258]                     invisible(muffled)
[13:36:41.258]                   }
[13:36:41.258]                   muffleCondition(cond)
[13:36:41.258]                 })
[13:36:41.258]             }))
[13:36:41.258]             future::FutureResult(value = ...future.value$value, 
[13:36:41.258]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.258]                   ...future.rng), globalenv = if (FALSE) 
[13:36:41.258]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:41.258]                     ...future.globalenv.names))
[13:36:41.258]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:41.258]         }, condition = base::local({
[13:36:41.258]             c <- base::c
[13:36:41.258]             inherits <- base::inherits
[13:36:41.258]             invokeRestart <- base::invokeRestart
[13:36:41.258]             length <- base::length
[13:36:41.258]             list <- base::list
[13:36:41.258]             seq.int <- base::seq.int
[13:36:41.258]             signalCondition <- base::signalCondition
[13:36:41.258]             sys.calls <- base::sys.calls
[13:36:41.258]             `[[` <- base::`[[`
[13:36:41.258]             `+` <- base::`+`
[13:36:41.258]             `<<-` <- base::`<<-`
[13:36:41.258]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:41.258]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:41.258]                   3L)]
[13:36:41.258]             }
[13:36:41.258]             function(cond) {
[13:36:41.258]                 is_error <- inherits(cond, "error")
[13:36:41.258]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:41.258]                   NULL)
[13:36:41.258]                 if (is_error) {
[13:36:41.258]                   sessionInformation <- function() {
[13:36:41.258]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:41.258]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:41.258]                       search = base::search(), system = base::Sys.info())
[13:36:41.258]                   }
[13:36:41.258]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.258]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:41.258]                     cond$call), session = sessionInformation(), 
[13:36:41.258]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:41.258]                   signalCondition(cond)
[13:36:41.258]                 }
[13:36:41.258]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:41.258]                 "immediateCondition"))) {
[13:36:41.258]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:41.258]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.258]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:41.258]                   if (TRUE && !signal) {
[13:36:41.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.258]                     {
[13:36:41.258]                       inherits <- base::inherits
[13:36:41.258]                       invokeRestart <- base::invokeRestart
[13:36:41.258]                       is.null <- base::is.null
[13:36:41.258]                       muffled <- FALSE
[13:36:41.258]                       if (inherits(cond, "message")) {
[13:36:41.258]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.258]                         if (muffled) 
[13:36:41.258]                           invokeRestart("muffleMessage")
[13:36:41.258]                       }
[13:36:41.258]                       else if (inherits(cond, "warning")) {
[13:36:41.258]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.258]                         if (muffled) 
[13:36:41.258]                           invokeRestart("muffleWarning")
[13:36:41.258]                       }
[13:36:41.258]                       else if (inherits(cond, "condition")) {
[13:36:41.258]                         if (!is.null(pattern)) {
[13:36:41.258]                           computeRestarts <- base::computeRestarts
[13:36:41.258]                           grepl <- base::grepl
[13:36:41.258]                           restarts <- computeRestarts(cond)
[13:36:41.258]                           for (restart in restarts) {
[13:36:41.258]                             name <- restart$name
[13:36:41.258]                             if (is.null(name)) 
[13:36:41.258]                               next
[13:36:41.258]                             if (!grepl(pattern, name)) 
[13:36:41.258]                               next
[13:36:41.258]                             invokeRestart(restart)
[13:36:41.258]                             muffled <- TRUE
[13:36:41.258]                             break
[13:36:41.258]                           }
[13:36:41.258]                         }
[13:36:41.258]                       }
[13:36:41.258]                       invisible(muffled)
[13:36:41.258]                     }
[13:36:41.258]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.258]                   }
[13:36:41.258]                 }
[13:36:41.258]                 else {
[13:36:41.258]                   if (TRUE) {
[13:36:41.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.258]                     {
[13:36:41.258]                       inherits <- base::inherits
[13:36:41.258]                       invokeRestart <- base::invokeRestart
[13:36:41.258]                       is.null <- base::is.null
[13:36:41.258]                       muffled <- FALSE
[13:36:41.258]                       if (inherits(cond, "message")) {
[13:36:41.258]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.258]                         if (muffled) 
[13:36:41.258]                           invokeRestart("muffleMessage")
[13:36:41.258]                       }
[13:36:41.258]                       else if (inherits(cond, "warning")) {
[13:36:41.258]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.258]                         if (muffled) 
[13:36:41.258]                           invokeRestart("muffleWarning")
[13:36:41.258]                       }
[13:36:41.258]                       else if (inherits(cond, "condition")) {
[13:36:41.258]                         if (!is.null(pattern)) {
[13:36:41.258]                           computeRestarts <- base::computeRestarts
[13:36:41.258]                           grepl <- base::grepl
[13:36:41.258]                           restarts <- computeRestarts(cond)
[13:36:41.258]                           for (restart in restarts) {
[13:36:41.258]                             name <- restart$name
[13:36:41.258]                             if (is.null(name)) 
[13:36:41.258]                               next
[13:36:41.258]                             if (!grepl(pattern, name)) 
[13:36:41.258]                               next
[13:36:41.258]                             invokeRestart(restart)
[13:36:41.258]                             muffled <- TRUE
[13:36:41.258]                             break
[13:36:41.258]                           }
[13:36:41.258]                         }
[13:36:41.258]                       }
[13:36:41.258]                       invisible(muffled)
[13:36:41.258]                     }
[13:36:41.258]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.258]                   }
[13:36:41.258]                 }
[13:36:41.258]             }
[13:36:41.258]         }))
[13:36:41.258]     }, error = function(ex) {
[13:36:41.258]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:41.258]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.258]                 ...future.rng), started = ...future.startTime, 
[13:36:41.258]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:41.258]             version = "1.8"), class = "FutureResult")
[13:36:41.258]     }, finally = {
[13:36:41.258]         if (!identical(...future.workdir, getwd())) 
[13:36:41.258]             setwd(...future.workdir)
[13:36:41.258]         {
[13:36:41.258]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:41.258]                 ...future.oldOptions$nwarnings <- NULL
[13:36:41.258]             }
[13:36:41.258]             base::options(...future.oldOptions)
[13:36:41.258]             if (.Platform$OS.type == "windows") {
[13:36:41.258]                 old_names <- names(...future.oldEnvVars)
[13:36:41.258]                 envs <- base::Sys.getenv()
[13:36:41.258]                 names <- names(envs)
[13:36:41.258]                 common <- intersect(names, old_names)
[13:36:41.258]                 added <- setdiff(names, old_names)
[13:36:41.258]                 removed <- setdiff(old_names, names)
[13:36:41.258]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:41.258]                   envs[common]]
[13:36:41.258]                 NAMES <- toupper(changed)
[13:36:41.258]                 args <- list()
[13:36:41.258]                 for (kk in seq_along(NAMES)) {
[13:36:41.258]                   name <- changed[[kk]]
[13:36:41.258]                   NAME <- NAMES[[kk]]
[13:36:41.258]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.258]                     next
[13:36:41.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.258]                 }
[13:36:41.258]                 NAMES <- toupper(added)
[13:36:41.258]                 for (kk in seq_along(NAMES)) {
[13:36:41.258]                   name <- added[[kk]]
[13:36:41.258]                   NAME <- NAMES[[kk]]
[13:36:41.258]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.258]                     next
[13:36:41.258]                   args[[name]] <- ""
[13:36:41.258]                 }
[13:36:41.258]                 NAMES <- toupper(removed)
[13:36:41.258]                 for (kk in seq_along(NAMES)) {
[13:36:41.258]                   name <- removed[[kk]]
[13:36:41.258]                   NAME <- NAMES[[kk]]
[13:36:41.258]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.258]                     next
[13:36:41.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.258]                 }
[13:36:41.258]                 if (length(args) > 0) 
[13:36:41.258]                   base::do.call(base::Sys.setenv, args = args)
[13:36:41.258]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:41.258]             }
[13:36:41.258]             else {
[13:36:41.258]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:41.258]             }
[13:36:41.258]             {
[13:36:41.258]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:41.258]                   0L) {
[13:36:41.258]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:41.258]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:41.258]                   base::options(opts)
[13:36:41.258]                 }
[13:36:41.258]                 {
[13:36:41.258]                   {
[13:36:41.258]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:41.258]                     NULL
[13:36:41.258]                   }
[13:36:41.258]                   options(future.plan = NULL)
[13:36:41.258]                   if (is.na(NA_character_)) 
[13:36:41.258]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.258]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:41.258]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:41.258]                     .init = FALSE)
[13:36:41.258]                 }
[13:36:41.258]             }
[13:36:41.258]         }
[13:36:41.258]     })
[13:36:41.258]     if (TRUE) {
[13:36:41.258]         base::sink(type = "output", split = FALSE)
[13:36:41.258]         if (TRUE) {
[13:36:41.258]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:41.258]         }
[13:36:41.258]         else {
[13:36:41.258]             ...future.result["stdout"] <- base::list(NULL)
[13:36:41.258]         }
[13:36:41.258]         base::close(...future.stdout)
[13:36:41.258]         ...future.stdout <- NULL
[13:36:41.258]     }
[13:36:41.258]     ...future.result$conditions <- ...future.conditions
[13:36:41.258]     ...future.result$finished <- base::Sys.time()
[13:36:41.258]     ...future.result
[13:36:41.258] }
[13:36:41.261] requestCore(): workers = 2
[13:36:41.262] MulticoreFuture started
[13:36:41.263] - Launch lazy future ... done
[13:36:41.263] run() for ‘MulticoreFuture’ ... done
[13:36:41.263] result() for MulticoreFuture ...
[13:36:41.264] plan(): Setting new future strategy stack:
[13:36:41.264] List of future strategies:
[13:36:41.264] 1. sequential:
[13:36:41.264]    - args: function (..., envir = parent.frame())
[13:36:41.264]    - tweaked: FALSE
[13:36:41.264]    - call: NULL
[13:36:41.265] plan(): nbrOfWorkers() = 1
[13:36:41.268] plan(): Setting new future strategy stack:
[13:36:41.269] List of future strategies:
[13:36:41.269] 1. multicore:
[13:36:41.269]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:41.269]    - tweaked: FALSE
[13:36:41.269]    - call: plan(strategy)
[13:36:41.274] plan(): nbrOfWorkers() = 2
[13:36:41.276] result() for MulticoreFuture ...
[13:36:41.276] result() for MulticoreFuture ... done
[13:36:41.276] result() for MulticoreFuture ... done
[13:36:41.276] result() for MulticoreFuture ...
[13:36:41.276] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[13:36:41.280] getGlobalsAndPackages() ...
[13:36:41.280] Searching for globals...
[13:36:41.282] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[13:36:41.282] Searching for globals ... DONE
[13:36:41.282] Resolving globals: FALSE
[13:36:41.283] 
[13:36:41.283] - packages: [2] ‘stats’, ‘datasets’
[13:36:41.283] getGlobalsAndPackages() ... DONE
[13:36:41.283] run() for ‘Future’ ...
[13:36:41.284] - state: ‘created’
[13:36:41.284] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:41.288] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:41.288] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:41.288]   - Field: ‘label’
[13:36:41.288]   - Field: ‘local’
[13:36:41.288]   - Field: ‘owner’
[13:36:41.288]   - Field: ‘envir’
[13:36:41.288]   - Field: ‘workers’
[13:36:41.289]   - Field: ‘packages’
[13:36:41.289]   - Field: ‘gc’
[13:36:41.289]   - Field: ‘job’
[13:36:41.289]   - Field: ‘conditions’
[13:36:41.289]   - Field: ‘expr’
[13:36:41.289]   - Field: ‘uuid’
[13:36:41.325]   - Field: ‘seed’
[13:36:41.325]   - Field: ‘version’
[13:36:41.325]   - Field: ‘result’
[13:36:41.325]   - Field: ‘asynchronous’
[13:36:41.326]   - Field: ‘calls’
[13:36:41.326]   - Field: ‘globals’
[13:36:41.326]   - Field: ‘stdout’
[13:36:41.326]   - Field: ‘earlySignal’
[13:36:41.326]   - Field: ‘lazy’
[13:36:41.326]   - Field: ‘state’
[13:36:41.326] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:41.326] - Launch lazy future ...
[13:36:41.327] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:36:41.327] Packages needed by future strategies (n = 0): <none>
[13:36:41.327] {
[13:36:41.327]     {
[13:36:41.327]         {
[13:36:41.327]             ...future.startTime <- base::Sys.time()
[13:36:41.327]             {
[13:36:41.327]                 {
[13:36:41.327]                   {
[13:36:41.327]                     {
[13:36:41.327]                       {
[13:36:41.327]                         base::local({
[13:36:41.327]                           has_future <- base::requireNamespace("future", 
[13:36:41.327]                             quietly = TRUE)
[13:36:41.327]                           if (has_future) {
[13:36:41.327]                             ns <- base::getNamespace("future")
[13:36:41.327]                             version <- ns[[".package"]][["version"]]
[13:36:41.327]                             if (is.null(version)) 
[13:36:41.327]                               version <- utils::packageVersion("future")
[13:36:41.327]                           }
[13:36:41.327]                           else {
[13:36:41.327]                             version <- NULL
[13:36:41.327]                           }
[13:36:41.327]                           if (!has_future || version < "1.8.0") {
[13:36:41.327]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:41.327]                               "", base::R.version$version.string), 
[13:36:41.327]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:41.327]                                 base::R.version$platform, 8 * 
[13:36:41.327]                                   base::.Machine$sizeof.pointer), 
[13:36:41.327]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:41.327]                                 "release", "version")], collapse = " "), 
[13:36:41.327]                               hostname = base::Sys.info()[["nodename"]])
[13:36:41.327]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:41.327]                               info)
[13:36:41.327]                             info <- base::paste(info, collapse = "; ")
[13:36:41.327]                             if (!has_future) {
[13:36:41.327]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:41.327]                                 info)
[13:36:41.327]                             }
[13:36:41.327]                             else {
[13:36:41.327]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:41.327]                                 info, version)
[13:36:41.327]                             }
[13:36:41.327]                             base::stop(msg)
[13:36:41.327]                           }
[13:36:41.327]                         })
[13:36:41.327]                       }
[13:36:41.327]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:41.327]                       base::options(mc.cores = 1L)
[13:36:41.327]                     }
[13:36:41.327]                     base::local({
[13:36:41.327]                       for (pkg in c("stats", "datasets")) {
[13:36:41.327]                         base::loadNamespace(pkg)
[13:36:41.327]                         base::library(pkg, character.only = TRUE)
[13:36:41.327]                       }
[13:36:41.327]                     })
[13:36:41.327]                   }
[13:36:41.327]                   ...future.strategy.old <- future::plan("list")
[13:36:41.327]                   options(future.plan = NULL)
[13:36:41.327]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.327]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:41.327]                 }
[13:36:41.327]                 ...future.workdir <- getwd()
[13:36:41.327]             }
[13:36:41.327]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:41.327]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:41.327]         }
[13:36:41.327]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:41.327]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:41.327]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:41.327]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:41.327]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:41.327]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:41.327]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:41.327]             base::names(...future.oldOptions))
[13:36:41.327]     }
[13:36:41.327]     if (FALSE) {
[13:36:41.327]     }
[13:36:41.327]     else {
[13:36:41.327]         if (TRUE) {
[13:36:41.327]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:41.327]                 open = "w")
[13:36:41.327]         }
[13:36:41.327]         else {
[13:36:41.327]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:41.327]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:41.327]         }
[13:36:41.327]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:41.327]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:41.327]             base::sink(type = "output", split = FALSE)
[13:36:41.327]             base::close(...future.stdout)
[13:36:41.327]         }, add = TRUE)
[13:36:41.327]     }
[13:36:41.327]     ...future.frame <- base::sys.nframe()
[13:36:41.327]     ...future.conditions <- base::list()
[13:36:41.327]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:41.327]     if (FALSE) {
[13:36:41.327]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:41.327]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:41.327]     }
[13:36:41.327]     ...future.result <- base::tryCatch({
[13:36:41.327]         base::withCallingHandlers({
[13:36:41.327]             ...future.value <- base::withVisible(base::local({
[13:36:41.327]                 withCallingHandlers({
[13:36:41.327]                   {
[13:36:41.327]                     lm(dist ~ . + 0, data = cars)
[13:36:41.327]                   }
[13:36:41.327]                 }, immediateCondition = function(cond) {
[13:36:41.327]                   save_rds <- function (object, pathname, ...) 
[13:36:41.327]                   {
[13:36:41.327]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:41.327]                     if (file_test("-f", pathname_tmp)) {
[13:36:41.327]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.327]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:41.327]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.327]                         fi_tmp[["mtime"]])
[13:36:41.327]                     }
[13:36:41.327]                     tryCatch({
[13:36:41.327]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:41.327]                     }, error = function(ex) {
[13:36:41.327]                       msg <- conditionMessage(ex)
[13:36:41.327]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.327]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:41.327]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.327]                         fi_tmp[["mtime"]], msg)
[13:36:41.327]                       ex$message <- msg
[13:36:41.327]                       stop(ex)
[13:36:41.327]                     })
[13:36:41.327]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:41.327]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:41.327]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:41.327]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.327]                       fi <- file.info(pathname)
[13:36:41.327]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:41.327]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.327]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:41.327]                         fi[["size"]], fi[["mtime"]])
[13:36:41.327]                       stop(msg)
[13:36:41.327]                     }
[13:36:41.327]                     invisible(pathname)
[13:36:41.327]                   }
[13:36:41.327]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:41.327]                     rootPath = tempdir()) 
[13:36:41.327]                   {
[13:36:41.327]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:41.327]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:41.327]                       tmpdir = path, fileext = ".rds")
[13:36:41.327]                     save_rds(obj, file)
[13:36:41.327]                   }
[13:36:41.327]                   saveImmediateCondition(cond, path = "/tmp/RtmphVqFyZ/.future/immediateConditions")
[13:36:41.327]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.327]                   {
[13:36:41.327]                     inherits <- base::inherits
[13:36:41.327]                     invokeRestart <- base::invokeRestart
[13:36:41.327]                     is.null <- base::is.null
[13:36:41.327]                     muffled <- FALSE
[13:36:41.327]                     if (inherits(cond, "message")) {
[13:36:41.327]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:41.327]                       if (muffled) 
[13:36:41.327]                         invokeRestart("muffleMessage")
[13:36:41.327]                     }
[13:36:41.327]                     else if (inherits(cond, "warning")) {
[13:36:41.327]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:41.327]                       if (muffled) 
[13:36:41.327]                         invokeRestart("muffleWarning")
[13:36:41.327]                     }
[13:36:41.327]                     else if (inherits(cond, "condition")) {
[13:36:41.327]                       if (!is.null(pattern)) {
[13:36:41.327]                         computeRestarts <- base::computeRestarts
[13:36:41.327]                         grepl <- base::grepl
[13:36:41.327]                         restarts <- computeRestarts(cond)
[13:36:41.327]                         for (restart in restarts) {
[13:36:41.327]                           name <- restart$name
[13:36:41.327]                           if (is.null(name)) 
[13:36:41.327]                             next
[13:36:41.327]                           if (!grepl(pattern, name)) 
[13:36:41.327]                             next
[13:36:41.327]                           invokeRestart(restart)
[13:36:41.327]                           muffled <- TRUE
[13:36:41.327]                           break
[13:36:41.327]                         }
[13:36:41.327]                       }
[13:36:41.327]                     }
[13:36:41.327]                     invisible(muffled)
[13:36:41.327]                   }
[13:36:41.327]                   muffleCondition(cond)
[13:36:41.327]                 })
[13:36:41.327]             }))
[13:36:41.327]             future::FutureResult(value = ...future.value$value, 
[13:36:41.327]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.327]                   ...future.rng), globalenv = if (FALSE) 
[13:36:41.327]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:41.327]                     ...future.globalenv.names))
[13:36:41.327]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:41.327]         }, condition = base::local({
[13:36:41.327]             c <- base::c
[13:36:41.327]             inherits <- base::inherits
[13:36:41.327]             invokeRestart <- base::invokeRestart
[13:36:41.327]             length <- base::length
[13:36:41.327]             list <- base::list
[13:36:41.327]             seq.int <- base::seq.int
[13:36:41.327]             signalCondition <- base::signalCondition
[13:36:41.327]             sys.calls <- base::sys.calls
[13:36:41.327]             `[[` <- base::`[[`
[13:36:41.327]             `+` <- base::`+`
[13:36:41.327]             `<<-` <- base::`<<-`
[13:36:41.327]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:41.327]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:41.327]                   3L)]
[13:36:41.327]             }
[13:36:41.327]             function(cond) {
[13:36:41.327]                 is_error <- inherits(cond, "error")
[13:36:41.327]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:41.327]                   NULL)
[13:36:41.327]                 if (is_error) {
[13:36:41.327]                   sessionInformation <- function() {
[13:36:41.327]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:41.327]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:41.327]                       search = base::search(), system = base::Sys.info())
[13:36:41.327]                   }
[13:36:41.327]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.327]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:41.327]                     cond$call), session = sessionInformation(), 
[13:36:41.327]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:41.327]                   signalCondition(cond)
[13:36:41.327]                 }
[13:36:41.327]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:41.327]                 "immediateCondition"))) {
[13:36:41.327]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:41.327]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.327]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:41.327]                   if (TRUE && !signal) {
[13:36:41.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.327]                     {
[13:36:41.327]                       inherits <- base::inherits
[13:36:41.327]                       invokeRestart <- base::invokeRestart
[13:36:41.327]                       is.null <- base::is.null
[13:36:41.327]                       muffled <- FALSE
[13:36:41.327]                       if (inherits(cond, "message")) {
[13:36:41.327]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.327]                         if (muffled) 
[13:36:41.327]                           invokeRestart("muffleMessage")
[13:36:41.327]                       }
[13:36:41.327]                       else if (inherits(cond, "warning")) {
[13:36:41.327]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.327]                         if (muffled) 
[13:36:41.327]                           invokeRestart("muffleWarning")
[13:36:41.327]                       }
[13:36:41.327]                       else if (inherits(cond, "condition")) {
[13:36:41.327]                         if (!is.null(pattern)) {
[13:36:41.327]                           computeRestarts <- base::computeRestarts
[13:36:41.327]                           grepl <- base::grepl
[13:36:41.327]                           restarts <- computeRestarts(cond)
[13:36:41.327]                           for (restart in restarts) {
[13:36:41.327]                             name <- restart$name
[13:36:41.327]                             if (is.null(name)) 
[13:36:41.327]                               next
[13:36:41.327]                             if (!grepl(pattern, name)) 
[13:36:41.327]                               next
[13:36:41.327]                             invokeRestart(restart)
[13:36:41.327]                             muffled <- TRUE
[13:36:41.327]                             break
[13:36:41.327]                           }
[13:36:41.327]                         }
[13:36:41.327]                       }
[13:36:41.327]                       invisible(muffled)
[13:36:41.327]                     }
[13:36:41.327]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.327]                   }
[13:36:41.327]                 }
[13:36:41.327]                 else {
[13:36:41.327]                   if (TRUE) {
[13:36:41.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.327]                     {
[13:36:41.327]                       inherits <- base::inherits
[13:36:41.327]                       invokeRestart <- base::invokeRestart
[13:36:41.327]                       is.null <- base::is.null
[13:36:41.327]                       muffled <- FALSE
[13:36:41.327]                       if (inherits(cond, "message")) {
[13:36:41.327]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.327]                         if (muffled) 
[13:36:41.327]                           invokeRestart("muffleMessage")
[13:36:41.327]                       }
[13:36:41.327]                       else if (inherits(cond, "warning")) {
[13:36:41.327]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.327]                         if (muffled) 
[13:36:41.327]                           invokeRestart("muffleWarning")
[13:36:41.327]                       }
[13:36:41.327]                       else if (inherits(cond, "condition")) {
[13:36:41.327]                         if (!is.null(pattern)) {
[13:36:41.327]                           computeRestarts <- base::computeRestarts
[13:36:41.327]                           grepl <- base::grepl
[13:36:41.327]                           restarts <- computeRestarts(cond)
[13:36:41.327]                           for (restart in restarts) {
[13:36:41.327]                             name <- restart$name
[13:36:41.327]                             if (is.null(name)) 
[13:36:41.327]                               next
[13:36:41.327]                             if (!grepl(pattern, name)) 
[13:36:41.327]                               next
[13:36:41.327]                             invokeRestart(restart)
[13:36:41.327]                             muffled <- TRUE
[13:36:41.327]                             break
[13:36:41.327]                           }
[13:36:41.327]                         }
[13:36:41.327]                       }
[13:36:41.327]                       invisible(muffled)
[13:36:41.327]                     }
[13:36:41.327]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.327]                   }
[13:36:41.327]                 }
[13:36:41.327]             }
[13:36:41.327]         }))
[13:36:41.327]     }, error = function(ex) {
[13:36:41.327]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:41.327]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.327]                 ...future.rng), started = ...future.startTime, 
[13:36:41.327]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:41.327]             version = "1.8"), class = "FutureResult")
[13:36:41.327]     }, finally = {
[13:36:41.327]         if (!identical(...future.workdir, getwd())) 
[13:36:41.327]             setwd(...future.workdir)
[13:36:41.327]         {
[13:36:41.327]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:41.327]                 ...future.oldOptions$nwarnings <- NULL
[13:36:41.327]             }
[13:36:41.327]             base::options(...future.oldOptions)
[13:36:41.327]             if (.Platform$OS.type == "windows") {
[13:36:41.327]                 old_names <- names(...future.oldEnvVars)
[13:36:41.327]                 envs <- base::Sys.getenv()
[13:36:41.327]                 names <- names(envs)
[13:36:41.327]                 common <- intersect(names, old_names)
[13:36:41.327]                 added <- setdiff(names, old_names)
[13:36:41.327]                 removed <- setdiff(old_names, names)
[13:36:41.327]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:41.327]                   envs[common]]
[13:36:41.327]                 NAMES <- toupper(changed)
[13:36:41.327]                 args <- list()
[13:36:41.327]                 for (kk in seq_along(NAMES)) {
[13:36:41.327]                   name <- changed[[kk]]
[13:36:41.327]                   NAME <- NAMES[[kk]]
[13:36:41.327]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.327]                     next
[13:36:41.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.327]                 }
[13:36:41.327]                 NAMES <- toupper(added)
[13:36:41.327]                 for (kk in seq_along(NAMES)) {
[13:36:41.327]                   name <- added[[kk]]
[13:36:41.327]                   NAME <- NAMES[[kk]]
[13:36:41.327]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.327]                     next
[13:36:41.327]                   args[[name]] <- ""
[13:36:41.327]                 }
[13:36:41.327]                 NAMES <- toupper(removed)
[13:36:41.327]                 for (kk in seq_along(NAMES)) {
[13:36:41.327]                   name <- removed[[kk]]
[13:36:41.327]                   NAME <- NAMES[[kk]]
[13:36:41.327]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.327]                     next
[13:36:41.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.327]                 }
[13:36:41.327]                 if (length(args) > 0) 
[13:36:41.327]                   base::do.call(base::Sys.setenv, args = args)
[13:36:41.327]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:41.327]             }
[13:36:41.327]             else {
[13:36:41.327]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:41.327]             }
[13:36:41.327]             {
[13:36:41.327]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:41.327]                   0L) {
[13:36:41.327]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:41.327]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:41.327]                   base::options(opts)
[13:36:41.327]                 }
[13:36:41.327]                 {
[13:36:41.327]                   {
[13:36:41.327]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:41.327]                     NULL
[13:36:41.327]                   }
[13:36:41.327]                   options(future.plan = NULL)
[13:36:41.327]                   if (is.na(NA_character_)) 
[13:36:41.327]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.327]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:41.327]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:41.327]                     .init = FALSE)
[13:36:41.327]                 }
[13:36:41.327]             }
[13:36:41.327]         }
[13:36:41.327]     })
[13:36:41.327]     if (TRUE) {
[13:36:41.327]         base::sink(type = "output", split = FALSE)
[13:36:41.327]         if (TRUE) {
[13:36:41.327]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:41.327]         }
[13:36:41.327]         else {
[13:36:41.327]             ...future.result["stdout"] <- base::list(NULL)
[13:36:41.327]         }
[13:36:41.327]         base::close(...future.stdout)
[13:36:41.327]         ...future.stdout <- NULL
[13:36:41.327]     }
[13:36:41.327]     ...future.result$conditions <- ...future.conditions
[13:36:41.327]     ...future.result$finished <- base::Sys.time()
[13:36:41.327]     ...future.result
[13:36:41.327] }
[13:36:41.330] requestCore(): workers = 2
[13:36:41.332] MulticoreFuture started
[13:36:41.332] - Launch lazy future ... done
[13:36:41.333] run() for ‘MulticoreFuture’ ... done
[13:36:41.333] result() for MulticoreFuture ...
[13:36:41.334] plan(): Setting new future strategy stack:
[13:36:41.334] List of future strategies:
[13:36:41.334] 1. sequential:
[13:36:41.334]    - args: function (..., envir = parent.frame())
[13:36:41.334]    - tweaked: FALSE
[13:36:41.334]    - call: NULL
[13:36:41.335] plan(): nbrOfWorkers() = 1
[13:36:41.339] plan(): Setting new future strategy stack:
[13:36:41.340] List of future strategies:
[13:36:41.340] 1. multicore:
[13:36:41.340]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:41.340]    - tweaked: FALSE
[13:36:41.340]    - call: plan(strategy)
[13:36:41.345] plan(): nbrOfWorkers() = 2
[13:36:41.347] result() for MulticoreFuture ...
[13:36:41.347] result() for MulticoreFuture ... done
[13:36:41.348] result() for MulticoreFuture ... done
[13:36:41.348] result() for MulticoreFuture ...
[13:36:41.348] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[13:36:41.352] getGlobalsAndPackages() ...
[13:36:41.352] Searching for globals...
[13:36:41.354] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[13:36:41.354] Searching for globals ... DONE
[13:36:41.355] Resolving globals: FALSE
[13:36:41.355] 
[13:36:41.355] - packages: [2] ‘stats’, ‘datasets’
[13:36:41.356] getGlobalsAndPackages() ... DONE
[13:36:41.356] run() for ‘Future’ ...
[13:36:41.356] - state: ‘created’
[13:36:41.356] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:41.360] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:41.360] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:41.361]   - Field: ‘label’
[13:36:41.361]   - Field: ‘local’
[13:36:41.361]   - Field: ‘owner’
[13:36:41.361]   - Field: ‘envir’
[13:36:41.361]   - Field: ‘workers’
[13:36:41.361]   - Field: ‘packages’
[13:36:41.361]   - Field: ‘gc’
[13:36:41.361]   - Field: ‘job’
[13:36:41.362]   - Field: ‘conditions’
[13:36:41.362]   - Field: ‘expr’
[13:36:41.362]   - Field: ‘uuid’
[13:36:41.362]   - Field: ‘seed’
[13:36:41.362]   - Field: ‘version’
[13:36:41.362]   - Field: ‘result’
[13:36:41.362]   - Field: ‘asynchronous’
[13:36:41.362]   - Field: ‘calls’
[13:36:41.362]   - Field: ‘globals’
[13:36:41.363]   - Field: ‘stdout’
[13:36:41.363]   - Field: ‘earlySignal’
[13:36:41.363]   - Field: ‘lazy’
[13:36:41.363]   - Field: ‘state’
[13:36:41.363] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:41.363] - Launch lazy future ...
[13:36:41.363] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:36:41.364] Packages needed by future strategies (n = 0): <none>
[13:36:41.364] {
[13:36:41.364]     {
[13:36:41.364]         {
[13:36:41.364]             ...future.startTime <- base::Sys.time()
[13:36:41.364]             {
[13:36:41.364]                 {
[13:36:41.364]                   {
[13:36:41.364]                     {
[13:36:41.364]                       {
[13:36:41.364]                         base::local({
[13:36:41.364]                           has_future <- base::requireNamespace("future", 
[13:36:41.364]                             quietly = TRUE)
[13:36:41.364]                           if (has_future) {
[13:36:41.364]                             ns <- base::getNamespace("future")
[13:36:41.364]                             version <- ns[[".package"]][["version"]]
[13:36:41.364]                             if (is.null(version)) 
[13:36:41.364]                               version <- utils::packageVersion("future")
[13:36:41.364]                           }
[13:36:41.364]                           else {
[13:36:41.364]                             version <- NULL
[13:36:41.364]                           }
[13:36:41.364]                           if (!has_future || version < "1.8.0") {
[13:36:41.364]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:41.364]                               "", base::R.version$version.string), 
[13:36:41.364]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:41.364]                                 base::R.version$platform, 8 * 
[13:36:41.364]                                   base::.Machine$sizeof.pointer), 
[13:36:41.364]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:41.364]                                 "release", "version")], collapse = " "), 
[13:36:41.364]                               hostname = base::Sys.info()[["nodename"]])
[13:36:41.364]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:41.364]                               info)
[13:36:41.364]                             info <- base::paste(info, collapse = "; ")
[13:36:41.364]                             if (!has_future) {
[13:36:41.364]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:41.364]                                 info)
[13:36:41.364]                             }
[13:36:41.364]                             else {
[13:36:41.364]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:41.364]                                 info, version)
[13:36:41.364]                             }
[13:36:41.364]                             base::stop(msg)
[13:36:41.364]                           }
[13:36:41.364]                         })
[13:36:41.364]                       }
[13:36:41.364]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:41.364]                       base::options(mc.cores = 1L)
[13:36:41.364]                     }
[13:36:41.364]                     base::local({
[13:36:41.364]                       for (pkg in c("stats", "datasets")) {
[13:36:41.364]                         base::loadNamespace(pkg)
[13:36:41.364]                         base::library(pkg, character.only = TRUE)
[13:36:41.364]                       }
[13:36:41.364]                     })
[13:36:41.364]                   }
[13:36:41.364]                   ...future.strategy.old <- future::plan("list")
[13:36:41.364]                   options(future.plan = NULL)
[13:36:41.364]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.364]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:41.364]                 }
[13:36:41.364]                 ...future.workdir <- getwd()
[13:36:41.364]             }
[13:36:41.364]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:41.364]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:41.364]         }
[13:36:41.364]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:41.364]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:41.364]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:41.364]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:41.364]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:41.364]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:41.364]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:41.364]             base::names(...future.oldOptions))
[13:36:41.364]     }
[13:36:41.364]     if (FALSE) {
[13:36:41.364]     }
[13:36:41.364]     else {
[13:36:41.364]         if (TRUE) {
[13:36:41.364]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:41.364]                 open = "w")
[13:36:41.364]         }
[13:36:41.364]         else {
[13:36:41.364]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:41.364]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:41.364]         }
[13:36:41.364]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:41.364]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:41.364]             base::sink(type = "output", split = FALSE)
[13:36:41.364]             base::close(...future.stdout)
[13:36:41.364]         }, add = TRUE)
[13:36:41.364]     }
[13:36:41.364]     ...future.frame <- base::sys.nframe()
[13:36:41.364]     ...future.conditions <- base::list()
[13:36:41.364]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:41.364]     if (FALSE) {
[13:36:41.364]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:41.364]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:41.364]     }
[13:36:41.364]     ...future.result <- base::tryCatch({
[13:36:41.364]         base::withCallingHandlers({
[13:36:41.364]             ...future.value <- base::withVisible(base::local({
[13:36:41.364]                 withCallingHandlers({
[13:36:41.364]                   {
[13:36:41.364]                     lm(dist ~ speed + speed^2, data = cars)
[13:36:41.364]                   }
[13:36:41.364]                 }, immediateCondition = function(cond) {
[13:36:41.364]                   save_rds <- function (object, pathname, ...) 
[13:36:41.364]                   {
[13:36:41.364]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:41.364]                     if (file_test("-f", pathname_tmp)) {
[13:36:41.364]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.364]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:41.364]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.364]                         fi_tmp[["mtime"]])
[13:36:41.364]                     }
[13:36:41.364]                     tryCatch({
[13:36:41.364]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:41.364]                     }, error = function(ex) {
[13:36:41.364]                       msg <- conditionMessage(ex)
[13:36:41.364]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.364]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:41.364]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.364]                         fi_tmp[["mtime"]], msg)
[13:36:41.364]                       ex$message <- msg
[13:36:41.364]                       stop(ex)
[13:36:41.364]                     })
[13:36:41.364]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:41.364]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:41.364]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:41.364]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.364]                       fi <- file.info(pathname)
[13:36:41.364]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:41.364]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.364]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:41.364]                         fi[["size"]], fi[["mtime"]])
[13:36:41.364]                       stop(msg)
[13:36:41.364]                     }
[13:36:41.364]                     invisible(pathname)
[13:36:41.364]                   }
[13:36:41.364]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:41.364]                     rootPath = tempdir()) 
[13:36:41.364]                   {
[13:36:41.364]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:41.364]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:41.364]                       tmpdir = path, fileext = ".rds")
[13:36:41.364]                     save_rds(obj, file)
[13:36:41.364]                   }
[13:36:41.364]                   saveImmediateCondition(cond, path = "/tmp/RtmphVqFyZ/.future/immediateConditions")
[13:36:41.364]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.364]                   {
[13:36:41.364]                     inherits <- base::inherits
[13:36:41.364]                     invokeRestart <- base::invokeRestart
[13:36:41.364]                     is.null <- base::is.null
[13:36:41.364]                     muffled <- FALSE
[13:36:41.364]                     if (inherits(cond, "message")) {
[13:36:41.364]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:41.364]                       if (muffled) 
[13:36:41.364]                         invokeRestart("muffleMessage")
[13:36:41.364]                     }
[13:36:41.364]                     else if (inherits(cond, "warning")) {
[13:36:41.364]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:41.364]                       if (muffled) 
[13:36:41.364]                         invokeRestart("muffleWarning")
[13:36:41.364]                     }
[13:36:41.364]                     else if (inherits(cond, "condition")) {
[13:36:41.364]                       if (!is.null(pattern)) {
[13:36:41.364]                         computeRestarts <- base::computeRestarts
[13:36:41.364]                         grepl <- base::grepl
[13:36:41.364]                         restarts <- computeRestarts(cond)
[13:36:41.364]                         for (restart in restarts) {
[13:36:41.364]                           name <- restart$name
[13:36:41.364]                           if (is.null(name)) 
[13:36:41.364]                             next
[13:36:41.364]                           if (!grepl(pattern, name)) 
[13:36:41.364]                             next
[13:36:41.364]                           invokeRestart(restart)
[13:36:41.364]                           muffled <- TRUE
[13:36:41.364]                           break
[13:36:41.364]                         }
[13:36:41.364]                       }
[13:36:41.364]                     }
[13:36:41.364]                     invisible(muffled)
[13:36:41.364]                   }
[13:36:41.364]                   muffleCondition(cond)
[13:36:41.364]                 })
[13:36:41.364]             }))
[13:36:41.364]             future::FutureResult(value = ...future.value$value, 
[13:36:41.364]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.364]                   ...future.rng), globalenv = if (FALSE) 
[13:36:41.364]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:41.364]                     ...future.globalenv.names))
[13:36:41.364]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:41.364]         }, condition = base::local({
[13:36:41.364]             c <- base::c
[13:36:41.364]             inherits <- base::inherits
[13:36:41.364]             invokeRestart <- base::invokeRestart
[13:36:41.364]             length <- base::length
[13:36:41.364]             list <- base::list
[13:36:41.364]             seq.int <- base::seq.int
[13:36:41.364]             signalCondition <- base::signalCondition
[13:36:41.364]             sys.calls <- base::sys.calls
[13:36:41.364]             `[[` <- base::`[[`
[13:36:41.364]             `+` <- base::`+`
[13:36:41.364]             `<<-` <- base::`<<-`
[13:36:41.364]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:41.364]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:41.364]                   3L)]
[13:36:41.364]             }
[13:36:41.364]             function(cond) {
[13:36:41.364]                 is_error <- inherits(cond, "error")
[13:36:41.364]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:41.364]                   NULL)
[13:36:41.364]                 if (is_error) {
[13:36:41.364]                   sessionInformation <- function() {
[13:36:41.364]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:41.364]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:41.364]                       search = base::search(), system = base::Sys.info())
[13:36:41.364]                   }
[13:36:41.364]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.364]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:41.364]                     cond$call), session = sessionInformation(), 
[13:36:41.364]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:41.364]                   signalCondition(cond)
[13:36:41.364]                 }
[13:36:41.364]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:41.364]                 "immediateCondition"))) {
[13:36:41.364]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:41.364]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.364]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:41.364]                   if (TRUE && !signal) {
[13:36:41.364]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.364]                     {
[13:36:41.364]                       inherits <- base::inherits
[13:36:41.364]                       invokeRestart <- base::invokeRestart
[13:36:41.364]                       is.null <- base::is.null
[13:36:41.364]                       muffled <- FALSE
[13:36:41.364]                       if (inherits(cond, "message")) {
[13:36:41.364]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.364]                         if (muffled) 
[13:36:41.364]                           invokeRestart("muffleMessage")
[13:36:41.364]                       }
[13:36:41.364]                       else if (inherits(cond, "warning")) {
[13:36:41.364]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.364]                         if (muffled) 
[13:36:41.364]                           invokeRestart("muffleWarning")
[13:36:41.364]                       }
[13:36:41.364]                       else if (inherits(cond, "condition")) {
[13:36:41.364]                         if (!is.null(pattern)) {
[13:36:41.364]                           computeRestarts <- base::computeRestarts
[13:36:41.364]                           grepl <- base::grepl
[13:36:41.364]                           restarts <- computeRestarts(cond)
[13:36:41.364]                           for (restart in restarts) {
[13:36:41.364]                             name <- restart$name
[13:36:41.364]                             if (is.null(name)) 
[13:36:41.364]                               next
[13:36:41.364]                             if (!grepl(pattern, name)) 
[13:36:41.364]                               next
[13:36:41.364]                             invokeRestart(restart)
[13:36:41.364]                             muffled <- TRUE
[13:36:41.364]                             break
[13:36:41.364]                           }
[13:36:41.364]                         }
[13:36:41.364]                       }
[13:36:41.364]                       invisible(muffled)
[13:36:41.364]                     }
[13:36:41.364]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.364]                   }
[13:36:41.364]                 }
[13:36:41.364]                 else {
[13:36:41.364]                   if (TRUE) {
[13:36:41.364]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.364]                     {
[13:36:41.364]                       inherits <- base::inherits
[13:36:41.364]                       invokeRestart <- base::invokeRestart
[13:36:41.364]                       is.null <- base::is.null
[13:36:41.364]                       muffled <- FALSE
[13:36:41.364]                       if (inherits(cond, "message")) {
[13:36:41.364]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.364]                         if (muffled) 
[13:36:41.364]                           invokeRestart("muffleMessage")
[13:36:41.364]                       }
[13:36:41.364]                       else if (inherits(cond, "warning")) {
[13:36:41.364]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.364]                         if (muffled) 
[13:36:41.364]                           invokeRestart("muffleWarning")
[13:36:41.364]                       }
[13:36:41.364]                       else if (inherits(cond, "condition")) {
[13:36:41.364]                         if (!is.null(pattern)) {
[13:36:41.364]                           computeRestarts <- base::computeRestarts
[13:36:41.364]                           grepl <- base::grepl
[13:36:41.364]                           restarts <- computeRestarts(cond)
[13:36:41.364]                           for (restart in restarts) {
[13:36:41.364]                             name <- restart$name
[13:36:41.364]                             if (is.null(name)) 
[13:36:41.364]                               next
[13:36:41.364]                             if (!grepl(pattern, name)) 
[13:36:41.364]                               next
[13:36:41.364]                             invokeRestart(restart)
[13:36:41.364]                             muffled <- TRUE
[13:36:41.364]                             break
[13:36:41.364]                           }
[13:36:41.364]                         }
[13:36:41.364]                       }
[13:36:41.364]                       invisible(muffled)
[13:36:41.364]                     }
[13:36:41.364]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.364]                   }
[13:36:41.364]                 }
[13:36:41.364]             }
[13:36:41.364]         }))
[13:36:41.364]     }, error = function(ex) {
[13:36:41.364]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:41.364]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.364]                 ...future.rng), started = ...future.startTime, 
[13:36:41.364]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:41.364]             version = "1.8"), class = "FutureResult")
[13:36:41.364]     }, finally = {
[13:36:41.364]         if (!identical(...future.workdir, getwd())) 
[13:36:41.364]             setwd(...future.workdir)
[13:36:41.364]         {
[13:36:41.364]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:41.364]                 ...future.oldOptions$nwarnings <- NULL
[13:36:41.364]             }
[13:36:41.364]             base::options(...future.oldOptions)
[13:36:41.364]             if (.Platform$OS.type == "windows") {
[13:36:41.364]                 old_names <- names(...future.oldEnvVars)
[13:36:41.364]                 envs <- base::Sys.getenv()
[13:36:41.364]                 names <- names(envs)
[13:36:41.364]                 common <- intersect(names, old_names)
[13:36:41.364]                 added <- setdiff(names, old_names)
[13:36:41.364]                 removed <- setdiff(old_names, names)
[13:36:41.364]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:41.364]                   envs[common]]
[13:36:41.364]                 NAMES <- toupper(changed)
[13:36:41.364]                 args <- list()
[13:36:41.364]                 for (kk in seq_along(NAMES)) {
[13:36:41.364]                   name <- changed[[kk]]
[13:36:41.364]                   NAME <- NAMES[[kk]]
[13:36:41.364]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.364]                     next
[13:36:41.364]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.364]                 }
[13:36:41.364]                 NAMES <- toupper(added)
[13:36:41.364]                 for (kk in seq_along(NAMES)) {
[13:36:41.364]                   name <- added[[kk]]
[13:36:41.364]                   NAME <- NAMES[[kk]]
[13:36:41.364]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.364]                     next
[13:36:41.364]                   args[[name]] <- ""
[13:36:41.364]                 }
[13:36:41.364]                 NAMES <- toupper(removed)
[13:36:41.364]                 for (kk in seq_along(NAMES)) {
[13:36:41.364]                   name <- removed[[kk]]
[13:36:41.364]                   NAME <- NAMES[[kk]]
[13:36:41.364]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.364]                     next
[13:36:41.364]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.364]                 }
[13:36:41.364]                 if (length(args) > 0) 
[13:36:41.364]                   base::do.call(base::Sys.setenv, args = args)
[13:36:41.364]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:41.364]             }
[13:36:41.364]             else {
[13:36:41.364]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:41.364]             }
[13:36:41.364]             {
[13:36:41.364]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:41.364]                   0L) {
[13:36:41.364]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:41.364]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:41.364]                   base::options(opts)
[13:36:41.364]                 }
[13:36:41.364]                 {
[13:36:41.364]                   {
[13:36:41.364]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:41.364]                     NULL
[13:36:41.364]                   }
[13:36:41.364]                   options(future.plan = NULL)
[13:36:41.364]                   if (is.na(NA_character_)) 
[13:36:41.364]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.364]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:41.364]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:41.364]                     .init = FALSE)
[13:36:41.364]                 }
[13:36:41.364]             }
[13:36:41.364]         }
[13:36:41.364]     })
[13:36:41.364]     if (TRUE) {
[13:36:41.364]         base::sink(type = "output", split = FALSE)
[13:36:41.364]         if (TRUE) {
[13:36:41.364]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:41.364]         }
[13:36:41.364]         else {
[13:36:41.364]             ...future.result["stdout"] <- base::list(NULL)
[13:36:41.364]         }
[13:36:41.364]         base::close(...future.stdout)
[13:36:41.364]         ...future.stdout <- NULL
[13:36:41.364]     }
[13:36:41.364]     ...future.result$conditions <- ...future.conditions
[13:36:41.364]     ...future.result$finished <- base::Sys.time()
[13:36:41.364]     ...future.result
[13:36:41.364] }
[13:36:41.367] requestCore(): workers = 2
[13:36:41.369] MulticoreFuture started
[13:36:41.369] - Launch lazy future ... done
[13:36:41.369] run() for ‘MulticoreFuture’ ... done
[13:36:41.369] result() for MulticoreFuture ...
[13:36:41.370] plan(): Setting new future strategy stack:
[13:36:41.370] List of future strategies:
[13:36:41.370] 1. sequential:
[13:36:41.370]    - args: function (..., envir = parent.frame())
[13:36:41.370]    - tweaked: FALSE
[13:36:41.370]    - call: NULL
[13:36:41.371] plan(): nbrOfWorkers() = 1
[13:36:41.375] plan(): Setting new future strategy stack:
[13:36:41.375] List of future strategies:
[13:36:41.375] 1. multicore:
[13:36:41.375]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:41.375]    - tweaked: FALSE
[13:36:41.375]    - call: plan(strategy)
[13:36:41.380] plan(): nbrOfWorkers() = 2
[13:36:41.382] result() for MulticoreFuture ...
[13:36:41.382] result() for MulticoreFuture ... done
[13:36:41.382] result() for MulticoreFuture ... done
[13:36:41.382] result() for MulticoreFuture ...
[13:36:41.383] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[13:36:41.387] getGlobalsAndPackages() ...
[13:36:41.387] Searching for globals...
[13:36:41.392] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[13:36:41.392] Searching for globals ... DONE
[13:36:41.392] Resolving globals: FALSE
[13:36:41.393] 
[13:36:41.394] - packages: [2] ‘stats’, ‘datasets’
[13:36:41.394] getGlobalsAndPackages() ... DONE
[13:36:41.394] run() for ‘Future’ ...
[13:36:41.394] - state: ‘created’
[13:36:41.395] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:41.399] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:41.399] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:41.399]   - Field: ‘label’
[13:36:41.399]   - Field: ‘local’
[13:36:41.399]   - Field: ‘owner’
[13:36:41.399]   - Field: ‘envir’
[13:36:41.399]   - Field: ‘workers’
[13:36:41.399]   - Field: ‘packages’
[13:36:41.400]   - Field: ‘gc’
[13:36:41.400]   - Field: ‘job’
[13:36:41.400]   - Field: ‘conditions’
[13:36:41.400]   - Field: ‘expr’
[13:36:41.400]   - Field: ‘uuid’
[13:36:41.400]   - Field: ‘seed’
[13:36:41.400]   - Field: ‘version’
[13:36:41.400]   - Field: ‘result’
[13:36:41.400]   - Field: ‘asynchronous’
[13:36:41.401]   - Field: ‘calls’
[13:36:41.401]   - Field: ‘globals’
[13:36:41.401]   - Field: ‘stdout’
[13:36:41.401]   - Field: ‘earlySignal’
[13:36:41.401]   - Field: ‘lazy’
[13:36:41.401]   - Field: ‘state’
[13:36:41.401] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:41.401] - Launch lazy future ...
[13:36:41.402] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:36:41.402] Packages needed by future strategies (n = 0): <none>
[13:36:41.402] {
[13:36:41.402]     {
[13:36:41.402]         {
[13:36:41.402]             ...future.startTime <- base::Sys.time()
[13:36:41.402]             {
[13:36:41.402]                 {
[13:36:41.402]                   {
[13:36:41.402]                     {
[13:36:41.402]                       {
[13:36:41.402]                         base::local({
[13:36:41.402]                           has_future <- base::requireNamespace("future", 
[13:36:41.402]                             quietly = TRUE)
[13:36:41.402]                           if (has_future) {
[13:36:41.402]                             ns <- base::getNamespace("future")
[13:36:41.402]                             version <- ns[[".package"]][["version"]]
[13:36:41.402]                             if (is.null(version)) 
[13:36:41.402]                               version <- utils::packageVersion("future")
[13:36:41.402]                           }
[13:36:41.402]                           else {
[13:36:41.402]                             version <- NULL
[13:36:41.402]                           }
[13:36:41.402]                           if (!has_future || version < "1.8.0") {
[13:36:41.402]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:41.402]                               "", base::R.version$version.string), 
[13:36:41.402]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:41.402]                                 base::R.version$platform, 8 * 
[13:36:41.402]                                   base::.Machine$sizeof.pointer), 
[13:36:41.402]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:41.402]                                 "release", "version")], collapse = " "), 
[13:36:41.402]                               hostname = base::Sys.info()[["nodename"]])
[13:36:41.402]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:41.402]                               info)
[13:36:41.402]                             info <- base::paste(info, collapse = "; ")
[13:36:41.402]                             if (!has_future) {
[13:36:41.402]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:41.402]                                 info)
[13:36:41.402]                             }
[13:36:41.402]                             else {
[13:36:41.402]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:41.402]                                 info, version)
[13:36:41.402]                             }
[13:36:41.402]                             base::stop(msg)
[13:36:41.402]                           }
[13:36:41.402]                         })
[13:36:41.402]                       }
[13:36:41.402]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:41.402]                       base::options(mc.cores = 1L)
[13:36:41.402]                     }
[13:36:41.402]                     base::local({
[13:36:41.402]                       for (pkg in c("stats", "datasets")) {
[13:36:41.402]                         base::loadNamespace(pkg)
[13:36:41.402]                         base::library(pkg, character.only = TRUE)
[13:36:41.402]                       }
[13:36:41.402]                     })
[13:36:41.402]                   }
[13:36:41.402]                   ...future.strategy.old <- future::plan("list")
[13:36:41.402]                   options(future.plan = NULL)
[13:36:41.402]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.402]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:41.402]                 }
[13:36:41.402]                 ...future.workdir <- getwd()
[13:36:41.402]             }
[13:36:41.402]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:41.402]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:41.402]         }
[13:36:41.402]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:41.402]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:41.402]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:41.402]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:41.402]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:41.402]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:41.402]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:41.402]             base::names(...future.oldOptions))
[13:36:41.402]     }
[13:36:41.402]     if (FALSE) {
[13:36:41.402]     }
[13:36:41.402]     else {
[13:36:41.402]         if (TRUE) {
[13:36:41.402]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:41.402]                 open = "w")
[13:36:41.402]         }
[13:36:41.402]         else {
[13:36:41.402]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:41.402]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:41.402]         }
[13:36:41.402]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:41.402]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:41.402]             base::sink(type = "output", split = FALSE)
[13:36:41.402]             base::close(...future.stdout)
[13:36:41.402]         }, add = TRUE)
[13:36:41.402]     }
[13:36:41.402]     ...future.frame <- base::sys.nframe()
[13:36:41.402]     ...future.conditions <- base::list()
[13:36:41.402]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:41.402]     if (FALSE) {
[13:36:41.402]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:41.402]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:41.402]     }
[13:36:41.402]     ...future.result <- base::tryCatch({
[13:36:41.402]         base::withCallingHandlers({
[13:36:41.402]             ...future.value <- base::withVisible(base::local({
[13:36:41.402]                 withCallingHandlers({
[13:36:41.402]                   {
[13:36:41.402]                     lm(dist ~ speed + I(speed^2), data = cars)
[13:36:41.402]                   }
[13:36:41.402]                 }, immediateCondition = function(cond) {
[13:36:41.402]                   save_rds <- function (object, pathname, ...) 
[13:36:41.402]                   {
[13:36:41.402]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:41.402]                     if (file_test("-f", pathname_tmp)) {
[13:36:41.402]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.402]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:41.402]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.402]                         fi_tmp[["mtime"]])
[13:36:41.402]                     }
[13:36:41.402]                     tryCatch({
[13:36:41.402]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:41.402]                     }, error = function(ex) {
[13:36:41.402]                       msg <- conditionMessage(ex)
[13:36:41.402]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.402]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:41.402]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.402]                         fi_tmp[["mtime"]], msg)
[13:36:41.402]                       ex$message <- msg
[13:36:41.402]                       stop(ex)
[13:36:41.402]                     })
[13:36:41.402]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:41.402]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:41.402]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:41.402]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.402]                       fi <- file.info(pathname)
[13:36:41.402]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:41.402]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.402]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:41.402]                         fi[["size"]], fi[["mtime"]])
[13:36:41.402]                       stop(msg)
[13:36:41.402]                     }
[13:36:41.402]                     invisible(pathname)
[13:36:41.402]                   }
[13:36:41.402]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:41.402]                     rootPath = tempdir()) 
[13:36:41.402]                   {
[13:36:41.402]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:41.402]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:41.402]                       tmpdir = path, fileext = ".rds")
[13:36:41.402]                     save_rds(obj, file)
[13:36:41.402]                   }
[13:36:41.402]                   saveImmediateCondition(cond, path = "/tmp/RtmphVqFyZ/.future/immediateConditions")
[13:36:41.402]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.402]                   {
[13:36:41.402]                     inherits <- base::inherits
[13:36:41.402]                     invokeRestart <- base::invokeRestart
[13:36:41.402]                     is.null <- base::is.null
[13:36:41.402]                     muffled <- FALSE
[13:36:41.402]                     if (inherits(cond, "message")) {
[13:36:41.402]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:41.402]                       if (muffled) 
[13:36:41.402]                         invokeRestart("muffleMessage")
[13:36:41.402]                     }
[13:36:41.402]                     else if (inherits(cond, "warning")) {
[13:36:41.402]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:41.402]                       if (muffled) 
[13:36:41.402]                         invokeRestart("muffleWarning")
[13:36:41.402]                     }
[13:36:41.402]                     else if (inherits(cond, "condition")) {
[13:36:41.402]                       if (!is.null(pattern)) {
[13:36:41.402]                         computeRestarts <- base::computeRestarts
[13:36:41.402]                         grepl <- base::grepl
[13:36:41.402]                         restarts <- computeRestarts(cond)
[13:36:41.402]                         for (restart in restarts) {
[13:36:41.402]                           name <- restart$name
[13:36:41.402]                           if (is.null(name)) 
[13:36:41.402]                             next
[13:36:41.402]                           if (!grepl(pattern, name)) 
[13:36:41.402]                             next
[13:36:41.402]                           invokeRestart(restart)
[13:36:41.402]                           muffled <- TRUE
[13:36:41.402]                           break
[13:36:41.402]                         }
[13:36:41.402]                       }
[13:36:41.402]                     }
[13:36:41.402]                     invisible(muffled)
[13:36:41.402]                   }
[13:36:41.402]                   muffleCondition(cond)
[13:36:41.402]                 })
[13:36:41.402]             }))
[13:36:41.402]             future::FutureResult(value = ...future.value$value, 
[13:36:41.402]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.402]                   ...future.rng), globalenv = if (FALSE) 
[13:36:41.402]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:41.402]                     ...future.globalenv.names))
[13:36:41.402]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:41.402]         }, condition = base::local({
[13:36:41.402]             c <- base::c
[13:36:41.402]             inherits <- base::inherits
[13:36:41.402]             invokeRestart <- base::invokeRestart
[13:36:41.402]             length <- base::length
[13:36:41.402]             list <- base::list
[13:36:41.402]             seq.int <- base::seq.int
[13:36:41.402]             signalCondition <- base::signalCondition
[13:36:41.402]             sys.calls <- base::sys.calls
[13:36:41.402]             `[[` <- base::`[[`
[13:36:41.402]             `+` <- base::`+`
[13:36:41.402]             `<<-` <- base::`<<-`
[13:36:41.402]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:41.402]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:41.402]                   3L)]
[13:36:41.402]             }
[13:36:41.402]             function(cond) {
[13:36:41.402]                 is_error <- inherits(cond, "error")
[13:36:41.402]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:41.402]                   NULL)
[13:36:41.402]                 if (is_error) {
[13:36:41.402]                   sessionInformation <- function() {
[13:36:41.402]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:41.402]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:41.402]                       search = base::search(), system = base::Sys.info())
[13:36:41.402]                   }
[13:36:41.402]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.402]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:41.402]                     cond$call), session = sessionInformation(), 
[13:36:41.402]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:41.402]                   signalCondition(cond)
[13:36:41.402]                 }
[13:36:41.402]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:41.402]                 "immediateCondition"))) {
[13:36:41.402]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:41.402]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.402]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:41.402]                   if (TRUE && !signal) {
[13:36:41.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.402]                     {
[13:36:41.402]                       inherits <- base::inherits
[13:36:41.402]                       invokeRestart <- base::invokeRestart
[13:36:41.402]                       is.null <- base::is.null
[13:36:41.402]                       muffled <- FALSE
[13:36:41.402]                       if (inherits(cond, "message")) {
[13:36:41.402]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.402]                         if (muffled) 
[13:36:41.402]                           invokeRestart("muffleMessage")
[13:36:41.402]                       }
[13:36:41.402]                       else if (inherits(cond, "warning")) {
[13:36:41.402]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.402]                         if (muffled) 
[13:36:41.402]                           invokeRestart("muffleWarning")
[13:36:41.402]                       }
[13:36:41.402]                       else if (inherits(cond, "condition")) {
[13:36:41.402]                         if (!is.null(pattern)) {
[13:36:41.402]                           computeRestarts <- base::computeRestarts
[13:36:41.402]                           grepl <- base::grepl
[13:36:41.402]                           restarts <- computeRestarts(cond)
[13:36:41.402]                           for (restart in restarts) {
[13:36:41.402]                             name <- restart$name
[13:36:41.402]                             if (is.null(name)) 
[13:36:41.402]                               next
[13:36:41.402]                             if (!grepl(pattern, name)) 
[13:36:41.402]                               next
[13:36:41.402]                             invokeRestart(restart)
[13:36:41.402]                             muffled <- TRUE
[13:36:41.402]                             break
[13:36:41.402]                           }
[13:36:41.402]                         }
[13:36:41.402]                       }
[13:36:41.402]                       invisible(muffled)
[13:36:41.402]                     }
[13:36:41.402]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.402]                   }
[13:36:41.402]                 }
[13:36:41.402]                 else {
[13:36:41.402]                   if (TRUE) {
[13:36:41.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.402]                     {
[13:36:41.402]                       inherits <- base::inherits
[13:36:41.402]                       invokeRestart <- base::invokeRestart
[13:36:41.402]                       is.null <- base::is.null
[13:36:41.402]                       muffled <- FALSE
[13:36:41.402]                       if (inherits(cond, "message")) {
[13:36:41.402]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.402]                         if (muffled) 
[13:36:41.402]                           invokeRestart("muffleMessage")
[13:36:41.402]                       }
[13:36:41.402]                       else if (inherits(cond, "warning")) {
[13:36:41.402]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.402]                         if (muffled) 
[13:36:41.402]                           invokeRestart("muffleWarning")
[13:36:41.402]                       }
[13:36:41.402]                       else if (inherits(cond, "condition")) {
[13:36:41.402]                         if (!is.null(pattern)) {
[13:36:41.402]                           computeRestarts <- base::computeRestarts
[13:36:41.402]                           grepl <- base::grepl
[13:36:41.402]                           restarts <- computeRestarts(cond)
[13:36:41.402]                           for (restart in restarts) {
[13:36:41.402]                             name <- restart$name
[13:36:41.402]                             if (is.null(name)) 
[13:36:41.402]                               next
[13:36:41.402]                             if (!grepl(pattern, name)) 
[13:36:41.402]                               next
[13:36:41.402]                             invokeRestart(restart)
[13:36:41.402]                             muffled <- TRUE
[13:36:41.402]                             break
[13:36:41.402]                           }
[13:36:41.402]                         }
[13:36:41.402]                       }
[13:36:41.402]                       invisible(muffled)
[13:36:41.402]                     }
[13:36:41.402]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.402]                   }
[13:36:41.402]                 }
[13:36:41.402]             }
[13:36:41.402]         }))
[13:36:41.402]     }, error = function(ex) {
[13:36:41.402]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:41.402]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.402]                 ...future.rng), started = ...future.startTime, 
[13:36:41.402]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:41.402]             version = "1.8"), class = "FutureResult")
[13:36:41.402]     }, finally = {
[13:36:41.402]         if (!identical(...future.workdir, getwd())) 
[13:36:41.402]             setwd(...future.workdir)
[13:36:41.402]         {
[13:36:41.402]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:41.402]                 ...future.oldOptions$nwarnings <- NULL
[13:36:41.402]             }
[13:36:41.402]             base::options(...future.oldOptions)
[13:36:41.402]             if (.Platform$OS.type == "windows") {
[13:36:41.402]                 old_names <- names(...future.oldEnvVars)
[13:36:41.402]                 envs <- base::Sys.getenv()
[13:36:41.402]                 names <- names(envs)
[13:36:41.402]                 common <- intersect(names, old_names)
[13:36:41.402]                 added <- setdiff(names, old_names)
[13:36:41.402]                 removed <- setdiff(old_names, names)
[13:36:41.402]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:41.402]                   envs[common]]
[13:36:41.402]                 NAMES <- toupper(changed)
[13:36:41.402]                 args <- list()
[13:36:41.402]                 for (kk in seq_along(NAMES)) {
[13:36:41.402]                   name <- changed[[kk]]
[13:36:41.402]                   NAME <- NAMES[[kk]]
[13:36:41.402]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.402]                     next
[13:36:41.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.402]                 }
[13:36:41.402]                 NAMES <- toupper(added)
[13:36:41.402]                 for (kk in seq_along(NAMES)) {
[13:36:41.402]                   name <- added[[kk]]
[13:36:41.402]                   NAME <- NAMES[[kk]]
[13:36:41.402]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.402]                     next
[13:36:41.402]                   args[[name]] <- ""
[13:36:41.402]                 }
[13:36:41.402]                 NAMES <- toupper(removed)
[13:36:41.402]                 for (kk in seq_along(NAMES)) {
[13:36:41.402]                   name <- removed[[kk]]
[13:36:41.402]                   NAME <- NAMES[[kk]]
[13:36:41.402]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.402]                     next
[13:36:41.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.402]                 }
[13:36:41.402]                 if (length(args) > 0) 
[13:36:41.402]                   base::do.call(base::Sys.setenv, args = args)
[13:36:41.402]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:41.402]             }
[13:36:41.402]             else {
[13:36:41.402]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:41.402]             }
[13:36:41.402]             {
[13:36:41.402]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:41.402]                   0L) {
[13:36:41.402]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:41.402]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:41.402]                   base::options(opts)
[13:36:41.402]                 }
[13:36:41.402]                 {
[13:36:41.402]                   {
[13:36:41.402]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:41.402]                     NULL
[13:36:41.402]                   }
[13:36:41.402]                   options(future.plan = NULL)
[13:36:41.402]                   if (is.na(NA_character_)) 
[13:36:41.402]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.402]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:41.402]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:41.402]                     .init = FALSE)
[13:36:41.402]                 }
[13:36:41.402]             }
[13:36:41.402]         }
[13:36:41.402]     })
[13:36:41.402]     if (TRUE) {
[13:36:41.402]         base::sink(type = "output", split = FALSE)
[13:36:41.402]         if (TRUE) {
[13:36:41.402]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:41.402]         }
[13:36:41.402]         else {
[13:36:41.402]             ...future.result["stdout"] <- base::list(NULL)
[13:36:41.402]         }
[13:36:41.402]         base::close(...future.stdout)
[13:36:41.402]         ...future.stdout <- NULL
[13:36:41.402]     }
[13:36:41.402]     ...future.result$conditions <- ...future.conditions
[13:36:41.402]     ...future.result$finished <- base::Sys.time()
[13:36:41.402]     ...future.result
[13:36:41.402] }
[13:36:41.405] requestCore(): workers = 2
[13:36:41.407] MulticoreFuture started
[13:36:41.407] - Launch lazy future ... done
[13:36:41.407] run() for ‘MulticoreFuture’ ... done
[13:36:41.408] result() for MulticoreFuture ...
[13:36:41.408] plan(): Setting new future strategy stack:
[13:36:41.408] List of future strategies:
[13:36:41.408] 1. sequential:
[13:36:41.408]    - args: function (..., envir = parent.frame())
[13:36:41.408]    - tweaked: FALSE
[13:36:41.408]    - call: NULL
[13:36:41.409] plan(): nbrOfWorkers() = 1
[13:36:41.413] plan(): Setting new future strategy stack:
[13:36:41.413] List of future strategies:
[13:36:41.413] 1. multicore:
[13:36:41.413]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:41.413]    - tweaked: FALSE
[13:36:41.413]    - call: plan(strategy)
[13:36:41.418] plan(): nbrOfWorkers() = 2
[13:36:41.420] result() for MulticoreFuture ...
[13:36:41.421] result() for MulticoreFuture ... done
[13:36:41.421] result() for MulticoreFuture ... done
[13:36:41.421] result() for MulticoreFuture ...
[13:36:41.421] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[13:36:41.425] getGlobalsAndPackages() ...
[13:36:41.425] Searching for globals...
[13:36:41.427] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[13:36:41.427] Searching for globals ... DONE
[13:36:41.428] Resolving globals: FALSE
[13:36:41.428] 
[13:36:41.428] - packages: [2] ‘stats’, ‘datasets’
[13:36:41.428] getGlobalsAndPackages() ... DONE
[13:36:41.429] run() for ‘Future’ ...
[13:36:41.429] - state: ‘created’
[13:36:41.429] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:41.433] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:41.433] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:41.433]   - Field: ‘label’
[13:36:41.433]   - Field: ‘local’
[13:36:41.434]   - Field: ‘owner’
[13:36:41.434]   - Field: ‘envir’
[13:36:41.434]   - Field: ‘workers’
[13:36:41.434]   - Field: ‘packages’
[13:36:41.434]   - Field: ‘gc’
[13:36:41.434]   - Field: ‘job’
[13:36:41.434]   - Field: ‘conditions’
[13:36:41.434]   - Field: ‘expr’
[13:36:41.435]   - Field: ‘uuid’
[13:36:41.435]   - Field: ‘seed’
[13:36:41.435]   - Field: ‘version’
[13:36:41.435]   - Field: ‘result’
[13:36:41.435]   - Field: ‘asynchronous’
[13:36:41.435]   - Field: ‘calls’
[13:36:41.435]   - Field: ‘globals’
[13:36:41.435]   - Field: ‘stdout’
[13:36:41.435]   - Field: ‘earlySignal’
[13:36:41.436]   - Field: ‘lazy’
[13:36:41.436]   - Field: ‘state’
[13:36:41.436] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:41.436] - Launch lazy future ...
[13:36:41.436] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:36:41.436] Packages needed by future strategies (n = 0): <none>
[13:36:41.437] {
[13:36:41.437]     {
[13:36:41.437]         {
[13:36:41.437]             ...future.startTime <- base::Sys.time()
[13:36:41.437]             {
[13:36:41.437]                 {
[13:36:41.437]                   {
[13:36:41.437]                     {
[13:36:41.437]                       {
[13:36:41.437]                         base::local({
[13:36:41.437]                           has_future <- base::requireNamespace("future", 
[13:36:41.437]                             quietly = TRUE)
[13:36:41.437]                           if (has_future) {
[13:36:41.437]                             ns <- base::getNamespace("future")
[13:36:41.437]                             version <- ns[[".package"]][["version"]]
[13:36:41.437]                             if (is.null(version)) 
[13:36:41.437]                               version <- utils::packageVersion("future")
[13:36:41.437]                           }
[13:36:41.437]                           else {
[13:36:41.437]                             version <- NULL
[13:36:41.437]                           }
[13:36:41.437]                           if (!has_future || version < "1.8.0") {
[13:36:41.437]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:41.437]                               "", base::R.version$version.string), 
[13:36:41.437]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:41.437]                                 base::R.version$platform, 8 * 
[13:36:41.437]                                   base::.Machine$sizeof.pointer), 
[13:36:41.437]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:41.437]                                 "release", "version")], collapse = " "), 
[13:36:41.437]                               hostname = base::Sys.info()[["nodename"]])
[13:36:41.437]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:41.437]                               info)
[13:36:41.437]                             info <- base::paste(info, collapse = "; ")
[13:36:41.437]                             if (!has_future) {
[13:36:41.437]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:41.437]                                 info)
[13:36:41.437]                             }
[13:36:41.437]                             else {
[13:36:41.437]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:41.437]                                 info, version)
[13:36:41.437]                             }
[13:36:41.437]                             base::stop(msg)
[13:36:41.437]                           }
[13:36:41.437]                         })
[13:36:41.437]                       }
[13:36:41.437]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:41.437]                       base::options(mc.cores = 1L)
[13:36:41.437]                     }
[13:36:41.437]                     base::local({
[13:36:41.437]                       for (pkg in c("stats", "datasets")) {
[13:36:41.437]                         base::loadNamespace(pkg)
[13:36:41.437]                         base::library(pkg, character.only = TRUE)
[13:36:41.437]                       }
[13:36:41.437]                     })
[13:36:41.437]                   }
[13:36:41.437]                   ...future.strategy.old <- future::plan("list")
[13:36:41.437]                   options(future.plan = NULL)
[13:36:41.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:41.437]                 }
[13:36:41.437]                 ...future.workdir <- getwd()
[13:36:41.437]             }
[13:36:41.437]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:41.437]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:41.437]         }
[13:36:41.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:41.437]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:41.437]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:41.437]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:41.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:41.437]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:41.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:41.437]             base::names(...future.oldOptions))
[13:36:41.437]     }
[13:36:41.437]     if (FALSE) {
[13:36:41.437]     }
[13:36:41.437]     else {
[13:36:41.437]         if (TRUE) {
[13:36:41.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:41.437]                 open = "w")
[13:36:41.437]         }
[13:36:41.437]         else {
[13:36:41.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:41.437]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:41.437]         }
[13:36:41.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:41.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:41.437]             base::sink(type = "output", split = FALSE)
[13:36:41.437]             base::close(...future.stdout)
[13:36:41.437]         }, add = TRUE)
[13:36:41.437]     }
[13:36:41.437]     ...future.frame <- base::sys.nframe()
[13:36:41.437]     ...future.conditions <- base::list()
[13:36:41.437]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:41.437]     if (FALSE) {
[13:36:41.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:41.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:41.437]     }
[13:36:41.437]     ...future.result <- base::tryCatch({
[13:36:41.437]         base::withCallingHandlers({
[13:36:41.437]             ...future.value <- base::withVisible(base::local({
[13:36:41.437]                 withCallingHandlers({
[13:36:41.437]                   {
[13:36:41.437]                     lm(dist ~ poly(speed, 2), data = cars)
[13:36:41.437]                   }
[13:36:41.437]                 }, immediateCondition = function(cond) {
[13:36:41.437]                   save_rds <- function (object, pathname, ...) 
[13:36:41.437]                   {
[13:36:41.437]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:41.437]                     if (file_test("-f", pathname_tmp)) {
[13:36:41.437]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.437]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:41.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.437]                         fi_tmp[["mtime"]])
[13:36:41.437]                     }
[13:36:41.437]                     tryCatch({
[13:36:41.437]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:41.437]                     }, error = function(ex) {
[13:36:41.437]                       msg <- conditionMessage(ex)
[13:36:41.437]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.437]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:41.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.437]                         fi_tmp[["mtime"]], msg)
[13:36:41.437]                       ex$message <- msg
[13:36:41.437]                       stop(ex)
[13:36:41.437]                     })
[13:36:41.437]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:41.437]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:41.437]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:41.437]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.437]                       fi <- file.info(pathname)
[13:36:41.437]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:41.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.437]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:41.437]                         fi[["size"]], fi[["mtime"]])
[13:36:41.437]                       stop(msg)
[13:36:41.437]                     }
[13:36:41.437]                     invisible(pathname)
[13:36:41.437]                   }
[13:36:41.437]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:41.437]                     rootPath = tempdir()) 
[13:36:41.437]                   {
[13:36:41.437]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:41.437]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:41.437]                       tmpdir = path, fileext = ".rds")
[13:36:41.437]                     save_rds(obj, file)
[13:36:41.437]                   }
[13:36:41.437]                   saveImmediateCondition(cond, path = "/tmp/RtmphVqFyZ/.future/immediateConditions")
[13:36:41.437]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.437]                   {
[13:36:41.437]                     inherits <- base::inherits
[13:36:41.437]                     invokeRestart <- base::invokeRestart
[13:36:41.437]                     is.null <- base::is.null
[13:36:41.437]                     muffled <- FALSE
[13:36:41.437]                     if (inherits(cond, "message")) {
[13:36:41.437]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:41.437]                       if (muffled) 
[13:36:41.437]                         invokeRestart("muffleMessage")
[13:36:41.437]                     }
[13:36:41.437]                     else if (inherits(cond, "warning")) {
[13:36:41.437]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:41.437]                       if (muffled) 
[13:36:41.437]                         invokeRestart("muffleWarning")
[13:36:41.437]                     }
[13:36:41.437]                     else if (inherits(cond, "condition")) {
[13:36:41.437]                       if (!is.null(pattern)) {
[13:36:41.437]                         computeRestarts <- base::computeRestarts
[13:36:41.437]                         grepl <- base::grepl
[13:36:41.437]                         restarts <- computeRestarts(cond)
[13:36:41.437]                         for (restart in restarts) {
[13:36:41.437]                           name <- restart$name
[13:36:41.437]                           if (is.null(name)) 
[13:36:41.437]                             next
[13:36:41.437]                           if (!grepl(pattern, name)) 
[13:36:41.437]                             next
[13:36:41.437]                           invokeRestart(restart)
[13:36:41.437]                           muffled <- TRUE
[13:36:41.437]                           break
[13:36:41.437]                         }
[13:36:41.437]                       }
[13:36:41.437]                     }
[13:36:41.437]                     invisible(muffled)
[13:36:41.437]                   }
[13:36:41.437]                   muffleCondition(cond)
[13:36:41.437]                 })
[13:36:41.437]             }))
[13:36:41.437]             future::FutureResult(value = ...future.value$value, 
[13:36:41.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.437]                   ...future.rng), globalenv = if (FALSE) 
[13:36:41.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:41.437]                     ...future.globalenv.names))
[13:36:41.437]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:41.437]         }, condition = base::local({
[13:36:41.437]             c <- base::c
[13:36:41.437]             inherits <- base::inherits
[13:36:41.437]             invokeRestart <- base::invokeRestart
[13:36:41.437]             length <- base::length
[13:36:41.437]             list <- base::list
[13:36:41.437]             seq.int <- base::seq.int
[13:36:41.437]             signalCondition <- base::signalCondition
[13:36:41.437]             sys.calls <- base::sys.calls
[13:36:41.437]             `[[` <- base::`[[`
[13:36:41.437]             `+` <- base::`+`
[13:36:41.437]             `<<-` <- base::`<<-`
[13:36:41.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:41.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:41.437]                   3L)]
[13:36:41.437]             }
[13:36:41.437]             function(cond) {
[13:36:41.437]                 is_error <- inherits(cond, "error")
[13:36:41.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:41.437]                   NULL)
[13:36:41.437]                 if (is_error) {
[13:36:41.437]                   sessionInformation <- function() {
[13:36:41.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:41.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:41.437]                       search = base::search(), system = base::Sys.info())
[13:36:41.437]                   }
[13:36:41.437]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:41.437]                     cond$call), session = sessionInformation(), 
[13:36:41.437]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:41.437]                   signalCondition(cond)
[13:36:41.437]                 }
[13:36:41.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:41.437]                 "immediateCondition"))) {
[13:36:41.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:41.437]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:41.437]                   if (TRUE && !signal) {
[13:36:41.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.437]                     {
[13:36:41.437]                       inherits <- base::inherits
[13:36:41.437]                       invokeRestart <- base::invokeRestart
[13:36:41.437]                       is.null <- base::is.null
[13:36:41.437]                       muffled <- FALSE
[13:36:41.437]                       if (inherits(cond, "message")) {
[13:36:41.437]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.437]                         if (muffled) 
[13:36:41.437]                           invokeRestart("muffleMessage")
[13:36:41.437]                       }
[13:36:41.437]                       else if (inherits(cond, "warning")) {
[13:36:41.437]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.437]                         if (muffled) 
[13:36:41.437]                           invokeRestart("muffleWarning")
[13:36:41.437]                       }
[13:36:41.437]                       else if (inherits(cond, "condition")) {
[13:36:41.437]                         if (!is.null(pattern)) {
[13:36:41.437]                           computeRestarts <- base::computeRestarts
[13:36:41.437]                           grepl <- base::grepl
[13:36:41.437]                           restarts <- computeRestarts(cond)
[13:36:41.437]                           for (restart in restarts) {
[13:36:41.437]                             name <- restart$name
[13:36:41.437]                             if (is.null(name)) 
[13:36:41.437]                               next
[13:36:41.437]                             if (!grepl(pattern, name)) 
[13:36:41.437]                               next
[13:36:41.437]                             invokeRestart(restart)
[13:36:41.437]                             muffled <- TRUE
[13:36:41.437]                             break
[13:36:41.437]                           }
[13:36:41.437]                         }
[13:36:41.437]                       }
[13:36:41.437]                       invisible(muffled)
[13:36:41.437]                     }
[13:36:41.437]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.437]                   }
[13:36:41.437]                 }
[13:36:41.437]                 else {
[13:36:41.437]                   if (TRUE) {
[13:36:41.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.437]                     {
[13:36:41.437]                       inherits <- base::inherits
[13:36:41.437]                       invokeRestart <- base::invokeRestart
[13:36:41.437]                       is.null <- base::is.null
[13:36:41.437]                       muffled <- FALSE
[13:36:41.437]                       if (inherits(cond, "message")) {
[13:36:41.437]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.437]                         if (muffled) 
[13:36:41.437]                           invokeRestart("muffleMessage")
[13:36:41.437]                       }
[13:36:41.437]                       else if (inherits(cond, "warning")) {
[13:36:41.437]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.437]                         if (muffled) 
[13:36:41.437]                           invokeRestart("muffleWarning")
[13:36:41.437]                       }
[13:36:41.437]                       else if (inherits(cond, "condition")) {
[13:36:41.437]                         if (!is.null(pattern)) {
[13:36:41.437]                           computeRestarts <- base::computeRestarts
[13:36:41.437]                           grepl <- base::grepl
[13:36:41.437]                           restarts <- computeRestarts(cond)
[13:36:41.437]                           for (restart in restarts) {
[13:36:41.437]                             name <- restart$name
[13:36:41.437]                             if (is.null(name)) 
[13:36:41.437]                               next
[13:36:41.437]                             if (!grepl(pattern, name)) 
[13:36:41.437]                               next
[13:36:41.437]                             invokeRestart(restart)
[13:36:41.437]                             muffled <- TRUE
[13:36:41.437]                             break
[13:36:41.437]                           }
[13:36:41.437]                         }
[13:36:41.437]                       }
[13:36:41.437]                       invisible(muffled)
[13:36:41.437]                     }
[13:36:41.437]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.437]                   }
[13:36:41.437]                 }
[13:36:41.437]             }
[13:36:41.437]         }))
[13:36:41.437]     }, error = function(ex) {
[13:36:41.437]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:41.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.437]                 ...future.rng), started = ...future.startTime, 
[13:36:41.437]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:41.437]             version = "1.8"), class = "FutureResult")
[13:36:41.437]     }, finally = {
[13:36:41.437]         if (!identical(...future.workdir, getwd())) 
[13:36:41.437]             setwd(...future.workdir)
[13:36:41.437]         {
[13:36:41.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:41.437]                 ...future.oldOptions$nwarnings <- NULL
[13:36:41.437]             }
[13:36:41.437]             base::options(...future.oldOptions)
[13:36:41.437]             if (.Platform$OS.type == "windows") {
[13:36:41.437]                 old_names <- names(...future.oldEnvVars)
[13:36:41.437]                 envs <- base::Sys.getenv()
[13:36:41.437]                 names <- names(envs)
[13:36:41.437]                 common <- intersect(names, old_names)
[13:36:41.437]                 added <- setdiff(names, old_names)
[13:36:41.437]                 removed <- setdiff(old_names, names)
[13:36:41.437]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:41.437]                   envs[common]]
[13:36:41.437]                 NAMES <- toupper(changed)
[13:36:41.437]                 args <- list()
[13:36:41.437]                 for (kk in seq_along(NAMES)) {
[13:36:41.437]                   name <- changed[[kk]]
[13:36:41.437]                   NAME <- NAMES[[kk]]
[13:36:41.437]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.437]                     next
[13:36:41.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.437]                 }
[13:36:41.437]                 NAMES <- toupper(added)
[13:36:41.437]                 for (kk in seq_along(NAMES)) {
[13:36:41.437]                   name <- added[[kk]]
[13:36:41.437]                   NAME <- NAMES[[kk]]
[13:36:41.437]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.437]                     next
[13:36:41.437]                   args[[name]] <- ""
[13:36:41.437]                 }
[13:36:41.437]                 NAMES <- toupper(removed)
[13:36:41.437]                 for (kk in seq_along(NAMES)) {
[13:36:41.437]                   name <- removed[[kk]]
[13:36:41.437]                   NAME <- NAMES[[kk]]
[13:36:41.437]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.437]                     next
[13:36:41.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.437]                 }
[13:36:41.437]                 if (length(args) > 0) 
[13:36:41.437]                   base::do.call(base::Sys.setenv, args = args)
[13:36:41.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:41.437]             }
[13:36:41.437]             else {
[13:36:41.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:41.437]             }
[13:36:41.437]             {
[13:36:41.437]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:41.437]                   0L) {
[13:36:41.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:41.437]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:41.437]                   base::options(opts)
[13:36:41.437]                 }
[13:36:41.437]                 {
[13:36:41.437]                   {
[13:36:41.437]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:41.437]                     NULL
[13:36:41.437]                   }
[13:36:41.437]                   options(future.plan = NULL)
[13:36:41.437]                   if (is.na(NA_character_)) 
[13:36:41.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:41.437]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:41.437]                     .init = FALSE)
[13:36:41.437]                 }
[13:36:41.437]             }
[13:36:41.437]         }
[13:36:41.437]     })
[13:36:41.437]     if (TRUE) {
[13:36:41.437]         base::sink(type = "output", split = FALSE)
[13:36:41.437]         if (TRUE) {
[13:36:41.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:41.437]         }
[13:36:41.437]         else {
[13:36:41.437]             ...future.result["stdout"] <- base::list(NULL)
[13:36:41.437]         }
[13:36:41.437]         base::close(...future.stdout)
[13:36:41.437]         ...future.stdout <- NULL
[13:36:41.437]     }
[13:36:41.437]     ...future.result$conditions <- ...future.conditions
[13:36:41.437]     ...future.result$finished <- base::Sys.time()
[13:36:41.437]     ...future.result
[13:36:41.437] }
[13:36:41.440] requestCore(): workers = 2
[13:36:41.441] MulticoreFuture started
[13:36:41.442] - Launch lazy future ... done
[13:36:41.442] run() for ‘MulticoreFuture’ ... done
[13:36:41.442] result() for MulticoreFuture ...
[13:36:41.443] plan(): Setting new future strategy stack:
[13:36:41.443] List of future strategies:
[13:36:41.443] 1. sequential:
[13:36:41.443]    - args: function (..., envir = parent.frame())
[13:36:41.443]    - tweaked: FALSE
[13:36:41.443]    - call: NULL
[13:36:41.444] plan(): nbrOfWorkers() = 1
[13:36:41.448] plan(): Setting new future strategy stack:
[13:36:41.453] List of future strategies:
[13:36:41.453] 1. multicore:
[13:36:41.453]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:41.453]    - tweaked: FALSE
[13:36:41.453]    - call: plan(strategy)
[13:36:41.460] plan(): nbrOfWorkers() = 2
[13:36:41.462] result() for MulticoreFuture ...
[13:36:41.463] result() for MulticoreFuture ... done
[13:36:41.463] result() for MulticoreFuture ... done
[13:36:41.463] result() for MulticoreFuture ...
[13:36:41.463] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[13:36:41.469] getGlobalsAndPackages() ...
[13:36:41.469] Searching for globals...
[13:36:41.475] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[13:36:41.475] Searching for globals ... DONE
[13:36:41.475] Resolving globals: FALSE
[13:36:41.476] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[13:36:41.477] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[13:36:41.477] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[13:36:41.477] 
[13:36:41.477] getGlobalsAndPackages() ... DONE
[13:36:41.477] run() for ‘Future’ ...
[13:36:41.477] - state: ‘created’
[13:36:41.477] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:41.481] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:41.481] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:41.481]   - Field: ‘label’
[13:36:41.482]   - Field: ‘local’
[13:36:41.482]   - Field: ‘owner’
[13:36:41.482]   - Field: ‘envir’
[13:36:41.482]   - Field: ‘workers’
[13:36:41.482]   - Field: ‘packages’
[13:36:41.482]   - Field: ‘gc’
[13:36:41.482]   - Field: ‘job’
[13:36:41.482]   - Field: ‘conditions’
[13:36:41.482]   - Field: ‘expr’
[13:36:41.483]   - Field: ‘uuid’
[13:36:41.483]   - Field: ‘seed’
[13:36:41.483]   - Field: ‘version’
[13:36:41.483]   - Field: ‘result’
[13:36:41.483]   - Field: ‘asynchronous’
[13:36:41.483]   - Field: ‘calls’
[13:36:41.483]   - Field: ‘globals’
[13:36:41.483]   - Field: ‘stdout’
[13:36:41.483]   - Field: ‘earlySignal’
[13:36:41.484]   - Field: ‘lazy’
[13:36:41.484]   - Field: ‘state’
[13:36:41.484] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:41.484] - Launch lazy future ...
[13:36:41.484] Packages needed by the future expression (n = 0): <none>
[13:36:41.484] Packages needed by future strategies (n = 0): <none>
[13:36:41.485] {
[13:36:41.485]     {
[13:36:41.485]         {
[13:36:41.485]             ...future.startTime <- base::Sys.time()
[13:36:41.485]             {
[13:36:41.485]                 {
[13:36:41.485]                   {
[13:36:41.485]                     {
[13:36:41.485]                       base::local({
[13:36:41.485]                         has_future <- base::requireNamespace("future", 
[13:36:41.485]                           quietly = TRUE)
[13:36:41.485]                         if (has_future) {
[13:36:41.485]                           ns <- base::getNamespace("future")
[13:36:41.485]                           version <- ns[[".package"]][["version"]]
[13:36:41.485]                           if (is.null(version)) 
[13:36:41.485]                             version <- utils::packageVersion("future")
[13:36:41.485]                         }
[13:36:41.485]                         else {
[13:36:41.485]                           version <- NULL
[13:36:41.485]                         }
[13:36:41.485]                         if (!has_future || version < "1.8.0") {
[13:36:41.485]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:41.485]                             "", base::R.version$version.string), 
[13:36:41.485]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:41.485]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:41.485]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:41.485]                               "release", "version")], collapse = " "), 
[13:36:41.485]                             hostname = base::Sys.info()[["nodename"]])
[13:36:41.485]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:41.485]                             info)
[13:36:41.485]                           info <- base::paste(info, collapse = "; ")
[13:36:41.485]                           if (!has_future) {
[13:36:41.485]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:41.485]                               info)
[13:36:41.485]                           }
[13:36:41.485]                           else {
[13:36:41.485]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:41.485]                               info, version)
[13:36:41.485]                           }
[13:36:41.485]                           base::stop(msg)
[13:36:41.485]                         }
[13:36:41.485]                       })
[13:36:41.485]                     }
[13:36:41.485]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:41.485]                     base::options(mc.cores = 1L)
[13:36:41.485]                   }
[13:36:41.485]                   ...future.strategy.old <- future::plan("list")
[13:36:41.485]                   options(future.plan = NULL)
[13:36:41.485]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.485]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:41.485]                 }
[13:36:41.485]                 ...future.workdir <- getwd()
[13:36:41.485]             }
[13:36:41.485]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:41.485]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:41.485]         }
[13:36:41.485]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:41.485]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:41.485]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:41.485]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:41.485]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:41.485]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:41.485]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:41.485]             base::names(...future.oldOptions))
[13:36:41.485]     }
[13:36:41.485]     if (FALSE) {
[13:36:41.485]     }
[13:36:41.485]     else {
[13:36:41.485]         if (TRUE) {
[13:36:41.485]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:41.485]                 open = "w")
[13:36:41.485]         }
[13:36:41.485]         else {
[13:36:41.485]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:41.485]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:41.485]         }
[13:36:41.485]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:41.485]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:41.485]             base::sink(type = "output", split = FALSE)
[13:36:41.485]             base::close(...future.stdout)
[13:36:41.485]         }, add = TRUE)
[13:36:41.485]     }
[13:36:41.485]     ...future.frame <- base::sys.nframe()
[13:36:41.485]     ...future.conditions <- base::list()
[13:36:41.485]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:41.485]     if (FALSE) {
[13:36:41.485]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:41.485]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:41.485]     }
[13:36:41.485]     ...future.result <- base::tryCatch({
[13:36:41.485]         base::withCallingHandlers({
[13:36:41.485]             ...future.value <- base::withVisible(base::local({
[13:36:41.485]                 withCallingHandlers({
[13:36:41.485]                   {
[13:36:41.485]                     outer_function(1L)
[13:36:41.485]                   }
[13:36:41.485]                 }, immediateCondition = function(cond) {
[13:36:41.485]                   save_rds <- function (object, pathname, ...) 
[13:36:41.485]                   {
[13:36:41.485]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:41.485]                     if (file_test("-f", pathname_tmp)) {
[13:36:41.485]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.485]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:41.485]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.485]                         fi_tmp[["mtime"]])
[13:36:41.485]                     }
[13:36:41.485]                     tryCatch({
[13:36:41.485]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:41.485]                     }, error = function(ex) {
[13:36:41.485]                       msg <- conditionMessage(ex)
[13:36:41.485]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.485]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:41.485]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.485]                         fi_tmp[["mtime"]], msg)
[13:36:41.485]                       ex$message <- msg
[13:36:41.485]                       stop(ex)
[13:36:41.485]                     })
[13:36:41.485]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:41.485]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:41.485]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:41.485]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.485]                       fi <- file.info(pathname)
[13:36:41.485]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:41.485]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.485]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:41.485]                         fi[["size"]], fi[["mtime"]])
[13:36:41.485]                       stop(msg)
[13:36:41.485]                     }
[13:36:41.485]                     invisible(pathname)
[13:36:41.485]                   }
[13:36:41.485]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:41.485]                     rootPath = tempdir()) 
[13:36:41.485]                   {
[13:36:41.485]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:41.485]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:41.485]                       tmpdir = path, fileext = ".rds")
[13:36:41.485]                     save_rds(obj, file)
[13:36:41.485]                   }
[13:36:41.485]                   saveImmediateCondition(cond, path = "/tmp/RtmphVqFyZ/.future/immediateConditions")
[13:36:41.485]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.485]                   {
[13:36:41.485]                     inherits <- base::inherits
[13:36:41.485]                     invokeRestart <- base::invokeRestart
[13:36:41.485]                     is.null <- base::is.null
[13:36:41.485]                     muffled <- FALSE
[13:36:41.485]                     if (inherits(cond, "message")) {
[13:36:41.485]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:41.485]                       if (muffled) 
[13:36:41.485]                         invokeRestart("muffleMessage")
[13:36:41.485]                     }
[13:36:41.485]                     else if (inherits(cond, "warning")) {
[13:36:41.485]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:41.485]                       if (muffled) 
[13:36:41.485]                         invokeRestart("muffleWarning")
[13:36:41.485]                     }
[13:36:41.485]                     else if (inherits(cond, "condition")) {
[13:36:41.485]                       if (!is.null(pattern)) {
[13:36:41.485]                         computeRestarts <- base::computeRestarts
[13:36:41.485]                         grepl <- base::grepl
[13:36:41.485]                         restarts <- computeRestarts(cond)
[13:36:41.485]                         for (restart in restarts) {
[13:36:41.485]                           name <- restart$name
[13:36:41.485]                           if (is.null(name)) 
[13:36:41.485]                             next
[13:36:41.485]                           if (!grepl(pattern, name)) 
[13:36:41.485]                             next
[13:36:41.485]                           invokeRestart(restart)
[13:36:41.485]                           muffled <- TRUE
[13:36:41.485]                           break
[13:36:41.485]                         }
[13:36:41.485]                       }
[13:36:41.485]                     }
[13:36:41.485]                     invisible(muffled)
[13:36:41.485]                   }
[13:36:41.485]                   muffleCondition(cond)
[13:36:41.485]                 })
[13:36:41.485]             }))
[13:36:41.485]             future::FutureResult(value = ...future.value$value, 
[13:36:41.485]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.485]                   ...future.rng), globalenv = if (FALSE) 
[13:36:41.485]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:41.485]                     ...future.globalenv.names))
[13:36:41.485]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:41.485]         }, condition = base::local({
[13:36:41.485]             c <- base::c
[13:36:41.485]             inherits <- base::inherits
[13:36:41.485]             invokeRestart <- base::invokeRestart
[13:36:41.485]             length <- base::length
[13:36:41.485]             list <- base::list
[13:36:41.485]             seq.int <- base::seq.int
[13:36:41.485]             signalCondition <- base::signalCondition
[13:36:41.485]             sys.calls <- base::sys.calls
[13:36:41.485]             `[[` <- base::`[[`
[13:36:41.485]             `+` <- base::`+`
[13:36:41.485]             `<<-` <- base::`<<-`
[13:36:41.485]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:41.485]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:41.485]                   3L)]
[13:36:41.485]             }
[13:36:41.485]             function(cond) {
[13:36:41.485]                 is_error <- inherits(cond, "error")
[13:36:41.485]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:41.485]                   NULL)
[13:36:41.485]                 if (is_error) {
[13:36:41.485]                   sessionInformation <- function() {
[13:36:41.485]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:41.485]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:41.485]                       search = base::search(), system = base::Sys.info())
[13:36:41.485]                   }
[13:36:41.485]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.485]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:41.485]                     cond$call), session = sessionInformation(), 
[13:36:41.485]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:41.485]                   signalCondition(cond)
[13:36:41.485]                 }
[13:36:41.485]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:41.485]                 "immediateCondition"))) {
[13:36:41.485]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:41.485]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.485]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:41.485]                   if (TRUE && !signal) {
[13:36:41.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.485]                     {
[13:36:41.485]                       inherits <- base::inherits
[13:36:41.485]                       invokeRestart <- base::invokeRestart
[13:36:41.485]                       is.null <- base::is.null
[13:36:41.485]                       muffled <- FALSE
[13:36:41.485]                       if (inherits(cond, "message")) {
[13:36:41.485]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.485]                         if (muffled) 
[13:36:41.485]                           invokeRestart("muffleMessage")
[13:36:41.485]                       }
[13:36:41.485]                       else if (inherits(cond, "warning")) {
[13:36:41.485]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.485]                         if (muffled) 
[13:36:41.485]                           invokeRestart("muffleWarning")
[13:36:41.485]                       }
[13:36:41.485]                       else if (inherits(cond, "condition")) {
[13:36:41.485]                         if (!is.null(pattern)) {
[13:36:41.485]                           computeRestarts <- base::computeRestarts
[13:36:41.485]                           grepl <- base::grepl
[13:36:41.485]                           restarts <- computeRestarts(cond)
[13:36:41.485]                           for (restart in restarts) {
[13:36:41.485]                             name <- restart$name
[13:36:41.485]                             if (is.null(name)) 
[13:36:41.485]                               next
[13:36:41.485]                             if (!grepl(pattern, name)) 
[13:36:41.485]                               next
[13:36:41.485]                             invokeRestart(restart)
[13:36:41.485]                             muffled <- TRUE
[13:36:41.485]                             break
[13:36:41.485]                           }
[13:36:41.485]                         }
[13:36:41.485]                       }
[13:36:41.485]                       invisible(muffled)
[13:36:41.485]                     }
[13:36:41.485]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.485]                   }
[13:36:41.485]                 }
[13:36:41.485]                 else {
[13:36:41.485]                   if (TRUE) {
[13:36:41.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.485]                     {
[13:36:41.485]                       inherits <- base::inherits
[13:36:41.485]                       invokeRestart <- base::invokeRestart
[13:36:41.485]                       is.null <- base::is.null
[13:36:41.485]                       muffled <- FALSE
[13:36:41.485]                       if (inherits(cond, "message")) {
[13:36:41.485]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.485]                         if (muffled) 
[13:36:41.485]                           invokeRestart("muffleMessage")
[13:36:41.485]                       }
[13:36:41.485]                       else if (inherits(cond, "warning")) {
[13:36:41.485]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.485]                         if (muffled) 
[13:36:41.485]                           invokeRestart("muffleWarning")
[13:36:41.485]                       }
[13:36:41.485]                       else if (inherits(cond, "condition")) {
[13:36:41.485]                         if (!is.null(pattern)) {
[13:36:41.485]                           computeRestarts <- base::computeRestarts
[13:36:41.485]                           grepl <- base::grepl
[13:36:41.485]                           restarts <- computeRestarts(cond)
[13:36:41.485]                           for (restart in restarts) {
[13:36:41.485]                             name <- restart$name
[13:36:41.485]                             if (is.null(name)) 
[13:36:41.485]                               next
[13:36:41.485]                             if (!grepl(pattern, name)) 
[13:36:41.485]                               next
[13:36:41.485]                             invokeRestart(restart)
[13:36:41.485]                             muffled <- TRUE
[13:36:41.485]                             break
[13:36:41.485]                           }
[13:36:41.485]                         }
[13:36:41.485]                       }
[13:36:41.485]                       invisible(muffled)
[13:36:41.485]                     }
[13:36:41.485]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.485]                   }
[13:36:41.485]                 }
[13:36:41.485]             }
[13:36:41.485]         }))
[13:36:41.485]     }, error = function(ex) {
[13:36:41.485]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:41.485]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.485]                 ...future.rng), started = ...future.startTime, 
[13:36:41.485]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:41.485]             version = "1.8"), class = "FutureResult")
[13:36:41.485]     }, finally = {
[13:36:41.485]         if (!identical(...future.workdir, getwd())) 
[13:36:41.485]             setwd(...future.workdir)
[13:36:41.485]         {
[13:36:41.485]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:41.485]                 ...future.oldOptions$nwarnings <- NULL
[13:36:41.485]             }
[13:36:41.485]             base::options(...future.oldOptions)
[13:36:41.485]             if (.Platform$OS.type == "windows") {
[13:36:41.485]                 old_names <- names(...future.oldEnvVars)
[13:36:41.485]                 envs <- base::Sys.getenv()
[13:36:41.485]                 names <- names(envs)
[13:36:41.485]                 common <- intersect(names, old_names)
[13:36:41.485]                 added <- setdiff(names, old_names)
[13:36:41.485]                 removed <- setdiff(old_names, names)
[13:36:41.485]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:41.485]                   envs[common]]
[13:36:41.485]                 NAMES <- toupper(changed)
[13:36:41.485]                 args <- list()
[13:36:41.485]                 for (kk in seq_along(NAMES)) {
[13:36:41.485]                   name <- changed[[kk]]
[13:36:41.485]                   NAME <- NAMES[[kk]]
[13:36:41.485]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.485]                     next
[13:36:41.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.485]                 }
[13:36:41.485]                 NAMES <- toupper(added)
[13:36:41.485]                 for (kk in seq_along(NAMES)) {
[13:36:41.485]                   name <- added[[kk]]
[13:36:41.485]                   NAME <- NAMES[[kk]]
[13:36:41.485]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.485]                     next
[13:36:41.485]                   args[[name]] <- ""
[13:36:41.485]                 }
[13:36:41.485]                 NAMES <- toupper(removed)
[13:36:41.485]                 for (kk in seq_along(NAMES)) {
[13:36:41.485]                   name <- removed[[kk]]
[13:36:41.485]                   NAME <- NAMES[[kk]]
[13:36:41.485]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.485]                     next
[13:36:41.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.485]                 }
[13:36:41.485]                 if (length(args) > 0) 
[13:36:41.485]                   base::do.call(base::Sys.setenv, args = args)
[13:36:41.485]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:41.485]             }
[13:36:41.485]             else {
[13:36:41.485]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:41.485]             }
[13:36:41.485]             {
[13:36:41.485]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:41.485]                   0L) {
[13:36:41.485]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:41.485]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:41.485]                   base::options(opts)
[13:36:41.485]                 }
[13:36:41.485]                 {
[13:36:41.485]                   {
[13:36:41.485]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:41.485]                     NULL
[13:36:41.485]                   }
[13:36:41.485]                   options(future.plan = NULL)
[13:36:41.485]                   if (is.na(NA_character_)) 
[13:36:41.485]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.485]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:41.485]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:41.485]                     .init = FALSE)
[13:36:41.485]                 }
[13:36:41.485]             }
[13:36:41.485]         }
[13:36:41.485]     })
[13:36:41.485]     if (TRUE) {
[13:36:41.485]         base::sink(type = "output", split = FALSE)
[13:36:41.485]         if (TRUE) {
[13:36:41.485]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:41.485]         }
[13:36:41.485]         else {
[13:36:41.485]             ...future.result["stdout"] <- base::list(NULL)
[13:36:41.485]         }
[13:36:41.485]         base::close(...future.stdout)
[13:36:41.485]         ...future.stdout <- NULL
[13:36:41.485]     }
[13:36:41.485]     ...future.result$conditions <- ...future.conditions
[13:36:41.485]     ...future.result$finished <- base::Sys.time()
[13:36:41.485]     ...future.result
[13:36:41.485] }
[13:36:41.487] assign_globals() ...
[13:36:41.487] List of 3
[13:36:41.487]  $ outer_function:function (x)  
[13:36:41.487]  $ map           :function (.x, .f, ...)  
[13:36:41.487]  $ inner_function:function (x)  
[13:36:41.487]  - attr(*, "where")=List of 3
[13:36:41.487]   ..$ outer_function:<environment: R_EmptyEnv> 
[13:36:41.487]   ..$ map           :<environment: R_EmptyEnv> 
[13:36:41.487]   ..$ inner_function:<environment: R_EmptyEnv> 
[13:36:41.487]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:41.487]  - attr(*, "resolved")= logi FALSE
[13:36:41.487]  - attr(*, "total_size")= num 7704
[13:36:41.487]  - attr(*, "already-done")= logi TRUE
[13:36:41.491] - reassign environment for ‘outer_function’
[13:36:41.491] - copied ‘outer_function’ to environment
[13:36:41.491] - reassign environment for ‘map’
[13:36:41.491] - copied ‘map’ to environment
[13:36:41.491] - reassign environment for ‘inner_function’
[13:36:41.491] - copied ‘inner_function’ to environment
[13:36:41.491] assign_globals() ... done
[13:36:41.492] requestCore(): workers = 2
[13:36:41.493] MulticoreFuture started
[13:36:41.494] - Launch lazy future ... done
[13:36:41.494] run() for ‘MulticoreFuture’ ... done
[13:36:41.494] result() for MulticoreFuture ...
[13:36:41.495] plan(): Setting new future strategy stack:
[13:36:41.495] List of future strategies:
[13:36:41.495] 1. sequential:
[13:36:41.495]    - args: function (..., envir = parent.frame())
[13:36:41.495]    - tweaked: FALSE
[13:36:41.495]    - call: NULL
[13:36:41.496] plan(): nbrOfWorkers() = 1
[13:36:41.498] plan(): Setting new future strategy stack:
[13:36:41.498] List of future strategies:
[13:36:41.498] 1. multicore:
[13:36:41.498]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:41.498]    - tweaked: FALSE
[13:36:41.498]    - call: plan(strategy)
[13:36:41.507] plan(): nbrOfWorkers() = 2
[13:36:41.508] result() for MulticoreFuture ...
[13:36:41.508] result() for MulticoreFuture ... done
[13:36:41.508] result() for MulticoreFuture ... done
[13:36:41.508] result() for MulticoreFuture ...
[13:36:41.508] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[13:36:41.510] getGlobalsAndPackages() ...
[13:36:41.510] Searching for globals...
[13:36:41.519] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[13:36:41.519] Searching for globals ... DONE
[13:36:41.519] Resolving globals: FALSE
[13:36:41.520] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[13:36:41.520] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[13:36:41.521] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[13:36:41.521] 
[13:36:41.521] getGlobalsAndPackages() ... DONE
[13:36:41.521] run() for ‘Future’ ...
[13:36:41.521] - state: ‘created’
[13:36:41.522] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:41.525] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:41.525] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:41.526]   - Field: ‘label’
[13:36:41.526]   - Field: ‘local’
[13:36:41.526]   - Field: ‘owner’
[13:36:41.526]   - Field: ‘envir’
[13:36:41.526]   - Field: ‘workers’
[13:36:41.526]   - Field: ‘packages’
[13:36:41.526]   - Field: ‘gc’
[13:36:41.526]   - Field: ‘job’
[13:36:41.527]   - Field: ‘conditions’
[13:36:41.527]   - Field: ‘expr’
[13:36:41.527]   - Field: ‘uuid’
[13:36:41.527]   - Field: ‘seed’
[13:36:41.527]   - Field: ‘version’
[13:36:41.527]   - Field: ‘result’
[13:36:41.527]   - Field: ‘asynchronous’
[13:36:41.527]   - Field: ‘calls’
[13:36:41.527]   - Field: ‘globals’
[13:36:41.527]   - Field: ‘stdout’
[13:36:41.528]   - Field: ‘earlySignal’
[13:36:41.528]   - Field: ‘lazy’
[13:36:41.528]   - Field: ‘state’
[13:36:41.528] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:41.528] - Launch lazy future ...
[13:36:41.528] Packages needed by the future expression (n = 0): <none>
[13:36:41.528] Packages needed by future strategies (n = 0): <none>
[13:36:41.529] {
[13:36:41.529]     {
[13:36:41.529]         {
[13:36:41.529]             ...future.startTime <- base::Sys.time()
[13:36:41.529]             {
[13:36:41.529]                 {
[13:36:41.529]                   {
[13:36:41.529]                     {
[13:36:41.529]                       base::local({
[13:36:41.529]                         has_future <- base::requireNamespace("future", 
[13:36:41.529]                           quietly = TRUE)
[13:36:41.529]                         if (has_future) {
[13:36:41.529]                           ns <- base::getNamespace("future")
[13:36:41.529]                           version <- ns[[".package"]][["version"]]
[13:36:41.529]                           if (is.null(version)) 
[13:36:41.529]                             version <- utils::packageVersion("future")
[13:36:41.529]                         }
[13:36:41.529]                         else {
[13:36:41.529]                           version <- NULL
[13:36:41.529]                         }
[13:36:41.529]                         if (!has_future || version < "1.8.0") {
[13:36:41.529]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:41.529]                             "", base::R.version$version.string), 
[13:36:41.529]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:41.529]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:41.529]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:41.529]                               "release", "version")], collapse = " "), 
[13:36:41.529]                             hostname = base::Sys.info()[["nodename"]])
[13:36:41.529]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:41.529]                             info)
[13:36:41.529]                           info <- base::paste(info, collapse = "; ")
[13:36:41.529]                           if (!has_future) {
[13:36:41.529]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:41.529]                               info)
[13:36:41.529]                           }
[13:36:41.529]                           else {
[13:36:41.529]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:41.529]                               info, version)
[13:36:41.529]                           }
[13:36:41.529]                           base::stop(msg)
[13:36:41.529]                         }
[13:36:41.529]                       })
[13:36:41.529]                     }
[13:36:41.529]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:41.529]                     base::options(mc.cores = 1L)
[13:36:41.529]                   }
[13:36:41.529]                   ...future.strategy.old <- future::plan("list")
[13:36:41.529]                   options(future.plan = NULL)
[13:36:41.529]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.529]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:41.529]                 }
[13:36:41.529]                 ...future.workdir <- getwd()
[13:36:41.529]             }
[13:36:41.529]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:41.529]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:41.529]         }
[13:36:41.529]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:41.529]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:41.529]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:41.529]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:41.529]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:41.529]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:41.529]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:41.529]             base::names(...future.oldOptions))
[13:36:41.529]     }
[13:36:41.529]     if (FALSE) {
[13:36:41.529]     }
[13:36:41.529]     else {
[13:36:41.529]         if (TRUE) {
[13:36:41.529]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:41.529]                 open = "w")
[13:36:41.529]         }
[13:36:41.529]         else {
[13:36:41.529]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:41.529]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:41.529]         }
[13:36:41.529]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:41.529]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:41.529]             base::sink(type = "output", split = FALSE)
[13:36:41.529]             base::close(...future.stdout)
[13:36:41.529]         }, add = TRUE)
[13:36:41.529]     }
[13:36:41.529]     ...future.frame <- base::sys.nframe()
[13:36:41.529]     ...future.conditions <- base::list()
[13:36:41.529]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:41.529]     if (FALSE) {
[13:36:41.529]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:41.529]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:41.529]     }
[13:36:41.529]     ...future.result <- base::tryCatch({
[13:36:41.529]         base::withCallingHandlers({
[13:36:41.529]             ...future.value <- base::withVisible(base::local({
[13:36:41.529]                 withCallingHandlers({
[13:36:41.529]                   {
[13:36:41.529]                     outer_function(1L)
[13:36:41.529]                   }
[13:36:41.529]                 }, immediateCondition = function(cond) {
[13:36:41.529]                   save_rds <- function (object, pathname, ...) 
[13:36:41.529]                   {
[13:36:41.529]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:41.529]                     if (file_test("-f", pathname_tmp)) {
[13:36:41.529]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.529]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:41.529]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.529]                         fi_tmp[["mtime"]])
[13:36:41.529]                     }
[13:36:41.529]                     tryCatch({
[13:36:41.529]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:41.529]                     }, error = function(ex) {
[13:36:41.529]                       msg <- conditionMessage(ex)
[13:36:41.529]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.529]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:41.529]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.529]                         fi_tmp[["mtime"]], msg)
[13:36:41.529]                       ex$message <- msg
[13:36:41.529]                       stop(ex)
[13:36:41.529]                     })
[13:36:41.529]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:41.529]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:41.529]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:41.529]                       fi_tmp <- file.info(pathname_tmp)
[13:36:41.529]                       fi <- file.info(pathname)
[13:36:41.529]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:41.529]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:41.529]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:41.529]                         fi[["size"]], fi[["mtime"]])
[13:36:41.529]                       stop(msg)
[13:36:41.529]                     }
[13:36:41.529]                     invisible(pathname)
[13:36:41.529]                   }
[13:36:41.529]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:41.529]                     rootPath = tempdir()) 
[13:36:41.529]                   {
[13:36:41.529]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:41.529]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:41.529]                       tmpdir = path, fileext = ".rds")
[13:36:41.529]                     save_rds(obj, file)
[13:36:41.529]                   }
[13:36:41.529]                   saveImmediateCondition(cond, path = "/tmp/RtmphVqFyZ/.future/immediateConditions")
[13:36:41.529]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.529]                   {
[13:36:41.529]                     inherits <- base::inherits
[13:36:41.529]                     invokeRestart <- base::invokeRestart
[13:36:41.529]                     is.null <- base::is.null
[13:36:41.529]                     muffled <- FALSE
[13:36:41.529]                     if (inherits(cond, "message")) {
[13:36:41.529]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:41.529]                       if (muffled) 
[13:36:41.529]                         invokeRestart("muffleMessage")
[13:36:41.529]                     }
[13:36:41.529]                     else if (inherits(cond, "warning")) {
[13:36:41.529]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:41.529]                       if (muffled) 
[13:36:41.529]                         invokeRestart("muffleWarning")
[13:36:41.529]                     }
[13:36:41.529]                     else if (inherits(cond, "condition")) {
[13:36:41.529]                       if (!is.null(pattern)) {
[13:36:41.529]                         computeRestarts <- base::computeRestarts
[13:36:41.529]                         grepl <- base::grepl
[13:36:41.529]                         restarts <- computeRestarts(cond)
[13:36:41.529]                         for (restart in restarts) {
[13:36:41.529]                           name <- restart$name
[13:36:41.529]                           if (is.null(name)) 
[13:36:41.529]                             next
[13:36:41.529]                           if (!grepl(pattern, name)) 
[13:36:41.529]                             next
[13:36:41.529]                           invokeRestart(restart)
[13:36:41.529]                           muffled <- TRUE
[13:36:41.529]                           break
[13:36:41.529]                         }
[13:36:41.529]                       }
[13:36:41.529]                     }
[13:36:41.529]                     invisible(muffled)
[13:36:41.529]                   }
[13:36:41.529]                   muffleCondition(cond)
[13:36:41.529]                 })
[13:36:41.529]             }))
[13:36:41.529]             future::FutureResult(value = ...future.value$value, 
[13:36:41.529]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.529]                   ...future.rng), globalenv = if (FALSE) 
[13:36:41.529]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:41.529]                     ...future.globalenv.names))
[13:36:41.529]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:41.529]         }, condition = base::local({
[13:36:41.529]             c <- base::c
[13:36:41.529]             inherits <- base::inherits
[13:36:41.529]             invokeRestart <- base::invokeRestart
[13:36:41.529]             length <- base::length
[13:36:41.529]             list <- base::list
[13:36:41.529]             seq.int <- base::seq.int
[13:36:41.529]             signalCondition <- base::signalCondition
[13:36:41.529]             sys.calls <- base::sys.calls
[13:36:41.529]             `[[` <- base::`[[`
[13:36:41.529]             `+` <- base::`+`
[13:36:41.529]             `<<-` <- base::`<<-`
[13:36:41.529]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:41.529]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:41.529]                   3L)]
[13:36:41.529]             }
[13:36:41.529]             function(cond) {
[13:36:41.529]                 is_error <- inherits(cond, "error")
[13:36:41.529]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:41.529]                   NULL)
[13:36:41.529]                 if (is_error) {
[13:36:41.529]                   sessionInformation <- function() {
[13:36:41.529]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:41.529]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:41.529]                       search = base::search(), system = base::Sys.info())
[13:36:41.529]                   }
[13:36:41.529]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.529]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:41.529]                     cond$call), session = sessionInformation(), 
[13:36:41.529]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:41.529]                   signalCondition(cond)
[13:36:41.529]                 }
[13:36:41.529]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:41.529]                 "immediateCondition"))) {
[13:36:41.529]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:41.529]                   ...future.conditions[[length(...future.conditions) + 
[13:36:41.529]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:41.529]                   if (TRUE && !signal) {
[13:36:41.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.529]                     {
[13:36:41.529]                       inherits <- base::inherits
[13:36:41.529]                       invokeRestart <- base::invokeRestart
[13:36:41.529]                       is.null <- base::is.null
[13:36:41.529]                       muffled <- FALSE
[13:36:41.529]                       if (inherits(cond, "message")) {
[13:36:41.529]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.529]                         if (muffled) 
[13:36:41.529]                           invokeRestart("muffleMessage")
[13:36:41.529]                       }
[13:36:41.529]                       else if (inherits(cond, "warning")) {
[13:36:41.529]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.529]                         if (muffled) 
[13:36:41.529]                           invokeRestart("muffleWarning")
[13:36:41.529]                       }
[13:36:41.529]                       else if (inherits(cond, "condition")) {
[13:36:41.529]                         if (!is.null(pattern)) {
[13:36:41.529]                           computeRestarts <- base::computeRestarts
[13:36:41.529]                           grepl <- base::grepl
[13:36:41.529]                           restarts <- computeRestarts(cond)
[13:36:41.529]                           for (restart in restarts) {
[13:36:41.529]                             name <- restart$name
[13:36:41.529]                             if (is.null(name)) 
[13:36:41.529]                               next
[13:36:41.529]                             if (!grepl(pattern, name)) 
[13:36:41.529]                               next
[13:36:41.529]                             invokeRestart(restart)
[13:36:41.529]                             muffled <- TRUE
[13:36:41.529]                             break
[13:36:41.529]                           }
[13:36:41.529]                         }
[13:36:41.529]                       }
[13:36:41.529]                       invisible(muffled)
[13:36:41.529]                     }
[13:36:41.529]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.529]                   }
[13:36:41.529]                 }
[13:36:41.529]                 else {
[13:36:41.529]                   if (TRUE) {
[13:36:41.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:41.529]                     {
[13:36:41.529]                       inherits <- base::inherits
[13:36:41.529]                       invokeRestart <- base::invokeRestart
[13:36:41.529]                       is.null <- base::is.null
[13:36:41.529]                       muffled <- FALSE
[13:36:41.529]                       if (inherits(cond, "message")) {
[13:36:41.529]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:41.529]                         if (muffled) 
[13:36:41.529]                           invokeRestart("muffleMessage")
[13:36:41.529]                       }
[13:36:41.529]                       else if (inherits(cond, "warning")) {
[13:36:41.529]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:41.529]                         if (muffled) 
[13:36:41.529]                           invokeRestart("muffleWarning")
[13:36:41.529]                       }
[13:36:41.529]                       else if (inherits(cond, "condition")) {
[13:36:41.529]                         if (!is.null(pattern)) {
[13:36:41.529]                           computeRestarts <- base::computeRestarts
[13:36:41.529]                           grepl <- base::grepl
[13:36:41.529]                           restarts <- computeRestarts(cond)
[13:36:41.529]                           for (restart in restarts) {
[13:36:41.529]                             name <- restart$name
[13:36:41.529]                             if (is.null(name)) 
[13:36:41.529]                               next
[13:36:41.529]                             if (!grepl(pattern, name)) 
[13:36:41.529]                               next
[13:36:41.529]                             invokeRestart(restart)
[13:36:41.529]                             muffled <- TRUE
[13:36:41.529]                             break
[13:36:41.529]                           }
[13:36:41.529]                         }
[13:36:41.529]                       }
[13:36:41.529]                       invisible(muffled)
[13:36:41.529]                     }
[13:36:41.529]                     muffleCondition(cond, pattern = "^muffle")
[13:36:41.529]                   }
[13:36:41.529]                 }
[13:36:41.529]             }
[13:36:41.529]         }))
[13:36:41.529]     }, error = function(ex) {
[13:36:41.529]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:41.529]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:41.529]                 ...future.rng), started = ...future.startTime, 
[13:36:41.529]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:41.529]             version = "1.8"), class = "FutureResult")
[13:36:41.529]     }, finally = {
[13:36:41.529]         if (!identical(...future.workdir, getwd())) 
[13:36:41.529]             setwd(...future.workdir)
[13:36:41.529]         {
[13:36:41.529]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:41.529]                 ...future.oldOptions$nwarnings <- NULL
[13:36:41.529]             }
[13:36:41.529]             base::options(...future.oldOptions)
[13:36:41.529]             if (.Platform$OS.type == "windows") {
[13:36:41.529]                 old_names <- names(...future.oldEnvVars)
[13:36:41.529]                 envs <- base::Sys.getenv()
[13:36:41.529]                 names <- names(envs)
[13:36:41.529]                 common <- intersect(names, old_names)
[13:36:41.529]                 added <- setdiff(names, old_names)
[13:36:41.529]                 removed <- setdiff(old_names, names)
[13:36:41.529]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:41.529]                   envs[common]]
[13:36:41.529]                 NAMES <- toupper(changed)
[13:36:41.529]                 args <- list()
[13:36:41.529]                 for (kk in seq_along(NAMES)) {
[13:36:41.529]                   name <- changed[[kk]]
[13:36:41.529]                   NAME <- NAMES[[kk]]
[13:36:41.529]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.529]                     next
[13:36:41.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.529]                 }
[13:36:41.529]                 NAMES <- toupper(added)
[13:36:41.529]                 for (kk in seq_along(NAMES)) {
[13:36:41.529]                   name <- added[[kk]]
[13:36:41.529]                   NAME <- NAMES[[kk]]
[13:36:41.529]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.529]                     next
[13:36:41.529]                   args[[name]] <- ""
[13:36:41.529]                 }
[13:36:41.529]                 NAMES <- toupper(removed)
[13:36:41.529]                 for (kk in seq_along(NAMES)) {
[13:36:41.529]                   name <- removed[[kk]]
[13:36:41.529]                   NAME <- NAMES[[kk]]
[13:36:41.529]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:41.529]                     next
[13:36:41.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:41.529]                 }
[13:36:41.529]                 if (length(args) > 0) 
[13:36:41.529]                   base::do.call(base::Sys.setenv, args = args)
[13:36:41.529]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:41.529]             }
[13:36:41.529]             else {
[13:36:41.529]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:41.529]             }
[13:36:41.529]             {
[13:36:41.529]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:41.529]                   0L) {
[13:36:41.529]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:41.529]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:41.529]                   base::options(opts)
[13:36:41.529]                 }
[13:36:41.529]                 {
[13:36:41.529]                   {
[13:36:41.529]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:41.529]                     NULL
[13:36:41.529]                   }
[13:36:41.529]                   options(future.plan = NULL)
[13:36:41.529]                   if (is.na(NA_character_)) 
[13:36:41.529]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:41.529]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:41.529]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:41.529]                     .init = FALSE)
[13:36:41.529]                 }
[13:36:41.529]             }
[13:36:41.529]         }
[13:36:41.529]     })
[13:36:41.529]     if (TRUE) {
[13:36:41.529]         base::sink(type = "output", split = FALSE)
[13:36:41.529]         if (TRUE) {
[13:36:41.529]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:41.529]         }
[13:36:41.529]         else {
[13:36:41.529]             ...future.result["stdout"] <- base::list(NULL)
[13:36:41.529]         }
[13:36:41.529]         base::close(...future.stdout)
[13:36:41.529]         ...future.stdout <- NULL
[13:36:41.529]     }
[13:36:41.529]     ...future.result$conditions <- ...future.conditions
[13:36:41.529]     ...future.result$finished <- base::Sys.time()
[13:36:41.529]     ...future.result
[13:36:41.529] }
[13:36:41.531] assign_globals() ...
[13:36:41.531] List of 3
[13:36:41.531]  $ outer_function:function (x)  
[13:36:41.531]  $ map           :function (.x, .f, ...)  
[13:36:41.531]  $ inner_function:function (x)  
[13:36:41.531]  - attr(*, "where")=List of 3
[13:36:41.531]   ..$ outer_function:<environment: R_EmptyEnv> 
[13:36:41.531]   ..$ map           :<environment: R_EmptyEnv> 
[13:36:41.531]   ..$ inner_function:<environment: R_EmptyEnv> 
[13:36:41.531]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:41.531]  - attr(*, "resolved")= logi FALSE
[13:36:41.531]  - attr(*, "total_size")= num 7704
[13:36:41.531]  - attr(*, "already-done")= logi TRUE
[13:36:41.535] - reassign environment for ‘outer_function’
[13:36:41.535] - copied ‘outer_function’ to environment
[13:36:41.535] - reassign environment for ‘map’
[13:36:41.535] - copied ‘map’ to environment
[13:36:41.535] - reassign environment for ‘inner_function’
[13:36:41.535] - copied ‘inner_function’ to environment
[13:36:41.535] assign_globals() ... done
[13:36:41.536] requestCore(): workers = 2
[13:36:41.537] MulticoreFuture started
[13:36:41.538] - Launch lazy future ... done
[13:36:41.538] run() for ‘MulticoreFuture’ ... done
[13:36:41.538] result() for MulticoreFuture ...
[13:36:41.539] plan(): Setting new future strategy stack:
[13:36:41.539] List of future strategies:
[13:36:41.539] 1. sequential:
[13:36:41.539]    - args: function (..., envir = parent.frame())
[13:36:41.539]    - tweaked: FALSE
[13:36:41.539]    - call: NULL
[13:36:41.540] plan(): nbrOfWorkers() = 1
[13:36:41.542] plan(): Setting new future strategy stack:
[13:36:41.542] List of future strategies:
[13:36:41.542] 1. multicore:
[13:36:41.542]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:41.542]    - tweaked: FALSE
[13:36:41.542]    - call: plan(strategy)
[13:36:41.547] plan(): nbrOfWorkers() = 2
[13:36:41.548] result() for MulticoreFuture ...
[13:36:41.548] result() for MulticoreFuture ... done
[13:36:41.548] result() for MulticoreFuture ... done
[13:36:41.548] result() for MulticoreFuture ...
[13:36:41.549] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
- plan('multisession') ...
[13:36:41.550] plan(): Setting new future strategy stack:
[13:36:41.551] List of future strategies:
[13:36:41.551] 1. multisession:
[13:36:41.551]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:36:41.551]    - tweaked: FALSE
[13:36:41.551]    - call: plan(strategy)
[13:36:41.551] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:36:41.551] multisession:
[13:36:41.551] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:36:41.551] - tweaked: FALSE
[13:36:41.551] - call: plan(strategy)
[13:36:41.561] getGlobalsAndPackages() ...
[13:36:41.561] Not searching for globals
[13:36:41.561] - globals: [0] <none>
[13:36:41.561] getGlobalsAndPackages() ... DONE
[13:36:41.562] [local output] makeClusterPSOCK() ...
[13:36:41.605] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:36:41.606] [local output] Base port: 11777
[13:36:41.606] [local output] Getting setup options for 2 cluster nodes ...
[13:36:41.606] [local output]  - Node 1 of 2 ...
[13:36:41.607] [local output] localMachine=TRUE => revtunnel=FALSE

[13:36:41.607] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmphVqFyZ/worker.rank=1.parallelly.parent=83264.145401065a860.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmphVqFyZ/worker.rank=1.parallelly.parent=83264.145401065a860.pid")'’
[13:36:41.797] - Possible to infer worker's PID: TRUE
[13:36:41.797] [local output] Rscript port: 11777

[13:36:41.798] [local output]  - Node 2 of 2 ...
[13:36:41.798] [local output] localMachine=TRUE => revtunnel=FALSE

[13:36:41.799] [local output] Rscript port: 11777

[13:36:41.799] [local output] Getting setup options for 2 cluster nodes ... done
[13:36:41.799] [local output]  - Parallel setup requested for some PSOCK nodes
[13:36:41.800] [local output] Setting up PSOCK nodes in parallel
[13:36:41.800] List of 36
[13:36:41.800]  $ worker          : chr "localhost"
[13:36:41.800]   ..- attr(*, "localhost")= logi TRUE
[13:36:41.800]  $ master          : chr "localhost"
[13:36:41.800]  $ port            : int 11777
[13:36:41.800]  $ connectTimeout  : num 120
[13:36:41.800]  $ timeout         : num 2592000
[13:36:41.800]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:36:41.800]  $ homogeneous     : logi TRUE
[13:36:41.800]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:36:41.800]  $ rscript_envs    : NULL
[13:36:41.800]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:36:41.800]  $ rscript_startup : NULL
[13:36:41.800]  $ rscript_sh      : chr "sh"
[13:36:41.800]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:36:41.800]  $ methods         : logi TRUE
[13:36:41.800]  $ socketOptions   : chr "no-delay"
[13:36:41.800]  $ useXDR          : logi FALSE
[13:36:41.800]  $ outfile         : chr "/dev/null"
[13:36:41.800]  $ renice          : int NA
[13:36:41.800]  $ rshcmd          : NULL
[13:36:41.800]  $ user            : chr(0) 
[13:36:41.800]  $ revtunnel       : logi FALSE
[13:36:41.800]  $ rshlogfile      : NULL
[13:36:41.800]  $ rshopts         : chr(0) 
[13:36:41.800]  $ rank            : int 1
[13:36:41.800]  $ manual          : logi FALSE
[13:36:41.800]  $ dryrun          : logi FALSE
[13:36:41.800]  $ quiet           : logi FALSE
[13:36:41.800]  $ setup_strategy  : chr "parallel"
[13:36:41.800]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:36:41.800]  $ pidfile         : chr "/tmp/RtmphVqFyZ/worker.rank=1.parallelly.parent=83264.145401065a860.pid"
[13:36:41.800]  $ rshcmd_label    : NULL
[13:36:41.800]  $ rsh_call        : NULL
[13:36:41.800]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:36:41.800]  $ localMachine    : logi TRUE
[13:36:41.800]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:36:41.800]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:36:41.800]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:36:41.800]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:36:41.800]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:36:41.800]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:36:41.800]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:36:41.800]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:36:41.800]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:36:41.800]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:36:41.800]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:36:41.800]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:36:41.800]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:36:41.800]  $ arguments       :List of 28
[13:36:41.800]   ..$ worker          : chr "localhost"
[13:36:41.800]   ..$ master          : NULL
[13:36:41.800]   ..$ port            : int 11777
[13:36:41.800]   ..$ connectTimeout  : num 120
[13:36:41.800]   ..$ timeout         : num 2592000
[13:36:41.800]   ..$ rscript         : NULL
[13:36:41.800]   ..$ homogeneous     : NULL
[13:36:41.800]   ..$ rscript_args    : NULL
[13:36:41.800]   ..$ rscript_envs    : NULL
[13:36:41.800]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:36:41.800]   ..$ rscript_startup : NULL
[13:36:41.800]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:36:41.800]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:36:41.800]   ..$ methods         : logi TRUE
[13:36:41.800]   ..$ socketOptions   : chr "no-delay"
[13:36:41.800]   ..$ useXDR          : logi FALSE
[13:36:41.800]   ..$ outfile         : chr "/dev/null"
[13:36:41.800]   ..$ renice          : int NA
[13:36:41.800]   ..$ rshcmd          : NULL
[13:36:41.800]   ..$ user            : NULL
[13:36:41.800]   ..$ revtunnel       : logi NA
[13:36:41.800]   ..$ rshlogfile      : NULL
[13:36:41.800]   ..$ rshopts         : NULL
[13:36:41.800]   ..$ rank            : int 1
[13:36:41.800]   ..$ manual          : logi FALSE
[13:36:41.800]   ..$ dryrun          : logi FALSE
[13:36:41.800]   ..$ quiet           : logi FALSE
[13:36:41.800]   ..$ setup_strategy  : chr "parallel"
[13:36:41.800]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:36:41.817] [local output] System call to launch all workers:
[13:36:41.817] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmphVqFyZ/worker.rank=1.parallelly.parent=83264.145401065a860.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11777 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:36:41.817] [local output] Starting PSOCK main server
[13:36:41.823] [local output] Workers launched
[13:36:41.823] [local output] Waiting for workers to connect back
[13:36:41.823]  - [local output] 0 workers out of 2 ready
[13:36:42.090]  - [local output] 0 workers out of 2 ready
[13:36:42.090]  - [local output] 1 workers out of 2 ready
[13:36:42.091]  - [local output] 2 workers out of 2 ready
[13:36:42.091] [local output] Launching of workers completed
[13:36:42.091] [local output] Collecting session information from workers
[13:36:42.092] [local output]  - Worker #1 of 2
[13:36:42.093] [local output]  - Worker #2 of 2
[13:36:42.093] [local output] makeClusterPSOCK() ... done
[13:36:42.105] Packages needed by the future expression (n = 0): <none>
[13:36:42.105] Packages needed by future strategies (n = 0): <none>
[13:36:42.105] {
[13:36:42.105]     {
[13:36:42.105]         {
[13:36:42.105]             ...future.startTime <- base::Sys.time()
[13:36:42.105]             {
[13:36:42.105]                 {
[13:36:42.105]                   {
[13:36:42.105]                     {
[13:36:42.105]                       base::local({
[13:36:42.105]                         has_future <- base::requireNamespace("future", 
[13:36:42.105]                           quietly = TRUE)
[13:36:42.105]                         if (has_future) {
[13:36:42.105]                           ns <- base::getNamespace("future")
[13:36:42.105]                           version <- ns[[".package"]][["version"]]
[13:36:42.105]                           if (is.null(version)) 
[13:36:42.105]                             version <- utils::packageVersion("future")
[13:36:42.105]                         }
[13:36:42.105]                         else {
[13:36:42.105]                           version <- NULL
[13:36:42.105]                         }
[13:36:42.105]                         if (!has_future || version < "1.8.0") {
[13:36:42.105]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:42.105]                             "", base::R.version$version.string), 
[13:36:42.105]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:42.105]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:42.105]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:42.105]                               "release", "version")], collapse = " "), 
[13:36:42.105]                             hostname = base::Sys.info()[["nodename"]])
[13:36:42.105]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:42.105]                             info)
[13:36:42.105]                           info <- base::paste(info, collapse = "; ")
[13:36:42.105]                           if (!has_future) {
[13:36:42.105]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:42.105]                               info)
[13:36:42.105]                           }
[13:36:42.105]                           else {
[13:36:42.105]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:42.105]                               info, version)
[13:36:42.105]                           }
[13:36:42.105]                           base::stop(msg)
[13:36:42.105]                         }
[13:36:42.105]                       })
[13:36:42.105]                     }
[13:36:42.105]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:42.105]                     base::options(mc.cores = 1L)
[13:36:42.105]                   }
[13:36:42.105]                   ...future.strategy.old <- future::plan("list")
[13:36:42.105]                   options(future.plan = NULL)
[13:36:42.105]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.105]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:42.105]                 }
[13:36:42.105]                 ...future.workdir <- getwd()
[13:36:42.105]             }
[13:36:42.105]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:42.105]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:42.105]         }
[13:36:42.105]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:42.105]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:42.105]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:42.105]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:42.105]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:42.105]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:42.105]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:42.105]             base::names(...future.oldOptions))
[13:36:42.105]     }
[13:36:42.105]     if (FALSE) {
[13:36:42.105]     }
[13:36:42.105]     else {
[13:36:42.105]         if (TRUE) {
[13:36:42.105]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:42.105]                 open = "w")
[13:36:42.105]         }
[13:36:42.105]         else {
[13:36:42.105]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:42.105]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:42.105]         }
[13:36:42.105]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:42.105]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:42.105]             base::sink(type = "output", split = FALSE)
[13:36:42.105]             base::close(...future.stdout)
[13:36:42.105]         }, add = TRUE)
[13:36:42.105]     }
[13:36:42.105]     ...future.frame <- base::sys.nframe()
[13:36:42.105]     ...future.conditions <- base::list()
[13:36:42.105]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:42.105]     if (FALSE) {
[13:36:42.105]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:42.105]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:42.105]     }
[13:36:42.105]     ...future.result <- base::tryCatch({
[13:36:42.105]         base::withCallingHandlers({
[13:36:42.105]             ...future.value <- base::withVisible(base::local({
[13:36:42.105]                 ...future.makeSendCondition <- base::local({
[13:36:42.105]                   sendCondition <- NULL
[13:36:42.105]                   function(frame = 1L) {
[13:36:42.105]                     if (is.function(sendCondition)) 
[13:36:42.105]                       return(sendCondition)
[13:36:42.105]                     ns <- getNamespace("parallel")
[13:36:42.105]                     if (exists("sendData", mode = "function", 
[13:36:42.105]                       envir = ns)) {
[13:36:42.105]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:42.105]                         envir = ns)
[13:36:42.105]                       envir <- sys.frame(frame)
[13:36:42.105]                       master <- NULL
[13:36:42.105]                       while (!identical(envir, .GlobalEnv) && 
[13:36:42.105]                         !identical(envir, emptyenv())) {
[13:36:42.105]                         if (exists("master", mode = "list", envir = envir, 
[13:36:42.105]                           inherits = FALSE)) {
[13:36:42.105]                           master <- get("master", mode = "list", 
[13:36:42.105]                             envir = envir, inherits = FALSE)
[13:36:42.105]                           if (inherits(master, c("SOCKnode", 
[13:36:42.105]                             "SOCK0node"))) {
[13:36:42.105]                             sendCondition <<- function(cond) {
[13:36:42.105]                               data <- list(type = "VALUE", value = cond, 
[13:36:42.105]                                 success = TRUE)
[13:36:42.105]                               parallel_sendData(master, data)
[13:36:42.105]                             }
[13:36:42.105]                             return(sendCondition)
[13:36:42.105]                           }
[13:36:42.105]                         }
[13:36:42.105]                         frame <- frame + 1L
[13:36:42.105]                         envir <- sys.frame(frame)
[13:36:42.105]                       }
[13:36:42.105]                     }
[13:36:42.105]                     sendCondition <<- function(cond) NULL
[13:36:42.105]                   }
[13:36:42.105]                 })
[13:36:42.105]                 withCallingHandlers({
[13:36:42.105]                   NA
[13:36:42.105]                 }, immediateCondition = function(cond) {
[13:36:42.105]                   sendCondition <- ...future.makeSendCondition()
[13:36:42.105]                   sendCondition(cond)
[13:36:42.105]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.105]                   {
[13:36:42.105]                     inherits <- base::inherits
[13:36:42.105]                     invokeRestart <- base::invokeRestart
[13:36:42.105]                     is.null <- base::is.null
[13:36:42.105]                     muffled <- FALSE
[13:36:42.105]                     if (inherits(cond, "message")) {
[13:36:42.105]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:42.105]                       if (muffled) 
[13:36:42.105]                         invokeRestart("muffleMessage")
[13:36:42.105]                     }
[13:36:42.105]                     else if (inherits(cond, "warning")) {
[13:36:42.105]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:42.105]                       if (muffled) 
[13:36:42.105]                         invokeRestart("muffleWarning")
[13:36:42.105]                     }
[13:36:42.105]                     else if (inherits(cond, "condition")) {
[13:36:42.105]                       if (!is.null(pattern)) {
[13:36:42.105]                         computeRestarts <- base::computeRestarts
[13:36:42.105]                         grepl <- base::grepl
[13:36:42.105]                         restarts <- computeRestarts(cond)
[13:36:42.105]                         for (restart in restarts) {
[13:36:42.105]                           name <- restart$name
[13:36:42.105]                           if (is.null(name)) 
[13:36:42.105]                             next
[13:36:42.105]                           if (!grepl(pattern, name)) 
[13:36:42.105]                             next
[13:36:42.105]                           invokeRestart(restart)
[13:36:42.105]                           muffled <- TRUE
[13:36:42.105]                           break
[13:36:42.105]                         }
[13:36:42.105]                       }
[13:36:42.105]                     }
[13:36:42.105]                     invisible(muffled)
[13:36:42.105]                   }
[13:36:42.105]                   muffleCondition(cond)
[13:36:42.105]                 })
[13:36:42.105]             }))
[13:36:42.105]             future::FutureResult(value = ...future.value$value, 
[13:36:42.105]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.105]                   ...future.rng), globalenv = if (FALSE) 
[13:36:42.105]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:42.105]                     ...future.globalenv.names))
[13:36:42.105]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:42.105]         }, condition = base::local({
[13:36:42.105]             c <- base::c
[13:36:42.105]             inherits <- base::inherits
[13:36:42.105]             invokeRestart <- base::invokeRestart
[13:36:42.105]             length <- base::length
[13:36:42.105]             list <- base::list
[13:36:42.105]             seq.int <- base::seq.int
[13:36:42.105]             signalCondition <- base::signalCondition
[13:36:42.105]             sys.calls <- base::sys.calls
[13:36:42.105]             `[[` <- base::`[[`
[13:36:42.105]             `+` <- base::`+`
[13:36:42.105]             `<<-` <- base::`<<-`
[13:36:42.105]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:42.105]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:42.105]                   3L)]
[13:36:42.105]             }
[13:36:42.105]             function(cond) {
[13:36:42.105]                 is_error <- inherits(cond, "error")
[13:36:42.105]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:42.105]                   NULL)
[13:36:42.105]                 if (is_error) {
[13:36:42.105]                   sessionInformation <- function() {
[13:36:42.105]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:42.105]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:42.105]                       search = base::search(), system = base::Sys.info())
[13:36:42.105]                   }
[13:36:42.105]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.105]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:42.105]                     cond$call), session = sessionInformation(), 
[13:36:42.105]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:42.105]                   signalCondition(cond)
[13:36:42.105]                 }
[13:36:42.105]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:42.105]                 "immediateCondition"))) {
[13:36:42.105]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:42.105]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.105]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:42.105]                   if (TRUE && !signal) {
[13:36:42.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.105]                     {
[13:36:42.105]                       inherits <- base::inherits
[13:36:42.105]                       invokeRestart <- base::invokeRestart
[13:36:42.105]                       is.null <- base::is.null
[13:36:42.105]                       muffled <- FALSE
[13:36:42.105]                       if (inherits(cond, "message")) {
[13:36:42.105]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.105]                         if (muffled) 
[13:36:42.105]                           invokeRestart("muffleMessage")
[13:36:42.105]                       }
[13:36:42.105]                       else if (inherits(cond, "warning")) {
[13:36:42.105]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.105]                         if (muffled) 
[13:36:42.105]                           invokeRestart("muffleWarning")
[13:36:42.105]                       }
[13:36:42.105]                       else if (inherits(cond, "condition")) {
[13:36:42.105]                         if (!is.null(pattern)) {
[13:36:42.105]                           computeRestarts <- base::computeRestarts
[13:36:42.105]                           grepl <- base::grepl
[13:36:42.105]                           restarts <- computeRestarts(cond)
[13:36:42.105]                           for (restart in restarts) {
[13:36:42.105]                             name <- restart$name
[13:36:42.105]                             if (is.null(name)) 
[13:36:42.105]                               next
[13:36:42.105]                             if (!grepl(pattern, name)) 
[13:36:42.105]                               next
[13:36:42.105]                             invokeRestart(restart)
[13:36:42.105]                             muffled <- TRUE
[13:36:42.105]                             break
[13:36:42.105]                           }
[13:36:42.105]                         }
[13:36:42.105]                       }
[13:36:42.105]                       invisible(muffled)
[13:36:42.105]                     }
[13:36:42.105]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.105]                   }
[13:36:42.105]                 }
[13:36:42.105]                 else {
[13:36:42.105]                   if (TRUE) {
[13:36:42.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.105]                     {
[13:36:42.105]                       inherits <- base::inherits
[13:36:42.105]                       invokeRestart <- base::invokeRestart
[13:36:42.105]                       is.null <- base::is.null
[13:36:42.105]                       muffled <- FALSE
[13:36:42.105]                       if (inherits(cond, "message")) {
[13:36:42.105]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.105]                         if (muffled) 
[13:36:42.105]                           invokeRestart("muffleMessage")
[13:36:42.105]                       }
[13:36:42.105]                       else if (inherits(cond, "warning")) {
[13:36:42.105]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.105]                         if (muffled) 
[13:36:42.105]                           invokeRestart("muffleWarning")
[13:36:42.105]                       }
[13:36:42.105]                       else if (inherits(cond, "condition")) {
[13:36:42.105]                         if (!is.null(pattern)) {
[13:36:42.105]                           computeRestarts <- base::computeRestarts
[13:36:42.105]                           grepl <- base::grepl
[13:36:42.105]                           restarts <- computeRestarts(cond)
[13:36:42.105]                           for (restart in restarts) {
[13:36:42.105]                             name <- restart$name
[13:36:42.105]                             if (is.null(name)) 
[13:36:42.105]                               next
[13:36:42.105]                             if (!grepl(pattern, name)) 
[13:36:42.105]                               next
[13:36:42.105]                             invokeRestart(restart)
[13:36:42.105]                             muffled <- TRUE
[13:36:42.105]                             break
[13:36:42.105]                           }
[13:36:42.105]                         }
[13:36:42.105]                       }
[13:36:42.105]                       invisible(muffled)
[13:36:42.105]                     }
[13:36:42.105]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.105]                   }
[13:36:42.105]                 }
[13:36:42.105]             }
[13:36:42.105]         }))
[13:36:42.105]     }, error = function(ex) {
[13:36:42.105]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:42.105]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.105]                 ...future.rng), started = ...future.startTime, 
[13:36:42.105]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:42.105]             version = "1.8"), class = "FutureResult")
[13:36:42.105]     }, finally = {
[13:36:42.105]         if (!identical(...future.workdir, getwd())) 
[13:36:42.105]             setwd(...future.workdir)
[13:36:42.105]         {
[13:36:42.105]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:42.105]                 ...future.oldOptions$nwarnings <- NULL
[13:36:42.105]             }
[13:36:42.105]             base::options(...future.oldOptions)
[13:36:42.105]             if (.Platform$OS.type == "windows") {
[13:36:42.105]                 old_names <- names(...future.oldEnvVars)
[13:36:42.105]                 envs <- base::Sys.getenv()
[13:36:42.105]                 names <- names(envs)
[13:36:42.105]                 common <- intersect(names, old_names)
[13:36:42.105]                 added <- setdiff(names, old_names)
[13:36:42.105]                 removed <- setdiff(old_names, names)
[13:36:42.105]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:42.105]                   envs[common]]
[13:36:42.105]                 NAMES <- toupper(changed)
[13:36:42.105]                 args <- list()
[13:36:42.105]                 for (kk in seq_along(NAMES)) {
[13:36:42.105]                   name <- changed[[kk]]
[13:36:42.105]                   NAME <- NAMES[[kk]]
[13:36:42.105]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.105]                     next
[13:36:42.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.105]                 }
[13:36:42.105]                 NAMES <- toupper(added)
[13:36:42.105]                 for (kk in seq_along(NAMES)) {
[13:36:42.105]                   name <- added[[kk]]
[13:36:42.105]                   NAME <- NAMES[[kk]]
[13:36:42.105]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.105]                     next
[13:36:42.105]                   args[[name]] <- ""
[13:36:42.105]                 }
[13:36:42.105]                 NAMES <- toupper(removed)
[13:36:42.105]                 for (kk in seq_along(NAMES)) {
[13:36:42.105]                   name <- removed[[kk]]
[13:36:42.105]                   NAME <- NAMES[[kk]]
[13:36:42.105]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.105]                     next
[13:36:42.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.105]                 }
[13:36:42.105]                 if (length(args) > 0) 
[13:36:42.105]                   base::do.call(base::Sys.setenv, args = args)
[13:36:42.105]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:42.105]             }
[13:36:42.105]             else {
[13:36:42.105]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:42.105]             }
[13:36:42.105]             {
[13:36:42.105]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:42.105]                   0L) {
[13:36:42.105]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:42.105]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:42.105]                   base::options(opts)
[13:36:42.105]                 }
[13:36:42.105]                 {
[13:36:42.105]                   {
[13:36:42.105]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:42.105]                     NULL
[13:36:42.105]                   }
[13:36:42.105]                   options(future.plan = NULL)
[13:36:42.105]                   if (is.na(NA_character_)) 
[13:36:42.105]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.105]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:42.105]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:42.105]                     .init = FALSE)
[13:36:42.105]                 }
[13:36:42.105]             }
[13:36:42.105]         }
[13:36:42.105]     })
[13:36:42.105]     if (TRUE) {
[13:36:42.105]         base::sink(type = "output", split = FALSE)
[13:36:42.105]         if (TRUE) {
[13:36:42.105]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:42.105]         }
[13:36:42.105]         else {
[13:36:42.105]             ...future.result["stdout"] <- base::list(NULL)
[13:36:42.105]         }
[13:36:42.105]         base::close(...future.stdout)
[13:36:42.105]         ...future.stdout <- NULL
[13:36:42.105]     }
[13:36:42.105]     ...future.result$conditions <- ...future.conditions
[13:36:42.105]     ...future.result$finished <- base::Sys.time()
[13:36:42.105]     ...future.result
[13:36:42.105] }
[13:36:42.158] MultisessionFuture started
[13:36:42.159] result() for ClusterFuture ...
[13:36:42.159] receiveMessageFromWorker() for ClusterFuture ...
[13:36:42.159] - Validating connection of MultisessionFuture
[13:36:42.191] - received message: FutureResult
[13:36:42.192] - Received FutureResult
[13:36:42.192] - Erased future from FutureRegistry
[13:36:42.192] result() for ClusterFuture ...
[13:36:42.192] - result already collected: FutureResult
[13:36:42.192] result() for ClusterFuture ... done
[13:36:42.192] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:42.192] result() for ClusterFuture ... done
[13:36:42.193] result() for ClusterFuture ...
[13:36:42.193] - result already collected: FutureResult
[13:36:42.193] result() for ClusterFuture ... done
[13:36:42.193] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:36:42.197] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[13:36:42.198] getGlobalsAndPackages() ...
[13:36:42.198] Searching for globals...
[13:36:42.200] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:36:42.200] Searching for globals ... DONE
[13:36:42.200] Resolving globals: FALSE
[13:36:42.201] The total size of the 2 globals is 896 bytes (896 bytes)
[13:36:42.201] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:36:42.202] - globals: [2] ‘weight’, ‘group’
[13:36:42.202] - packages: [1] ‘stats’
[13:36:42.202] getGlobalsAndPackages() ... DONE
[13:36:42.202] run() for ‘Future’ ...
[13:36:42.202] - state: ‘created’
[13:36:42.203] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:42.217] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:42.217] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:42.218]   - Field: ‘node’
[13:36:42.218]   - Field: ‘label’
[13:36:42.218]   - Field: ‘local’
[13:36:42.218]   - Field: ‘owner’
[13:36:42.218]   - Field: ‘envir’
[13:36:42.218]   - Field: ‘workers’
[13:36:42.218]   - Field: ‘packages’
[13:36:42.218]   - Field: ‘gc’
[13:36:42.218]   - Field: ‘conditions’
[13:36:42.218]   - Field: ‘persistent’
[13:36:42.219]   - Field: ‘expr’
[13:36:42.219]   - Field: ‘uuid’
[13:36:42.219]   - Field: ‘seed’
[13:36:42.219]   - Field: ‘version’
[13:36:42.219]   - Field: ‘result’
[13:36:42.219]   - Field: ‘asynchronous’
[13:36:42.219]   - Field: ‘calls’
[13:36:42.219]   - Field: ‘globals’
[13:36:42.220]   - Field: ‘stdout’
[13:36:42.220]   - Field: ‘earlySignal’
[13:36:42.220]   - Field: ‘lazy’
[13:36:42.220]   - Field: ‘state’
[13:36:42.220] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:42.220] - Launch lazy future ...
[13:36:42.221] Packages needed by the future expression (n = 1): ‘stats’
[13:36:42.221] Packages needed by future strategies (n = 0): <none>
[13:36:42.221] {
[13:36:42.221]     {
[13:36:42.221]         {
[13:36:42.221]             ...future.startTime <- base::Sys.time()
[13:36:42.221]             {
[13:36:42.221]                 {
[13:36:42.221]                   {
[13:36:42.221]                     {
[13:36:42.221]                       {
[13:36:42.221]                         base::local({
[13:36:42.221]                           has_future <- base::requireNamespace("future", 
[13:36:42.221]                             quietly = TRUE)
[13:36:42.221]                           if (has_future) {
[13:36:42.221]                             ns <- base::getNamespace("future")
[13:36:42.221]                             version <- ns[[".package"]][["version"]]
[13:36:42.221]                             if (is.null(version)) 
[13:36:42.221]                               version <- utils::packageVersion("future")
[13:36:42.221]                           }
[13:36:42.221]                           else {
[13:36:42.221]                             version <- NULL
[13:36:42.221]                           }
[13:36:42.221]                           if (!has_future || version < "1.8.0") {
[13:36:42.221]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:42.221]                               "", base::R.version$version.string), 
[13:36:42.221]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:42.221]                                 base::R.version$platform, 8 * 
[13:36:42.221]                                   base::.Machine$sizeof.pointer), 
[13:36:42.221]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:42.221]                                 "release", "version")], collapse = " "), 
[13:36:42.221]                               hostname = base::Sys.info()[["nodename"]])
[13:36:42.221]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:42.221]                               info)
[13:36:42.221]                             info <- base::paste(info, collapse = "; ")
[13:36:42.221]                             if (!has_future) {
[13:36:42.221]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:42.221]                                 info)
[13:36:42.221]                             }
[13:36:42.221]                             else {
[13:36:42.221]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:42.221]                                 info, version)
[13:36:42.221]                             }
[13:36:42.221]                             base::stop(msg)
[13:36:42.221]                           }
[13:36:42.221]                         })
[13:36:42.221]                       }
[13:36:42.221]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:42.221]                       base::options(mc.cores = 1L)
[13:36:42.221]                     }
[13:36:42.221]                     base::local({
[13:36:42.221]                       for (pkg in "stats") {
[13:36:42.221]                         base::loadNamespace(pkg)
[13:36:42.221]                         base::library(pkg, character.only = TRUE)
[13:36:42.221]                       }
[13:36:42.221]                     })
[13:36:42.221]                   }
[13:36:42.221]                   ...future.strategy.old <- future::plan("list")
[13:36:42.221]                   options(future.plan = NULL)
[13:36:42.221]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.221]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:42.221]                 }
[13:36:42.221]                 ...future.workdir <- getwd()
[13:36:42.221]             }
[13:36:42.221]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:42.221]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:42.221]         }
[13:36:42.221]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:42.221]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:42.221]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:42.221]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:42.221]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:42.221]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:42.221]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:42.221]             base::names(...future.oldOptions))
[13:36:42.221]     }
[13:36:42.221]     if (FALSE) {
[13:36:42.221]     }
[13:36:42.221]     else {
[13:36:42.221]         if (TRUE) {
[13:36:42.221]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:42.221]                 open = "w")
[13:36:42.221]         }
[13:36:42.221]         else {
[13:36:42.221]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:42.221]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:42.221]         }
[13:36:42.221]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:42.221]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:42.221]             base::sink(type = "output", split = FALSE)
[13:36:42.221]             base::close(...future.stdout)
[13:36:42.221]         }, add = TRUE)
[13:36:42.221]     }
[13:36:42.221]     ...future.frame <- base::sys.nframe()
[13:36:42.221]     ...future.conditions <- base::list()
[13:36:42.221]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:42.221]     if (FALSE) {
[13:36:42.221]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:42.221]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:42.221]     }
[13:36:42.221]     ...future.result <- base::tryCatch({
[13:36:42.221]         base::withCallingHandlers({
[13:36:42.221]             ...future.value <- base::withVisible(base::local({
[13:36:42.221]                 ...future.makeSendCondition <- base::local({
[13:36:42.221]                   sendCondition <- NULL
[13:36:42.221]                   function(frame = 1L) {
[13:36:42.221]                     if (is.function(sendCondition)) 
[13:36:42.221]                       return(sendCondition)
[13:36:42.221]                     ns <- getNamespace("parallel")
[13:36:42.221]                     if (exists("sendData", mode = "function", 
[13:36:42.221]                       envir = ns)) {
[13:36:42.221]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:42.221]                         envir = ns)
[13:36:42.221]                       envir <- sys.frame(frame)
[13:36:42.221]                       master <- NULL
[13:36:42.221]                       while (!identical(envir, .GlobalEnv) && 
[13:36:42.221]                         !identical(envir, emptyenv())) {
[13:36:42.221]                         if (exists("master", mode = "list", envir = envir, 
[13:36:42.221]                           inherits = FALSE)) {
[13:36:42.221]                           master <- get("master", mode = "list", 
[13:36:42.221]                             envir = envir, inherits = FALSE)
[13:36:42.221]                           if (inherits(master, c("SOCKnode", 
[13:36:42.221]                             "SOCK0node"))) {
[13:36:42.221]                             sendCondition <<- function(cond) {
[13:36:42.221]                               data <- list(type = "VALUE", value = cond, 
[13:36:42.221]                                 success = TRUE)
[13:36:42.221]                               parallel_sendData(master, data)
[13:36:42.221]                             }
[13:36:42.221]                             return(sendCondition)
[13:36:42.221]                           }
[13:36:42.221]                         }
[13:36:42.221]                         frame <- frame + 1L
[13:36:42.221]                         envir <- sys.frame(frame)
[13:36:42.221]                       }
[13:36:42.221]                     }
[13:36:42.221]                     sendCondition <<- function(cond) NULL
[13:36:42.221]                   }
[13:36:42.221]                 })
[13:36:42.221]                 withCallingHandlers({
[13:36:42.221]                   {
[13:36:42.221]                     lm(weight ~ group - 1)
[13:36:42.221]                   }
[13:36:42.221]                 }, immediateCondition = function(cond) {
[13:36:42.221]                   sendCondition <- ...future.makeSendCondition()
[13:36:42.221]                   sendCondition(cond)
[13:36:42.221]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.221]                   {
[13:36:42.221]                     inherits <- base::inherits
[13:36:42.221]                     invokeRestart <- base::invokeRestart
[13:36:42.221]                     is.null <- base::is.null
[13:36:42.221]                     muffled <- FALSE
[13:36:42.221]                     if (inherits(cond, "message")) {
[13:36:42.221]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:42.221]                       if (muffled) 
[13:36:42.221]                         invokeRestart("muffleMessage")
[13:36:42.221]                     }
[13:36:42.221]                     else if (inherits(cond, "warning")) {
[13:36:42.221]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:42.221]                       if (muffled) 
[13:36:42.221]                         invokeRestart("muffleWarning")
[13:36:42.221]                     }
[13:36:42.221]                     else if (inherits(cond, "condition")) {
[13:36:42.221]                       if (!is.null(pattern)) {
[13:36:42.221]                         computeRestarts <- base::computeRestarts
[13:36:42.221]                         grepl <- base::grepl
[13:36:42.221]                         restarts <- computeRestarts(cond)
[13:36:42.221]                         for (restart in restarts) {
[13:36:42.221]                           name <- restart$name
[13:36:42.221]                           if (is.null(name)) 
[13:36:42.221]                             next
[13:36:42.221]                           if (!grepl(pattern, name)) 
[13:36:42.221]                             next
[13:36:42.221]                           invokeRestart(restart)
[13:36:42.221]                           muffled <- TRUE
[13:36:42.221]                           break
[13:36:42.221]                         }
[13:36:42.221]                       }
[13:36:42.221]                     }
[13:36:42.221]                     invisible(muffled)
[13:36:42.221]                   }
[13:36:42.221]                   muffleCondition(cond)
[13:36:42.221]                 })
[13:36:42.221]             }))
[13:36:42.221]             future::FutureResult(value = ...future.value$value, 
[13:36:42.221]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.221]                   ...future.rng), globalenv = if (FALSE) 
[13:36:42.221]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:42.221]                     ...future.globalenv.names))
[13:36:42.221]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:42.221]         }, condition = base::local({
[13:36:42.221]             c <- base::c
[13:36:42.221]             inherits <- base::inherits
[13:36:42.221]             invokeRestart <- base::invokeRestart
[13:36:42.221]             length <- base::length
[13:36:42.221]             list <- base::list
[13:36:42.221]             seq.int <- base::seq.int
[13:36:42.221]             signalCondition <- base::signalCondition
[13:36:42.221]             sys.calls <- base::sys.calls
[13:36:42.221]             `[[` <- base::`[[`
[13:36:42.221]             `+` <- base::`+`
[13:36:42.221]             `<<-` <- base::`<<-`
[13:36:42.221]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:42.221]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:42.221]                   3L)]
[13:36:42.221]             }
[13:36:42.221]             function(cond) {
[13:36:42.221]                 is_error <- inherits(cond, "error")
[13:36:42.221]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:42.221]                   NULL)
[13:36:42.221]                 if (is_error) {
[13:36:42.221]                   sessionInformation <- function() {
[13:36:42.221]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:42.221]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:42.221]                       search = base::search(), system = base::Sys.info())
[13:36:42.221]                   }
[13:36:42.221]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.221]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:42.221]                     cond$call), session = sessionInformation(), 
[13:36:42.221]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:42.221]                   signalCondition(cond)
[13:36:42.221]                 }
[13:36:42.221]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:42.221]                 "immediateCondition"))) {
[13:36:42.221]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:42.221]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.221]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:42.221]                   if (TRUE && !signal) {
[13:36:42.221]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.221]                     {
[13:36:42.221]                       inherits <- base::inherits
[13:36:42.221]                       invokeRestart <- base::invokeRestart
[13:36:42.221]                       is.null <- base::is.null
[13:36:42.221]                       muffled <- FALSE
[13:36:42.221]                       if (inherits(cond, "message")) {
[13:36:42.221]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.221]                         if (muffled) 
[13:36:42.221]                           invokeRestart("muffleMessage")
[13:36:42.221]                       }
[13:36:42.221]                       else if (inherits(cond, "warning")) {
[13:36:42.221]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.221]                         if (muffled) 
[13:36:42.221]                           invokeRestart("muffleWarning")
[13:36:42.221]                       }
[13:36:42.221]                       else if (inherits(cond, "condition")) {
[13:36:42.221]                         if (!is.null(pattern)) {
[13:36:42.221]                           computeRestarts <- base::computeRestarts
[13:36:42.221]                           grepl <- base::grepl
[13:36:42.221]                           restarts <- computeRestarts(cond)
[13:36:42.221]                           for (restart in restarts) {
[13:36:42.221]                             name <- restart$name
[13:36:42.221]                             if (is.null(name)) 
[13:36:42.221]                               next
[13:36:42.221]                             if (!grepl(pattern, name)) 
[13:36:42.221]                               next
[13:36:42.221]                             invokeRestart(restart)
[13:36:42.221]                             muffled <- TRUE
[13:36:42.221]                             break
[13:36:42.221]                           }
[13:36:42.221]                         }
[13:36:42.221]                       }
[13:36:42.221]                       invisible(muffled)
[13:36:42.221]                     }
[13:36:42.221]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.221]                   }
[13:36:42.221]                 }
[13:36:42.221]                 else {
[13:36:42.221]                   if (TRUE) {
[13:36:42.221]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.221]                     {
[13:36:42.221]                       inherits <- base::inherits
[13:36:42.221]                       invokeRestart <- base::invokeRestart
[13:36:42.221]                       is.null <- base::is.null
[13:36:42.221]                       muffled <- FALSE
[13:36:42.221]                       if (inherits(cond, "message")) {
[13:36:42.221]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.221]                         if (muffled) 
[13:36:42.221]                           invokeRestart("muffleMessage")
[13:36:42.221]                       }
[13:36:42.221]                       else if (inherits(cond, "warning")) {
[13:36:42.221]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.221]                         if (muffled) 
[13:36:42.221]                           invokeRestart("muffleWarning")
[13:36:42.221]                       }
[13:36:42.221]                       else if (inherits(cond, "condition")) {
[13:36:42.221]                         if (!is.null(pattern)) {
[13:36:42.221]                           computeRestarts <- base::computeRestarts
[13:36:42.221]                           grepl <- base::grepl
[13:36:42.221]                           restarts <- computeRestarts(cond)
[13:36:42.221]                           for (restart in restarts) {
[13:36:42.221]                             name <- restart$name
[13:36:42.221]                             if (is.null(name)) 
[13:36:42.221]                               next
[13:36:42.221]                             if (!grepl(pattern, name)) 
[13:36:42.221]                               next
[13:36:42.221]                             invokeRestart(restart)
[13:36:42.221]                             muffled <- TRUE
[13:36:42.221]                             break
[13:36:42.221]                           }
[13:36:42.221]                         }
[13:36:42.221]                       }
[13:36:42.221]                       invisible(muffled)
[13:36:42.221]                     }
[13:36:42.221]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.221]                   }
[13:36:42.221]                 }
[13:36:42.221]             }
[13:36:42.221]         }))
[13:36:42.221]     }, error = function(ex) {
[13:36:42.221]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:42.221]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.221]                 ...future.rng), started = ...future.startTime, 
[13:36:42.221]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:42.221]             version = "1.8"), class = "FutureResult")
[13:36:42.221]     }, finally = {
[13:36:42.221]         if (!identical(...future.workdir, getwd())) 
[13:36:42.221]             setwd(...future.workdir)
[13:36:42.221]         {
[13:36:42.221]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:42.221]                 ...future.oldOptions$nwarnings <- NULL
[13:36:42.221]             }
[13:36:42.221]             base::options(...future.oldOptions)
[13:36:42.221]             if (.Platform$OS.type == "windows") {
[13:36:42.221]                 old_names <- names(...future.oldEnvVars)
[13:36:42.221]                 envs <- base::Sys.getenv()
[13:36:42.221]                 names <- names(envs)
[13:36:42.221]                 common <- intersect(names, old_names)
[13:36:42.221]                 added <- setdiff(names, old_names)
[13:36:42.221]                 removed <- setdiff(old_names, names)
[13:36:42.221]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:42.221]                   envs[common]]
[13:36:42.221]                 NAMES <- toupper(changed)
[13:36:42.221]                 args <- list()
[13:36:42.221]                 for (kk in seq_along(NAMES)) {
[13:36:42.221]                   name <- changed[[kk]]
[13:36:42.221]                   NAME <- NAMES[[kk]]
[13:36:42.221]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.221]                     next
[13:36:42.221]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.221]                 }
[13:36:42.221]                 NAMES <- toupper(added)
[13:36:42.221]                 for (kk in seq_along(NAMES)) {
[13:36:42.221]                   name <- added[[kk]]
[13:36:42.221]                   NAME <- NAMES[[kk]]
[13:36:42.221]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.221]                     next
[13:36:42.221]                   args[[name]] <- ""
[13:36:42.221]                 }
[13:36:42.221]                 NAMES <- toupper(removed)
[13:36:42.221]                 for (kk in seq_along(NAMES)) {
[13:36:42.221]                   name <- removed[[kk]]
[13:36:42.221]                   NAME <- NAMES[[kk]]
[13:36:42.221]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.221]                     next
[13:36:42.221]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.221]                 }
[13:36:42.221]                 if (length(args) > 0) 
[13:36:42.221]                   base::do.call(base::Sys.setenv, args = args)
[13:36:42.221]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:42.221]             }
[13:36:42.221]             else {
[13:36:42.221]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:42.221]             }
[13:36:42.221]             {
[13:36:42.221]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:42.221]                   0L) {
[13:36:42.221]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:42.221]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:42.221]                   base::options(opts)
[13:36:42.221]                 }
[13:36:42.221]                 {
[13:36:42.221]                   {
[13:36:42.221]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:42.221]                     NULL
[13:36:42.221]                   }
[13:36:42.221]                   options(future.plan = NULL)
[13:36:42.221]                   if (is.na(NA_character_)) 
[13:36:42.221]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.221]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:42.221]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:42.221]                     .init = FALSE)
[13:36:42.221]                 }
[13:36:42.221]             }
[13:36:42.221]         }
[13:36:42.221]     })
[13:36:42.221]     if (TRUE) {
[13:36:42.221]         base::sink(type = "output", split = FALSE)
[13:36:42.221]         if (TRUE) {
[13:36:42.221]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:42.221]         }
[13:36:42.221]         else {
[13:36:42.221]             ...future.result["stdout"] <- base::list(NULL)
[13:36:42.221]         }
[13:36:42.221]         base::close(...future.stdout)
[13:36:42.221]         ...future.stdout <- NULL
[13:36:42.221]     }
[13:36:42.221]     ...future.result$conditions <- ...future.conditions
[13:36:42.221]     ...future.result$finished <- base::Sys.time()
[13:36:42.221]     ...future.result
[13:36:42.221] }
[13:36:42.224] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[13:36:42.224] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[13:36:42.225] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[13:36:42.225] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[13:36:42.225] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[13:36:42.226] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[13:36:42.226] MultisessionFuture started
[13:36:42.226] - Launch lazy future ... done
[13:36:42.226] run() for ‘MultisessionFuture’ ... done
[13:36:42.227] result() for ClusterFuture ...
[13:36:42.227] receiveMessageFromWorker() for ClusterFuture ...
[13:36:42.227] - Validating connection of MultisessionFuture
[13:36:42.274] - received message: FutureResult
[13:36:42.275] - Received FutureResult
[13:36:42.275] - Erased future from FutureRegistry
[13:36:42.275] result() for ClusterFuture ...
[13:36:42.275] - result already collected: FutureResult
[13:36:42.275] result() for ClusterFuture ... done
[13:36:42.275] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:42.275] result() for ClusterFuture ... done
[13:36:42.276] result() for ClusterFuture ...
[13:36:42.276] - result already collected: FutureResult
[13:36:42.276] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:36:42.278] getGlobalsAndPackages() ...
[13:36:42.278] Searching for globals...
[13:36:42.280] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:36:42.280] Searching for globals ... DONE
[13:36:42.280] Resolving globals: FALSE
[13:36:42.281] The total size of the 2 globals is 896 bytes (896 bytes)
[13:36:42.281] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:36:42.281] - globals: [2] ‘weight’, ‘group’
[13:36:42.282] - packages: [1] ‘stats’
[13:36:42.282] getGlobalsAndPackages() ... DONE
[13:36:42.282] run() for ‘Future’ ...
[13:36:42.282] - state: ‘created’
[13:36:42.282] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:42.297] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:42.297] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:42.297]   - Field: ‘node’
[13:36:42.297]   - Field: ‘label’
[13:36:42.297]   - Field: ‘local’
[13:36:42.297]   - Field: ‘owner’
[13:36:42.298]   - Field: ‘envir’
[13:36:42.298]   - Field: ‘workers’
[13:36:42.298]   - Field: ‘packages’
[13:36:42.298]   - Field: ‘gc’
[13:36:42.298]   - Field: ‘conditions’
[13:36:42.298]   - Field: ‘persistent’
[13:36:42.298]   - Field: ‘expr’
[13:36:42.298]   - Field: ‘uuid’
[13:36:42.298]   - Field: ‘seed’
[13:36:42.299]   - Field: ‘version’
[13:36:42.299]   - Field: ‘result’
[13:36:42.299]   - Field: ‘asynchronous’
[13:36:42.299]   - Field: ‘calls’
[13:36:42.299]   - Field: ‘globals’
[13:36:42.299]   - Field: ‘stdout’
[13:36:42.299]   - Field: ‘earlySignal’
[13:36:42.299]   - Field: ‘lazy’
[13:36:42.300]   - Field: ‘state’
[13:36:42.300] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:42.300] - Launch lazy future ...
[13:36:42.300] Packages needed by the future expression (n = 1): ‘stats’
[13:36:42.300] Packages needed by future strategies (n = 0): <none>
[13:36:42.301] {
[13:36:42.301]     {
[13:36:42.301]         {
[13:36:42.301]             ...future.startTime <- base::Sys.time()
[13:36:42.301]             {
[13:36:42.301]                 {
[13:36:42.301]                   {
[13:36:42.301]                     {
[13:36:42.301]                       {
[13:36:42.301]                         base::local({
[13:36:42.301]                           has_future <- base::requireNamespace("future", 
[13:36:42.301]                             quietly = TRUE)
[13:36:42.301]                           if (has_future) {
[13:36:42.301]                             ns <- base::getNamespace("future")
[13:36:42.301]                             version <- ns[[".package"]][["version"]]
[13:36:42.301]                             if (is.null(version)) 
[13:36:42.301]                               version <- utils::packageVersion("future")
[13:36:42.301]                           }
[13:36:42.301]                           else {
[13:36:42.301]                             version <- NULL
[13:36:42.301]                           }
[13:36:42.301]                           if (!has_future || version < "1.8.0") {
[13:36:42.301]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:42.301]                               "", base::R.version$version.string), 
[13:36:42.301]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:42.301]                                 base::R.version$platform, 8 * 
[13:36:42.301]                                   base::.Machine$sizeof.pointer), 
[13:36:42.301]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:42.301]                                 "release", "version")], collapse = " "), 
[13:36:42.301]                               hostname = base::Sys.info()[["nodename"]])
[13:36:42.301]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:42.301]                               info)
[13:36:42.301]                             info <- base::paste(info, collapse = "; ")
[13:36:42.301]                             if (!has_future) {
[13:36:42.301]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:42.301]                                 info)
[13:36:42.301]                             }
[13:36:42.301]                             else {
[13:36:42.301]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:42.301]                                 info, version)
[13:36:42.301]                             }
[13:36:42.301]                             base::stop(msg)
[13:36:42.301]                           }
[13:36:42.301]                         })
[13:36:42.301]                       }
[13:36:42.301]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:42.301]                       base::options(mc.cores = 1L)
[13:36:42.301]                     }
[13:36:42.301]                     base::local({
[13:36:42.301]                       for (pkg in "stats") {
[13:36:42.301]                         base::loadNamespace(pkg)
[13:36:42.301]                         base::library(pkg, character.only = TRUE)
[13:36:42.301]                       }
[13:36:42.301]                     })
[13:36:42.301]                   }
[13:36:42.301]                   ...future.strategy.old <- future::plan("list")
[13:36:42.301]                   options(future.plan = NULL)
[13:36:42.301]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.301]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:42.301]                 }
[13:36:42.301]                 ...future.workdir <- getwd()
[13:36:42.301]             }
[13:36:42.301]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:42.301]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:42.301]         }
[13:36:42.301]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:42.301]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:42.301]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:42.301]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:42.301]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:42.301]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:42.301]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:42.301]             base::names(...future.oldOptions))
[13:36:42.301]     }
[13:36:42.301]     if (FALSE) {
[13:36:42.301]     }
[13:36:42.301]     else {
[13:36:42.301]         if (TRUE) {
[13:36:42.301]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:42.301]                 open = "w")
[13:36:42.301]         }
[13:36:42.301]         else {
[13:36:42.301]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:42.301]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:42.301]         }
[13:36:42.301]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:42.301]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:42.301]             base::sink(type = "output", split = FALSE)
[13:36:42.301]             base::close(...future.stdout)
[13:36:42.301]         }, add = TRUE)
[13:36:42.301]     }
[13:36:42.301]     ...future.frame <- base::sys.nframe()
[13:36:42.301]     ...future.conditions <- base::list()
[13:36:42.301]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:42.301]     if (FALSE) {
[13:36:42.301]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:42.301]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:42.301]     }
[13:36:42.301]     ...future.result <- base::tryCatch({
[13:36:42.301]         base::withCallingHandlers({
[13:36:42.301]             ...future.value <- base::withVisible(base::local({
[13:36:42.301]                 ...future.makeSendCondition <- base::local({
[13:36:42.301]                   sendCondition <- NULL
[13:36:42.301]                   function(frame = 1L) {
[13:36:42.301]                     if (is.function(sendCondition)) 
[13:36:42.301]                       return(sendCondition)
[13:36:42.301]                     ns <- getNamespace("parallel")
[13:36:42.301]                     if (exists("sendData", mode = "function", 
[13:36:42.301]                       envir = ns)) {
[13:36:42.301]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:42.301]                         envir = ns)
[13:36:42.301]                       envir <- sys.frame(frame)
[13:36:42.301]                       master <- NULL
[13:36:42.301]                       while (!identical(envir, .GlobalEnv) && 
[13:36:42.301]                         !identical(envir, emptyenv())) {
[13:36:42.301]                         if (exists("master", mode = "list", envir = envir, 
[13:36:42.301]                           inherits = FALSE)) {
[13:36:42.301]                           master <- get("master", mode = "list", 
[13:36:42.301]                             envir = envir, inherits = FALSE)
[13:36:42.301]                           if (inherits(master, c("SOCKnode", 
[13:36:42.301]                             "SOCK0node"))) {
[13:36:42.301]                             sendCondition <<- function(cond) {
[13:36:42.301]                               data <- list(type = "VALUE", value = cond, 
[13:36:42.301]                                 success = TRUE)
[13:36:42.301]                               parallel_sendData(master, data)
[13:36:42.301]                             }
[13:36:42.301]                             return(sendCondition)
[13:36:42.301]                           }
[13:36:42.301]                         }
[13:36:42.301]                         frame <- frame + 1L
[13:36:42.301]                         envir <- sys.frame(frame)
[13:36:42.301]                       }
[13:36:42.301]                     }
[13:36:42.301]                     sendCondition <<- function(cond) NULL
[13:36:42.301]                   }
[13:36:42.301]                 })
[13:36:42.301]                 withCallingHandlers({
[13:36:42.301]                   {
[13:36:42.301]                     lm(weight ~ group - 1)
[13:36:42.301]                   }
[13:36:42.301]                 }, immediateCondition = function(cond) {
[13:36:42.301]                   sendCondition <- ...future.makeSendCondition()
[13:36:42.301]                   sendCondition(cond)
[13:36:42.301]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.301]                   {
[13:36:42.301]                     inherits <- base::inherits
[13:36:42.301]                     invokeRestart <- base::invokeRestart
[13:36:42.301]                     is.null <- base::is.null
[13:36:42.301]                     muffled <- FALSE
[13:36:42.301]                     if (inherits(cond, "message")) {
[13:36:42.301]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:42.301]                       if (muffled) 
[13:36:42.301]                         invokeRestart("muffleMessage")
[13:36:42.301]                     }
[13:36:42.301]                     else if (inherits(cond, "warning")) {
[13:36:42.301]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:42.301]                       if (muffled) 
[13:36:42.301]                         invokeRestart("muffleWarning")
[13:36:42.301]                     }
[13:36:42.301]                     else if (inherits(cond, "condition")) {
[13:36:42.301]                       if (!is.null(pattern)) {
[13:36:42.301]                         computeRestarts <- base::computeRestarts
[13:36:42.301]                         grepl <- base::grepl
[13:36:42.301]                         restarts <- computeRestarts(cond)
[13:36:42.301]                         for (restart in restarts) {
[13:36:42.301]                           name <- restart$name
[13:36:42.301]                           if (is.null(name)) 
[13:36:42.301]                             next
[13:36:42.301]                           if (!grepl(pattern, name)) 
[13:36:42.301]                             next
[13:36:42.301]                           invokeRestart(restart)
[13:36:42.301]                           muffled <- TRUE
[13:36:42.301]                           break
[13:36:42.301]                         }
[13:36:42.301]                       }
[13:36:42.301]                     }
[13:36:42.301]                     invisible(muffled)
[13:36:42.301]                   }
[13:36:42.301]                   muffleCondition(cond)
[13:36:42.301]                 })
[13:36:42.301]             }))
[13:36:42.301]             future::FutureResult(value = ...future.value$value, 
[13:36:42.301]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.301]                   ...future.rng), globalenv = if (FALSE) 
[13:36:42.301]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:42.301]                     ...future.globalenv.names))
[13:36:42.301]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:42.301]         }, condition = base::local({
[13:36:42.301]             c <- base::c
[13:36:42.301]             inherits <- base::inherits
[13:36:42.301]             invokeRestart <- base::invokeRestart
[13:36:42.301]             length <- base::length
[13:36:42.301]             list <- base::list
[13:36:42.301]             seq.int <- base::seq.int
[13:36:42.301]             signalCondition <- base::signalCondition
[13:36:42.301]             sys.calls <- base::sys.calls
[13:36:42.301]             `[[` <- base::`[[`
[13:36:42.301]             `+` <- base::`+`
[13:36:42.301]             `<<-` <- base::`<<-`
[13:36:42.301]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:42.301]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:42.301]                   3L)]
[13:36:42.301]             }
[13:36:42.301]             function(cond) {
[13:36:42.301]                 is_error <- inherits(cond, "error")
[13:36:42.301]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:42.301]                   NULL)
[13:36:42.301]                 if (is_error) {
[13:36:42.301]                   sessionInformation <- function() {
[13:36:42.301]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:42.301]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:42.301]                       search = base::search(), system = base::Sys.info())
[13:36:42.301]                   }
[13:36:42.301]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.301]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:42.301]                     cond$call), session = sessionInformation(), 
[13:36:42.301]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:42.301]                   signalCondition(cond)
[13:36:42.301]                 }
[13:36:42.301]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:42.301]                 "immediateCondition"))) {
[13:36:42.301]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:42.301]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.301]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:42.301]                   if (TRUE && !signal) {
[13:36:42.301]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.301]                     {
[13:36:42.301]                       inherits <- base::inherits
[13:36:42.301]                       invokeRestart <- base::invokeRestart
[13:36:42.301]                       is.null <- base::is.null
[13:36:42.301]                       muffled <- FALSE
[13:36:42.301]                       if (inherits(cond, "message")) {
[13:36:42.301]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.301]                         if (muffled) 
[13:36:42.301]                           invokeRestart("muffleMessage")
[13:36:42.301]                       }
[13:36:42.301]                       else if (inherits(cond, "warning")) {
[13:36:42.301]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.301]                         if (muffled) 
[13:36:42.301]                           invokeRestart("muffleWarning")
[13:36:42.301]                       }
[13:36:42.301]                       else if (inherits(cond, "condition")) {
[13:36:42.301]                         if (!is.null(pattern)) {
[13:36:42.301]                           computeRestarts <- base::computeRestarts
[13:36:42.301]                           grepl <- base::grepl
[13:36:42.301]                           restarts <- computeRestarts(cond)
[13:36:42.301]                           for (restart in restarts) {
[13:36:42.301]                             name <- restart$name
[13:36:42.301]                             if (is.null(name)) 
[13:36:42.301]                               next
[13:36:42.301]                             if (!grepl(pattern, name)) 
[13:36:42.301]                               next
[13:36:42.301]                             invokeRestart(restart)
[13:36:42.301]                             muffled <- TRUE
[13:36:42.301]                             break
[13:36:42.301]                           }
[13:36:42.301]                         }
[13:36:42.301]                       }
[13:36:42.301]                       invisible(muffled)
[13:36:42.301]                     }
[13:36:42.301]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.301]                   }
[13:36:42.301]                 }
[13:36:42.301]                 else {
[13:36:42.301]                   if (TRUE) {
[13:36:42.301]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.301]                     {
[13:36:42.301]                       inherits <- base::inherits
[13:36:42.301]                       invokeRestart <- base::invokeRestart
[13:36:42.301]                       is.null <- base::is.null
[13:36:42.301]                       muffled <- FALSE
[13:36:42.301]                       if (inherits(cond, "message")) {
[13:36:42.301]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.301]                         if (muffled) 
[13:36:42.301]                           invokeRestart("muffleMessage")
[13:36:42.301]                       }
[13:36:42.301]                       else if (inherits(cond, "warning")) {
[13:36:42.301]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.301]                         if (muffled) 
[13:36:42.301]                           invokeRestart("muffleWarning")
[13:36:42.301]                       }
[13:36:42.301]                       else if (inherits(cond, "condition")) {
[13:36:42.301]                         if (!is.null(pattern)) {
[13:36:42.301]                           computeRestarts <- base::computeRestarts
[13:36:42.301]                           grepl <- base::grepl
[13:36:42.301]                           restarts <- computeRestarts(cond)
[13:36:42.301]                           for (restart in restarts) {
[13:36:42.301]                             name <- restart$name
[13:36:42.301]                             if (is.null(name)) 
[13:36:42.301]                               next
[13:36:42.301]                             if (!grepl(pattern, name)) 
[13:36:42.301]                               next
[13:36:42.301]                             invokeRestart(restart)
[13:36:42.301]                             muffled <- TRUE
[13:36:42.301]                             break
[13:36:42.301]                           }
[13:36:42.301]                         }
[13:36:42.301]                       }
[13:36:42.301]                       invisible(muffled)
[13:36:42.301]                     }
[13:36:42.301]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.301]                   }
[13:36:42.301]                 }
[13:36:42.301]             }
[13:36:42.301]         }))
[13:36:42.301]     }, error = function(ex) {
[13:36:42.301]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:42.301]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.301]                 ...future.rng), started = ...future.startTime, 
[13:36:42.301]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:42.301]             version = "1.8"), class = "FutureResult")
[13:36:42.301]     }, finally = {
[13:36:42.301]         if (!identical(...future.workdir, getwd())) 
[13:36:42.301]             setwd(...future.workdir)
[13:36:42.301]         {
[13:36:42.301]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:42.301]                 ...future.oldOptions$nwarnings <- NULL
[13:36:42.301]             }
[13:36:42.301]             base::options(...future.oldOptions)
[13:36:42.301]             if (.Platform$OS.type == "windows") {
[13:36:42.301]                 old_names <- names(...future.oldEnvVars)
[13:36:42.301]                 envs <- base::Sys.getenv()
[13:36:42.301]                 names <- names(envs)
[13:36:42.301]                 common <- intersect(names, old_names)
[13:36:42.301]                 added <- setdiff(names, old_names)
[13:36:42.301]                 removed <- setdiff(old_names, names)
[13:36:42.301]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:42.301]                   envs[common]]
[13:36:42.301]                 NAMES <- toupper(changed)
[13:36:42.301]                 args <- list()
[13:36:42.301]                 for (kk in seq_along(NAMES)) {
[13:36:42.301]                   name <- changed[[kk]]
[13:36:42.301]                   NAME <- NAMES[[kk]]
[13:36:42.301]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.301]                     next
[13:36:42.301]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.301]                 }
[13:36:42.301]                 NAMES <- toupper(added)
[13:36:42.301]                 for (kk in seq_along(NAMES)) {
[13:36:42.301]                   name <- added[[kk]]
[13:36:42.301]                   NAME <- NAMES[[kk]]
[13:36:42.301]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.301]                     next
[13:36:42.301]                   args[[name]] <- ""
[13:36:42.301]                 }
[13:36:42.301]                 NAMES <- toupper(removed)
[13:36:42.301]                 for (kk in seq_along(NAMES)) {
[13:36:42.301]                   name <- removed[[kk]]
[13:36:42.301]                   NAME <- NAMES[[kk]]
[13:36:42.301]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.301]                     next
[13:36:42.301]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.301]                 }
[13:36:42.301]                 if (length(args) > 0) 
[13:36:42.301]                   base::do.call(base::Sys.setenv, args = args)
[13:36:42.301]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:42.301]             }
[13:36:42.301]             else {
[13:36:42.301]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:42.301]             }
[13:36:42.301]             {
[13:36:42.301]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:42.301]                   0L) {
[13:36:42.301]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:42.301]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:42.301]                   base::options(opts)
[13:36:42.301]                 }
[13:36:42.301]                 {
[13:36:42.301]                   {
[13:36:42.301]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:42.301]                     NULL
[13:36:42.301]                   }
[13:36:42.301]                   options(future.plan = NULL)
[13:36:42.301]                   if (is.na(NA_character_)) 
[13:36:42.301]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.301]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:42.301]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:42.301]                     .init = FALSE)
[13:36:42.301]                 }
[13:36:42.301]             }
[13:36:42.301]         }
[13:36:42.301]     })
[13:36:42.301]     if (TRUE) {
[13:36:42.301]         base::sink(type = "output", split = FALSE)
[13:36:42.301]         if (TRUE) {
[13:36:42.301]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:42.301]         }
[13:36:42.301]         else {
[13:36:42.301]             ...future.result["stdout"] <- base::list(NULL)
[13:36:42.301]         }
[13:36:42.301]         base::close(...future.stdout)
[13:36:42.301]         ...future.stdout <- NULL
[13:36:42.301]     }
[13:36:42.301]     ...future.result$conditions <- ...future.conditions
[13:36:42.301]     ...future.result$finished <- base::Sys.time()
[13:36:42.301]     ...future.result
[13:36:42.301] }
[13:36:42.304] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[13:36:42.304] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[13:36:42.304] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[13:36:42.305] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[13:36:42.305] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[13:36:42.305] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[13:36:42.306] MultisessionFuture started
[13:36:42.306] - Launch lazy future ... done
[13:36:42.306] run() for ‘MultisessionFuture’ ... done
[13:36:42.306] result() for ClusterFuture ...
[13:36:42.306] receiveMessageFromWorker() for ClusterFuture ...
[13:36:42.307] - Validating connection of MultisessionFuture
[13:36:42.349] - received message: FutureResult
[13:36:42.349] - Received FutureResult
[13:36:42.349] - Erased future from FutureRegistry
[13:36:42.349] result() for ClusterFuture ...
[13:36:42.349] - result already collected: FutureResult
[13:36:42.349] result() for ClusterFuture ... done
[13:36:42.349] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:42.349] result() for ClusterFuture ... done
[13:36:42.350] result() for ClusterFuture ...
[13:36:42.350] - result already collected: FutureResult
[13:36:42.350] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:36:42.352] getGlobalsAndPackages() ...
[13:36:42.352] Searching for globals...
[13:36:42.354] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:36:42.354] Searching for globals ... DONE
[13:36:42.354] Resolving globals: FALSE
[13:36:42.355] The total size of the 2 globals is 896 bytes (896 bytes)
[13:36:42.355] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:36:42.356] - globals: [2] ‘weight’, ‘group’
[13:36:42.356] - packages: [1] ‘stats’
[13:36:42.356] getGlobalsAndPackages() ... DONE
[13:36:42.356] run() for ‘Future’ ...
[13:36:42.356] - state: ‘created’
[13:36:42.356] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:42.371] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:42.371] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:42.371]   - Field: ‘node’
[13:36:42.371]   - Field: ‘label’
[13:36:42.371]   - Field: ‘local’
[13:36:42.371]   - Field: ‘owner’
[13:36:42.372]   - Field: ‘envir’
[13:36:42.372]   - Field: ‘workers’
[13:36:42.372]   - Field: ‘packages’
[13:36:42.372]   - Field: ‘gc’
[13:36:42.372]   - Field: ‘conditions’
[13:36:42.372]   - Field: ‘persistent’
[13:36:42.372]   - Field: ‘expr’
[13:36:42.372]   - Field: ‘uuid’
[13:36:42.372]   - Field: ‘seed’
[13:36:42.373]   - Field: ‘version’
[13:36:42.373]   - Field: ‘result’
[13:36:42.373]   - Field: ‘asynchronous’
[13:36:42.373]   - Field: ‘calls’
[13:36:42.373]   - Field: ‘globals’
[13:36:42.373]   - Field: ‘stdout’
[13:36:42.373]   - Field: ‘earlySignal’
[13:36:42.373]   - Field: ‘lazy’
[13:36:42.373]   - Field: ‘state’
[13:36:42.374] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:42.374] - Launch lazy future ...
[13:36:42.374] Packages needed by the future expression (n = 1): ‘stats’
[13:36:42.374] Packages needed by future strategies (n = 0): <none>
[13:36:42.375] {
[13:36:42.375]     {
[13:36:42.375]         {
[13:36:42.375]             ...future.startTime <- base::Sys.time()
[13:36:42.375]             {
[13:36:42.375]                 {
[13:36:42.375]                   {
[13:36:42.375]                     {
[13:36:42.375]                       {
[13:36:42.375]                         base::local({
[13:36:42.375]                           has_future <- base::requireNamespace("future", 
[13:36:42.375]                             quietly = TRUE)
[13:36:42.375]                           if (has_future) {
[13:36:42.375]                             ns <- base::getNamespace("future")
[13:36:42.375]                             version <- ns[[".package"]][["version"]]
[13:36:42.375]                             if (is.null(version)) 
[13:36:42.375]                               version <- utils::packageVersion("future")
[13:36:42.375]                           }
[13:36:42.375]                           else {
[13:36:42.375]                             version <- NULL
[13:36:42.375]                           }
[13:36:42.375]                           if (!has_future || version < "1.8.0") {
[13:36:42.375]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:42.375]                               "", base::R.version$version.string), 
[13:36:42.375]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:42.375]                                 base::R.version$platform, 8 * 
[13:36:42.375]                                   base::.Machine$sizeof.pointer), 
[13:36:42.375]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:42.375]                                 "release", "version")], collapse = " "), 
[13:36:42.375]                               hostname = base::Sys.info()[["nodename"]])
[13:36:42.375]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:42.375]                               info)
[13:36:42.375]                             info <- base::paste(info, collapse = "; ")
[13:36:42.375]                             if (!has_future) {
[13:36:42.375]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:42.375]                                 info)
[13:36:42.375]                             }
[13:36:42.375]                             else {
[13:36:42.375]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:42.375]                                 info, version)
[13:36:42.375]                             }
[13:36:42.375]                             base::stop(msg)
[13:36:42.375]                           }
[13:36:42.375]                         })
[13:36:42.375]                       }
[13:36:42.375]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:42.375]                       base::options(mc.cores = 1L)
[13:36:42.375]                     }
[13:36:42.375]                     base::local({
[13:36:42.375]                       for (pkg in "stats") {
[13:36:42.375]                         base::loadNamespace(pkg)
[13:36:42.375]                         base::library(pkg, character.only = TRUE)
[13:36:42.375]                       }
[13:36:42.375]                     })
[13:36:42.375]                   }
[13:36:42.375]                   ...future.strategy.old <- future::plan("list")
[13:36:42.375]                   options(future.plan = NULL)
[13:36:42.375]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.375]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:42.375]                 }
[13:36:42.375]                 ...future.workdir <- getwd()
[13:36:42.375]             }
[13:36:42.375]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:42.375]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:42.375]         }
[13:36:42.375]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:42.375]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:42.375]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:42.375]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:42.375]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:42.375]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:42.375]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:42.375]             base::names(...future.oldOptions))
[13:36:42.375]     }
[13:36:42.375]     if (FALSE) {
[13:36:42.375]     }
[13:36:42.375]     else {
[13:36:42.375]         if (TRUE) {
[13:36:42.375]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:42.375]                 open = "w")
[13:36:42.375]         }
[13:36:42.375]         else {
[13:36:42.375]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:42.375]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:42.375]         }
[13:36:42.375]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:42.375]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:42.375]             base::sink(type = "output", split = FALSE)
[13:36:42.375]             base::close(...future.stdout)
[13:36:42.375]         }, add = TRUE)
[13:36:42.375]     }
[13:36:42.375]     ...future.frame <- base::sys.nframe()
[13:36:42.375]     ...future.conditions <- base::list()
[13:36:42.375]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:42.375]     if (FALSE) {
[13:36:42.375]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:42.375]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:42.375]     }
[13:36:42.375]     ...future.result <- base::tryCatch({
[13:36:42.375]         base::withCallingHandlers({
[13:36:42.375]             ...future.value <- base::withVisible(base::local({
[13:36:42.375]                 ...future.makeSendCondition <- base::local({
[13:36:42.375]                   sendCondition <- NULL
[13:36:42.375]                   function(frame = 1L) {
[13:36:42.375]                     if (is.function(sendCondition)) 
[13:36:42.375]                       return(sendCondition)
[13:36:42.375]                     ns <- getNamespace("parallel")
[13:36:42.375]                     if (exists("sendData", mode = "function", 
[13:36:42.375]                       envir = ns)) {
[13:36:42.375]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:42.375]                         envir = ns)
[13:36:42.375]                       envir <- sys.frame(frame)
[13:36:42.375]                       master <- NULL
[13:36:42.375]                       while (!identical(envir, .GlobalEnv) && 
[13:36:42.375]                         !identical(envir, emptyenv())) {
[13:36:42.375]                         if (exists("master", mode = "list", envir = envir, 
[13:36:42.375]                           inherits = FALSE)) {
[13:36:42.375]                           master <- get("master", mode = "list", 
[13:36:42.375]                             envir = envir, inherits = FALSE)
[13:36:42.375]                           if (inherits(master, c("SOCKnode", 
[13:36:42.375]                             "SOCK0node"))) {
[13:36:42.375]                             sendCondition <<- function(cond) {
[13:36:42.375]                               data <- list(type = "VALUE", value = cond, 
[13:36:42.375]                                 success = TRUE)
[13:36:42.375]                               parallel_sendData(master, data)
[13:36:42.375]                             }
[13:36:42.375]                             return(sendCondition)
[13:36:42.375]                           }
[13:36:42.375]                         }
[13:36:42.375]                         frame <- frame + 1L
[13:36:42.375]                         envir <- sys.frame(frame)
[13:36:42.375]                       }
[13:36:42.375]                     }
[13:36:42.375]                     sendCondition <<- function(cond) NULL
[13:36:42.375]                   }
[13:36:42.375]                 })
[13:36:42.375]                 withCallingHandlers({
[13:36:42.375]                   {
[13:36:42.375]                     lm(weight ~ group - 1)
[13:36:42.375]                   }
[13:36:42.375]                 }, immediateCondition = function(cond) {
[13:36:42.375]                   sendCondition <- ...future.makeSendCondition()
[13:36:42.375]                   sendCondition(cond)
[13:36:42.375]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.375]                   {
[13:36:42.375]                     inherits <- base::inherits
[13:36:42.375]                     invokeRestart <- base::invokeRestart
[13:36:42.375]                     is.null <- base::is.null
[13:36:42.375]                     muffled <- FALSE
[13:36:42.375]                     if (inherits(cond, "message")) {
[13:36:42.375]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:42.375]                       if (muffled) 
[13:36:42.375]                         invokeRestart("muffleMessage")
[13:36:42.375]                     }
[13:36:42.375]                     else if (inherits(cond, "warning")) {
[13:36:42.375]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:42.375]                       if (muffled) 
[13:36:42.375]                         invokeRestart("muffleWarning")
[13:36:42.375]                     }
[13:36:42.375]                     else if (inherits(cond, "condition")) {
[13:36:42.375]                       if (!is.null(pattern)) {
[13:36:42.375]                         computeRestarts <- base::computeRestarts
[13:36:42.375]                         grepl <- base::grepl
[13:36:42.375]                         restarts <- computeRestarts(cond)
[13:36:42.375]                         for (restart in restarts) {
[13:36:42.375]                           name <- restart$name
[13:36:42.375]                           if (is.null(name)) 
[13:36:42.375]                             next
[13:36:42.375]                           if (!grepl(pattern, name)) 
[13:36:42.375]                             next
[13:36:42.375]                           invokeRestart(restart)
[13:36:42.375]                           muffled <- TRUE
[13:36:42.375]                           break
[13:36:42.375]                         }
[13:36:42.375]                       }
[13:36:42.375]                     }
[13:36:42.375]                     invisible(muffled)
[13:36:42.375]                   }
[13:36:42.375]                   muffleCondition(cond)
[13:36:42.375]                 })
[13:36:42.375]             }))
[13:36:42.375]             future::FutureResult(value = ...future.value$value, 
[13:36:42.375]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.375]                   ...future.rng), globalenv = if (FALSE) 
[13:36:42.375]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:42.375]                     ...future.globalenv.names))
[13:36:42.375]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:42.375]         }, condition = base::local({
[13:36:42.375]             c <- base::c
[13:36:42.375]             inherits <- base::inherits
[13:36:42.375]             invokeRestart <- base::invokeRestart
[13:36:42.375]             length <- base::length
[13:36:42.375]             list <- base::list
[13:36:42.375]             seq.int <- base::seq.int
[13:36:42.375]             signalCondition <- base::signalCondition
[13:36:42.375]             sys.calls <- base::sys.calls
[13:36:42.375]             `[[` <- base::`[[`
[13:36:42.375]             `+` <- base::`+`
[13:36:42.375]             `<<-` <- base::`<<-`
[13:36:42.375]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:42.375]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:42.375]                   3L)]
[13:36:42.375]             }
[13:36:42.375]             function(cond) {
[13:36:42.375]                 is_error <- inherits(cond, "error")
[13:36:42.375]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:42.375]                   NULL)
[13:36:42.375]                 if (is_error) {
[13:36:42.375]                   sessionInformation <- function() {
[13:36:42.375]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:42.375]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:42.375]                       search = base::search(), system = base::Sys.info())
[13:36:42.375]                   }
[13:36:42.375]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.375]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:42.375]                     cond$call), session = sessionInformation(), 
[13:36:42.375]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:42.375]                   signalCondition(cond)
[13:36:42.375]                 }
[13:36:42.375]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:42.375]                 "immediateCondition"))) {
[13:36:42.375]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:42.375]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.375]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:42.375]                   if (TRUE && !signal) {
[13:36:42.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.375]                     {
[13:36:42.375]                       inherits <- base::inherits
[13:36:42.375]                       invokeRestart <- base::invokeRestart
[13:36:42.375]                       is.null <- base::is.null
[13:36:42.375]                       muffled <- FALSE
[13:36:42.375]                       if (inherits(cond, "message")) {
[13:36:42.375]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.375]                         if (muffled) 
[13:36:42.375]                           invokeRestart("muffleMessage")
[13:36:42.375]                       }
[13:36:42.375]                       else if (inherits(cond, "warning")) {
[13:36:42.375]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.375]                         if (muffled) 
[13:36:42.375]                           invokeRestart("muffleWarning")
[13:36:42.375]                       }
[13:36:42.375]                       else if (inherits(cond, "condition")) {
[13:36:42.375]                         if (!is.null(pattern)) {
[13:36:42.375]                           computeRestarts <- base::computeRestarts
[13:36:42.375]                           grepl <- base::grepl
[13:36:42.375]                           restarts <- computeRestarts(cond)
[13:36:42.375]                           for (restart in restarts) {
[13:36:42.375]                             name <- restart$name
[13:36:42.375]                             if (is.null(name)) 
[13:36:42.375]                               next
[13:36:42.375]                             if (!grepl(pattern, name)) 
[13:36:42.375]                               next
[13:36:42.375]                             invokeRestart(restart)
[13:36:42.375]                             muffled <- TRUE
[13:36:42.375]                             break
[13:36:42.375]                           }
[13:36:42.375]                         }
[13:36:42.375]                       }
[13:36:42.375]                       invisible(muffled)
[13:36:42.375]                     }
[13:36:42.375]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.375]                   }
[13:36:42.375]                 }
[13:36:42.375]                 else {
[13:36:42.375]                   if (TRUE) {
[13:36:42.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.375]                     {
[13:36:42.375]                       inherits <- base::inherits
[13:36:42.375]                       invokeRestart <- base::invokeRestart
[13:36:42.375]                       is.null <- base::is.null
[13:36:42.375]                       muffled <- FALSE
[13:36:42.375]                       if (inherits(cond, "message")) {
[13:36:42.375]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.375]                         if (muffled) 
[13:36:42.375]                           invokeRestart("muffleMessage")
[13:36:42.375]                       }
[13:36:42.375]                       else if (inherits(cond, "warning")) {
[13:36:42.375]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.375]                         if (muffled) 
[13:36:42.375]                           invokeRestart("muffleWarning")
[13:36:42.375]                       }
[13:36:42.375]                       else if (inherits(cond, "condition")) {
[13:36:42.375]                         if (!is.null(pattern)) {
[13:36:42.375]                           computeRestarts <- base::computeRestarts
[13:36:42.375]                           grepl <- base::grepl
[13:36:42.375]                           restarts <- computeRestarts(cond)
[13:36:42.375]                           for (restart in restarts) {
[13:36:42.375]                             name <- restart$name
[13:36:42.375]                             if (is.null(name)) 
[13:36:42.375]                               next
[13:36:42.375]                             if (!grepl(pattern, name)) 
[13:36:42.375]                               next
[13:36:42.375]                             invokeRestart(restart)
[13:36:42.375]                             muffled <- TRUE
[13:36:42.375]                             break
[13:36:42.375]                           }
[13:36:42.375]                         }
[13:36:42.375]                       }
[13:36:42.375]                       invisible(muffled)
[13:36:42.375]                     }
[13:36:42.375]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.375]                   }
[13:36:42.375]                 }
[13:36:42.375]             }
[13:36:42.375]         }))
[13:36:42.375]     }, error = function(ex) {
[13:36:42.375]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:42.375]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.375]                 ...future.rng), started = ...future.startTime, 
[13:36:42.375]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:42.375]             version = "1.8"), class = "FutureResult")
[13:36:42.375]     }, finally = {
[13:36:42.375]         if (!identical(...future.workdir, getwd())) 
[13:36:42.375]             setwd(...future.workdir)
[13:36:42.375]         {
[13:36:42.375]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:42.375]                 ...future.oldOptions$nwarnings <- NULL
[13:36:42.375]             }
[13:36:42.375]             base::options(...future.oldOptions)
[13:36:42.375]             if (.Platform$OS.type == "windows") {
[13:36:42.375]                 old_names <- names(...future.oldEnvVars)
[13:36:42.375]                 envs <- base::Sys.getenv()
[13:36:42.375]                 names <- names(envs)
[13:36:42.375]                 common <- intersect(names, old_names)
[13:36:42.375]                 added <- setdiff(names, old_names)
[13:36:42.375]                 removed <- setdiff(old_names, names)
[13:36:42.375]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:42.375]                   envs[common]]
[13:36:42.375]                 NAMES <- toupper(changed)
[13:36:42.375]                 args <- list()
[13:36:42.375]                 for (kk in seq_along(NAMES)) {
[13:36:42.375]                   name <- changed[[kk]]
[13:36:42.375]                   NAME <- NAMES[[kk]]
[13:36:42.375]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.375]                     next
[13:36:42.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.375]                 }
[13:36:42.375]                 NAMES <- toupper(added)
[13:36:42.375]                 for (kk in seq_along(NAMES)) {
[13:36:42.375]                   name <- added[[kk]]
[13:36:42.375]                   NAME <- NAMES[[kk]]
[13:36:42.375]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.375]                     next
[13:36:42.375]                   args[[name]] <- ""
[13:36:42.375]                 }
[13:36:42.375]                 NAMES <- toupper(removed)
[13:36:42.375]                 for (kk in seq_along(NAMES)) {
[13:36:42.375]                   name <- removed[[kk]]
[13:36:42.375]                   NAME <- NAMES[[kk]]
[13:36:42.375]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.375]                     next
[13:36:42.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.375]                 }
[13:36:42.375]                 if (length(args) > 0) 
[13:36:42.375]                   base::do.call(base::Sys.setenv, args = args)
[13:36:42.375]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:42.375]             }
[13:36:42.375]             else {
[13:36:42.375]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:42.375]             }
[13:36:42.375]             {
[13:36:42.375]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:42.375]                   0L) {
[13:36:42.375]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:42.375]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:42.375]                   base::options(opts)
[13:36:42.375]                 }
[13:36:42.375]                 {
[13:36:42.375]                   {
[13:36:42.375]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:42.375]                     NULL
[13:36:42.375]                   }
[13:36:42.375]                   options(future.plan = NULL)
[13:36:42.375]                   if (is.na(NA_character_)) 
[13:36:42.375]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.375]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:42.375]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:42.375]                     .init = FALSE)
[13:36:42.375]                 }
[13:36:42.375]             }
[13:36:42.375]         }
[13:36:42.375]     })
[13:36:42.375]     if (TRUE) {
[13:36:42.375]         base::sink(type = "output", split = FALSE)
[13:36:42.375]         if (TRUE) {
[13:36:42.375]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:42.375]         }
[13:36:42.375]         else {
[13:36:42.375]             ...future.result["stdout"] <- base::list(NULL)
[13:36:42.375]         }
[13:36:42.375]         base::close(...future.stdout)
[13:36:42.375]         ...future.stdout <- NULL
[13:36:42.375]     }
[13:36:42.375]     ...future.result$conditions <- ...future.conditions
[13:36:42.375]     ...future.result$finished <- base::Sys.time()
[13:36:42.375]     ...future.result
[13:36:42.375] }
[13:36:42.378] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[13:36:42.378] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[13:36:42.378] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[13:36:42.378] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[13:36:42.379] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[13:36:42.381] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[13:36:42.382] MultisessionFuture started
[13:36:42.382] - Launch lazy future ... done
[13:36:42.382] run() for ‘MultisessionFuture’ ... done
[13:36:42.382] result() for ClusterFuture ...
[13:36:42.382] receiveMessageFromWorker() for ClusterFuture ...
[13:36:42.382] - Validating connection of MultisessionFuture
[13:36:42.384] - received message: FutureResult
[13:36:42.384] - Received FutureResult
[13:36:42.385] - Erased future from FutureRegistry
[13:36:42.385] result() for ClusterFuture ...
[13:36:42.385] - result already collected: FutureResult
[13:36:42.385] result() for ClusterFuture ... done
[13:36:42.385] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:42.385] result() for ClusterFuture ... done
[13:36:42.385] result() for ClusterFuture ...
[13:36:42.385] - result already collected: FutureResult
[13:36:42.385] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:36:42.387] getGlobalsAndPackages() ...
[13:36:42.387] Searching for globals...
[13:36:42.388] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:36:42.389] Searching for globals ... DONE
[13:36:42.389] Resolving globals: FALSE
[13:36:42.389] The total size of the 2 globals is 896 bytes (896 bytes)
[13:36:42.389] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:36:42.390] - globals: [2] ‘weight’, ‘group’
[13:36:42.390] - packages: [1] ‘stats’
[13:36:42.390] getGlobalsAndPackages() ... DONE
[13:36:42.390] run() for ‘Future’ ...
[13:36:42.390] - state: ‘created’
[13:36:42.390] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:42.404] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:42.404] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:42.404]   - Field: ‘node’
[13:36:42.404]   - Field: ‘label’
[13:36:42.404]   - Field: ‘local’
[13:36:42.404]   - Field: ‘owner’
[13:36:42.404]   - Field: ‘envir’
[13:36:42.405]   - Field: ‘workers’
[13:36:42.405]   - Field: ‘packages’
[13:36:42.405]   - Field: ‘gc’
[13:36:42.405]   - Field: ‘conditions’
[13:36:42.405]   - Field: ‘persistent’
[13:36:42.405]   - Field: ‘expr’
[13:36:42.405]   - Field: ‘uuid’
[13:36:42.405]   - Field: ‘seed’
[13:36:42.405]   - Field: ‘version’
[13:36:42.405]   - Field: ‘result’
[13:36:42.405]   - Field: ‘asynchronous’
[13:36:42.406]   - Field: ‘calls’
[13:36:42.406]   - Field: ‘globals’
[13:36:42.406]   - Field: ‘stdout’
[13:36:42.406]   - Field: ‘earlySignal’
[13:36:42.406]   - Field: ‘lazy’
[13:36:42.406]   - Field: ‘state’
[13:36:42.406] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:42.406] - Launch lazy future ...
[13:36:42.406] Packages needed by the future expression (n = 1): ‘stats’
[13:36:42.407] Packages needed by future strategies (n = 0): <none>
[13:36:42.407] {
[13:36:42.407]     {
[13:36:42.407]         {
[13:36:42.407]             ...future.startTime <- base::Sys.time()
[13:36:42.407]             {
[13:36:42.407]                 {
[13:36:42.407]                   {
[13:36:42.407]                     {
[13:36:42.407]                       {
[13:36:42.407]                         base::local({
[13:36:42.407]                           has_future <- base::requireNamespace("future", 
[13:36:42.407]                             quietly = TRUE)
[13:36:42.407]                           if (has_future) {
[13:36:42.407]                             ns <- base::getNamespace("future")
[13:36:42.407]                             version <- ns[[".package"]][["version"]]
[13:36:42.407]                             if (is.null(version)) 
[13:36:42.407]                               version <- utils::packageVersion("future")
[13:36:42.407]                           }
[13:36:42.407]                           else {
[13:36:42.407]                             version <- NULL
[13:36:42.407]                           }
[13:36:42.407]                           if (!has_future || version < "1.8.0") {
[13:36:42.407]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:42.407]                               "", base::R.version$version.string), 
[13:36:42.407]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:42.407]                                 base::R.version$platform, 8 * 
[13:36:42.407]                                   base::.Machine$sizeof.pointer), 
[13:36:42.407]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:42.407]                                 "release", "version")], collapse = " "), 
[13:36:42.407]                               hostname = base::Sys.info()[["nodename"]])
[13:36:42.407]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:42.407]                               info)
[13:36:42.407]                             info <- base::paste(info, collapse = "; ")
[13:36:42.407]                             if (!has_future) {
[13:36:42.407]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:42.407]                                 info)
[13:36:42.407]                             }
[13:36:42.407]                             else {
[13:36:42.407]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:42.407]                                 info, version)
[13:36:42.407]                             }
[13:36:42.407]                             base::stop(msg)
[13:36:42.407]                           }
[13:36:42.407]                         })
[13:36:42.407]                       }
[13:36:42.407]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:42.407]                       base::options(mc.cores = 1L)
[13:36:42.407]                     }
[13:36:42.407]                     base::local({
[13:36:42.407]                       for (pkg in "stats") {
[13:36:42.407]                         base::loadNamespace(pkg)
[13:36:42.407]                         base::library(pkg, character.only = TRUE)
[13:36:42.407]                       }
[13:36:42.407]                     })
[13:36:42.407]                   }
[13:36:42.407]                   ...future.strategy.old <- future::plan("list")
[13:36:42.407]                   options(future.plan = NULL)
[13:36:42.407]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.407]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:42.407]                 }
[13:36:42.407]                 ...future.workdir <- getwd()
[13:36:42.407]             }
[13:36:42.407]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:42.407]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:42.407]         }
[13:36:42.407]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:42.407]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:42.407]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:42.407]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:42.407]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:42.407]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:42.407]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:42.407]             base::names(...future.oldOptions))
[13:36:42.407]     }
[13:36:42.407]     if (FALSE) {
[13:36:42.407]     }
[13:36:42.407]     else {
[13:36:42.407]         if (TRUE) {
[13:36:42.407]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:42.407]                 open = "w")
[13:36:42.407]         }
[13:36:42.407]         else {
[13:36:42.407]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:42.407]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:42.407]         }
[13:36:42.407]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:42.407]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:42.407]             base::sink(type = "output", split = FALSE)
[13:36:42.407]             base::close(...future.stdout)
[13:36:42.407]         }, add = TRUE)
[13:36:42.407]     }
[13:36:42.407]     ...future.frame <- base::sys.nframe()
[13:36:42.407]     ...future.conditions <- base::list()
[13:36:42.407]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:42.407]     if (FALSE) {
[13:36:42.407]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:42.407]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:42.407]     }
[13:36:42.407]     ...future.result <- base::tryCatch({
[13:36:42.407]         base::withCallingHandlers({
[13:36:42.407]             ...future.value <- base::withVisible(base::local({
[13:36:42.407]                 ...future.makeSendCondition <- base::local({
[13:36:42.407]                   sendCondition <- NULL
[13:36:42.407]                   function(frame = 1L) {
[13:36:42.407]                     if (is.function(sendCondition)) 
[13:36:42.407]                       return(sendCondition)
[13:36:42.407]                     ns <- getNamespace("parallel")
[13:36:42.407]                     if (exists("sendData", mode = "function", 
[13:36:42.407]                       envir = ns)) {
[13:36:42.407]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:42.407]                         envir = ns)
[13:36:42.407]                       envir <- sys.frame(frame)
[13:36:42.407]                       master <- NULL
[13:36:42.407]                       while (!identical(envir, .GlobalEnv) && 
[13:36:42.407]                         !identical(envir, emptyenv())) {
[13:36:42.407]                         if (exists("master", mode = "list", envir = envir, 
[13:36:42.407]                           inherits = FALSE)) {
[13:36:42.407]                           master <- get("master", mode = "list", 
[13:36:42.407]                             envir = envir, inherits = FALSE)
[13:36:42.407]                           if (inherits(master, c("SOCKnode", 
[13:36:42.407]                             "SOCK0node"))) {
[13:36:42.407]                             sendCondition <<- function(cond) {
[13:36:42.407]                               data <- list(type = "VALUE", value = cond, 
[13:36:42.407]                                 success = TRUE)
[13:36:42.407]                               parallel_sendData(master, data)
[13:36:42.407]                             }
[13:36:42.407]                             return(sendCondition)
[13:36:42.407]                           }
[13:36:42.407]                         }
[13:36:42.407]                         frame <- frame + 1L
[13:36:42.407]                         envir <- sys.frame(frame)
[13:36:42.407]                       }
[13:36:42.407]                     }
[13:36:42.407]                     sendCondition <<- function(cond) NULL
[13:36:42.407]                   }
[13:36:42.407]                 })
[13:36:42.407]                 withCallingHandlers({
[13:36:42.407]                   {
[13:36:42.407]                     lm(weight ~ group - 1)
[13:36:42.407]                   }
[13:36:42.407]                 }, immediateCondition = function(cond) {
[13:36:42.407]                   sendCondition <- ...future.makeSendCondition()
[13:36:42.407]                   sendCondition(cond)
[13:36:42.407]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.407]                   {
[13:36:42.407]                     inherits <- base::inherits
[13:36:42.407]                     invokeRestart <- base::invokeRestart
[13:36:42.407]                     is.null <- base::is.null
[13:36:42.407]                     muffled <- FALSE
[13:36:42.407]                     if (inherits(cond, "message")) {
[13:36:42.407]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:42.407]                       if (muffled) 
[13:36:42.407]                         invokeRestart("muffleMessage")
[13:36:42.407]                     }
[13:36:42.407]                     else if (inherits(cond, "warning")) {
[13:36:42.407]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:42.407]                       if (muffled) 
[13:36:42.407]                         invokeRestart("muffleWarning")
[13:36:42.407]                     }
[13:36:42.407]                     else if (inherits(cond, "condition")) {
[13:36:42.407]                       if (!is.null(pattern)) {
[13:36:42.407]                         computeRestarts <- base::computeRestarts
[13:36:42.407]                         grepl <- base::grepl
[13:36:42.407]                         restarts <- computeRestarts(cond)
[13:36:42.407]                         for (restart in restarts) {
[13:36:42.407]                           name <- restart$name
[13:36:42.407]                           if (is.null(name)) 
[13:36:42.407]                             next
[13:36:42.407]                           if (!grepl(pattern, name)) 
[13:36:42.407]                             next
[13:36:42.407]                           invokeRestart(restart)
[13:36:42.407]                           muffled <- TRUE
[13:36:42.407]                           break
[13:36:42.407]                         }
[13:36:42.407]                       }
[13:36:42.407]                     }
[13:36:42.407]                     invisible(muffled)
[13:36:42.407]                   }
[13:36:42.407]                   muffleCondition(cond)
[13:36:42.407]                 })
[13:36:42.407]             }))
[13:36:42.407]             future::FutureResult(value = ...future.value$value, 
[13:36:42.407]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.407]                   ...future.rng), globalenv = if (FALSE) 
[13:36:42.407]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:42.407]                     ...future.globalenv.names))
[13:36:42.407]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:42.407]         }, condition = base::local({
[13:36:42.407]             c <- base::c
[13:36:42.407]             inherits <- base::inherits
[13:36:42.407]             invokeRestart <- base::invokeRestart
[13:36:42.407]             length <- base::length
[13:36:42.407]             list <- base::list
[13:36:42.407]             seq.int <- base::seq.int
[13:36:42.407]             signalCondition <- base::signalCondition
[13:36:42.407]             sys.calls <- base::sys.calls
[13:36:42.407]             `[[` <- base::`[[`
[13:36:42.407]             `+` <- base::`+`
[13:36:42.407]             `<<-` <- base::`<<-`
[13:36:42.407]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:42.407]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:42.407]                   3L)]
[13:36:42.407]             }
[13:36:42.407]             function(cond) {
[13:36:42.407]                 is_error <- inherits(cond, "error")
[13:36:42.407]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:42.407]                   NULL)
[13:36:42.407]                 if (is_error) {
[13:36:42.407]                   sessionInformation <- function() {
[13:36:42.407]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:42.407]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:42.407]                       search = base::search(), system = base::Sys.info())
[13:36:42.407]                   }
[13:36:42.407]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.407]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:42.407]                     cond$call), session = sessionInformation(), 
[13:36:42.407]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:42.407]                   signalCondition(cond)
[13:36:42.407]                 }
[13:36:42.407]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:42.407]                 "immediateCondition"))) {
[13:36:42.407]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:42.407]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.407]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:42.407]                   if (TRUE && !signal) {
[13:36:42.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.407]                     {
[13:36:42.407]                       inherits <- base::inherits
[13:36:42.407]                       invokeRestart <- base::invokeRestart
[13:36:42.407]                       is.null <- base::is.null
[13:36:42.407]                       muffled <- FALSE
[13:36:42.407]                       if (inherits(cond, "message")) {
[13:36:42.407]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.407]                         if (muffled) 
[13:36:42.407]                           invokeRestart("muffleMessage")
[13:36:42.407]                       }
[13:36:42.407]                       else if (inherits(cond, "warning")) {
[13:36:42.407]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.407]                         if (muffled) 
[13:36:42.407]                           invokeRestart("muffleWarning")
[13:36:42.407]                       }
[13:36:42.407]                       else if (inherits(cond, "condition")) {
[13:36:42.407]                         if (!is.null(pattern)) {
[13:36:42.407]                           computeRestarts <- base::computeRestarts
[13:36:42.407]                           grepl <- base::grepl
[13:36:42.407]                           restarts <- computeRestarts(cond)
[13:36:42.407]                           for (restart in restarts) {
[13:36:42.407]                             name <- restart$name
[13:36:42.407]                             if (is.null(name)) 
[13:36:42.407]                               next
[13:36:42.407]                             if (!grepl(pattern, name)) 
[13:36:42.407]                               next
[13:36:42.407]                             invokeRestart(restart)
[13:36:42.407]                             muffled <- TRUE
[13:36:42.407]                             break
[13:36:42.407]                           }
[13:36:42.407]                         }
[13:36:42.407]                       }
[13:36:42.407]                       invisible(muffled)
[13:36:42.407]                     }
[13:36:42.407]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.407]                   }
[13:36:42.407]                 }
[13:36:42.407]                 else {
[13:36:42.407]                   if (TRUE) {
[13:36:42.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.407]                     {
[13:36:42.407]                       inherits <- base::inherits
[13:36:42.407]                       invokeRestart <- base::invokeRestart
[13:36:42.407]                       is.null <- base::is.null
[13:36:42.407]                       muffled <- FALSE
[13:36:42.407]                       if (inherits(cond, "message")) {
[13:36:42.407]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.407]                         if (muffled) 
[13:36:42.407]                           invokeRestart("muffleMessage")
[13:36:42.407]                       }
[13:36:42.407]                       else if (inherits(cond, "warning")) {
[13:36:42.407]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.407]                         if (muffled) 
[13:36:42.407]                           invokeRestart("muffleWarning")
[13:36:42.407]                       }
[13:36:42.407]                       else if (inherits(cond, "condition")) {
[13:36:42.407]                         if (!is.null(pattern)) {
[13:36:42.407]                           computeRestarts <- base::computeRestarts
[13:36:42.407]                           grepl <- base::grepl
[13:36:42.407]                           restarts <- computeRestarts(cond)
[13:36:42.407]                           for (restart in restarts) {
[13:36:42.407]                             name <- restart$name
[13:36:42.407]                             if (is.null(name)) 
[13:36:42.407]                               next
[13:36:42.407]                             if (!grepl(pattern, name)) 
[13:36:42.407]                               next
[13:36:42.407]                             invokeRestart(restart)
[13:36:42.407]                             muffled <- TRUE
[13:36:42.407]                             break
[13:36:42.407]                           }
[13:36:42.407]                         }
[13:36:42.407]                       }
[13:36:42.407]                       invisible(muffled)
[13:36:42.407]                     }
[13:36:42.407]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.407]                   }
[13:36:42.407]                 }
[13:36:42.407]             }
[13:36:42.407]         }))
[13:36:42.407]     }, error = function(ex) {
[13:36:42.407]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:42.407]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.407]                 ...future.rng), started = ...future.startTime, 
[13:36:42.407]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:42.407]             version = "1.8"), class = "FutureResult")
[13:36:42.407]     }, finally = {
[13:36:42.407]         if (!identical(...future.workdir, getwd())) 
[13:36:42.407]             setwd(...future.workdir)
[13:36:42.407]         {
[13:36:42.407]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:42.407]                 ...future.oldOptions$nwarnings <- NULL
[13:36:42.407]             }
[13:36:42.407]             base::options(...future.oldOptions)
[13:36:42.407]             if (.Platform$OS.type == "windows") {
[13:36:42.407]                 old_names <- names(...future.oldEnvVars)
[13:36:42.407]                 envs <- base::Sys.getenv()
[13:36:42.407]                 names <- names(envs)
[13:36:42.407]                 common <- intersect(names, old_names)
[13:36:42.407]                 added <- setdiff(names, old_names)
[13:36:42.407]                 removed <- setdiff(old_names, names)
[13:36:42.407]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:42.407]                   envs[common]]
[13:36:42.407]                 NAMES <- toupper(changed)
[13:36:42.407]                 args <- list()
[13:36:42.407]                 for (kk in seq_along(NAMES)) {
[13:36:42.407]                   name <- changed[[kk]]
[13:36:42.407]                   NAME <- NAMES[[kk]]
[13:36:42.407]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.407]                     next
[13:36:42.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.407]                 }
[13:36:42.407]                 NAMES <- toupper(added)
[13:36:42.407]                 for (kk in seq_along(NAMES)) {
[13:36:42.407]                   name <- added[[kk]]
[13:36:42.407]                   NAME <- NAMES[[kk]]
[13:36:42.407]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.407]                     next
[13:36:42.407]                   args[[name]] <- ""
[13:36:42.407]                 }
[13:36:42.407]                 NAMES <- toupper(removed)
[13:36:42.407]                 for (kk in seq_along(NAMES)) {
[13:36:42.407]                   name <- removed[[kk]]
[13:36:42.407]                   NAME <- NAMES[[kk]]
[13:36:42.407]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.407]                     next
[13:36:42.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.407]                 }
[13:36:42.407]                 if (length(args) > 0) 
[13:36:42.407]                   base::do.call(base::Sys.setenv, args = args)
[13:36:42.407]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:42.407]             }
[13:36:42.407]             else {
[13:36:42.407]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:42.407]             }
[13:36:42.407]             {
[13:36:42.407]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:42.407]                   0L) {
[13:36:42.407]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:42.407]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:42.407]                   base::options(opts)
[13:36:42.407]                 }
[13:36:42.407]                 {
[13:36:42.407]                   {
[13:36:42.407]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:42.407]                     NULL
[13:36:42.407]                   }
[13:36:42.407]                   options(future.plan = NULL)
[13:36:42.407]                   if (is.na(NA_character_)) 
[13:36:42.407]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.407]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:42.407]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:42.407]                     .init = FALSE)
[13:36:42.407]                 }
[13:36:42.407]             }
[13:36:42.407]         }
[13:36:42.407]     })
[13:36:42.407]     if (TRUE) {
[13:36:42.407]         base::sink(type = "output", split = FALSE)
[13:36:42.407]         if (TRUE) {
[13:36:42.407]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:42.407]         }
[13:36:42.407]         else {
[13:36:42.407]             ...future.result["stdout"] <- base::list(NULL)
[13:36:42.407]         }
[13:36:42.407]         base::close(...future.stdout)
[13:36:42.407]         ...future.stdout <- NULL
[13:36:42.407]     }
[13:36:42.407]     ...future.result$conditions <- ...future.conditions
[13:36:42.407]     ...future.result$finished <- base::Sys.time()
[13:36:42.407]     ...future.result
[13:36:42.407] }
[13:36:42.410] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[13:36:42.410] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[13:36:42.410] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[13:36:42.410] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[13:36:42.411] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[13:36:42.411] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[13:36:42.411] MultisessionFuture started
[13:36:42.411] - Launch lazy future ... done
[13:36:42.411] run() for ‘MultisessionFuture’ ... done
[13:36:42.412] result() for ClusterFuture ...
[13:36:42.412] receiveMessageFromWorker() for ClusterFuture ...
[13:36:42.412] - Validating connection of MultisessionFuture
[13:36:42.414] - received message: FutureResult
[13:36:42.414] - Received FutureResult
[13:36:42.414] - Erased future from FutureRegistry
[13:36:42.414] result() for ClusterFuture ...
[13:36:42.414] - result already collected: FutureResult
[13:36:42.414] result() for ClusterFuture ... done
[13:36:42.414] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:42.414] result() for ClusterFuture ... done
[13:36:42.415] result() for ClusterFuture ...
[13:36:42.415] - result already collected: FutureResult
[13:36:42.415] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:36:42.416] getGlobalsAndPackages() ...
[13:36:42.417] Searching for globals...
[13:36:42.418] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:36:42.418] Searching for globals ... DONE
[13:36:42.418] Resolving globals: FALSE
[13:36:42.419] The total size of the 2 globals is 896 bytes (896 bytes)
[13:36:42.419] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:36:42.419] - globals: [2] ‘weight’, ‘group’
[13:36:42.419] - packages: [1] ‘stats’
[13:36:42.419] getGlobalsAndPackages() ... DONE
[13:36:42.420] run() for ‘Future’ ...
[13:36:42.420] - state: ‘created’
[13:36:42.420] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:42.436] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:42.436] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:42.436]   - Field: ‘node’
[13:36:42.436]   - Field: ‘label’
[13:36:42.436]   - Field: ‘local’
[13:36:42.436]   - Field: ‘owner’
[13:36:42.436]   - Field: ‘envir’
[13:36:42.436]   - Field: ‘workers’
[13:36:42.437]   - Field: ‘packages’
[13:36:42.437]   - Field: ‘gc’
[13:36:42.437]   - Field: ‘conditions’
[13:36:42.437]   - Field: ‘persistent’
[13:36:42.437]   - Field: ‘expr’
[13:36:42.437]   - Field: ‘uuid’
[13:36:42.437]   - Field: ‘seed’
[13:36:42.437]   - Field: ‘version’
[13:36:42.437]   - Field: ‘result’
[13:36:42.437]   - Field: ‘asynchronous’
[13:36:42.438]   - Field: ‘calls’
[13:36:42.438]   - Field: ‘globals’
[13:36:42.438]   - Field: ‘stdout’
[13:36:42.438]   - Field: ‘earlySignal’
[13:36:42.438]   - Field: ‘lazy’
[13:36:42.438]   - Field: ‘state’
[13:36:42.438] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:42.438] - Launch lazy future ...
[13:36:42.438] Packages needed by the future expression (n = 1): ‘stats’
[13:36:42.439] Packages needed by future strategies (n = 0): <none>
[13:36:42.439] {
[13:36:42.439]     {
[13:36:42.439]         {
[13:36:42.439]             ...future.startTime <- base::Sys.time()
[13:36:42.439]             {
[13:36:42.439]                 {
[13:36:42.439]                   {
[13:36:42.439]                     {
[13:36:42.439]                       {
[13:36:42.439]                         base::local({
[13:36:42.439]                           has_future <- base::requireNamespace("future", 
[13:36:42.439]                             quietly = TRUE)
[13:36:42.439]                           if (has_future) {
[13:36:42.439]                             ns <- base::getNamespace("future")
[13:36:42.439]                             version <- ns[[".package"]][["version"]]
[13:36:42.439]                             if (is.null(version)) 
[13:36:42.439]                               version <- utils::packageVersion("future")
[13:36:42.439]                           }
[13:36:42.439]                           else {
[13:36:42.439]                             version <- NULL
[13:36:42.439]                           }
[13:36:42.439]                           if (!has_future || version < "1.8.0") {
[13:36:42.439]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:42.439]                               "", base::R.version$version.string), 
[13:36:42.439]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:42.439]                                 base::R.version$platform, 8 * 
[13:36:42.439]                                   base::.Machine$sizeof.pointer), 
[13:36:42.439]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:42.439]                                 "release", "version")], collapse = " "), 
[13:36:42.439]                               hostname = base::Sys.info()[["nodename"]])
[13:36:42.439]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:42.439]                               info)
[13:36:42.439]                             info <- base::paste(info, collapse = "; ")
[13:36:42.439]                             if (!has_future) {
[13:36:42.439]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:42.439]                                 info)
[13:36:42.439]                             }
[13:36:42.439]                             else {
[13:36:42.439]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:42.439]                                 info, version)
[13:36:42.439]                             }
[13:36:42.439]                             base::stop(msg)
[13:36:42.439]                           }
[13:36:42.439]                         })
[13:36:42.439]                       }
[13:36:42.439]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:42.439]                       base::options(mc.cores = 1L)
[13:36:42.439]                     }
[13:36:42.439]                     base::local({
[13:36:42.439]                       for (pkg in "stats") {
[13:36:42.439]                         base::loadNamespace(pkg)
[13:36:42.439]                         base::library(pkg, character.only = TRUE)
[13:36:42.439]                       }
[13:36:42.439]                     })
[13:36:42.439]                   }
[13:36:42.439]                   ...future.strategy.old <- future::plan("list")
[13:36:42.439]                   options(future.plan = NULL)
[13:36:42.439]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.439]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:42.439]                 }
[13:36:42.439]                 ...future.workdir <- getwd()
[13:36:42.439]             }
[13:36:42.439]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:42.439]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:42.439]         }
[13:36:42.439]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:42.439]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:42.439]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:42.439]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:42.439]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:42.439]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:42.439]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:42.439]             base::names(...future.oldOptions))
[13:36:42.439]     }
[13:36:42.439]     if (FALSE) {
[13:36:42.439]     }
[13:36:42.439]     else {
[13:36:42.439]         if (TRUE) {
[13:36:42.439]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:42.439]                 open = "w")
[13:36:42.439]         }
[13:36:42.439]         else {
[13:36:42.439]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:42.439]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:42.439]         }
[13:36:42.439]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:42.439]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:42.439]             base::sink(type = "output", split = FALSE)
[13:36:42.439]             base::close(...future.stdout)
[13:36:42.439]         }, add = TRUE)
[13:36:42.439]     }
[13:36:42.439]     ...future.frame <- base::sys.nframe()
[13:36:42.439]     ...future.conditions <- base::list()
[13:36:42.439]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:42.439]     if (FALSE) {
[13:36:42.439]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:42.439]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:42.439]     }
[13:36:42.439]     ...future.result <- base::tryCatch({
[13:36:42.439]         base::withCallingHandlers({
[13:36:42.439]             ...future.value <- base::withVisible(base::local({
[13:36:42.439]                 ...future.makeSendCondition <- base::local({
[13:36:42.439]                   sendCondition <- NULL
[13:36:42.439]                   function(frame = 1L) {
[13:36:42.439]                     if (is.function(sendCondition)) 
[13:36:42.439]                       return(sendCondition)
[13:36:42.439]                     ns <- getNamespace("parallel")
[13:36:42.439]                     if (exists("sendData", mode = "function", 
[13:36:42.439]                       envir = ns)) {
[13:36:42.439]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:42.439]                         envir = ns)
[13:36:42.439]                       envir <- sys.frame(frame)
[13:36:42.439]                       master <- NULL
[13:36:42.439]                       while (!identical(envir, .GlobalEnv) && 
[13:36:42.439]                         !identical(envir, emptyenv())) {
[13:36:42.439]                         if (exists("master", mode = "list", envir = envir, 
[13:36:42.439]                           inherits = FALSE)) {
[13:36:42.439]                           master <- get("master", mode = "list", 
[13:36:42.439]                             envir = envir, inherits = FALSE)
[13:36:42.439]                           if (inherits(master, c("SOCKnode", 
[13:36:42.439]                             "SOCK0node"))) {
[13:36:42.439]                             sendCondition <<- function(cond) {
[13:36:42.439]                               data <- list(type = "VALUE", value = cond, 
[13:36:42.439]                                 success = TRUE)
[13:36:42.439]                               parallel_sendData(master, data)
[13:36:42.439]                             }
[13:36:42.439]                             return(sendCondition)
[13:36:42.439]                           }
[13:36:42.439]                         }
[13:36:42.439]                         frame <- frame + 1L
[13:36:42.439]                         envir <- sys.frame(frame)
[13:36:42.439]                       }
[13:36:42.439]                     }
[13:36:42.439]                     sendCondition <<- function(cond) NULL
[13:36:42.439]                   }
[13:36:42.439]                 })
[13:36:42.439]                 withCallingHandlers({
[13:36:42.439]                   {
[13:36:42.439]                     lm(weight ~ group - 1)
[13:36:42.439]                   }
[13:36:42.439]                 }, immediateCondition = function(cond) {
[13:36:42.439]                   sendCondition <- ...future.makeSendCondition()
[13:36:42.439]                   sendCondition(cond)
[13:36:42.439]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.439]                   {
[13:36:42.439]                     inherits <- base::inherits
[13:36:42.439]                     invokeRestart <- base::invokeRestart
[13:36:42.439]                     is.null <- base::is.null
[13:36:42.439]                     muffled <- FALSE
[13:36:42.439]                     if (inherits(cond, "message")) {
[13:36:42.439]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:42.439]                       if (muffled) 
[13:36:42.439]                         invokeRestart("muffleMessage")
[13:36:42.439]                     }
[13:36:42.439]                     else if (inherits(cond, "warning")) {
[13:36:42.439]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:42.439]                       if (muffled) 
[13:36:42.439]                         invokeRestart("muffleWarning")
[13:36:42.439]                     }
[13:36:42.439]                     else if (inherits(cond, "condition")) {
[13:36:42.439]                       if (!is.null(pattern)) {
[13:36:42.439]                         computeRestarts <- base::computeRestarts
[13:36:42.439]                         grepl <- base::grepl
[13:36:42.439]                         restarts <- computeRestarts(cond)
[13:36:42.439]                         for (restart in restarts) {
[13:36:42.439]                           name <- restart$name
[13:36:42.439]                           if (is.null(name)) 
[13:36:42.439]                             next
[13:36:42.439]                           if (!grepl(pattern, name)) 
[13:36:42.439]                             next
[13:36:42.439]                           invokeRestart(restart)
[13:36:42.439]                           muffled <- TRUE
[13:36:42.439]                           break
[13:36:42.439]                         }
[13:36:42.439]                       }
[13:36:42.439]                     }
[13:36:42.439]                     invisible(muffled)
[13:36:42.439]                   }
[13:36:42.439]                   muffleCondition(cond)
[13:36:42.439]                 })
[13:36:42.439]             }))
[13:36:42.439]             future::FutureResult(value = ...future.value$value, 
[13:36:42.439]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.439]                   ...future.rng), globalenv = if (FALSE) 
[13:36:42.439]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:42.439]                     ...future.globalenv.names))
[13:36:42.439]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:42.439]         }, condition = base::local({
[13:36:42.439]             c <- base::c
[13:36:42.439]             inherits <- base::inherits
[13:36:42.439]             invokeRestart <- base::invokeRestart
[13:36:42.439]             length <- base::length
[13:36:42.439]             list <- base::list
[13:36:42.439]             seq.int <- base::seq.int
[13:36:42.439]             signalCondition <- base::signalCondition
[13:36:42.439]             sys.calls <- base::sys.calls
[13:36:42.439]             `[[` <- base::`[[`
[13:36:42.439]             `+` <- base::`+`
[13:36:42.439]             `<<-` <- base::`<<-`
[13:36:42.439]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:42.439]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:42.439]                   3L)]
[13:36:42.439]             }
[13:36:42.439]             function(cond) {
[13:36:42.439]                 is_error <- inherits(cond, "error")
[13:36:42.439]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:42.439]                   NULL)
[13:36:42.439]                 if (is_error) {
[13:36:42.439]                   sessionInformation <- function() {
[13:36:42.439]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:42.439]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:42.439]                       search = base::search(), system = base::Sys.info())
[13:36:42.439]                   }
[13:36:42.439]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.439]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:42.439]                     cond$call), session = sessionInformation(), 
[13:36:42.439]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:42.439]                   signalCondition(cond)
[13:36:42.439]                 }
[13:36:42.439]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:42.439]                 "immediateCondition"))) {
[13:36:42.439]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:42.439]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.439]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:42.439]                   if (TRUE && !signal) {
[13:36:42.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.439]                     {
[13:36:42.439]                       inherits <- base::inherits
[13:36:42.439]                       invokeRestart <- base::invokeRestart
[13:36:42.439]                       is.null <- base::is.null
[13:36:42.439]                       muffled <- FALSE
[13:36:42.439]                       if (inherits(cond, "message")) {
[13:36:42.439]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.439]                         if (muffled) 
[13:36:42.439]                           invokeRestart("muffleMessage")
[13:36:42.439]                       }
[13:36:42.439]                       else if (inherits(cond, "warning")) {
[13:36:42.439]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.439]                         if (muffled) 
[13:36:42.439]                           invokeRestart("muffleWarning")
[13:36:42.439]                       }
[13:36:42.439]                       else if (inherits(cond, "condition")) {
[13:36:42.439]                         if (!is.null(pattern)) {
[13:36:42.439]                           computeRestarts <- base::computeRestarts
[13:36:42.439]                           grepl <- base::grepl
[13:36:42.439]                           restarts <- computeRestarts(cond)
[13:36:42.439]                           for (restart in restarts) {
[13:36:42.439]                             name <- restart$name
[13:36:42.439]                             if (is.null(name)) 
[13:36:42.439]                               next
[13:36:42.439]                             if (!grepl(pattern, name)) 
[13:36:42.439]                               next
[13:36:42.439]                             invokeRestart(restart)
[13:36:42.439]                             muffled <- TRUE
[13:36:42.439]                             break
[13:36:42.439]                           }
[13:36:42.439]                         }
[13:36:42.439]                       }
[13:36:42.439]                       invisible(muffled)
[13:36:42.439]                     }
[13:36:42.439]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.439]                   }
[13:36:42.439]                 }
[13:36:42.439]                 else {
[13:36:42.439]                   if (TRUE) {
[13:36:42.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.439]                     {
[13:36:42.439]                       inherits <- base::inherits
[13:36:42.439]                       invokeRestart <- base::invokeRestart
[13:36:42.439]                       is.null <- base::is.null
[13:36:42.439]                       muffled <- FALSE
[13:36:42.439]                       if (inherits(cond, "message")) {
[13:36:42.439]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.439]                         if (muffled) 
[13:36:42.439]                           invokeRestart("muffleMessage")
[13:36:42.439]                       }
[13:36:42.439]                       else if (inherits(cond, "warning")) {
[13:36:42.439]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.439]                         if (muffled) 
[13:36:42.439]                           invokeRestart("muffleWarning")
[13:36:42.439]                       }
[13:36:42.439]                       else if (inherits(cond, "condition")) {
[13:36:42.439]                         if (!is.null(pattern)) {
[13:36:42.439]                           computeRestarts <- base::computeRestarts
[13:36:42.439]                           grepl <- base::grepl
[13:36:42.439]                           restarts <- computeRestarts(cond)
[13:36:42.439]                           for (restart in restarts) {
[13:36:42.439]                             name <- restart$name
[13:36:42.439]                             if (is.null(name)) 
[13:36:42.439]                               next
[13:36:42.439]                             if (!grepl(pattern, name)) 
[13:36:42.439]                               next
[13:36:42.439]                             invokeRestart(restart)
[13:36:42.439]                             muffled <- TRUE
[13:36:42.439]                             break
[13:36:42.439]                           }
[13:36:42.439]                         }
[13:36:42.439]                       }
[13:36:42.439]                       invisible(muffled)
[13:36:42.439]                     }
[13:36:42.439]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.439]                   }
[13:36:42.439]                 }
[13:36:42.439]             }
[13:36:42.439]         }))
[13:36:42.439]     }, error = function(ex) {
[13:36:42.439]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:42.439]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.439]                 ...future.rng), started = ...future.startTime, 
[13:36:42.439]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:42.439]             version = "1.8"), class = "FutureResult")
[13:36:42.439]     }, finally = {
[13:36:42.439]         if (!identical(...future.workdir, getwd())) 
[13:36:42.439]             setwd(...future.workdir)
[13:36:42.439]         {
[13:36:42.439]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:42.439]                 ...future.oldOptions$nwarnings <- NULL
[13:36:42.439]             }
[13:36:42.439]             base::options(...future.oldOptions)
[13:36:42.439]             if (.Platform$OS.type == "windows") {
[13:36:42.439]                 old_names <- names(...future.oldEnvVars)
[13:36:42.439]                 envs <- base::Sys.getenv()
[13:36:42.439]                 names <- names(envs)
[13:36:42.439]                 common <- intersect(names, old_names)
[13:36:42.439]                 added <- setdiff(names, old_names)
[13:36:42.439]                 removed <- setdiff(old_names, names)
[13:36:42.439]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:42.439]                   envs[common]]
[13:36:42.439]                 NAMES <- toupper(changed)
[13:36:42.439]                 args <- list()
[13:36:42.439]                 for (kk in seq_along(NAMES)) {
[13:36:42.439]                   name <- changed[[kk]]
[13:36:42.439]                   NAME <- NAMES[[kk]]
[13:36:42.439]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.439]                     next
[13:36:42.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.439]                 }
[13:36:42.439]                 NAMES <- toupper(added)
[13:36:42.439]                 for (kk in seq_along(NAMES)) {
[13:36:42.439]                   name <- added[[kk]]
[13:36:42.439]                   NAME <- NAMES[[kk]]
[13:36:42.439]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.439]                     next
[13:36:42.439]                   args[[name]] <- ""
[13:36:42.439]                 }
[13:36:42.439]                 NAMES <- toupper(removed)
[13:36:42.439]                 for (kk in seq_along(NAMES)) {
[13:36:42.439]                   name <- removed[[kk]]
[13:36:42.439]                   NAME <- NAMES[[kk]]
[13:36:42.439]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.439]                     next
[13:36:42.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.439]                 }
[13:36:42.439]                 if (length(args) > 0) 
[13:36:42.439]                   base::do.call(base::Sys.setenv, args = args)
[13:36:42.439]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:42.439]             }
[13:36:42.439]             else {
[13:36:42.439]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:42.439]             }
[13:36:42.439]             {
[13:36:42.439]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:42.439]                   0L) {
[13:36:42.439]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:42.439]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:42.439]                   base::options(opts)
[13:36:42.439]                 }
[13:36:42.439]                 {
[13:36:42.439]                   {
[13:36:42.439]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:42.439]                     NULL
[13:36:42.439]                   }
[13:36:42.439]                   options(future.plan = NULL)
[13:36:42.439]                   if (is.na(NA_character_)) 
[13:36:42.439]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.439]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:42.439]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:42.439]                     .init = FALSE)
[13:36:42.439]                 }
[13:36:42.439]             }
[13:36:42.439]         }
[13:36:42.439]     })
[13:36:42.439]     if (TRUE) {
[13:36:42.439]         base::sink(type = "output", split = FALSE)
[13:36:42.439]         if (TRUE) {
[13:36:42.439]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:42.439]         }
[13:36:42.439]         else {
[13:36:42.439]             ...future.result["stdout"] <- base::list(NULL)
[13:36:42.439]         }
[13:36:42.439]         base::close(...future.stdout)
[13:36:42.439]         ...future.stdout <- NULL
[13:36:42.439]     }
[13:36:42.439]     ...future.result$conditions <- ...future.conditions
[13:36:42.439]     ...future.result$finished <- base::Sys.time()
[13:36:42.439]     ...future.result
[13:36:42.439] }
[13:36:42.441] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[13:36:42.442] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[13:36:42.442] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[13:36:42.442] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[13:36:42.443] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[13:36:42.443] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[13:36:42.443] MultisessionFuture started
[13:36:42.443] - Launch lazy future ... done
[13:36:42.443] run() for ‘MultisessionFuture’ ... done
[13:36:42.444] result() for ClusterFuture ...
[13:36:42.444] receiveMessageFromWorker() for ClusterFuture ...
[13:36:42.444] - Validating connection of MultisessionFuture
[13:36:42.489] - received message: FutureResult
[13:36:42.489] - Received FutureResult
[13:36:42.489] - Erased future from FutureRegistry
[13:36:42.489] result() for ClusterFuture ...
[13:36:42.489] - result already collected: FutureResult
[13:36:42.489] result() for ClusterFuture ... done
[13:36:42.489] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:42.489] result() for ClusterFuture ... done
[13:36:42.489] result() for ClusterFuture ...
[13:36:42.489] - result already collected: FutureResult
[13:36:42.490] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[13:36:42.491] getGlobalsAndPackages() ...
[13:36:42.491] Searching for globals...
[13:36:42.492] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[13:36:42.492] Searching for globals ... DONE
[13:36:42.493] Resolving globals: FALSE
[13:36:42.493] The total size of the 1 globals is 96 bytes (96 bytes)
[13:36:42.493] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[13:36:42.493] - globals: [1] ‘x’
[13:36:42.493] - packages: [1] ‘stats’
[13:36:42.494] getGlobalsAndPackages() ... DONE
[13:36:42.494] run() for ‘Future’ ...
[13:36:42.494] - state: ‘created’
[13:36:42.494] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:42.507] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:42.508] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:42.508]   - Field: ‘node’
[13:36:42.508]   - Field: ‘label’
[13:36:42.508]   - Field: ‘local’
[13:36:42.508]   - Field: ‘owner’
[13:36:42.508]   - Field: ‘envir’
[13:36:42.508]   - Field: ‘workers’
[13:36:42.508]   - Field: ‘packages’
[13:36:42.508]   - Field: ‘gc’
[13:36:42.508]   - Field: ‘conditions’
[13:36:42.509]   - Field: ‘persistent’
[13:36:42.509]   - Field: ‘expr’
[13:36:42.509]   - Field: ‘uuid’
[13:36:42.509]   - Field: ‘seed’
[13:36:42.509]   - Field: ‘version’
[13:36:42.509]   - Field: ‘result’
[13:36:42.509]   - Field: ‘asynchronous’
[13:36:42.509]   - Field: ‘calls’
[13:36:42.509]   - Field: ‘globals’
[13:36:42.509]   - Field: ‘stdout’
[13:36:42.509]   - Field: ‘earlySignal’
[13:36:42.510]   - Field: ‘lazy’
[13:36:42.510]   - Field: ‘state’
[13:36:42.510] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:42.510] - Launch lazy future ...
[13:36:42.510] Packages needed by the future expression (n = 1): ‘stats’
[13:36:42.510] Packages needed by future strategies (n = 0): <none>
[13:36:42.511] {
[13:36:42.511]     {
[13:36:42.511]         {
[13:36:42.511]             ...future.startTime <- base::Sys.time()
[13:36:42.511]             {
[13:36:42.511]                 {
[13:36:42.511]                   {
[13:36:42.511]                     {
[13:36:42.511]                       {
[13:36:42.511]                         base::local({
[13:36:42.511]                           has_future <- base::requireNamespace("future", 
[13:36:42.511]                             quietly = TRUE)
[13:36:42.511]                           if (has_future) {
[13:36:42.511]                             ns <- base::getNamespace("future")
[13:36:42.511]                             version <- ns[[".package"]][["version"]]
[13:36:42.511]                             if (is.null(version)) 
[13:36:42.511]                               version <- utils::packageVersion("future")
[13:36:42.511]                           }
[13:36:42.511]                           else {
[13:36:42.511]                             version <- NULL
[13:36:42.511]                           }
[13:36:42.511]                           if (!has_future || version < "1.8.0") {
[13:36:42.511]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:42.511]                               "", base::R.version$version.string), 
[13:36:42.511]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:42.511]                                 base::R.version$platform, 8 * 
[13:36:42.511]                                   base::.Machine$sizeof.pointer), 
[13:36:42.511]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:42.511]                                 "release", "version")], collapse = " "), 
[13:36:42.511]                               hostname = base::Sys.info()[["nodename"]])
[13:36:42.511]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:42.511]                               info)
[13:36:42.511]                             info <- base::paste(info, collapse = "; ")
[13:36:42.511]                             if (!has_future) {
[13:36:42.511]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:42.511]                                 info)
[13:36:42.511]                             }
[13:36:42.511]                             else {
[13:36:42.511]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:42.511]                                 info, version)
[13:36:42.511]                             }
[13:36:42.511]                             base::stop(msg)
[13:36:42.511]                           }
[13:36:42.511]                         })
[13:36:42.511]                       }
[13:36:42.511]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:42.511]                       base::options(mc.cores = 1L)
[13:36:42.511]                     }
[13:36:42.511]                     base::local({
[13:36:42.511]                       for (pkg in "stats") {
[13:36:42.511]                         base::loadNamespace(pkg)
[13:36:42.511]                         base::library(pkg, character.only = TRUE)
[13:36:42.511]                       }
[13:36:42.511]                     })
[13:36:42.511]                   }
[13:36:42.511]                   ...future.strategy.old <- future::plan("list")
[13:36:42.511]                   options(future.plan = NULL)
[13:36:42.511]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.511]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:42.511]                 }
[13:36:42.511]                 ...future.workdir <- getwd()
[13:36:42.511]             }
[13:36:42.511]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:42.511]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:42.511]         }
[13:36:42.511]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:42.511]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:42.511]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:42.511]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:42.511]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:42.511]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:42.511]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:42.511]             base::names(...future.oldOptions))
[13:36:42.511]     }
[13:36:42.511]     if (FALSE) {
[13:36:42.511]     }
[13:36:42.511]     else {
[13:36:42.511]         if (TRUE) {
[13:36:42.511]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:42.511]                 open = "w")
[13:36:42.511]         }
[13:36:42.511]         else {
[13:36:42.511]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:42.511]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:42.511]         }
[13:36:42.511]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:42.511]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:42.511]             base::sink(type = "output", split = FALSE)
[13:36:42.511]             base::close(...future.stdout)
[13:36:42.511]         }, add = TRUE)
[13:36:42.511]     }
[13:36:42.511]     ...future.frame <- base::sys.nframe()
[13:36:42.511]     ...future.conditions <- base::list()
[13:36:42.511]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:42.511]     if (FALSE) {
[13:36:42.511]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:42.511]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:42.511]     }
[13:36:42.511]     ...future.result <- base::tryCatch({
[13:36:42.511]         base::withCallingHandlers({
[13:36:42.511]             ...future.value <- base::withVisible(base::local({
[13:36:42.511]                 ...future.makeSendCondition <- base::local({
[13:36:42.511]                   sendCondition <- NULL
[13:36:42.511]                   function(frame = 1L) {
[13:36:42.511]                     if (is.function(sendCondition)) 
[13:36:42.511]                       return(sendCondition)
[13:36:42.511]                     ns <- getNamespace("parallel")
[13:36:42.511]                     if (exists("sendData", mode = "function", 
[13:36:42.511]                       envir = ns)) {
[13:36:42.511]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:42.511]                         envir = ns)
[13:36:42.511]                       envir <- sys.frame(frame)
[13:36:42.511]                       master <- NULL
[13:36:42.511]                       while (!identical(envir, .GlobalEnv) && 
[13:36:42.511]                         !identical(envir, emptyenv())) {
[13:36:42.511]                         if (exists("master", mode = "list", envir = envir, 
[13:36:42.511]                           inherits = FALSE)) {
[13:36:42.511]                           master <- get("master", mode = "list", 
[13:36:42.511]                             envir = envir, inherits = FALSE)
[13:36:42.511]                           if (inherits(master, c("SOCKnode", 
[13:36:42.511]                             "SOCK0node"))) {
[13:36:42.511]                             sendCondition <<- function(cond) {
[13:36:42.511]                               data <- list(type = "VALUE", value = cond, 
[13:36:42.511]                                 success = TRUE)
[13:36:42.511]                               parallel_sendData(master, data)
[13:36:42.511]                             }
[13:36:42.511]                             return(sendCondition)
[13:36:42.511]                           }
[13:36:42.511]                         }
[13:36:42.511]                         frame <- frame + 1L
[13:36:42.511]                         envir <- sys.frame(frame)
[13:36:42.511]                       }
[13:36:42.511]                     }
[13:36:42.511]                     sendCondition <<- function(cond) NULL
[13:36:42.511]                   }
[13:36:42.511]                 })
[13:36:42.511]                 withCallingHandlers({
[13:36:42.511]                   {
[13:36:42.511]                     xtabs(~x)
[13:36:42.511]                   }
[13:36:42.511]                 }, immediateCondition = function(cond) {
[13:36:42.511]                   sendCondition <- ...future.makeSendCondition()
[13:36:42.511]                   sendCondition(cond)
[13:36:42.511]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.511]                   {
[13:36:42.511]                     inherits <- base::inherits
[13:36:42.511]                     invokeRestart <- base::invokeRestart
[13:36:42.511]                     is.null <- base::is.null
[13:36:42.511]                     muffled <- FALSE
[13:36:42.511]                     if (inherits(cond, "message")) {
[13:36:42.511]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:42.511]                       if (muffled) 
[13:36:42.511]                         invokeRestart("muffleMessage")
[13:36:42.511]                     }
[13:36:42.511]                     else if (inherits(cond, "warning")) {
[13:36:42.511]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:42.511]                       if (muffled) 
[13:36:42.511]                         invokeRestart("muffleWarning")
[13:36:42.511]                     }
[13:36:42.511]                     else if (inherits(cond, "condition")) {
[13:36:42.511]                       if (!is.null(pattern)) {
[13:36:42.511]                         computeRestarts <- base::computeRestarts
[13:36:42.511]                         grepl <- base::grepl
[13:36:42.511]                         restarts <- computeRestarts(cond)
[13:36:42.511]                         for (restart in restarts) {
[13:36:42.511]                           name <- restart$name
[13:36:42.511]                           if (is.null(name)) 
[13:36:42.511]                             next
[13:36:42.511]                           if (!grepl(pattern, name)) 
[13:36:42.511]                             next
[13:36:42.511]                           invokeRestart(restart)
[13:36:42.511]                           muffled <- TRUE
[13:36:42.511]                           break
[13:36:42.511]                         }
[13:36:42.511]                       }
[13:36:42.511]                     }
[13:36:42.511]                     invisible(muffled)
[13:36:42.511]                   }
[13:36:42.511]                   muffleCondition(cond)
[13:36:42.511]                 })
[13:36:42.511]             }))
[13:36:42.511]             future::FutureResult(value = ...future.value$value, 
[13:36:42.511]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.511]                   ...future.rng), globalenv = if (FALSE) 
[13:36:42.511]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:42.511]                     ...future.globalenv.names))
[13:36:42.511]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:42.511]         }, condition = base::local({
[13:36:42.511]             c <- base::c
[13:36:42.511]             inherits <- base::inherits
[13:36:42.511]             invokeRestart <- base::invokeRestart
[13:36:42.511]             length <- base::length
[13:36:42.511]             list <- base::list
[13:36:42.511]             seq.int <- base::seq.int
[13:36:42.511]             signalCondition <- base::signalCondition
[13:36:42.511]             sys.calls <- base::sys.calls
[13:36:42.511]             `[[` <- base::`[[`
[13:36:42.511]             `+` <- base::`+`
[13:36:42.511]             `<<-` <- base::`<<-`
[13:36:42.511]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:42.511]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:42.511]                   3L)]
[13:36:42.511]             }
[13:36:42.511]             function(cond) {
[13:36:42.511]                 is_error <- inherits(cond, "error")
[13:36:42.511]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:42.511]                   NULL)
[13:36:42.511]                 if (is_error) {
[13:36:42.511]                   sessionInformation <- function() {
[13:36:42.511]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:42.511]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:42.511]                       search = base::search(), system = base::Sys.info())
[13:36:42.511]                   }
[13:36:42.511]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.511]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:42.511]                     cond$call), session = sessionInformation(), 
[13:36:42.511]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:42.511]                   signalCondition(cond)
[13:36:42.511]                 }
[13:36:42.511]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:42.511]                 "immediateCondition"))) {
[13:36:42.511]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:42.511]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.511]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:42.511]                   if (TRUE && !signal) {
[13:36:42.511]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.511]                     {
[13:36:42.511]                       inherits <- base::inherits
[13:36:42.511]                       invokeRestart <- base::invokeRestart
[13:36:42.511]                       is.null <- base::is.null
[13:36:42.511]                       muffled <- FALSE
[13:36:42.511]                       if (inherits(cond, "message")) {
[13:36:42.511]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.511]                         if (muffled) 
[13:36:42.511]                           invokeRestart("muffleMessage")
[13:36:42.511]                       }
[13:36:42.511]                       else if (inherits(cond, "warning")) {
[13:36:42.511]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.511]                         if (muffled) 
[13:36:42.511]                           invokeRestart("muffleWarning")
[13:36:42.511]                       }
[13:36:42.511]                       else if (inherits(cond, "condition")) {
[13:36:42.511]                         if (!is.null(pattern)) {
[13:36:42.511]                           computeRestarts <- base::computeRestarts
[13:36:42.511]                           grepl <- base::grepl
[13:36:42.511]                           restarts <- computeRestarts(cond)
[13:36:42.511]                           for (restart in restarts) {
[13:36:42.511]                             name <- restart$name
[13:36:42.511]                             if (is.null(name)) 
[13:36:42.511]                               next
[13:36:42.511]                             if (!grepl(pattern, name)) 
[13:36:42.511]                               next
[13:36:42.511]                             invokeRestart(restart)
[13:36:42.511]                             muffled <- TRUE
[13:36:42.511]                             break
[13:36:42.511]                           }
[13:36:42.511]                         }
[13:36:42.511]                       }
[13:36:42.511]                       invisible(muffled)
[13:36:42.511]                     }
[13:36:42.511]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.511]                   }
[13:36:42.511]                 }
[13:36:42.511]                 else {
[13:36:42.511]                   if (TRUE) {
[13:36:42.511]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.511]                     {
[13:36:42.511]                       inherits <- base::inherits
[13:36:42.511]                       invokeRestart <- base::invokeRestart
[13:36:42.511]                       is.null <- base::is.null
[13:36:42.511]                       muffled <- FALSE
[13:36:42.511]                       if (inherits(cond, "message")) {
[13:36:42.511]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.511]                         if (muffled) 
[13:36:42.511]                           invokeRestart("muffleMessage")
[13:36:42.511]                       }
[13:36:42.511]                       else if (inherits(cond, "warning")) {
[13:36:42.511]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.511]                         if (muffled) 
[13:36:42.511]                           invokeRestart("muffleWarning")
[13:36:42.511]                       }
[13:36:42.511]                       else if (inherits(cond, "condition")) {
[13:36:42.511]                         if (!is.null(pattern)) {
[13:36:42.511]                           computeRestarts <- base::computeRestarts
[13:36:42.511]                           grepl <- base::grepl
[13:36:42.511]                           restarts <- computeRestarts(cond)
[13:36:42.511]                           for (restart in restarts) {
[13:36:42.511]                             name <- restart$name
[13:36:42.511]                             if (is.null(name)) 
[13:36:42.511]                               next
[13:36:42.511]                             if (!grepl(pattern, name)) 
[13:36:42.511]                               next
[13:36:42.511]                             invokeRestart(restart)
[13:36:42.511]                             muffled <- TRUE
[13:36:42.511]                             break
[13:36:42.511]                           }
[13:36:42.511]                         }
[13:36:42.511]                       }
[13:36:42.511]                       invisible(muffled)
[13:36:42.511]                     }
[13:36:42.511]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.511]                   }
[13:36:42.511]                 }
[13:36:42.511]             }
[13:36:42.511]         }))
[13:36:42.511]     }, error = function(ex) {
[13:36:42.511]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:42.511]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.511]                 ...future.rng), started = ...future.startTime, 
[13:36:42.511]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:42.511]             version = "1.8"), class = "FutureResult")
[13:36:42.511]     }, finally = {
[13:36:42.511]         if (!identical(...future.workdir, getwd())) 
[13:36:42.511]             setwd(...future.workdir)
[13:36:42.511]         {
[13:36:42.511]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:42.511]                 ...future.oldOptions$nwarnings <- NULL
[13:36:42.511]             }
[13:36:42.511]             base::options(...future.oldOptions)
[13:36:42.511]             if (.Platform$OS.type == "windows") {
[13:36:42.511]                 old_names <- names(...future.oldEnvVars)
[13:36:42.511]                 envs <- base::Sys.getenv()
[13:36:42.511]                 names <- names(envs)
[13:36:42.511]                 common <- intersect(names, old_names)
[13:36:42.511]                 added <- setdiff(names, old_names)
[13:36:42.511]                 removed <- setdiff(old_names, names)
[13:36:42.511]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:42.511]                   envs[common]]
[13:36:42.511]                 NAMES <- toupper(changed)
[13:36:42.511]                 args <- list()
[13:36:42.511]                 for (kk in seq_along(NAMES)) {
[13:36:42.511]                   name <- changed[[kk]]
[13:36:42.511]                   NAME <- NAMES[[kk]]
[13:36:42.511]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.511]                     next
[13:36:42.511]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.511]                 }
[13:36:42.511]                 NAMES <- toupper(added)
[13:36:42.511]                 for (kk in seq_along(NAMES)) {
[13:36:42.511]                   name <- added[[kk]]
[13:36:42.511]                   NAME <- NAMES[[kk]]
[13:36:42.511]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.511]                     next
[13:36:42.511]                   args[[name]] <- ""
[13:36:42.511]                 }
[13:36:42.511]                 NAMES <- toupper(removed)
[13:36:42.511]                 for (kk in seq_along(NAMES)) {
[13:36:42.511]                   name <- removed[[kk]]
[13:36:42.511]                   NAME <- NAMES[[kk]]
[13:36:42.511]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.511]                     next
[13:36:42.511]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.511]                 }
[13:36:42.511]                 if (length(args) > 0) 
[13:36:42.511]                   base::do.call(base::Sys.setenv, args = args)
[13:36:42.511]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:42.511]             }
[13:36:42.511]             else {
[13:36:42.511]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:42.511]             }
[13:36:42.511]             {
[13:36:42.511]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:42.511]                   0L) {
[13:36:42.511]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:42.511]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:42.511]                   base::options(opts)
[13:36:42.511]                 }
[13:36:42.511]                 {
[13:36:42.511]                   {
[13:36:42.511]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:42.511]                     NULL
[13:36:42.511]                   }
[13:36:42.511]                   options(future.plan = NULL)
[13:36:42.511]                   if (is.na(NA_character_)) 
[13:36:42.511]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.511]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:42.511]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:42.511]                     .init = FALSE)
[13:36:42.511]                 }
[13:36:42.511]             }
[13:36:42.511]         }
[13:36:42.511]     })
[13:36:42.511]     if (TRUE) {
[13:36:42.511]         base::sink(type = "output", split = FALSE)
[13:36:42.511]         if (TRUE) {
[13:36:42.511]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:42.511]         }
[13:36:42.511]         else {
[13:36:42.511]             ...future.result["stdout"] <- base::list(NULL)
[13:36:42.511]         }
[13:36:42.511]         base::close(...future.stdout)
[13:36:42.511]         ...future.stdout <- NULL
[13:36:42.511]     }
[13:36:42.511]     ...future.result$conditions <- ...future.conditions
[13:36:42.511]     ...future.result$finished <- base::Sys.time()
[13:36:42.511]     ...future.result
[13:36:42.511] }
[13:36:42.513] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[13:36:42.513] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[13:36:42.514] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[13:36:42.514] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[13:36:42.514] MultisessionFuture started
[13:36:42.514] - Launch lazy future ... done
[13:36:42.515] run() for ‘MultisessionFuture’ ... done
[13:36:42.515] result() for ClusterFuture ...
[13:36:42.515] receiveMessageFromWorker() for ClusterFuture ...
[13:36:42.515] - Validating connection of MultisessionFuture
[13:36:42.561] - received message: FutureResult
[13:36:42.561] - Received FutureResult
[13:36:42.561] - Erased future from FutureRegistry
[13:36:42.561] result() for ClusterFuture ...
[13:36:42.561] - result already collected: FutureResult
[13:36:42.561] result() for ClusterFuture ... done
[13:36:42.561] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:42.561] result() for ClusterFuture ... done
[13:36:42.562] result() for ClusterFuture ...
[13:36:42.562] - result already collected: FutureResult
[13:36:42.562] result() for ClusterFuture ... done
x
1 2 
2 3 
[13:36:42.562] getGlobalsAndPackages() ...
[13:36:42.563] Searching for globals...
[13:36:42.564] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[13:36:42.564] Searching for globals ... DONE
[13:36:42.564] Resolving globals: FALSE
[13:36:42.564] The total size of the 1 globals is 96 bytes (96 bytes)
[13:36:42.565] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[13:36:42.565] - globals: [1] ‘x’
[13:36:42.565] - packages: [1] ‘stats’
[13:36:42.565] getGlobalsAndPackages() ... DONE
[13:36:42.565] run() for ‘Future’ ...
[13:36:42.565] - state: ‘created’
[13:36:42.565] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:42.579] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:42.579] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:42.579]   - Field: ‘node’
[13:36:42.579]   - Field: ‘label’
[13:36:42.579]   - Field: ‘local’
[13:36:42.579]   - Field: ‘owner’
[13:36:42.579]   - Field: ‘envir’
[13:36:42.580]   - Field: ‘workers’
[13:36:42.580]   - Field: ‘packages’
[13:36:42.580]   - Field: ‘gc’
[13:36:42.580]   - Field: ‘conditions’
[13:36:42.580]   - Field: ‘persistent’
[13:36:42.580]   - Field: ‘expr’
[13:36:42.580]   - Field: ‘uuid’
[13:36:42.580]   - Field: ‘seed’
[13:36:42.580]   - Field: ‘version’
[13:36:42.580]   - Field: ‘result’
[13:36:42.580]   - Field: ‘asynchronous’
[13:36:42.581]   - Field: ‘calls’
[13:36:42.581]   - Field: ‘globals’
[13:36:42.581]   - Field: ‘stdout’
[13:36:42.581]   - Field: ‘earlySignal’
[13:36:42.581]   - Field: ‘lazy’
[13:36:42.581]   - Field: ‘state’
[13:36:42.581] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:42.581] - Launch lazy future ...
[13:36:42.581] Packages needed by the future expression (n = 1): ‘stats’
[13:36:42.582] Packages needed by future strategies (n = 0): <none>
[13:36:42.582] {
[13:36:42.582]     {
[13:36:42.582]         {
[13:36:42.582]             ...future.startTime <- base::Sys.time()
[13:36:42.582]             {
[13:36:42.582]                 {
[13:36:42.582]                   {
[13:36:42.582]                     {
[13:36:42.582]                       {
[13:36:42.582]                         base::local({
[13:36:42.582]                           has_future <- base::requireNamespace("future", 
[13:36:42.582]                             quietly = TRUE)
[13:36:42.582]                           if (has_future) {
[13:36:42.582]                             ns <- base::getNamespace("future")
[13:36:42.582]                             version <- ns[[".package"]][["version"]]
[13:36:42.582]                             if (is.null(version)) 
[13:36:42.582]                               version <- utils::packageVersion("future")
[13:36:42.582]                           }
[13:36:42.582]                           else {
[13:36:42.582]                             version <- NULL
[13:36:42.582]                           }
[13:36:42.582]                           if (!has_future || version < "1.8.0") {
[13:36:42.582]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:42.582]                               "", base::R.version$version.string), 
[13:36:42.582]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:42.582]                                 base::R.version$platform, 8 * 
[13:36:42.582]                                   base::.Machine$sizeof.pointer), 
[13:36:42.582]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:42.582]                                 "release", "version")], collapse = " "), 
[13:36:42.582]                               hostname = base::Sys.info()[["nodename"]])
[13:36:42.582]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:42.582]                               info)
[13:36:42.582]                             info <- base::paste(info, collapse = "; ")
[13:36:42.582]                             if (!has_future) {
[13:36:42.582]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:42.582]                                 info)
[13:36:42.582]                             }
[13:36:42.582]                             else {
[13:36:42.582]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:42.582]                                 info, version)
[13:36:42.582]                             }
[13:36:42.582]                             base::stop(msg)
[13:36:42.582]                           }
[13:36:42.582]                         })
[13:36:42.582]                       }
[13:36:42.582]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:42.582]                       base::options(mc.cores = 1L)
[13:36:42.582]                     }
[13:36:42.582]                     base::local({
[13:36:42.582]                       for (pkg in "stats") {
[13:36:42.582]                         base::loadNamespace(pkg)
[13:36:42.582]                         base::library(pkg, character.only = TRUE)
[13:36:42.582]                       }
[13:36:42.582]                     })
[13:36:42.582]                   }
[13:36:42.582]                   ...future.strategy.old <- future::plan("list")
[13:36:42.582]                   options(future.plan = NULL)
[13:36:42.582]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.582]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:42.582]                 }
[13:36:42.582]                 ...future.workdir <- getwd()
[13:36:42.582]             }
[13:36:42.582]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:42.582]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:42.582]         }
[13:36:42.582]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:42.582]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:42.582]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:42.582]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:42.582]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:42.582]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:42.582]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:42.582]             base::names(...future.oldOptions))
[13:36:42.582]     }
[13:36:42.582]     if (FALSE) {
[13:36:42.582]     }
[13:36:42.582]     else {
[13:36:42.582]         if (TRUE) {
[13:36:42.582]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:42.582]                 open = "w")
[13:36:42.582]         }
[13:36:42.582]         else {
[13:36:42.582]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:42.582]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:42.582]         }
[13:36:42.582]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:42.582]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:42.582]             base::sink(type = "output", split = FALSE)
[13:36:42.582]             base::close(...future.stdout)
[13:36:42.582]         }, add = TRUE)
[13:36:42.582]     }
[13:36:42.582]     ...future.frame <- base::sys.nframe()
[13:36:42.582]     ...future.conditions <- base::list()
[13:36:42.582]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:42.582]     if (FALSE) {
[13:36:42.582]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:42.582]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:42.582]     }
[13:36:42.582]     ...future.result <- base::tryCatch({
[13:36:42.582]         base::withCallingHandlers({
[13:36:42.582]             ...future.value <- base::withVisible(base::local({
[13:36:42.582]                 ...future.makeSendCondition <- base::local({
[13:36:42.582]                   sendCondition <- NULL
[13:36:42.582]                   function(frame = 1L) {
[13:36:42.582]                     if (is.function(sendCondition)) 
[13:36:42.582]                       return(sendCondition)
[13:36:42.582]                     ns <- getNamespace("parallel")
[13:36:42.582]                     if (exists("sendData", mode = "function", 
[13:36:42.582]                       envir = ns)) {
[13:36:42.582]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:42.582]                         envir = ns)
[13:36:42.582]                       envir <- sys.frame(frame)
[13:36:42.582]                       master <- NULL
[13:36:42.582]                       while (!identical(envir, .GlobalEnv) && 
[13:36:42.582]                         !identical(envir, emptyenv())) {
[13:36:42.582]                         if (exists("master", mode = "list", envir = envir, 
[13:36:42.582]                           inherits = FALSE)) {
[13:36:42.582]                           master <- get("master", mode = "list", 
[13:36:42.582]                             envir = envir, inherits = FALSE)
[13:36:42.582]                           if (inherits(master, c("SOCKnode", 
[13:36:42.582]                             "SOCK0node"))) {
[13:36:42.582]                             sendCondition <<- function(cond) {
[13:36:42.582]                               data <- list(type = "VALUE", value = cond, 
[13:36:42.582]                                 success = TRUE)
[13:36:42.582]                               parallel_sendData(master, data)
[13:36:42.582]                             }
[13:36:42.582]                             return(sendCondition)
[13:36:42.582]                           }
[13:36:42.582]                         }
[13:36:42.582]                         frame <- frame + 1L
[13:36:42.582]                         envir <- sys.frame(frame)
[13:36:42.582]                       }
[13:36:42.582]                     }
[13:36:42.582]                     sendCondition <<- function(cond) NULL
[13:36:42.582]                   }
[13:36:42.582]                 })
[13:36:42.582]                 withCallingHandlers({
[13:36:42.582]                   {
[13:36:42.582]                     xtabs(~x)
[13:36:42.582]                   }
[13:36:42.582]                 }, immediateCondition = function(cond) {
[13:36:42.582]                   sendCondition <- ...future.makeSendCondition()
[13:36:42.582]                   sendCondition(cond)
[13:36:42.582]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.582]                   {
[13:36:42.582]                     inherits <- base::inherits
[13:36:42.582]                     invokeRestart <- base::invokeRestart
[13:36:42.582]                     is.null <- base::is.null
[13:36:42.582]                     muffled <- FALSE
[13:36:42.582]                     if (inherits(cond, "message")) {
[13:36:42.582]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:42.582]                       if (muffled) 
[13:36:42.582]                         invokeRestart("muffleMessage")
[13:36:42.582]                     }
[13:36:42.582]                     else if (inherits(cond, "warning")) {
[13:36:42.582]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:42.582]                       if (muffled) 
[13:36:42.582]                         invokeRestart("muffleWarning")
[13:36:42.582]                     }
[13:36:42.582]                     else if (inherits(cond, "condition")) {
[13:36:42.582]                       if (!is.null(pattern)) {
[13:36:42.582]                         computeRestarts <- base::computeRestarts
[13:36:42.582]                         grepl <- base::grepl
[13:36:42.582]                         restarts <- computeRestarts(cond)
[13:36:42.582]                         for (restart in restarts) {
[13:36:42.582]                           name <- restart$name
[13:36:42.582]                           if (is.null(name)) 
[13:36:42.582]                             next
[13:36:42.582]                           if (!grepl(pattern, name)) 
[13:36:42.582]                             next
[13:36:42.582]                           invokeRestart(restart)
[13:36:42.582]                           muffled <- TRUE
[13:36:42.582]                           break
[13:36:42.582]                         }
[13:36:42.582]                       }
[13:36:42.582]                     }
[13:36:42.582]                     invisible(muffled)
[13:36:42.582]                   }
[13:36:42.582]                   muffleCondition(cond)
[13:36:42.582]                 })
[13:36:42.582]             }))
[13:36:42.582]             future::FutureResult(value = ...future.value$value, 
[13:36:42.582]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.582]                   ...future.rng), globalenv = if (FALSE) 
[13:36:42.582]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:42.582]                     ...future.globalenv.names))
[13:36:42.582]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:42.582]         }, condition = base::local({
[13:36:42.582]             c <- base::c
[13:36:42.582]             inherits <- base::inherits
[13:36:42.582]             invokeRestart <- base::invokeRestart
[13:36:42.582]             length <- base::length
[13:36:42.582]             list <- base::list
[13:36:42.582]             seq.int <- base::seq.int
[13:36:42.582]             signalCondition <- base::signalCondition
[13:36:42.582]             sys.calls <- base::sys.calls
[13:36:42.582]             `[[` <- base::`[[`
[13:36:42.582]             `+` <- base::`+`
[13:36:42.582]             `<<-` <- base::`<<-`
[13:36:42.582]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:42.582]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:42.582]                   3L)]
[13:36:42.582]             }
[13:36:42.582]             function(cond) {
[13:36:42.582]                 is_error <- inherits(cond, "error")
[13:36:42.582]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:42.582]                   NULL)
[13:36:42.582]                 if (is_error) {
[13:36:42.582]                   sessionInformation <- function() {
[13:36:42.582]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:42.582]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:42.582]                       search = base::search(), system = base::Sys.info())
[13:36:42.582]                   }
[13:36:42.582]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.582]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:42.582]                     cond$call), session = sessionInformation(), 
[13:36:42.582]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:42.582]                   signalCondition(cond)
[13:36:42.582]                 }
[13:36:42.582]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:42.582]                 "immediateCondition"))) {
[13:36:42.582]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:42.582]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.582]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:42.582]                   if (TRUE && !signal) {
[13:36:42.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.582]                     {
[13:36:42.582]                       inherits <- base::inherits
[13:36:42.582]                       invokeRestart <- base::invokeRestart
[13:36:42.582]                       is.null <- base::is.null
[13:36:42.582]                       muffled <- FALSE
[13:36:42.582]                       if (inherits(cond, "message")) {
[13:36:42.582]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.582]                         if (muffled) 
[13:36:42.582]                           invokeRestart("muffleMessage")
[13:36:42.582]                       }
[13:36:42.582]                       else if (inherits(cond, "warning")) {
[13:36:42.582]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.582]                         if (muffled) 
[13:36:42.582]                           invokeRestart("muffleWarning")
[13:36:42.582]                       }
[13:36:42.582]                       else if (inherits(cond, "condition")) {
[13:36:42.582]                         if (!is.null(pattern)) {
[13:36:42.582]                           computeRestarts <- base::computeRestarts
[13:36:42.582]                           grepl <- base::grepl
[13:36:42.582]                           restarts <- computeRestarts(cond)
[13:36:42.582]                           for (restart in restarts) {
[13:36:42.582]                             name <- restart$name
[13:36:42.582]                             if (is.null(name)) 
[13:36:42.582]                               next
[13:36:42.582]                             if (!grepl(pattern, name)) 
[13:36:42.582]                               next
[13:36:42.582]                             invokeRestart(restart)
[13:36:42.582]                             muffled <- TRUE
[13:36:42.582]                             break
[13:36:42.582]                           }
[13:36:42.582]                         }
[13:36:42.582]                       }
[13:36:42.582]                       invisible(muffled)
[13:36:42.582]                     }
[13:36:42.582]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.582]                   }
[13:36:42.582]                 }
[13:36:42.582]                 else {
[13:36:42.582]                   if (TRUE) {
[13:36:42.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.582]                     {
[13:36:42.582]                       inherits <- base::inherits
[13:36:42.582]                       invokeRestart <- base::invokeRestart
[13:36:42.582]                       is.null <- base::is.null
[13:36:42.582]                       muffled <- FALSE
[13:36:42.582]                       if (inherits(cond, "message")) {
[13:36:42.582]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.582]                         if (muffled) 
[13:36:42.582]                           invokeRestart("muffleMessage")
[13:36:42.582]                       }
[13:36:42.582]                       else if (inherits(cond, "warning")) {
[13:36:42.582]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.582]                         if (muffled) 
[13:36:42.582]                           invokeRestart("muffleWarning")
[13:36:42.582]                       }
[13:36:42.582]                       else if (inherits(cond, "condition")) {
[13:36:42.582]                         if (!is.null(pattern)) {
[13:36:42.582]                           computeRestarts <- base::computeRestarts
[13:36:42.582]                           grepl <- base::grepl
[13:36:42.582]                           restarts <- computeRestarts(cond)
[13:36:42.582]                           for (restart in restarts) {
[13:36:42.582]                             name <- restart$name
[13:36:42.582]                             if (is.null(name)) 
[13:36:42.582]                               next
[13:36:42.582]                             if (!grepl(pattern, name)) 
[13:36:42.582]                               next
[13:36:42.582]                             invokeRestart(restart)
[13:36:42.582]                             muffled <- TRUE
[13:36:42.582]                             break
[13:36:42.582]                           }
[13:36:42.582]                         }
[13:36:42.582]                       }
[13:36:42.582]                       invisible(muffled)
[13:36:42.582]                     }
[13:36:42.582]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.582]                   }
[13:36:42.582]                 }
[13:36:42.582]             }
[13:36:42.582]         }))
[13:36:42.582]     }, error = function(ex) {
[13:36:42.582]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:42.582]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.582]                 ...future.rng), started = ...future.startTime, 
[13:36:42.582]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:42.582]             version = "1.8"), class = "FutureResult")
[13:36:42.582]     }, finally = {
[13:36:42.582]         if (!identical(...future.workdir, getwd())) 
[13:36:42.582]             setwd(...future.workdir)
[13:36:42.582]         {
[13:36:42.582]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:42.582]                 ...future.oldOptions$nwarnings <- NULL
[13:36:42.582]             }
[13:36:42.582]             base::options(...future.oldOptions)
[13:36:42.582]             if (.Platform$OS.type == "windows") {
[13:36:42.582]                 old_names <- names(...future.oldEnvVars)
[13:36:42.582]                 envs <- base::Sys.getenv()
[13:36:42.582]                 names <- names(envs)
[13:36:42.582]                 common <- intersect(names, old_names)
[13:36:42.582]                 added <- setdiff(names, old_names)
[13:36:42.582]                 removed <- setdiff(old_names, names)
[13:36:42.582]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:42.582]                   envs[common]]
[13:36:42.582]                 NAMES <- toupper(changed)
[13:36:42.582]                 args <- list()
[13:36:42.582]                 for (kk in seq_along(NAMES)) {
[13:36:42.582]                   name <- changed[[kk]]
[13:36:42.582]                   NAME <- NAMES[[kk]]
[13:36:42.582]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.582]                     next
[13:36:42.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.582]                 }
[13:36:42.582]                 NAMES <- toupper(added)
[13:36:42.582]                 for (kk in seq_along(NAMES)) {
[13:36:42.582]                   name <- added[[kk]]
[13:36:42.582]                   NAME <- NAMES[[kk]]
[13:36:42.582]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.582]                     next
[13:36:42.582]                   args[[name]] <- ""
[13:36:42.582]                 }
[13:36:42.582]                 NAMES <- toupper(removed)
[13:36:42.582]                 for (kk in seq_along(NAMES)) {
[13:36:42.582]                   name <- removed[[kk]]
[13:36:42.582]                   NAME <- NAMES[[kk]]
[13:36:42.582]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.582]                     next
[13:36:42.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.582]                 }
[13:36:42.582]                 if (length(args) > 0) 
[13:36:42.582]                   base::do.call(base::Sys.setenv, args = args)
[13:36:42.582]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:42.582]             }
[13:36:42.582]             else {
[13:36:42.582]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:42.582]             }
[13:36:42.582]             {
[13:36:42.582]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:42.582]                   0L) {
[13:36:42.582]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:42.582]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:42.582]                   base::options(opts)
[13:36:42.582]                 }
[13:36:42.582]                 {
[13:36:42.582]                   {
[13:36:42.582]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:42.582]                     NULL
[13:36:42.582]                   }
[13:36:42.582]                   options(future.plan = NULL)
[13:36:42.582]                   if (is.na(NA_character_)) 
[13:36:42.582]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.582]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:42.582]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:42.582]                     .init = FALSE)
[13:36:42.582]                 }
[13:36:42.582]             }
[13:36:42.582]         }
[13:36:42.582]     })
[13:36:42.582]     if (TRUE) {
[13:36:42.582]         base::sink(type = "output", split = FALSE)
[13:36:42.582]         if (TRUE) {
[13:36:42.582]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:42.582]         }
[13:36:42.582]         else {
[13:36:42.582]             ...future.result["stdout"] <- base::list(NULL)
[13:36:42.582]         }
[13:36:42.582]         base::close(...future.stdout)
[13:36:42.582]         ...future.stdout <- NULL
[13:36:42.582]     }
[13:36:42.582]     ...future.result$conditions <- ...future.conditions
[13:36:42.582]     ...future.result$finished <- base::Sys.time()
[13:36:42.582]     ...future.result
[13:36:42.582] }
[13:36:42.584] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[13:36:42.585] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[13:36:42.585] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[13:36:42.585] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[13:36:42.585] MultisessionFuture started
[13:36:42.586] - Launch lazy future ... done
[13:36:42.586] run() for ‘MultisessionFuture’ ... done
[13:36:42.586] result() for ClusterFuture ...
[13:36:42.586] receiveMessageFromWorker() for ClusterFuture ...
[13:36:42.586] - Validating connection of MultisessionFuture
[13:36:42.628] - received message: FutureResult
[13:36:42.628] - Received FutureResult
[13:36:42.628] - Erased future from FutureRegistry
[13:36:42.629] result() for ClusterFuture ...
[13:36:42.629] - result already collected: FutureResult
[13:36:42.629] result() for ClusterFuture ... done
[13:36:42.629] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:42.629] result() for ClusterFuture ... done
[13:36:42.629] result() for ClusterFuture ...
[13:36:42.629] - result already collected: FutureResult
[13:36:42.629] result() for ClusterFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[13:36:42.631] getGlobalsAndPackages() ...
[13:36:42.631] Searching for globals...
[13:36:42.632] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[13:36:42.632] Searching for globals ... DONE
[13:36:42.633] Resolving globals: FALSE
[13:36:42.633] 
[13:36:42.633] - packages: [2] ‘stats’, ‘datasets’
[13:36:42.633] getGlobalsAndPackages() ... DONE
[13:36:42.633] run() for ‘Future’ ...
[13:36:42.634] - state: ‘created’
[13:36:42.634] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:42.648] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:42.648] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:42.648]   - Field: ‘node’
[13:36:42.648]   - Field: ‘label’
[13:36:42.648]   - Field: ‘local’
[13:36:42.648]   - Field: ‘owner’
[13:36:42.648]   - Field: ‘envir’
[13:36:42.648]   - Field: ‘workers’
[13:36:42.648]   - Field: ‘packages’
[13:36:42.648]   - Field: ‘gc’
[13:36:42.649]   - Field: ‘conditions’
[13:36:42.649]   - Field: ‘persistent’
[13:36:42.649]   - Field: ‘expr’
[13:36:42.649]   - Field: ‘uuid’
[13:36:42.649]   - Field: ‘seed’
[13:36:42.649]   - Field: ‘version’
[13:36:42.649]   - Field: ‘result’
[13:36:42.649]   - Field: ‘asynchronous’
[13:36:42.649]   - Field: ‘calls’
[13:36:42.649]   - Field: ‘globals’
[13:36:42.649]   - Field: ‘stdout’
[13:36:42.650]   - Field: ‘earlySignal’
[13:36:42.650]   - Field: ‘lazy’
[13:36:42.650]   - Field: ‘state’
[13:36:42.650] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:42.650] - Launch lazy future ...
[13:36:42.650] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:36:42.650] Packages needed by future strategies (n = 0): <none>
[13:36:42.651] {
[13:36:42.651]     {
[13:36:42.651]         {
[13:36:42.651]             ...future.startTime <- base::Sys.time()
[13:36:42.651]             {
[13:36:42.651]                 {
[13:36:42.651]                   {
[13:36:42.651]                     {
[13:36:42.651]                       {
[13:36:42.651]                         base::local({
[13:36:42.651]                           has_future <- base::requireNamespace("future", 
[13:36:42.651]                             quietly = TRUE)
[13:36:42.651]                           if (has_future) {
[13:36:42.651]                             ns <- base::getNamespace("future")
[13:36:42.651]                             version <- ns[[".package"]][["version"]]
[13:36:42.651]                             if (is.null(version)) 
[13:36:42.651]                               version <- utils::packageVersion("future")
[13:36:42.651]                           }
[13:36:42.651]                           else {
[13:36:42.651]                             version <- NULL
[13:36:42.651]                           }
[13:36:42.651]                           if (!has_future || version < "1.8.0") {
[13:36:42.651]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:42.651]                               "", base::R.version$version.string), 
[13:36:42.651]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:42.651]                                 base::R.version$platform, 8 * 
[13:36:42.651]                                   base::.Machine$sizeof.pointer), 
[13:36:42.651]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:42.651]                                 "release", "version")], collapse = " "), 
[13:36:42.651]                               hostname = base::Sys.info()[["nodename"]])
[13:36:42.651]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:42.651]                               info)
[13:36:42.651]                             info <- base::paste(info, collapse = "; ")
[13:36:42.651]                             if (!has_future) {
[13:36:42.651]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:42.651]                                 info)
[13:36:42.651]                             }
[13:36:42.651]                             else {
[13:36:42.651]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:42.651]                                 info, version)
[13:36:42.651]                             }
[13:36:42.651]                             base::stop(msg)
[13:36:42.651]                           }
[13:36:42.651]                         })
[13:36:42.651]                       }
[13:36:42.651]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:42.651]                       base::options(mc.cores = 1L)
[13:36:42.651]                     }
[13:36:42.651]                     base::local({
[13:36:42.651]                       for (pkg in c("stats", "datasets")) {
[13:36:42.651]                         base::loadNamespace(pkg)
[13:36:42.651]                         base::library(pkg, character.only = TRUE)
[13:36:42.651]                       }
[13:36:42.651]                     })
[13:36:42.651]                   }
[13:36:42.651]                   ...future.strategy.old <- future::plan("list")
[13:36:42.651]                   options(future.plan = NULL)
[13:36:42.651]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.651]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:42.651]                 }
[13:36:42.651]                 ...future.workdir <- getwd()
[13:36:42.651]             }
[13:36:42.651]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:42.651]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:42.651]         }
[13:36:42.651]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:42.651]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:42.651]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:42.651]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:42.651]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:42.651]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:42.651]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:42.651]             base::names(...future.oldOptions))
[13:36:42.651]     }
[13:36:42.651]     if (FALSE) {
[13:36:42.651]     }
[13:36:42.651]     else {
[13:36:42.651]         if (TRUE) {
[13:36:42.651]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:42.651]                 open = "w")
[13:36:42.651]         }
[13:36:42.651]         else {
[13:36:42.651]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:42.651]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:42.651]         }
[13:36:42.651]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:42.651]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:42.651]             base::sink(type = "output", split = FALSE)
[13:36:42.651]             base::close(...future.stdout)
[13:36:42.651]         }, add = TRUE)
[13:36:42.651]     }
[13:36:42.651]     ...future.frame <- base::sys.nframe()
[13:36:42.651]     ...future.conditions <- base::list()
[13:36:42.651]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:42.651]     if (FALSE) {
[13:36:42.651]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:42.651]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:42.651]     }
[13:36:42.651]     ...future.result <- base::tryCatch({
[13:36:42.651]         base::withCallingHandlers({
[13:36:42.651]             ...future.value <- base::withVisible(base::local({
[13:36:42.651]                 ...future.makeSendCondition <- base::local({
[13:36:42.651]                   sendCondition <- NULL
[13:36:42.651]                   function(frame = 1L) {
[13:36:42.651]                     if (is.function(sendCondition)) 
[13:36:42.651]                       return(sendCondition)
[13:36:42.651]                     ns <- getNamespace("parallel")
[13:36:42.651]                     if (exists("sendData", mode = "function", 
[13:36:42.651]                       envir = ns)) {
[13:36:42.651]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:42.651]                         envir = ns)
[13:36:42.651]                       envir <- sys.frame(frame)
[13:36:42.651]                       master <- NULL
[13:36:42.651]                       while (!identical(envir, .GlobalEnv) && 
[13:36:42.651]                         !identical(envir, emptyenv())) {
[13:36:42.651]                         if (exists("master", mode = "list", envir = envir, 
[13:36:42.651]                           inherits = FALSE)) {
[13:36:42.651]                           master <- get("master", mode = "list", 
[13:36:42.651]                             envir = envir, inherits = FALSE)
[13:36:42.651]                           if (inherits(master, c("SOCKnode", 
[13:36:42.651]                             "SOCK0node"))) {
[13:36:42.651]                             sendCondition <<- function(cond) {
[13:36:42.651]                               data <- list(type = "VALUE", value = cond, 
[13:36:42.651]                                 success = TRUE)
[13:36:42.651]                               parallel_sendData(master, data)
[13:36:42.651]                             }
[13:36:42.651]                             return(sendCondition)
[13:36:42.651]                           }
[13:36:42.651]                         }
[13:36:42.651]                         frame <- frame + 1L
[13:36:42.651]                         envir <- sys.frame(frame)
[13:36:42.651]                       }
[13:36:42.651]                     }
[13:36:42.651]                     sendCondition <<- function(cond) NULL
[13:36:42.651]                   }
[13:36:42.651]                 })
[13:36:42.651]                 withCallingHandlers({
[13:36:42.651]                   {
[13:36:42.651]                     lm(dist ~ . - 1, data = cars)
[13:36:42.651]                   }
[13:36:42.651]                 }, immediateCondition = function(cond) {
[13:36:42.651]                   sendCondition <- ...future.makeSendCondition()
[13:36:42.651]                   sendCondition(cond)
[13:36:42.651]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.651]                   {
[13:36:42.651]                     inherits <- base::inherits
[13:36:42.651]                     invokeRestart <- base::invokeRestart
[13:36:42.651]                     is.null <- base::is.null
[13:36:42.651]                     muffled <- FALSE
[13:36:42.651]                     if (inherits(cond, "message")) {
[13:36:42.651]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:42.651]                       if (muffled) 
[13:36:42.651]                         invokeRestart("muffleMessage")
[13:36:42.651]                     }
[13:36:42.651]                     else if (inherits(cond, "warning")) {
[13:36:42.651]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:42.651]                       if (muffled) 
[13:36:42.651]                         invokeRestart("muffleWarning")
[13:36:42.651]                     }
[13:36:42.651]                     else if (inherits(cond, "condition")) {
[13:36:42.651]                       if (!is.null(pattern)) {
[13:36:42.651]                         computeRestarts <- base::computeRestarts
[13:36:42.651]                         grepl <- base::grepl
[13:36:42.651]                         restarts <- computeRestarts(cond)
[13:36:42.651]                         for (restart in restarts) {
[13:36:42.651]                           name <- restart$name
[13:36:42.651]                           if (is.null(name)) 
[13:36:42.651]                             next
[13:36:42.651]                           if (!grepl(pattern, name)) 
[13:36:42.651]                             next
[13:36:42.651]                           invokeRestart(restart)
[13:36:42.651]                           muffled <- TRUE
[13:36:42.651]                           break
[13:36:42.651]                         }
[13:36:42.651]                       }
[13:36:42.651]                     }
[13:36:42.651]                     invisible(muffled)
[13:36:42.651]                   }
[13:36:42.651]                   muffleCondition(cond)
[13:36:42.651]                 })
[13:36:42.651]             }))
[13:36:42.651]             future::FutureResult(value = ...future.value$value, 
[13:36:42.651]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.651]                   ...future.rng), globalenv = if (FALSE) 
[13:36:42.651]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:42.651]                     ...future.globalenv.names))
[13:36:42.651]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:42.651]         }, condition = base::local({
[13:36:42.651]             c <- base::c
[13:36:42.651]             inherits <- base::inherits
[13:36:42.651]             invokeRestart <- base::invokeRestart
[13:36:42.651]             length <- base::length
[13:36:42.651]             list <- base::list
[13:36:42.651]             seq.int <- base::seq.int
[13:36:42.651]             signalCondition <- base::signalCondition
[13:36:42.651]             sys.calls <- base::sys.calls
[13:36:42.651]             `[[` <- base::`[[`
[13:36:42.651]             `+` <- base::`+`
[13:36:42.651]             `<<-` <- base::`<<-`
[13:36:42.651]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:42.651]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:42.651]                   3L)]
[13:36:42.651]             }
[13:36:42.651]             function(cond) {
[13:36:42.651]                 is_error <- inherits(cond, "error")
[13:36:42.651]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:42.651]                   NULL)
[13:36:42.651]                 if (is_error) {
[13:36:42.651]                   sessionInformation <- function() {
[13:36:42.651]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:42.651]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:42.651]                       search = base::search(), system = base::Sys.info())
[13:36:42.651]                   }
[13:36:42.651]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.651]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:42.651]                     cond$call), session = sessionInformation(), 
[13:36:42.651]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:42.651]                   signalCondition(cond)
[13:36:42.651]                 }
[13:36:42.651]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:42.651]                 "immediateCondition"))) {
[13:36:42.651]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:42.651]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.651]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:42.651]                   if (TRUE && !signal) {
[13:36:42.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.651]                     {
[13:36:42.651]                       inherits <- base::inherits
[13:36:42.651]                       invokeRestart <- base::invokeRestart
[13:36:42.651]                       is.null <- base::is.null
[13:36:42.651]                       muffled <- FALSE
[13:36:42.651]                       if (inherits(cond, "message")) {
[13:36:42.651]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.651]                         if (muffled) 
[13:36:42.651]                           invokeRestart("muffleMessage")
[13:36:42.651]                       }
[13:36:42.651]                       else if (inherits(cond, "warning")) {
[13:36:42.651]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.651]                         if (muffled) 
[13:36:42.651]                           invokeRestart("muffleWarning")
[13:36:42.651]                       }
[13:36:42.651]                       else if (inherits(cond, "condition")) {
[13:36:42.651]                         if (!is.null(pattern)) {
[13:36:42.651]                           computeRestarts <- base::computeRestarts
[13:36:42.651]                           grepl <- base::grepl
[13:36:42.651]                           restarts <- computeRestarts(cond)
[13:36:42.651]                           for (restart in restarts) {
[13:36:42.651]                             name <- restart$name
[13:36:42.651]                             if (is.null(name)) 
[13:36:42.651]                               next
[13:36:42.651]                             if (!grepl(pattern, name)) 
[13:36:42.651]                               next
[13:36:42.651]                             invokeRestart(restart)
[13:36:42.651]                             muffled <- TRUE
[13:36:42.651]                             break
[13:36:42.651]                           }
[13:36:42.651]                         }
[13:36:42.651]                       }
[13:36:42.651]                       invisible(muffled)
[13:36:42.651]                     }
[13:36:42.651]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.651]                   }
[13:36:42.651]                 }
[13:36:42.651]                 else {
[13:36:42.651]                   if (TRUE) {
[13:36:42.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.651]                     {
[13:36:42.651]                       inherits <- base::inherits
[13:36:42.651]                       invokeRestart <- base::invokeRestart
[13:36:42.651]                       is.null <- base::is.null
[13:36:42.651]                       muffled <- FALSE
[13:36:42.651]                       if (inherits(cond, "message")) {
[13:36:42.651]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.651]                         if (muffled) 
[13:36:42.651]                           invokeRestart("muffleMessage")
[13:36:42.651]                       }
[13:36:42.651]                       else if (inherits(cond, "warning")) {
[13:36:42.651]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.651]                         if (muffled) 
[13:36:42.651]                           invokeRestart("muffleWarning")
[13:36:42.651]                       }
[13:36:42.651]                       else if (inherits(cond, "condition")) {
[13:36:42.651]                         if (!is.null(pattern)) {
[13:36:42.651]                           computeRestarts <- base::computeRestarts
[13:36:42.651]                           grepl <- base::grepl
[13:36:42.651]                           restarts <- computeRestarts(cond)
[13:36:42.651]                           for (restart in restarts) {
[13:36:42.651]                             name <- restart$name
[13:36:42.651]                             if (is.null(name)) 
[13:36:42.651]                               next
[13:36:42.651]                             if (!grepl(pattern, name)) 
[13:36:42.651]                               next
[13:36:42.651]                             invokeRestart(restart)
[13:36:42.651]                             muffled <- TRUE
[13:36:42.651]                             break
[13:36:42.651]                           }
[13:36:42.651]                         }
[13:36:42.651]                       }
[13:36:42.651]                       invisible(muffled)
[13:36:42.651]                     }
[13:36:42.651]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.651]                   }
[13:36:42.651]                 }
[13:36:42.651]             }
[13:36:42.651]         }))
[13:36:42.651]     }, error = function(ex) {
[13:36:42.651]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:42.651]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.651]                 ...future.rng), started = ...future.startTime, 
[13:36:42.651]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:42.651]             version = "1.8"), class = "FutureResult")
[13:36:42.651]     }, finally = {
[13:36:42.651]         if (!identical(...future.workdir, getwd())) 
[13:36:42.651]             setwd(...future.workdir)
[13:36:42.651]         {
[13:36:42.651]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:42.651]                 ...future.oldOptions$nwarnings <- NULL
[13:36:42.651]             }
[13:36:42.651]             base::options(...future.oldOptions)
[13:36:42.651]             if (.Platform$OS.type == "windows") {
[13:36:42.651]                 old_names <- names(...future.oldEnvVars)
[13:36:42.651]                 envs <- base::Sys.getenv()
[13:36:42.651]                 names <- names(envs)
[13:36:42.651]                 common <- intersect(names, old_names)
[13:36:42.651]                 added <- setdiff(names, old_names)
[13:36:42.651]                 removed <- setdiff(old_names, names)
[13:36:42.651]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:42.651]                   envs[common]]
[13:36:42.651]                 NAMES <- toupper(changed)
[13:36:42.651]                 args <- list()
[13:36:42.651]                 for (kk in seq_along(NAMES)) {
[13:36:42.651]                   name <- changed[[kk]]
[13:36:42.651]                   NAME <- NAMES[[kk]]
[13:36:42.651]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.651]                     next
[13:36:42.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.651]                 }
[13:36:42.651]                 NAMES <- toupper(added)
[13:36:42.651]                 for (kk in seq_along(NAMES)) {
[13:36:42.651]                   name <- added[[kk]]
[13:36:42.651]                   NAME <- NAMES[[kk]]
[13:36:42.651]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.651]                     next
[13:36:42.651]                   args[[name]] <- ""
[13:36:42.651]                 }
[13:36:42.651]                 NAMES <- toupper(removed)
[13:36:42.651]                 for (kk in seq_along(NAMES)) {
[13:36:42.651]                   name <- removed[[kk]]
[13:36:42.651]                   NAME <- NAMES[[kk]]
[13:36:42.651]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.651]                     next
[13:36:42.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.651]                 }
[13:36:42.651]                 if (length(args) > 0) 
[13:36:42.651]                   base::do.call(base::Sys.setenv, args = args)
[13:36:42.651]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:42.651]             }
[13:36:42.651]             else {
[13:36:42.651]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:42.651]             }
[13:36:42.651]             {
[13:36:42.651]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:42.651]                   0L) {
[13:36:42.651]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:42.651]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:42.651]                   base::options(opts)
[13:36:42.651]                 }
[13:36:42.651]                 {
[13:36:42.651]                   {
[13:36:42.651]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:42.651]                     NULL
[13:36:42.651]                   }
[13:36:42.651]                   options(future.plan = NULL)
[13:36:42.651]                   if (is.na(NA_character_)) 
[13:36:42.651]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.651]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:42.651]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:42.651]                     .init = FALSE)
[13:36:42.651]                 }
[13:36:42.651]             }
[13:36:42.651]         }
[13:36:42.651]     })
[13:36:42.651]     if (TRUE) {
[13:36:42.651]         base::sink(type = "output", split = FALSE)
[13:36:42.651]         if (TRUE) {
[13:36:42.651]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:42.651]         }
[13:36:42.651]         else {
[13:36:42.651]             ...future.result["stdout"] <- base::list(NULL)
[13:36:42.651]         }
[13:36:42.651]         base::close(...future.stdout)
[13:36:42.651]         ...future.stdout <- NULL
[13:36:42.651]     }
[13:36:42.651]     ...future.result$conditions <- ...future.conditions
[13:36:42.651]     ...future.result$finished <- base::Sys.time()
[13:36:42.651]     ...future.result
[13:36:42.651] }
[13:36:42.654] MultisessionFuture started
[13:36:42.654] - Launch lazy future ... done
[13:36:42.654] run() for ‘MultisessionFuture’ ... done
[13:36:42.654] result() for ClusterFuture ...
[13:36:42.655] receiveMessageFromWorker() for ClusterFuture ...
[13:36:42.655] - Validating connection of MultisessionFuture
[13:36:42.697] - received message: FutureResult
[13:36:42.697] - Received FutureResult
[13:36:42.697] - Erased future from FutureRegistry
[13:36:42.697] result() for ClusterFuture ...
[13:36:42.697] - result already collected: FutureResult
[13:36:42.697] result() for ClusterFuture ... done
[13:36:42.697] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:42.698] result() for ClusterFuture ... done
[13:36:42.698] result() for ClusterFuture ...
[13:36:42.698] - result already collected: FutureResult
[13:36:42.698] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[13:36:42.703] getGlobalsAndPackages() ...
[13:36:42.703] Searching for globals...
[13:36:42.704] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[13:36:42.704] Searching for globals ... DONE
[13:36:42.704] Resolving globals: FALSE
[13:36:42.705] 
[13:36:42.705] - packages: [2] ‘stats’, ‘datasets’
[13:36:42.705] getGlobalsAndPackages() ... DONE
[13:36:42.705] run() for ‘Future’ ...
[13:36:42.705] - state: ‘created’
[13:36:42.706] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:42.720] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:42.720] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:42.720]   - Field: ‘node’
[13:36:42.720]   - Field: ‘label’
[13:36:42.720]   - Field: ‘local’
[13:36:42.720]   - Field: ‘owner’
[13:36:42.721]   - Field: ‘envir’
[13:36:42.721]   - Field: ‘workers’
[13:36:42.721]   - Field: ‘packages’
[13:36:42.721]   - Field: ‘gc’
[13:36:42.721]   - Field: ‘conditions’
[13:36:42.721]   - Field: ‘persistent’
[13:36:42.721]   - Field: ‘expr’
[13:36:42.721]   - Field: ‘uuid’
[13:36:42.721]   - Field: ‘seed’
[13:36:42.721]   - Field: ‘version’
[13:36:42.721]   - Field: ‘result’
[13:36:42.722]   - Field: ‘asynchronous’
[13:36:42.722]   - Field: ‘calls’
[13:36:42.722]   - Field: ‘globals’
[13:36:42.722]   - Field: ‘stdout’
[13:36:42.722]   - Field: ‘earlySignal’
[13:36:42.722]   - Field: ‘lazy’
[13:36:42.722]   - Field: ‘state’
[13:36:42.722] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:42.722] - Launch lazy future ...
[13:36:42.723] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:36:42.723] Packages needed by future strategies (n = 0): <none>
[13:36:42.723] {
[13:36:42.723]     {
[13:36:42.723]         {
[13:36:42.723]             ...future.startTime <- base::Sys.time()
[13:36:42.723]             {
[13:36:42.723]                 {
[13:36:42.723]                   {
[13:36:42.723]                     {
[13:36:42.723]                       {
[13:36:42.723]                         base::local({
[13:36:42.723]                           has_future <- base::requireNamespace("future", 
[13:36:42.723]                             quietly = TRUE)
[13:36:42.723]                           if (has_future) {
[13:36:42.723]                             ns <- base::getNamespace("future")
[13:36:42.723]                             version <- ns[[".package"]][["version"]]
[13:36:42.723]                             if (is.null(version)) 
[13:36:42.723]                               version <- utils::packageVersion("future")
[13:36:42.723]                           }
[13:36:42.723]                           else {
[13:36:42.723]                             version <- NULL
[13:36:42.723]                           }
[13:36:42.723]                           if (!has_future || version < "1.8.0") {
[13:36:42.723]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:42.723]                               "", base::R.version$version.string), 
[13:36:42.723]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:42.723]                                 base::R.version$platform, 8 * 
[13:36:42.723]                                   base::.Machine$sizeof.pointer), 
[13:36:42.723]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:42.723]                                 "release", "version")], collapse = " "), 
[13:36:42.723]                               hostname = base::Sys.info()[["nodename"]])
[13:36:42.723]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:42.723]                               info)
[13:36:42.723]                             info <- base::paste(info, collapse = "; ")
[13:36:42.723]                             if (!has_future) {
[13:36:42.723]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:42.723]                                 info)
[13:36:42.723]                             }
[13:36:42.723]                             else {
[13:36:42.723]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:42.723]                                 info, version)
[13:36:42.723]                             }
[13:36:42.723]                             base::stop(msg)
[13:36:42.723]                           }
[13:36:42.723]                         })
[13:36:42.723]                       }
[13:36:42.723]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:42.723]                       base::options(mc.cores = 1L)
[13:36:42.723]                     }
[13:36:42.723]                     base::local({
[13:36:42.723]                       for (pkg in c("stats", "datasets")) {
[13:36:42.723]                         base::loadNamespace(pkg)
[13:36:42.723]                         base::library(pkg, character.only = TRUE)
[13:36:42.723]                       }
[13:36:42.723]                     })
[13:36:42.723]                   }
[13:36:42.723]                   ...future.strategy.old <- future::plan("list")
[13:36:42.723]                   options(future.plan = NULL)
[13:36:42.723]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.723]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:42.723]                 }
[13:36:42.723]                 ...future.workdir <- getwd()
[13:36:42.723]             }
[13:36:42.723]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:42.723]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:42.723]         }
[13:36:42.723]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:42.723]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:42.723]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:42.723]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:42.723]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:42.723]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:42.723]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:42.723]             base::names(...future.oldOptions))
[13:36:42.723]     }
[13:36:42.723]     if (FALSE) {
[13:36:42.723]     }
[13:36:42.723]     else {
[13:36:42.723]         if (TRUE) {
[13:36:42.723]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:42.723]                 open = "w")
[13:36:42.723]         }
[13:36:42.723]         else {
[13:36:42.723]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:42.723]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:42.723]         }
[13:36:42.723]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:42.723]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:42.723]             base::sink(type = "output", split = FALSE)
[13:36:42.723]             base::close(...future.stdout)
[13:36:42.723]         }, add = TRUE)
[13:36:42.723]     }
[13:36:42.723]     ...future.frame <- base::sys.nframe()
[13:36:42.723]     ...future.conditions <- base::list()
[13:36:42.723]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:42.723]     if (FALSE) {
[13:36:42.723]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:42.723]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:42.723]     }
[13:36:42.723]     ...future.result <- base::tryCatch({
[13:36:42.723]         base::withCallingHandlers({
[13:36:42.723]             ...future.value <- base::withVisible(base::local({
[13:36:42.723]                 ...future.makeSendCondition <- base::local({
[13:36:42.723]                   sendCondition <- NULL
[13:36:42.723]                   function(frame = 1L) {
[13:36:42.723]                     if (is.function(sendCondition)) 
[13:36:42.723]                       return(sendCondition)
[13:36:42.723]                     ns <- getNamespace("parallel")
[13:36:42.723]                     if (exists("sendData", mode = "function", 
[13:36:42.723]                       envir = ns)) {
[13:36:42.723]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:42.723]                         envir = ns)
[13:36:42.723]                       envir <- sys.frame(frame)
[13:36:42.723]                       master <- NULL
[13:36:42.723]                       while (!identical(envir, .GlobalEnv) && 
[13:36:42.723]                         !identical(envir, emptyenv())) {
[13:36:42.723]                         if (exists("master", mode = "list", envir = envir, 
[13:36:42.723]                           inherits = FALSE)) {
[13:36:42.723]                           master <- get("master", mode = "list", 
[13:36:42.723]                             envir = envir, inherits = FALSE)
[13:36:42.723]                           if (inherits(master, c("SOCKnode", 
[13:36:42.723]                             "SOCK0node"))) {
[13:36:42.723]                             sendCondition <<- function(cond) {
[13:36:42.723]                               data <- list(type = "VALUE", value = cond, 
[13:36:42.723]                                 success = TRUE)
[13:36:42.723]                               parallel_sendData(master, data)
[13:36:42.723]                             }
[13:36:42.723]                             return(sendCondition)
[13:36:42.723]                           }
[13:36:42.723]                         }
[13:36:42.723]                         frame <- frame + 1L
[13:36:42.723]                         envir <- sys.frame(frame)
[13:36:42.723]                       }
[13:36:42.723]                     }
[13:36:42.723]                     sendCondition <<- function(cond) NULL
[13:36:42.723]                   }
[13:36:42.723]                 })
[13:36:42.723]                 withCallingHandlers({
[13:36:42.723]                   {
[13:36:42.723]                     lm(dist ~ . + 0, data = cars)
[13:36:42.723]                   }
[13:36:42.723]                 }, immediateCondition = function(cond) {
[13:36:42.723]                   sendCondition <- ...future.makeSendCondition()
[13:36:42.723]                   sendCondition(cond)
[13:36:42.723]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.723]                   {
[13:36:42.723]                     inherits <- base::inherits
[13:36:42.723]                     invokeRestart <- base::invokeRestart
[13:36:42.723]                     is.null <- base::is.null
[13:36:42.723]                     muffled <- FALSE
[13:36:42.723]                     if (inherits(cond, "message")) {
[13:36:42.723]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:42.723]                       if (muffled) 
[13:36:42.723]                         invokeRestart("muffleMessage")
[13:36:42.723]                     }
[13:36:42.723]                     else if (inherits(cond, "warning")) {
[13:36:42.723]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:42.723]                       if (muffled) 
[13:36:42.723]                         invokeRestart("muffleWarning")
[13:36:42.723]                     }
[13:36:42.723]                     else if (inherits(cond, "condition")) {
[13:36:42.723]                       if (!is.null(pattern)) {
[13:36:42.723]                         computeRestarts <- base::computeRestarts
[13:36:42.723]                         grepl <- base::grepl
[13:36:42.723]                         restarts <- computeRestarts(cond)
[13:36:42.723]                         for (restart in restarts) {
[13:36:42.723]                           name <- restart$name
[13:36:42.723]                           if (is.null(name)) 
[13:36:42.723]                             next
[13:36:42.723]                           if (!grepl(pattern, name)) 
[13:36:42.723]                             next
[13:36:42.723]                           invokeRestart(restart)
[13:36:42.723]                           muffled <- TRUE
[13:36:42.723]                           break
[13:36:42.723]                         }
[13:36:42.723]                       }
[13:36:42.723]                     }
[13:36:42.723]                     invisible(muffled)
[13:36:42.723]                   }
[13:36:42.723]                   muffleCondition(cond)
[13:36:42.723]                 })
[13:36:42.723]             }))
[13:36:42.723]             future::FutureResult(value = ...future.value$value, 
[13:36:42.723]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.723]                   ...future.rng), globalenv = if (FALSE) 
[13:36:42.723]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:42.723]                     ...future.globalenv.names))
[13:36:42.723]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:42.723]         }, condition = base::local({
[13:36:42.723]             c <- base::c
[13:36:42.723]             inherits <- base::inherits
[13:36:42.723]             invokeRestart <- base::invokeRestart
[13:36:42.723]             length <- base::length
[13:36:42.723]             list <- base::list
[13:36:42.723]             seq.int <- base::seq.int
[13:36:42.723]             signalCondition <- base::signalCondition
[13:36:42.723]             sys.calls <- base::sys.calls
[13:36:42.723]             `[[` <- base::`[[`
[13:36:42.723]             `+` <- base::`+`
[13:36:42.723]             `<<-` <- base::`<<-`
[13:36:42.723]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:42.723]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:42.723]                   3L)]
[13:36:42.723]             }
[13:36:42.723]             function(cond) {
[13:36:42.723]                 is_error <- inherits(cond, "error")
[13:36:42.723]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:42.723]                   NULL)
[13:36:42.723]                 if (is_error) {
[13:36:42.723]                   sessionInformation <- function() {
[13:36:42.723]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:42.723]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:42.723]                       search = base::search(), system = base::Sys.info())
[13:36:42.723]                   }
[13:36:42.723]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.723]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:42.723]                     cond$call), session = sessionInformation(), 
[13:36:42.723]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:42.723]                   signalCondition(cond)
[13:36:42.723]                 }
[13:36:42.723]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:42.723]                 "immediateCondition"))) {
[13:36:42.723]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:42.723]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.723]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:42.723]                   if (TRUE && !signal) {
[13:36:42.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.723]                     {
[13:36:42.723]                       inherits <- base::inherits
[13:36:42.723]                       invokeRestart <- base::invokeRestart
[13:36:42.723]                       is.null <- base::is.null
[13:36:42.723]                       muffled <- FALSE
[13:36:42.723]                       if (inherits(cond, "message")) {
[13:36:42.723]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.723]                         if (muffled) 
[13:36:42.723]                           invokeRestart("muffleMessage")
[13:36:42.723]                       }
[13:36:42.723]                       else if (inherits(cond, "warning")) {
[13:36:42.723]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.723]                         if (muffled) 
[13:36:42.723]                           invokeRestart("muffleWarning")
[13:36:42.723]                       }
[13:36:42.723]                       else if (inherits(cond, "condition")) {
[13:36:42.723]                         if (!is.null(pattern)) {
[13:36:42.723]                           computeRestarts <- base::computeRestarts
[13:36:42.723]                           grepl <- base::grepl
[13:36:42.723]                           restarts <- computeRestarts(cond)
[13:36:42.723]                           for (restart in restarts) {
[13:36:42.723]                             name <- restart$name
[13:36:42.723]                             if (is.null(name)) 
[13:36:42.723]                               next
[13:36:42.723]                             if (!grepl(pattern, name)) 
[13:36:42.723]                               next
[13:36:42.723]                             invokeRestart(restart)
[13:36:42.723]                             muffled <- TRUE
[13:36:42.723]                             break
[13:36:42.723]                           }
[13:36:42.723]                         }
[13:36:42.723]                       }
[13:36:42.723]                       invisible(muffled)
[13:36:42.723]                     }
[13:36:42.723]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.723]                   }
[13:36:42.723]                 }
[13:36:42.723]                 else {
[13:36:42.723]                   if (TRUE) {
[13:36:42.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.723]                     {
[13:36:42.723]                       inherits <- base::inherits
[13:36:42.723]                       invokeRestart <- base::invokeRestart
[13:36:42.723]                       is.null <- base::is.null
[13:36:42.723]                       muffled <- FALSE
[13:36:42.723]                       if (inherits(cond, "message")) {
[13:36:42.723]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.723]                         if (muffled) 
[13:36:42.723]                           invokeRestart("muffleMessage")
[13:36:42.723]                       }
[13:36:42.723]                       else if (inherits(cond, "warning")) {
[13:36:42.723]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.723]                         if (muffled) 
[13:36:42.723]                           invokeRestart("muffleWarning")
[13:36:42.723]                       }
[13:36:42.723]                       else if (inherits(cond, "condition")) {
[13:36:42.723]                         if (!is.null(pattern)) {
[13:36:42.723]                           computeRestarts <- base::computeRestarts
[13:36:42.723]                           grepl <- base::grepl
[13:36:42.723]                           restarts <- computeRestarts(cond)
[13:36:42.723]                           for (restart in restarts) {
[13:36:42.723]                             name <- restart$name
[13:36:42.723]                             if (is.null(name)) 
[13:36:42.723]                               next
[13:36:42.723]                             if (!grepl(pattern, name)) 
[13:36:42.723]                               next
[13:36:42.723]                             invokeRestart(restart)
[13:36:42.723]                             muffled <- TRUE
[13:36:42.723]                             break
[13:36:42.723]                           }
[13:36:42.723]                         }
[13:36:42.723]                       }
[13:36:42.723]                       invisible(muffled)
[13:36:42.723]                     }
[13:36:42.723]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.723]                   }
[13:36:42.723]                 }
[13:36:42.723]             }
[13:36:42.723]         }))
[13:36:42.723]     }, error = function(ex) {
[13:36:42.723]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:42.723]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.723]                 ...future.rng), started = ...future.startTime, 
[13:36:42.723]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:42.723]             version = "1.8"), class = "FutureResult")
[13:36:42.723]     }, finally = {
[13:36:42.723]         if (!identical(...future.workdir, getwd())) 
[13:36:42.723]             setwd(...future.workdir)
[13:36:42.723]         {
[13:36:42.723]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:42.723]                 ...future.oldOptions$nwarnings <- NULL
[13:36:42.723]             }
[13:36:42.723]             base::options(...future.oldOptions)
[13:36:42.723]             if (.Platform$OS.type == "windows") {
[13:36:42.723]                 old_names <- names(...future.oldEnvVars)
[13:36:42.723]                 envs <- base::Sys.getenv()
[13:36:42.723]                 names <- names(envs)
[13:36:42.723]                 common <- intersect(names, old_names)
[13:36:42.723]                 added <- setdiff(names, old_names)
[13:36:42.723]                 removed <- setdiff(old_names, names)
[13:36:42.723]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:42.723]                   envs[common]]
[13:36:42.723]                 NAMES <- toupper(changed)
[13:36:42.723]                 args <- list()
[13:36:42.723]                 for (kk in seq_along(NAMES)) {
[13:36:42.723]                   name <- changed[[kk]]
[13:36:42.723]                   NAME <- NAMES[[kk]]
[13:36:42.723]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.723]                     next
[13:36:42.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.723]                 }
[13:36:42.723]                 NAMES <- toupper(added)
[13:36:42.723]                 for (kk in seq_along(NAMES)) {
[13:36:42.723]                   name <- added[[kk]]
[13:36:42.723]                   NAME <- NAMES[[kk]]
[13:36:42.723]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.723]                     next
[13:36:42.723]                   args[[name]] <- ""
[13:36:42.723]                 }
[13:36:42.723]                 NAMES <- toupper(removed)
[13:36:42.723]                 for (kk in seq_along(NAMES)) {
[13:36:42.723]                   name <- removed[[kk]]
[13:36:42.723]                   NAME <- NAMES[[kk]]
[13:36:42.723]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.723]                     next
[13:36:42.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.723]                 }
[13:36:42.723]                 if (length(args) > 0) 
[13:36:42.723]                   base::do.call(base::Sys.setenv, args = args)
[13:36:42.723]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:42.723]             }
[13:36:42.723]             else {
[13:36:42.723]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:42.723]             }
[13:36:42.723]             {
[13:36:42.723]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:42.723]                   0L) {
[13:36:42.723]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:42.723]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:42.723]                   base::options(opts)
[13:36:42.723]                 }
[13:36:42.723]                 {
[13:36:42.723]                   {
[13:36:42.723]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:42.723]                     NULL
[13:36:42.723]                   }
[13:36:42.723]                   options(future.plan = NULL)
[13:36:42.723]                   if (is.na(NA_character_)) 
[13:36:42.723]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.723]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:42.723]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:42.723]                     .init = FALSE)
[13:36:42.723]                 }
[13:36:42.723]             }
[13:36:42.723]         }
[13:36:42.723]     })
[13:36:42.723]     if (TRUE) {
[13:36:42.723]         base::sink(type = "output", split = FALSE)
[13:36:42.723]         if (TRUE) {
[13:36:42.723]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:42.723]         }
[13:36:42.723]         else {
[13:36:42.723]             ...future.result["stdout"] <- base::list(NULL)
[13:36:42.723]         }
[13:36:42.723]         base::close(...future.stdout)
[13:36:42.723]         ...future.stdout <- NULL
[13:36:42.723]     }
[13:36:42.723]     ...future.result$conditions <- ...future.conditions
[13:36:42.723]     ...future.result$finished <- base::Sys.time()
[13:36:42.723]     ...future.result
[13:36:42.723] }
[13:36:42.726] MultisessionFuture started
[13:36:42.726] - Launch lazy future ... done
[13:36:42.726] run() for ‘MultisessionFuture’ ... done
[13:36:42.727] result() for ClusterFuture ...
[13:36:42.727] receiveMessageFromWorker() for ClusterFuture ...
[13:36:42.727] - Validating connection of MultisessionFuture
[13:36:42.769] - received message: FutureResult
[13:36:42.769] - Received FutureResult
[13:36:42.769] - Erased future from FutureRegistry
[13:36:42.769] result() for ClusterFuture ...
[13:36:42.769] - result already collected: FutureResult
[13:36:42.769] result() for ClusterFuture ... done
[13:36:42.769] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:42.769] result() for ClusterFuture ... done
[13:36:42.769] result() for ClusterFuture ...
[13:36:42.770] - result already collected: FutureResult
[13:36:42.770] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[13:36:42.772] getGlobalsAndPackages() ...
[13:36:42.772] Searching for globals...
[13:36:42.774] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[13:36:42.774] Searching for globals ... DONE
[13:36:42.774] Resolving globals: FALSE
[13:36:42.774] 
[13:36:42.775] - packages: [2] ‘stats’, ‘datasets’
[13:36:42.775] getGlobalsAndPackages() ... DONE
[13:36:42.775] run() for ‘Future’ ...
[13:36:42.775] - state: ‘created’
[13:36:42.775] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:42.789] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:42.789] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:42.790]   - Field: ‘node’
[13:36:42.790]   - Field: ‘label’
[13:36:42.790]   - Field: ‘local’
[13:36:42.790]   - Field: ‘owner’
[13:36:42.790]   - Field: ‘envir’
[13:36:42.790]   - Field: ‘workers’
[13:36:42.790]   - Field: ‘packages’
[13:36:42.790]   - Field: ‘gc’
[13:36:42.790]   - Field: ‘conditions’
[13:36:42.790]   - Field: ‘persistent’
[13:36:42.791]   - Field: ‘expr’
[13:36:42.791]   - Field: ‘uuid’
[13:36:42.791]   - Field: ‘seed’
[13:36:42.791]   - Field: ‘version’
[13:36:42.791]   - Field: ‘result’
[13:36:42.791]   - Field: ‘asynchronous’
[13:36:42.791]   - Field: ‘calls’
[13:36:42.791]   - Field: ‘globals’
[13:36:42.791]   - Field: ‘stdout’
[13:36:42.791]   - Field: ‘earlySignal’
[13:36:42.791]   - Field: ‘lazy’
[13:36:42.792]   - Field: ‘state’
[13:36:42.792] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:42.792] - Launch lazy future ...
[13:36:42.792] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:36:42.792] Packages needed by future strategies (n = 0): <none>
[13:36:42.793] {
[13:36:42.793]     {
[13:36:42.793]         {
[13:36:42.793]             ...future.startTime <- base::Sys.time()
[13:36:42.793]             {
[13:36:42.793]                 {
[13:36:42.793]                   {
[13:36:42.793]                     {
[13:36:42.793]                       {
[13:36:42.793]                         base::local({
[13:36:42.793]                           has_future <- base::requireNamespace("future", 
[13:36:42.793]                             quietly = TRUE)
[13:36:42.793]                           if (has_future) {
[13:36:42.793]                             ns <- base::getNamespace("future")
[13:36:42.793]                             version <- ns[[".package"]][["version"]]
[13:36:42.793]                             if (is.null(version)) 
[13:36:42.793]                               version <- utils::packageVersion("future")
[13:36:42.793]                           }
[13:36:42.793]                           else {
[13:36:42.793]                             version <- NULL
[13:36:42.793]                           }
[13:36:42.793]                           if (!has_future || version < "1.8.0") {
[13:36:42.793]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:42.793]                               "", base::R.version$version.string), 
[13:36:42.793]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:42.793]                                 base::R.version$platform, 8 * 
[13:36:42.793]                                   base::.Machine$sizeof.pointer), 
[13:36:42.793]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:42.793]                                 "release", "version")], collapse = " "), 
[13:36:42.793]                               hostname = base::Sys.info()[["nodename"]])
[13:36:42.793]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:42.793]                               info)
[13:36:42.793]                             info <- base::paste(info, collapse = "; ")
[13:36:42.793]                             if (!has_future) {
[13:36:42.793]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:42.793]                                 info)
[13:36:42.793]                             }
[13:36:42.793]                             else {
[13:36:42.793]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:42.793]                                 info, version)
[13:36:42.793]                             }
[13:36:42.793]                             base::stop(msg)
[13:36:42.793]                           }
[13:36:42.793]                         })
[13:36:42.793]                       }
[13:36:42.793]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:42.793]                       base::options(mc.cores = 1L)
[13:36:42.793]                     }
[13:36:42.793]                     base::local({
[13:36:42.793]                       for (pkg in c("stats", "datasets")) {
[13:36:42.793]                         base::loadNamespace(pkg)
[13:36:42.793]                         base::library(pkg, character.only = TRUE)
[13:36:42.793]                       }
[13:36:42.793]                     })
[13:36:42.793]                   }
[13:36:42.793]                   ...future.strategy.old <- future::plan("list")
[13:36:42.793]                   options(future.plan = NULL)
[13:36:42.793]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.793]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:42.793]                 }
[13:36:42.793]                 ...future.workdir <- getwd()
[13:36:42.793]             }
[13:36:42.793]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:42.793]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:42.793]         }
[13:36:42.793]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:42.793]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:42.793]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:42.793]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:42.793]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:42.793]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:42.793]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:42.793]             base::names(...future.oldOptions))
[13:36:42.793]     }
[13:36:42.793]     if (FALSE) {
[13:36:42.793]     }
[13:36:42.793]     else {
[13:36:42.793]         if (TRUE) {
[13:36:42.793]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:42.793]                 open = "w")
[13:36:42.793]         }
[13:36:42.793]         else {
[13:36:42.793]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:42.793]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:42.793]         }
[13:36:42.793]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:42.793]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:42.793]             base::sink(type = "output", split = FALSE)
[13:36:42.793]             base::close(...future.stdout)
[13:36:42.793]         }, add = TRUE)
[13:36:42.793]     }
[13:36:42.793]     ...future.frame <- base::sys.nframe()
[13:36:42.793]     ...future.conditions <- base::list()
[13:36:42.793]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:42.793]     if (FALSE) {
[13:36:42.793]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:42.793]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:42.793]     }
[13:36:42.793]     ...future.result <- base::tryCatch({
[13:36:42.793]         base::withCallingHandlers({
[13:36:42.793]             ...future.value <- base::withVisible(base::local({
[13:36:42.793]                 ...future.makeSendCondition <- base::local({
[13:36:42.793]                   sendCondition <- NULL
[13:36:42.793]                   function(frame = 1L) {
[13:36:42.793]                     if (is.function(sendCondition)) 
[13:36:42.793]                       return(sendCondition)
[13:36:42.793]                     ns <- getNamespace("parallel")
[13:36:42.793]                     if (exists("sendData", mode = "function", 
[13:36:42.793]                       envir = ns)) {
[13:36:42.793]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:42.793]                         envir = ns)
[13:36:42.793]                       envir <- sys.frame(frame)
[13:36:42.793]                       master <- NULL
[13:36:42.793]                       while (!identical(envir, .GlobalEnv) && 
[13:36:42.793]                         !identical(envir, emptyenv())) {
[13:36:42.793]                         if (exists("master", mode = "list", envir = envir, 
[13:36:42.793]                           inherits = FALSE)) {
[13:36:42.793]                           master <- get("master", mode = "list", 
[13:36:42.793]                             envir = envir, inherits = FALSE)
[13:36:42.793]                           if (inherits(master, c("SOCKnode", 
[13:36:42.793]                             "SOCK0node"))) {
[13:36:42.793]                             sendCondition <<- function(cond) {
[13:36:42.793]                               data <- list(type = "VALUE", value = cond, 
[13:36:42.793]                                 success = TRUE)
[13:36:42.793]                               parallel_sendData(master, data)
[13:36:42.793]                             }
[13:36:42.793]                             return(sendCondition)
[13:36:42.793]                           }
[13:36:42.793]                         }
[13:36:42.793]                         frame <- frame + 1L
[13:36:42.793]                         envir <- sys.frame(frame)
[13:36:42.793]                       }
[13:36:42.793]                     }
[13:36:42.793]                     sendCondition <<- function(cond) NULL
[13:36:42.793]                   }
[13:36:42.793]                 })
[13:36:42.793]                 withCallingHandlers({
[13:36:42.793]                   {
[13:36:42.793]                     lm(dist ~ speed + speed^2, data = cars)
[13:36:42.793]                   }
[13:36:42.793]                 }, immediateCondition = function(cond) {
[13:36:42.793]                   sendCondition <- ...future.makeSendCondition()
[13:36:42.793]                   sendCondition(cond)
[13:36:42.793]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.793]                   {
[13:36:42.793]                     inherits <- base::inherits
[13:36:42.793]                     invokeRestart <- base::invokeRestart
[13:36:42.793]                     is.null <- base::is.null
[13:36:42.793]                     muffled <- FALSE
[13:36:42.793]                     if (inherits(cond, "message")) {
[13:36:42.793]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:42.793]                       if (muffled) 
[13:36:42.793]                         invokeRestart("muffleMessage")
[13:36:42.793]                     }
[13:36:42.793]                     else if (inherits(cond, "warning")) {
[13:36:42.793]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:42.793]                       if (muffled) 
[13:36:42.793]                         invokeRestart("muffleWarning")
[13:36:42.793]                     }
[13:36:42.793]                     else if (inherits(cond, "condition")) {
[13:36:42.793]                       if (!is.null(pattern)) {
[13:36:42.793]                         computeRestarts <- base::computeRestarts
[13:36:42.793]                         grepl <- base::grepl
[13:36:42.793]                         restarts <- computeRestarts(cond)
[13:36:42.793]                         for (restart in restarts) {
[13:36:42.793]                           name <- restart$name
[13:36:42.793]                           if (is.null(name)) 
[13:36:42.793]                             next
[13:36:42.793]                           if (!grepl(pattern, name)) 
[13:36:42.793]                             next
[13:36:42.793]                           invokeRestart(restart)
[13:36:42.793]                           muffled <- TRUE
[13:36:42.793]                           break
[13:36:42.793]                         }
[13:36:42.793]                       }
[13:36:42.793]                     }
[13:36:42.793]                     invisible(muffled)
[13:36:42.793]                   }
[13:36:42.793]                   muffleCondition(cond)
[13:36:42.793]                 })
[13:36:42.793]             }))
[13:36:42.793]             future::FutureResult(value = ...future.value$value, 
[13:36:42.793]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.793]                   ...future.rng), globalenv = if (FALSE) 
[13:36:42.793]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:42.793]                     ...future.globalenv.names))
[13:36:42.793]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:42.793]         }, condition = base::local({
[13:36:42.793]             c <- base::c
[13:36:42.793]             inherits <- base::inherits
[13:36:42.793]             invokeRestart <- base::invokeRestart
[13:36:42.793]             length <- base::length
[13:36:42.793]             list <- base::list
[13:36:42.793]             seq.int <- base::seq.int
[13:36:42.793]             signalCondition <- base::signalCondition
[13:36:42.793]             sys.calls <- base::sys.calls
[13:36:42.793]             `[[` <- base::`[[`
[13:36:42.793]             `+` <- base::`+`
[13:36:42.793]             `<<-` <- base::`<<-`
[13:36:42.793]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:42.793]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:42.793]                   3L)]
[13:36:42.793]             }
[13:36:42.793]             function(cond) {
[13:36:42.793]                 is_error <- inherits(cond, "error")
[13:36:42.793]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:42.793]                   NULL)
[13:36:42.793]                 if (is_error) {
[13:36:42.793]                   sessionInformation <- function() {
[13:36:42.793]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:42.793]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:42.793]                       search = base::search(), system = base::Sys.info())
[13:36:42.793]                   }
[13:36:42.793]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.793]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:42.793]                     cond$call), session = sessionInformation(), 
[13:36:42.793]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:42.793]                   signalCondition(cond)
[13:36:42.793]                 }
[13:36:42.793]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:42.793]                 "immediateCondition"))) {
[13:36:42.793]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:42.793]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.793]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:42.793]                   if (TRUE && !signal) {
[13:36:42.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.793]                     {
[13:36:42.793]                       inherits <- base::inherits
[13:36:42.793]                       invokeRestart <- base::invokeRestart
[13:36:42.793]                       is.null <- base::is.null
[13:36:42.793]                       muffled <- FALSE
[13:36:42.793]                       if (inherits(cond, "message")) {
[13:36:42.793]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.793]                         if (muffled) 
[13:36:42.793]                           invokeRestart("muffleMessage")
[13:36:42.793]                       }
[13:36:42.793]                       else if (inherits(cond, "warning")) {
[13:36:42.793]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.793]                         if (muffled) 
[13:36:42.793]                           invokeRestart("muffleWarning")
[13:36:42.793]                       }
[13:36:42.793]                       else if (inherits(cond, "condition")) {
[13:36:42.793]                         if (!is.null(pattern)) {
[13:36:42.793]                           computeRestarts <- base::computeRestarts
[13:36:42.793]                           grepl <- base::grepl
[13:36:42.793]                           restarts <- computeRestarts(cond)
[13:36:42.793]                           for (restart in restarts) {
[13:36:42.793]                             name <- restart$name
[13:36:42.793]                             if (is.null(name)) 
[13:36:42.793]                               next
[13:36:42.793]                             if (!grepl(pattern, name)) 
[13:36:42.793]                               next
[13:36:42.793]                             invokeRestart(restart)
[13:36:42.793]                             muffled <- TRUE
[13:36:42.793]                             break
[13:36:42.793]                           }
[13:36:42.793]                         }
[13:36:42.793]                       }
[13:36:42.793]                       invisible(muffled)
[13:36:42.793]                     }
[13:36:42.793]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.793]                   }
[13:36:42.793]                 }
[13:36:42.793]                 else {
[13:36:42.793]                   if (TRUE) {
[13:36:42.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.793]                     {
[13:36:42.793]                       inherits <- base::inherits
[13:36:42.793]                       invokeRestart <- base::invokeRestart
[13:36:42.793]                       is.null <- base::is.null
[13:36:42.793]                       muffled <- FALSE
[13:36:42.793]                       if (inherits(cond, "message")) {
[13:36:42.793]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.793]                         if (muffled) 
[13:36:42.793]                           invokeRestart("muffleMessage")
[13:36:42.793]                       }
[13:36:42.793]                       else if (inherits(cond, "warning")) {
[13:36:42.793]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.793]                         if (muffled) 
[13:36:42.793]                           invokeRestart("muffleWarning")
[13:36:42.793]                       }
[13:36:42.793]                       else if (inherits(cond, "condition")) {
[13:36:42.793]                         if (!is.null(pattern)) {
[13:36:42.793]                           computeRestarts <- base::computeRestarts
[13:36:42.793]                           grepl <- base::grepl
[13:36:42.793]                           restarts <- computeRestarts(cond)
[13:36:42.793]                           for (restart in restarts) {
[13:36:42.793]                             name <- restart$name
[13:36:42.793]                             if (is.null(name)) 
[13:36:42.793]                               next
[13:36:42.793]                             if (!grepl(pattern, name)) 
[13:36:42.793]                               next
[13:36:42.793]                             invokeRestart(restart)
[13:36:42.793]                             muffled <- TRUE
[13:36:42.793]                             break
[13:36:42.793]                           }
[13:36:42.793]                         }
[13:36:42.793]                       }
[13:36:42.793]                       invisible(muffled)
[13:36:42.793]                     }
[13:36:42.793]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.793]                   }
[13:36:42.793]                 }
[13:36:42.793]             }
[13:36:42.793]         }))
[13:36:42.793]     }, error = function(ex) {
[13:36:42.793]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:42.793]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.793]                 ...future.rng), started = ...future.startTime, 
[13:36:42.793]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:42.793]             version = "1.8"), class = "FutureResult")
[13:36:42.793]     }, finally = {
[13:36:42.793]         if (!identical(...future.workdir, getwd())) 
[13:36:42.793]             setwd(...future.workdir)
[13:36:42.793]         {
[13:36:42.793]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:42.793]                 ...future.oldOptions$nwarnings <- NULL
[13:36:42.793]             }
[13:36:42.793]             base::options(...future.oldOptions)
[13:36:42.793]             if (.Platform$OS.type == "windows") {
[13:36:42.793]                 old_names <- names(...future.oldEnvVars)
[13:36:42.793]                 envs <- base::Sys.getenv()
[13:36:42.793]                 names <- names(envs)
[13:36:42.793]                 common <- intersect(names, old_names)
[13:36:42.793]                 added <- setdiff(names, old_names)
[13:36:42.793]                 removed <- setdiff(old_names, names)
[13:36:42.793]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:42.793]                   envs[common]]
[13:36:42.793]                 NAMES <- toupper(changed)
[13:36:42.793]                 args <- list()
[13:36:42.793]                 for (kk in seq_along(NAMES)) {
[13:36:42.793]                   name <- changed[[kk]]
[13:36:42.793]                   NAME <- NAMES[[kk]]
[13:36:42.793]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.793]                     next
[13:36:42.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.793]                 }
[13:36:42.793]                 NAMES <- toupper(added)
[13:36:42.793]                 for (kk in seq_along(NAMES)) {
[13:36:42.793]                   name <- added[[kk]]
[13:36:42.793]                   NAME <- NAMES[[kk]]
[13:36:42.793]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.793]                     next
[13:36:42.793]                   args[[name]] <- ""
[13:36:42.793]                 }
[13:36:42.793]                 NAMES <- toupper(removed)
[13:36:42.793]                 for (kk in seq_along(NAMES)) {
[13:36:42.793]                   name <- removed[[kk]]
[13:36:42.793]                   NAME <- NAMES[[kk]]
[13:36:42.793]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.793]                     next
[13:36:42.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.793]                 }
[13:36:42.793]                 if (length(args) > 0) 
[13:36:42.793]                   base::do.call(base::Sys.setenv, args = args)
[13:36:42.793]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:42.793]             }
[13:36:42.793]             else {
[13:36:42.793]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:42.793]             }
[13:36:42.793]             {
[13:36:42.793]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:42.793]                   0L) {
[13:36:42.793]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:42.793]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:42.793]                   base::options(opts)
[13:36:42.793]                 }
[13:36:42.793]                 {
[13:36:42.793]                   {
[13:36:42.793]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:42.793]                     NULL
[13:36:42.793]                   }
[13:36:42.793]                   options(future.plan = NULL)
[13:36:42.793]                   if (is.na(NA_character_)) 
[13:36:42.793]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.793]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:42.793]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:42.793]                     .init = FALSE)
[13:36:42.793]                 }
[13:36:42.793]             }
[13:36:42.793]         }
[13:36:42.793]     })
[13:36:42.793]     if (TRUE) {
[13:36:42.793]         base::sink(type = "output", split = FALSE)
[13:36:42.793]         if (TRUE) {
[13:36:42.793]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:42.793]         }
[13:36:42.793]         else {
[13:36:42.793]             ...future.result["stdout"] <- base::list(NULL)
[13:36:42.793]         }
[13:36:42.793]         base::close(...future.stdout)
[13:36:42.793]         ...future.stdout <- NULL
[13:36:42.793]     }
[13:36:42.793]     ...future.result$conditions <- ...future.conditions
[13:36:42.793]     ...future.result$finished <- base::Sys.time()
[13:36:42.793]     ...future.result
[13:36:42.793] }
[13:36:42.795] MultisessionFuture started
[13:36:42.796] - Launch lazy future ... done
[13:36:42.796] run() for ‘MultisessionFuture’ ... done
[13:36:42.796] result() for ClusterFuture ...
[13:36:42.796] receiveMessageFromWorker() for ClusterFuture ...
[13:36:42.796] - Validating connection of MultisessionFuture
[13:36:42.798] - received message: FutureResult
[13:36:42.798] - Received FutureResult
[13:36:42.798] - Erased future from FutureRegistry
[13:36:42.798] result() for ClusterFuture ...
[13:36:42.798] - result already collected: FutureResult
[13:36:42.798] result() for ClusterFuture ... done
[13:36:42.798] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:42.798] result() for ClusterFuture ... done
[13:36:42.799] result() for ClusterFuture ...
[13:36:42.799] - result already collected: FutureResult
[13:36:42.799] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[13:36:42.801] getGlobalsAndPackages() ...
[13:36:42.801] Searching for globals...
[13:36:42.803] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[13:36:42.803] Searching for globals ... DONE
[13:36:42.803] Resolving globals: FALSE
[13:36:42.804] 
[13:36:42.804] - packages: [2] ‘stats’, ‘datasets’
[13:36:42.804] getGlobalsAndPackages() ... DONE
[13:36:42.804] run() for ‘Future’ ...
[13:36:42.804] - state: ‘created’
[13:36:42.805] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:42.818] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:42.818] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:42.818]   - Field: ‘node’
[13:36:42.818]   - Field: ‘label’
[13:36:42.819]   - Field: ‘local’
[13:36:42.819]   - Field: ‘owner’
[13:36:42.819]   - Field: ‘envir’
[13:36:42.819]   - Field: ‘workers’
[13:36:42.819]   - Field: ‘packages’
[13:36:42.819]   - Field: ‘gc’
[13:36:42.819]   - Field: ‘conditions’
[13:36:42.819]   - Field: ‘persistent’
[13:36:42.819]   - Field: ‘expr’
[13:36:42.819]   - Field: ‘uuid’
[13:36:42.819]   - Field: ‘seed’
[13:36:42.820]   - Field: ‘version’
[13:36:42.820]   - Field: ‘result’
[13:36:42.820]   - Field: ‘asynchronous’
[13:36:42.820]   - Field: ‘calls’
[13:36:42.820]   - Field: ‘globals’
[13:36:42.820]   - Field: ‘stdout’
[13:36:42.820]   - Field: ‘earlySignal’
[13:36:42.820]   - Field: ‘lazy’
[13:36:42.820]   - Field: ‘state’
[13:36:42.820] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:42.820] - Launch lazy future ...
[13:36:42.821] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:36:42.821] Packages needed by future strategies (n = 0): <none>
[13:36:42.821] {
[13:36:42.821]     {
[13:36:42.821]         {
[13:36:42.821]             ...future.startTime <- base::Sys.time()
[13:36:42.821]             {
[13:36:42.821]                 {
[13:36:42.821]                   {
[13:36:42.821]                     {
[13:36:42.821]                       {
[13:36:42.821]                         base::local({
[13:36:42.821]                           has_future <- base::requireNamespace("future", 
[13:36:42.821]                             quietly = TRUE)
[13:36:42.821]                           if (has_future) {
[13:36:42.821]                             ns <- base::getNamespace("future")
[13:36:42.821]                             version <- ns[[".package"]][["version"]]
[13:36:42.821]                             if (is.null(version)) 
[13:36:42.821]                               version <- utils::packageVersion("future")
[13:36:42.821]                           }
[13:36:42.821]                           else {
[13:36:42.821]                             version <- NULL
[13:36:42.821]                           }
[13:36:42.821]                           if (!has_future || version < "1.8.0") {
[13:36:42.821]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:42.821]                               "", base::R.version$version.string), 
[13:36:42.821]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:42.821]                                 base::R.version$platform, 8 * 
[13:36:42.821]                                   base::.Machine$sizeof.pointer), 
[13:36:42.821]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:42.821]                                 "release", "version")], collapse = " "), 
[13:36:42.821]                               hostname = base::Sys.info()[["nodename"]])
[13:36:42.821]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:42.821]                               info)
[13:36:42.821]                             info <- base::paste(info, collapse = "; ")
[13:36:42.821]                             if (!has_future) {
[13:36:42.821]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:42.821]                                 info)
[13:36:42.821]                             }
[13:36:42.821]                             else {
[13:36:42.821]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:42.821]                                 info, version)
[13:36:42.821]                             }
[13:36:42.821]                             base::stop(msg)
[13:36:42.821]                           }
[13:36:42.821]                         })
[13:36:42.821]                       }
[13:36:42.821]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:42.821]                       base::options(mc.cores = 1L)
[13:36:42.821]                     }
[13:36:42.821]                     base::local({
[13:36:42.821]                       for (pkg in c("stats", "datasets")) {
[13:36:42.821]                         base::loadNamespace(pkg)
[13:36:42.821]                         base::library(pkg, character.only = TRUE)
[13:36:42.821]                       }
[13:36:42.821]                     })
[13:36:42.821]                   }
[13:36:42.821]                   ...future.strategy.old <- future::plan("list")
[13:36:42.821]                   options(future.plan = NULL)
[13:36:42.821]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.821]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:42.821]                 }
[13:36:42.821]                 ...future.workdir <- getwd()
[13:36:42.821]             }
[13:36:42.821]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:42.821]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:42.821]         }
[13:36:42.821]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:42.821]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:42.821]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:42.821]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:42.821]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:42.821]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:42.821]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:42.821]             base::names(...future.oldOptions))
[13:36:42.821]     }
[13:36:42.821]     if (FALSE) {
[13:36:42.821]     }
[13:36:42.821]     else {
[13:36:42.821]         if (TRUE) {
[13:36:42.821]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:42.821]                 open = "w")
[13:36:42.821]         }
[13:36:42.821]         else {
[13:36:42.821]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:42.821]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:42.821]         }
[13:36:42.821]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:42.821]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:42.821]             base::sink(type = "output", split = FALSE)
[13:36:42.821]             base::close(...future.stdout)
[13:36:42.821]         }, add = TRUE)
[13:36:42.821]     }
[13:36:42.821]     ...future.frame <- base::sys.nframe()
[13:36:42.821]     ...future.conditions <- base::list()
[13:36:42.821]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:42.821]     if (FALSE) {
[13:36:42.821]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:42.821]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:42.821]     }
[13:36:42.821]     ...future.result <- base::tryCatch({
[13:36:42.821]         base::withCallingHandlers({
[13:36:42.821]             ...future.value <- base::withVisible(base::local({
[13:36:42.821]                 ...future.makeSendCondition <- base::local({
[13:36:42.821]                   sendCondition <- NULL
[13:36:42.821]                   function(frame = 1L) {
[13:36:42.821]                     if (is.function(sendCondition)) 
[13:36:42.821]                       return(sendCondition)
[13:36:42.821]                     ns <- getNamespace("parallel")
[13:36:42.821]                     if (exists("sendData", mode = "function", 
[13:36:42.821]                       envir = ns)) {
[13:36:42.821]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:42.821]                         envir = ns)
[13:36:42.821]                       envir <- sys.frame(frame)
[13:36:42.821]                       master <- NULL
[13:36:42.821]                       while (!identical(envir, .GlobalEnv) && 
[13:36:42.821]                         !identical(envir, emptyenv())) {
[13:36:42.821]                         if (exists("master", mode = "list", envir = envir, 
[13:36:42.821]                           inherits = FALSE)) {
[13:36:42.821]                           master <- get("master", mode = "list", 
[13:36:42.821]                             envir = envir, inherits = FALSE)
[13:36:42.821]                           if (inherits(master, c("SOCKnode", 
[13:36:42.821]                             "SOCK0node"))) {
[13:36:42.821]                             sendCondition <<- function(cond) {
[13:36:42.821]                               data <- list(type = "VALUE", value = cond, 
[13:36:42.821]                                 success = TRUE)
[13:36:42.821]                               parallel_sendData(master, data)
[13:36:42.821]                             }
[13:36:42.821]                             return(sendCondition)
[13:36:42.821]                           }
[13:36:42.821]                         }
[13:36:42.821]                         frame <- frame + 1L
[13:36:42.821]                         envir <- sys.frame(frame)
[13:36:42.821]                       }
[13:36:42.821]                     }
[13:36:42.821]                     sendCondition <<- function(cond) NULL
[13:36:42.821]                   }
[13:36:42.821]                 })
[13:36:42.821]                 withCallingHandlers({
[13:36:42.821]                   {
[13:36:42.821]                     lm(dist ~ speed + I(speed^2), data = cars)
[13:36:42.821]                   }
[13:36:42.821]                 }, immediateCondition = function(cond) {
[13:36:42.821]                   sendCondition <- ...future.makeSendCondition()
[13:36:42.821]                   sendCondition(cond)
[13:36:42.821]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.821]                   {
[13:36:42.821]                     inherits <- base::inherits
[13:36:42.821]                     invokeRestart <- base::invokeRestart
[13:36:42.821]                     is.null <- base::is.null
[13:36:42.821]                     muffled <- FALSE
[13:36:42.821]                     if (inherits(cond, "message")) {
[13:36:42.821]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:42.821]                       if (muffled) 
[13:36:42.821]                         invokeRestart("muffleMessage")
[13:36:42.821]                     }
[13:36:42.821]                     else if (inherits(cond, "warning")) {
[13:36:42.821]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:42.821]                       if (muffled) 
[13:36:42.821]                         invokeRestart("muffleWarning")
[13:36:42.821]                     }
[13:36:42.821]                     else if (inherits(cond, "condition")) {
[13:36:42.821]                       if (!is.null(pattern)) {
[13:36:42.821]                         computeRestarts <- base::computeRestarts
[13:36:42.821]                         grepl <- base::grepl
[13:36:42.821]                         restarts <- computeRestarts(cond)
[13:36:42.821]                         for (restart in restarts) {
[13:36:42.821]                           name <- restart$name
[13:36:42.821]                           if (is.null(name)) 
[13:36:42.821]                             next
[13:36:42.821]                           if (!grepl(pattern, name)) 
[13:36:42.821]                             next
[13:36:42.821]                           invokeRestart(restart)
[13:36:42.821]                           muffled <- TRUE
[13:36:42.821]                           break
[13:36:42.821]                         }
[13:36:42.821]                       }
[13:36:42.821]                     }
[13:36:42.821]                     invisible(muffled)
[13:36:42.821]                   }
[13:36:42.821]                   muffleCondition(cond)
[13:36:42.821]                 })
[13:36:42.821]             }))
[13:36:42.821]             future::FutureResult(value = ...future.value$value, 
[13:36:42.821]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.821]                   ...future.rng), globalenv = if (FALSE) 
[13:36:42.821]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:42.821]                     ...future.globalenv.names))
[13:36:42.821]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:42.821]         }, condition = base::local({
[13:36:42.821]             c <- base::c
[13:36:42.821]             inherits <- base::inherits
[13:36:42.821]             invokeRestart <- base::invokeRestart
[13:36:42.821]             length <- base::length
[13:36:42.821]             list <- base::list
[13:36:42.821]             seq.int <- base::seq.int
[13:36:42.821]             signalCondition <- base::signalCondition
[13:36:42.821]             sys.calls <- base::sys.calls
[13:36:42.821]             `[[` <- base::`[[`
[13:36:42.821]             `+` <- base::`+`
[13:36:42.821]             `<<-` <- base::`<<-`
[13:36:42.821]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:42.821]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:42.821]                   3L)]
[13:36:42.821]             }
[13:36:42.821]             function(cond) {
[13:36:42.821]                 is_error <- inherits(cond, "error")
[13:36:42.821]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:42.821]                   NULL)
[13:36:42.821]                 if (is_error) {
[13:36:42.821]                   sessionInformation <- function() {
[13:36:42.821]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:42.821]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:42.821]                       search = base::search(), system = base::Sys.info())
[13:36:42.821]                   }
[13:36:42.821]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.821]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:42.821]                     cond$call), session = sessionInformation(), 
[13:36:42.821]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:42.821]                   signalCondition(cond)
[13:36:42.821]                 }
[13:36:42.821]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:42.821]                 "immediateCondition"))) {
[13:36:42.821]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:42.821]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.821]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:42.821]                   if (TRUE && !signal) {
[13:36:42.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.821]                     {
[13:36:42.821]                       inherits <- base::inherits
[13:36:42.821]                       invokeRestart <- base::invokeRestart
[13:36:42.821]                       is.null <- base::is.null
[13:36:42.821]                       muffled <- FALSE
[13:36:42.821]                       if (inherits(cond, "message")) {
[13:36:42.821]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.821]                         if (muffled) 
[13:36:42.821]                           invokeRestart("muffleMessage")
[13:36:42.821]                       }
[13:36:42.821]                       else if (inherits(cond, "warning")) {
[13:36:42.821]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.821]                         if (muffled) 
[13:36:42.821]                           invokeRestart("muffleWarning")
[13:36:42.821]                       }
[13:36:42.821]                       else if (inherits(cond, "condition")) {
[13:36:42.821]                         if (!is.null(pattern)) {
[13:36:42.821]                           computeRestarts <- base::computeRestarts
[13:36:42.821]                           grepl <- base::grepl
[13:36:42.821]                           restarts <- computeRestarts(cond)
[13:36:42.821]                           for (restart in restarts) {
[13:36:42.821]                             name <- restart$name
[13:36:42.821]                             if (is.null(name)) 
[13:36:42.821]                               next
[13:36:42.821]                             if (!grepl(pattern, name)) 
[13:36:42.821]                               next
[13:36:42.821]                             invokeRestart(restart)
[13:36:42.821]                             muffled <- TRUE
[13:36:42.821]                             break
[13:36:42.821]                           }
[13:36:42.821]                         }
[13:36:42.821]                       }
[13:36:42.821]                       invisible(muffled)
[13:36:42.821]                     }
[13:36:42.821]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.821]                   }
[13:36:42.821]                 }
[13:36:42.821]                 else {
[13:36:42.821]                   if (TRUE) {
[13:36:42.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.821]                     {
[13:36:42.821]                       inherits <- base::inherits
[13:36:42.821]                       invokeRestart <- base::invokeRestart
[13:36:42.821]                       is.null <- base::is.null
[13:36:42.821]                       muffled <- FALSE
[13:36:42.821]                       if (inherits(cond, "message")) {
[13:36:42.821]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.821]                         if (muffled) 
[13:36:42.821]                           invokeRestart("muffleMessage")
[13:36:42.821]                       }
[13:36:42.821]                       else if (inherits(cond, "warning")) {
[13:36:42.821]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.821]                         if (muffled) 
[13:36:42.821]                           invokeRestart("muffleWarning")
[13:36:42.821]                       }
[13:36:42.821]                       else if (inherits(cond, "condition")) {
[13:36:42.821]                         if (!is.null(pattern)) {
[13:36:42.821]                           computeRestarts <- base::computeRestarts
[13:36:42.821]                           grepl <- base::grepl
[13:36:42.821]                           restarts <- computeRestarts(cond)
[13:36:42.821]                           for (restart in restarts) {
[13:36:42.821]                             name <- restart$name
[13:36:42.821]                             if (is.null(name)) 
[13:36:42.821]                               next
[13:36:42.821]                             if (!grepl(pattern, name)) 
[13:36:42.821]                               next
[13:36:42.821]                             invokeRestart(restart)
[13:36:42.821]                             muffled <- TRUE
[13:36:42.821]                             break
[13:36:42.821]                           }
[13:36:42.821]                         }
[13:36:42.821]                       }
[13:36:42.821]                       invisible(muffled)
[13:36:42.821]                     }
[13:36:42.821]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.821]                   }
[13:36:42.821]                 }
[13:36:42.821]             }
[13:36:42.821]         }))
[13:36:42.821]     }, error = function(ex) {
[13:36:42.821]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:42.821]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.821]                 ...future.rng), started = ...future.startTime, 
[13:36:42.821]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:42.821]             version = "1.8"), class = "FutureResult")
[13:36:42.821]     }, finally = {
[13:36:42.821]         if (!identical(...future.workdir, getwd())) 
[13:36:42.821]             setwd(...future.workdir)
[13:36:42.821]         {
[13:36:42.821]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:42.821]                 ...future.oldOptions$nwarnings <- NULL
[13:36:42.821]             }
[13:36:42.821]             base::options(...future.oldOptions)
[13:36:42.821]             if (.Platform$OS.type == "windows") {
[13:36:42.821]                 old_names <- names(...future.oldEnvVars)
[13:36:42.821]                 envs <- base::Sys.getenv()
[13:36:42.821]                 names <- names(envs)
[13:36:42.821]                 common <- intersect(names, old_names)
[13:36:42.821]                 added <- setdiff(names, old_names)
[13:36:42.821]                 removed <- setdiff(old_names, names)
[13:36:42.821]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:42.821]                   envs[common]]
[13:36:42.821]                 NAMES <- toupper(changed)
[13:36:42.821]                 args <- list()
[13:36:42.821]                 for (kk in seq_along(NAMES)) {
[13:36:42.821]                   name <- changed[[kk]]
[13:36:42.821]                   NAME <- NAMES[[kk]]
[13:36:42.821]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.821]                     next
[13:36:42.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.821]                 }
[13:36:42.821]                 NAMES <- toupper(added)
[13:36:42.821]                 for (kk in seq_along(NAMES)) {
[13:36:42.821]                   name <- added[[kk]]
[13:36:42.821]                   NAME <- NAMES[[kk]]
[13:36:42.821]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.821]                     next
[13:36:42.821]                   args[[name]] <- ""
[13:36:42.821]                 }
[13:36:42.821]                 NAMES <- toupper(removed)
[13:36:42.821]                 for (kk in seq_along(NAMES)) {
[13:36:42.821]                   name <- removed[[kk]]
[13:36:42.821]                   NAME <- NAMES[[kk]]
[13:36:42.821]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.821]                     next
[13:36:42.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.821]                 }
[13:36:42.821]                 if (length(args) > 0) 
[13:36:42.821]                   base::do.call(base::Sys.setenv, args = args)
[13:36:42.821]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:42.821]             }
[13:36:42.821]             else {
[13:36:42.821]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:42.821]             }
[13:36:42.821]             {
[13:36:42.821]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:42.821]                   0L) {
[13:36:42.821]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:42.821]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:42.821]                   base::options(opts)
[13:36:42.821]                 }
[13:36:42.821]                 {
[13:36:42.821]                   {
[13:36:42.821]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:42.821]                     NULL
[13:36:42.821]                   }
[13:36:42.821]                   options(future.plan = NULL)
[13:36:42.821]                   if (is.na(NA_character_)) 
[13:36:42.821]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.821]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:42.821]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:42.821]                     .init = FALSE)
[13:36:42.821]                 }
[13:36:42.821]             }
[13:36:42.821]         }
[13:36:42.821]     })
[13:36:42.821]     if (TRUE) {
[13:36:42.821]         base::sink(type = "output", split = FALSE)
[13:36:42.821]         if (TRUE) {
[13:36:42.821]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:42.821]         }
[13:36:42.821]         else {
[13:36:42.821]             ...future.result["stdout"] <- base::list(NULL)
[13:36:42.821]         }
[13:36:42.821]         base::close(...future.stdout)
[13:36:42.821]         ...future.stdout <- NULL
[13:36:42.821]     }
[13:36:42.821]     ...future.result$conditions <- ...future.conditions
[13:36:42.821]     ...future.result$finished <- base::Sys.time()
[13:36:42.821]     ...future.result
[13:36:42.821] }
[13:36:42.824] MultisessionFuture started
[13:36:42.824] - Launch lazy future ... done
[13:36:42.824] run() for ‘MultisessionFuture’ ... done
[13:36:42.825] result() for ClusterFuture ...
[13:36:42.825] receiveMessageFromWorker() for ClusterFuture ...
[13:36:42.825] - Validating connection of MultisessionFuture
[13:36:42.869] - received message: FutureResult
[13:36:42.869] - Received FutureResult
[13:36:42.869] - Erased future from FutureRegistry
[13:36:42.869] result() for ClusterFuture ...
[13:36:42.869] - result already collected: FutureResult
[13:36:42.869] result() for ClusterFuture ... done
[13:36:42.870] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:42.870] result() for ClusterFuture ... done
[13:36:42.870] result() for ClusterFuture ...
[13:36:42.870] - result already collected: FutureResult
[13:36:42.870] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[13:36:42.872] getGlobalsAndPackages() ...
[13:36:42.873] Searching for globals...
[13:36:42.874] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[13:36:42.874] Searching for globals ... DONE
[13:36:42.874] Resolving globals: FALSE
[13:36:42.875] 
[13:36:42.875] - packages: [2] ‘stats’, ‘datasets’
[13:36:42.875] getGlobalsAndPackages() ... DONE
[13:36:42.875] run() for ‘Future’ ...
[13:36:42.875] - state: ‘created’
[13:36:42.875] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:42.889] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:42.889] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:42.889]   - Field: ‘node’
[13:36:42.889]   - Field: ‘label’
[13:36:42.889]   - Field: ‘local’
[13:36:42.889]   - Field: ‘owner’
[13:36:42.889]   - Field: ‘envir’
[13:36:42.890]   - Field: ‘workers’
[13:36:42.890]   - Field: ‘packages’
[13:36:42.890]   - Field: ‘gc’
[13:36:42.890]   - Field: ‘conditions’
[13:36:42.890]   - Field: ‘persistent’
[13:36:42.890]   - Field: ‘expr’
[13:36:42.890]   - Field: ‘uuid’
[13:36:42.890]   - Field: ‘seed’
[13:36:42.890]   - Field: ‘version’
[13:36:42.890]   - Field: ‘result’
[13:36:42.890]   - Field: ‘asynchronous’
[13:36:42.891]   - Field: ‘calls’
[13:36:42.891]   - Field: ‘globals’
[13:36:42.891]   - Field: ‘stdout’
[13:36:42.891]   - Field: ‘earlySignal’
[13:36:42.891]   - Field: ‘lazy’
[13:36:42.891]   - Field: ‘state’
[13:36:42.891] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:42.891] - Launch lazy future ...
[13:36:42.891] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:36:42.892] Packages needed by future strategies (n = 0): <none>
[13:36:42.892] {
[13:36:42.892]     {
[13:36:42.892]         {
[13:36:42.892]             ...future.startTime <- base::Sys.time()
[13:36:42.892]             {
[13:36:42.892]                 {
[13:36:42.892]                   {
[13:36:42.892]                     {
[13:36:42.892]                       {
[13:36:42.892]                         base::local({
[13:36:42.892]                           has_future <- base::requireNamespace("future", 
[13:36:42.892]                             quietly = TRUE)
[13:36:42.892]                           if (has_future) {
[13:36:42.892]                             ns <- base::getNamespace("future")
[13:36:42.892]                             version <- ns[[".package"]][["version"]]
[13:36:42.892]                             if (is.null(version)) 
[13:36:42.892]                               version <- utils::packageVersion("future")
[13:36:42.892]                           }
[13:36:42.892]                           else {
[13:36:42.892]                             version <- NULL
[13:36:42.892]                           }
[13:36:42.892]                           if (!has_future || version < "1.8.0") {
[13:36:42.892]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:42.892]                               "", base::R.version$version.string), 
[13:36:42.892]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:42.892]                                 base::R.version$platform, 8 * 
[13:36:42.892]                                   base::.Machine$sizeof.pointer), 
[13:36:42.892]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:42.892]                                 "release", "version")], collapse = " "), 
[13:36:42.892]                               hostname = base::Sys.info()[["nodename"]])
[13:36:42.892]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:42.892]                               info)
[13:36:42.892]                             info <- base::paste(info, collapse = "; ")
[13:36:42.892]                             if (!has_future) {
[13:36:42.892]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:42.892]                                 info)
[13:36:42.892]                             }
[13:36:42.892]                             else {
[13:36:42.892]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:42.892]                                 info, version)
[13:36:42.892]                             }
[13:36:42.892]                             base::stop(msg)
[13:36:42.892]                           }
[13:36:42.892]                         })
[13:36:42.892]                       }
[13:36:42.892]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:42.892]                       base::options(mc.cores = 1L)
[13:36:42.892]                     }
[13:36:42.892]                     base::local({
[13:36:42.892]                       for (pkg in c("stats", "datasets")) {
[13:36:42.892]                         base::loadNamespace(pkg)
[13:36:42.892]                         base::library(pkg, character.only = TRUE)
[13:36:42.892]                       }
[13:36:42.892]                     })
[13:36:42.892]                   }
[13:36:42.892]                   ...future.strategy.old <- future::plan("list")
[13:36:42.892]                   options(future.plan = NULL)
[13:36:42.892]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.892]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:42.892]                 }
[13:36:42.892]                 ...future.workdir <- getwd()
[13:36:42.892]             }
[13:36:42.892]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:42.892]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:42.892]         }
[13:36:42.892]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:42.892]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:42.892]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:42.892]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:42.892]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:42.892]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:42.892]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:42.892]             base::names(...future.oldOptions))
[13:36:42.892]     }
[13:36:42.892]     if (FALSE) {
[13:36:42.892]     }
[13:36:42.892]     else {
[13:36:42.892]         if (TRUE) {
[13:36:42.892]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:42.892]                 open = "w")
[13:36:42.892]         }
[13:36:42.892]         else {
[13:36:42.892]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:42.892]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:42.892]         }
[13:36:42.892]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:42.892]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:42.892]             base::sink(type = "output", split = FALSE)
[13:36:42.892]             base::close(...future.stdout)
[13:36:42.892]         }, add = TRUE)
[13:36:42.892]     }
[13:36:42.892]     ...future.frame <- base::sys.nframe()
[13:36:42.892]     ...future.conditions <- base::list()
[13:36:42.892]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:42.892]     if (FALSE) {
[13:36:42.892]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:42.892]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:42.892]     }
[13:36:42.892]     ...future.result <- base::tryCatch({
[13:36:42.892]         base::withCallingHandlers({
[13:36:42.892]             ...future.value <- base::withVisible(base::local({
[13:36:42.892]                 ...future.makeSendCondition <- base::local({
[13:36:42.892]                   sendCondition <- NULL
[13:36:42.892]                   function(frame = 1L) {
[13:36:42.892]                     if (is.function(sendCondition)) 
[13:36:42.892]                       return(sendCondition)
[13:36:42.892]                     ns <- getNamespace("parallel")
[13:36:42.892]                     if (exists("sendData", mode = "function", 
[13:36:42.892]                       envir = ns)) {
[13:36:42.892]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:42.892]                         envir = ns)
[13:36:42.892]                       envir <- sys.frame(frame)
[13:36:42.892]                       master <- NULL
[13:36:42.892]                       while (!identical(envir, .GlobalEnv) && 
[13:36:42.892]                         !identical(envir, emptyenv())) {
[13:36:42.892]                         if (exists("master", mode = "list", envir = envir, 
[13:36:42.892]                           inherits = FALSE)) {
[13:36:42.892]                           master <- get("master", mode = "list", 
[13:36:42.892]                             envir = envir, inherits = FALSE)
[13:36:42.892]                           if (inherits(master, c("SOCKnode", 
[13:36:42.892]                             "SOCK0node"))) {
[13:36:42.892]                             sendCondition <<- function(cond) {
[13:36:42.892]                               data <- list(type = "VALUE", value = cond, 
[13:36:42.892]                                 success = TRUE)
[13:36:42.892]                               parallel_sendData(master, data)
[13:36:42.892]                             }
[13:36:42.892]                             return(sendCondition)
[13:36:42.892]                           }
[13:36:42.892]                         }
[13:36:42.892]                         frame <- frame + 1L
[13:36:42.892]                         envir <- sys.frame(frame)
[13:36:42.892]                       }
[13:36:42.892]                     }
[13:36:42.892]                     sendCondition <<- function(cond) NULL
[13:36:42.892]                   }
[13:36:42.892]                 })
[13:36:42.892]                 withCallingHandlers({
[13:36:42.892]                   {
[13:36:42.892]                     lm(dist ~ poly(speed, 2), data = cars)
[13:36:42.892]                   }
[13:36:42.892]                 }, immediateCondition = function(cond) {
[13:36:42.892]                   sendCondition <- ...future.makeSendCondition()
[13:36:42.892]                   sendCondition(cond)
[13:36:42.892]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.892]                   {
[13:36:42.892]                     inherits <- base::inherits
[13:36:42.892]                     invokeRestart <- base::invokeRestart
[13:36:42.892]                     is.null <- base::is.null
[13:36:42.892]                     muffled <- FALSE
[13:36:42.892]                     if (inherits(cond, "message")) {
[13:36:42.892]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:42.892]                       if (muffled) 
[13:36:42.892]                         invokeRestart("muffleMessage")
[13:36:42.892]                     }
[13:36:42.892]                     else if (inherits(cond, "warning")) {
[13:36:42.892]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:42.892]                       if (muffled) 
[13:36:42.892]                         invokeRestart("muffleWarning")
[13:36:42.892]                     }
[13:36:42.892]                     else if (inherits(cond, "condition")) {
[13:36:42.892]                       if (!is.null(pattern)) {
[13:36:42.892]                         computeRestarts <- base::computeRestarts
[13:36:42.892]                         grepl <- base::grepl
[13:36:42.892]                         restarts <- computeRestarts(cond)
[13:36:42.892]                         for (restart in restarts) {
[13:36:42.892]                           name <- restart$name
[13:36:42.892]                           if (is.null(name)) 
[13:36:42.892]                             next
[13:36:42.892]                           if (!grepl(pattern, name)) 
[13:36:42.892]                             next
[13:36:42.892]                           invokeRestart(restart)
[13:36:42.892]                           muffled <- TRUE
[13:36:42.892]                           break
[13:36:42.892]                         }
[13:36:42.892]                       }
[13:36:42.892]                     }
[13:36:42.892]                     invisible(muffled)
[13:36:42.892]                   }
[13:36:42.892]                   muffleCondition(cond)
[13:36:42.892]                 })
[13:36:42.892]             }))
[13:36:42.892]             future::FutureResult(value = ...future.value$value, 
[13:36:42.892]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.892]                   ...future.rng), globalenv = if (FALSE) 
[13:36:42.892]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:42.892]                     ...future.globalenv.names))
[13:36:42.892]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:42.892]         }, condition = base::local({
[13:36:42.892]             c <- base::c
[13:36:42.892]             inherits <- base::inherits
[13:36:42.892]             invokeRestart <- base::invokeRestart
[13:36:42.892]             length <- base::length
[13:36:42.892]             list <- base::list
[13:36:42.892]             seq.int <- base::seq.int
[13:36:42.892]             signalCondition <- base::signalCondition
[13:36:42.892]             sys.calls <- base::sys.calls
[13:36:42.892]             `[[` <- base::`[[`
[13:36:42.892]             `+` <- base::`+`
[13:36:42.892]             `<<-` <- base::`<<-`
[13:36:42.892]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:42.892]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:42.892]                   3L)]
[13:36:42.892]             }
[13:36:42.892]             function(cond) {
[13:36:42.892]                 is_error <- inherits(cond, "error")
[13:36:42.892]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:42.892]                   NULL)
[13:36:42.892]                 if (is_error) {
[13:36:42.892]                   sessionInformation <- function() {
[13:36:42.892]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:42.892]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:42.892]                       search = base::search(), system = base::Sys.info())
[13:36:42.892]                   }
[13:36:42.892]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.892]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:42.892]                     cond$call), session = sessionInformation(), 
[13:36:42.892]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:42.892]                   signalCondition(cond)
[13:36:42.892]                 }
[13:36:42.892]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:42.892]                 "immediateCondition"))) {
[13:36:42.892]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:42.892]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.892]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:42.892]                   if (TRUE && !signal) {
[13:36:42.892]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.892]                     {
[13:36:42.892]                       inherits <- base::inherits
[13:36:42.892]                       invokeRestart <- base::invokeRestart
[13:36:42.892]                       is.null <- base::is.null
[13:36:42.892]                       muffled <- FALSE
[13:36:42.892]                       if (inherits(cond, "message")) {
[13:36:42.892]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.892]                         if (muffled) 
[13:36:42.892]                           invokeRestart("muffleMessage")
[13:36:42.892]                       }
[13:36:42.892]                       else if (inherits(cond, "warning")) {
[13:36:42.892]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.892]                         if (muffled) 
[13:36:42.892]                           invokeRestart("muffleWarning")
[13:36:42.892]                       }
[13:36:42.892]                       else if (inherits(cond, "condition")) {
[13:36:42.892]                         if (!is.null(pattern)) {
[13:36:42.892]                           computeRestarts <- base::computeRestarts
[13:36:42.892]                           grepl <- base::grepl
[13:36:42.892]                           restarts <- computeRestarts(cond)
[13:36:42.892]                           for (restart in restarts) {
[13:36:42.892]                             name <- restart$name
[13:36:42.892]                             if (is.null(name)) 
[13:36:42.892]                               next
[13:36:42.892]                             if (!grepl(pattern, name)) 
[13:36:42.892]                               next
[13:36:42.892]                             invokeRestart(restart)
[13:36:42.892]                             muffled <- TRUE
[13:36:42.892]                             break
[13:36:42.892]                           }
[13:36:42.892]                         }
[13:36:42.892]                       }
[13:36:42.892]                       invisible(muffled)
[13:36:42.892]                     }
[13:36:42.892]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.892]                   }
[13:36:42.892]                 }
[13:36:42.892]                 else {
[13:36:42.892]                   if (TRUE) {
[13:36:42.892]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.892]                     {
[13:36:42.892]                       inherits <- base::inherits
[13:36:42.892]                       invokeRestart <- base::invokeRestart
[13:36:42.892]                       is.null <- base::is.null
[13:36:42.892]                       muffled <- FALSE
[13:36:42.892]                       if (inherits(cond, "message")) {
[13:36:42.892]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.892]                         if (muffled) 
[13:36:42.892]                           invokeRestart("muffleMessage")
[13:36:42.892]                       }
[13:36:42.892]                       else if (inherits(cond, "warning")) {
[13:36:42.892]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.892]                         if (muffled) 
[13:36:42.892]                           invokeRestart("muffleWarning")
[13:36:42.892]                       }
[13:36:42.892]                       else if (inherits(cond, "condition")) {
[13:36:42.892]                         if (!is.null(pattern)) {
[13:36:42.892]                           computeRestarts <- base::computeRestarts
[13:36:42.892]                           grepl <- base::grepl
[13:36:42.892]                           restarts <- computeRestarts(cond)
[13:36:42.892]                           for (restart in restarts) {
[13:36:42.892]                             name <- restart$name
[13:36:42.892]                             if (is.null(name)) 
[13:36:42.892]                               next
[13:36:42.892]                             if (!grepl(pattern, name)) 
[13:36:42.892]                               next
[13:36:42.892]                             invokeRestart(restart)
[13:36:42.892]                             muffled <- TRUE
[13:36:42.892]                             break
[13:36:42.892]                           }
[13:36:42.892]                         }
[13:36:42.892]                       }
[13:36:42.892]                       invisible(muffled)
[13:36:42.892]                     }
[13:36:42.892]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.892]                   }
[13:36:42.892]                 }
[13:36:42.892]             }
[13:36:42.892]         }))
[13:36:42.892]     }, error = function(ex) {
[13:36:42.892]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:42.892]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.892]                 ...future.rng), started = ...future.startTime, 
[13:36:42.892]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:42.892]             version = "1.8"), class = "FutureResult")
[13:36:42.892]     }, finally = {
[13:36:42.892]         if (!identical(...future.workdir, getwd())) 
[13:36:42.892]             setwd(...future.workdir)
[13:36:42.892]         {
[13:36:42.892]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:42.892]                 ...future.oldOptions$nwarnings <- NULL
[13:36:42.892]             }
[13:36:42.892]             base::options(...future.oldOptions)
[13:36:42.892]             if (.Platform$OS.type == "windows") {
[13:36:42.892]                 old_names <- names(...future.oldEnvVars)
[13:36:42.892]                 envs <- base::Sys.getenv()
[13:36:42.892]                 names <- names(envs)
[13:36:42.892]                 common <- intersect(names, old_names)
[13:36:42.892]                 added <- setdiff(names, old_names)
[13:36:42.892]                 removed <- setdiff(old_names, names)
[13:36:42.892]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:42.892]                   envs[common]]
[13:36:42.892]                 NAMES <- toupper(changed)
[13:36:42.892]                 args <- list()
[13:36:42.892]                 for (kk in seq_along(NAMES)) {
[13:36:42.892]                   name <- changed[[kk]]
[13:36:42.892]                   NAME <- NAMES[[kk]]
[13:36:42.892]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.892]                     next
[13:36:42.892]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.892]                 }
[13:36:42.892]                 NAMES <- toupper(added)
[13:36:42.892]                 for (kk in seq_along(NAMES)) {
[13:36:42.892]                   name <- added[[kk]]
[13:36:42.892]                   NAME <- NAMES[[kk]]
[13:36:42.892]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.892]                     next
[13:36:42.892]                   args[[name]] <- ""
[13:36:42.892]                 }
[13:36:42.892]                 NAMES <- toupper(removed)
[13:36:42.892]                 for (kk in seq_along(NAMES)) {
[13:36:42.892]                   name <- removed[[kk]]
[13:36:42.892]                   NAME <- NAMES[[kk]]
[13:36:42.892]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.892]                     next
[13:36:42.892]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.892]                 }
[13:36:42.892]                 if (length(args) > 0) 
[13:36:42.892]                   base::do.call(base::Sys.setenv, args = args)
[13:36:42.892]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:42.892]             }
[13:36:42.892]             else {
[13:36:42.892]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:42.892]             }
[13:36:42.892]             {
[13:36:42.892]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:42.892]                   0L) {
[13:36:42.892]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:42.892]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:42.892]                   base::options(opts)
[13:36:42.892]                 }
[13:36:42.892]                 {
[13:36:42.892]                   {
[13:36:42.892]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:42.892]                     NULL
[13:36:42.892]                   }
[13:36:42.892]                   options(future.plan = NULL)
[13:36:42.892]                   if (is.na(NA_character_)) 
[13:36:42.892]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.892]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:42.892]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:42.892]                     .init = FALSE)
[13:36:42.892]                 }
[13:36:42.892]             }
[13:36:42.892]         }
[13:36:42.892]     })
[13:36:42.892]     if (TRUE) {
[13:36:42.892]         base::sink(type = "output", split = FALSE)
[13:36:42.892]         if (TRUE) {
[13:36:42.892]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:42.892]         }
[13:36:42.892]         else {
[13:36:42.892]             ...future.result["stdout"] <- base::list(NULL)
[13:36:42.892]         }
[13:36:42.892]         base::close(...future.stdout)
[13:36:42.892]         ...future.stdout <- NULL
[13:36:42.892]     }
[13:36:42.892]     ...future.result$conditions <- ...future.conditions
[13:36:42.892]     ...future.result$finished <- base::Sys.time()
[13:36:42.892]     ...future.result
[13:36:42.892] }
[13:36:42.895] MultisessionFuture started
[13:36:42.895] - Launch lazy future ... done
[13:36:42.895] run() for ‘MultisessionFuture’ ... done
[13:36:42.895] result() for ClusterFuture ...
[13:36:42.895] receiveMessageFromWorker() for ClusterFuture ...
[13:36:42.895] - Validating connection of MultisessionFuture
[13:36:42.941] - received message: FutureResult
[13:36:42.942] - Received FutureResult
[13:36:42.942] - Erased future from FutureRegistry
[13:36:42.942] result() for ClusterFuture ...
[13:36:42.942] - result already collected: FutureResult
[13:36:42.942] result() for ClusterFuture ... done
[13:36:42.942] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:42.942] result() for ClusterFuture ... done
[13:36:42.942] result() for ClusterFuture ...
[13:36:42.942] - result already collected: FutureResult
[13:36:42.942] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[13:36:42.944] getGlobalsAndPackages() ...
[13:36:42.944] Searching for globals...
[13:36:42.948] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[13:36:42.948] Searching for globals ... DONE
[13:36:42.949] Resolving globals: FALSE
[13:36:42.949] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[13:36:42.950] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[13:36:42.950] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[13:36:42.950] 
[13:36:42.950] getGlobalsAndPackages() ... DONE
[13:36:42.950] run() for ‘Future’ ...
[13:36:42.950] - state: ‘created’
[13:36:42.950] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:42.964] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:42.964] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:42.964]   - Field: ‘node’
[13:36:42.964]   - Field: ‘label’
[13:36:42.965]   - Field: ‘local’
[13:36:42.965]   - Field: ‘owner’
[13:36:42.965]   - Field: ‘envir’
[13:36:42.965]   - Field: ‘workers’
[13:36:42.965]   - Field: ‘packages’
[13:36:42.965]   - Field: ‘gc’
[13:36:42.965]   - Field: ‘conditions’
[13:36:42.965]   - Field: ‘persistent’
[13:36:42.965]   - Field: ‘expr’
[13:36:42.965]   - Field: ‘uuid’
[13:36:42.965]   - Field: ‘seed’
[13:36:42.966]   - Field: ‘version’
[13:36:42.968]   - Field: ‘result’
[13:36:42.968]   - Field: ‘asynchronous’
[13:36:42.968]   - Field: ‘calls’
[13:36:42.968]   - Field: ‘globals’
[13:36:42.968]   - Field: ‘stdout’
[13:36:42.969]   - Field: ‘earlySignal’
[13:36:42.969]   - Field: ‘lazy’
[13:36:42.969]   - Field: ‘state’
[13:36:42.969] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:42.969] - Launch lazy future ...
[13:36:42.969] Packages needed by the future expression (n = 0): <none>
[13:36:42.969] Packages needed by future strategies (n = 0): <none>
[13:36:42.970] {
[13:36:42.970]     {
[13:36:42.970]         {
[13:36:42.970]             ...future.startTime <- base::Sys.time()
[13:36:42.970]             {
[13:36:42.970]                 {
[13:36:42.970]                   {
[13:36:42.970]                     {
[13:36:42.970]                       base::local({
[13:36:42.970]                         has_future <- base::requireNamespace("future", 
[13:36:42.970]                           quietly = TRUE)
[13:36:42.970]                         if (has_future) {
[13:36:42.970]                           ns <- base::getNamespace("future")
[13:36:42.970]                           version <- ns[[".package"]][["version"]]
[13:36:42.970]                           if (is.null(version)) 
[13:36:42.970]                             version <- utils::packageVersion("future")
[13:36:42.970]                         }
[13:36:42.970]                         else {
[13:36:42.970]                           version <- NULL
[13:36:42.970]                         }
[13:36:42.970]                         if (!has_future || version < "1.8.0") {
[13:36:42.970]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:42.970]                             "", base::R.version$version.string), 
[13:36:42.970]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:42.970]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:42.970]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:42.970]                               "release", "version")], collapse = " "), 
[13:36:42.970]                             hostname = base::Sys.info()[["nodename"]])
[13:36:42.970]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:42.970]                             info)
[13:36:42.970]                           info <- base::paste(info, collapse = "; ")
[13:36:42.970]                           if (!has_future) {
[13:36:42.970]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:42.970]                               info)
[13:36:42.970]                           }
[13:36:42.970]                           else {
[13:36:42.970]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:42.970]                               info, version)
[13:36:42.970]                           }
[13:36:42.970]                           base::stop(msg)
[13:36:42.970]                         }
[13:36:42.970]                       })
[13:36:42.970]                     }
[13:36:42.970]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:42.970]                     base::options(mc.cores = 1L)
[13:36:42.970]                   }
[13:36:42.970]                   ...future.strategy.old <- future::plan("list")
[13:36:42.970]                   options(future.plan = NULL)
[13:36:42.970]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.970]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:42.970]                 }
[13:36:42.970]                 ...future.workdir <- getwd()
[13:36:42.970]             }
[13:36:42.970]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:42.970]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:42.970]         }
[13:36:42.970]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:42.970]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:42.970]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:42.970]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:42.970]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:42.970]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:42.970]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:42.970]             base::names(...future.oldOptions))
[13:36:42.970]     }
[13:36:42.970]     if (FALSE) {
[13:36:42.970]     }
[13:36:42.970]     else {
[13:36:42.970]         if (TRUE) {
[13:36:42.970]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:42.970]                 open = "w")
[13:36:42.970]         }
[13:36:42.970]         else {
[13:36:42.970]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:42.970]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:42.970]         }
[13:36:42.970]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:42.970]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:42.970]             base::sink(type = "output", split = FALSE)
[13:36:42.970]             base::close(...future.stdout)
[13:36:42.970]         }, add = TRUE)
[13:36:42.970]     }
[13:36:42.970]     ...future.frame <- base::sys.nframe()
[13:36:42.970]     ...future.conditions <- base::list()
[13:36:42.970]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:42.970]     if (FALSE) {
[13:36:42.970]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:42.970]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:42.970]     }
[13:36:42.970]     ...future.result <- base::tryCatch({
[13:36:42.970]         base::withCallingHandlers({
[13:36:42.970]             ...future.value <- base::withVisible(base::local({
[13:36:42.970]                 ...future.makeSendCondition <- base::local({
[13:36:42.970]                   sendCondition <- NULL
[13:36:42.970]                   function(frame = 1L) {
[13:36:42.970]                     if (is.function(sendCondition)) 
[13:36:42.970]                       return(sendCondition)
[13:36:42.970]                     ns <- getNamespace("parallel")
[13:36:42.970]                     if (exists("sendData", mode = "function", 
[13:36:42.970]                       envir = ns)) {
[13:36:42.970]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:42.970]                         envir = ns)
[13:36:42.970]                       envir <- sys.frame(frame)
[13:36:42.970]                       master <- NULL
[13:36:42.970]                       while (!identical(envir, .GlobalEnv) && 
[13:36:42.970]                         !identical(envir, emptyenv())) {
[13:36:42.970]                         if (exists("master", mode = "list", envir = envir, 
[13:36:42.970]                           inherits = FALSE)) {
[13:36:42.970]                           master <- get("master", mode = "list", 
[13:36:42.970]                             envir = envir, inherits = FALSE)
[13:36:42.970]                           if (inherits(master, c("SOCKnode", 
[13:36:42.970]                             "SOCK0node"))) {
[13:36:42.970]                             sendCondition <<- function(cond) {
[13:36:42.970]                               data <- list(type = "VALUE", value = cond, 
[13:36:42.970]                                 success = TRUE)
[13:36:42.970]                               parallel_sendData(master, data)
[13:36:42.970]                             }
[13:36:42.970]                             return(sendCondition)
[13:36:42.970]                           }
[13:36:42.970]                         }
[13:36:42.970]                         frame <- frame + 1L
[13:36:42.970]                         envir <- sys.frame(frame)
[13:36:42.970]                       }
[13:36:42.970]                     }
[13:36:42.970]                     sendCondition <<- function(cond) NULL
[13:36:42.970]                   }
[13:36:42.970]                 })
[13:36:42.970]                 withCallingHandlers({
[13:36:42.970]                   {
[13:36:42.970]                     outer_function(1L)
[13:36:42.970]                   }
[13:36:42.970]                 }, immediateCondition = function(cond) {
[13:36:42.970]                   sendCondition <- ...future.makeSendCondition()
[13:36:42.970]                   sendCondition(cond)
[13:36:42.970]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.970]                   {
[13:36:42.970]                     inherits <- base::inherits
[13:36:42.970]                     invokeRestart <- base::invokeRestart
[13:36:42.970]                     is.null <- base::is.null
[13:36:42.970]                     muffled <- FALSE
[13:36:42.970]                     if (inherits(cond, "message")) {
[13:36:42.970]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:42.970]                       if (muffled) 
[13:36:42.970]                         invokeRestart("muffleMessage")
[13:36:42.970]                     }
[13:36:42.970]                     else if (inherits(cond, "warning")) {
[13:36:42.970]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:42.970]                       if (muffled) 
[13:36:42.970]                         invokeRestart("muffleWarning")
[13:36:42.970]                     }
[13:36:42.970]                     else if (inherits(cond, "condition")) {
[13:36:42.970]                       if (!is.null(pattern)) {
[13:36:42.970]                         computeRestarts <- base::computeRestarts
[13:36:42.970]                         grepl <- base::grepl
[13:36:42.970]                         restarts <- computeRestarts(cond)
[13:36:42.970]                         for (restart in restarts) {
[13:36:42.970]                           name <- restart$name
[13:36:42.970]                           if (is.null(name)) 
[13:36:42.970]                             next
[13:36:42.970]                           if (!grepl(pattern, name)) 
[13:36:42.970]                             next
[13:36:42.970]                           invokeRestart(restart)
[13:36:42.970]                           muffled <- TRUE
[13:36:42.970]                           break
[13:36:42.970]                         }
[13:36:42.970]                       }
[13:36:42.970]                     }
[13:36:42.970]                     invisible(muffled)
[13:36:42.970]                   }
[13:36:42.970]                   muffleCondition(cond)
[13:36:42.970]                 })
[13:36:42.970]             }))
[13:36:42.970]             future::FutureResult(value = ...future.value$value, 
[13:36:42.970]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.970]                   ...future.rng), globalenv = if (FALSE) 
[13:36:42.970]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:42.970]                     ...future.globalenv.names))
[13:36:42.970]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:42.970]         }, condition = base::local({
[13:36:42.970]             c <- base::c
[13:36:42.970]             inherits <- base::inherits
[13:36:42.970]             invokeRestart <- base::invokeRestart
[13:36:42.970]             length <- base::length
[13:36:42.970]             list <- base::list
[13:36:42.970]             seq.int <- base::seq.int
[13:36:42.970]             signalCondition <- base::signalCondition
[13:36:42.970]             sys.calls <- base::sys.calls
[13:36:42.970]             `[[` <- base::`[[`
[13:36:42.970]             `+` <- base::`+`
[13:36:42.970]             `<<-` <- base::`<<-`
[13:36:42.970]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:42.970]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:42.970]                   3L)]
[13:36:42.970]             }
[13:36:42.970]             function(cond) {
[13:36:42.970]                 is_error <- inherits(cond, "error")
[13:36:42.970]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:42.970]                   NULL)
[13:36:42.970]                 if (is_error) {
[13:36:42.970]                   sessionInformation <- function() {
[13:36:42.970]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:42.970]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:42.970]                       search = base::search(), system = base::Sys.info())
[13:36:42.970]                   }
[13:36:42.970]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.970]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:42.970]                     cond$call), session = sessionInformation(), 
[13:36:42.970]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:42.970]                   signalCondition(cond)
[13:36:42.970]                 }
[13:36:42.970]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:42.970]                 "immediateCondition"))) {
[13:36:42.970]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:42.970]                   ...future.conditions[[length(...future.conditions) + 
[13:36:42.970]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:42.970]                   if (TRUE && !signal) {
[13:36:42.970]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.970]                     {
[13:36:42.970]                       inherits <- base::inherits
[13:36:42.970]                       invokeRestart <- base::invokeRestart
[13:36:42.970]                       is.null <- base::is.null
[13:36:42.970]                       muffled <- FALSE
[13:36:42.970]                       if (inherits(cond, "message")) {
[13:36:42.970]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.970]                         if (muffled) 
[13:36:42.970]                           invokeRestart("muffleMessage")
[13:36:42.970]                       }
[13:36:42.970]                       else if (inherits(cond, "warning")) {
[13:36:42.970]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.970]                         if (muffled) 
[13:36:42.970]                           invokeRestart("muffleWarning")
[13:36:42.970]                       }
[13:36:42.970]                       else if (inherits(cond, "condition")) {
[13:36:42.970]                         if (!is.null(pattern)) {
[13:36:42.970]                           computeRestarts <- base::computeRestarts
[13:36:42.970]                           grepl <- base::grepl
[13:36:42.970]                           restarts <- computeRestarts(cond)
[13:36:42.970]                           for (restart in restarts) {
[13:36:42.970]                             name <- restart$name
[13:36:42.970]                             if (is.null(name)) 
[13:36:42.970]                               next
[13:36:42.970]                             if (!grepl(pattern, name)) 
[13:36:42.970]                               next
[13:36:42.970]                             invokeRestart(restart)
[13:36:42.970]                             muffled <- TRUE
[13:36:42.970]                             break
[13:36:42.970]                           }
[13:36:42.970]                         }
[13:36:42.970]                       }
[13:36:42.970]                       invisible(muffled)
[13:36:42.970]                     }
[13:36:42.970]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.970]                   }
[13:36:42.970]                 }
[13:36:42.970]                 else {
[13:36:42.970]                   if (TRUE) {
[13:36:42.970]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:42.970]                     {
[13:36:42.970]                       inherits <- base::inherits
[13:36:42.970]                       invokeRestart <- base::invokeRestart
[13:36:42.970]                       is.null <- base::is.null
[13:36:42.970]                       muffled <- FALSE
[13:36:42.970]                       if (inherits(cond, "message")) {
[13:36:42.970]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:42.970]                         if (muffled) 
[13:36:42.970]                           invokeRestart("muffleMessage")
[13:36:42.970]                       }
[13:36:42.970]                       else if (inherits(cond, "warning")) {
[13:36:42.970]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:42.970]                         if (muffled) 
[13:36:42.970]                           invokeRestart("muffleWarning")
[13:36:42.970]                       }
[13:36:42.970]                       else if (inherits(cond, "condition")) {
[13:36:42.970]                         if (!is.null(pattern)) {
[13:36:42.970]                           computeRestarts <- base::computeRestarts
[13:36:42.970]                           grepl <- base::grepl
[13:36:42.970]                           restarts <- computeRestarts(cond)
[13:36:42.970]                           for (restart in restarts) {
[13:36:42.970]                             name <- restart$name
[13:36:42.970]                             if (is.null(name)) 
[13:36:42.970]                               next
[13:36:42.970]                             if (!grepl(pattern, name)) 
[13:36:42.970]                               next
[13:36:42.970]                             invokeRestart(restart)
[13:36:42.970]                             muffled <- TRUE
[13:36:42.970]                             break
[13:36:42.970]                           }
[13:36:42.970]                         }
[13:36:42.970]                       }
[13:36:42.970]                       invisible(muffled)
[13:36:42.970]                     }
[13:36:42.970]                     muffleCondition(cond, pattern = "^muffle")
[13:36:42.970]                   }
[13:36:42.970]                 }
[13:36:42.970]             }
[13:36:42.970]         }))
[13:36:42.970]     }, error = function(ex) {
[13:36:42.970]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:42.970]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:42.970]                 ...future.rng), started = ...future.startTime, 
[13:36:42.970]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:42.970]             version = "1.8"), class = "FutureResult")
[13:36:42.970]     }, finally = {
[13:36:42.970]         if (!identical(...future.workdir, getwd())) 
[13:36:42.970]             setwd(...future.workdir)
[13:36:42.970]         {
[13:36:42.970]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:42.970]                 ...future.oldOptions$nwarnings <- NULL
[13:36:42.970]             }
[13:36:42.970]             base::options(...future.oldOptions)
[13:36:42.970]             if (.Platform$OS.type == "windows") {
[13:36:42.970]                 old_names <- names(...future.oldEnvVars)
[13:36:42.970]                 envs <- base::Sys.getenv()
[13:36:42.970]                 names <- names(envs)
[13:36:42.970]                 common <- intersect(names, old_names)
[13:36:42.970]                 added <- setdiff(names, old_names)
[13:36:42.970]                 removed <- setdiff(old_names, names)
[13:36:42.970]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:42.970]                   envs[common]]
[13:36:42.970]                 NAMES <- toupper(changed)
[13:36:42.970]                 args <- list()
[13:36:42.970]                 for (kk in seq_along(NAMES)) {
[13:36:42.970]                   name <- changed[[kk]]
[13:36:42.970]                   NAME <- NAMES[[kk]]
[13:36:42.970]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.970]                     next
[13:36:42.970]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.970]                 }
[13:36:42.970]                 NAMES <- toupper(added)
[13:36:42.970]                 for (kk in seq_along(NAMES)) {
[13:36:42.970]                   name <- added[[kk]]
[13:36:42.970]                   NAME <- NAMES[[kk]]
[13:36:42.970]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.970]                     next
[13:36:42.970]                   args[[name]] <- ""
[13:36:42.970]                 }
[13:36:42.970]                 NAMES <- toupper(removed)
[13:36:42.970]                 for (kk in seq_along(NAMES)) {
[13:36:42.970]                   name <- removed[[kk]]
[13:36:42.970]                   NAME <- NAMES[[kk]]
[13:36:42.970]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:42.970]                     next
[13:36:42.970]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:42.970]                 }
[13:36:42.970]                 if (length(args) > 0) 
[13:36:42.970]                   base::do.call(base::Sys.setenv, args = args)
[13:36:42.970]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:42.970]             }
[13:36:42.970]             else {
[13:36:42.970]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:42.970]             }
[13:36:42.970]             {
[13:36:42.970]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:42.970]                   0L) {
[13:36:42.970]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:42.970]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:42.970]                   base::options(opts)
[13:36:42.970]                 }
[13:36:42.970]                 {
[13:36:42.970]                   {
[13:36:42.970]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:42.970]                     NULL
[13:36:42.970]                   }
[13:36:42.970]                   options(future.plan = NULL)
[13:36:42.970]                   if (is.na(NA_character_)) 
[13:36:42.970]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:42.970]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:42.970]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:42.970]                     .init = FALSE)
[13:36:42.970]                 }
[13:36:42.970]             }
[13:36:42.970]         }
[13:36:42.970]     })
[13:36:42.970]     if (TRUE) {
[13:36:42.970]         base::sink(type = "output", split = FALSE)
[13:36:42.970]         if (TRUE) {
[13:36:42.970]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:42.970]         }
[13:36:42.970]         else {
[13:36:42.970]             ...future.result["stdout"] <- base::list(NULL)
[13:36:42.970]         }
[13:36:42.970]         base::close(...future.stdout)
[13:36:42.970]         ...future.stdout <- NULL
[13:36:42.970]     }
[13:36:42.970]     ...future.result$conditions <- ...future.conditions
[13:36:42.970]     ...future.result$finished <- base::Sys.time()
[13:36:42.970]     ...future.result
[13:36:42.970] }
[13:36:42.972] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[13:36:42.972] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[13:36:42.973] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[13:36:42.973] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[13:36:42.973] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[13:36:42.973] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[13:36:42.974] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[13:36:42.974] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[13:36:42.974] MultisessionFuture started
[13:36:42.975] - Launch lazy future ... done
[13:36:42.975] run() for ‘MultisessionFuture’ ... done
[13:36:42.975] result() for ClusterFuture ...
[13:36:42.975] receiveMessageFromWorker() for ClusterFuture ...
[13:36:42.975] - Validating connection of MultisessionFuture
[13:36:42.981] - received message: FutureResult
[13:36:42.981] - Received FutureResult
[13:36:42.981] - Erased future from FutureRegistry
[13:36:42.981] result() for ClusterFuture ...
[13:36:42.981] - result already collected: FutureResult
[13:36:42.981] result() for ClusterFuture ... done
[13:36:42.981] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:42.982] result() for ClusterFuture ... done
[13:36:42.982] result() for ClusterFuture ...
[13:36:42.982] - result already collected: FutureResult
[13:36:42.982] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[13:36:42.983] getGlobalsAndPackages() ...
[13:36:42.983] Searching for globals...
[13:36:42.987] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[13:36:42.987] Searching for globals ... DONE
[13:36:42.987] Resolving globals: FALSE
[13:36:42.988] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[13:36:42.988] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[13:36:42.989] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[13:36:42.989] 
[13:36:42.989] getGlobalsAndPackages() ... DONE
[13:36:42.989] run() for ‘Future’ ...
[13:36:42.989] - state: ‘created’
[13:36:42.989] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:43.003] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:43.003] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:43.003]   - Field: ‘node’
[13:36:43.003]   - Field: ‘label’
[13:36:43.003]   - Field: ‘local’
[13:36:43.003]   - Field: ‘owner’
[13:36:43.003]   - Field: ‘envir’
[13:36:43.004]   - Field: ‘workers’
[13:36:43.004]   - Field: ‘packages’
[13:36:43.004]   - Field: ‘gc’
[13:36:43.004]   - Field: ‘conditions’
[13:36:43.004]   - Field: ‘persistent’
[13:36:43.004]   - Field: ‘expr’
[13:36:43.004]   - Field: ‘uuid’
[13:36:43.004]   - Field: ‘seed’
[13:36:43.004]   - Field: ‘version’
[13:36:43.004]   - Field: ‘result’
[13:36:43.004]   - Field: ‘asynchronous’
[13:36:43.005]   - Field: ‘calls’
[13:36:43.005]   - Field: ‘globals’
[13:36:43.005]   - Field: ‘stdout’
[13:36:43.005]   - Field: ‘earlySignal’
[13:36:43.005]   - Field: ‘lazy’
[13:36:43.005]   - Field: ‘state’
[13:36:43.005] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:43.005] - Launch lazy future ...
[13:36:43.005] Packages needed by the future expression (n = 0): <none>
[13:36:43.006] Packages needed by future strategies (n = 0): <none>
[13:36:43.006] {
[13:36:43.006]     {
[13:36:43.006]         {
[13:36:43.006]             ...future.startTime <- base::Sys.time()
[13:36:43.006]             {
[13:36:43.006]                 {
[13:36:43.006]                   {
[13:36:43.006]                     {
[13:36:43.006]                       base::local({
[13:36:43.006]                         has_future <- base::requireNamespace("future", 
[13:36:43.006]                           quietly = TRUE)
[13:36:43.006]                         if (has_future) {
[13:36:43.006]                           ns <- base::getNamespace("future")
[13:36:43.006]                           version <- ns[[".package"]][["version"]]
[13:36:43.006]                           if (is.null(version)) 
[13:36:43.006]                             version <- utils::packageVersion("future")
[13:36:43.006]                         }
[13:36:43.006]                         else {
[13:36:43.006]                           version <- NULL
[13:36:43.006]                         }
[13:36:43.006]                         if (!has_future || version < "1.8.0") {
[13:36:43.006]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:43.006]                             "", base::R.version$version.string), 
[13:36:43.006]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:43.006]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:43.006]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:43.006]                               "release", "version")], collapse = " "), 
[13:36:43.006]                             hostname = base::Sys.info()[["nodename"]])
[13:36:43.006]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:43.006]                             info)
[13:36:43.006]                           info <- base::paste(info, collapse = "; ")
[13:36:43.006]                           if (!has_future) {
[13:36:43.006]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:43.006]                               info)
[13:36:43.006]                           }
[13:36:43.006]                           else {
[13:36:43.006]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:43.006]                               info, version)
[13:36:43.006]                           }
[13:36:43.006]                           base::stop(msg)
[13:36:43.006]                         }
[13:36:43.006]                       })
[13:36:43.006]                     }
[13:36:43.006]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:43.006]                     base::options(mc.cores = 1L)
[13:36:43.006]                   }
[13:36:43.006]                   ...future.strategy.old <- future::plan("list")
[13:36:43.006]                   options(future.plan = NULL)
[13:36:43.006]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:43.006]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:43.006]                 }
[13:36:43.006]                 ...future.workdir <- getwd()
[13:36:43.006]             }
[13:36:43.006]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:43.006]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:43.006]         }
[13:36:43.006]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:43.006]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:43.006]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:43.006]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:43.006]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:43.006]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:43.006]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:43.006]             base::names(...future.oldOptions))
[13:36:43.006]     }
[13:36:43.006]     if (FALSE) {
[13:36:43.006]     }
[13:36:43.006]     else {
[13:36:43.006]         if (TRUE) {
[13:36:43.006]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:43.006]                 open = "w")
[13:36:43.006]         }
[13:36:43.006]         else {
[13:36:43.006]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:43.006]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:43.006]         }
[13:36:43.006]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:43.006]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:43.006]             base::sink(type = "output", split = FALSE)
[13:36:43.006]             base::close(...future.stdout)
[13:36:43.006]         }, add = TRUE)
[13:36:43.006]     }
[13:36:43.006]     ...future.frame <- base::sys.nframe()
[13:36:43.006]     ...future.conditions <- base::list()
[13:36:43.006]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:43.006]     if (FALSE) {
[13:36:43.006]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:43.006]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:43.006]     }
[13:36:43.006]     ...future.result <- base::tryCatch({
[13:36:43.006]         base::withCallingHandlers({
[13:36:43.006]             ...future.value <- base::withVisible(base::local({
[13:36:43.006]                 ...future.makeSendCondition <- base::local({
[13:36:43.006]                   sendCondition <- NULL
[13:36:43.006]                   function(frame = 1L) {
[13:36:43.006]                     if (is.function(sendCondition)) 
[13:36:43.006]                       return(sendCondition)
[13:36:43.006]                     ns <- getNamespace("parallel")
[13:36:43.006]                     if (exists("sendData", mode = "function", 
[13:36:43.006]                       envir = ns)) {
[13:36:43.006]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:43.006]                         envir = ns)
[13:36:43.006]                       envir <- sys.frame(frame)
[13:36:43.006]                       master <- NULL
[13:36:43.006]                       while (!identical(envir, .GlobalEnv) && 
[13:36:43.006]                         !identical(envir, emptyenv())) {
[13:36:43.006]                         if (exists("master", mode = "list", envir = envir, 
[13:36:43.006]                           inherits = FALSE)) {
[13:36:43.006]                           master <- get("master", mode = "list", 
[13:36:43.006]                             envir = envir, inherits = FALSE)
[13:36:43.006]                           if (inherits(master, c("SOCKnode", 
[13:36:43.006]                             "SOCK0node"))) {
[13:36:43.006]                             sendCondition <<- function(cond) {
[13:36:43.006]                               data <- list(type = "VALUE", value = cond, 
[13:36:43.006]                                 success = TRUE)
[13:36:43.006]                               parallel_sendData(master, data)
[13:36:43.006]                             }
[13:36:43.006]                             return(sendCondition)
[13:36:43.006]                           }
[13:36:43.006]                         }
[13:36:43.006]                         frame <- frame + 1L
[13:36:43.006]                         envir <- sys.frame(frame)
[13:36:43.006]                       }
[13:36:43.006]                     }
[13:36:43.006]                     sendCondition <<- function(cond) NULL
[13:36:43.006]                   }
[13:36:43.006]                 })
[13:36:43.006]                 withCallingHandlers({
[13:36:43.006]                   {
[13:36:43.006]                     outer_function(1L)
[13:36:43.006]                   }
[13:36:43.006]                 }, immediateCondition = function(cond) {
[13:36:43.006]                   sendCondition <- ...future.makeSendCondition()
[13:36:43.006]                   sendCondition(cond)
[13:36:43.006]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:43.006]                   {
[13:36:43.006]                     inherits <- base::inherits
[13:36:43.006]                     invokeRestart <- base::invokeRestart
[13:36:43.006]                     is.null <- base::is.null
[13:36:43.006]                     muffled <- FALSE
[13:36:43.006]                     if (inherits(cond, "message")) {
[13:36:43.006]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:43.006]                       if (muffled) 
[13:36:43.006]                         invokeRestart("muffleMessage")
[13:36:43.006]                     }
[13:36:43.006]                     else if (inherits(cond, "warning")) {
[13:36:43.006]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:43.006]                       if (muffled) 
[13:36:43.006]                         invokeRestart("muffleWarning")
[13:36:43.006]                     }
[13:36:43.006]                     else if (inherits(cond, "condition")) {
[13:36:43.006]                       if (!is.null(pattern)) {
[13:36:43.006]                         computeRestarts <- base::computeRestarts
[13:36:43.006]                         grepl <- base::grepl
[13:36:43.006]                         restarts <- computeRestarts(cond)
[13:36:43.006]                         for (restart in restarts) {
[13:36:43.006]                           name <- restart$name
[13:36:43.006]                           if (is.null(name)) 
[13:36:43.006]                             next
[13:36:43.006]                           if (!grepl(pattern, name)) 
[13:36:43.006]                             next
[13:36:43.006]                           invokeRestart(restart)
[13:36:43.006]                           muffled <- TRUE
[13:36:43.006]                           break
[13:36:43.006]                         }
[13:36:43.006]                       }
[13:36:43.006]                     }
[13:36:43.006]                     invisible(muffled)
[13:36:43.006]                   }
[13:36:43.006]                   muffleCondition(cond)
[13:36:43.006]                 })
[13:36:43.006]             }))
[13:36:43.006]             future::FutureResult(value = ...future.value$value, 
[13:36:43.006]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:43.006]                   ...future.rng), globalenv = if (FALSE) 
[13:36:43.006]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:43.006]                     ...future.globalenv.names))
[13:36:43.006]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:43.006]         }, condition = base::local({
[13:36:43.006]             c <- base::c
[13:36:43.006]             inherits <- base::inherits
[13:36:43.006]             invokeRestart <- base::invokeRestart
[13:36:43.006]             length <- base::length
[13:36:43.006]             list <- base::list
[13:36:43.006]             seq.int <- base::seq.int
[13:36:43.006]             signalCondition <- base::signalCondition
[13:36:43.006]             sys.calls <- base::sys.calls
[13:36:43.006]             `[[` <- base::`[[`
[13:36:43.006]             `+` <- base::`+`
[13:36:43.006]             `<<-` <- base::`<<-`
[13:36:43.006]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:43.006]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:43.006]                   3L)]
[13:36:43.006]             }
[13:36:43.006]             function(cond) {
[13:36:43.006]                 is_error <- inherits(cond, "error")
[13:36:43.006]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:43.006]                   NULL)
[13:36:43.006]                 if (is_error) {
[13:36:43.006]                   sessionInformation <- function() {
[13:36:43.006]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:43.006]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:43.006]                       search = base::search(), system = base::Sys.info())
[13:36:43.006]                   }
[13:36:43.006]                   ...future.conditions[[length(...future.conditions) + 
[13:36:43.006]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:43.006]                     cond$call), session = sessionInformation(), 
[13:36:43.006]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:43.006]                   signalCondition(cond)
[13:36:43.006]                 }
[13:36:43.006]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:43.006]                 "immediateCondition"))) {
[13:36:43.006]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:43.006]                   ...future.conditions[[length(...future.conditions) + 
[13:36:43.006]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:43.006]                   if (TRUE && !signal) {
[13:36:43.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:43.006]                     {
[13:36:43.006]                       inherits <- base::inherits
[13:36:43.006]                       invokeRestart <- base::invokeRestart
[13:36:43.006]                       is.null <- base::is.null
[13:36:43.006]                       muffled <- FALSE
[13:36:43.006]                       if (inherits(cond, "message")) {
[13:36:43.006]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:43.006]                         if (muffled) 
[13:36:43.006]                           invokeRestart("muffleMessage")
[13:36:43.006]                       }
[13:36:43.006]                       else if (inherits(cond, "warning")) {
[13:36:43.006]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:43.006]                         if (muffled) 
[13:36:43.006]                           invokeRestart("muffleWarning")
[13:36:43.006]                       }
[13:36:43.006]                       else if (inherits(cond, "condition")) {
[13:36:43.006]                         if (!is.null(pattern)) {
[13:36:43.006]                           computeRestarts <- base::computeRestarts
[13:36:43.006]                           grepl <- base::grepl
[13:36:43.006]                           restarts <- computeRestarts(cond)
[13:36:43.006]                           for (restart in restarts) {
[13:36:43.006]                             name <- restart$name
[13:36:43.006]                             if (is.null(name)) 
[13:36:43.006]                               next
[13:36:43.006]                             if (!grepl(pattern, name)) 
[13:36:43.006]                               next
[13:36:43.006]                             invokeRestart(restart)
[13:36:43.006]                             muffled <- TRUE
[13:36:43.006]                             break
[13:36:43.006]                           }
[13:36:43.006]                         }
[13:36:43.006]                       }
[13:36:43.006]                       invisible(muffled)
[13:36:43.006]                     }
[13:36:43.006]                     muffleCondition(cond, pattern = "^muffle")
[13:36:43.006]                   }
[13:36:43.006]                 }
[13:36:43.006]                 else {
[13:36:43.006]                   if (TRUE) {
[13:36:43.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:43.006]                     {
[13:36:43.006]                       inherits <- base::inherits
[13:36:43.006]                       invokeRestart <- base::invokeRestart
[13:36:43.006]                       is.null <- base::is.null
[13:36:43.006]                       muffled <- FALSE
[13:36:43.006]                       if (inherits(cond, "message")) {
[13:36:43.006]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:43.006]                         if (muffled) 
[13:36:43.006]                           invokeRestart("muffleMessage")
[13:36:43.006]                       }
[13:36:43.006]                       else if (inherits(cond, "warning")) {
[13:36:43.006]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:43.006]                         if (muffled) 
[13:36:43.006]                           invokeRestart("muffleWarning")
[13:36:43.006]                       }
[13:36:43.006]                       else if (inherits(cond, "condition")) {
[13:36:43.006]                         if (!is.null(pattern)) {
[13:36:43.006]                           computeRestarts <- base::computeRestarts
[13:36:43.006]                           grepl <- base::grepl
[13:36:43.006]                           restarts <- computeRestarts(cond)
[13:36:43.006]                           for (restart in restarts) {
[13:36:43.006]                             name <- restart$name
[13:36:43.006]                             if (is.null(name)) 
[13:36:43.006]                               next
[13:36:43.006]                             if (!grepl(pattern, name)) 
[13:36:43.006]                               next
[13:36:43.006]                             invokeRestart(restart)
[13:36:43.006]                             muffled <- TRUE
[13:36:43.006]                             break
[13:36:43.006]                           }
[13:36:43.006]                         }
[13:36:43.006]                       }
[13:36:43.006]                       invisible(muffled)
[13:36:43.006]                     }
[13:36:43.006]                     muffleCondition(cond, pattern = "^muffle")
[13:36:43.006]                   }
[13:36:43.006]                 }
[13:36:43.006]             }
[13:36:43.006]         }))
[13:36:43.006]     }, error = function(ex) {
[13:36:43.006]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:43.006]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:43.006]                 ...future.rng), started = ...future.startTime, 
[13:36:43.006]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:43.006]             version = "1.8"), class = "FutureResult")
[13:36:43.006]     }, finally = {
[13:36:43.006]         if (!identical(...future.workdir, getwd())) 
[13:36:43.006]             setwd(...future.workdir)
[13:36:43.006]         {
[13:36:43.006]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:43.006]                 ...future.oldOptions$nwarnings <- NULL
[13:36:43.006]             }
[13:36:43.006]             base::options(...future.oldOptions)
[13:36:43.006]             if (.Platform$OS.type == "windows") {
[13:36:43.006]                 old_names <- names(...future.oldEnvVars)
[13:36:43.006]                 envs <- base::Sys.getenv()
[13:36:43.006]                 names <- names(envs)
[13:36:43.006]                 common <- intersect(names, old_names)
[13:36:43.006]                 added <- setdiff(names, old_names)
[13:36:43.006]                 removed <- setdiff(old_names, names)
[13:36:43.006]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:43.006]                   envs[common]]
[13:36:43.006]                 NAMES <- toupper(changed)
[13:36:43.006]                 args <- list()
[13:36:43.006]                 for (kk in seq_along(NAMES)) {
[13:36:43.006]                   name <- changed[[kk]]
[13:36:43.006]                   NAME <- NAMES[[kk]]
[13:36:43.006]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:43.006]                     next
[13:36:43.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:43.006]                 }
[13:36:43.006]                 NAMES <- toupper(added)
[13:36:43.006]                 for (kk in seq_along(NAMES)) {
[13:36:43.006]                   name <- added[[kk]]
[13:36:43.006]                   NAME <- NAMES[[kk]]
[13:36:43.006]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:43.006]                     next
[13:36:43.006]                   args[[name]] <- ""
[13:36:43.006]                 }
[13:36:43.006]                 NAMES <- toupper(removed)
[13:36:43.006]                 for (kk in seq_along(NAMES)) {
[13:36:43.006]                   name <- removed[[kk]]
[13:36:43.006]                   NAME <- NAMES[[kk]]
[13:36:43.006]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:43.006]                     next
[13:36:43.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:43.006]                 }
[13:36:43.006]                 if (length(args) > 0) 
[13:36:43.006]                   base::do.call(base::Sys.setenv, args = args)
[13:36:43.006]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:43.006]             }
[13:36:43.006]             else {
[13:36:43.006]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:43.006]             }
[13:36:43.006]             {
[13:36:43.006]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:43.006]                   0L) {
[13:36:43.006]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:43.006]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:43.006]                   base::options(opts)
[13:36:43.006]                 }
[13:36:43.006]                 {
[13:36:43.006]                   {
[13:36:43.006]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:43.006]                     NULL
[13:36:43.006]                   }
[13:36:43.006]                   options(future.plan = NULL)
[13:36:43.006]                   if (is.na(NA_character_)) 
[13:36:43.006]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:43.006]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:43.006]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:43.006]                     .init = FALSE)
[13:36:43.006]                 }
[13:36:43.006]             }
[13:36:43.006]         }
[13:36:43.006]     })
[13:36:43.006]     if (TRUE) {
[13:36:43.006]         base::sink(type = "output", split = FALSE)
[13:36:43.006]         if (TRUE) {
[13:36:43.006]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:43.006]         }
[13:36:43.006]         else {
[13:36:43.006]             ...future.result["stdout"] <- base::list(NULL)
[13:36:43.006]         }
[13:36:43.006]         base::close(...future.stdout)
[13:36:43.006]         ...future.stdout <- NULL
[13:36:43.006]     }
[13:36:43.006]     ...future.result$conditions <- ...future.conditions
[13:36:43.006]     ...future.result$finished <- base::Sys.time()
[13:36:43.006]     ...future.result
[13:36:43.006] }
[13:36:43.008] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[13:36:43.009] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[13:36:43.009] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[13:36:43.009] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[13:36:43.010] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[13:36:43.010] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[13:36:43.010] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[13:36:43.010] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[13:36:43.011] MultisessionFuture started
[13:36:43.011] - Launch lazy future ... done
[13:36:43.011] run() for ‘MultisessionFuture’ ... done
[13:36:43.011] result() for ClusterFuture ...
[13:36:43.011] receiveMessageFromWorker() for ClusterFuture ...
[13:36:43.012] - Validating connection of MultisessionFuture
[13:36:43.015] - received message: FutureResult
[13:36:43.015] - Received FutureResult
[13:36:43.015] - Erased future from FutureRegistry
[13:36:43.016] result() for ClusterFuture ...
[13:36:43.016] - result already collected: FutureResult
[13:36:43.016] result() for ClusterFuture ... done
[13:36:43.016] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:43.016] result() for ClusterFuture ... done
[13:36:43.016] result() for ClusterFuture ...
[13:36:43.016] - result already collected: FutureResult
[13:36:43.016] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 2 cores ... DONE
> 
> message("*** Globals - formulas ... DONE")
*** Globals - formulas ... DONE
> 
> source("incl/end.R")
[13:36:43.018] plan(): Setting new future strategy stack:
[13:36:43.018] List of future strategies:
[13:36:43.018] 1. FutureStrategy:
[13:36:43.018]    - args: function (..., envir = parent.frame())
[13:36:43.018]    - tweaked: FALSE
[13:36:43.018]    - call: future::plan(oplan)
[13:36:43.019] plan(): nbrOfWorkers() = 1
> 
