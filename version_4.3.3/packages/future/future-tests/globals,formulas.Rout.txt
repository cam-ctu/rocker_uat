
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:20:47.967] plan(): Setting new future strategy stack:
[16:20:47.968] List of future strategies:
[16:20:47.968] 1. sequential:
[16:20:47.968]    - args: function (..., envir = parent.frame())
[16:20:47.968]    - tweaked: FALSE
[16:20:47.968]    - call: future::plan("sequential")
[16:20:47.982] plan(): nbrOfWorkers() = 1
> 
> library("datasets") ## cars data set
> library("stats")    ## lm(), poly(), xtabs()
> 
> message("*** Globals - formulas ...")
*** Globals - formulas ...
> 
> ## (i) lm(<formula>):
> ## From example("lm", package = "stats")
> ctl <- c(4.17, 5.58, 5.18, 6.11, 4.50, 4.61, 5.17, 4.53, 5.33, 5.14)
> trt <- c(4.81, 4.17, 4.41, 3.59, 5.87, 3.83, 6.03, 4.89, 4.32, 4.69)
> group <- gl(2, 10, 20, labels = c("Ctl", "Trt"))
> weight <- c(ctl, trt)
> ctl <- trt <- NULL
> ## Truth:
> fit_i <- lm(weight ~ group - 1)
> print(fit_i)

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

> 
> ## (ii) xtabs(~ x):
> x <- c(1, 1, 2, 2, 2)
> ## Truth:
> tbl_ii <- xtabs(~ x)
> print(tbl_ii)
x
1 2 
2 3 
> 
> ## (iii) lm(<formula>, data = cars):
> exprs <- list(
+   # "remove-intercept-term" form of no-intercept
+   a = substitute({ lm(dist ~ . -1, data = cars) }),
+   # "make-intercept-zero" form of no-intercept
+   b = substitute({ lm(dist ~ . +0, data = cars) }),
+   # doesn't do what we want here
+   c = substitute({ lm(dist ~ speed + speed ^ 2, data = cars) }),
+   # gets us a quadratic term
+   d = substitute({ lm(dist ~ speed + I(speed ^ 2), data = cars) }),
+   # avoid potential multicollinearity
+   e = substitute({ lm(dist ~ poly(speed, 2), data = cars) })
+ )
> 
> ## (iv) Globals - map(x, ~ expr):
> ## A fake purrr::map() function with limited functionality
> map <- function(.x, .f, ...) {
+   if (inherits(.f, "formula")) {
+     expr <- .f[[-1]]
+     .f <- eval(bquote(function(...) {
+       .(expr)
+     }))
+   }
+   eval(lapply(.x, FUN = .f, ...))
+ }
> 
> inner_function <- function(x) { x + 1 }
> 
> outer_function <- function(x) {
+   map(1:2, ~ inner_function(.x))
+ }
> 
> y_iv <- outer_function(1L)
> str(y_iv)
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
> 
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     message("- lm(<formula>) ...")
+     
+     ## Explicit future
+     f <- future({ lm(weight ~ group - 1) })
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Explicit future (lazy)
+     f <- future({ lm(weight ~ group - 1) }, lazy = TRUE)
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment
+     fit %<-% { lm(weight ~ group - 1) }
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (non-lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% FALSE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% TRUE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     message("- Globals - one-side formulas, e.g. xtabs(~ x) ...")
+     ## Explicit future
+     f <- future({ xtabs(~ x) })
+     tbl <- value(f)
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     ## Future assignment
+     tbl %<-% { xtabs(~ x) }
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     message("- Globals - lm(<formula>, data = cars) ...")
+     for (kk in seq_along(exprs)) {
+       expr <- exprs[[kk]]
+       name <- names(exprs)[kk]
+       message(sprintf("- Globals - lm(<formula #%d (%s)>, data = cars) ...",
+                       kk, sQuote(name)))
+     
+       fit_iii <- eval(expr)
+       print(fit_iii)
+     
+       f <- future(expr, substitute = FALSE)
+       fit <- value(f)
+       print(fit)
+     
+       stopifnot(all.equal(fit, fit_iii))
+     } ## for (kk ...)
+ 
+     message("- Globals - map(x, ~ expr) ...")
+     f <- future({ outer_function(1L) })
+     y <- value(f)
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+ 
+     y %<-% { outer_function(1L) }
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+   } ## for (strategy ...)
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[16:20:48.039] plan(): Setting new future strategy stack:
[16:20:48.039] List of future strategies:
[16:20:48.039] 1. sequential:
[16:20:48.039]    - args: function (..., envir = parent.frame())
[16:20:48.039]    - tweaked: FALSE
[16:20:48.039]    - call: plan(strategy)
[16:20:48.051] plan(): nbrOfWorkers() = 1
- lm(<formula>) ...
[16:20:48.052] getGlobalsAndPackages() ...
[16:20:48.052] Searching for globals...
[16:20:48.059] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:20:48.059] Searching for globals ... DONE
[16:20:48.059] Resolving globals: FALSE
[16:20:48.061] The total size of the 2 globals is 896 bytes (896 bytes)
[16:20:48.061] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:20:48.061] - globals: [2] ‘weight’, ‘group’
[16:20:48.061] - packages: [1] ‘stats’
[16:20:48.061] getGlobalsAndPackages() ... DONE
[16:20:48.062] run() for ‘Future’ ...
[16:20:48.062] - state: ‘created’
[16:20:48.062] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:48.063] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:48.063] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:48.063]   - Field: ‘label’
[16:20:48.063]   - Field: ‘local’
[16:20:48.063]   - Field: ‘owner’
[16:20:48.063]   - Field: ‘envir’
[16:20:48.063]   - Field: ‘packages’
[16:20:48.063]   - Field: ‘gc’
[16:20:48.064]   - Field: ‘conditions’
[16:20:48.064]   - Field: ‘expr’
[16:20:48.064]   - Field: ‘uuid’
[16:20:48.064]   - Field: ‘seed’
[16:20:48.064]   - Field: ‘version’
[16:20:48.064]   - Field: ‘result’
[16:20:48.064]   - Field: ‘asynchronous’
[16:20:48.064]   - Field: ‘calls’
[16:20:48.064]   - Field: ‘globals’
[16:20:48.064]   - Field: ‘stdout’
[16:20:48.065]   - Field: ‘earlySignal’
[16:20:48.065]   - Field: ‘lazy’
[16:20:48.065]   - Field: ‘state’
[16:20:48.065] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:48.065] - Launch lazy future ...
[16:20:48.066] Packages needed by the future expression (n = 1): ‘stats’
[16:20:48.066] Packages needed by future strategies (n = 0): <none>
[16:20:48.067] {
[16:20:48.067]     {
[16:20:48.067]         {
[16:20:48.067]             ...future.startTime <- base::Sys.time()
[16:20:48.067]             {
[16:20:48.067]                 {
[16:20:48.067]                   {
[16:20:48.067]                     {
[16:20:48.067]                       base::local({
[16:20:48.067]                         has_future <- base::requireNamespace("future", 
[16:20:48.067]                           quietly = TRUE)
[16:20:48.067]                         if (has_future) {
[16:20:48.067]                           ns <- base::getNamespace("future")
[16:20:48.067]                           version <- ns[[".package"]][["version"]]
[16:20:48.067]                           if (is.null(version)) 
[16:20:48.067]                             version <- utils::packageVersion("future")
[16:20:48.067]                         }
[16:20:48.067]                         else {
[16:20:48.067]                           version <- NULL
[16:20:48.067]                         }
[16:20:48.067]                         if (!has_future || version < "1.8.0") {
[16:20:48.067]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.067]                             "", base::R.version$version.string), 
[16:20:48.067]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:48.067]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:48.067]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.067]                               "release", "version")], collapse = " "), 
[16:20:48.067]                             hostname = base::Sys.info()[["nodename"]])
[16:20:48.067]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.067]                             info)
[16:20:48.067]                           info <- base::paste(info, collapse = "; ")
[16:20:48.067]                           if (!has_future) {
[16:20:48.067]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.067]                               info)
[16:20:48.067]                           }
[16:20:48.067]                           else {
[16:20:48.067]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.067]                               info, version)
[16:20:48.067]                           }
[16:20:48.067]                           base::stop(msg)
[16:20:48.067]                         }
[16:20:48.067]                       })
[16:20:48.067]                     }
[16:20:48.067]                     base::local({
[16:20:48.067]                       for (pkg in "stats") {
[16:20:48.067]                         base::loadNamespace(pkg)
[16:20:48.067]                         base::library(pkg, character.only = TRUE)
[16:20:48.067]                       }
[16:20:48.067]                     })
[16:20:48.067]                   }
[16:20:48.067]                   ...future.strategy.old <- future::plan("list")
[16:20:48.067]                   options(future.plan = NULL)
[16:20:48.067]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.067]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.067]                 }
[16:20:48.067]                 ...future.workdir <- getwd()
[16:20:48.067]             }
[16:20:48.067]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.067]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.067]         }
[16:20:48.067]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.067]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.067]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.067]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.067]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.067]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.067]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.067]             base::names(...future.oldOptions))
[16:20:48.067]     }
[16:20:48.067]     if (FALSE) {
[16:20:48.067]     }
[16:20:48.067]     else {
[16:20:48.067]         if (TRUE) {
[16:20:48.067]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.067]                 open = "w")
[16:20:48.067]         }
[16:20:48.067]         else {
[16:20:48.067]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.067]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.067]         }
[16:20:48.067]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.067]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.067]             base::sink(type = "output", split = FALSE)
[16:20:48.067]             base::close(...future.stdout)
[16:20:48.067]         }, add = TRUE)
[16:20:48.067]     }
[16:20:48.067]     ...future.frame <- base::sys.nframe()
[16:20:48.067]     ...future.conditions <- base::list()
[16:20:48.067]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.067]     if (FALSE) {
[16:20:48.067]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.067]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.067]     }
[16:20:48.067]     ...future.result <- base::tryCatch({
[16:20:48.067]         base::withCallingHandlers({
[16:20:48.067]             ...future.value <- base::withVisible(base::local({
[16:20:48.067]                 lm(weight ~ group - 1)
[16:20:48.067]             }))
[16:20:48.067]             future::FutureResult(value = ...future.value$value, 
[16:20:48.067]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.067]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.067]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.067]                     ...future.globalenv.names))
[16:20:48.067]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.067]         }, condition = base::local({
[16:20:48.067]             c <- base::c
[16:20:48.067]             inherits <- base::inherits
[16:20:48.067]             invokeRestart <- base::invokeRestart
[16:20:48.067]             length <- base::length
[16:20:48.067]             list <- base::list
[16:20:48.067]             seq.int <- base::seq.int
[16:20:48.067]             signalCondition <- base::signalCondition
[16:20:48.067]             sys.calls <- base::sys.calls
[16:20:48.067]             `[[` <- base::`[[`
[16:20:48.067]             `+` <- base::`+`
[16:20:48.067]             `<<-` <- base::`<<-`
[16:20:48.067]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.067]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.067]                   3L)]
[16:20:48.067]             }
[16:20:48.067]             function(cond) {
[16:20:48.067]                 is_error <- inherits(cond, "error")
[16:20:48.067]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.067]                   NULL)
[16:20:48.067]                 if (is_error) {
[16:20:48.067]                   sessionInformation <- function() {
[16:20:48.067]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.067]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.067]                       search = base::search(), system = base::Sys.info())
[16:20:48.067]                   }
[16:20:48.067]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.067]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.067]                     cond$call), session = sessionInformation(), 
[16:20:48.067]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.067]                   signalCondition(cond)
[16:20:48.067]                 }
[16:20:48.067]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.067]                 "immediateCondition"))) {
[16:20:48.067]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.067]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.067]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.067]                   if (TRUE && !signal) {
[16:20:48.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.067]                     {
[16:20:48.067]                       inherits <- base::inherits
[16:20:48.067]                       invokeRestart <- base::invokeRestart
[16:20:48.067]                       is.null <- base::is.null
[16:20:48.067]                       muffled <- FALSE
[16:20:48.067]                       if (inherits(cond, "message")) {
[16:20:48.067]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.067]                         if (muffled) 
[16:20:48.067]                           invokeRestart("muffleMessage")
[16:20:48.067]                       }
[16:20:48.067]                       else if (inherits(cond, "warning")) {
[16:20:48.067]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.067]                         if (muffled) 
[16:20:48.067]                           invokeRestart("muffleWarning")
[16:20:48.067]                       }
[16:20:48.067]                       else if (inherits(cond, "condition")) {
[16:20:48.067]                         if (!is.null(pattern)) {
[16:20:48.067]                           computeRestarts <- base::computeRestarts
[16:20:48.067]                           grepl <- base::grepl
[16:20:48.067]                           restarts <- computeRestarts(cond)
[16:20:48.067]                           for (restart in restarts) {
[16:20:48.067]                             name <- restart$name
[16:20:48.067]                             if (is.null(name)) 
[16:20:48.067]                               next
[16:20:48.067]                             if (!grepl(pattern, name)) 
[16:20:48.067]                               next
[16:20:48.067]                             invokeRestart(restart)
[16:20:48.067]                             muffled <- TRUE
[16:20:48.067]                             break
[16:20:48.067]                           }
[16:20:48.067]                         }
[16:20:48.067]                       }
[16:20:48.067]                       invisible(muffled)
[16:20:48.067]                     }
[16:20:48.067]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.067]                   }
[16:20:48.067]                 }
[16:20:48.067]                 else {
[16:20:48.067]                   if (TRUE) {
[16:20:48.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.067]                     {
[16:20:48.067]                       inherits <- base::inherits
[16:20:48.067]                       invokeRestart <- base::invokeRestart
[16:20:48.067]                       is.null <- base::is.null
[16:20:48.067]                       muffled <- FALSE
[16:20:48.067]                       if (inherits(cond, "message")) {
[16:20:48.067]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.067]                         if (muffled) 
[16:20:48.067]                           invokeRestart("muffleMessage")
[16:20:48.067]                       }
[16:20:48.067]                       else if (inherits(cond, "warning")) {
[16:20:48.067]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.067]                         if (muffled) 
[16:20:48.067]                           invokeRestart("muffleWarning")
[16:20:48.067]                       }
[16:20:48.067]                       else if (inherits(cond, "condition")) {
[16:20:48.067]                         if (!is.null(pattern)) {
[16:20:48.067]                           computeRestarts <- base::computeRestarts
[16:20:48.067]                           grepl <- base::grepl
[16:20:48.067]                           restarts <- computeRestarts(cond)
[16:20:48.067]                           for (restart in restarts) {
[16:20:48.067]                             name <- restart$name
[16:20:48.067]                             if (is.null(name)) 
[16:20:48.067]                               next
[16:20:48.067]                             if (!grepl(pattern, name)) 
[16:20:48.067]                               next
[16:20:48.067]                             invokeRestart(restart)
[16:20:48.067]                             muffled <- TRUE
[16:20:48.067]                             break
[16:20:48.067]                           }
[16:20:48.067]                         }
[16:20:48.067]                       }
[16:20:48.067]                       invisible(muffled)
[16:20:48.067]                     }
[16:20:48.067]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.067]                   }
[16:20:48.067]                 }
[16:20:48.067]             }
[16:20:48.067]         }))
[16:20:48.067]     }, error = function(ex) {
[16:20:48.067]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.067]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.067]                 ...future.rng), started = ...future.startTime, 
[16:20:48.067]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.067]             version = "1.8"), class = "FutureResult")
[16:20:48.067]     }, finally = {
[16:20:48.067]         if (!identical(...future.workdir, getwd())) 
[16:20:48.067]             setwd(...future.workdir)
[16:20:48.067]         {
[16:20:48.067]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.067]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.067]             }
[16:20:48.067]             base::options(...future.oldOptions)
[16:20:48.067]             if (.Platform$OS.type == "windows") {
[16:20:48.067]                 old_names <- names(...future.oldEnvVars)
[16:20:48.067]                 envs <- base::Sys.getenv()
[16:20:48.067]                 names <- names(envs)
[16:20:48.067]                 common <- intersect(names, old_names)
[16:20:48.067]                 added <- setdiff(names, old_names)
[16:20:48.067]                 removed <- setdiff(old_names, names)
[16:20:48.067]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.067]                   envs[common]]
[16:20:48.067]                 NAMES <- toupper(changed)
[16:20:48.067]                 args <- list()
[16:20:48.067]                 for (kk in seq_along(NAMES)) {
[16:20:48.067]                   name <- changed[[kk]]
[16:20:48.067]                   NAME <- NAMES[[kk]]
[16:20:48.067]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.067]                     next
[16:20:48.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.067]                 }
[16:20:48.067]                 NAMES <- toupper(added)
[16:20:48.067]                 for (kk in seq_along(NAMES)) {
[16:20:48.067]                   name <- added[[kk]]
[16:20:48.067]                   NAME <- NAMES[[kk]]
[16:20:48.067]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.067]                     next
[16:20:48.067]                   args[[name]] <- ""
[16:20:48.067]                 }
[16:20:48.067]                 NAMES <- toupper(removed)
[16:20:48.067]                 for (kk in seq_along(NAMES)) {
[16:20:48.067]                   name <- removed[[kk]]
[16:20:48.067]                   NAME <- NAMES[[kk]]
[16:20:48.067]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.067]                     next
[16:20:48.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.067]                 }
[16:20:48.067]                 if (length(args) > 0) 
[16:20:48.067]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.067]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.067]             }
[16:20:48.067]             else {
[16:20:48.067]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.067]             }
[16:20:48.067]             {
[16:20:48.067]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.067]                   0L) {
[16:20:48.067]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.067]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.067]                   base::options(opts)
[16:20:48.067]                 }
[16:20:48.067]                 {
[16:20:48.067]                   {
[16:20:48.067]                     NULL
[16:20:48.067]                     RNGkind("Mersenne-Twister")
[16:20:48.067]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:48.067]                       inherits = FALSE)
[16:20:48.067]                   }
[16:20:48.067]                   options(future.plan = NULL)
[16:20:48.067]                   if (is.na(NA_character_)) 
[16:20:48.067]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.067]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.067]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.067]                     .init = FALSE)
[16:20:48.067]                 }
[16:20:48.067]             }
[16:20:48.067]         }
[16:20:48.067]     })
[16:20:48.067]     if (TRUE) {
[16:20:48.067]         base::sink(type = "output", split = FALSE)
[16:20:48.067]         if (TRUE) {
[16:20:48.067]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.067]         }
[16:20:48.067]         else {
[16:20:48.067]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.067]         }
[16:20:48.067]         base::close(...future.stdout)
[16:20:48.067]         ...future.stdout <- NULL
[16:20:48.067]     }
[16:20:48.067]     ...future.result$conditions <- ...future.conditions
[16:20:48.067]     ...future.result$finished <- base::Sys.time()
[16:20:48.067]     ...future.result
[16:20:48.067] }
[16:20:48.069] assign_globals() ...
[16:20:48.069] List of 2
[16:20:48.069]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:20:48.069]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:20:48.069]  - attr(*, "where")=List of 2
[16:20:48.069]   ..$ weight:<environment: R_EmptyEnv> 
[16:20:48.069]   ..$ group :<environment: R_EmptyEnv> 
[16:20:48.069]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:48.069]  - attr(*, "resolved")= logi FALSE
[16:20:48.069]  - attr(*, "total_size")= num 896
[16:20:48.069]  - attr(*, "already-done")= logi TRUE
[16:20:48.072] - copied ‘weight’ to environment
[16:20:48.072] - copied ‘group’ to environment
[16:20:48.072] assign_globals() ... done
[16:20:48.072] plan(): Setting new future strategy stack:
[16:20:48.073] List of future strategies:
[16:20:48.073] 1. sequential:
[16:20:48.073]    - args: function (..., envir = parent.frame())
[16:20:48.073]    - tweaked: FALSE
[16:20:48.073]    - call: NULL
[16:20:48.073] plan(): nbrOfWorkers() = 1
[16:20:48.075] plan(): Setting new future strategy stack:
[16:20:48.075] List of future strategies:
[16:20:48.075] 1. sequential:
[16:20:48.075]    - args: function (..., envir = parent.frame())
[16:20:48.075]    - tweaked: FALSE
[16:20:48.075]    - call: plan(strategy)
[16:20:48.075] plan(): nbrOfWorkers() = 1
[16:20:48.075] SequentialFuture started (and completed)
[16:20:48.076] - Launch lazy future ... done
[16:20:48.076] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:20:48.081] getGlobalsAndPackages() ...
[16:20:48.081] Searching for globals...
[16:20:48.083] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:20:48.083] Searching for globals ... DONE
[16:20:48.083] Resolving globals: FALSE
[16:20:48.083] The total size of the 2 globals is 896 bytes (896 bytes)
[16:20:48.084] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:20:48.084] - globals: [2] ‘weight’, ‘group’
[16:20:48.084] - packages: [1] ‘stats’
[16:20:48.084] getGlobalsAndPackages() ... DONE
[16:20:48.085] run() for ‘Future’ ...
[16:20:48.085] - state: ‘created’
[16:20:48.085] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:48.085] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:48.085] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:48.085]   - Field: ‘label’
[16:20:48.085]   - Field: ‘local’
[16:20:48.085]   - Field: ‘owner’
[16:20:48.086]   - Field: ‘envir’
[16:20:48.086]   - Field: ‘packages’
[16:20:48.086]   - Field: ‘gc’
[16:20:48.086]   - Field: ‘conditions’
[16:20:48.086]   - Field: ‘expr’
[16:20:48.086]   - Field: ‘uuid’
[16:20:48.086]   - Field: ‘seed’
[16:20:48.086]   - Field: ‘version’
[16:20:48.086]   - Field: ‘result’
[16:20:48.086]   - Field: ‘asynchronous’
[16:20:48.087]   - Field: ‘calls’
[16:20:48.087]   - Field: ‘globals’
[16:20:48.087]   - Field: ‘stdout’
[16:20:48.087]   - Field: ‘earlySignal’
[16:20:48.087]   - Field: ‘lazy’
[16:20:48.087]   - Field: ‘state’
[16:20:48.087] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:48.087] - Launch lazy future ...
[16:20:48.087] Packages needed by the future expression (n = 1): ‘stats’
[16:20:48.087] Packages needed by future strategies (n = 0): <none>
[16:20:48.088] {
[16:20:48.088]     {
[16:20:48.088]         {
[16:20:48.088]             ...future.startTime <- base::Sys.time()
[16:20:48.088]             {
[16:20:48.088]                 {
[16:20:48.088]                   {
[16:20:48.088]                     {
[16:20:48.088]                       base::local({
[16:20:48.088]                         has_future <- base::requireNamespace("future", 
[16:20:48.088]                           quietly = TRUE)
[16:20:48.088]                         if (has_future) {
[16:20:48.088]                           ns <- base::getNamespace("future")
[16:20:48.088]                           version <- ns[[".package"]][["version"]]
[16:20:48.088]                           if (is.null(version)) 
[16:20:48.088]                             version <- utils::packageVersion("future")
[16:20:48.088]                         }
[16:20:48.088]                         else {
[16:20:48.088]                           version <- NULL
[16:20:48.088]                         }
[16:20:48.088]                         if (!has_future || version < "1.8.0") {
[16:20:48.088]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.088]                             "", base::R.version$version.string), 
[16:20:48.088]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:48.088]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:48.088]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.088]                               "release", "version")], collapse = " "), 
[16:20:48.088]                             hostname = base::Sys.info()[["nodename"]])
[16:20:48.088]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.088]                             info)
[16:20:48.088]                           info <- base::paste(info, collapse = "; ")
[16:20:48.088]                           if (!has_future) {
[16:20:48.088]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.088]                               info)
[16:20:48.088]                           }
[16:20:48.088]                           else {
[16:20:48.088]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.088]                               info, version)
[16:20:48.088]                           }
[16:20:48.088]                           base::stop(msg)
[16:20:48.088]                         }
[16:20:48.088]                       })
[16:20:48.088]                     }
[16:20:48.088]                     base::local({
[16:20:48.088]                       for (pkg in "stats") {
[16:20:48.088]                         base::loadNamespace(pkg)
[16:20:48.088]                         base::library(pkg, character.only = TRUE)
[16:20:48.088]                       }
[16:20:48.088]                     })
[16:20:48.088]                   }
[16:20:48.088]                   ...future.strategy.old <- future::plan("list")
[16:20:48.088]                   options(future.plan = NULL)
[16:20:48.088]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.088]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.088]                 }
[16:20:48.088]                 ...future.workdir <- getwd()
[16:20:48.088]             }
[16:20:48.088]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.088]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.088]         }
[16:20:48.088]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.088]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.088]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.088]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.088]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.088]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.088]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.088]             base::names(...future.oldOptions))
[16:20:48.088]     }
[16:20:48.088]     if (FALSE) {
[16:20:48.088]     }
[16:20:48.088]     else {
[16:20:48.088]         if (TRUE) {
[16:20:48.088]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.088]                 open = "w")
[16:20:48.088]         }
[16:20:48.088]         else {
[16:20:48.088]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.088]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.088]         }
[16:20:48.088]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.088]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.088]             base::sink(type = "output", split = FALSE)
[16:20:48.088]             base::close(...future.stdout)
[16:20:48.088]         }, add = TRUE)
[16:20:48.088]     }
[16:20:48.088]     ...future.frame <- base::sys.nframe()
[16:20:48.088]     ...future.conditions <- base::list()
[16:20:48.088]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.088]     if (FALSE) {
[16:20:48.088]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.088]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.088]     }
[16:20:48.088]     ...future.result <- base::tryCatch({
[16:20:48.088]         base::withCallingHandlers({
[16:20:48.088]             ...future.value <- base::withVisible(base::local({
[16:20:48.088]                 lm(weight ~ group - 1)
[16:20:48.088]             }))
[16:20:48.088]             future::FutureResult(value = ...future.value$value, 
[16:20:48.088]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.088]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.088]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.088]                     ...future.globalenv.names))
[16:20:48.088]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.088]         }, condition = base::local({
[16:20:48.088]             c <- base::c
[16:20:48.088]             inherits <- base::inherits
[16:20:48.088]             invokeRestart <- base::invokeRestart
[16:20:48.088]             length <- base::length
[16:20:48.088]             list <- base::list
[16:20:48.088]             seq.int <- base::seq.int
[16:20:48.088]             signalCondition <- base::signalCondition
[16:20:48.088]             sys.calls <- base::sys.calls
[16:20:48.088]             `[[` <- base::`[[`
[16:20:48.088]             `+` <- base::`+`
[16:20:48.088]             `<<-` <- base::`<<-`
[16:20:48.088]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.088]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.088]                   3L)]
[16:20:48.088]             }
[16:20:48.088]             function(cond) {
[16:20:48.088]                 is_error <- inherits(cond, "error")
[16:20:48.088]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.088]                   NULL)
[16:20:48.088]                 if (is_error) {
[16:20:48.088]                   sessionInformation <- function() {
[16:20:48.088]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.088]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.088]                       search = base::search(), system = base::Sys.info())
[16:20:48.088]                   }
[16:20:48.088]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.088]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.088]                     cond$call), session = sessionInformation(), 
[16:20:48.088]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.088]                   signalCondition(cond)
[16:20:48.088]                 }
[16:20:48.088]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.088]                 "immediateCondition"))) {
[16:20:48.088]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.088]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.088]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.088]                   if (TRUE && !signal) {
[16:20:48.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.088]                     {
[16:20:48.088]                       inherits <- base::inherits
[16:20:48.088]                       invokeRestart <- base::invokeRestart
[16:20:48.088]                       is.null <- base::is.null
[16:20:48.088]                       muffled <- FALSE
[16:20:48.088]                       if (inherits(cond, "message")) {
[16:20:48.088]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.088]                         if (muffled) 
[16:20:48.088]                           invokeRestart("muffleMessage")
[16:20:48.088]                       }
[16:20:48.088]                       else if (inherits(cond, "warning")) {
[16:20:48.088]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.088]                         if (muffled) 
[16:20:48.088]                           invokeRestart("muffleWarning")
[16:20:48.088]                       }
[16:20:48.088]                       else if (inherits(cond, "condition")) {
[16:20:48.088]                         if (!is.null(pattern)) {
[16:20:48.088]                           computeRestarts <- base::computeRestarts
[16:20:48.088]                           grepl <- base::grepl
[16:20:48.088]                           restarts <- computeRestarts(cond)
[16:20:48.088]                           for (restart in restarts) {
[16:20:48.088]                             name <- restart$name
[16:20:48.088]                             if (is.null(name)) 
[16:20:48.088]                               next
[16:20:48.088]                             if (!grepl(pattern, name)) 
[16:20:48.088]                               next
[16:20:48.088]                             invokeRestart(restart)
[16:20:48.088]                             muffled <- TRUE
[16:20:48.088]                             break
[16:20:48.088]                           }
[16:20:48.088]                         }
[16:20:48.088]                       }
[16:20:48.088]                       invisible(muffled)
[16:20:48.088]                     }
[16:20:48.088]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.088]                   }
[16:20:48.088]                 }
[16:20:48.088]                 else {
[16:20:48.088]                   if (TRUE) {
[16:20:48.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.088]                     {
[16:20:48.088]                       inherits <- base::inherits
[16:20:48.088]                       invokeRestart <- base::invokeRestart
[16:20:48.088]                       is.null <- base::is.null
[16:20:48.088]                       muffled <- FALSE
[16:20:48.088]                       if (inherits(cond, "message")) {
[16:20:48.088]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.088]                         if (muffled) 
[16:20:48.088]                           invokeRestart("muffleMessage")
[16:20:48.088]                       }
[16:20:48.088]                       else if (inherits(cond, "warning")) {
[16:20:48.088]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.088]                         if (muffled) 
[16:20:48.088]                           invokeRestart("muffleWarning")
[16:20:48.088]                       }
[16:20:48.088]                       else if (inherits(cond, "condition")) {
[16:20:48.088]                         if (!is.null(pattern)) {
[16:20:48.088]                           computeRestarts <- base::computeRestarts
[16:20:48.088]                           grepl <- base::grepl
[16:20:48.088]                           restarts <- computeRestarts(cond)
[16:20:48.088]                           for (restart in restarts) {
[16:20:48.088]                             name <- restart$name
[16:20:48.088]                             if (is.null(name)) 
[16:20:48.088]                               next
[16:20:48.088]                             if (!grepl(pattern, name)) 
[16:20:48.088]                               next
[16:20:48.088]                             invokeRestart(restart)
[16:20:48.088]                             muffled <- TRUE
[16:20:48.088]                             break
[16:20:48.088]                           }
[16:20:48.088]                         }
[16:20:48.088]                       }
[16:20:48.088]                       invisible(muffled)
[16:20:48.088]                     }
[16:20:48.088]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.088]                   }
[16:20:48.088]                 }
[16:20:48.088]             }
[16:20:48.088]         }))
[16:20:48.088]     }, error = function(ex) {
[16:20:48.088]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.088]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.088]                 ...future.rng), started = ...future.startTime, 
[16:20:48.088]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.088]             version = "1.8"), class = "FutureResult")
[16:20:48.088]     }, finally = {
[16:20:48.088]         if (!identical(...future.workdir, getwd())) 
[16:20:48.088]             setwd(...future.workdir)
[16:20:48.088]         {
[16:20:48.088]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.088]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.088]             }
[16:20:48.088]             base::options(...future.oldOptions)
[16:20:48.088]             if (.Platform$OS.type == "windows") {
[16:20:48.088]                 old_names <- names(...future.oldEnvVars)
[16:20:48.088]                 envs <- base::Sys.getenv()
[16:20:48.088]                 names <- names(envs)
[16:20:48.088]                 common <- intersect(names, old_names)
[16:20:48.088]                 added <- setdiff(names, old_names)
[16:20:48.088]                 removed <- setdiff(old_names, names)
[16:20:48.088]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.088]                   envs[common]]
[16:20:48.088]                 NAMES <- toupper(changed)
[16:20:48.088]                 args <- list()
[16:20:48.088]                 for (kk in seq_along(NAMES)) {
[16:20:48.088]                   name <- changed[[kk]]
[16:20:48.088]                   NAME <- NAMES[[kk]]
[16:20:48.088]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.088]                     next
[16:20:48.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.088]                 }
[16:20:48.088]                 NAMES <- toupper(added)
[16:20:48.088]                 for (kk in seq_along(NAMES)) {
[16:20:48.088]                   name <- added[[kk]]
[16:20:48.088]                   NAME <- NAMES[[kk]]
[16:20:48.088]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.088]                     next
[16:20:48.088]                   args[[name]] <- ""
[16:20:48.088]                 }
[16:20:48.088]                 NAMES <- toupper(removed)
[16:20:48.088]                 for (kk in seq_along(NAMES)) {
[16:20:48.088]                   name <- removed[[kk]]
[16:20:48.088]                   NAME <- NAMES[[kk]]
[16:20:48.088]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.088]                     next
[16:20:48.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.088]                 }
[16:20:48.088]                 if (length(args) > 0) 
[16:20:48.088]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.088]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.088]             }
[16:20:48.088]             else {
[16:20:48.088]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.088]             }
[16:20:48.088]             {
[16:20:48.088]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.088]                   0L) {
[16:20:48.088]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.088]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.088]                   base::options(opts)
[16:20:48.088]                 }
[16:20:48.088]                 {
[16:20:48.088]                   {
[16:20:48.088]                     NULL
[16:20:48.088]                     RNGkind("Mersenne-Twister")
[16:20:48.088]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:48.088]                       inherits = FALSE)
[16:20:48.088]                   }
[16:20:48.088]                   options(future.plan = NULL)
[16:20:48.088]                   if (is.na(NA_character_)) 
[16:20:48.088]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.088]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.088]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.088]                     .init = FALSE)
[16:20:48.088]                 }
[16:20:48.088]             }
[16:20:48.088]         }
[16:20:48.088]     })
[16:20:48.088]     if (TRUE) {
[16:20:48.088]         base::sink(type = "output", split = FALSE)
[16:20:48.088]         if (TRUE) {
[16:20:48.088]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.088]         }
[16:20:48.088]         else {
[16:20:48.088]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.088]         }
[16:20:48.088]         base::close(...future.stdout)
[16:20:48.088]         ...future.stdout <- NULL
[16:20:48.088]     }
[16:20:48.088]     ...future.result$conditions <- ...future.conditions
[16:20:48.088]     ...future.result$finished <- base::Sys.time()
[16:20:48.088]     ...future.result
[16:20:48.088] }
[16:20:48.090] assign_globals() ...
[16:20:48.090] List of 2
[16:20:48.090]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:20:48.090]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:20:48.090]  - attr(*, "where")=List of 2
[16:20:48.090]   ..$ weight:<environment: R_EmptyEnv> 
[16:20:48.090]   ..$ group :<environment: R_EmptyEnv> 
[16:20:48.090]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:48.090]  - attr(*, "resolved")= logi FALSE
[16:20:48.090]  - attr(*, "total_size")= num 896
[16:20:48.090]  - attr(*, "already-done")= logi TRUE
[16:20:48.093] - copied ‘weight’ to environment
[16:20:48.093] - copied ‘group’ to environment
[16:20:48.093] assign_globals() ... done
[16:20:48.093] plan(): Setting new future strategy stack:
[16:20:48.093] List of future strategies:
[16:20:48.093] 1. sequential:
[16:20:48.093]    - args: function (..., envir = parent.frame())
[16:20:48.093]    - tweaked: FALSE
[16:20:48.093]    - call: NULL
[16:20:48.094] plan(): nbrOfWorkers() = 1
[16:20:48.095] plan(): Setting new future strategy stack:
[16:20:48.095] List of future strategies:
[16:20:48.095] 1. sequential:
[16:20:48.095]    - args: function (..., envir = parent.frame())
[16:20:48.095]    - tweaked: FALSE
[16:20:48.095]    - call: plan(strategy)
[16:20:48.096] plan(): nbrOfWorkers() = 1
[16:20:48.096] SequentialFuture started (and completed)
[16:20:48.096] - Launch lazy future ... done
[16:20:48.096] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:20:48.098] getGlobalsAndPackages() ...
[16:20:48.099] Searching for globals...
[16:20:48.100] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:20:48.100] Searching for globals ... DONE
[16:20:48.100] Resolving globals: FALSE
[16:20:48.101] The total size of the 2 globals is 896 bytes (896 bytes)
[16:20:48.101] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:20:48.101] - globals: [2] ‘weight’, ‘group’
[16:20:48.101] - packages: [1] ‘stats’
[16:20:48.101] getGlobalsAndPackages() ... DONE
[16:20:48.102] run() for ‘Future’ ...
[16:20:48.102] - state: ‘created’
[16:20:48.102] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:48.102] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:48.102] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:48.102]   - Field: ‘label’
[16:20:48.102]   - Field: ‘local’
[16:20:48.102]   - Field: ‘owner’
[16:20:48.103]   - Field: ‘envir’
[16:20:48.103]   - Field: ‘packages’
[16:20:48.103]   - Field: ‘gc’
[16:20:48.103]   - Field: ‘conditions’
[16:20:48.103]   - Field: ‘expr’
[16:20:48.103]   - Field: ‘uuid’
[16:20:48.103]   - Field: ‘seed’
[16:20:48.103]   - Field: ‘version’
[16:20:48.103]   - Field: ‘result’
[16:20:48.103]   - Field: ‘asynchronous’
[16:20:48.103]   - Field: ‘calls’
[16:20:48.104]   - Field: ‘globals’
[16:20:48.104]   - Field: ‘stdout’
[16:20:48.104]   - Field: ‘earlySignal’
[16:20:48.104]   - Field: ‘lazy’
[16:20:48.104]   - Field: ‘state’
[16:20:48.104] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:48.104] - Launch lazy future ...
[16:20:48.104] Packages needed by the future expression (n = 1): ‘stats’
[16:20:48.104] Packages needed by future strategies (n = 0): <none>
[16:20:48.106] {
[16:20:48.106]     {
[16:20:48.106]         {
[16:20:48.106]             ...future.startTime <- base::Sys.time()
[16:20:48.106]             {
[16:20:48.106]                 {
[16:20:48.106]                   {
[16:20:48.106]                     {
[16:20:48.106]                       base::local({
[16:20:48.106]                         has_future <- base::requireNamespace("future", 
[16:20:48.106]                           quietly = TRUE)
[16:20:48.106]                         if (has_future) {
[16:20:48.106]                           ns <- base::getNamespace("future")
[16:20:48.106]                           version <- ns[[".package"]][["version"]]
[16:20:48.106]                           if (is.null(version)) 
[16:20:48.106]                             version <- utils::packageVersion("future")
[16:20:48.106]                         }
[16:20:48.106]                         else {
[16:20:48.106]                           version <- NULL
[16:20:48.106]                         }
[16:20:48.106]                         if (!has_future || version < "1.8.0") {
[16:20:48.106]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.106]                             "", base::R.version$version.string), 
[16:20:48.106]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:48.106]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:48.106]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.106]                               "release", "version")], collapse = " "), 
[16:20:48.106]                             hostname = base::Sys.info()[["nodename"]])
[16:20:48.106]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.106]                             info)
[16:20:48.106]                           info <- base::paste(info, collapse = "; ")
[16:20:48.106]                           if (!has_future) {
[16:20:48.106]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.106]                               info)
[16:20:48.106]                           }
[16:20:48.106]                           else {
[16:20:48.106]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.106]                               info, version)
[16:20:48.106]                           }
[16:20:48.106]                           base::stop(msg)
[16:20:48.106]                         }
[16:20:48.106]                       })
[16:20:48.106]                     }
[16:20:48.106]                     base::local({
[16:20:48.106]                       for (pkg in "stats") {
[16:20:48.106]                         base::loadNamespace(pkg)
[16:20:48.106]                         base::library(pkg, character.only = TRUE)
[16:20:48.106]                       }
[16:20:48.106]                     })
[16:20:48.106]                   }
[16:20:48.106]                   ...future.strategy.old <- future::plan("list")
[16:20:48.106]                   options(future.plan = NULL)
[16:20:48.106]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.106]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.106]                 }
[16:20:48.106]                 ...future.workdir <- getwd()
[16:20:48.106]             }
[16:20:48.106]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.106]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.106]         }
[16:20:48.106]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.106]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.106]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.106]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.106]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.106]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.106]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.106]             base::names(...future.oldOptions))
[16:20:48.106]     }
[16:20:48.106]     if (FALSE) {
[16:20:48.106]     }
[16:20:48.106]     else {
[16:20:48.106]         if (TRUE) {
[16:20:48.106]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.106]                 open = "w")
[16:20:48.106]         }
[16:20:48.106]         else {
[16:20:48.106]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.106]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.106]         }
[16:20:48.106]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.106]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.106]             base::sink(type = "output", split = FALSE)
[16:20:48.106]             base::close(...future.stdout)
[16:20:48.106]         }, add = TRUE)
[16:20:48.106]     }
[16:20:48.106]     ...future.frame <- base::sys.nframe()
[16:20:48.106]     ...future.conditions <- base::list()
[16:20:48.106]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.106]     if (FALSE) {
[16:20:48.106]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.106]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.106]     }
[16:20:48.106]     ...future.result <- base::tryCatch({
[16:20:48.106]         base::withCallingHandlers({
[16:20:48.106]             ...future.value <- base::withVisible(base::local({
[16:20:48.106]                 lm(weight ~ group - 1)
[16:20:48.106]             }))
[16:20:48.106]             future::FutureResult(value = ...future.value$value, 
[16:20:48.106]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.106]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.106]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.106]                     ...future.globalenv.names))
[16:20:48.106]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.106]         }, condition = base::local({
[16:20:48.106]             c <- base::c
[16:20:48.106]             inherits <- base::inherits
[16:20:48.106]             invokeRestart <- base::invokeRestart
[16:20:48.106]             length <- base::length
[16:20:48.106]             list <- base::list
[16:20:48.106]             seq.int <- base::seq.int
[16:20:48.106]             signalCondition <- base::signalCondition
[16:20:48.106]             sys.calls <- base::sys.calls
[16:20:48.106]             `[[` <- base::`[[`
[16:20:48.106]             `+` <- base::`+`
[16:20:48.106]             `<<-` <- base::`<<-`
[16:20:48.106]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.106]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.106]                   3L)]
[16:20:48.106]             }
[16:20:48.106]             function(cond) {
[16:20:48.106]                 is_error <- inherits(cond, "error")
[16:20:48.106]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.106]                   NULL)
[16:20:48.106]                 if (is_error) {
[16:20:48.106]                   sessionInformation <- function() {
[16:20:48.106]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.106]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.106]                       search = base::search(), system = base::Sys.info())
[16:20:48.106]                   }
[16:20:48.106]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.106]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.106]                     cond$call), session = sessionInformation(), 
[16:20:48.106]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.106]                   signalCondition(cond)
[16:20:48.106]                 }
[16:20:48.106]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.106]                 "immediateCondition"))) {
[16:20:48.106]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.106]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.106]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.106]                   if (TRUE && !signal) {
[16:20:48.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.106]                     {
[16:20:48.106]                       inherits <- base::inherits
[16:20:48.106]                       invokeRestart <- base::invokeRestart
[16:20:48.106]                       is.null <- base::is.null
[16:20:48.106]                       muffled <- FALSE
[16:20:48.106]                       if (inherits(cond, "message")) {
[16:20:48.106]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.106]                         if (muffled) 
[16:20:48.106]                           invokeRestart("muffleMessage")
[16:20:48.106]                       }
[16:20:48.106]                       else if (inherits(cond, "warning")) {
[16:20:48.106]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.106]                         if (muffled) 
[16:20:48.106]                           invokeRestart("muffleWarning")
[16:20:48.106]                       }
[16:20:48.106]                       else if (inherits(cond, "condition")) {
[16:20:48.106]                         if (!is.null(pattern)) {
[16:20:48.106]                           computeRestarts <- base::computeRestarts
[16:20:48.106]                           grepl <- base::grepl
[16:20:48.106]                           restarts <- computeRestarts(cond)
[16:20:48.106]                           for (restart in restarts) {
[16:20:48.106]                             name <- restart$name
[16:20:48.106]                             if (is.null(name)) 
[16:20:48.106]                               next
[16:20:48.106]                             if (!grepl(pattern, name)) 
[16:20:48.106]                               next
[16:20:48.106]                             invokeRestart(restart)
[16:20:48.106]                             muffled <- TRUE
[16:20:48.106]                             break
[16:20:48.106]                           }
[16:20:48.106]                         }
[16:20:48.106]                       }
[16:20:48.106]                       invisible(muffled)
[16:20:48.106]                     }
[16:20:48.106]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.106]                   }
[16:20:48.106]                 }
[16:20:48.106]                 else {
[16:20:48.106]                   if (TRUE) {
[16:20:48.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.106]                     {
[16:20:48.106]                       inherits <- base::inherits
[16:20:48.106]                       invokeRestart <- base::invokeRestart
[16:20:48.106]                       is.null <- base::is.null
[16:20:48.106]                       muffled <- FALSE
[16:20:48.106]                       if (inherits(cond, "message")) {
[16:20:48.106]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.106]                         if (muffled) 
[16:20:48.106]                           invokeRestart("muffleMessage")
[16:20:48.106]                       }
[16:20:48.106]                       else if (inherits(cond, "warning")) {
[16:20:48.106]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.106]                         if (muffled) 
[16:20:48.106]                           invokeRestart("muffleWarning")
[16:20:48.106]                       }
[16:20:48.106]                       else if (inherits(cond, "condition")) {
[16:20:48.106]                         if (!is.null(pattern)) {
[16:20:48.106]                           computeRestarts <- base::computeRestarts
[16:20:48.106]                           grepl <- base::grepl
[16:20:48.106]                           restarts <- computeRestarts(cond)
[16:20:48.106]                           for (restart in restarts) {
[16:20:48.106]                             name <- restart$name
[16:20:48.106]                             if (is.null(name)) 
[16:20:48.106]                               next
[16:20:48.106]                             if (!grepl(pattern, name)) 
[16:20:48.106]                               next
[16:20:48.106]                             invokeRestart(restart)
[16:20:48.106]                             muffled <- TRUE
[16:20:48.106]                             break
[16:20:48.106]                           }
[16:20:48.106]                         }
[16:20:48.106]                       }
[16:20:48.106]                       invisible(muffled)
[16:20:48.106]                     }
[16:20:48.106]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.106]                   }
[16:20:48.106]                 }
[16:20:48.106]             }
[16:20:48.106]         }))
[16:20:48.106]     }, error = function(ex) {
[16:20:48.106]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.106]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.106]                 ...future.rng), started = ...future.startTime, 
[16:20:48.106]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.106]             version = "1.8"), class = "FutureResult")
[16:20:48.106]     }, finally = {
[16:20:48.106]         if (!identical(...future.workdir, getwd())) 
[16:20:48.106]             setwd(...future.workdir)
[16:20:48.106]         {
[16:20:48.106]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.106]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.106]             }
[16:20:48.106]             base::options(...future.oldOptions)
[16:20:48.106]             if (.Platform$OS.type == "windows") {
[16:20:48.106]                 old_names <- names(...future.oldEnvVars)
[16:20:48.106]                 envs <- base::Sys.getenv()
[16:20:48.106]                 names <- names(envs)
[16:20:48.106]                 common <- intersect(names, old_names)
[16:20:48.106]                 added <- setdiff(names, old_names)
[16:20:48.106]                 removed <- setdiff(old_names, names)
[16:20:48.106]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.106]                   envs[common]]
[16:20:48.106]                 NAMES <- toupper(changed)
[16:20:48.106]                 args <- list()
[16:20:48.106]                 for (kk in seq_along(NAMES)) {
[16:20:48.106]                   name <- changed[[kk]]
[16:20:48.106]                   NAME <- NAMES[[kk]]
[16:20:48.106]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.106]                     next
[16:20:48.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.106]                 }
[16:20:48.106]                 NAMES <- toupper(added)
[16:20:48.106]                 for (kk in seq_along(NAMES)) {
[16:20:48.106]                   name <- added[[kk]]
[16:20:48.106]                   NAME <- NAMES[[kk]]
[16:20:48.106]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.106]                     next
[16:20:48.106]                   args[[name]] <- ""
[16:20:48.106]                 }
[16:20:48.106]                 NAMES <- toupper(removed)
[16:20:48.106]                 for (kk in seq_along(NAMES)) {
[16:20:48.106]                   name <- removed[[kk]]
[16:20:48.106]                   NAME <- NAMES[[kk]]
[16:20:48.106]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.106]                     next
[16:20:48.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.106]                 }
[16:20:48.106]                 if (length(args) > 0) 
[16:20:48.106]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.106]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.106]             }
[16:20:48.106]             else {
[16:20:48.106]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.106]             }
[16:20:48.106]             {
[16:20:48.106]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.106]                   0L) {
[16:20:48.106]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.106]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.106]                   base::options(opts)
[16:20:48.106]                 }
[16:20:48.106]                 {
[16:20:48.106]                   {
[16:20:48.106]                     NULL
[16:20:48.106]                     RNGkind("Mersenne-Twister")
[16:20:48.106]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:48.106]                       inherits = FALSE)
[16:20:48.106]                   }
[16:20:48.106]                   options(future.plan = NULL)
[16:20:48.106]                   if (is.na(NA_character_)) 
[16:20:48.106]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.106]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.106]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.106]                     .init = FALSE)
[16:20:48.106]                 }
[16:20:48.106]             }
[16:20:48.106]         }
[16:20:48.106]     })
[16:20:48.106]     if (TRUE) {
[16:20:48.106]         base::sink(type = "output", split = FALSE)
[16:20:48.106]         if (TRUE) {
[16:20:48.106]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.106]         }
[16:20:48.106]         else {
[16:20:48.106]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.106]         }
[16:20:48.106]         base::close(...future.stdout)
[16:20:48.106]         ...future.stdout <- NULL
[16:20:48.106]     }
[16:20:48.106]     ...future.result$conditions <- ...future.conditions
[16:20:48.106]     ...future.result$finished <- base::Sys.time()
[16:20:48.106]     ...future.result
[16:20:48.106] }
[16:20:48.108] assign_globals() ...
[16:20:48.108] List of 2
[16:20:48.108]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:20:48.108]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:20:48.108]  - attr(*, "where")=List of 2
[16:20:48.108]   ..$ weight:<environment: R_EmptyEnv> 
[16:20:48.108]   ..$ group :<environment: R_EmptyEnv> 
[16:20:48.108]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:48.108]  - attr(*, "resolved")= logi FALSE
[16:20:48.108]  - attr(*, "total_size")= num 896
[16:20:48.108]  - attr(*, "already-done")= logi TRUE
[16:20:48.111] - copied ‘weight’ to environment
[16:20:48.111] - copied ‘group’ to environment
[16:20:48.111] assign_globals() ... done
[16:20:48.112] plan(): Setting new future strategy stack:
[16:20:48.112] List of future strategies:
[16:20:48.112] 1. sequential:
[16:20:48.112]    - args: function (..., envir = parent.frame())
[16:20:48.112]    - tweaked: FALSE
[16:20:48.112]    - call: NULL
[16:20:48.112] plan(): nbrOfWorkers() = 1
[16:20:48.113] plan(): Setting new future strategy stack:
[16:20:48.114] List of future strategies:
[16:20:48.114] 1. sequential:
[16:20:48.114]    - args: function (..., envir = parent.frame())
[16:20:48.114]    - tweaked: FALSE
[16:20:48.114]    - call: plan(strategy)
[16:20:48.114] plan(): nbrOfWorkers() = 1
[16:20:48.114] SequentialFuture started (and completed)
[16:20:48.114] - Launch lazy future ... done
[16:20:48.114] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:20:48.116] getGlobalsAndPackages() ...
[16:20:48.116] Searching for globals...
[16:20:48.118] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:20:48.118] Searching for globals ... DONE
[16:20:48.118] Resolving globals: FALSE
[16:20:48.118] The total size of the 2 globals is 896 bytes (896 bytes)
[16:20:48.119] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:20:48.119] - globals: [2] ‘weight’, ‘group’
[16:20:48.119] - packages: [1] ‘stats’
[16:20:48.119] getGlobalsAndPackages() ... DONE
[16:20:48.119] run() for ‘Future’ ...
[16:20:48.119] - state: ‘created’
[16:20:48.119] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:48.120] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:48.120] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:48.120]   - Field: ‘label’
[16:20:48.120]   - Field: ‘local’
[16:20:48.120]   - Field: ‘owner’
[16:20:48.120]   - Field: ‘envir’
[16:20:48.120]   - Field: ‘packages’
[16:20:48.120]   - Field: ‘gc’
[16:20:48.121]   - Field: ‘conditions’
[16:20:48.121]   - Field: ‘expr’
[16:20:48.121]   - Field: ‘uuid’
[16:20:48.121]   - Field: ‘seed’
[16:20:48.121]   - Field: ‘version’
[16:20:48.121]   - Field: ‘result’
[16:20:48.121]   - Field: ‘asynchronous’
[16:20:48.121]   - Field: ‘calls’
[16:20:48.121]   - Field: ‘globals’
[16:20:48.121]   - Field: ‘stdout’
[16:20:48.121]   - Field: ‘earlySignal’
[16:20:48.122]   - Field: ‘lazy’
[16:20:48.122]   - Field: ‘state’
[16:20:48.122] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:48.122] - Launch lazy future ...
[16:20:48.122] Packages needed by the future expression (n = 1): ‘stats’
[16:20:48.122] Packages needed by future strategies (n = 0): <none>
[16:20:48.123] {
[16:20:48.123]     {
[16:20:48.123]         {
[16:20:48.123]             ...future.startTime <- base::Sys.time()
[16:20:48.123]             {
[16:20:48.123]                 {
[16:20:48.123]                   {
[16:20:48.123]                     {
[16:20:48.123]                       base::local({
[16:20:48.123]                         has_future <- base::requireNamespace("future", 
[16:20:48.123]                           quietly = TRUE)
[16:20:48.123]                         if (has_future) {
[16:20:48.123]                           ns <- base::getNamespace("future")
[16:20:48.123]                           version <- ns[[".package"]][["version"]]
[16:20:48.123]                           if (is.null(version)) 
[16:20:48.123]                             version <- utils::packageVersion("future")
[16:20:48.123]                         }
[16:20:48.123]                         else {
[16:20:48.123]                           version <- NULL
[16:20:48.123]                         }
[16:20:48.123]                         if (!has_future || version < "1.8.0") {
[16:20:48.123]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.123]                             "", base::R.version$version.string), 
[16:20:48.123]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:48.123]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:48.123]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.123]                               "release", "version")], collapse = " "), 
[16:20:48.123]                             hostname = base::Sys.info()[["nodename"]])
[16:20:48.123]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.123]                             info)
[16:20:48.123]                           info <- base::paste(info, collapse = "; ")
[16:20:48.123]                           if (!has_future) {
[16:20:48.123]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.123]                               info)
[16:20:48.123]                           }
[16:20:48.123]                           else {
[16:20:48.123]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.123]                               info, version)
[16:20:48.123]                           }
[16:20:48.123]                           base::stop(msg)
[16:20:48.123]                         }
[16:20:48.123]                       })
[16:20:48.123]                     }
[16:20:48.123]                     base::local({
[16:20:48.123]                       for (pkg in "stats") {
[16:20:48.123]                         base::loadNamespace(pkg)
[16:20:48.123]                         base::library(pkg, character.only = TRUE)
[16:20:48.123]                       }
[16:20:48.123]                     })
[16:20:48.123]                   }
[16:20:48.123]                   ...future.strategy.old <- future::plan("list")
[16:20:48.123]                   options(future.plan = NULL)
[16:20:48.123]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.123]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.123]                 }
[16:20:48.123]                 ...future.workdir <- getwd()
[16:20:48.123]             }
[16:20:48.123]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.123]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.123]         }
[16:20:48.123]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.123]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.123]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.123]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.123]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.123]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.123]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.123]             base::names(...future.oldOptions))
[16:20:48.123]     }
[16:20:48.123]     if (FALSE) {
[16:20:48.123]     }
[16:20:48.123]     else {
[16:20:48.123]         if (TRUE) {
[16:20:48.123]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.123]                 open = "w")
[16:20:48.123]         }
[16:20:48.123]         else {
[16:20:48.123]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.123]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.123]         }
[16:20:48.123]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.123]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.123]             base::sink(type = "output", split = FALSE)
[16:20:48.123]             base::close(...future.stdout)
[16:20:48.123]         }, add = TRUE)
[16:20:48.123]     }
[16:20:48.123]     ...future.frame <- base::sys.nframe()
[16:20:48.123]     ...future.conditions <- base::list()
[16:20:48.123]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.123]     if (FALSE) {
[16:20:48.123]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.123]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.123]     }
[16:20:48.123]     ...future.result <- base::tryCatch({
[16:20:48.123]         base::withCallingHandlers({
[16:20:48.123]             ...future.value <- base::withVisible(base::local({
[16:20:48.123]                 lm(weight ~ group - 1)
[16:20:48.123]             }))
[16:20:48.123]             future::FutureResult(value = ...future.value$value, 
[16:20:48.123]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.123]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.123]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.123]                     ...future.globalenv.names))
[16:20:48.123]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.123]         }, condition = base::local({
[16:20:48.123]             c <- base::c
[16:20:48.123]             inherits <- base::inherits
[16:20:48.123]             invokeRestart <- base::invokeRestart
[16:20:48.123]             length <- base::length
[16:20:48.123]             list <- base::list
[16:20:48.123]             seq.int <- base::seq.int
[16:20:48.123]             signalCondition <- base::signalCondition
[16:20:48.123]             sys.calls <- base::sys.calls
[16:20:48.123]             `[[` <- base::`[[`
[16:20:48.123]             `+` <- base::`+`
[16:20:48.123]             `<<-` <- base::`<<-`
[16:20:48.123]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.123]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.123]                   3L)]
[16:20:48.123]             }
[16:20:48.123]             function(cond) {
[16:20:48.123]                 is_error <- inherits(cond, "error")
[16:20:48.123]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.123]                   NULL)
[16:20:48.123]                 if (is_error) {
[16:20:48.123]                   sessionInformation <- function() {
[16:20:48.123]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.123]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.123]                       search = base::search(), system = base::Sys.info())
[16:20:48.123]                   }
[16:20:48.123]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.123]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.123]                     cond$call), session = sessionInformation(), 
[16:20:48.123]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.123]                   signalCondition(cond)
[16:20:48.123]                 }
[16:20:48.123]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.123]                 "immediateCondition"))) {
[16:20:48.123]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.123]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.123]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.123]                   if (TRUE && !signal) {
[16:20:48.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.123]                     {
[16:20:48.123]                       inherits <- base::inherits
[16:20:48.123]                       invokeRestart <- base::invokeRestart
[16:20:48.123]                       is.null <- base::is.null
[16:20:48.123]                       muffled <- FALSE
[16:20:48.123]                       if (inherits(cond, "message")) {
[16:20:48.123]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.123]                         if (muffled) 
[16:20:48.123]                           invokeRestart("muffleMessage")
[16:20:48.123]                       }
[16:20:48.123]                       else if (inherits(cond, "warning")) {
[16:20:48.123]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.123]                         if (muffled) 
[16:20:48.123]                           invokeRestart("muffleWarning")
[16:20:48.123]                       }
[16:20:48.123]                       else if (inherits(cond, "condition")) {
[16:20:48.123]                         if (!is.null(pattern)) {
[16:20:48.123]                           computeRestarts <- base::computeRestarts
[16:20:48.123]                           grepl <- base::grepl
[16:20:48.123]                           restarts <- computeRestarts(cond)
[16:20:48.123]                           for (restart in restarts) {
[16:20:48.123]                             name <- restart$name
[16:20:48.123]                             if (is.null(name)) 
[16:20:48.123]                               next
[16:20:48.123]                             if (!grepl(pattern, name)) 
[16:20:48.123]                               next
[16:20:48.123]                             invokeRestart(restart)
[16:20:48.123]                             muffled <- TRUE
[16:20:48.123]                             break
[16:20:48.123]                           }
[16:20:48.123]                         }
[16:20:48.123]                       }
[16:20:48.123]                       invisible(muffled)
[16:20:48.123]                     }
[16:20:48.123]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.123]                   }
[16:20:48.123]                 }
[16:20:48.123]                 else {
[16:20:48.123]                   if (TRUE) {
[16:20:48.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.123]                     {
[16:20:48.123]                       inherits <- base::inherits
[16:20:48.123]                       invokeRestart <- base::invokeRestart
[16:20:48.123]                       is.null <- base::is.null
[16:20:48.123]                       muffled <- FALSE
[16:20:48.123]                       if (inherits(cond, "message")) {
[16:20:48.123]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.123]                         if (muffled) 
[16:20:48.123]                           invokeRestart("muffleMessage")
[16:20:48.123]                       }
[16:20:48.123]                       else if (inherits(cond, "warning")) {
[16:20:48.123]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.123]                         if (muffled) 
[16:20:48.123]                           invokeRestart("muffleWarning")
[16:20:48.123]                       }
[16:20:48.123]                       else if (inherits(cond, "condition")) {
[16:20:48.123]                         if (!is.null(pattern)) {
[16:20:48.123]                           computeRestarts <- base::computeRestarts
[16:20:48.123]                           grepl <- base::grepl
[16:20:48.123]                           restarts <- computeRestarts(cond)
[16:20:48.123]                           for (restart in restarts) {
[16:20:48.123]                             name <- restart$name
[16:20:48.123]                             if (is.null(name)) 
[16:20:48.123]                               next
[16:20:48.123]                             if (!grepl(pattern, name)) 
[16:20:48.123]                               next
[16:20:48.123]                             invokeRestart(restart)
[16:20:48.123]                             muffled <- TRUE
[16:20:48.123]                             break
[16:20:48.123]                           }
[16:20:48.123]                         }
[16:20:48.123]                       }
[16:20:48.123]                       invisible(muffled)
[16:20:48.123]                     }
[16:20:48.123]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.123]                   }
[16:20:48.123]                 }
[16:20:48.123]             }
[16:20:48.123]         }))
[16:20:48.123]     }, error = function(ex) {
[16:20:48.123]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.123]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.123]                 ...future.rng), started = ...future.startTime, 
[16:20:48.123]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.123]             version = "1.8"), class = "FutureResult")
[16:20:48.123]     }, finally = {
[16:20:48.123]         if (!identical(...future.workdir, getwd())) 
[16:20:48.123]             setwd(...future.workdir)
[16:20:48.123]         {
[16:20:48.123]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.123]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.123]             }
[16:20:48.123]             base::options(...future.oldOptions)
[16:20:48.123]             if (.Platform$OS.type == "windows") {
[16:20:48.123]                 old_names <- names(...future.oldEnvVars)
[16:20:48.123]                 envs <- base::Sys.getenv()
[16:20:48.123]                 names <- names(envs)
[16:20:48.123]                 common <- intersect(names, old_names)
[16:20:48.123]                 added <- setdiff(names, old_names)
[16:20:48.123]                 removed <- setdiff(old_names, names)
[16:20:48.123]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.123]                   envs[common]]
[16:20:48.123]                 NAMES <- toupper(changed)
[16:20:48.123]                 args <- list()
[16:20:48.123]                 for (kk in seq_along(NAMES)) {
[16:20:48.123]                   name <- changed[[kk]]
[16:20:48.123]                   NAME <- NAMES[[kk]]
[16:20:48.123]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.123]                     next
[16:20:48.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.123]                 }
[16:20:48.123]                 NAMES <- toupper(added)
[16:20:48.123]                 for (kk in seq_along(NAMES)) {
[16:20:48.123]                   name <- added[[kk]]
[16:20:48.123]                   NAME <- NAMES[[kk]]
[16:20:48.123]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.123]                     next
[16:20:48.123]                   args[[name]] <- ""
[16:20:48.123]                 }
[16:20:48.123]                 NAMES <- toupper(removed)
[16:20:48.123]                 for (kk in seq_along(NAMES)) {
[16:20:48.123]                   name <- removed[[kk]]
[16:20:48.123]                   NAME <- NAMES[[kk]]
[16:20:48.123]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.123]                     next
[16:20:48.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.123]                 }
[16:20:48.123]                 if (length(args) > 0) 
[16:20:48.123]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.123]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.123]             }
[16:20:48.123]             else {
[16:20:48.123]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.123]             }
[16:20:48.123]             {
[16:20:48.123]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.123]                   0L) {
[16:20:48.123]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.123]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.123]                   base::options(opts)
[16:20:48.123]                 }
[16:20:48.123]                 {
[16:20:48.123]                   {
[16:20:48.123]                     NULL
[16:20:48.123]                     RNGkind("Mersenne-Twister")
[16:20:48.123]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:48.123]                       inherits = FALSE)
[16:20:48.123]                   }
[16:20:48.123]                   options(future.plan = NULL)
[16:20:48.123]                   if (is.na(NA_character_)) 
[16:20:48.123]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.123]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.123]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.123]                     .init = FALSE)
[16:20:48.123]                 }
[16:20:48.123]             }
[16:20:48.123]         }
[16:20:48.123]     })
[16:20:48.123]     if (TRUE) {
[16:20:48.123]         base::sink(type = "output", split = FALSE)
[16:20:48.123]         if (TRUE) {
[16:20:48.123]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.123]         }
[16:20:48.123]         else {
[16:20:48.123]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.123]         }
[16:20:48.123]         base::close(...future.stdout)
[16:20:48.123]         ...future.stdout <- NULL
[16:20:48.123]     }
[16:20:48.123]     ...future.result$conditions <- ...future.conditions
[16:20:48.123]     ...future.result$finished <- base::Sys.time()
[16:20:48.123]     ...future.result
[16:20:48.123] }
[16:20:48.124] assign_globals() ...
[16:20:48.124] List of 2
[16:20:48.124]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:20:48.124]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:20:48.124]  - attr(*, "where")=List of 2
[16:20:48.124]   ..$ weight:<environment: R_EmptyEnv> 
[16:20:48.124]   ..$ group :<environment: R_EmptyEnv> 
[16:20:48.124]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:48.124]  - attr(*, "resolved")= logi FALSE
[16:20:48.124]  - attr(*, "total_size")= num 896
[16:20:48.124]  - attr(*, "already-done")= logi TRUE
[16:20:48.127] - copied ‘weight’ to environment
[16:20:48.127] - copied ‘group’ to environment
[16:20:48.127] assign_globals() ... done
[16:20:48.128] plan(): Setting new future strategy stack:
[16:20:48.128] List of future strategies:
[16:20:48.128] 1. sequential:
[16:20:48.128]    - args: function (..., envir = parent.frame())
[16:20:48.128]    - tweaked: FALSE
[16:20:48.128]    - call: NULL
[16:20:48.128] plan(): nbrOfWorkers() = 1
[16:20:48.130] plan(): Setting new future strategy stack:
[16:20:48.130] List of future strategies:
[16:20:48.130] 1. sequential:
[16:20:48.130]    - args: function (..., envir = parent.frame())
[16:20:48.130]    - tweaked: FALSE
[16:20:48.130]    - call: plan(strategy)
[16:20:48.130] plan(): nbrOfWorkers() = 1
[16:20:48.130] SequentialFuture started (and completed)
[16:20:48.130] - Launch lazy future ... done
[16:20:48.130] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:20:48.134] getGlobalsAndPackages() ...
[16:20:48.134] Searching for globals...
[16:20:48.135] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:20:48.135] Searching for globals ... DONE
[16:20:48.135] Resolving globals: FALSE
[16:20:48.136] The total size of the 2 globals is 896 bytes (896 bytes)
[16:20:48.136] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:20:48.136] - globals: [2] ‘weight’, ‘group’
[16:20:48.136] - packages: [1] ‘stats’
[16:20:48.136] getGlobalsAndPackages() ... DONE
[16:20:48.137] run() for ‘Future’ ...
[16:20:48.137] - state: ‘created’
[16:20:48.137] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:48.137] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:48.137] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:48.137]   - Field: ‘label’
[16:20:48.137]   - Field: ‘local’
[16:20:48.138]   - Field: ‘owner’
[16:20:48.138]   - Field: ‘envir’
[16:20:48.138]   - Field: ‘packages’
[16:20:48.138]   - Field: ‘gc’
[16:20:48.138]   - Field: ‘conditions’
[16:20:48.138]   - Field: ‘expr’
[16:20:48.138]   - Field: ‘uuid’
[16:20:48.138]   - Field: ‘seed’
[16:20:48.138]   - Field: ‘version’
[16:20:48.138]   - Field: ‘result’
[16:20:48.139]   - Field: ‘asynchronous’
[16:20:48.139]   - Field: ‘calls’
[16:20:48.139]   - Field: ‘globals’
[16:20:48.139]   - Field: ‘stdout’
[16:20:48.139]   - Field: ‘earlySignal’
[16:20:48.139]   - Field: ‘lazy’
[16:20:48.139]   - Field: ‘state’
[16:20:48.139] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:48.139] - Launch lazy future ...
[16:20:48.139] Packages needed by the future expression (n = 1): ‘stats’
[16:20:48.140] Packages needed by future strategies (n = 0): <none>
[16:20:48.140] {
[16:20:48.140]     {
[16:20:48.140]         {
[16:20:48.140]             ...future.startTime <- base::Sys.time()
[16:20:48.140]             {
[16:20:48.140]                 {
[16:20:48.140]                   {
[16:20:48.140]                     {
[16:20:48.140]                       base::local({
[16:20:48.140]                         has_future <- base::requireNamespace("future", 
[16:20:48.140]                           quietly = TRUE)
[16:20:48.140]                         if (has_future) {
[16:20:48.140]                           ns <- base::getNamespace("future")
[16:20:48.140]                           version <- ns[[".package"]][["version"]]
[16:20:48.140]                           if (is.null(version)) 
[16:20:48.140]                             version <- utils::packageVersion("future")
[16:20:48.140]                         }
[16:20:48.140]                         else {
[16:20:48.140]                           version <- NULL
[16:20:48.140]                         }
[16:20:48.140]                         if (!has_future || version < "1.8.0") {
[16:20:48.140]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.140]                             "", base::R.version$version.string), 
[16:20:48.140]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:48.140]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:48.140]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.140]                               "release", "version")], collapse = " "), 
[16:20:48.140]                             hostname = base::Sys.info()[["nodename"]])
[16:20:48.140]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.140]                             info)
[16:20:48.140]                           info <- base::paste(info, collapse = "; ")
[16:20:48.140]                           if (!has_future) {
[16:20:48.140]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.140]                               info)
[16:20:48.140]                           }
[16:20:48.140]                           else {
[16:20:48.140]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.140]                               info, version)
[16:20:48.140]                           }
[16:20:48.140]                           base::stop(msg)
[16:20:48.140]                         }
[16:20:48.140]                       })
[16:20:48.140]                     }
[16:20:48.140]                     base::local({
[16:20:48.140]                       for (pkg in "stats") {
[16:20:48.140]                         base::loadNamespace(pkg)
[16:20:48.140]                         base::library(pkg, character.only = TRUE)
[16:20:48.140]                       }
[16:20:48.140]                     })
[16:20:48.140]                   }
[16:20:48.140]                   ...future.strategy.old <- future::plan("list")
[16:20:48.140]                   options(future.plan = NULL)
[16:20:48.140]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.140]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.140]                 }
[16:20:48.140]                 ...future.workdir <- getwd()
[16:20:48.140]             }
[16:20:48.140]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.140]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.140]         }
[16:20:48.140]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.140]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.140]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.140]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.140]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.140]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.140]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.140]             base::names(...future.oldOptions))
[16:20:48.140]     }
[16:20:48.140]     if (FALSE) {
[16:20:48.140]     }
[16:20:48.140]     else {
[16:20:48.140]         if (TRUE) {
[16:20:48.140]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.140]                 open = "w")
[16:20:48.140]         }
[16:20:48.140]         else {
[16:20:48.140]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.140]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.140]         }
[16:20:48.140]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.140]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.140]             base::sink(type = "output", split = FALSE)
[16:20:48.140]             base::close(...future.stdout)
[16:20:48.140]         }, add = TRUE)
[16:20:48.140]     }
[16:20:48.140]     ...future.frame <- base::sys.nframe()
[16:20:48.140]     ...future.conditions <- base::list()
[16:20:48.140]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.140]     if (FALSE) {
[16:20:48.140]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.140]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.140]     }
[16:20:48.140]     ...future.result <- base::tryCatch({
[16:20:48.140]         base::withCallingHandlers({
[16:20:48.140]             ...future.value <- base::withVisible(base::local({
[16:20:48.140]                 lm(weight ~ group - 1)
[16:20:48.140]             }))
[16:20:48.140]             future::FutureResult(value = ...future.value$value, 
[16:20:48.140]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.140]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.140]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.140]                     ...future.globalenv.names))
[16:20:48.140]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.140]         }, condition = base::local({
[16:20:48.140]             c <- base::c
[16:20:48.140]             inherits <- base::inherits
[16:20:48.140]             invokeRestart <- base::invokeRestart
[16:20:48.140]             length <- base::length
[16:20:48.140]             list <- base::list
[16:20:48.140]             seq.int <- base::seq.int
[16:20:48.140]             signalCondition <- base::signalCondition
[16:20:48.140]             sys.calls <- base::sys.calls
[16:20:48.140]             `[[` <- base::`[[`
[16:20:48.140]             `+` <- base::`+`
[16:20:48.140]             `<<-` <- base::`<<-`
[16:20:48.140]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.140]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.140]                   3L)]
[16:20:48.140]             }
[16:20:48.140]             function(cond) {
[16:20:48.140]                 is_error <- inherits(cond, "error")
[16:20:48.140]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.140]                   NULL)
[16:20:48.140]                 if (is_error) {
[16:20:48.140]                   sessionInformation <- function() {
[16:20:48.140]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.140]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.140]                       search = base::search(), system = base::Sys.info())
[16:20:48.140]                   }
[16:20:48.140]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.140]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.140]                     cond$call), session = sessionInformation(), 
[16:20:48.140]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.140]                   signalCondition(cond)
[16:20:48.140]                 }
[16:20:48.140]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.140]                 "immediateCondition"))) {
[16:20:48.140]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.140]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.140]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.140]                   if (TRUE && !signal) {
[16:20:48.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.140]                     {
[16:20:48.140]                       inherits <- base::inherits
[16:20:48.140]                       invokeRestart <- base::invokeRestart
[16:20:48.140]                       is.null <- base::is.null
[16:20:48.140]                       muffled <- FALSE
[16:20:48.140]                       if (inherits(cond, "message")) {
[16:20:48.140]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.140]                         if (muffled) 
[16:20:48.140]                           invokeRestart("muffleMessage")
[16:20:48.140]                       }
[16:20:48.140]                       else if (inherits(cond, "warning")) {
[16:20:48.140]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.140]                         if (muffled) 
[16:20:48.140]                           invokeRestart("muffleWarning")
[16:20:48.140]                       }
[16:20:48.140]                       else if (inherits(cond, "condition")) {
[16:20:48.140]                         if (!is.null(pattern)) {
[16:20:48.140]                           computeRestarts <- base::computeRestarts
[16:20:48.140]                           grepl <- base::grepl
[16:20:48.140]                           restarts <- computeRestarts(cond)
[16:20:48.140]                           for (restart in restarts) {
[16:20:48.140]                             name <- restart$name
[16:20:48.140]                             if (is.null(name)) 
[16:20:48.140]                               next
[16:20:48.140]                             if (!grepl(pattern, name)) 
[16:20:48.140]                               next
[16:20:48.140]                             invokeRestart(restart)
[16:20:48.140]                             muffled <- TRUE
[16:20:48.140]                             break
[16:20:48.140]                           }
[16:20:48.140]                         }
[16:20:48.140]                       }
[16:20:48.140]                       invisible(muffled)
[16:20:48.140]                     }
[16:20:48.140]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.140]                   }
[16:20:48.140]                 }
[16:20:48.140]                 else {
[16:20:48.140]                   if (TRUE) {
[16:20:48.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.140]                     {
[16:20:48.140]                       inherits <- base::inherits
[16:20:48.140]                       invokeRestart <- base::invokeRestart
[16:20:48.140]                       is.null <- base::is.null
[16:20:48.140]                       muffled <- FALSE
[16:20:48.140]                       if (inherits(cond, "message")) {
[16:20:48.140]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.140]                         if (muffled) 
[16:20:48.140]                           invokeRestart("muffleMessage")
[16:20:48.140]                       }
[16:20:48.140]                       else if (inherits(cond, "warning")) {
[16:20:48.140]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.140]                         if (muffled) 
[16:20:48.140]                           invokeRestart("muffleWarning")
[16:20:48.140]                       }
[16:20:48.140]                       else if (inherits(cond, "condition")) {
[16:20:48.140]                         if (!is.null(pattern)) {
[16:20:48.140]                           computeRestarts <- base::computeRestarts
[16:20:48.140]                           grepl <- base::grepl
[16:20:48.140]                           restarts <- computeRestarts(cond)
[16:20:48.140]                           for (restart in restarts) {
[16:20:48.140]                             name <- restart$name
[16:20:48.140]                             if (is.null(name)) 
[16:20:48.140]                               next
[16:20:48.140]                             if (!grepl(pattern, name)) 
[16:20:48.140]                               next
[16:20:48.140]                             invokeRestart(restart)
[16:20:48.140]                             muffled <- TRUE
[16:20:48.140]                             break
[16:20:48.140]                           }
[16:20:48.140]                         }
[16:20:48.140]                       }
[16:20:48.140]                       invisible(muffled)
[16:20:48.140]                     }
[16:20:48.140]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.140]                   }
[16:20:48.140]                 }
[16:20:48.140]             }
[16:20:48.140]         }))
[16:20:48.140]     }, error = function(ex) {
[16:20:48.140]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.140]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.140]                 ...future.rng), started = ...future.startTime, 
[16:20:48.140]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.140]             version = "1.8"), class = "FutureResult")
[16:20:48.140]     }, finally = {
[16:20:48.140]         if (!identical(...future.workdir, getwd())) 
[16:20:48.140]             setwd(...future.workdir)
[16:20:48.140]         {
[16:20:48.140]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.140]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.140]             }
[16:20:48.140]             base::options(...future.oldOptions)
[16:20:48.140]             if (.Platform$OS.type == "windows") {
[16:20:48.140]                 old_names <- names(...future.oldEnvVars)
[16:20:48.140]                 envs <- base::Sys.getenv()
[16:20:48.140]                 names <- names(envs)
[16:20:48.140]                 common <- intersect(names, old_names)
[16:20:48.140]                 added <- setdiff(names, old_names)
[16:20:48.140]                 removed <- setdiff(old_names, names)
[16:20:48.140]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.140]                   envs[common]]
[16:20:48.140]                 NAMES <- toupper(changed)
[16:20:48.140]                 args <- list()
[16:20:48.140]                 for (kk in seq_along(NAMES)) {
[16:20:48.140]                   name <- changed[[kk]]
[16:20:48.140]                   NAME <- NAMES[[kk]]
[16:20:48.140]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.140]                     next
[16:20:48.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.140]                 }
[16:20:48.140]                 NAMES <- toupper(added)
[16:20:48.140]                 for (kk in seq_along(NAMES)) {
[16:20:48.140]                   name <- added[[kk]]
[16:20:48.140]                   NAME <- NAMES[[kk]]
[16:20:48.140]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.140]                     next
[16:20:48.140]                   args[[name]] <- ""
[16:20:48.140]                 }
[16:20:48.140]                 NAMES <- toupper(removed)
[16:20:48.140]                 for (kk in seq_along(NAMES)) {
[16:20:48.140]                   name <- removed[[kk]]
[16:20:48.140]                   NAME <- NAMES[[kk]]
[16:20:48.140]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.140]                     next
[16:20:48.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.140]                 }
[16:20:48.140]                 if (length(args) > 0) 
[16:20:48.140]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.140]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.140]             }
[16:20:48.140]             else {
[16:20:48.140]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.140]             }
[16:20:48.140]             {
[16:20:48.140]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.140]                   0L) {
[16:20:48.140]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.140]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.140]                   base::options(opts)
[16:20:48.140]                 }
[16:20:48.140]                 {
[16:20:48.140]                   {
[16:20:48.140]                     NULL
[16:20:48.140]                     RNGkind("Mersenne-Twister")
[16:20:48.140]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:48.140]                       inherits = FALSE)
[16:20:48.140]                   }
[16:20:48.140]                   options(future.plan = NULL)
[16:20:48.140]                   if (is.na(NA_character_)) 
[16:20:48.140]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.140]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.140]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.140]                     .init = FALSE)
[16:20:48.140]                 }
[16:20:48.140]             }
[16:20:48.140]         }
[16:20:48.140]     })
[16:20:48.140]     if (TRUE) {
[16:20:48.140]         base::sink(type = "output", split = FALSE)
[16:20:48.140]         if (TRUE) {
[16:20:48.140]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.140]         }
[16:20:48.140]         else {
[16:20:48.140]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.140]         }
[16:20:48.140]         base::close(...future.stdout)
[16:20:48.140]         ...future.stdout <- NULL
[16:20:48.140]     }
[16:20:48.140]     ...future.result$conditions <- ...future.conditions
[16:20:48.140]     ...future.result$finished <- base::Sys.time()
[16:20:48.140]     ...future.result
[16:20:48.140] }
[16:20:48.142] assign_globals() ...
[16:20:48.142] List of 2
[16:20:48.142]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:20:48.142]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:20:48.142]  - attr(*, "where")=List of 2
[16:20:48.142]   ..$ weight:<environment: R_EmptyEnv> 
[16:20:48.142]   ..$ group :<environment: R_EmptyEnv> 
[16:20:48.142]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:48.142]  - attr(*, "resolved")= logi FALSE
[16:20:48.142]  - attr(*, "total_size")= num 896
[16:20:48.142]  - attr(*, "already-done")= logi TRUE
[16:20:48.145] - copied ‘weight’ to environment
[16:20:48.145] - copied ‘group’ to environment
[16:20:48.145] assign_globals() ... done
[16:20:48.145] plan(): Setting new future strategy stack:
[16:20:48.145] List of future strategies:
[16:20:48.145] 1. sequential:
[16:20:48.145]    - args: function (..., envir = parent.frame())
[16:20:48.145]    - tweaked: FALSE
[16:20:48.145]    - call: NULL
[16:20:48.146] plan(): nbrOfWorkers() = 1
[16:20:48.147] plan(): Setting new future strategy stack:
[16:20:48.147] List of future strategies:
[16:20:48.147] 1. sequential:
[16:20:48.147]    - args: function (..., envir = parent.frame())
[16:20:48.147]    - tweaked: FALSE
[16:20:48.147]    - call: plan(strategy)
[16:20:48.147] plan(): nbrOfWorkers() = 1
[16:20:48.147] SequentialFuture started (and completed)
[16:20:48.148] - Launch lazy future ... done
[16:20:48.148] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[16:20:48.149] getGlobalsAndPackages() ...
[16:20:48.149] Searching for globals...
[16:20:48.150] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[16:20:48.151] Searching for globals ... DONE
[16:20:48.151] Resolving globals: FALSE
[16:20:48.151] The total size of the 1 globals is 96 bytes (96 bytes)
[16:20:48.151] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[16:20:48.151] - globals: [1] ‘x’
[16:20:48.152] - packages: [1] ‘stats’
[16:20:48.152] getGlobalsAndPackages() ... DONE
[16:20:48.152] run() for ‘Future’ ...
[16:20:48.152] - state: ‘created’
[16:20:48.152] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:48.152] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:48.152] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:48.153]   - Field: ‘label’
[16:20:48.153]   - Field: ‘local’
[16:20:48.153]   - Field: ‘owner’
[16:20:48.153]   - Field: ‘envir’
[16:20:48.153]   - Field: ‘packages’
[16:20:48.153]   - Field: ‘gc’
[16:20:48.153]   - Field: ‘conditions’
[16:20:48.153]   - Field: ‘expr’
[16:20:48.153]   - Field: ‘uuid’
[16:20:48.153]   - Field: ‘seed’
[16:20:48.155]   - Field: ‘version’
[16:20:48.155]   - Field: ‘result’
[16:20:48.155]   - Field: ‘asynchronous’
[16:20:48.155]   - Field: ‘calls’
[16:20:48.155]   - Field: ‘globals’
[16:20:48.155]   - Field: ‘stdout’
[16:20:48.155]   - Field: ‘earlySignal’
[16:20:48.155]   - Field: ‘lazy’
[16:20:48.155]   - Field: ‘state’
[16:20:48.155] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:48.156] - Launch lazy future ...
[16:20:48.156] Packages needed by the future expression (n = 1): ‘stats’
[16:20:48.156] Packages needed by future strategies (n = 0): <none>
[16:20:48.156] {
[16:20:48.156]     {
[16:20:48.156]         {
[16:20:48.156]             ...future.startTime <- base::Sys.time()
[16:20:48.156]             {
[16:20:48.156]                 {
[16:20:48.156]                   {
[16:20:48.156]                     {
[16:20:48.156]                       base::local({
[16:20:48.156]                         has_future <- base::requireNamespace("future", 
[16:20:48.156]                           quietly = TRUE)
[16:20:48.156]                         if (has_future) {
[16:20:48.156]                           ns <- base::getNamespace("future")
[16:20:48.156]                           version <- ns[[".package"]][["version"]]
[16:20:48.156]                           if (is.null(version)) 
[16:20:48.156]                             version <- utils::packageVersion("future")
[16:20:48.156]                         }
[16:20:48.156]                         else {
[16:20:48.156]                           version <- NULL
[16:20:48.156]                         }
[16:20:48.156]                         if (!has_future || version < "1.8.0") {
[16:20:48.156]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.156]                             "", base::R.version$version.string), 
[16:20:48.156]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:48.156]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:48.156]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.156]                               "release", "version")], collapse = " "), 
[16:20:48.156]                             hostname = base::Sys.info()[["nodename"]])
[16:20:48.156]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.156]                             info)
[16:20:48.156]                           info <- base::paste(info, collapse = "; ")
[16:20:48.156]                           if (!has_future) {
[16:20:48.156]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.156]                               info)
[16:20:48.156]                           }
[16:20:48.156]                           else {
[16:20:48.156]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.156]                               info, version)
[16:20:48.156]                           }
[16:20:48.156]                           base::stop(msg)
[16:20:48.156]                         }
[16:20:48.156]                       })
[16:20:48.156]                     }
[16:20:48.156]                     base::local({
[16:20:48.156]                       for (pkg in "stats") {
[16:20:48.156]                         base::loadNamespace(pkg)
[16:20:48.156]                         base::library(pkg, character.only = TRUE)
[16:20:48.156]                       }
[16:20:48.156]                     })
[16:20:48.156]                   }
[16:20:48.156]                   ...future.strategy.old <- future::plan("list")
[16:20:48.156]                   options(future.plan = NULL)
[16:20:48.156]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.156]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.156]                 }
[16:20:48.156]                 ...future.workdir <- getwd()
[16:20:48.156]             }
[16:20:48.156]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.156]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.156]         }
[16:20:48.156]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.156]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.156]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.156]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.156]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.156]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.156]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.156]             base::names(...future.oldOptions))
[16:20:48.156]     }
[16:20:48.156]     if (FALSE) {
[16:20:48.156]     }
[16:20:48.156]     else {
[16:20:48.156]         if (TRUE) {
[16:20:48.156]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.156]                 open = "w")
[16:20:48.156]         }
[16:20:48.156]         else {
[16:20:48.156]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.156]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.156]         }
[16:20:48.156]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.156]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.156]             base::sink(type = "output", split = FALSE)
[16:20:48.156]             base::close(...future.stdout)
[16:20:48.156]         }, add = TRUE)
[16:20:48.156]     }
[16:20:48.156]     ...future.frame <- base::sys.nframe()
[16:20:48.156]     ...future.conditions <- base::list()
[16:20:48.156]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.156]     if (FALSE) {
[16:20:48.156]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.156]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.156]     }
[16:20:48.156]     ...future.result <- base::tryCatch({
[16:20:48.156]         base::withCallingHandlers({
[16:20:48.156]             ...future.value <- base::withVisible(base::local({
[16:20:48.156]                 xtabs(~x)
[16:20:48.156]             }))
[16:20:48.156]             future::FutureResult(value = ...future.value$value, 
[16:20:48.156]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.156]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.156]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.156]                     ...future.globalenv.names))
[16:20:48.156]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.156]         }, condition = base::local({
[16:20:48.156]             c <- base::c
[16:20:48.156]             inherits <- base::inherits
[16:20:48.156]             invokeRestart <- base::invokeRestart
[16:20:48.156]             length <- base::length
[16:20:48.156]             list <- base::list
[16:20:48.156]             seq.int <- base::seq.int
[16:20:48.156]             signalCondition <- base::signalCondition
[16:20:48.156]             sys.calls <- base::sys.calls
[16:20:48.156]             `[[` <- base::`[[`
[16:20:48.156]             `+` <- base::`+`
[16:20:48.156]             `<<-` <- base::`<<-`
[16:20:48.156]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.156]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.156]                   3L)]
[16:20:48.156]             }
[16:20:48.156]             function(cond) {
[16:20:48.156]                 is_error <- inherits(cond, "error")
[16:20:48.156]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.156]                   NULL)
[16:20:48.156]                 if (is_error) {
[16:20:48.156]                   sessionInformation <- function() {
[16:20:48.156]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.156]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.156]                       search = base::search(), system = base::Sys.info())
[16:20:48.156]                   }
[16:20:48.156]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.156]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.156]                     cond$call), session = sessionInformation(), 
[16:20:48.156]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.156]                   signalCondition(cond)
[16:20:48.156]                 }
[16:20:48.156]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.156]                 "immediateCondition"))) {
[16:20:48.156]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.156]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.156]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.156]                   if (TRUE && !signal) {
[16:20:48.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.156]                     {
[16:20:48.156]                       inherits <- base::inherits
[16:20:48.156]                       invokeRestart <- base::invokeRestart
[16:20:48.156]                       is.null <- base::is.null
[16:20:48.156]                       muffled <- FALSE
[16:20:48.156]                       if (inherits(cond, "message")) {
[16:20:48.156]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.156]                         if (muffled) 
[16:20:48.156]                           invokeRestart("muffleMessage")
[16:20:48.156]                       }
[16:20:48.156]                       else if (inherits(cond, "warning")) {
[16:20:48.156]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.156]                         if (muffled) 
[16:20:48.156]                           invokeRestart("muffleWarning")
[16:20:48.156]                       }
[16:20:48.156]                       else if (inherits(cond, "condition")) {
[16:20:48.156]                         if (!is.null(pattern)) {
[16:20:48.156]                           computeRestarts <- base::computeRestarts
[16:20:48.156]                           grepl <- base::grepl
[16:20:48.156]                           restarts <- computeRestarts(cond)
[16:20:48.156]                           for (restart in restarts) {
[16:20:48.156]                             name <- restart$name
[16:20:48.156]                             if (is.null(name)) 
[16:20:48.156]                               next
[16:20:48.156]                             if (!grepl(pattern, name)) 
[16:20:48.156]                               next
[16:20:48.156]                             invokeRestart(restart)
[16:20:48.156]                             muffled <- TRUE
[16:20:48.156]                             break
[16:20:48.156]                           }
[16:20:48.156]                         }
[16:20:48.156]                       }
[16:20:48.156]                       invisible(muffled)
[16:20:48.156]                     }
[16:20:48.156]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.156]                   }
[16:20:48.156]                 }
[16:20:48.156]                 else {
[16:20:48.156]                   if (TRUE) {
[16:20:48.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.156]                     {
[16:20:48.156]                       inherits <- base::inherits
[16:20:48.156]                       invokeRestart <- base::invokeRestart
[16:20:48.156]                       is.null <- base::is.null
[16:20:48.156]                       muffled <- FALSE
[16:20:48.156]                       if (inherits(cond, "message")) {
[16:20:48.156]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.156]                         if (muffled) 
[16:20:48.156]                           invokeRestart("muffleMessage")
[16:20:48.156]                       }
[16:20:48.156]                       else if (inherits(cond, "warning")) {
[16:20:48.156]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.156]                         if (muffled) 
[16:20:48.156]                           invokeRestart("muffleWarning")
[16:20:48.156]                       }
[16:20:48.156]                       else if (inherits(cond, "condition")) {
[16:20:48.156]                         if (!is.null(pattern)) {
[16:20:48.156]                           computeRestarts <- base::computeRestarts
[16:20:48.156]                           grepl <- base::grepl
[16:20:48.156]                           restarts <- computeRestarts(cond)
[16:20:48.156]                           for (restart in restarts) {
[16:20:48.156]                             name <- restart$name
[16:20:48.156]                             if (is.null(name)) 
[16:20:48.156]                               next
[16:20:48.156]                             if (!grepl(pattern, name)) 
[16:20:48.156]                               next
[16:20:48.156]                             invokeRestart(restart)
[16:20:48.156]                             muffled <- TRUE
[16:20:48.156]                             break
[16:20:48.156]                           }
[16:20:48.156]                         }
[16:20:48.156]                       }
[16:20:48.156]                       invisible(muffled)
[16:20:48.156]                     }
[16:20:48.156]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.156]                   }
[16:20:48.156]                 }
[16:20:48.156]             }
[16:20:48.156]         }))
[16:20:48.156]     }, error = function(ex) {
[16:20:48.156]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.156]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.156]                 ...future.rng), started = ...future.startTime, 
[16:20:48.156]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.156]             version = "1.8"), class = "FutureResult")
[16:20:48.156]     }, finally = {
[16:20:48.156]         if (!identical(...future.workdir, getwd())) 
[16:20:48.156]             setwd(...future.workdir)
[16:20:48.156]         {
[16:20:48.156]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.156]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.156]             }
[16:20:48.156]             base::options(...future.oldOptions)
[16:20:48.156]             if (.Platform$OS.type == "windows") {
[16:20:48.156]                 old_names <- names(...future.oldEnvVars)
[16:20:48.156]                 envs <- base::Sys.getenv()
[16:20:48.156]                 names <- names(envs)
[16:20:48.156]                 common <- intersect(names, old_names)
[16:20:48.156]                 added <- setdiff(names, old_names)
[16:20:48.156]                 removed <- setdiff(old_names, names)
[16:20:48.156]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.156]                   envs[common]]
[16:20:48.156]                 NAMES <- toupper(changed)
[16:20:48.156]                 args <- list()
[16:20:48.156]                 for (kk in seq_along(NAMES)) {
[16:20:48.156]                   name <- changed[[kk]]
[16:20:48.156]                   NAME <- NAMES[[kk]]
[16:20:48.156]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.156]                     next
[16:20:48.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.156]                 }
[16:20:48.156]                 NAMES <- toupper(added)
[16:20:48.156]                 for (kk in seq_along(NAMES)) {
[16:20:48.156]                   name <- added[[kk]]
[16:20:48.156]                   NAME <- NAMES[[kk]]
[16:20:48.156]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.156]                     next
[16:20:48.156]                   args[[name]] <- ""
[16:20:48.156]                 }
[16:20:48.156]                 NAMES <- toupper(removed)
[16:20:48.156]                 for (kk in seq_along(NAMES)) {
[16:20:48.156]                   name <- removed[[kk]]
[16:20:48.156]                   NAME <- NAMES[[kk]]
[16:20:48.156]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.156]                     next
[16:20:48.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.156]                 }
[16:20:48.156]                 if (length(args) > 0) 
[16:20:48.156]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.156]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.156]             }
[16:20:48.156]             else {
[16:20:48.156]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.156]             }
[16:20:48.156]             {
[16:20:48.156]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.156]                   0L) {
[16:20:48.156]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.156]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.156]                   base::options(opts)
[16:20:48.156]                 }
[16:20:48.156]                 {
[16:20:48.156]                   {
[16:20:48.156]                     NULL
[16:20:48.156]                     RNGkind("Mersenne-Twister")
[16:20:48.156]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:48.156]                       inherits = FALSE)
[16:20:48.156]                   }
[16:20:48.156]                   options(future.plan = NULL)
[16:20:48.156]                   if (is.na(NA_character_)) 
[16:20:48.156]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.156]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.156]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.156]                     .init = FALSE)
[16:20:48.156]                 }
[16:20:48.156]             }
[16:20:48.156]         }
[16:20:48.156]     })
[16:20:48.156]     if (TRUE) {
[16:20:48.156]         base::sink(type = "output", split = FALSE)
[16:20:48.156]         if (TRUE) {
[16:20:48.156]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.156]         }
[16:20:48.156]         else {
[16:20:48.156]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.156]         }
[16:20:48.156]         base::close(...future.stdout)
[16:20:48.156]         ...future.stdout <- NULL
[16:20:48.156]     }
[16:20:48.156]     ...future.result$conditions <- ...future.conditions
[16:20:48.156]     ...future.result$finished <- base::Sys.time()
[16:20:48.156]     ...future.result
[16:20:48.156] }
[16:20:48.158] assign_globals() ...
[16:20:48.158] List of 1
[16:20:48.158]  $ x: num [1:5] 1 1 2 2 2
[16:20:48.158]  - attr(*, "where")=List of 1
[16:20:48.158]   ..$ x:<environment: R_EmptyEnv> 
[16:20:48.158]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:48.158]  - attr(*, "resolved")= logi FALSE
[16:20:48.158]  - attr(*, "total_size")= num 96
[16:20:48.158]  - attr(*, "already-done")= logi TRUE
[16:20:48.160] - copied ‘x’ to environment
[16:20:48.161] assign_globals() ... done
[16:20:48.161] plan(): Setting new future strategy stack:
[16:20:48.161] List of future strategies:
[16:20:48.161] 1. sequential:
[16:20:48.161]    - args: function (..., envir = parent.frame())
[16:20:48.161]    - tweaked: FALSE
[16:20:48.161]    - call: NULL
[16:20:48.161] plan(): nbrOfWorkers() = 1
[16:20:48.162] plan(): Setting new future strategy stack:
[16:20:48.162] List of future strategies:
[16:20:48.162] 1. sequential:
[16:20:48.162]    - args: function (..., envir = parent.frame())
[16:20:48.162]    - tweaked: FALSE
[16:20:48.162]    - call: plan(strategy)
[16:20:48.163] plan(): nbrOfWorkers() = 1
[16:20:48.163] SequentialFuture started (and completed)
[16:20:48.163] - Launch lazy future ... done
[16:20:48.163] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
[16:20:48.164] getGlobalsAndPackages() ...
[16:20:48.164] Searching for globals...
[16:20:48.165] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[16:20:48.165] Searching for globals ... DONE
[16:20:48.165] Resolving globals: FALSE
[16:20:48.166] The total size of the 1 globals is 96 bytes (96 bytes)
[16:20:48.166] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[16:20:48.166] - globals: [1] ‘x’
[16:20:48.166] - packages: [1] ‘stats’
[16:20:48.166] getGlobalsAndPackages() ... DONE
[16:20:48.166] run() for ‘Future’ ...
[16:20:48.167] - state: ‘created’
[16:20:48.167] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:48.167] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:48.167] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:48.167]   - Field: ‘label’
[16:20:48.167]   - Field: ‘local’
[16:20:48.167]   - Field: ‘owner’
[16:20:48.167]   - Field: ‘envir’
[16:20:48.168]   - Field: ‘packages’
[16:20:48.168]   - Field: ‘gc’
[16:20:48.168]   - Field: ‘conditions’
[16:20:48.168]   - Field: ‘expr’
[16:20:48.168]   - Field: ‘uuid’
[16:20:48.168]   - Field: ‘seed’
[16:20:48.168]   - Field: ‘version’
[16:20:48.168]   - Field: ‘result’
[16:20:48.168]   - Field: ‘asynchronous’
[16:20:48.168]   - Field: ‘calls’
[16:20:48.169]   - Field: ‘globals’
[16:20:48.169]   - Field: ‘stdout’
[16:20:48.169]   - Field: ‘earlySignal’
[16:20:48.169]   - Field: ‘lazy’
[16:20:48.169]   - Field: ‘state’
[16:20:48.169] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:48.169] - Launch lazy future ...
[16:20:48.169] Packages needed by the future expression (n = 1): ‘stats’
[16:20:48.169] Packages needed by future strategies (n = 0): <none>
[16:20:48.170] {
[16:20:48.170]     {
[16:20:48.170]         {
[16:20:48.170]             ...future.startTime <- base::Sys.time()
[16:20:48.170]             {
[16:20:48.170]                 {
[16:20:48.170]                   {
[16:20:48.170]                     {
[16:20:48.170]                       base::local({
[16:20:48.170]                         has_future <- base::requireNamespace("future", 
[16:20:48.170]                           quietly = TRUE)
[16:20:48.170]                         if (has_future) {
[16:20:48.170]                           ns <- base::getNamespace("future")
[16:20:48.170]                           version <- ns[[".package"]][["version"]]
[16:20:48.170]                           if (is.null(version)) 
[16:20:48.170]                             version <- utils::packageVersion("future")
[16:20:48.170]                         }
[16:20:48.170]                         else {
[16:20:48.170]                           version <- NULL
[16:20:48.170]                         }
[16:20:48.170]                         if (!has_future || version < "1.8.0") {
[16:20:48.170]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.170]                             "", base::R.version$version.string), 
[16:20:48.170]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:48.170]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:48.170]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.170]                               "release", "version")], collapse = " "), 
[16:20:48.170]                             hostname = base::Sys.info()[["nodename"]])
[16:20:48.170]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.170]                             info)
[16:20:48.170]                           info <- base::paste(info, collapse = "; ")
[16:20:48.170]                           if (!has_future) {
[16:20:48.170]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.170]                               info)
[16:20:48.170]                           }
[16:20:48.170]                           else {
[16:20:48.170]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.170]                               info, version)
[16:20:48.170]                           }
[16:20:48.170]                           base::stop(msg)
[16:20:48.170]                         }
[16:20:48.170]                       })
[16:20:48.170]                     }
[16:20:48.170]                     base::local({
[16:20:48.170]                       for (pkg in "stats") {
[16:20:48.170]                         base::loadNamespace(pkg)
[16:20:48.170]                         base::library(pkg, character.only = TRUE)
[16:20:48.170]                       }
[16:20:48.170]                     })
[16:20:48.170]                   }
[16:20:48.170]                   ...future.strategy.old <- future::plan("list")
[16:20:48.170]                   options(future.plan = NULL)
[16:20:48.170]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.170]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.170]                 }
[16:20:48.170]                 ...future.workdir <- getwd()
[16:20:48.170]             }
[16:20:48.170]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.170]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.170]         }
[16:20:48.170]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.170]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.170]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.170]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.170]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.170]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.170]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.170]             base::names(...future.oldOptions))
[16:20:48.170]     }
[16:20:48.170]     if (FALSE) {
[16:20:48.170]     }
[16:20:48.170]     else {
[16:20:48.170]         if (TRUE) {
[16:20:48.170]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.170]                 open = "w")
[16:20:48.170]         }
[16:20:48.170]         else {
[16:20:48.170]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.170]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.170]         }
[16:20:48.170]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.170]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.170]             base::sink(type = "output", split = FALSE)
[16:20:48.170]             base::close(...future.stdout)
[16:20:48.170]         }, add = TRUE)
[16:20:48.170]     }
[16:20:48.170]     ...future.frame <- base::sys.nframe()
[16:20:48.170]     ...future.conditions <- base::list()
[16:20:48.170]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.170]     if (FALSE) {
[16:20:48.170]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.170]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.170]     }
[16:20:48.170]     ...future.result <- base::tryCatch({
[16:20:48.170]         base::withCallingHandlers({
[16:20:48.170]             ...future.value <- base::withVisible(base::local({
[16:20:48.170]                 xtabs(~x)
[16:20:48.170]             }))
[16:20:48.170]             future::FutureResult(value = ...future.value$value, 
[16:20:48.170]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.170]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.170]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.170]                     ...future.globalenv.names))
[16:20:48.170]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.170]         }, condition = base::local({
[16:20:48.170]             c <- base::c
[16:20:48.170]             inherits <- base::inherits
[16:20:48.170]             invokeRestart <- base::invokeRestart
[16:20:48.170]             length <- base::length
[16:20:48.170]             list <- base::list
[16:20:48.170]             seq.int <- base::seq.int
[16:20:48.170]             signalCondition <- base::signalCondition
[16:20:48.170]             sys.calls <- base::sys.calls
[16:20:48.170]             `[[` <- base::`[[`
[16:20:48.170]             `+` <- base::`+`
[16:20:48.170]             `<<-` <- base::`<<-`
[16:20:48.170]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.170]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.170]                   3L)]
[16:20:48.170]             }
[16:20:48.170]             function(cond) {
[16:20:48.170]                 is_error <- inherits(cond, "error")
[16:20:48.170]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.170]                   NULL)
[16:20:48.170]                 if (is_error) {
[16:20:48.170]                   sessionInformation <- function() {
[16:20:48.170]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.170]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.170]                       search = base::search(), system = base::Sys.info())
[16:20:48.170]                   }
[16:20:48.170]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.170]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.170]                     cond$call), session = sessionInformation(), 
[16:20:48.170]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.170]                   signalCondition(cond)
[16:20:48.170]                 }
[16:20:48.170]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.170]                 "immediateCondition"))) {
[16:20:48.170]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.170]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.170]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.170]                   if (TRUE && !signal) {
[16:20:48.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.170]                     {
[16:20:48.170]                       inherits <- base::inherits
[16:20:48.170]                       invokeRestart <- base::invokeRestart
[16:20:48.170]                       is.null <- base::is.null
[16:20:48.170]                       muffled <- FALSE
[16:20:48.170]                       if (inherits(cond, "message")) {
[16:20:48.170]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.170]                         if (muffled) 
[16:20:48.170]                           invokeRestart("muffleMessage")
[16:20:48.170]                       }
[16:20:48.170]                       else if (inherits(cond, "warning")) {
[16:20:48.170]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.170]                         if (muffled) 
[16:20:48.170]                           invokeRestart("muffleWarning")
[16:20:48.170]                       }
[16:20:48.170]                       else if (inherits(cond, "condition")) {
[16:20:48.170]                         if (!is.null(pattern)) {
[16:20:48.170]                           computeRestarts <- base::computeRestarts
[16:20:48.170]                           grepl <- base::grepl
[16:20:48.170]                           restarts <- computeRestarts(cond)
[16:20:48.170]                           for (restart in restarts) {
[16:20:48.170]                             name <- restart$name
[16:20:48.170]                             if (is.null(name)) 
[16:20:48.170]                               next
[16:20:48.170]                             if (!grepl(pattern, name)) 
[16:20:48.170]                               next
[16:20:48.170]                             invokeRestart(restart)
[16:20:48.170]                             muffled <- TRUE
[16:20:48.170]                             break
[16:20:48.170]                           }
[16:20:48.170]                         }
[16:20:48.170]                       }
[16:20:48.170]                       invisible(muffled)
[16:20:48.170]                     }
[16:20:48.170]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.170]                   }
[16:20:48.170]                 }
[16:20:48.170]                 else {
[16:20:48.170]                   if (TRUE) {
[16:20:48.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.170]                     {
[16:20:48.170]                       inherits <- base::inherits
[16:20:48.170]                       invokeRestart <- base::invokeRestart
[16:20:48.170]                       is.null <- base::is.null
[16:20:48.170]                       muffled <- FALSE
[16:20:48.170]                       if (inherits(cond, "message")) {
[16:20:48.170]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.170]                         if (muffled) 
[16:20:48.170]                           invokeRestart("muffleMessage")
[16:20:48.170]                       }
[16:20:48.170]                       else if (inherits(cond, "warning")) {
[16:20:48.170]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.170]                         if (muffled) 
[16:20:48.170]                           invokeRestart("muffleWarning")
[16:20:48.170]                       }
[16:20:48.170]                       else if (inherits(cond, "condition")) {
[16:20:48.170]                         if (!is.null(pattern)) {
[16:20:48.170]                           computeRestarts <- base::computeRestarts
[16:20:48.170]                           grepl <- base::grepl
[16:20:48.170]                           restarts <- computeRestarts(cond)
[16:20:48.170]                           for (restart in restarts) {
[16:20:48.170]                             name <- restart$name
[16:20:48.170]                             if (is.null(name)) 
[16:20:48.170]                               next
[16:20:48.170]                             if (!grepl(pattern, name)) 
[16:20:48.170]                               next
[16:20:48.170]                             invokeRestart(restart)
[16:20:48.170]                             muffled <- TRUE
[16:20:48.170]                             break
[16:20:48.170]                           }
[16:20:48.170]                         }
[16:20:48.170]                       }
[16:20:48.170]                       invisible(muffled)
[16:20:48.170]                     }
[16:20:48.170]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.170]                   }
[16:20:48.170]                 }
[16:20:48.170]             }
[16:20:48.170]         }))
[16:20:48.170]     }, error = function(ex) {
[16:20:48.170]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.170]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.170]                 ...future.rng), started = ...future.startTime, 
[16:20:48.170]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.170]             version = "1.8"), class = "FutureResult")
[16:20:48.170]     }, finally = {
[16:20:48.170]         if (!identical(...future.workdir, getwd())) 
[16:20:48.170]             setwd(...future.workdir)
[16:20:48.170]         {
[16:20:48.170]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.170]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.170]             }
[16:20:48.170]             base::options(...future.oldOptions)
[16:20:48.170]             if (.Platform$OS.type == "windows") {
[16:20:48.170]                 old_names <- names(...future.oldEnvVars)
[16:20:48.170]                 envs <- base::Sys.getenv()
[16:20:48.170]                 names <- names(envs)
[16:20:48.170]                 common <- intersect(names, old_names)
[16:20:48.170]                 added <- setdiff(names, old_names)
[16:20:48.170]                 removed <- setdiff(old_names, names)
[16:20:48.170]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.170]                   envs[common]]
[16:20:48.170]                 NAMES <- toupper(changed)
[16:20:48.170]                 args <- list()
[16:20:48.170]                 for (kk in seq_along(NAMES)) {
[16:20:48.170]                   name <- changed[[kk]]
[16:20:48.170]                   NAME <- NAMES[[kk]]
[16:20:48.170]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.170]                     next
[16:20:48.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.170]                 }
[16:20:48.170]                 NAMES <- toupper(added)
[16:20:48.170]                 for (kk in seq_along(NAMES)) {
[16:20:48.170]                   name <- added[[kk]]
[16:20:48.170]                   NAME <- NAMES[[kk]]
[16:20:48.170]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.170]                     next
[16:20:48.170]                   args[[name]] <- ""
[16:20:48.170]                 }
[16:20:48.170]                 NAMES <- toupper(removed)
[16:20:48.170]                 for (kk in seq_along(NAMES)) {
[16:20:48.170]                   name <- removed[[kk]]
[16:20:48.170]                   NAME <- NAMES[[kk]]
[16:20:48.170]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.170]                     next
[16:20:48.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.170]                 }
[16:20:48.170]                 if (length(args) > 0) 
[16:20:48.170]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.170]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.170]             }
[16:20:48.170]             else {
[16:20:48.170]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.170]             }
[16:20:48.170]             {
[16:20:48.170]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.170]                   0L) {
[16:20:48.170]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.170]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.170]                   base::options(opts)
[16:20:48.170]                 }
[16:20:48.170]                 {
[16:20:48.170]                   {
[16:20:48.170]                     NULL
[16:20:48.170]                     RNGkind("Mersenne-Twister")
[16:20:48.170]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:48.170]                       inherits = FALSE)
[16:20:48.170]                   }
[16:20:48.170]                   options(future.plan = NULL)
[16:20:48.170]                   if (is.na(NA_character_)) 
[16:20:48.170]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.170]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.170]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.170]                     .init = FALSE)
[16:20:48.170]                 }
[16:20:48.170]             }
[16:20:48.170]         }
[16:20:48.170]     })
[16:20:48.170]     if (TRUE) {
[16:20:48.170]         base::sink(type = "output", split = FALSE)
[16:20:48.170]         if (TRUE) {
[16:20:48.170]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.170]         }
[16:20:48.170]         else {
[16:20:48.170]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.170]         }
[16:20:48.170]         base::close(...future.stdout)
[16:20:48.170]         ...future.stdout <- NULL
[16:20:48.170]     }
[16:20:48.170]     ...future.result$conditions <- ...future.conditions
[16:20:48.170]     ...future.result$finished <- base::Sys.time()
[16:20:48.170]     ...future.result
[16:20:48.170] }
[16:20:48.171] assign_globals() ...
[16:20:48.171] List of 1
[16:20:48.171]  $ x: num [1:5] 1 1 2 2 2
[16:20:48.171]  - attr(*, "where")=List of 1
[16:20:48.171]   ..$ x:<environment: R_EmptyEnv> 
[16:20:48.171]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:48.171]  - attr(*, "resolved")= logi FALSE
[16:20:48.171]  - attr(*, "total_size")= num 96
[16:20:48.171]  - attr(*, "already-done")= logi TRUE
[16:20:48.174] - copied ‘x’ to environment
[16:20:48.174] assign_globals() ... done
[16:20:48.174] plan(): Setting new future strategy stack:
[16:20:48.174] List of future strategies:
[16:20:48.174] 1. sequential:
[16:20:48.174]    - args: function (..., envir = parent.frame())
[16:20:48.174]    - tweaked: FALSE
[16:20:48.174]    - call: NULL
[16:20:48.175] plan(): nbrOfWorkers() = 1
[16:20:48.176] plan(): Setting new future strategy stack:
[16:20:48.176] List of future strategies:
[16:20:48.176] 1. sequential:
[16:20:48.176]    - args: function (..., envir = parent.frame())
[16:20:48.176]    - tweaked: FALSE
[16:20:48.176]    - call: plan(strategy)
[16:20:48.176] plan(): nbrOfWorkers() = 1
[16:20:48.176] SequentialFuture started (and completed)
[16:20:48.177] - Launch lazy future ... done
[16:20:48.177] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[16:20:48.179] getGlobalsAndPackages() ...
[16:20:48.179] Searching for globals...
[16:20:48.182] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[16:20:48.182] Searching for globals ... DONE
[16:20:48.182] Resolving globals: FALSE
[16:20:48.183] 
[16:20:48.183] - packages: [2] ‘stats’, ‘datasets’
[16:20:48.183] getGlobalsAndPackages() ... DONE
[16:20:48.183] run() for ‘Future’ ...
[16:20:48.183] - state: ‘created’
[16:20:48.183] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:48.184] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:48.184] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:48.184]   - Field: ‘label’
[16:20:48.184]   - Field: ‘local’
[16:20:48.184]   - Field: ‘owner’
[16:20:48.184]   - Field: ‘envir’
[16:20:48.184]   - Field: ‘packages’
[16:20:48.184]   - Field: ‘gc’
[16:20:48.185]   - Field: ‘conditions’
[16:20:48.185]   - Field: ‘expr’
[16:20:48.185]   - Field: ‘uuid’
[16:20:48.185]   - Field: ‘seed’
[16:20:48.185]   - Field: ‘version’
[16:20:48.185]   - Field: ‘result’
[16:20:48.185]   - Field: ‘asynchronous’
[16:20:48.185]   - Field: ‘calls’
[16:20:48.185]   - Field: ‘globals’
[16:20:48.185]   - Field: ‘stdout’
[16:20:48.185]   - Field: ‘earlySignal’
[16:20:48.186]   - Field: ‘lazy’
[16:20:48.186]   - Field: ‘state’
[16:20:48.186] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:48.186] - Launch lazy future ...
[16:20:48.186] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:20:48.186] Packages needed by future strategies (n = 0): <none>
[16:20:48.187] {
[16:20:48.187]     {
[16:20:48.187]         {
[16:20:48.187]             ...future.startTime <- base::Sys.time()
[16:20:48.187]             {
[16:20:48.187]                 {
[16:20:48.187]                   {
[16:20:48.187]                     {
[16:20:48.187]                       base::local({
[16:20:48.187]                         has_future <- base::requireNamespace("future", 
[16:20:48.187]                           quietly = TRUE)
[16:20:48.187]                         if (has_future) {
[16:20:48.187]                           ns <- base::getNamespace("future")
[16:20:48.187]                           version <- ns[[".package"]][["version"]]
[16:20:48.187]                           if (is.null(version)) 
[16:20:48.187]                             version <- utils::packageVersion("future")
[16:20:48.187]                         }
[16:20:48.187]                         else {
[16:20:48.187]                           version <- NULL
[16:20:48.187]                         }
[16:20:48.187]                         if (!has_future || version < "1.8.0") {
[16:20:48.187]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.187]                             "", base::R.version$version.string), 
[16:20:48.187]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:48.187]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:48.187]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.187]                               "release", "version")], collapse = " "), 
[16:20:48.187]                             hostname = base::Sys.info()[["nodename"]])
[16:20:48.187]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.187]                             info)
[16:20:48.187]                           info <- base::paste(info, collapse = "; ")
[16:20:48.187]                           if (!has_future) {
[16:20:48.187]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.187]                               info)
[16:20:48.187]                           }
[16:20:48.187]                           else {
[16:20:48.187]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.187]                               info, version)
[16:20:48.187]                           }
[16:20:48.187]                           base::stop(msg)
[16:20:48.187]                         }
[16:20:48.187]                       })
[16:20:48.187]                     }
[16:20:48.187]                     base::local({
[16:20:48.187]                       for (pkg in c("stats", "datasets")) {
[16:20:48.187]                         base::loadNamespace(pkg)
[16:20:48.187]                         base::library(pkg, character.only = TRUE)
[16:20:48.187]                       }
[16:20:48.187]                     })
[16:20:48.187]                   }
[16:20:48.187]                   ...future.strategy.old <- future::plan("list")
[16:20:48.187]                   options(future.plan = NULL)
[16:20:48.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.187]                 }
[16:20:48.187]                 ...future.workdir <- getwd()
[16:20:48.187]             }
[16:20:48.187]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.187]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.187]         }
[16:20:48.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.187]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.187]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.187]             base::names(...future.oldOptions))
[16:20:48.187]     }
[16:20:48.187]     if (FALSE) {
[16:20:48.187]     }
[16:20:48.187]     else {
[16:20:48.187]         if (TRUE) {
[16:20:48.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.187]                 open = "w")
[16:20:48.187]         }
[16:20:48.187]         else {
[16:20:48.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.187]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.187]         }
[16:20:48.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.187]             base::sink(type = "output", split = FALSE)
[16:20:48.187]             base::close(...future.stdout)
[16:20:48.187]         }, add = TRUE)
[16:20:48.187]     }
[16:20:48.187]     ...future.frame <- base::sys.nframe()
[16:20:48.187]     ...future.conditions <- base::list()
[16:20:48.187]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.187]     if (FALSE) {
[16:20:48.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.187]     }
[16:20:48.187]     ...future.result <- base::tryCatch({
[16:20:48.187]         base::withCallingHandlers({
[16:20:48.187]             ...future.value <- base::withVisible(base::local({
[16:20:48.187]                 lm(dist ~ . - 1, data = cars)
[16:20:48.187]             }))
[16:20:48.187]             future::FutureResult(value = ...future.value$value, 
[16:20:48.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.187]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.187]                     ...future.globalenv.names))
[16:20:48.187]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.187]         }, condition = base::local({
[16:20:48.187]             c <- base::c
[16:20:48.187]             inherits <- base::inherits
[16:20:48.187]             invokeRestart <- base::invokeRestart
[16:20:48.187]             length <- base::length
[16:20:48.187]             list <- base::list
[16:20:48.187]             seq.int <- base::seq.int
[16:20:48.187]             signalCondition <- base::signalCondition
[16:20:48.187]             sys.calls <- base::sys.calls
[16:20:48.187]             `[[` <- base::`[[`
[16:20:48.187]             `+` <- base::`+`
[16:20:48.187]             `<<-` <- base::`<<-`
[16:20:48.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.187]                   3L)]
[16:20:48.187]             }
[16:20:48.187]             function(cond) {
[16:20:48.187]                 is_error <- inherits(cond, "error")
[16:20:48.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.187]                   NULL)
[16:20:48.187]                 if (is_error) {
[16:20:48.187]                   sessionInformation <- function() {
[16:20:48.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.187]                       search = base::search(), system = base::Sys.info())
[16:20:48.187]                   }
[16:20:48.187]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.187]                     cond$call), session = sessionInformation(), 
[16:20:48.187]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.187]                   signalCondition(cond)
[16:20:48.187]                 }
[16:20:48.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.187]                 "immediateCondition"))) {
[16:20:48.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.187]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.187]                   if (TRUE && !signal) {
[16:20:48.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.187]                     {
[16:20:48.187]                       inherits <- base::inherits
[16:20:48.187]                       invokeRestart <- base::invokeRestart
[16:20:48.187]                       is.null <- base::is.null
[16:20:48.187]                       muffled <- FALSE
[16:20:48.187]                       if (inherits(cond, "message")) {
[16:20:48.187]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.187]                         if (muffled) 
[16:20:48.187]                           invokeRestart("muffleMessage")
[16:20:48.187]                       }
[16:20:48.187]                       else if (inherits(cond, "warning")) {
[16:20:48.187]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.187]                         if (muffled) 
[16:20:48.187]                           invokeRestart("muffleWarning")
[16:20:48.187]                       }
[16:20:48.187]                       else if (inherits(cond, "condition")) {
[16:20:48.187]                         if (!is.null(pattern)) {
[16:20:48.187]                           computeRestarts <- base::computeRestarts
[16:20:48.187]                           grepl <- base::grepl
[16:20:48.187]                           restarts <- computeRestarts(cond)
[16:20:48.187]                           for (restart in restarts) {
[16:20:48.187]                             name <- restart$name
[16:20:48.187]                             if (is.null(name)) 
[16:20:48.187]                               next
[16:20:48.187]                             if (!grepl(pattern, name)) 
[16:20:48.187]                               next
[16:20:48.187]                             invokeRestart(restart)
[16:20:48.187]                             muffled <- TRUE
[16:20:48.187]                             break
[16:20:48.187]                           }
[16:20:48.187]                         }
[16:20:48.187]                       }
[16:20:48.187]                       invisible(muffled)
[16:20:48.187]                     }
[16:20:48.187]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.187]                   }
[16:20:48.187]                 }
[16:20:48.187]                 else {
[16:20:48.187]                   if (TRUE) {
[16:20:48.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.187]                     {
[16:20:48.187]                       inherits <- base::inherits
[16:20:48.187]                       invokeRestart <- base::invokeRestart
[16:20:48.187]                       is.null <- base::is.null
[16:20:48.187]                       muffled <- FALSE
[16:20:48.187]                       if (inherits(cond, "message")) {
[16:20:48.187]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.187]                         if (muffled) 
[16:20:48.187]                           invokeRestart("muffleMessage")
[16:20:48.187]                       }
[16:20:48.187]                       else if (inherits(cond, "warning")) {
[16:20:48.187]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.187]                         if (muffled) 
[16:20:48.187]                           invokeRestart("muffleWarning")
[16:20:48.187]                       }
[16:20:48.187]                       else if (inherits(cond, "condition")) {
[16:20:48.187]                         if (!is.null(pattern)) {
[16:20:48.187]                           computeRestarts <- base::computeRestarts
[16:20:48.187]                           grepl <- base::grepl
[16:20:48.187]                           restarts <- computeRestarts(cond)
[16:20:48.187]                           for (restart in restarts) {
[16:20:48.187]                             name <- restart$name
[16:20:48.187]                             if (is.null(name)) 
[16:20:48.187]                               next
[16:20:48.187]                             if (!grepl(pattern, name)) 
[16:20:48.187]                               next
[16:20:48.187]                             invokeRestart(restart)
[16:20:48.187]                             muffled <- TRUE
[16:20:48.187]                             break
[16:20:48.187]                           }
[16:20:48.187]                         }
[16:20:48.187]                       }
[16:20:48.187]                       invisible(muffled)
[16:20:48.187]                     }
[16:20:48.187]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.187]                   }
[16:20:48.187]                 }
[16:20:48.187]             }
[16:20:48.187]         }))
[16:20:48.187]     }, error = function(ex) {
[16:20:48.187]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.187]                 ...future.rng), started = ...future.startTime, 
[16:20:48.187]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.187]             version = "1.8"), class = "FutureResult")
[16:20:48.187]     }, finally = {
[16:20:48.187]         if (!identical(...future.workdir, getwd())) 
[16:20:48.187]             setwd(...future.workdir)
[16:20:48.187]         {
[16:20:48.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.187]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.187]             }
[16:20:48.187]             base::options(...future.oldOptions)
[16:20:48.187]             if (.Platform$OS.type == "windows") {
[16:20:48.187]                 old_names <- names(...future.oldEnvVars)
[16:20:48.187]                 envs <- base::Sys.getenv()
[16:20:48.187]                 names <- names(envs)
[16:20:48.187]                 common <- intersect(names, old_names)
[16:20:48.187]                 added <- setdiff(names, old_names)
[16:20:48.187]                 removed <- setdiff(old_names, names)
[16:20:48.187]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.187]                   envs[common]]
[16:20:48.187]                 NAMES <- toupper(changed)
[16:20:48.187]                 args <- list()
[16:20:48.187]                 for (kk in seq_along(NAMES)) {
[16:20:48.187]                   name <- changed[[kk]]
[16:20:48.187]                   NAME <- NAMES[[kk]]
[16:20:48.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.187]                     next
[16:20:48.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.187]                 }
[16:20:48.187]                 NAMES <- toupper(added)
[16:20:48.187]                 for (kk in seq_along(NAMES)) {
[16:20:48.187]                   name <- added[[kk]]
[16:20:48.187]                   NAME <- NAMES[[kk]]
[16:20:48.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.187]                     next
[16:20:48.187]                   args[[name]] <- ""
[16:20:48.187]                 }
[16:20:48.187]                 NAMES <- toupper(removed)
[16:20:48.187]                 for (kk in seq_along(NAMES)) {
[16:20:48.187]                   name <- removed[[kk]]
[16:20:48.187]                   NAME <- NAMES[[kk]]
[16:20:48.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.187]                     next
[16:20:48.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.187]                 }
[16:20:48.187]                 if (length(args) > 0) 
[16:20:48.187]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.187]             }
[16:20:48.187]             else {
[16:20:48.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.187]             }
[16:20:48.187]             {
[16:20:48.187]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.187]                   0L) {
[16:20:48.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.187]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.187]                   base::options(opts)
[16:20:48.187]                 }
[16:20:48.187]                 {
[16:20:48.187]                   {
[16:20:48.187]                     NULL
[16:20:48.187]                     RNGkind("Mersenne-Twister")
[16:20:48.187]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:48.187]                       inherits = FALSE)
[16:20:48.187]                   }
[16:20:48.187]                   options(future.plan = NULL)
[16:20:48.187]                   if (is.na(NA_character_)) 
[16:20:48.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.187]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.187]                     .init = FALSE)
[16:20:48.187]                 }
[16:20:48.187]             }
[16:20:48.187]         }
[16:20:48.187]     })
[16:20:48.187]     if (TRUE) {
[16:20:48.187]         base::sink(type = "output", split = FALSE)
[16:20:48.187]         if (TRUE) {
[16:20:48.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.187]         }
[16:20:48.187]         else {
[16:20:48.187]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.187]         }
[16:20:48.187]         base::close(...future.stdout)
[16:20:48.187]         ...future.stdout <- NULL
[16:20:48.187]     }
[16:20:48.187]     ...future.result$conditions <- ...future.conditions
[16:20:48.187]     ...future.result$finished <- base::Sys.time()
[16:20:48.187]     ...future.result
[16:20:48.187] }
[16:20:48.189] plan(): Setting new future strategy stack:
[16:20:48.189] List of future strategies:
[16:20:48.189] 1. sequential:
[16:20:48.189]    - args: function (..., envir = parent.frame())
[16:20:48.189]    - tweaked: FALSE
[16:20:48.189]    - call: NULL
[16:20:48.189] plan(): nbrOfWorkers() = 1
[16:20:48.190] plan(): Setting new future strategy stack:
[16:20:48.190] List of future strategies:
[16:20:48.190] 1. sequential:
[16:20:48.190]    - args: function (..., envir = parent.frame())
[16:20:48.190]    - tweaked: FALSE
[16:20:48.190]    - call: plan(strategy)
[16:20:48.191] plan(): nbrOfWorkers() = 1
[16:20:48.191] SequentialFuture started (and completed)
[16:20:48.191] - Launch lazy future ... done
[16:20:48.191] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[16:20:48.194] getGlobalsAndPackages() ...
[16:20:48.194] Searching for globals...
[16:20:48.195] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[16:20:48.195] Searching for globals ... DONE
[16:20:48.195] Resolving globals: FALSE
[16:20:48.196] 
[16:20:48.196] - packages: [2] ‘stats’, ‘datasets’
[16:20:48.196] getGlobalsAndPackages() ... DONE
[16:20:48.196] run() for ‘Future’ ...
[16:20:48.196] - state: ‘created’
[16:20:48.196] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:48.197] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:48.197] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:48.197]   - Field: ‘label’
[16:20:48.197]   - Field: ‘local’
[16:20:48.197]   - Field: ‘owner’
[16:20:48.197]   - Field: ‘envir’
[16:20:48.197]   - Field: ‘packages’
[16:20:48.197]   - Field: ‘gc’
[16:20:48.198]   - Field: ‘conditions’
[16:20:48.198]   - Field: ‘expr’
[16:20:48.198]   - Field: ‘uuid’
[16:20:48.198]   - Field: ‘seed’
[16:20:48.198]   - Field: ‘version’
[16:20:48.198]   - Field: ‘result’
[16:20:48.198]   - Field: ‘asynchronous’
[16:20:48.198]   - Field: ‘calls’
[16:20:48.198]   - Field: ‘globals’
[16:20:48.198]   - Field: ‘stdout’
[16:20:48.198]   - Field: ‘earlySignal’
[16:20:48.199]   - Field: ‘lazy’
[16:20:48.199]   - Field: ‘state’
[16:20:48.199] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:48.199] - Launch lazy future ...
[16:20:48.199] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:20:48.199] Packages needed by future strategies (n = 0): <none>
[16:20:48.200] {
[16:20:48.200]     {
[16:20:48.200]         {
[16:20:48.200]             ...future.startTime <- base::Sys.time()
[16:20:48.200]             {
[16:20:48.200]                 {
[16:20:48.200]                   {
[16:20:48.200]                     {
[16:20:48.200]                       base::local({
[16:20:48.200]                         has_future <- base::requireNamespace("future", 
[16:20:48.200]                           quietly = TRUE)
[16:20:48.200]                         if (has_future) {
[16:20:48.200]                           ns <- base::getNamespace("future")
[16:20:48.200]                           version <- ns[[".package"]][["version"]]
[16:20:48.200]                           if (is.null(version)) 
[16:20:48.200]                             version <- utils::packageVersion("future")
[16:20:48.200]                         }
[16:20:48.200]                         else {
[16:20:48.200]                           version <- NULL
[16:20:48.200]                         }
[16:20:48.200]                         if (!has_future || version < "1.8.0") {
[16:20:48.200]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.200]                             "", base::R.version$version.string), 
[16:20:48.200]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:48.200]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:48.200]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.200]                               "release", "version")], collapse = " "), 
[16:20:48.200]                             hostname = base::Sys.info()[["nodename"]])
[16:20:48.200]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.200]                             info)
[16:20:48.200]                           info <- base::paste(info, collapse = "; ")
[16:20:48.200]                           if (!has_future) {
[16:20:48.200]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.200]                               info)
[16:20:48.200]                           }
[16:20:48.200]                           else {
[16:20:48.200]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.200]                               info, version)
[16:20:48.200]                           }
[16:20:48.200]                           base::stop(msg)
[16:20:48.200]                         }
[16:20:48.200]                       })
[16:20:48.200]                     }
[16:20:48.200]                     base::local({
[16:20:48.200]                       for (pkg in c("stats", "datasets")) {
[16:20:48.200]                         base::loadNamespace(pkg)
[16:20:48.200]                         base::library(pkg, character.only = TRUE)
[16:20:48.200]                       }
[16:20:48.200]                     })
[16:20:48.200]                   }
[16:20:48.200]                   ...future.strategy.old <- future::plan("list")
[16:20:48.200]                   options(future.plan = NULL)
[16:20:48.200]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.200]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.200]                 }
[16:20:48.200]                 ...future.workdir <- getwd()
[16:20:48.200]             }
[16:20:48.200]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.200]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.200]         }
[16:20:48.200]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.200]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.200]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.200]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.200]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.200]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.200]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.200]             base::names(...future.oldOptions))
[16:20:48.200]     }
[16:20:48.200]     if (FALSE) {
[16:20:48.200]     }
[16:20:48.200]     else {
[16:20:48.200]         if (TRUE) {
[16:20:48.200]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.200]                 open = "w")
[16:20:48.200]         }
[16:20:48.200]         else {
[16:20:48.200]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.200]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.200]         }
[16:20:48.200]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.200]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.200]             base::sink(type = "output", split = FALSE)
[16:20:48.200]             base::close(...future.stdout)
[16:20:48.200]         }, add = TRUE)
[16:20:48.200]     }
[16:20:48.200]     ...future.frame <- base::sys.nframe()
[16:20:48.200]     ...future.conditions <- base::list()
[16:20:48.200]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.200]     if (FALSE) {
[16:20:48.200]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.200]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.200]     }
[16:20:48.200]     ...future.result <- base::tryCatch({
[16:20:48.200]         base::withCallingHandlers({
[16:20:48.200]             ...future.value <- base::withVisible(base::local({
[16:20:48.200]                 lm(dist ~ . + 0, data = cars)
[16:20:48.200]             }))
[16:20:48.200]             future::FutureResult(value = ...future.value$value, 
[16:20:48.200]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.200]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.200]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.200]                     ...future.globalenv.names))
[16:20:48.200]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.200]         }, condition = base::local({
[16:20:48.200]             c <- base::c
[16:20:48.200]             inherits <- base::inherits
[16:20:48.200]             invokeRestart <- base::invokeRestart
[16:20:48.200]             length <- base::length
[16:20:48.200]             list <- base::list
[16:20:48.200]             seq.int <- base::seq.int
[16:20:48.200]             signalCondition <- base::signalCondition
[16:20:48.200]             sys.calls <- base::sys.calls
[16:20:48.200]             `[[` <- base::`[[`
[16:20:48.200]             `+` <- base::`+`
[16:20:48.200]             `<<-` <- base::`<<-`
[16:20:48.200]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.200]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.200]                   3L)]
[16:20:48.200]             }
[16:20:48.200]             function(cond) {
[16:20:48.200]                 is_error <- inherits(cond, "error")
[16:20:48.200]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.200]                   NULL)
[16:20:48.200]                 if (is_error) {
[16:20:48.200]                   sessionInformation <- function() {
[16:20:48.200]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.200]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.200]                       search = base::search(), system = base::Sys.info())
[16:20:48.200]                   }
[16:20:48.200]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.200]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.200]                     cond$call), session = sessionInformation(), 
[16:20:48.200]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.200]                   signalCondition(cond)
[16:20:48.200]                 }
[16:20:48.200]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.200]                 "immediateCondition"))) {
[16:20:48.200]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.200]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.200]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.200]                   if (TRUE && !signal) {
[16:20:48.200]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.200]                     {
[16:20:48.200]                       inherits <- base::inherits
[16:20:48.200]                       invokeRestart <- base::invokeRestart
[16:20:48.200]                       is.null <- base::is.null
[16:20:48.200]                       muffled <- FALSE
[16:20:48.200]                       if (inherits(cond, "message")) {
[16:20:48.200]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.200]                         if (muffled) 
[16:20:48.200]                           invokeRestart("muffleMessage")
[16:20:48.200]                       }
[16:20:48.200]                       else if (inherits(cond, "warning")) {
[16:20:48.200]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.200]                         if (muffled) 
[16:20:48.200]                           invokeRestart("muffleWarning")
[16:20:48.200]                       }
[16:20:48.200]                       else if (inherits(cond, "condition")) {
[16:20:48.200]                         if (!is.null(pattern)) {
[16:20:48.200]                           computeRestarts <- base::computeRestarts
[16:20:48.200]                           grepl <- base::grepl
[16:20:48.200]                           restarts <- computeRestarts(cond)
[16:20:48.200]                           for (restart in restarts) {
[16:20:48.200]                             name <- restart$name
[16:20:48.200]                             if (is.null(name)) 
[16:20:48.200]                               next
[16:20:48.200]                             if (!grepl(pattern, name)) 
[16:20:48.200]                               next
[16:20:48.200]                             invokeRestart(restart)
[16:20:48.200]                             muffled <- TRUE
[16:20:48.200]                             break
[16:20:48.200]                           }
[16:20:48.200]                         }
[16:20:48.200]                       }
[16:20:48.200]                       invisible(muffled)
[16:20:48.200]                     }
[16:20:48.200]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.200]                   }
[16:20:48.200]                 }
[16:20:48.200]                 else {
[16:20:48.200]                   if (TRUE) {
[16:20:48.200]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.200]                     {
[16:20:48.200]                       inherits <- base::inherits
[16:20:48.200]                       invokeRestart <- base::invokeRestart
[16:20:48.200]                       is.null <- base::is.null
[16:20:48.200]                       muffled <- FALSE
[16:20:48.200]                       if (inherits(cond, "message")) {
[16:20:48.200]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.200]                         if (muffled) 
[16:20:48.200]                           invokeRestart("muffleMessage")
[16:20:48.200]                       }
[16:20:48.200]                       else if (inherits(cond, "warning")) {
[16:20:48.200]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.200]                         if (muffled) 
[16:20:48.200]                           invokeRestart("muffleWarning")
[16:20:48.200]                       }
[16:20:48.200]                       else if (inherits(cond, "condition")) {
[16:20:48.200]                         if (!is.null(pattern)) {
[16:20:48.200]                           computeRestarts <- base::computeRestarts
[16:20:48.200]                           grepl <- base::grepl
[16:20:48.200]                           restarts <- computeRestarts(cond)
[16:20:48.200]                           for (restart in restarts) {
[16:20:48.200]                             name <- restart$name
[16:20:48.200]                             if (is.null(name)) 
[16:20:48.200]                               next
[16:20:48.200]                             if (!grepl(pattern, name)) 
[16:20:48.200]                               next
[16:20:48.200]                             invokeRestart(restart)
[16:20:48.200]                             muffled <- TRUE
[16:20:48.200]                             break
[16:20:48.200]                           }
[16:20:48.200]                         }
[16:20:48.200]                       }
[16:20:48.200]                       invisible(muffled)
[16:20:48.200]                     }
[16:20:48.200]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.200]                   }
[16:20:48.200]                 }
[16:20:48.200]             }
[16:20:48.200]         }))
[16:20:48.200]     }, error = function(ex) {
[16:20:48.200]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.200]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.200]                 ...future.rng), started = ...future.startTime, 
[16:20:48.200]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.200]             version = "1.8"), class = "FutureResult")
[16:20:48.200]     }, finally = {
[16:20:48.200]         if (!identical(...future.workdir, getwd())) 
[16:20:48.200]             setwd(...future.workdir)
[16:20:48.200]         {
[16:20:48.200]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.200]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.200]             }
[16:20:48.200]             base::options(...future.oldOptions)
[16:20:48.200]             if (.Platform$OS.type == "windows") {
[16:20:48.200]                 old_names <- names(...future.oldEnvVars)
[16:20:48.200]                 envs <- base::Sys.getenv()
[16:20:48.200]                 names <- names(envs)
[16:20:48.200]                 common <- intersect(names, old_names)
[16:20:48.200]                 added <- setdiff(names, old_names)
[16:20:48.200]                 removed <- setdiff(old_names, names)
[16:20:48.200]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.200]                   envs[common]]
[16:20:48.200]                 NAMES <- toupper(changed)
[16:20:48.200]                 args <- list()
[16:20:48.200]                 for (kk in seq_along(NAMES)) {
[16:20:48.200]                   name <- changed[[kk]]
[16:20:48.200]                   NAME <- NAMES[[kk]]
[16:20:48.200]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.200]                     next
[16:20:48.200]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.200]                 }
[16:20:48.200]                 NAMES <- toupper(added)
[16:20:48.200]                 for (kk in seq_along(NAMES)) {
[16:20:48.200]                   name <- added[[kk]]
[16:20:48.200]                   NAME <- NAMES[[kk]]
[16:20:48.200]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.200]                     next
[16:20:48.200]                   args[[name]] <- ""
[16:20:48.200]                 }
[16:20:48.200]                 NAMES <- toupper(removed)
[16:20:48.200]                 for (kk in seq_along(NAMES)) {
[16:20:48.200]                   name <- removed[[kk]]
[16:20:48.200]                   NAME <- NAMES[[kk]]
[16:20:48.200]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.200]                     next
[16:20:48.200]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.200]                 }
[16:20:48.200]                 if (length(args) > 0) 
[16:20:48.200]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.200]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.200]             }
[16:20:48.200]             else {
[16:20:48.200]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.200]             }
[16:20:48.200]             {
[16:20:48.200]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.200]                   0L) {
[16:20:48.200]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.200]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.200]                   base::options(opts)
[16:20:48.200]                 }
[16:20:48.200]                 {
[16:20:48.200]                   {
[16:20:48.200]                     NULL
[16:20:48.200]                     RNGkind("Mersenne-Twister")
[16:20:48.200]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:48.200]                       inherits = FALSE)
[16:20:48.200]                   }
[16:20:48.200]                   options(future.plan = NULL)
[16:20:48.200]                   if (is.na(NA_character_)) 
[16:20:48.200]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.200]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.200]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.200]                     .init = FALSE)
[16:20:48.200]                 }
[16:20:48.200]             }
[16:20:48.200]         }
[16:20:48.200]     })
[16:20:48.200]     if (TRUE) {
[16:20:48.200]         base::sink(type = "output", split = FALSE)
[16:20:48.200]         if (TRUE) {
[16:20:48.200]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.200]         }
[16:20:48.200]         else {
[16:20:48.200]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.200]         }
[16:20:48.200]         base::close(...future.stdout)
[16:20:48.200]         ...future.stdout <- NULL
[16:20:48.200]     }
[16:20:48.200]     ...future.result$conditions <- ...future.conditions
[16:20:48.200]     ...future.result$finished <- base::Sys.time()
[16:20:48.200]     ...future.result
[16:20:48.200] }
[16:20:48.202] plan(): Setting new future strategy stack:
[16:20:48.202] List of future strategies:
[16:20:48.202] 1. sequential:
[16:20:48.202]    - args: function (..., envir = parent.frame())
[16:20:48.202]    - tweaked: FALSE
[16:20:48.202]    - call: NULL
[16:20:48.202] plan(): nbrOfWorkers() = 1
[16:20:48.203] plan(): Setting new future strategy stack:
[16:20:48.203] List of future strategies:
[16:20:48.203] 1. sequential:
[16:20:48.203]    - args: function (..., envir = parent.frame())
[16:20:48.203]    - tweaked: FALSE
[16:20:48.203]    - call: plan(strategy)
[16:20:48.204] plan(): nbrOfWorkers() = 1
[16:20:48.204] SequentialFuture started (and completed)
[16:20:48.204] - Launch lazy future ... done
[16:20:48.204] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[16:20:48.208] getGlobalsAndPackages() ...
[16:20:48.208] Searching for globals...
[16:20:48.210] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[16:20:48.210] Searching for globals ... DONE
[16:20:48.210] Resolving globals: FALSE
[16:20:48.210] 
[16:20:48.210] - packages: [2] ‘stats’, ‘datasets’
[16:20:48.211] getGlobalsAndPackages() ... DONE
[16:20:48.211] run() for ‘Future’ ...
[16:20:48.211] - state: ‘created’
[16:20:48.211] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:48.211] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:48.211] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:48.212]   - Field: ‘label’
[16:20:48.212]   - Field: ‘local’
[16:20:48.212]   - Field: ‘owner’
[16:20:48.212]   - Field: ‘envir’
[16:20:48.212]   - Field: ‘packages’
[16:20:48.212]   - Field: ‘gc’
[16:20:48.212]   - Field: ‘conditions’
[16:20:48.212]   - Field: ‘expr’
[16:20:48.212]   - Field: ‘uuid’
[16:20:48.212]   - Field: ‘seed’
[16:20:48.213]   - Field: ‘version’
[16:20:48.213]   - Field: ‘result’
[16:20:48.213]   - Field: ‘asynchronous’
[16:20:48.213]   - Field: ‘calls’
[16:20:48.213]   - Field: ‘globals’
[16:20:48.213]   - Field: ‘stdout’
[16:20:48.213]   - Field: ‘earlySignal’
[16:20:48.213]   - Field: ‘lazy’
[16:20:48.213]   - Field: ‘state’
[16:20:48.213] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:48.213] - Launch lazy future ...
[16:20:48.214] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:20:48.214] Packages needed by future strategies (n = 0): <none>
[16:20:48.214] {
[16:20:48.214]     {
[16:20:48.214]         {
[16:20:48.214]             ...future.startTime <- base::Sys.time()
[16:20:48.214]             {
[16:20:48.214]                 {
[16:20:48.214]                   {
[16:20:48.214]                     {
[16:20:48.214]                       base::local({
[16:20:48.214]                         has_future <- base::requireNamespace("future", 
[16:20:48.214]                           quietly = TRUE)
[16:20:48.214]                         if (has_future) {
[16:20:48.214]                           ns <- base::getNamespace("future")
[16:20:48.214]                           version <- ns[[".package"]][["version"]]
[16:20:48.214]                           if (is.null(version)) 
[16:20:48.214]                             version <- utils::packageVersion("future")
[16:20:48.214]                         }
[16:20:48.214]                         else {
[16:20:48.214]                           version <- NULL
[16:20:48.214]                         }
[16:20:48.214]                         if (!has_future || version < "1.8.0") {
[16:20:48.214]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.214]                             "", base::R.version$version.string), 
[16:20:48.214]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:48.214]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:48.214]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.214]                               "release", "version")], collapse = " "), 
[16:20:48.214]                             hostname = base::Sys.info()[["nodename"]])
[16:20:48.214]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.214]                             info)
[16:20:48.214]                           info <- base::paste(info, collapse = "; ")
[16:20:48.214]                           if (!has_future) {
[16:20:48.214]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.214]                               info)
[16:20:48.214]                           }
[16:20:48.214]                           else {
[16:20:48.214]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.214]                               info, version)
[16:20:48.214]                           }
[16:20:48.214]                           base::stop(msg)
[16:20:48.214]                         }
[16:20:48.214]                       })
[16:20:48.214]                     }
[16:20:48.214]                     base::local({
[16:20:48.214]                       for (pkg in c("stats", "datasets")) {
[16:20:48.214]                         base::loadNamespace(pkg)
[16:20:48.214]                         base::library(pkg, character.only = TRUE)
[16:20:48.214]                       }
[16:20:48.214]                     })
[16:20:48.214]                   }
[16:20:48.214]                   ...future.strategy.old <- future::plan("list")
[16:20:48.214]                   options(future.plan = NULL)
[16:20:48.214]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.214]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.214]                 }
[16:20:48.214]                 ...future.workdir <- getwd()
[16:20:48.214]             }
[16:20:48.214]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.214]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.214]         }
[16:20:48.214]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.214]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.214]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.214]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.214]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.214]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.214]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.214]             base::names(...future.oldOptions))
[16:20:48.214]     }
[16:20:48.214]     if (FALSE) {
[16:20:48.214]     }
[16:20:48.214]     else {
[16:20:48.214]         if (TRUE) {
[16:20:48.214]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.214]                 open = "w")
[16:20:48.214]         }
[16:20:48.214]         else {
[16:20:48.214]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.214]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.214]         }
[16:20:48.214]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.214]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.214]             base::sink(type = "output", split = FALSE)
[16:20:48.214]             base::close(...future.stdout)
[16:20:48.214]         }, add = TRUE)
[16:20:48.214]     }
[16:20:48.214]     ...future.frame <- base::sys.nframe()
[16:20:48.214]     ...future.conditions <- base::list()
[16:20:48.214]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.214]     if (FALSE) {
[16:20:48.214]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.214]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.214]     }
[16:20:48.214]     ...future.result <- base::tryCatch({
[16:20:48.214]         base::withCallingHandlers({
[16:20:48.214]             ...future.value <- base::withVisible(base::local({
[16:20:48.214]                 lm(dist ~ speed + speed^2, data = cars)
[16:20:48.214]             }))
[16:20:48.214]             future::FutureResult(value = ...future.value$value, 
[16:20:48.214]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.214]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.214]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.214]                     ...future.globalenv.names))
[16:20:48.214]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.214]         }, condition = base::local({
[16:20:48.214]             c <- base::c
[16:20:48.214]             inherits <- base::inherits
[16:20:48.214]             invokeRestart <- base::invokeRestart
[16:20:48.214]             length <- base::length
[16:20:48.214]             list <- base::list
[16:20:48.214]             seq.int <- base::seq.int
[16:20:48.214]             signalCondition <- base::signalCondition
[16:20:48.214]             sys.calls <- base::sys.calls
[16:20:48.214]             `[[` <- base::`[[`
[16:20:48.214]             `+` <- base::`+`
[16:20:48.214]             `<<-` <- base::`<<-`
[16:20:48.214]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.214]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.214]                   3L)]
[16:20:48.214]             }
[16:20:48.214]             function(cond) {
[16:20:48.214]                 is_error <- inherits(cond, "error")
[16:20:48.214]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.214]                   NULL)
[16:20:48.214]                 if (is_error) {
[16:20:48.214]                   sessionInformation <- function() {
[16:20:48.214]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.214]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.214]                       search = base::search(), system = base::Sys.info())
[16:20:48.214]                   }
[16:20:48.214]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.214]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.214]                     cond$call), session = sessionInformation(), 
[16:20:48.214]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.214]                   signalCondition(cond)
[16:20:48.214]                 }
[16:20:48.214]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.214]                 "immediateCondition"))) {
[16:20:48.214]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.214]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.214]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.214]                   if (TRUE && !signal) {
[16:20:48.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.214]                     {
[16:20:48.214]                       inherits <- base::inherits
[16:20:48.214]                       invokeRestart <- base::invokeRestart
[16:20:48.214]                       is.null <- base::is.null
[16:20:48.214]                       muffled <- FALSE
[16:20:48.214]                       if (inherits(cond, "message")) {
[16:20:48.214]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.214]                         if (muffled) 
[16:20:48.214]                           invokeRestart("muffleMessage")
[16:20:48.214]                       }
[16:20:48.214]                       else if (inherits(cond, "warning")) {
[16:20:48.214]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.214]                         if (muffled) 
[16:20:48.214]                           invokeRestart("muffleWarning")
[16:20:48.214]                       }
[16:20:48.214]                       else if (inherits(cond, "condition")) {
[16:20:48.214]                         if (!is.null(pattern)) {
[16:20:48.214]                           computeRestarts <- base::computeRestarts
[16:20:48.214]                           grepl <- base::grepl
[16:20:48.214]                           restarts <- computeRestarts(cond)
[16:20:48.214]                           for (restart in restarts) {
[16:20:48.214]                             name <- restart$name
[16:20:48.214]                             if (is.null(name)) 
[16:20:48.214]                               next
[16:20:48.214]                             if (!grepl(pattern, name)) 
[16:20:48.214]                               next
[16:20:48.214]                             invokeRestart(restart)
[16:20:48.214]                             muffled <- TRUE
[16:20:48.214]                             break
[16:20:48.214]                           }
[16:20:48.214]                         }
[16:20:48.214]                       }
[16:20:48.214]                       invisible(muffled)
[16:20:48.214]                     }
[16:20:48.214]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.214]                   }
[16:20:48.214]                 }
[16:20:48.214]                 else {
[16:20:48.214]                   if (TRUE) {
[16:20:48.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.214]                     {
[16:20:48.214]                       inherits <- base::inherits
[16:20:48.214]                       invokeRestart <- base::invokeRestart
[16:20:48.214]                       is.null <- base::is.null
[16:20:48.214]                       muffled <- FALSE
[16:20:48.214]                       if (inherits(cond, "message")) {
[16:20:48.214]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.214]                         if (muffled) 
[16:20:48.214]                           invokeRestart("muffleMessage")
[16:20:48.214]                       }
[16:20:48.214]                       else if (inherits(cond, "warning")) {
[16:20:48.214]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.214]                         if (muffled) 
[16:20:48.214]                           invokeRestart("muffleWarning")
[16:20:48.214]                       }
[16:20:48.214]                       else if (inherits(cond, "condition")) {
[16:20:48.214]                         if (!is.null(pattern)) {
[16:20:48.214]                           computeRestarts <- base::computeRestarts
[16:20:48.214]                           grepl <- base::grepl
[16:20:48.214]                           restarts <- computeRestarts(cond)
[16:20:48.214]                           for (restart in restarts) {
[16:20:48.214]                             name <- restart$name
[16:20:48.214]                             if (is.null(name)) 
[16:20:48.214]                               next
[16:20:48.214]                             if (!grepl(pattern, name)) 
[16:20:48.214]                               next
[16:20:48.214]                             invokeRestart(restart)
[16:20:48.214]                             muffled <- TRUE
[16:20:48.214]                             break
[16:20:48.214]                           }
[16:20:48.214]                         }
[16:20:48.214]                       }
[16:20:48.214]                       invisible(muffled)
[16:20:48.214]                     }
[16:20:48.214]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.214]                   }
[16:20:48.214]                 }
[16:20:48.214]             }
[16:20:48.214]         }))
[16:20:48.214]     }, error = function(ex) {
[16:20:48.214]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.214]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.214]                 ...future.rng), started = ...future.startTime, 
[16:20:48.214]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.214]             version = "1.8"), class = "FutureResult")
[16:20:48.214]     }, finally = {
[16:20:48.214]         if (!identical(...future.workdir, getwd())) 
[16:20:48.214]             setwd(...future.workdir)
[16:20:48.214]         {
[16:20:48.214]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.214]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.214]             }
[16:20:48.214]             base::options(...future.oldOptions)
[16:20:48.214]             if (.Platform$OS.type == "windows") {
[16:20:48.214]                 old_names <- names(...future.oldEnvVars)
[16:20:48.214]                 envs <- base::Sys.getenv()
[16:20:48.214]                 names <- names(envs)
[16:20:48.214]                 common <- intersect(names, old_names)
[16:20:48.214]                 added <- setdiff(names, old_names)
[16:20:48.214]                 removed <- setdiff(old_names, names)
[16:20:48.214]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.214]                   envs[common]]
[16:20:48.214]                 NAMES <- toupper(changed)
[16:20:48.214]                 args <- list()
[16:20:48.214]                 for (kk in seq_along(NAMES)) {
[16:20:48.214]                   name <- changed[[kk]]
[16:20:48.214]                   NAME <- NAMES[[kk]]
[16:20:48.214]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.214]                     next
[16:20:48.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.214]                 }
[16:20:48.214]                 NAMES <- toupper(added)
[16:20:48.214]                 for (kk in seq_along(NAMES)) {
[16:20:48.214]                   name <- added[[kk]]
[16:20:48.214]                   NAME <- NAMES[[kk]]
[16:20:48.214]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.214]                     next
[16:20:48.214]                   args[[name]] <- ""
[16:20:48.214]                 }
[16:20:48.214]                 NAMES <- toupper(removed)
[16:20:48.214]                 for (kk in seq_along(NAMES)) {
[16:20:48.214]                   name <- removed[[kk]]
[16:20:48.214]                   NAME <- NAMES[[kk]]
[16:20:48.214]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.214]                     next
[16:20:48.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.214]                 }
[16:20:48.214]                 if (length(args) > 0) 
[16:20:48.214]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.214]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.214]             }
[16:20:48.214]             else {
[16:20:48.214]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.214]             }
[16:20:48.214]             {
[16:20:48.214]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.214]                   0L) {
[16:20:48.214]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.214]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.214]                   base::options(opts)
[16:20:48.214]                 }
[16:20:48.214]                 {
[16:20:48.214]                   {
[16:20:48.214]                     NULL
[16:20:48.214]                     RNGkind("Mersenne-Twister")
[16:20:48.214]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:48.214]                       inherits = FALSE)
[16:20:48.214]                   }
[16:20:48.214]                   options(future.plan = NULL)
[16:20:48.214]                   if (is.na(NA_character_)) 
[16:20:48.214]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.214]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.214]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.214]                     .init = FALSE)
[16:20:48.214]                 }
[16:20:48.214]             }
[16:20:48.214]         }
[16:20:48.214]     })
[16:20:48.214]     if (TRUE) {
[16:20:48.214]         base::sink(type = "output", split = FALSE)
[16:20:48.214]         if (TRUE) {
[16:20:48.214]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.214]         }
[16:20:48.214]         else {
[16:20:48.214]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.214]         }
[16:20:48.214]         base::close(...future.stdout)
[16:20:48.214]         ...future.stdout <- NULL
[16:20:48.214]     }
[16:20:48.214]     ...future.result$conditions <- ...future.conditions
[16:20:48.214]     ...future.result$finished <- base::Sys.time()
[16:20:48.214]     ...future.result
[16:20:48.214] }
[16:20:48.216] plan(): Setting new future strategy stack:
[16:20:48.216] List of future strategies:
[16:20:48.216] 1. sequential:
[16:20:48.216]    - args: function (..., envir = parent.frame())
[16:20:48.216]    - tweaked: FALSE
[16:20:48.216]    - call: NULL
[16:20:48.217] plan(): nbrOfWorkers() = 1
[16:20:48.218] plan(): Setting new future strategy stack:
[16:20:48.218] List of future strategies:
[16:20:48.218] 1. sequential:
[16:20:48.218]    - args: function (..., envir = parent.frame())
[16:20:48.218]    - tweaked: FALSE
[16:20:48.218]    - call: plan(strategy)
[16:20:48.218] plan(): nbrOfWorkers() = 1
[16:20:48.218] SequentialFuture started (and completed)
[16:20:48.218] - Launch lazy future ... done
[16:20:48.219] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[16:20:48.221] getGlobalsAndPackages() ...
[16:20:48.221] Searching for globals...
[16:20:48.223] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[16:20:48.223] Searching for globals ... DONE
[16:20:48.223] Resolving globals: FALSE
[16:20:48.223] 
[16:20:48.224] - packages: [2] ‘stats’, ‘datasets’
[16:20:48.224] getGlobalsAndPackages() ... DONE
[16:20:48.224] run() for ‘Future’ ...
[16:20:48.224] - state: ‘created’
[16:20:48.224] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:48.224] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:48.224] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:48.225]   - Field: ‘label’
[16:20:48.225]   - Field: ‘local’
[16:20:48.225]   - Field: ‘owner’
[16:20:48.225]   - Field: ‘envir’
[16:20:48.225]   - Field: ‘packages’
[16:20:48.225]   - Field: ‘gc’
[16:20:48.225]   - Field: ‘conditions’
[16:20:48.225]   - Field: ‘expr’
[16:20:48.225]   - Field: ‘uuid’
[16:20:48.225]   - Field: ‘seed’
[16:20:48.225]   - Field: ‘version’
[16:20:48.226]   - Field: ‘result’
[16:20:48.226]   - Field: ‘asynchronous’
[16:20:48.226]   - Field: ‘calls’
[16:20:48.226]   - Field: ‘globals’
[16:20:48.226]   - Field: ‘stdout’
[16:20:48.226]   - Field: ‘earlySignal’
[16:20:48.226]   - Field: ‘lazy’
[16:20:48.226]   - Field: ‘state’
[16:20:48.226] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:48.226] - Launch lazy future ...
[16:20:48.227] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:20:48.227] Packages needed by future strategies (n = 0): <none>
[16:20:48.227] {
[16:20:48.227]     {
[16:20:48.227]         {
[16:20:48.227]             ...future.startTime <- base::Sys.time()
[16:20:48.227]             {
[16:20:48.227]                 {
[16:20:48.227]                   {
[16:20:48.227]                     {
[16:20:48.227]                       base::local({
[16:20:48.227]                         has_future <- base::requireNamespace("future", 
[16:20:48.227]                           quietly = TRUE)
[16:20:48.227]                         if (has_future) {
[16:20:48.227]                           ns <- base::getNamespace("future")
[16:20:48.227]                           version <- ns[[".package"]][["version"]]
[16:20:48.227]                           if (is.null(version)) 
[16:20:48.227]                             version <- utils::packageVersion("future")
[16:20:48.227]                         }
[16:20:48.227]                         else {
[16:20:48.227]                           version <- NULL
[16:20:48.227]                         }
[16:20:48.227]                         if (!has_future || version < "1.8.0") {
[16:20:48.227]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.227]                             "", base::R.version$version.string), 
[16:20:48.227]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:48.227]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:48.227]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.227]                               "release", "version")], collapse = " "), 
[16:20:48.227]                             hostname = base::Sys.info()[["nodename"]])
[16:20:48.227]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.227]                             info)
[16:20:48.227]                           info <- base::paste(info, collapse = "; ")
[16:20:48.227]                           if (!has_future) {
[16:20:48.227]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.227]                               info)
[16:20:48.227]                           }
[16:20:48.227]                           else {
[16:20:48.227]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.227]                               info, version)
[16:20:48.227]                           }
[16:20:48.227]                           base::stop(msg)
[16:20:48.227]                         }
[16:20:48.227]                       })
[16:20:48.227]                     }
[16:20:48.227]                     base::local({
[16:20:48.227]                       for (pkg in c("stats", "datasets")) {
[16:20:48.227]                         base::loadNamespace(pkg)
[16:20:48.227]                         base::library(pkg, character.only = TRUE)
[16:20:48.227]                       }
[16:20:48.227]                     })
[16:20:48.227]                   }
[16:20:48.227]                   ...future.strategy.old <- future::plan("list")
[16:20:48.227]                   options(future.plan = NULL)
[16:20:48.227]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.227]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.227]                 }
[16:20:48.227]                 ...future.workdir <- getwd()
[16:20:48.227]             }
[16:20:48.227]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.227]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.227]         }
[16:20:48.227]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.227]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.227]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.227]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.227]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.227]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.227]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.227]             base::names(...future.oldOptions))
[16:20:48.227]     }
[16:20:48.227]     if (FALSE) {
[16:20:48.227]     }
[16:20:48.227]     else {
[16:20:48.227]         if (TRUE) {
[16:20:48.227]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.227]                 open = "w")
[16:20:48.227]         }
[16:20:48.227]         else {
[16:20:48.227]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.227]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.227]         }
[16:20:48.227]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.227]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.227]             base::sink(type = "output", split = FALSE)
[16:20:48.227]             base::close(...future.stdout)
[16:20:48.227]         }, add = TRUE)
[16:20:48.227]     }
[16:20:48.227]     ...future.frame <- base::sys.nframe()
[16:20:48.227]     ...future.conditions <- base::list()
[16:20:48.227]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.227]     if (FALSE) {
[16:20:48.227]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.227]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.227]     }
[16:20:48.227]     ...future.result <- base::tryCatch({
[16:20:48.227]         base::withCallingHandlers({
[16:20:48.227]             ...future.value <- base::withVisible(base::local({
[16:20:48.227]                 lm(dist ~ speed + I(speed^2), data = cars)
[16:20:48.227]             }))
[16:20:48.227]             future::FutureResult(value = ...future.value$value, 
[16:20:48.227]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.227]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.227]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.227]                     ...future.globalenv.names))
[16:20:48.227]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.227]         }, condition = base::local({
[16:20:48.227]             c <- base::c
[16:20:48.227]             inherits <- base::inherits
[16:20:48.227]             invokeRestart <- base::invokeRestart
[16:20:48.227]             length <- base::length
[16:20:48.227]             list <- base::list
[16:20:48.227]             seq.int <- base::seq.int
[16:20:48.227]             signalCondition <- base::signalCondition
[16:20:48.227]             sys.calls <- base::sys.calls
[16:20:48.227]             `[[` <- base::`[[`
[16:20:48.227]             `+` <- base::`+`
[16:20:48.227]             `<<-` <- base::`<<-`
[16:20:48.227]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.227]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.227]                   3L)]
[16:20:48.227]             }
[16:20:48.227]             function(cond) {
[16:20:48.227]                 is_error <- inherits(cond, "error")
[16:20:48.227]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.227]                   NULL)
[16:20:48.227]                 if (is_error) {
[16:20:48.227]                   sessionInformation <- function() {
[16:20:48.227]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.227]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.227]                       search = base::search(), system = base::Sys.info())
[16:20:48.227]                   }
[16:20:48.227]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.227]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.227]                     cond$call), session = sessionInformation(), 
[16:20:48.227]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.227]                   signalCondition(cond)
[16:20:48.227]                 }
[16:20:48.227]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.227]                 "immediateCondition"))) {
[16:20:48.227]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.227]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.227]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.227]                   if (TRUE && !signal) {
[16:20:48.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.227]                     {
[16:20:48.227]                       inherits <- base::inherits
[16:20:48.227]                       invokeRestart <- base::invokeRestart
[16:20:48.227]                       is.null <- base::is.null
[16:20:48.227]                       muffled <- FALSE
[16:20:48.227]                       if (inherits(cond, "message")) {
[16:20:48.227]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.227]                         if (muffled) 
[16:20:48.227]                           invokeRestart("muffleMessage")
[16:20:48.227]                       }
[16:20:48.227]                       else if (inherits(cond, "warning")) {
[16:20:48.227]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.227]                         if (muffled) 
[16:20:48.227]                           invokeRestart("muffleWarning")
[16:20:48.227]                       }
[16:20:48.227]                       else if (inherits(cond, "condition")) {
[16:20:48.227]                         if (!is.null(pattern)) {
[16:20:48.227]                           computeRestarts <- base::computeRestarts
[16:20:48.227]                           grepl <- base::grepl
[16:20:48.227]                           restarts <- computeRestarts(cond)
[16:20:48.227]                           for (restart in restarts) {
[16:20:48.227]                             name <- restart$name
[16:20:48.227]                             if (is.null(name)) 
[16:20:48.227]                               next
[16:20:48.227]                             if (!grepl(pattern, name)) 
[16:20:48.227]                               next
[16:20:48.227]                             invokeRestart(restart)
[16:20:48.227]                             muffled <- TRUE
[16:20:48.227]                             break
[16:20:48.227]                           }
[16:20:48.227]                         }
[16:20:48.227]                       }
[16:20:48.227]                       invisible(muffled)
[16:20:48.227]                     }
[16:20:48.227]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.227]                   }
[16:20:48.227]                 }
[16:20:48.227]                 else {
[16:20:48.227]                   if (TRUE) {
[16:20:48.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.227]                     {
[16:20:48.227]                       inherits <- base::inherits
[16:20:48.227]                       invokeRestart <- base::invokeRestart
[16:20:48.227]                       is.null <- base::is.null
[16:20:48.227]                       muffled <- FALSE
[16:20:48.227]                       if (inherits(cond, "message")) {
[16:20:48.227]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.227]                         if (muffled) 
[16:20:48.227]                           invokeRestart("muffleMessage")
[16:20:48.227]                       }
[16:20:48.227]                       else if (inherits(cond, "warning")) {
[16:20:48.227]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.227]                         if (muffled) 
[16:20:48.227]                           invokeRestart("muffleWarning")
[16:20:48.227]                       }
[16:20:48.227]                       else if (inherits(cond, "condition")) {
[16:20:48.227]                         if (!is.null(pattern)) {
[16:20:48.227]                           computeRestarts <- base::computeRestarts
[16:20:48.227]                           grepl <- base::grepl
[16:20:48.227]                           restarts <- computeRestarts(cond)
[16:20:48.227]                           for (restart in restarts) {
[16:20:48.227]                             name <- restart$name
[16:20:48.227]                             if (is.null(name)) 
[16:20:48.227]                               next
[16:20:48.227]                             if (!grepl(pattern, name)) 
[16:20:48.227]                               next
[16:20:48.227]                             invokeRestart(restart)
[16:20:48.227]                             muffled <- TRUE
[16:20:48.227]                             break
[16:20:48.227]                           }
[16:20:48.227]                         }
[16:20:48.227]                       }
[16:20:48.227]                       invisible(muffled)
[16:20:48.227]                     }
[16:20:48.227]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.227]                   }
[16:20:48.227]                 }
[16:20:48.227]             }
[16:20:48.227]         }))
[16:20:48.227]     }, error = function(ex) {
[16:20:48.227]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.227]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.227]                 ...future.rng), started = ...future.startTime, 
[16:20:48.227]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.227]             version = "1.8"), class = "FutureResult")
[16:20:48.227]     }, finally = {
[16:20:48.227]         if (!identical(...future.workdir, getwd())) 
[16:20:48.227]             setwd(...future.workdir)
[16:20:48.227]         {
[16:20:48.227]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.227]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.227]             }
[16:20:48.227]             base::options(...future.oldOptions)
[16:20:48.227]             if (.Platform$OS.type == "windows") {
[16:20:48.227]                 old_names <- names(...future.oldEnvVars)
[16:20:48.227]                 envs <- base::Sys.getenv()
[16:20:48.227]                 names <- names(envs)
[16:20:48.227]                 common <- intersect(names, old_names)
[16:20:48.227]                 added <- setdiff(names, old_names)
[16:20:48.227]                 removed <- setdiff(old_names, names)
[16:20:48.227]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.227]                   envs[common]]
[16:20:48.227]                 NAMES <- toupper(changed)
[16:20:48.227]                 args <- list()
[16:20:48.227]                 for (kk in seq_along(NAMES)) {
[16:20:48.227]                   name <- changed[[kk]]
[16:20:48.227]                   NAME <- NAMES[[kk]]
[16:20:48.227]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.227]                     next
[16:20:48.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.227]                 }
[16:20:48.227]                 NAMES <- toupper(added)
[16:20:48.227]                 for (kk in seq_along(NAMES)) {
[16:20:48.227]                   name <- added[[kk]]
[16:20:48.227]                   NAME <- NAMES[[kk]]
[16:20:48.227]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.227]                     next
[16:20:48.227]                   args[[name]] <- ""
[16:20:48.227]                 }
[16:20:48.227]                 NAMES <- toupper(removed)
[16:20:48.227]                 for (kk in seq_along(NAMES)) {
[16:20:48.227]                   name <- removed[[kk]]
[16:20:48.227]                   NAME <- NAMES[[kk]]
[16:20:48.227]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.227]                     next
[16:20:48.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.227]                 }
[16:20:48.227]                 if (length(args) > 0) 
[16:20:48.227]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.227]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.227]             }
[16:20:48.227]             else {
[16:20:48.227]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.227]             }
[16:20:48.227]             {
[16:20:48.227]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.227]                   0L) {
[16:20:48.227]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.227]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.227]                   base::options(opts)
[16:20:48.227]                 }
[16:20:48.227]                 {
[16:20:48.227]                   {
[16:20:48.227]                     NULL
[16:20:48.227]                     RNGkind("Mersenne-Twister")
[16:20:48.227]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:48.227]                       inherits = FALSE)
[16:20:48.227]                   }
[16:20:48.227]                   options(future.plan = NULL)
[16:20:48.227]                   if (is.na(NA_character_)) 
[16:20:48.227]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.227]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.227]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.227]                     .init = FALSE)
[16:20:48.227]                 }
[16:20:48.227]             }
[16:20:48.227]         }
[16:20:48.227]     })
[16:20:48.227]     if (TRUE) {
[16:20:48.227]         base::sink(type = "output", split = FALSE)
[16:20:48.227]         if (TRUE) {
[16:20:48.227]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.227]         }
[16:20:48.227]         else {
[16:20:48.227]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.227]         }
[16:20:48.227]         base::close(...future.stdout)
[16:20:48.227]         ...future.stdout <- NULL
[16:20:48.227]     }
[16:20:48.227]     ...future.result$conditions <- ...future.conditions
[16:20:48.227]     ...future.result$finished <- base::Sys.time()
[16:20:48.227]     ...future.result
[16:20:48.227] }
[16:20:48.229] plan(): Setting new future strategy stack:
[16:20:48.229] List of future strategies:
[16:20:48.229] 1. sequential:
[16:20:48.229]    - args: function (..., envir = parent.frame())
[16:20:48.229]    - tweaked: FALSE
[16:20:48.229]    - call: NULL
[16:20:48.231] plan(): nbrOfWorkers() = 1
[16:20:48.232] plan(): Setting new future strategy stack:
[16:20:48.232] List of future strategies:
[16:20:48.232] 1. sequential:
[16:20:48.232]    - args: function (..., envir = parent.frame())
[16:20:48.232]    - tweaked: FALSE
[16:20:48.232]    - call: plan(strategy)
[16:20:48.233] plan(): nbrOfWorkers() = 1
[16:20:48.233] SequentialFuture started (and completed)
[16:20:48.233] - Launch lazy future ... done
[16:20:48.233] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[16:20:48.236] getGlobalsAndPackages() ...
[16:20:48.236] Searching for globals...
[16:20:48.238] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[16:20:48.238] Searching for globals ... DONE
[16:20:48.238] Resolving globals: FALSE
[16:20:48.238] 
[16:20:48.239] - packages: [2] ‘stats’, ‘datasets’
[16:20:48.239] getGlobalsAndPackages() ... DONE
[16:20:48.239] run() for ‘Future’ ...
[16:20:48.239] - state: ‘created’
[16:20:48.239] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:48.239] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:48.239] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:48.240]   - Field: ‘label’
[16:20:48.240]   - Field: ‘local’
[16:20:48.240]   - Field: ‘owner’
[16:20:48.240]   - Field: ‘envir’
[16:20:48.240]   - Field: ‘packages’
[16:20:48.240]   - Field: ‘gc’
[16:20:48.240]   - Field: ‘conditions’
[16:20:48.240]   - Field: ‘expr’
[16:20:48.240]   - Field: ‘uuid’
[16:20:48.240]   - Field: ‘seed’
[16:20:48.240]   - Field: ‘version’
[16:20:48.241]   - Field: ‘result’
[16:20:48.241]   - Field: ‘asynchronous’
[16:20:48.241]   - Field: ‘calls’
[16:20:48.241]   - Field: ‘globals’
[16:20:48.241]   - Field: ‘stdout’
[16:20:48.241]   - Field: ‘earlySignal’
[16:20:48.241]   - Field: ‘lazy’
[16:20:48.241]   - Field: ‘state’
[16:20:48.241] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:48.241] - Launch lazy future ...
[16:20:48.242] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:20:48.242] Packages needed by future strategies (n = 0): <none>
[16:20:48.242] {
[16:20:48.242]     {
[16:20:48.242]         {
[16:20:48.242]             ...future.startTime <- base::Sys.time()
[16:20:48.242]             {
[16:20:48.242]                 {
[16:20:48.242]                   {
[16:20:48.242]                     {
[16:20:48.242]                       base::local({
[16:20:48.242]                         has_future <- base::requireNamespace("future", 
[16:20:48.242]                           quietly = TRUE)
[16:20:48.242]                         if (has_future) {
[16:20:48.242]                           ns <- base::getNamespace("future")
[16:20:48.242]                           version <- ns[[".package"]][["version"]]
[16:20:48.242]                           if (is.null(version)) 
[16:20:48.242]                             version <- utils::packageVersion("future")
[16:20:48.242]                         }
[16:20:48.242]                         else {
[16:20:48.242]                           version <- NULL
[16:20:48.242]                         }
[16:20:48.242]                         if (!has_future || version < "1.8.0") {
[16:20:48.242]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.242]                             "", base::R.version$version.string), 
[16:20:48.242]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:48.242]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:48.242]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.242]                               "release", "version")], collapse = " "), 
[16:20:48.242]                             hostname = base::Sys.info()[["nodename"]])
[16:20:48.242]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.242]                             info)
[16:20:48.242]                           info <- base::paste(info, collapse = "; ")
[16:20:48.242]                           if (!has_future) {
[16:20:48.242]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.242]                               info)
[16:20:48.242]                           }
[16:20:48.242]                           else {
[16:20:48.242]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.242]                               info, version)
[16:20:48.242]                           }
[16:20:48.242]                           base::stop(msg)
[16:20:48.242]                         }
[16:20:48.242]                       })
[16:20:48.242]                     }
[16:20:48.242]                     base::local({
[16:20:48.242]                       for (pkg in c("stats", "datasets")) {
[16:20:48.242]                         base::loadNamespace(pkg)
[16:20:48.242]                         base::library(pkg, character.only = TRUE)
[16:20:48.242]                       }
[16:20:48.242]                     })
[16:20:48.242]                   }
[16:20:48.242]                   ...future.strategy.old <- future::plan("list")
[16:20:48.242]                   options(future.plan = NULL)
[16:20:48.242]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.242]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.242]                 }
[16:20:48.242]                 ...future.workdir <- getwd()
[16:20:48.242]             }
[16:20:48.242]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.242]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.242]         }
[16:20:48.242]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.242]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.242]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.242]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.242]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.242]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.242]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.242]             base::names(...future.oldOptions))
[16:20:48.242]     }
[16:20:48.242]     if (FALSE) {
[16:20:48.242]     }
[16:20:48.242]     else {
[16:20:48.242]         if (TRUE) {
[16:20:48.242]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.242]                 open = "w")
[16:20:48.242]         }
[16:20:48.242]         else {
[16:20:48.242]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.242]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.242]         }
[16:20:48.242]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.242]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.242]             base::sink(type = "output", split = FALSE)
[16:20:48.242]             base::close(...future.stdout)
[16:20:48.242]         }, add = TRUE)
[16:20:48.242]     }
[16:20:48.242]     ...future.frame <- base::sys.nframe()
[16:20:48.242]     ...future.conditions <- base::list()
[16:20:48.242]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.242]     if (FALSE) {
[16:20:48.242]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.242]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.242]     }
[16:20:48.242]     ...future.result <- base::tryCatch({
[16:20:48.242]         base::withCallingHandlers({
[16:20:48.242]             ...future.value <- base::withVisible(base::local({
[16:20:48.242]                 lm(dist ~ poly(speed, 2), data = cars)
[16:20:48.242]             }))
[16:20:48.242]             future::FutureResult(value = ...future.value$value, 
[16:20:48.242]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.242]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.242]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.242]                     ...future.globalenv.names))
[16:20:48.242]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.242]         }, condition = base::local({
[16:20:48.242]             c <- base::c
[16:20:48.242]             inherits <- base::inherits
[16:20:48.242]             invokeRestart <- base::invokeRestart
[16:20:48.242]             length <- base::length
[16:20:48.242]             list <- base::list
[16:20:48.242]             seq.int <- base::seq.int
[16:20:48.242]             signalCondition <- base::signalCondition
[16:20:48.242]             sys.calls <- base::sys.calls
[16:20:48.242]             `[[` <- base::`[[`
[16:20:48.242]             `+` <- base::`+`
[16:20:48.242]             `<<-` <- base::`<<-`
[16:20:48.242]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.242]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.242]                   3L)]
[16:20:48.242]             }
[16:20:48.242]             function(cond) {
[16:20:48.242]                 is_error <- inherits(cond, "error")
[16:20:48.242]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.242]                   NULL)
[16:20:48.242]                 if (is_error) {
[16:20:48.242]                   sessionInformation <- function() {
[16:20:48.242]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.242]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.242]                       search = base::search(), system = base::Sys.info())
[16:20:48.242]                   }
[16:20:48.242]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.242]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.242]                     cond$call), session = sessionInformation(), 
[16:20:48.242]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.242]                   signalCondition(cond)
[16:20:48.242]                 }
[16:20:48.242]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.242]                 "immediateCondition"))) {
[16:20:48.242]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.242]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.242]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.242]                   if (TRUE && !signal) {
[16:20:48.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.242]                     {
[16:20:48.242]                       inherits <- base::inherits
[16:20:48.242]                       invokeRestart <- base::invokeRestart
[16:20:48.242]                       is.null <- base::is.null
[16:20:48.242]                       muffled <- FALSE
[16:20:48.242]                       if (inherits(cond, "message")) {
[16:20:48.242]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.242]                         if (muffled) 
[16:20:48.242]                           invokeRestart("muffleMessage")
[16:20:48.242]                       }
[16:20:48.242]                       else if (inherits(cond, "warning")) {
[16:20:48.242]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.242]                         if (muffled) 
[16:20:48.242]                           invokeRestart("muffleWarning")
[16:20:48.242]                       }
[16:20:48.242]                       else if (inherits(cond, "condition")) {
[16:20:48.242]                         if (!is.null(pattern)) {
[16:20:48.242]                           computeRestarts <- base::computeRestarts
[16:20:48.242]                           grepl <- base::grepl
[16:20:48.242]                           restarts <- computeRestarts(cond)
[16:20:48.242]                           for (restart in restarts) {
[16:20:48.242]                             name <- restart$name
[16:20:48.242]                             if (is.null(name)) 
[16:20:48.242]                               next
[16:20:48.242]                             if (!grepl(pattern, name)) 
[16:20:48.242]                               next
[16:20:48.242]                             invokeRestart(restart)
[16:20:48.242]                             muffled <- TRUE
[16:20:48.242]                             break
[16:20:48.242]                           }
[16:20:48.242]                         }
[16:20:48.242]                       }
[16:20:48.242]                       invisible(muffled)
[16:20:48.242]                     }
[16:20:48.242]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.242]                   }
[16:20:48.242]                 }
[16:20:48.242]                 else {
[16:20:48.242]                   if (TRUE) {
[16:20:48.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.242]                     {
[16:20:48.242]                       inherits <- base::inherits
[16:20:48.242]                       invokeRestart <- base::invokeRestart
[16:20:48.242]                       is.null <- base::is.null
[16:20:48.242]                       muffled <- FALSE
[16:20:48.242]                       if (inherits(cond, "message")) {
[16:20:48.242]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.242]                         if (muffled) 
[16:20:48.242]                           invokeRestart("muffleMessage")
[16:20:48.242]                       }
[16:20:48.242]                       else if (inherits(cond, "warning")) {
[16:20:48.242]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.242]                         if (muffled) 
[16:20:48.242]                           invokeRestart("muffleWarning")
[16:20:48.242]                       }
[16:20:48.242]                       else if (inherits(cond, "condition")) {
[16:20:48.242]                         if (!is.null(pattern)) {
[16:20:48.242]                           computeRestarts <- base::computeRestarts
[16:20:48.242]                           grepl <- base::grepl
[16:20:48.242]                           restarts <- computeRestarts(cond)
[16:20:48.242]                           for (restart in restarts) {
[16:20:48.242]                             name <- restart$name
[16:20:48.242]                             if (is.null(name)) 
[16:20:48.242]                               next
[16:20:48.242]                             if (!grepl(pattern, name)) 
[16:20:48.242]                               next
[16:20:48.242]                             invokeRestart(restart)
[16:20:48.242]                             muffled <- TRUE
[16:20:48.242]                             break
[16:20:48.242]                           }
[16:20:48.242]                         }
[16:20:48.242]                       }
[16:20:48.242]                       invisible(muffled)
[16:20:48.242]                     }
[16:20:48.242]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.242]                   }
[16:20:48.242]                 }
[16:20:48.242]             }
[16:20:48.242]         }))
[16:20:48.242]     }, error = function(ex) {
[16:20:48.242]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.242]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.242]                 ...future.rng), started = ...future.startTime, 
[16:20:48.242]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.242]             version = "1.8"), class = "FutureResult")
[16:20:48.242]     }, finally = {
[16:20:48.242]         if (!identical(...future.workdir, getwd())) 
[16:20:48.242]             setwd(...future.workdir)
[16:20:48.242]         {
[16:20:48.242]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.242]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.242]             }
[16:20:48.242]             base::options(...future.oldOptions)
[16:20:48.242]             if (.Platform$OS.type == "windows") {
[16:20:48.242]                 old_names <- names(...future.oldEnvVars)
[16:20:48.242]                 envs <- base::Sys.getenv()
[16:20:48.242]                 names <- names(envs)
[16:20:48.242]                 common <- intersect(names, old_names)
[16:20:48.242]                 added <- setdiff(names, old_names)
[16:20:48.242]                 removed <- setdiff(old_names, names)
[16:20:48.242]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.242]                   envs[common]]
[16:20:48.242]                 NAMES <- toupper(changed)
[16:20:48.242]                 args <- list()
[16:20:48.242]                 for (kk in seq_along(NAMES)) {
[16:20:48.242]                   name <- changed[[kk]]
[16:20:48.242]                   NAME <- NAMES[[kk]]
[16:20:48.242]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.242]                     next
[16:20:48.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.242]                 }
[16:20:48.242]                 NAMES <- toupper(added)
[16:20:48.242]                 for (kk in seq_along(NAMES)) {
[16:20:48.242]                   name <- added[[kk]]
[16:20:48.242]                   NAME <- NAMES[[kk]]
[16:20:48.242]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.242]                     next
[16:20:48.242]                   args[[name]] <- ""
[16:20:48.242]                 }
[16:20:48.242]                 NAMES <- toupper(removed)
[16:20:48.242]                 for (kk in seq_along(NAMES)) {
[16:20:48.242]                   name <- removed[[kk]]
[16:20:48.242]                   NAME <- NAMES[[kk]]
[16:20:48.242]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.242]                     next
[16:20:48.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.242]                 }
[16:20:48.242]                 if (length(args) > 0) 
[16:20:48.242]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.242]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.242]             }
[16:20:48.242]             else {
[16:20:48.242]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.242]             }
[16:20:48.242]             {
[16:20:48.242]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.242]                   0L) {
[16:20:48.242]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.242]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.242]                   base::options(opts)
[16:20:48.242]                 }
[16:20:48.242]                 {
[16:20:48.242]                   {
[16:20:48.242]                     NULL
[16:20:48.242]                     RNGkind("Mersenne-Twister")
[16:20:48.242]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:48.242]                       inherits = FALSE)
[16:20:48.242]                   }
[16:20:48.242]                   options(future.plan = NULL)
[16:20:48.242]                   if (is.na(NA_character_)) 
[16:20:48.242]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.242]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.242]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.242]                     .init = FALSE)
[16:20:48.242]                 }
[16:20:48.242]             }
[16:20:48.242]         }
[16:20:48.242]     })
[16:20:48.242]     if (TRUE) {
[16:20:48.242]         base::sink(type = "output", split = FALSE)
[16:20:48.242]         if (TRUE) {
[16:20:48.242]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.242]         }
[16:20:48.242]         else {
[16:20:48.242]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.242]         }
[16:20:48.242]         base::close(...future.stdout)
[16:20:48.242]         ...future.stdout <- NULL
[16:20:48.242]     }
[16:20:48.242]     ...future.result$conditions <- ...future.conditions
[16:20:48.242]     ...future.result$finished <- base::Sys.time()
[16:20:48.242]     ...future.result
[16:20:48.242] }
[16:20:48.244] plan(): Setting new future strategy stack:
[16:20:48.244] List of future strategies:
[16:20:48.244] 1. sequential:
[16:20:48.244]    - args: function (..., envir = parent.frame())
[16:20:48.244]    - tweaked: FALSE
[16:20:48.244]    - call: NULL
[16:20:48.244] plan(): nbrOfWorkers() = 1
[16:20:48.246] plan(): Setting new future strategy stack:
[16:20:48.246] List of future strategies:
[16:20:48.246] 1. sequential:
[16:20:48.246]    - args: function (..., envir = parent.frame())
[16:20:48.246]    - tweaked: FALSE
[16:20:48.246]    - call: plan(strategy)
[16:20:48.246] plan(): nbrOfWorkers() = 1
[16:20:48.246] SequentialFuture started (and completed)
[16:20:48.247] - Launch lazy future ... done
[16:20:48.247] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[16:20:48.248] getGlobalsAndPackages() ...
[16:20:48.249] Searching for globals...
[16:20:48.255] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[16:20:48.255] Searching for globals ... DONE
[16:20:48.255] Resolving globals: FALSE
[16:20:48.256] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[16:20:48.256] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[16:20:48.256] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[16:20:48.256] 
[16:20:48.256] getGlobalsAndPackages() ... DONE
[16:20:48.257] run() for ‘Future’ ...
[16:20:48.257] - state: ‘created’
[16:20:48.257] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:48.257] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:48.257] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:48.257]   - Field: ‘label’
[16:20:48.257]   - Field: ‘local’
[16:20:48.257]   - Field: ‘owner’
[16:20:48.257]   - Field: ‘envir’
[16:20:48.258]   - Field: ‘packages’
[16:20:48.258]   - Field: ‘gc’
[16:20:48.258]   - Field: ‘conditions’
[16:20:48.258]   - Field: ‘expr’
[16:20:48.258]   - Field: ‘uuid’
[16:20:48.258]   - Field: ‘seed’
[16:20:48.258]   - Field: ‘version’
[16:20:48.258]   - Field: ‘result’
[16:20:48.258]   - Field: ‘asynchronous’
[16:20:48.258]   - Field: ‘calls’
[16:20:48.258]   - Field: ‘globals’
[16:20:48.259]   - Field: ‘stdout’
[16:20:48.259]   - Field: ‘earlySignal’
[16:20:48.259]   - Field: ‘lazy’
[16:20:48.259]   - Field: ‘state’
[16:20:48.259] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:48.259] - Launch lazy future ...
[16:20:48.259] Packages needed by the future expression (n = 0): <none>
[16:20:48.259] Packages needed by future strategies (n = 0): <none>
[16:20:48.260] {
[16:20:48.260]     {
[16:20:48.260]         {
[16:20:48.260]             ...future.startTime <- base::Sys.time()
[16:20:48.260]             {
[16:20:48.260]                 {
[16:20:48.260]                   {
[16:20:48.260]                     base::local({
[16:20:48.260]                       has_future <- base::requireNamespace("future", 
[16:20:48.260]                         quietly = TRUE)
[16:20:48.260]                       if (has_future) {
[16:20:48.260]                         ns <- base::getNamespace("future")
[16:20:48.260]                         version <- ns[[".package"]][["version"]]
[16:20:48.260]                         if (is.null(version)) 
[16:20:48.260]                           version <- utils::packageVersion("future")
[16:20:48.260]                       }
[16:20:48.260]                       else {
[16:20:48.260]                         version <- NULL
[16:20:48.260]                       }
[16:20:48.260]                       if (!has_future || version < "1.8.0") {
[16:20:48.260]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.260]                           "", base::R.version$version.string), 
[16:20:48.260]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:48.260]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:48.260]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.260]                             "release", "version")], collapse = " "), 
[16:20:48.260]                           hostname = base::Sys.info()[["nodename"]])
[16:20:48.260]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.260]                           info)
[16:20:48.260]                         info <- base::paste(info, collapse = "; ")
[16:20:48.260]                         if (!has_future) {
[16:20:48.260]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.260]                             info)
[16:20:48.260]                         }
[16:20:48.260]                         else {
[16:20:48.260]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.260]                             info, version)
[16:20:48.260]                         }
[16:20:48.260]                         base::stop(msg)
[16:20:48.260]                       }
[16:20:48.260]                     })
[16:20:48.260]                   }
[16:20:48.260]                   ...future.strategy.old <- future::plan("list")
[16:20:48.260]                   options(future.plan = NULL)
[16:20:48.260]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.260]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.260]                 }
[16:20:48.260]                 ...future.workdir <- getwd()
[16:20:48.260]             }
[16:20:48.260]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.260]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.260]         }
[16:20:48.260]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.260]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.260]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.260]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.260]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.260]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.260]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.260]             base::names(...future.oldOptions))
[16:20:48.260]     }
[16:20:48.260]     if (FALSE) {
[16:20:48.260]     }
[16:20:48.260]     else {
[16:20:48.260]         if (TRUE) {
[16:20:48.260]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.260]                 open = "w")
[16:20:48.260]         }
[16:20:48.260]         else {
[16:20:48.260]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.260]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.260]         }
[16:20:48.260]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.260]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.260]             base::sink(type = "output", split = FALSE)
[16:20:48.260]             base::close(...future.stdout)
[16:20:48.260]         }, add = TRUE)
[16:20:48.260]     }
[16:20:48.260]     ...future.frame <- base::sys.nframe()
[16:20:48.260]     ...future.conditions <- base::list()
[16:20:48.260]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.260]     if (FALSE) {
[16:20:48.260]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.260]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.260]     }
[16:20:48.260]     ...future.result <- base::tryCatch({
[16:20:48.260]         base::withCallingHandlers({
[16:20:48.260]             ...future.value <- base::withVisible(base::local({
[16:20:48.260]                 outer_function(1L)
[16:20:48.260]             }))
[16:20:48.260]             future::FutureResult(value = ...future.value$value, 
[16:20:48.260]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.260]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.260]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.260]                     ...future.globalenv.names))
[16:20:48.260]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.260]         }, condition = base::local({
[16:20:48.260]             c <- base::c
[16:20:48.260]             inherits <- base::inherits
[16:20:48.260]             invokeRestart <- base::invokeRestart
[16:20:48.260]             length <- base::length
[16:20:48.260]             list <- base::list
[16:20:48.260]             seq.int <- base::seq.int
[16:20:48.260]             signalCondition <- base::signalCondition
[16:20:48.260]             sys.calls <- base::sys.calls
[16:20:48.260]             `[[` <- base::`[[`
[16:20:48.260]             `+` <- base::`+`
[16:20:48.260]             `<<-` <- base::`<<-`
[16:20:48.260]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.260]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.260]                   3L)]
[16:20:48.260]             }
[16:20:48.260]             function(cond) {
[16:20:48.260]                 is_error <- inherits(cond, "error")
[16:20:48.260]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.260]                   NULL)
[16:20:48.260]                 if (is_error) {
[16:20:48.260]                   sessionInformation <- function() {
[16:20:48.260]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.260]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.260]                       search = base::search(), system = base::Sys.info())
[16:20:48.260]                   }
[16:20:48.260]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.260]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.260]                     cond$call), session = sessionInformation(), 
[16:20:48.260]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.260]                   signalCondition(cond)
[16:20:48.260]                 }
[16:20:48.260]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.260]                 "immediateCondition"))) {
[16:20:48.260]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.260]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.260]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.260]                   if (TRUE && !signal) {
[16:20:48.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.260]                     {
[16:20:48.260]                       inherits <- base::inherits
[16:20:48.260]                       invokeRestart <- base::invokeRestart
[16:20:48.260]                       is.null <- base::is.null
[16:20:48.260]                       muffled <- FALSE
[16:20:48.260]                       if (inherits(cond, "message")) {
[16:20:48.260]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.260]                         if (muffled) 
[16:20:48.260]                           invokeRestart("muffleMessage")
[16:20:48.260]                       }
[16:20:48.260]                       else if (inherits(cond, "warning")) {
[16:20:48.260]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.260]                         if (muffled) 
[16:20:48.260]                           invokeRestart("muffleWarning")
[16:20:48.260]                       }
[16:20:48.260]                       else if (inherits(cond, "condition")) {
[16:20:48.260]                         if (!is.null(pattern)) {
[16:20:48.260]                           computeRestarts <- base::computeRestarts
[16:20:48.260]                           grepl <- base::grepl
[16:20:48.260]                           restarts <- computeRestarts(cond)
[16:20:48.260]                           for (restart in restarts) {
[16:20:48.260]                             name <- restart$name
[16:20:48.260]                             if (is.null(name)) 
[16:20:48.260]                               next
[16:20:48.260]                             if (!grepl(pattern, name)) 
[16:20:48.260]                               next
[16:20:48.260]                             invokeRestart(restart)
[16:20:48.260]                             muffled <- TRUE
[16:20:48.260]                             break
[16:20:48.260]                           }
[16:20:48.260]                         }
[16:20:48.260]                       }
[16:20:48.260]                       invisible(muffled)
[16:20:48.260]                     }
[16:20:48.260]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.260]                   }
[16:20:48.260]                 }
[16:20:48.260]                 else {
[16:20:48.260]                   if (TRUE) {
[16:20:48.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.260]                     {
[16:20:48.260]                       inherits <- base::inherits
[16:20:48.260]                       invokeRestart <- base::invokeRestart
[16:20:48.260]                       is.null <- base::is.null
[16:20:48.260]                       muffled <- FALSE
[16:20:48.260]                       if (inherits(cond, "message")) {
[16:20:48.260]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.260]                         if (muffled) 
[16:20:48.260]                           invokeRestart("muffleMessage")
[16:20:48.260]                       }
[16:20:48.260]                       else if (inherits(cond, "warning")) {
[16:20:48.260]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.260]                         if (muffled) 
[16:20:48.260]                           invokeRestart("muffleWarning")
[16:20:48.260]                       }
[16:20:48.260]                       else if (inherits(cond, "condition")) {
[16:20:48.260]                         if (!is.null(pattern)) {
[16:20:48.260]                           computeRestarts <- base::computeRestarts
[16:20:48.260]                           grepl <- base::grepl
[16:20:48.260]                           restarts <- computeRestarts(cond)
[16:20:48.260]                           for (restart in restarts) {
[16:20:48.260]                             name <- restart$name
[16:20:48.260]                             if (is.null(name)) 
[16:20:48.260]                               next
[16:20:48.260]                             if (!grepl(pattern, name)) 
[16:20:48.260]                               next
[16:20:48.260]                             invokeRestart(restart)
[16:20:48.260]                             muffled <- TRUE
[16:20:48.260]                             break
[16:20:48.260]                           }
[16:20:48.260]                         }
[16:20:48.260]                       }
[16:20:48.260]                       invisible(muffled)
[16:20:48.260]                     }
[16:20:48.260]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.260]                   }
[16:20:48.260]                 }
[16:20:48.260]             }
[16:20:48.260]         }))
[16:20:48.260]     }, error = function(ex) {
[16:20:48.260]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.260]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.260]                 ...future.rng), started = ...future.startTime, 
[16:20:48.260]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.260]             version = "1.8"), class = "FutureResult")
[16:20:48.260]     }, finally = {
[16:20:48.260]         if (!identical(...future.workdir, getwd())) 
[16:20:48.260]             setwd(...future.workdir)
[16:20:48.260]         {
[16:20:48.260]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.260]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.260]             }
[16:20:48.260]             base::options(...future.oldOptions)
[16:20:48.260]             if (.Platform$OS.type == "windows") {
[16:20:48.260]                 old_names <- names(...future.oldEnvVars)
[16:20:48.260]                 envs <- base::Sys.getenv()
[16:20:48.260]                 names <- names(envs)
[16:20:48.260]                 common <- intersect(names, old_names)
[16:20:48.260]                 added <- setdiff(names, old_names)
[16:20:48.260]                 removed <- setdiff(old_names, names)
[16:20:48.260]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.260]                   envs[common]]
[16:20:48.260]                 NAMES <- toupper(changed)
[16:20:48.260]                 args <- list()
[16:20:48.260]                 for (kk in seq_along(NAMES)) {
[16:20:48.260]                   name <- changed[[kk]]
[16:20:48.260]                   NAME <- NAMES[[kk]]
[16:20:48.260]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.260]                     next
[16:20:48.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.260]                 }
[16:20:48.260]                 NAMES <- toupper(added)
[16:20:48.260]                 for (kk in seq_along(NAMES)) {
[16:20:48.260]                   name <- added[[kk]]
[16:20:48.260]                   NAME <- NAMES[[kk]]
[16:20:48.260]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.260]                     next
[16:20:48.260]                   args[[name]] <- ""
[16:20:48.260]                 }
[16:20:48.260]                 NAMES <- toupper(removed)
[16:20:48.260]                 for (kk in seq_along(NAMES)) {
[16:20:48.260]                   name <- removed[[kk]]
[16:20:48.260]                   NAME <- NAMES[[kk]]
[16:20:48.260]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.260]                     next
[16:20:48.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.260]                 }
[16:20:48.260]                 if (length(args) > 0) 
[16:20:48.260]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.260]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.260]             }
[16:20:48.260]             else {
[16:20:48.260]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.260]             }
[16:20:48.260]             {
[16:20:48.260]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.260]                   0L) {
[16:20:48.260]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.260]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.260]                   base::options(opts)
[16:20:48.260]                 }
[16:20:48.260]                 {
[16:20:48.260]                   {
[16:20:48.260]                     NULL
[16:20:48.260]                     RNGkind("Mersenne-Twister")
[16:20:48.260]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:48.260]                       inherits = FALSE)
[16:20:48.260]                   }
[16:20:48.260]                   options(future.plan = NULL)
[16:20:48.260]                   if (is.na(NA_character_)) 
[16:20:48.260]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.260]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.260]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.260]                     .init = FALSE)
[16:20:48.260]                 }
[16:20:48.260]             }
[16:20:48.260]         }
[16:20:48.260]     })
[16:20:48.260]     if (TRUE) {
[16:20:48.260]         base::sink(type = "output", split = FALSE)
[16:20:48.260]         if (TRUE) {
[16:20:48.260]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.260]         }
[16:20:48.260]         else {
[16:20:48.260]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.260]         }
[16:20:48.260]         base::close(...future.stdout)
[16:20:48.260]         ...future.stdout <- NULL
[16:20:48.260]     }
[16:20:48.260]     ...future.result$conditions <- ...future.conditions
[16:20:48.260]     ...future.result$finished <- base::Sys.time()
[16:20:48.260]     ...future.result
[16:20:48.260] }
[16:20:48.261] assign_globals() ...
[16:20:48.261] List of 3
[16:20:48.261]  $ outer_function:function (x)  
[16:20:48.261]  $ map           :function (.x, .f, ...)  
[16:20:48.261]  $ inner_function:function (x)  
[16:20:48.261]  - attr(*, "where")=List of 3
[16:20:48.261]   ..$ outer_function:<environment: R_EmptyEnv> 
[16:20:48.261]   ..$ map           :<environment: R_EmptyEnv> 
[16:20:48.261]   ..$ inner_function:<environment: R_EmptyEnv> 
[16:20:48.261]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:48.261]  - attr(*, "resolved")= logi FALSE
[16:20:48.261]  - attr(*, "total_size")= num 7704
[16:20:48.261]  - attr(*, "already-done")= logi TRUE
[16:20:48.265] - reassign environment for ‘outer_function’
[16:20:48.265] - copied ‘outer_function’ to environment
[16:20:48.265] - reassign environment for ‘map’
[16:20:48.265] - copied ‘map’ to environment
[16:20:48.265] - reassign environment for ‘inner_function’
[16:20:48.265] - copied ‘inner_function’ to environment
[16:20:48.265] assign_globals() ... done
[16:20:48.266] plan(): Setting new future strategy stack:
[16:20:48.266] List of future strategies:
[16:20:48.266] 1. sequential:
[16:20:48.266]    - args: function (..., envir = parent.frame())
[16:20:48.266]    - tweaked: FALSE
[16:20:48.266]    - call: NULL
[16:20:48.266] plan(): nbrOfWorkers() = 1
[16:20:48.271] plan(): Setting new future strategy stack:
[16:20:48.271] List of future strategies:
[16:20:48.271] 1. sequential:
[16:20:48.271]    - args: function (..., envir = parent.frame())
[16:20:48.271]    - tweaked: FALSE
[16:20:48.271]    - call: plan(strategy)
[16:20:48.272] plan(): nbrOfWorkers() = 1
[16:20:48.272] SequentialFuture started (and completed)
[16:20:48.272] - Launch lazy future ... done
[16:20:48.272] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[16:20:48.273] getGlobalsAndPackages() ...
[16:20:48.273] Searching for globals...
[16:20:48.279] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[16:20:48.279] Searching for globals ... DONE
[16:20:48.280] Resolving globals: FALSE
[16:20:48.280] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[16:20:48.281] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[16:20:48.281] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[16:20:48.281] 
[16:20:48.281] getGlobalsAndPackages() ... DONE
[16:20:48.281] run() for ‘Future’ ...
[16:20:48.281] - state: ‘created’
[16:20:48.282] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:48.282] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:48.282] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:48.282]   - Field: ‘label’
[16:20:48.282]   - Field: ‘local’
[16:20:48.282]   - Field: ‘owner’
[16:20:48.282]   - Field: ‘envir’
[16:20:48.282]   - Field: ‘packages’
[16:20:48.282]   - Field: ‘gc’
[16:20:48.283]   - Field: ‘conditions’
[16:20:48.283]   - Field: ‘expr’
[16:20:48.283]   - Field: ‘uuid’
[16:20:48.283]   - Field: ‘seed’
[16:20:48.283]   - Field: ‘version’
[16:20:48.283]   - Field: ‘result’
[16:20:48.283]   - Field: ‘asynchronous’
[16:20:48.283]   - Field: ‘calls’
[16:20:48.283]   - Field: ‘globals’
[16:20:48.283]   - Field: ‘stdout’
[16:20:48.284]   - Field: ‘earlySignal’
[16:20:48.284]   - Field: ‘lazy’
[16:20:48.284]   - Field: ‘state’
[16:20:48.284] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:48.284] - Launch lazy future ...
[16:20:48.284] Packages needed by the future expression (n = 0): <none>
[16:20:48.284] Packages needed by future strategies (n = 0): <none>
[16:20:48.285] {
[16:20:48.285]     {
[16:20:48.285]         {
[16:20:48.285]             ...future.startTime <- base::Sys.time()
[16:20:48.285]             {
[16:20:48.285]                 {
[16:20:48.285]                   {
[16:20:48.285]                     base::local({
[16:20:48.285]                       has_future <- base::requireNamespace("future", 
[16:20:48.285]                         quietly = TRUE)
[16:20:48.285]                       if (has_future) {
[16:20:48.285]                         ns <- base::getNamespace("future")
[16:20:48.285]                         version <- ns[[".package"]][["version"]]
[16:20:48.285]                         if (is.null(version)) 
[16:20:48.285]                           version <- utils::packageVersion("future")
[16:20:48.285]                       }
[16:20:48.285]                       else {
[16:20:48.285]                         version <- NULL
[16:20:48.285]                       }
[16:20:48.285]                       if (!has_future || version < "1.8.0") {
[16:20:48.285]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.285]                           "", base::R.version$version.string), 
[16:20:48.285]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:48.285]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:48.285]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.285]                             "release", "version")], collapse = " "), 
[16:20:48.285]                           hostname = base::Sys.info()[["nodename"]])
[16:20:48.285]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.285]                           info)
[16:20:48.285]                         info <- base::paste(info, collapse = "; ")
[16:20:48.285]                         if (!has_future) {
[16:20:48.285]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.285]                             info)
[16:20:48.285]                         }
[16:20:48.285]                         else {
[16:20:48.285]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.285]                             info, version)
[16:20:48.285]                         }
[16:20:48.285]                         base::stop(msg)
[16:20:48.285]                       }
[16:20:48.285]                     })
[16:20:48.285]                   }
[16:20:48.285]                   ...future.strategy.old <- future::plan("list")
[16:20:48.285]                   options(future.plan = NULL)
[16:20:48.285]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.285]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.285]                 }
[16:20:48.285]                 ...future.workdir <- getwd()
[16:20:48.285]             }
[16:20:48.285]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.285]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.285]         }
[16:20:48.285]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.285]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.285]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.285]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.285]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.285]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.285]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.285]             base::names(...future.oldOptions))
[16:20:48.285]     }
[16:20:48.285]     if (FALSE) {
[16:20:48.285]     }
[16:20:48.285]     else {
[16:20:48.285]         if (TRUE) {
[16:20:48.285]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.285]                 open = "w")
[16:20:48.285]         }
[16:20:48.285]         else {
[16:20:48.285]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.285]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.285]         }
[16:20:48.285]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.285]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.285]             base::sink(type = "output", split = FALSE)
[16:20:48.285]             base::close(...future.stdout)
[16:20:48.285]         }, add = TRUE)
[16:20:48.285]     }
[16:20:48.285]     ...future.frame <- base::sys.nframe()
[16:20:48.285]     ...future.conditions <- base::list()
[16:20:48.285]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.285]     if (FALSE) {
[16:20:48.285]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.285]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.285]     }
[16:20:48.285]     ...future.result <- base::tryCatch({
[16:20:48.285]         base::withCallingHandlers({
[16:20:48.285]             ...future.value <- base::withVisible(base::local({
[16:20:48.285]                 outer_function(1L)
[16:20:48.285]             }))
[16:20:48.285]             future::FutureResult(value = ...future.value$value, 
[16:20:48.285]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.285]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.285]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.285]                     ...future.globalenv.names))
[16:20:48.285]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.285]         }, condition = base::local({
[16:20:48.285]             c <- base::c
[16:20:48.285]             inherits <- base::inherits
[16:20:48.285]             invokeRestart <- base::invokeRestart
[16:20:48.285]             length <- base::length
[16:20:48.285]             list <- base::list
[16:20:48.285]             seq.int <- base::seq.int
[16:20:48.285]             signalCondition <- base::signalCondition
[16:20:48.285]             sys.calls <- base::sys.calls
[16:20:48.285]             `[[` <- base::`[[`
[16:20:48.285]             `+` <- base::`+`
[16:20:48.285]             `<<-` <- base::`<<-`
[16:20:48.285]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.285]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.285]                   3L)]
[16:20:48.285]             }
[16:20:48.285]             function(cond) {
[16:20:48.285]                 is_error <- inherits(cond, "error")
[16:20:48.285]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.285]                   NULL)
[16:20:48.285]                 if (is_error) {
[16:20:48.285]                   sessionInformation <- function() {
[16:20:48.285]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.285]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.285]                       search = base::search(), system = base::Sys.info())
[16:20:48.285]                   }
[16:20:48.285]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.285]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.285]                     cond$call), session = sessionInformation(), 
[16:20:48.285]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.285]                   signalCondition(cond)
[16:20:48.285]                 }
[16:20:48.285]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.285]                 "immediateCondition"))) {
[16:20:48.285]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.285]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.285]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.285]                   if (TRUE && !signal) {
[16:20:48.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.285]                     {
[16:20:48.285]                       inherits <- base::inherits
[16:20:48.285]                       invokeRestart <- base::invokeRestart
[16:20:48.285]                       is.null <- base::is.null
[16:20:48.285]                       muffled <- FALSE
[16:20:48.285]                       if (inherits(cond, "message")) {
[16:20:48.285]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.285]                         if (muffled) 
[16:20:48.285]                           invokeRestart("muffleMessage")
[16:20:48.285]                       }
[16:20:48.285]                       else if (inherits(cond, "warning")) {
[16:20:48.285]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.285]                         if (muffled) 
[16:20:48.285]                           invokeRestart("muffleWarning")
[16:20:48.285]                       }
[16:20:48.285]                       else if (inherits(cond, "condition")) {
[16:20:48.285]                         if (!is.null(pattern)) {
[16:20:48.285]                           computeRestarts <- base::computeRestarts
[16:20:48.285]                           grepl <- base::grepl
[16:20:48.285]                           restarts <- computeRestarts(cond)
[16:20:48.285]                           for (restart in restarts) {
[16:20:48.285]                             name <- restart$name
[16:20:48.285]                             if (is.null(name)) 
[16:20:48.285]                               next
[16:20:48.285]                             if (!grepl(pattern, name)) 
[16:20:48.285]                               next
[16:20:48.285]                             invokeRestart(restart)
[16:20:48.285]                             muffled <- TRUE
[16:20:48.285]                             break
[16:20:48.285]                           }
[16:20:48.285]                         }
[16:20:48.285]                       }
[16:20:48.285]                       invisible(muffled)
[16:20:48.285]                     }
[16:20:48.285]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.285]                   }
[16:20:48.285]                 }
[16:20:48.285]                 else {
[16:20:48.285]                   if (TRUE) {
[16:20:48.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.285]                     {
[16:20:48.285]                       inherits <- base::inherits
[16:20:48.285]                       invokeRestart <- base::invokeRestart
[16:20:48.285]                       is.null <- base::is.null
[16:20:48.285]                       muffled <- FALSE
[16:20:48.285]                       if (inherits(cond, "message")) {
[16:20:48.285]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.285]                         if (muffled) 
[16:20:48.285]                           invokeRestart("muffleMessage")
[16:20:48.285]                       }
[16:20:48.285]                       else if (inherits(cond, "warning")) {
[16:20:48.285]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.285]                         if (muffled) 
[16:20:48.285]                           invokeRestart("muffleWarning")
[16:20:48.285]                       }
[16:20:48.285]                       else if (inherits(cond, "condition")) {
[16:20:48.285]                         if (!is.null(pattern)) {
[16:20:48.285]                           computeRestarts <- base::computeRestarts
[16:20:48.285]                           grepl <- base::grepl
[16:20:48.285]                           restarts <- computeRestarts(cond)
[16:20:48.285]                           for (restart in restarts) {
[16:20:48.285]                             name <- restart$name
[16:20:48.285]                             if (is.null(name)) 
[16:20:48.285]                               next
[16:20:48.285]                             if (!grepl(pattern, name)) 
[16:20:48.285]                               next
[16:20:48.285]                             invokeRestart(restart)
[16:20:48.285]                             muffled <- TRUE
[16:20:48.285]                             break
[16:20:48.285]                           }
[16:20:48.285]                         }
[16:20:48.285]                       }
[16:20:48.285]                       invisible(muffled)
[16:20:48.285]                     }
[16:20:48.285]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.285]                   }
[16:20:48.285]                 }
[16:20:48.285]             }
[16:20:48.285]         }))
[16:20:48.285]     }, error = function(ex) {
[16:20:48.285]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.285]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.285]                 ...future.rng), started = ...future.startTime, 
[16:20:48.285]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.285]             version = "1.8"), class = "FutureResult")
[16:20:48.285]     }, finally = {
[16:20:48.285]         if (!identical(...future.workdir, getwd())) 
[16:20:48.285]             setwd(...future.workdir)
[16:20:48.285]         {
[16:20:48.285]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.285]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.285]             }
[16:20:48.285]             base::options(...future.oldOptions)
[16:20:48.285]             if (.Platform$OS.type == "windows") {
[16:20:48.285]                 old_names <- names(...future.oldEnvVars)
[16:20:48.285]                 envs <- base::Sys.getenv()
[16:20:48.285]                 names <- names(envs)
[16:20:48.285]                 common <- intersect(names, old_names)
[16:20:48.285]                 added <- setdiff(names, old_names)
[16:20:48.285]                 removed <- setdiff(old_names, names)
[16:20:48.285]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.285]                   envs[common]]
[16:20:48.285]                 NAMES <- toupper(changed)
[16:20:48.285]                 args <- list()
[16:20:48.285]                 for (kk in seq_along(NAMES)) {
[16:20:48.285]                   name <- changed[[kk]]
[16:20:48.285]                   NAME <- NAMES[[kk]]
[16:20:48.285]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.285]                     next
[16:20:48.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.285]                 }
[16:20:48.285]                 NAMES <- toupper(added)
[16:20:48.285]                 for (kk in seq_along(NAMES)) {
[16:20:48.285]                   name <- added[[kk]]
[16:20:48.285]                   NAME <- NAMES[[kk]]
[16:20:48.285]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.285]                     next
[16:20:48.285]                   args[[name]] <- ""
[16:20:48.285]                 }
[16:20:48.285]                 NAMES <- toupper(removed)
[16:20:48.285]                 for (kk in seq_along(NAMES)) {
[16:20:48.285]                   name <- removed[[kk]]
[16:20:48.285]                   NAME <- NAMES[[kk]]
[16:20:48.285]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.285]                     next
[16:20:48.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.285]                 }
[16:20:48.285]                 if (length(args) > 0) 
[16:20:48.285]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.285]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.285]             }
[16:20:48.285]             else {
[16:20:48.285]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.285]             }
[16:20:48.285]             {
[16:20:48.285]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.285]                   0L) {
[16:20:48.285]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.285]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.285]                   base::options(opts)
[16:20:48.285]                 }
[16:20:48.285]                 {
[16:20:48.285]                   {
[16:20:48.285]                     NULL
[16:20:48.285]                     RNGkind("Mersenne-Twister")
[16:20:48.285]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:48.285]                       inherits = FALSE)
[16:20:48.285]                   }
[16:20:48.285]                   options(future.plan = NULL)
[16:20:48.285]                   if (is.na(NA_character_)) 
[16:20:48.285]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.285]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.285]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.285]                     .init = FALSE)
[16:20:48.285]                 }
[16:20:48.285]             }
[16:20:48.285]         }
[16:20:48.285]     })
[16:20:48.285]     if (TRUE) {
[16:20:48.285]         base::sink(type = "output", split = FALSE)
[16:20:48.285]         if (TRUE) {
[16:20:48.285]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.285]         }
[16:20:48.285]         else {
[16:20:48.285]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.285]         }
[16:20:48.285]         base::close(...future.stdout)
[16:20:48.285]         ...future.stdout <- NULL
[16:20:48.285]     }
[16:20:48.285]     ...future.result$conditions <- ...future.conditions
[16:20:48.285]     ...future.result$finished <- base::Sys.time()
[16:20:48.285]     ...future.result
[16:20:48.285] }
[16:20:48.286] assign_globals() ...
[16:20:48.286] List of 3
[16:20:48.286]  $ outer_function:function (x)  
[16:20:48.286]  $ map           :function (.x, .f, ...)  
[16:20:48.286]  $ inner_function:function (x)  
[16:20:48.286]  - attr(*, "where")=List of 3
[16:20:48.286]   ..$ outer_function:<environment: R_EmptyEnv> 
[16:20:48.286]   ..$ map           :<environment: R_EmptyEnv> 
[16:20:48.286]   ..$ inner_function:<environment: R_EmptyEnv> 
[16:20:48.286]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:48.286]  - attr(*, "resolved")= logi FALSE
[16:20:48.286]  - attr(*, "total_size")= num 7704
[16:20:48.286]  - attr(*, "already-done")= logi TRUE
[16:20:48.289] - reassign environment for ‘outer_function’
[16:20:48.290] - copied ‘outer_function’ to environment
[16:20:48.290] - reassign environment for ‘map’
[16:20:48.290] - copied ‘map’ to environment
[16:20:48.290] - reassign environment for ‘inner_function’
[16:20:48.290] - copied ‘inner_function’ to environment
[16:20:48.290] assign_globals() ... done
[16:20:48.290] plan(): Setting new future strategy stack:
[16:20:48.290] List of future strategies:
[16:20:48.290] 1. sequential:
[16:20:48.290]    - args: function (..., envir = parent.frame())
[16:20:48.290]    - tweaked: FALSE
[16:20:48.290]    - call: NULL
[16:20:48.291] plan(): nbrOfWorkers() = 1
[16:20:48.291] plan(): Setting new future strategy stack:
[16:20:48.292] List of future strategies:
[16:20:48.292] 1. sequential:
[16:20:48.292]    - args: function (..., envir = parent.frame())
[16:20:48.292]    - tweaked: FALSE
[16:20:48.292]    - call: plan(strategy)
[16:20:48.292] plan(): nbrOfWorkers() = 1
[16:20:48.292] SequentialFuture started (and completed)
[16:20:48.292] - Launch lazy future ... done
[16:20:48.292] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[16:20:48.304] plan(): Setting new future strategy stack:
[16:20:48.304] List of future strategies:
[16:20:48.304] 1. multicore:
[16:20:48.304]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:48.304]    - tweaked: FALSE
[16:20:48.304]    - call: plan(strategy)
[16:20:48.307] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[16:20:48.308] getGlobalsAndPackages() ...
[16:20:48.308] Searching for globals...
[16:20:48.309] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:20:48.309] Searching for globals ... DONE
[16:20:48.309] Resolving globals: FALSE
[16:20:48.310] The total size of the 2 globals is 896 bytes (896 bytes)
[16:20:48.310] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:20:48.310] - globals: [2] ‘weight’, ‘group’
[16:20:48.311] - packages: [1] ‘stats’
[16:20:48.311] getGlobalsAndPackages() ... DONE
[16:20:48.311] run() for ‘Future’ ...
[16:20:48.311] - state: ‘created’
[16:20:48.311] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:48.315] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:48.315] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:48.315]   - Field: ‘label’
[16:20:48.315]   - Field: ‘local’
[16:20:48.315]   - Field: ‘owner’
[16:20:48.315]   - Field: ‘envir’
[16:20:48.315]   - Field: ‘workers’
[16:20:48.315]   - Field: ‘packages’
[16:20:48.316]   - Field: ‘gc’
[16:20:48.316]   - Field: ‘job’
[16:20:48.316]   - Field: ‘conditions’
[16:20:48.316]   - Field: ‘expr’
[16:20:48.316]   - Field: ‘uuid’
[16:20:48.316]   - Field: ‘seed’
[16:20:48.316]   - Field: ‘version’
[16:20:48.316]   - Field: ‘result’
[16:20:48.316]   - Field: ‘asynchronous’
[16:20:48.316]   - Field: ‘calls’
[16:20:48.317]   - Field: ‘globals’
[16:20:48.317]   - Field: ‘stdout’
[16:20:48.317]   - Field: ‘earlySignal’
[16:20:48.317]   - Field: ‘lazy’
[16:20:48.317]   - Field: ‘state’
[16:20:48.317] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:48.317] - Launch lazy future ...
[16:20:48.318] Packages needed by the future expression (n = 1): ‘stats’
[16:20:48.318] Packages needed by future strategies (n = 0): <none>
[16:20:48.319] {
[16:20:48.319]     {
[16:20:48.319]         {
[16:20:48.319]             ...future.startTime <- base::Sys.time()
[16:20:48.319]             {
[16:20:48.319]                 {
[16:20:48.319]                   {
[16:20:48.319]                     {
[16:20:48.319]                       {
[16:20:48.319]                         base::local({
[16:20:48.319]                           has_future <- base::requireNamespace("future", 
[16:20:48.319]                             quietly = TRUE)
[16:20:48.319]                           if (has_future) {
[16:20:48.319]                             ns <- base::getNamespace("future")
[16:20:48.319]                             version <- ns[[".package"]][["version"]]
[16:20:48.319]                             if (is.null(version)) 
[16:20:48.319]                               version <- utils::packageVersion("future")
[16:20:48.319]                           }
[16:20:48.319]                           else {
[16:20:48.319]                             version <- NULL
[16:20:48.319]                           }
[16:20:48.319]                           if (!has_future || version < "1.8.0") {
[16:20:48.319]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.319]                               "", base::R.version$version.string), 
[16:20:48.319]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:48.319]                                 base::R.version$platform, 8 * 
[16:20:48.319]                                   base::.Machine$sizeof.pointer), 
[16:20:48.319]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.319]                                 "release", "version")], collapse = " "), 
[16:20:48.319]                               hostname = base::Sys.info()[["nodename"]])
[16:20:48.319]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.319]                               info)
[16:20:48.319]                             info <- base::paste(info, collapse = "; ")
[16:20:48.319]                             if (!has_future) {
[16:20:48.319]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.319]                                 info)
[16:20:48.319]                             }
[16:20:48.319]                             else {
[16:20:48.319]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.319]                                 info, version)
[16:20:48.319]                             }
[16:20:48.319]                             base::stop(msg)
[16:20:48.319]                           }
[16:20:48.319]                         })
[16:20:48.319]                       }
[16:20:48.319]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:48.319]                       base::options(mc.cores = 1L)
[16:20:48.319]                     }
[16:20:48.319]                     base::local({
[16:20:48.319]                       for (pkg in "stats") {
[16:20:48.319]                         base::loadNamespace(pkg)
[16:20:48.319]                         base::library(pkg, character.only = TRUE)
[16:20:48.319]                       }
[16:20:48.319]                     })
[16:20:48.319]                   }
[16:20:48.319]                   ...future.strategy.old <- future::plan("list")
[16:20:48.319]                   options(future.plan = NULL)
[16:20:48.319]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.319]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.319]                 }
[16:20:48.319]                 ...future.workdir <- getwd()
[16:20:48.319]             }
[16:20:48.319]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.319]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.319]         }
[16:20:48.319]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.319]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.319]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.319]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.319]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.319]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.319]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.319]             base::names(...future.oldOptions))
[16:20:48.319]     }
[16:20:48.319]     if (FALSE) {
[16:20:48.319]     }
[16:20:48.319]     else {
[16:20:48.319]         if (TRUE) {
[16:20:48.319]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.319]                 open = "w")
[16:20:48.319]         }
[16:20:48.319]         else {
[16:20:48.319]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.319]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.319]         }
[16:20:48.319]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.319]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.319]             base::sink(type = "output", split = FALSE)
[16:20:48.319]             base::close(...future.stdout)
[16:20:48.319]         }, add = TRUE)
[16:20:48.319]     }
[16:20:48.319]     ...future.frame <- base::sys.nframe()
[16:20:48.319]     ...future.conditions <- base::list()
[16:20:48.319]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.319]     if (FALSE) {
[16:20:48.319]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.319]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.319]     }
[16:20:48.319]     ...future.result <- base::tryCatch({
[16:20:48.319]         base::withCallingHandlers({
[16:20:48.319]             ...future.value <- base::withVisible(base::local({
[16:20:48.319]                 withCallingHandlers({
[16:20:48.319]                   {
[16:20:48.319]                     lm(weight ~ group - 1)
[16:20:48.319]                   }
[16:20:48.319]                 }, immediateCondition = function(cond) {
[16:20:48.319]                   save_rds <- function (object, pathname, ...) 
[16:20:48.319]                   {
[16:20:48.319]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:48.319]                     if (file_test("-f", pathname_tmp)) {
[16:20:48.319]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.319]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:48.319]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.319]                         fi_tmp[["mtime"]])
[16:20:48.319]                     }
[16:20:48.319]                     tryCatch({
[16:20:48.319]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:48.319]                     }, error = function(ex) {
[16:20:48.319]                       msg <- conditionMessage(ex)
[16:20:48.319]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.319]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:48.319]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.319]                         fi_tmp[["mtime"]], msg)
[16:20:48.319]                       ex$message <- msg
[16:20:48.319]                       stop(ex)
[16:20:48.319]                     })
[16:20:48.319]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:48.319]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:48.319]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:48.319]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.319]                       fi <- file.info(pathname)
[16:20:48.319]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:48.319]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.319]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:48.319]                         fi[["size"]], fi[["mtime"]])
[16:20:48.319]                       stop(msg)
[16:20:48.319]                     }
[16:20:48.319]                     invisible(pathname)
[16:20:48.319]                   }
[16:20:48.319]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:48.319]                     rootPath = tempdir()) 
[16:20:48.319]                   {
[16:20:48.319]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:48.319]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:48.319]                       tmpdir = path, fileext = ".rds")
[16:20:48.319]                     save_rds(obj, file)
[16:20:48.319]                   }
[16:20:48.319]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4Mnhkl/.future/immediateConditions")
[16:20:48.319]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.319]                   {
[16:20:48.319]                     inherits <- base::inherits
[16:20:48.319]                     invokeRestart <- base::invokeRestart
[16:20:48.319]                     is.null <- base::is.null
[16:20:48.319]                     muffled <- FALSE
[16:20:48.319]                     if (inherits(cond, "message")) {
[16:20:48.319]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:48.319]                       if (muffled) 
[16:20:48.319]                         invokeRestart("muffleMessage")
[16:20:48.319]                     }
[16:20:48.319]                     else if (inherits(cond, "warning")) {
[16:20:48.319]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:48.319]                       if (muffled) 
[16:20:48.319]                         invokeRestart("muffleWarning")
[16:20:48.319]                     }
[16:20:48.319]                     else if (inherits(cond, "condition")) {
[16:20:48.319]                       if (!is.null(pattern)) {
[16:20:48.319]                         computeRestarts <- base::computeRestarts
[16:20:48.319]                         grepl <- base::grepl
[16:20:48.319]                         restarts <- computeRestarts(cond)
[16:20:48.319]                         for (restart in restarts) {
[16:20:48.319]                           name <- restart$name
[16:20:48.319]                           if (is.null(name)) 
[16:20:48.319]                             next
[16:20:48.319]                           if (!grepl(pattern, name)) 
[16:20:48.319]                             next
[16:20:48.319]                           invokeRestart(restart)
[16:20:48.319]                           muffled <- TRUE
[16:20:48.319]                           break
[16:20:48.319]                         }
[16:20:48.319]                       }
[16:20:48.319]                     }
[16:20:48.319]                     invisible(muffled)
[16:20:48.319]                   }
[16:20:48.319]                   muffleCondition(cond)
[16:20:48.319]                 })
[16:20:48.319]             }))
[16:20:48.319]             future::FutureResult(value = ...future.value$value, 
[16:20:48.319]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.319]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.319]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.319]                     ...future.globalenv.names))
[16:20:48.319]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.319]         }, condition = base::local({
[16:20:48.319]             c <- base::c
[16:20:48.319]             inherits <- base::inherits
[16:20:48.319]             invokeRestart <- base::invokeRestart
[16:20:48.319]             length <- base::length
[16:20:48.319]             list <- base::list
[16:20:48.319]             seq.int <- base::seq.int
[16:20:48.319]             signalCondition <- base::signalCondition
[16:20:48.319]             sys.calls <- base::sys.calls
[16:20:48.319]             `[[` <- base::`[[`
[16:20:48.319]             `+` <- base::`+`
[16:20:48.319]             `<<-` <- base::`<<-`
[16:20:48.319]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.319]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.319]                   3L)]
[16:20:48.319]             }
[16:20:48.319]             function(cond) {
[16:20:48.319]                 is_error <- inherits(cond, "error")
[16:20:48.319]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.319]                   NULL)
[16:20:48.319]                 if (is_error) {
[16:20:48.319]                   sessionInformation <- function() {
[16:20:48.319]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.319]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.319]                       search = base::search(), system = base::Sys.info())
[16:20:48.319]                   }
[16:20:48.319]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.319]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.319]                     cond$call), session = sessionInformation(), 
[16:20:48.319]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.319]                   signalCondition(cond)
[16:20:48.319]                 }
[16:20:48.319]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.319]                 "immediateCondition"))) {
[16:20:48.319]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.319]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.319]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.319]                   if (TRUE && !signal) {
[16:20:48.319]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.319]                     {
[16:20:48.319]                       inherits <- base::inherits
[16:20:48.319]                       invokeRestart <- base::invokeRestart
[16:20:48.319]                       is.null <- base::is.null
[16:20:48.319]                       muffled <- FALSE
[16:20:48.319]                       if (inherits(cond, "message")) {
[16:20:48.319]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.319]                         if (muffled) 
[16:20:48.319]                           invokeRestart("muffleMessage")
[16:20:48.319]                       }
[16:20:48.319]                       else if (inherits(cond, "warning")) {
[16:20:48.319]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.319]                         if (muffled) 
[16:20:48.319]                           invokeRestart("muffleWarning")
[16:20:48.319]                       }
[16:20:48.319]                       else if (inherits(cond, "condition")) {
[16:20:48.319]                         if (!is.null(pattern)) {
[16:20:48.319]                           computeRestarts <- base::computeRestarts
[16:20:48.319]                           grepl <- base::grepl
[16:20:48.319]                           restarts <- computeRestarts(cond)
[16:20:48.319]                           for (restart in restarts) {
[16:20:48.319]                             name <- restart$name
[16:20:48.319]                             if (is.null(name)) 
[16:20:48.319]                               next
[16:20:48.319]                             if (!grepl(pattern, name)) 
[16:20:48.319]                               next
[16:20:48.319]                             invokeRestart(restart)
[16:20:48.319]                             muffled <- TRUE
[16:20:48.319]                             break
[16:20:48.319]                           }
[16:20:48.319]                         }
[16:20:48.319]                       }
[16:20:48.319]                       invisible(muffled)
[16:20:48.319]                     }
[16:20:48.319]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.319]                   }
[16:20:48.319]                 }
[16:20:48.319]                 else {
[16:20:48.319]                   if (TRUE) {
[16:20:48.319]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.319]                     {
[16:20:48.319]                       inherits <- base::inherits
[16:20:48.319]                       invokeRestart <- base::invokeRestart
[16:20:48.319]                       is.null <- base::is.null
[16:20:48.319]                       muffled <- FALSE
[16:20:48.319]                       if (inherits(cond, "message")) {
[16:20:48.319]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.319]                         if (muffled) 
[16:20:48.319]                           invokeRestart("muffleMessage")
[16:20:48.319]                       }
[16:20:48.319]                       else if (inherits(cond, "warning")) {
[16:20:48.319]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.319]                         if (muffled) 
[16:20:48.319]                           invokeRestart("muffleWarning")
[16:20:48.319]                       }
[16:20:48.319]                       else if (inherits(cond, "condition")) {
[16:20:48.319]                         if (!is.null(pattern)) {
[16:20:48.319]                           computeRestarts <- base::computeRestarts
[16:20:48.319]                           grepl <- base::grepl
[16:20:48.319]                           restarts <- computeRestarts(cond)
[16:20:48.319]                           for (restart in restarts) {
[16:20:48.319]                             name <- restart$name
[16:20:48.319]                             if (is.null(name)) 
[16:20:48.319]                               next
[16:20:48.319]                             if (!grepl(pattern, name)) 
[16:20:48.319]                               next
[16:20:48.319]                             invokeRestart(restart)
[16:20:48.319]                             muffled <- TRUE
[16:20:48.319]                             break
[16:20:48.319]                           }
[16:20:48.319]                         }
[16:20:48.319]                       }
[16:20:48.319]                       invisible(muffled)
[16:20:48.319]                     }
[16:20:48.319]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.319]                   }
[16:20:48.319]                 }
[16:20:48.319]             }
[16:20:48.319]         }))
[16:20:48.319]     }, error = function(ex) {
[16:20:48.319]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.319]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.319]                 ...future.rng), started = ...future.startTime, 
[16:20:48.319]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.319]             version = "1.8"), class = "FutureResult")
[16:20:48.319]     }, finally = {
[16:20:48.319]         if (!identical(...future.workdir, getwd())) 
[16:20:48.319]             setwd(...future.workdir)
[16:20:48.319]         {
[16:20:48.319]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.319]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.319]             }
[16:20:48.319]             base::options(...future.oldOptions)
[16:20:48.319]             if (.Platform$OS.type == "windows") {
[16:20:48.319]                 old_names <- names(...future.oldEnvVars)
[16:20:48.319]                 envs <- base::Sys.getenv()
[16:20:48.319]                 names <- names(envs)
[16:20:48.319]                 common <- intersect(names, old_names)
[16:20:48.319]                 added <- setdiff(names, old_names)
[16:20:48.319]                 removed <- setdiff(old_names, names)
[16:20:48.319]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.319]                   envs[common]]
[16:20:48.319]                 NAMES <- toupper(changed)
[16:20:48.319]                 args <- list()
[16:20:48.319]                 for (kk in seq_along(NAMES)) {
[16:20:48.319]                   name <- changed[[kk]]
[16:20:48.319]                   NAME <- NAMES[[kk]]
[16:20:48.319]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.319]                     next
[16:20:48.319]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.319]                 }
[16:20:48.319]                 NAMES <- toupper(added)
[16:20:48.319]                 for (kk in seq_along(NAMES)) {
[16:20:48.319]                   name <- added[[kk]]
[16:20:48.319]                   NAME <- NAMES[[kk]]
[16:20:48.319]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.319]                     next
[16:20:48.319]                   args[[name]] <- ""
[16:20:48.319]                 }
[16:20:48.319]                 NAMES <- toupper(removed)
[16:20:48.319]                 for (kk in seq_along(NAMES)) {
[16:20:48.319]                   name <- removed[[kk]]
[16:20:48.319]                   NAME <- NAMES[[kk]]
[16:20:48.319]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.319]                     next
[16:20:48.319]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.319]                 }
[16:20:48.319]                 if (length(args) > 0) 
[16:20:48.319]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.319]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.319]             }
[16:20:48.319]             else {
[16:20:48.319]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.319]             }
[16:20:48.319]             {
[16:20:48.319]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.319]                   0L) {
[16:20:48.319]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.319]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.319]                   base::options(opts)
[16:20:48.319]                 }
[16:20:48.319]                 {
[16:20:48.319]                   {
[16:20:48.319]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:48.319]                     NULL
[16:20:48.319]                   }
[16:20:48.319]                   options(future.plan = NULL)
[16:20:48.319]                   if (is.na(NA_character_)) 
[16:20:48.319]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.319]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.319]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.319]                     .init = FALSE)
[16:20:48.319]                 }
[16:20:48.319]             }
[16:20:48.319]         }
[16:20:48.319]     })
[16:20:48.319]     if (TRUE) {
[16:20:48.319]         base::sink(type = "output", split = FALSE)
[16:20:48.319]         if (TRUE) {
[16:20:48.319]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.319]         }
[16:20:48.319]         else {
[16:20:48.319]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.319]         }
[16:20:48.319]         base::close(...future.stdout)
[16:20:48.319]         ...future.stdout <- NULL
[16:20:48.319]     }
[16:20:48.319]     ...future.result$conditions <- ...future.conditions
[16:20:48.319]     ...future.result$finished <- base::Sys.time()
[16:20:48.319]     ...future.result
[16:20:48.319] }
[16:20:48.321] assign_globals() ...
[16:20:48.321] List of 2
[16:20:48.321]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:20:48.321]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:20:48.321]  - attr(*, "where")=List of 2
[16:20:48.321]   ..$ weight:<environment: R_EmptyEnv> 
[16:20:48.321]   ..$ group :<environment: R_EmptyEnv> 
[16:20:48.321]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:48.321]  - attr(*, "resolved")= logi FALSE
[16:20:48.321]  - attr(*, "total_size")= num 896
[16:20:48.321]  - attr(*, "already-done")= logi TRUE
[16:20:48.324] - copied ‘weight’ to environment
[16:20:48.324] - copied ‘group’ to environment
[16:20:48.324] assign_globals() ... done
[16:20:48.325] requestCore(): workers = 2
[16:20:48.327] MulticoreFuture started
[16:20:48.328] - Launch lazy future ... done
[16:20:48.328] run() for ‘MulticoreFuture’ ... done
[16:20:48.329] plan(): Setting new future strategy stack:
[16:20:48.329] result() for MulticoreFuture ...
[16:20:48.329] List of future strategies:
[16:20:48.329] 1. sequential:
[16:20:48.329]    - args: function (..., envir = parent.frame())
[16:20:48.329]    - tweaked: FALSE
[16:20:48.329]    - call: NULL
[16:20:48.330] plan(): nbrOfWorkers() = 1
[16:20:48.333] plan(): Setting new future strategy stack:
[16:20:48.333] List of future strategies:
[16:20:48.333] 1. multicore:
[16:20:48.333]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:48.333]    - tweaked: FALSE
[16:20:48.333]    - call: plan(strategy)
[16:20:48.343] plan(): nbrOfWorkers() = 2
[16:20:48.352] result() for MulticoreFuture ...
[16:20:48.352] result() for MulticoreFuture ... done
[16:20:48.352] result() for MulticoreFuture ... done
[16:20:48.352] result() for MulticoreFuture ...
[16:20:48.352] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:20:48.354] getGlobalsAndPackages() ...
[16:20:48.355] Searching for globals...
[16:20:48.357] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:20:48.357] Searching for globals ... DONE
[16:20:48.357] Resolving globals: FALSE
[16:20:48.357] The total size of the 2 globals is 896 bytes (896 bytes)
[16:20:48.358] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:20:48.358] - globals: [2] ‘weight’, ‘group’
[16:20:48.358] - packages: [1] ‘stats’
[16:20:48.358] getGlobalsAndPackages() ... DONE
[16:20:48.359] run() for ‘Future’ ...
[16:20:48.359] - state: ‘created’
[16:20:48.359] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:48.363] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:48.363] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:48.363]   - Field: ‘label’
[16:20:48.363]   - Field: ‘local’
[16:20:48.363]   - Field: ‘owner’
[16:20:48.364]   - Field: ‘envir’
[16:20:48.364]   - Field: ‘workers’
[16:20:48.364]   - Field: ‘packages’
[16:20:48.364]   - Field: ‘gc’
[16:20:48.364]   - Field: ‘job’
[16:20:48.364]   - Field: ‘conditions’
[16:20:48.364]   - Field: ‘expr’
[16:20:48.364]   - Field: ‘uuid’
[16:20:48.364]   - Field: ‘seed’
[16:20:48.365]   - Field: ‘version’
[16:20:48.365]   - Field: ‘result’
[16:20:48.365]   - Field: ‘asynchronous’
[16:20:48.365]   - Field: ‘calls’
[16:20:48.365]   - Field: ‘globals’
[16:20:48.365]   - Field: ‘stdout’
[16:20:48.365]   - Field: ‘earlySignal’
[16:20:48.365]   - Field: ‘lazy’
[16:20:48.365]   - Field: ‘state’
[16:20:48.366] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:48.366] - Launch lazy future ...
[16:20:48.366] Packages needed by the future expression (n = 1): ‘stats’
[16:20:48.366] Packages needed by future strategies (n = 0): <none>
[16:20:48.367] {
[16:20:48.367]     {
[16:20:48.367]         {
[16:20:48.367]             ...future.startTime <- base::Sys.time()
[16:20:48.367]             {
[16:20:48.367]                 {
[16:20:48.367]                   {
[16:20:48.367]                     {
[16:20:48.367]                       {
[16:20:48.367]                         base::local({
[16:20:48.367]                           has_future <- base::requireNamespace("future", 
[16:20:48.367]                             quietly = TRUE)
[16:20:48.367]                           if (has_future) {
[16:20:48.367]                             ns <- base::getNamespace("future")
[16:20:48.367]                             version <- ns[[".package"]][["version"]]
[16:20:48.367]                             if (is.null(version)) 
[16:20:48.367]                               version <- utils::packageVersion("future")
[16:20:48.367]                           }
[16:20:48.367]                           else {
[16:20:48.367]                             version <- NULL
[16:20:48.367]                           }
[16:20:48.367]                           if (!has_future || version < "1.8.0") {
[16:20:48.367]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.367]                               "", base::R.version$version.string), 
[16:20:48.367]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:48.367]                                 base::R.version$platform, 8 * 
[16:20:48.367]                                   base::.Machine$sizeof.pointer), 
[16:20:48.367]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.367]                                 "release", "version")], collapse = " "), 
[16:20:48.367]                               hostname = base::Sys.info()[["nodename"]])
[16:20:48.367]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.367]                               info)
[16:20:48.367]                             info <- base::paste(info, collapse = "; ")
[16:20:48.367]                             if (!has_future) {
[16:20:48.367]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.367]                                 info)
[16:20:48.367]                             }
[16:20:48.367]                             else {
[16:20:48.367]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.367]                                 info, version)
[16:20:48.367]                             }
[16:20:48.367]                             base::stop(msg)
[16:20:48.367]                           }
[16:20:48.367]                         })
[16:20:48.367]                       }
[16:20:48.367]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:48.367]                       base::options(mc.cores = 1L)
[16:20:48.367]                     }
[16:20:48.367]                     base::local({
[16:20:48.367]                       for (pkg in "stats") {
[16:20:48.367]                         base::loadNamespace(pkg)
[16:20:48.367]                         base::library(pkg, character.only = TRUE)
[16:20:48.367]                       }
[16:20:48.367]                     })
[16:20:48.367]                   }
[16:20:48.367]                   ...future.strategy.old <- future::plan("list")
[16:20:48.367]                   options(future.plan = NULL)
[16:20:48.367]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.367]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.367]                 }
[16:20:48.367]                 ...future.workdir <- getwd()
[16:20:48.367]             }
[16:20:48.367]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.367]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.367]         }
[16:20:48.367]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.367]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.367]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.367]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.367]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.367]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.367]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.367]             base::names(...future.oldOptions))
[16:20:48.367]     }
[16:20:48.367]     if (FALSE) {
[16:20:48.367]     }
[16:20:48.367]     else {
[16:20:48.367]         if (TRUE) {
[16:20:48.367]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.367]                 open = "w")
[16:20:48.367]         }
[16:20:48.367]         else {
[16:20:48.367]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.367]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.367]         }
[16:20:48.367]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.367]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.367]             base::sink(type = "output", split = FALSE)
[16:20:48.367]             base::close(...future.stdout)
[16:20:48.367]         }, add = TRUE)
[16:20:48.367]     }
[16:20:48.367]     ...future.frame <- base::sys.nframe()
[16:20:48.367]     ...future.conditions <- base::list()
[16:20:48.367]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.367]     if (FALSE) {
[16:20:48.367]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.367]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.367]     }
[16:20:48.367]     ...future.result <- base::tryCatch({
[16:20:48.367]         base::withCallingHandlers({
[16:20:48.367]             ...future.value <- base::withVisible(base::local({
[16:20:48.367]                 withCallingHandlers({
[16:20:48.367]                   {
[16:20:48.367]                     lm(weight ~ group - 1)
[16:20:48.367]                   }
[16:20:48.367]                 }, immediateCondition = function(cond) {
[16:20:48.367]                   save_rds <- function (object, pathname, ...) 
[16:20:48.367]                   {
[16:20:48.367]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:48.367]                     if (file_test("-f", pathname_tmp)) {
[16:20:48.367]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.367]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:48.367]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.367]                         fi_tmp[["mtime"]])
[16:20:48.367]                     }
[16:20:48.367]                     tryCatch({
[16:20:48.367]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:48.367]                     }, error = function(ex) {
[16:20:48.367]                       msg <- conditionMessage(ex)
[16:20:48.367]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.367]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:48.367]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.367]                         fi_tmp[["mtime"]], msg)
[16:20:48.367]                       ex$message <- msg
[16:20:48.367]                       stop(ex)
[16:20:48.367]                     })
[16:20:48.367]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:48.367]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:48.367]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:48.367]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.367]                       fi <- file.info(pathname)
[16:20:48.367]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:48.367]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.367]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:48.367]                         fi[["size"]], fi[["mtime"]])
[16:20:48.367]                       stop(msg)
[16:20:48.367]                     }
[16:20:48.367]                     invisible(pathname)
[16:20:48.367]                   }
[16:20:48.367]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:48.367]                     rootPath = tempdir()) 
[16:20:48.367]                   {
[16:20:48.367]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:48.367]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:48.367]                       tmpdir = path, fileext = ".rds")
[16:20:48.367]                     save_rds(obj, file)
[16:20:48.367]                   }
[16:20:48.367]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4Mnhkl/.future/immediateConditions")
[16:20:48.367]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.367]                   {
[16:20:48.367]                     inherits <- base::inherits
[16:20:48.367]                     invokeRestart <- base::invokeRestart
[16:20:48.367]                     is.null <- base::is.null
[16:20:48.367]                     muffled <- FALSE
[16:20:48.367]                     if (inherits(cond, "message")) {
[16:20:48.367]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:48.367]                       if (muffled) 
[16:20:48.367]                         invokeRestart("muffleMessage")
[16:20:48.367]                     }
[16:20:48.367]                     else if (inherits(cond, "warning")) {
[16:20:48.367]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:48.367]                       if (muffled) 
[16:20:48.367]                         invokeRestart("muffleWarning")
[16:20:48.367]                     }
[16:20:48.367]                     else if (inherits(cond, "condition")) {
[16:20:48.367]                       if (!is.null(pattern)) {
[16:20:48.367]                         computeRestarts <- base::computeRestarts
[16:20:48.367]                         grepl <- base::grepl
[16:20:48.367]                         restarts <- computeRestarts(cond)
[16:20:48.367]                         for (restart in restarts) {
[16:20:48.367]                           name <- restart$name
[16:20:48.367]                           if (is.null(name)) 
[16:20:48.367]                             next
[16:20:48.367]                           if (!grepl(pattern, name)) 
[16:20:48.367]                             next
[16:20:48.367]                           invokeRestart(restart)
[16:20:48.367]                           muffled <- TRUE
[16:20:48.367]                           break
[16:20:48.367]                         }
[16:20:48.367]                       }
[16:20:48.367]                     }
[16:20:48.367]                     invisible(muffled)
[16:20:48.367]                   }
[16:20:48.367]                   muffleCondition(cond)
[16:20:48.367]                 })
[16:20:48.367]             }))
[16:20:48.367]             future::FutureResult(value = ...future.value$value, 
[16:20:48.367]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.367]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.367]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.367]                     ...future.globalenv.names))
[16:20:48.367]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.367]         }, condition = base::local({
[16:20:48.367]             c <- base::c
[16:20:48.367]             inherits <- base::inherits
[16:20:48.367]             invokeRestart <- base::invokeRestart
[16:20:48.367]             length <- base::length
[16:20:48.367]             list <- base::list
[16:20:48.367]             seq.int <- base::seq.int
[16:20:48.367]             signalCondition <- base::signalCondition
[16:20:48.367]             sys.calls <- base::sys.calls
[16:20:48.367]             `[[` <- base::`[[`
[16:20:48.367]             `+` <- base::`+`
[16:20:48.367]             `<<-` <- base::`<<-`
[16:20:48.367]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.367]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.367]                   3L)]
[16:20:48.367]             }
[16:20:48.367]             function(cond) {
[16:20:48.367]                 is_error <- inherits(cond, "error")
[16:20:48.367]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.367]                   NULL)
[16:20:48.367]                 if (is_error) {
[16:20:48.367]                   sessionInformation <- function() {
[16:20:48.367]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.367]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.367]                       search = base::search(), system = base::Sys.info())
[16:20:48.367]                   }
[16:20:48.367]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.367]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.367]                     cond$call), session = sessionInformation(), 
[16:20:48.367]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.367]                   signalCondition(cond)
[16:20:48.367]                 }
[16:20:48.367]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.367]                 "immediateCondition"))) {
[16:20:48.367]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.367]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.367]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.367]                   if (TRUE && !signal) {
[16:20:48.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.367]                     {
[16:20:48.367]                       inherits <- base::inherits
[16:20:48.367]                       invokeRestart <- base::invokeRestart
[16:20:48.367]                       is.null <- base::is.null
[16:20:48.367]                       muffled <- FALSE
[16:20:48.367]                       if (inherits(cond, "message")) {
[16:20:48.367]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.367]                         if (muffled) 
[16:20:48.367]                           invokeRestart("muffleMessage")
[16:20:48.367]                       }
[16:20:48.367]                       else if (inherits(cond, "warning")) {
[16:20:48.367]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.367]                         if (muffled) 
[16:20:48.367]                           invokeRestart("muffleWarning")
[16:20:48.367]                       }
[16:20:48.367]                       else if (inherits(cond, "condition")) {
[16:20:48.367]                         if (!is.null(pattern)) {
[16:20:48.367]                           computeRestarts <- base::computeRestarts
[16:20:48.367]                           grepl <- base::grepl
[16:20:48.367]                           restarts <- computeRestarts(cond)
[16:20:48.367]                           for (restart in restarts) {
[16:20:48.367]                             name <- restart$name
[16:20:48.367]                             if (is.null(name)) 
[16:20:48.367]                               next
[16:20:48.367]                             if (!grepl(pattern, name)) 
[16:20:48.367]                               next
[16:20:48.367]                             invokeRestart(restart)
[16:20:48.367]                             muffled <- TRUE
[16:20:48.367]                             break
[16:20:48.367]                           }
[16:20:48.367]                         }
[16:20:48.367]                       }
[16:20:48.367]                       invisible(muffled)
[16:20:48.367]                     }
[16:20:48.367]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.367]                   }
[16:20:48.367]                 }
[16:20:48.367]                 else {
[16:20:48.367]                   if (TRUE) {
[16:20:48.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.367]                     {
[16:20:48.367]                       inherits <- base::inherits
[16:20:48.367]                       invokeRestart <- base::invokeRestart
[16:20:48.367]                       is.null <- base::is.null
[16:20:48.367]                       muffled <- FALSE
[16:20:48.367]                       if (inherits(cond, "message")) {
[16:20:48.367]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.367]                         if (muffled) 
[16:20:48.367]                           invokeRestart("muffleMessage")
[16:20:48.367]                       }
[16:20:48.367]                       else if (inherits(cond, "warning")) {
[16:20:48.367]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.367]                         if (muffled) 
[16:20:48.367]                           invokeRestart("muffleWarning")
[16:20:48.367]                       }
[16:20:48.367]                       else if (inherits(cond, "condition")) {
[16:20:48.367]                         if (!is.null(pattern)) {
[16:20:48.367]                           computeRestarts <- base::computeRestarts
[16:20:48.367]                           grepl <- base::grepl
[16:20:48.367]                           restarts <- computeRestarts(cond)
[16:20:48.367]                           for (restart in restarts) {
[16:20:48.367]                             name <- restart$name
[16:20:48.367]                             if (is.null(name)) 
[16:20:48.367]                               next
[16:20:48.367]                             if (!grepl(pattern, name)) 
[16:20:48.367]                               next
[16:20:48.367]                             invokeRestart(restart)
[16:20:48.367]                             muffled <- TRUE
[16:20:48.367]                             break
[16:20:48.367]                           }
[16:20:48.367]                         }
[16:20:48.367]                       }
[16:20:48.367]                       invisible(muffled)
[16:20:48.367]                     }
[16:20:48.367]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.367]                   }
[16:20:48.367]                 }
[16:20:48.367]             }
[16:20:48.367]         }))
[16:20:48.367]     }, error = function(ex) {
[16:20:48.367]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.367]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.367]                 ...future.rng), started = ...future.startTime, 
[16:20:48.367]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.367]             version = "1.8"), class = "FutureResult")
[16:20:48.367]     }, finally = {
[16:20:48.367]         if (!identical(...future.workdir, getwd())) 
[16:20:48.367]             setwd(...future.workdir)
[16:20:48.367]         {
[16:20:48.367]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.367]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.367]             }
[16:20:48.367]             base::options(...future.oldOptions)
[16:20:48.367]             if (.Platform$OS.type == "windows") {
[16:20:48.367]                 old_names <- names(...future.oldEnvVars)
[16:20:48.367]                 envs <- base::Sys.getenv()
[16:20:48.367]                 names <- names(envs)
[16:20:48.367]                 common <- intersect(names, old_names)
[16:20:48.367]                 added <- setdiff(names, old_names)
[16:20:48.367]                 removed <- setdiff(old_names, names)
[16:20:48.367]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.367]                   envs[common]]
[16:20:48.367]                 NAMES <- toupper(changed)
[16:20:48.367]                 args <- list()
[16:20:48.367]                 for (kk in seq_along(NAMES)) {
[16:20:48.367]                   name <- changed[[kk]]
[16:20:48.367]                   NAME <- NAMES[[kk]]
[16:20:48.367]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.367]                     next
[16:20:48.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.367]                 }
[16:20:48.367]                 NAMES <- toupper(added)
[16:20:48.367]                 for (kk in seq_along(NAMES)) {
[16:20:48.367]                   name <- added[[kk]]
[16:20:48.367]                   NAME <- NAMES[[kk]]
[16:20:48.367]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.367]                     next
[16:20:48.367]                   args[[name]] <- ""
[16:20:48.367]                 }
[16:20:48.367]                 NAMES <- toupper(removed)
[16:20:48.367]                 for (kk in seq_along(NAMES)) {
[16:20:48.367]                   name <- removed[[kk]]
[16:20:48.367]                   NAME <- NAMES[[kk]]
[16:20:48.367]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.367]                     next
[16:20:48.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.367]                 }
[16:20:48.367]                 if (length(args) > 0) 
[16:20:48.367]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.367]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.367]             }
[16:20:48.367]             else {
[16:20:48.367]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.367]             }
[16:20:48.367]             {
[16:20:48.367]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.367]                   0L) {
[16:20:48.367]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.367]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.367]                   base::options(opts)
[16:20:48.367]                 }
[16:20:48.367]                 {
[16:20:48.367]                   {
[16:20:48.367]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:48.367]                     NULL
[16:20:48.367]                   }
[16:20:48.367]                   options(future.plan = NULL)
[16:20:48.367]                   if (is.na(NA_character_)) 
[16:20:48.367]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.367]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.367]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.367]                     .init = FALSE)
[16:20:48.367]                 }
[16:20:48.367]             }
[16:20:48.367]         }
[16:20:48.367]     })
[16:20:48.367]     if (TRUE) {
[16:20:48.367]         base::sink(type = "output", split = FALSE)
[16:20:48.367]         if (TRUE) {
[16:20:48.367]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.367]         }
[16:20:48.367]         else {
[16:20:48.367]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.367]         }
[16:20:48.367]         base::close(...future.stdout)
[16:20:48.367]         ...future.stdout <- NULL
[16:20:48.367]     }
[16:20:48.367]     ...future.result$conditions <- ...future.conditions
[16:20:48.367]     ...future.result$finished <- base::Sys.time()
[16:20:48.367]     ...future.result
[16:20:48.367] }
[16:20:48.369] assign_globals() ...
[16:20:48.369] List of 2
[16:20:48.369]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:20:48.369]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:20:48.369]  - attr(*, "where")=List of 2
[16:20:48.369]   ..$ weight:<environment: R_EmptyEnv> 
[16:20:48.369]   ..$ group :<environment: R_EmptyEnv> 
[16:20:48.369]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:48.369]  - attr(*, "resolved")= logi FALSE
[16:20:48.369]  - attr(*, "total_size")= num 896
[16:20:48.369]  - attr(*, "already-done")= logi TRUE
[16:20:48.373] - copied ‘weight’ to environment
[16:20:48.373] - copied ‘group’ to environment
[16:20:48.373] assign_globals() ... done
[16:20:48.373] requestCore(): workers = 2
[16:20:48.375] MulticoreFuture started
[16:20:48.376] - Launch lazy future ... done
[16:20:48.376] run() for ‘MulticoreFuture’ ... done
[16:20:48.376] result() for MulticoreFuture ...
[16:20:48.377] plan(): Setting new future strategy stack:
[16:20:48.377] List of future strategies:
[16:20:48.377] 1. sequential:
[16:20:48.377]    - args: function (..., envir = parent.frame())
[16:20:48.377]    - tweaked: FALSE
[16:20:48.377]    - call: NULL
[16:20:48.378] plan(): nbrOfWorkers() = 1
[16:20:48.382] plan(): Setting new future strategy stack:
[16:20:48.382] List of future strategies:
[16:20:48.382] 1. multicore:
[16:20:48.382]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:48.382]    - tweaked: FALSE
[16:20:48.382]    - call: plan(strategy)
[16:20:48.390] plan(): nbrOfWorkers() = 2
[16:20:48.393] result() for MulticoreFuture ...
[16:20:48.393] result() for MulticoreFuture ... done
[16:20:48.393] result() for MulticoreFuture ... done
[16:20:48.393] result() for MulticoreFuture ...
[16:20:48.394] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:20:48.398] getGlobalsAndPackages() ...
[16:20:48.399] Searching for globals...
[16:20:48.401] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:20:48.401] Searching for globals ... DONE
[16:20:48.401] Resolving globals: FALSE
[16:20:48.402] The total size of the 2 globals is 896 bytes (896 bytes)
[16:20:48.403] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:20:48.403] - globals: [2] ‘weight’, ‘group’
[16:20:48.403] - packages: [1] ‘stats’
[16:20:48.403] getGlobalsAndPackages() ... DONE
[16:20:48.403] run() for ‘Future’ ...
[16:20:48.404] - state: ‘created’
[16:20:48.404] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:48.408] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:48.408] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:48.408]   - Field: ‘label’
[16:20:48.408]   - Field: ‘local’
[16:20:48.408]   - Field: ‘owner’
[16:20:48.409]   - Field: ‘envir’
[16:20:48.409]   - Field: ‘workers’
[16:20:48.409]   - Field: ‘packages’
[16:20:48.409]   - Field: ‘gc’
[16:20:48.409]   - Field: ‘job’
[16:20:48.409]   - Field: ‘conditions’
[16:20:48.409]   - Field: ‘expr’
[16:20:48.409]   - Field: ‘uuid’
[16:20:48.409]   - Field: ‘seed’
[16:20:48.410]   - Field: ‘version’
[16:20:48.410]   - Field: ‘result’
[16:20:48.410]   - Field: ‘asynchronous’
[16:20:48.410]   - Field: ‘calls’
[16:20:48.410]   - Field: ‘globals’
[16:20:48.410]   - Field: ‘stdout’
[16:20:48.410]   - Field: ‘earlySignal’
[16:20:48.410]   - Field: ‘lazy’
[16:20:48.411]   - Field: ‘state’
[16:20:48.411] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:48.411] - Launch lazy future ...
[16:20:48.411] Packages needed by the future expression (n = 1): ‘stats’
[16:20:48.411] Packages needed by future strategies (n = 0): <none>
[16:20:48.412] {
[16:20:48.412]     {
[16:20:48.412]         {
[16:20:48.412]             ...future.startTime <- base::Sys.time()
[16:20:48.412]             {
[16:20:48.412]                 {
[16:20:48.412]                   {
[16:20:48.412]                     {
[16:20:48.412]                       {
[16:20:48.412]                         base::local({
[16:20:48.412]                           has_future <- base::requireNamespace("future", 
[16:20:48.412]                             quietly = TRUE)
[16:20:48.412]                           if (has_future) {
[16:20:48.412]                             ns <- base::getNamespace("future")
[16:20:48.412]                             version <- ns[[".package"]][["version"]]
[16:20:48.412]                             if (is.null(version)) 
[16:20:48.412]                               version <- utils::packageVersion("future")
[16:20:48.412]                           }
[16:20:48.412]                           else {
[16:20:48.412]                             version <- NULL
[16:20:48.412]                           }
[16:20:48.412]                           if (!has_future || version < "1.8.0") {
[16:20:48.412]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.412]                               "", base::R.version$version.string), 
[16:20:48.412]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:48.412]                                 base::R.version$platform, 8 * 
[16:20:48.412]                                   base::.Machine$sizeof.pointer), 
[16:20:48.412]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.412]                                 "release", "version")], collapse = " "), 
[16:20:48.412]                               hostname = base::Sys.info()[["nodename"]])
[16:20:48.412]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.412]                               info)
[16:20:48.412]                             info <- base::paste(info, collapse = "; ")
[16:20:48.412]                             if (!has_future) {
[16:20:48.412]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.412]                                 info)
[16:20:48.412]                             }
[16:20:48.412]                             else {
[16:20:48.412]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.412]                                 info, version)
[16:20:48.412]                             }
[16:20:48.412]                             base::stop(msg)
[16:20:48.412]                           }
[16:20:48.412]                         })
[16:20:48.412]                       }
[16:20:48.412]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:48.412]                       base::options(mc.cores = 1L)
[16:20:48.412]                     }
[16:20:48.412]                     base::local({
[16:20:48.412]                       for (pkg in "stats") {
[16:20:48.412]                         base::loadNamespace(pkg)
[16:20:48.412]                         base::library(pkg, character.only = TRUE)
[16:20:48.412]                       }
[16:20:48.412]                     })
[16:20:48.412]                   }
[16:20:48.412]                   ...future.strategy.old <- future::plan("list")
[16:20:48.412]                   options(future.plan = NULL)
[16:20:48.412]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.412]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.412]                 }
[16:20:48.412]                 ...future.workdir <- getwd()
[16:20:48.412]             }
[16:20:48.412]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.412]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.412]         }
[16:20:48.412]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.412]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.412]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.412]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.412]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.412]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.412]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.412]             base::names(...future.oldOptions))
[16:20:48.412]     }
[16:20:48.412]     if (FALSE) {
[16:20:48.412]     }
[16:20:48.412]     else {
[16:20:48.412]         if (TRUE) {
[16:20:48.412]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.412]                 open = "w")
[16:20:48.412]         }
[16:20:48.412]         else {
[16:20:48.412]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.412]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.412]         }
[16:20:48.412]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.412]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.412]             base::sink(type = "output", split = FALSE)
[16:20:48.412]             base::close(...future.stdout)
[16:20:48.412]         }, add = TRUE)
[16:20:48.412]     }
[16:20:48.412]     ...future.frame <- base::sys.nframe()
[16:20:48.412]     ...future.conditions <- base::list()
[16:20:48.412]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.412]     if (FALSE) {
[16:20:48.412]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.412]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.412]     }
[16:20:48.412]     ...future.result <- base::tryCatch({
[16:20:48.412]         base::withCallingHandlers({
[16:20:48.412]             ...future.value <- base::withVisible(base::local({
[16:20:48.412]                 withCallingHandlers({
[16:20:48.412]                   {
[16:20:48.412]                     lm(weight ~ group - 1)
[16:20:48.412]                   }
[16:20:48.412]                 }, immediateCondition = function(cond) {
[16:20:48.412]                   save_rds <- function (object, pathname, ...) 
[16:20:48.412]                   {
[16:20:48.412]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:48.412]                     if (file_test("-f", pathname_tmp)) {
[16:20:48.412]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.412]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:48.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.412]                         fi_tmp[["mtime"]])
[16:20:48.412]                     }
[16:20:48.412]                     tryCatch({
[16:20:48.412]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:48.412]                     }, error = function(ex) {
[16:20:48.412]                       msg <- conditionMessage(ex)
[16:20:48.412]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.412]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:48.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.412]                         fi_tmp[["mtime"]], msg)
[16:20:48.412]                       ex$message <- msg
[16:20:48.412]                       stop(ex)
[16:20:48.412]                     })
[16:20:48.412]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:48.412]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:48.412]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:48.412]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.412]                       fi <- file.info(pathname)
[16:20:48.412]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:48.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.412]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:48.412]                         fi[["size"]], fi[["mtime"]])
[16:20:48.412]                       stop(msg)
[16:20:48.412]                     }
[16:20:48.412]                     invisible(pathname)
[16:20:48.412]                   }
[16:20:48.412]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:48.412]                     rootPath = tempdir()) 
[16:20:48.412]                   {
[16:20:48.412]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:48.412]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:48.412]                       tmpdir = path, fileext = ".rds")
[16:20:48.412]                     save_rds(obj, file)
[16:20:48.412]                   }
[16:20:48.412]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4Mnhkl/.future/immediateConditions")
[16:20:48.412]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.412]                   {
[16:20:48.412]                     inherits <- base::inherits
[16:20:48.412]                     invokeRestart <- base::invokeRestart
[16:20:48.412]                     is.null <- base::is.null
[16:20:48.412]                     muffled <- FALSE
[16:20:48.412]                     if (inherits(cond, "message")) {
[16:20:48.412]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:48.412]                       if (muffled) 
[16:20:48.412]                         invokeRestart("muffleMessage")
[16:20:48.412]                     }
[16:20:48.412]                     else if (inherits(cond, "warning")) {
[16:20:48.412]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:48.412]                       if (muffled) 
[16:20:48.412]                         invokeRestart("muffleWarning")
[16:20:48.412]                     }
[16:20:48.412]                     else if (inherits(cond, "condition")) {
[16:20:48.412]                       if (!is.null(pattern)) {
[16:20:48.412]                         computeRestarts <- base::computeRestarts
[16:20:48.412]                         grepl <- base::grepl
[16:20:48.412]                         restarts <- computeRestarts(cond)
[16:20:48.412]                         for (restart in restarts) {
[16:20:48.412]                           name <- restart$name
[16:20:48.412]                           if (is.null(name)) 
[16:20:48.412]                             next
[16:20:48.412]                           if (!grepl(pattern, name)) 
[16:20:48.412]                             next
[16:20:48.412]                           invokeRestart(restart)
[16:20:48.412]                           muffled <- TRUE
[16:20:48.412]                           break
[16:20:48.412]                         }
[16:20:48.412]                       }
[16:20:48.412]                     }
[16:20:48.412]                     invisible(muffled)
[16:20:48.412]                   }
[16:20:48.412]                   muffleCondition(cond)
[16:20:48.412]                 })
[16:20:48.412]             }))
[16:20:48.412]             future::FutureResult(value = ...future.value$value, 
[16:20:48.412]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.412]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.412]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.412]                     ...future.globalenv.names))
[16:20:48.412]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.412]         }, condition = base::local({
[16:20:48.412]             c <- base::c
[16:20:48.412]             inherits <- base::inherits
[16:20:48.412]             invokeRestart <- base::invokeRestart
[16:20:48.412]             length <- base::length
[16:20:48.412]             list <- base::list
[16:20:48.412]             seq.int <- base::seq.int
[16:20:48.412]             signalCondition <- base::signalCondition
[16:20:48.412]             sys.calls <- base::sys.calls
[16:20:48.412]             `[[` <- base::`[[`
[16:20:48.412]             `+` <- base::`+`
[16:20:48.412]             `<<-` <- base::`<<-`
[16:20:48.412]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.412]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.412]                   3L)]
[16:20:48.412]             }
[16:20:48.412]             function(cond) {
[16:20:48.412]                 is_error <- inherits(cond, "error")
[16:20:48.412]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.412]                   NULL)
[16:20:48.412]                 if (is_error) {
[16:20:48.412]                   sessionInformation <- function() {
[16:20:48.412]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.412]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.412]                       search = base::search(), system = base::Sys.info())
[16:20:48.412]                   }
[16:20:48.412]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.412]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.412]                     cond$call), session = sessionInformation(), 
[16:20:48.412]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.412]                   signalCondition(cond)
[16:20:48.412]                 }
[16:20:48.412]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.412]                 "immediateCondition"))) {
[16:20:48.412]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.412]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.412]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.412]                   if (TRUE && !signal) {
[16:20:48.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.412]                     {
[16:20:48.412]                       inherits <- base::inherits
[16:20:48.412]                       invokeRestart <- base::invokeRestart
[16:20:48.412]                       is.null <- base::is.null
[16:20:48.412]                       muffled <- FALSE
[16:20:48.412]                       if (inherits(cond, "message")) {
[16:20:48.412]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.412]                         if (muffled) 
[16:20:48.412]                           invokeRestart("muffleMessage")
[16:20:48.412]                       }
[16:20:48.412]                       else if (inherits(cond, "warning")) {
[16:20:48.412]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.412]                         if (muffled) 
[16:20:48.412]                           invokeRestart("muffleWarning")
[16:20:48.412]                       }
[16:20:48.412]                       else if (inherits(cond, "condition")) {
[16:20:48.412]                         if (!is.null(pattern)) {
[16:20:48.412]                           computeRestarts <- base::computeRestarts
[16:20:48.412]                           grepl <- base::grepl
[16:20:48.412]                           restarts <- computeRestarts(cond)
[16:20:48.412]                           for (restart in restarts) {
[16:20:48.412]                             name <- restart$name
[16:20:48.412]                             if (is.null(name)) 
[16:20:48.412]                               next
[16:20:48.412]                             if (!grepl(pattern, name)) 
[16:20:48.412]                               next
[16:20:48.412]                             invokeRestart(restart)
[16:20:48.412]                             muffled <- TRUE
[16:20:48.412]                             break
[16:20:48.412]                           }
[16:20:48.412]                         }
[16:20:48.412]                       }
[16:20:48.412]                       invisible(muffled)
[16:20:48.412]                     }
[16:20:48.412]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.412]                   }
[16:20:48.412]                 }
[16:20:48.412]                 else {
[16:20:48.412]                   if (TRUE) {
[16:20:48.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.412]                     {
[16:20:48.412]                       inherits <- base::inherits
[16:20:48.412]                       invokeRestart <- base::invokeRestart
[16:20:48.412]                       is.null <- base::is.null
[16:20:48.412]                       muffled <- FALSE
[16:20:48.412]                       if (inherits(cond, "message")) {
[16:20:48.412]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.412]                         if (muffled) 
[16:20:48.412]                           invokeRestart("muffleMessage")
[16:20:48.412]                       }
[16:20:48.412]                       else if (inherits(cond, "warning")) {
[16:20:48.412]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.412]                         if (muffled) 
[16:20:48.412]                           invokeRestart("muffleWarning")
[16:20:48.412]                       }
[16:20:48.412]                       else if (inherits(cond, "condition")) {
[16:20:48.412]                         if (!is.null(pattern)) {
[16:20:48.412]                           computeRestarts <- base::computeRestarts
[16:20:48.412]                           grepl <- base::grepl
[16:20:48.412]                           restarts <- computeRestarts(cond)
[16:20:48.412]                           for (restart in restarts) {
[16:20:48.412]                             name <- restart$name
[16:20:48.412]                             if (is.null(name)) 
[16:20:48.412]                               next
[16:20:48.412]                             if (!grepl(pattern, name)) 
[16:20:48.412]                               next
[16:20:48.412]                             invokeRestart(restart)
[16:20:48.412]                             muffled <- TRUE
[16:20:48.412]                             break
[16:20:48.412]                           }
[16:20:48.412]                         }
[16:20:48.412]                       }
[16:20:48.412]                       invisible(muffled)
[16:20:48.412]                     }
[16:20:48.412]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.412]                   }
[16:20:48.412]                 }
[16:20:48.412]             }
[16:20:48.412]         }))
[16:20:48.412]     }, error = function(ex) {
[16:20:48.412]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.412]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.412]                 ...future.rng), started = ...future.startTime, 
[16:20:48.412]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.412]             version = "1.8"), class = "FutureResult")
[16:20:48.412]     }, finally = {
[16:20:48.412]         if (!identical(...future.workdir, getwd())) 
[16:20:48.412]             setwd(...future.workdir)
[16:20:48.412]         {
[16:20:48.412]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.412]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.412]             }
[16:20:48.412]             base::options(...future.oldOptions)
[16:20:48.412]             if (.Platform$OS.type == "windows") {
[16:20:48.412]                 old_names <- names(...future.oldEnvVars)
[16:20:48.412]                 envs <- base::Sys.getenv()
[16:20:48.412]                 names <- names(envs)
[16:20:48.412]                 common <- intersect(names, old_names)
[16:20:48.412]                 added <- setdiff(names, old_names)
[16:20:48.412]                 removed <- setdiff(old_names, names)
[16:20:48.412]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.412]                   envs[common]]
[16:20:48.412]                 NAMES <- toupper(changed)
[16:20:48.412]                 args <- list()
[16:20:48.412]                 for (kk in seq_along(NAMES)) {
[16:20:48.412]                   name <- changed[[kk]]
[16:20:48.412]                   NAME <- NAMES[[kk]]
[16:20:48.412]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.412]                     next
[16:20:48.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.412]                 }
[16:20:48.412]                 NAMES <- toupper(added)
[16:20:48.412]                 for (kk in seq_along(NAMES)) {
[16:20:48.412]                   name <- added[[kk]]
[16:20:48.412]                   NAME <- NAMES[[kk]]
[16:20:48.412]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.412]                     next
[16:20:48.412]                   args[[name]] <- ""
[16:20:48.412]                 }
[16:20:48.412]                 NAMES <- toupper(removed)
[16:20:48.412]                 for (kk in seq_along(NAMES)) {
[16:20:48.412]                   name <- removed[[kk]]
[16:20:48.412]                   NAME <- NAMES[[kk]]
[16:20:48.412]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.412]                     next
[16:20:48.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.412]                 }
[16:20:48.412]                 if (length(args) > 0) 
[16:20:48.412]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.412]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.412]             }
[16:20:48.412]             else {
[16:20:48.412]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.412]             }
[16:20:48.412]             {
[16:20:48.412]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.412]                   0L) {
[16:20:48.412]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.412]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.412]                   base::options(opts)
[16:20:48.412]                 }
[16:20:48.412]                 {
[16:20:48.412]                   {
[16:20:48.412]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:48.412]                     NULL
[16:20:48.412]                   }
[16:20:48.412]                   options(future.plan = NULL)
[16:20:48.412]                   if (is.na(NA_character_)) 
[16:20:48.412]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.412]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.412]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.412]                     .init = FALSE)
[16:20:48.412]                 }
[16:20:48.412]             }
[16:20:48.412]         }
[16:20:48.412]     })
[16:20:48.412]     if (TRUE) {
[16:20:48.412]         base::sink(type = "output", split = FALSE)
[16:20:48.412]         if (TRUE) {
[16:20:48.412]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.412]         }
[16:20:48.412]         else {
[16:20:48.412]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.412]         }
[16:20:48.412]         base::close(...future.stdout)
[16:20:48.412]         ...future.stdout <- NULL
[16:20:48.412]     }
[16:20:48.412]     ...future.result$conditions <- ...future.conditions
[16:20:48.412]     ...future.result$finished <- base::Sys.time()
[16:20:48.412]     ...future.result
[16:20:48.412] }
[16:20:48.414] assign_globals() ...
[16:20:48.414] List of 2
[16:20:48.414]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:20:48.414]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:20:48.414]  - attr(*, "where")=List of 2
[16:20:48.414]   ..$ weight:<environment: R_EmptyEnv> 
[16:20:48.414]   ..$ group :<environment: R_EmptyEnv> 
[16:20:48.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:48.414]  - attr(*, "resolved")= logi FALSE
[16:20:48.414]  - attr(*, "total_size")= num 896
[16:20:48.414]  - attr(*, "already-done")= logi TRUE
[16:20:48.418] - copied ‘weight’ to environment
[16:20:48.418] - copied ‘group’ to environment
[16:20:48.418] assign_globals() ... done
[16:20:48.418] requestCore(): workers = 2
[16:20:48.420] MulticoreFuture started
[16:20:48.421] - Launch lazy future ... done
[16:20:48.421] run() for ‘MulticoreFuture’ ... done
[16:20:48.422] result() for MulticoreFuture ...
[16:20:48.422] plan(): Setting new future strategy stack:
[16:20:48.422] List of future strategies:
[16:20:48.422] 1. sequential:
[16:20:48.422]    - args: function (..., envir = parent.frame())
[16:20:48.422]    - tweaked: FALSE
[16:20:48.422]    - call: NULL
[16:20:48.423] plan(): nbrOfWorkers() = 1
[16:20:48.427] plan(): Setting new future strategy stack:
[16:20:48.427] List of future strategies:
[16:20:48.427] 1. multicore:
[16:20:48.427]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:48.427]    - tweaked: FALSE
[16:20:48.427]    - call: plan(strategy)
[16:20:48.432] plan(): nbrOfWorkers() = 2
[16:20:48.434] result() for MulticoreFuture ...
[16:20:48.434] result() for MulticoreFuture ... done
[16:20:48.434] result() for MulticoreFuture ... done
[16:20:48.434] result() for MulticoreFuture ...
[16:20:48.435] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:20:48.437] getGlobalsAndPackages() ...
[16:20:48.437] Searching for globals...
[16:20:48.439] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:20:48.439] Searching for globals ... DONE
[16:20:48.440] Resolving globals: FALSE
[16:20:48.440] The total size of the 2 globals is 896 bytes (896 bytes)
[16:20:48.443] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:20:48.443] - globals: [2] ‘weight’, ‘group’
[16:20:48.443] - packages: [1] ‘stats’
[16:20:48.443] getGlobalsAndPackages() ... DONE
[16:20:48.444] run() for ‘Future’ ...
[16:20:48.444] - state: ‘created’
[16:20:48.444] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:48.448] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:48.448] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:48.449]   - Field: ‘label’
[16:20:48.449]   - Field: ‘local’
[16:20:48.449]   - Field: ‘owner’
[16:20:48.449]   - Field: ‘envir’
[16:20:48.449]   - Field: ‘workers’
[16:20:48.449]   - Field: ‘packages’
[16:20:48.449]   - Field: ‘gc’
[16:20:48.450]   - Field: ‘job’
[16:20:48.450]   - Field: ‘conditions’
[16:20:48.450]   - Field: ‘expr’
[16:20:48.450]   - Field: ‘uuid’
[16:20:48.450]   - Field: ‘seed’
[16:20:48.450]   - Field: ‘version’
[16:20:48.450]   - Field: ‘result’
[16:20:48.450]   - Field: ‘asynchronous’
[16:20:48.451]   - Field: ‘calls’
[16:20:48.451]   - Field: ‘globals’
[16:20:48.451]   - Field: ‘stdout’
[16:20:48.451]   - Field: ‘earlySignal’
[16:20:48.451]   - Field: ‘lazy’
[16:20:48.451]   - Field: ‘state’
[16:20:48.451] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:48.451] - Launch lazy future ...
[16:20:48.452] Packages needed by the future expression (n = 1): ‘stats’
[16:20:48.452] Packages needed by future strategies (n = 0): <none>
[16:20:48.452] {
[16:20:48.452]     {
[16:20:48.452]         {
[16:20:48.452]             ...future.startTime <- base::Sys.time()
[16:20:48.452]             {
[16:20:48.452]                 {
[16:20:48.452]                   {
[16:20:48.452]                     {
[16:20:48.452]                       {
[16:20:48.452]                         base::local({
[16:20:48.452]                           has_future <- base::requireNamespace("future", 
[16:20:48.452]                             quietly = TRUE)
[16:20:48.452]                           if (has_future) {
[16:20:48.452]                             ns <- base::getNamespace("future")
[16:20:48.452]                             version <- ns[[".package"]][["version"]]
[16:20:48.452]                             if (is.null(version)) 
[16:20:48.452]                               version <- utils::packageVersion("future")
[16:20:48.452]                           }
[16:20:48.452]                           else {
[16:20:48.452]                             version <- NULL
[16:20:48.452]                           }
[16:20:48.452]                           if (!has_future || version < "1.8.0") {
[16:20:48.452]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.452]                               "", base::R.version$version.string), 
[16:20:48.452]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:48.452]                                 base::R.version$platform, 8 * 
[16:20:48.452]                                   base::.Machine$sizeof.pointer), 
[16:20:48.452]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.452]                                 "release", "version")], collapse = " "), 
[16:20:48.452]                               hostname = base::Sys.info()[["nodename"]])
[16:20:48.452]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.452]                               info)
[16:20:48.452]                             info <- base::paste(info, collapse = "; ")
[16:20:48.452]                             if (!has_future) {
[16:20:48.452]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.452]                                 info)
[16:20:48.452]                             }
[16:20:48.452]                             else {
[16:20:48.452]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.452]                                 info, version)
[16:20:48.452]                             }
[16:20:48.452]                             base::stop(msg)
[16:20:48.452]                           }
[16:20:48.452]                         })
[16:20:48.452]                       }
[16:20:48.452]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:48.452]                       base::options(mc.cores = 1L)
[16:20:48.452]                     }
[16:20:48.452]                     base::local({
[16:20:48.452]                       for (pkg in "stats") {
[16:20:48.452]                         base::loadNamespace(pkg)
[16:20:48.452]                         base::library(pkg, character.only = TRUE)
[16:20:48.452]                       }
[16:20:48.452]                     })
[16:20:48.452]                   }
[16:20:48.452]                   ...future.strategy.old <- future::plan("list")
[16:20:48.452]                   options(future.plan = NULL)
[16:20:48.452]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.452]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.452]                 }
[16:20:48.452]                 ...future.workdir <- getwd()
[16:20:48.452]             }
[16:20:48.452]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.452]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.452]         }
[16:20:48.452]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.452]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.452]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.452]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.452]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.452]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.452]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.452]             base::names(...future.oldOptions))
[16:20:48.452]     }
[16:20:48.452]     if (FALSE) {
[16:20:48.452]     }
[16:20:48.452]     else {
[16:20:48.452]         if (TRUE) {
[16:20:48.452]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.452]                 open = "w")
[16:20:48.452]         }
[16:20:48.452]         else {
[16:20:48.452]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.452]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.452]         }
[16:20:48.452]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.452]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.452]             base::sink(type = "output", split = FALSE)
[16:20:48.452]             base::close(...future.stdout)
[16:20:48.452]         }, add = TRUE)
[16:20:48.452]     }
[16:20:48.452]     ...future.frame <- base::sys.nframe()
[16:20:48.452]     ...future.conditions <- base::list()
[16:20:48.452]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.452]     if (FALSE) {
[16:20:48.452]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.452]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.452]     }
[16:20:48.452]     ...future.result <- base::tryCatch({
[16:20:48.452]         base::withCallingHandlers({
[16:20:48.452]             ...future.value <- base::withVisible(base::local({
[16:20:48.452]                 withCallingHandlers({
[16:20:48.452]                   {
[16:20:48.452]                     lm(weight ~ group - 1)
[16:20:48.452]                   }
[16:20:48.452]                 }, immediateCondition = function(cond) {
[16:20:48.452]                   save_rds <- function (object, pathname, ...) 
[16:20:48.452]                   {
[16:20:48.452]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:48.452]                     if (file_test("-f", pathname_tmp)) {
[16:20:48.452]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.452]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:48.452]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.452]                         fi_tmp[["mtime"]])
[16:20:48.452]                     }
[16:20:48.452]                     tryCatch({
[16:20:48.452]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:48.452]                     }, error = function(ex) {
[16:20:48.452]                       msg <- conditionMessage(ex)
[16:20:48.452]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.452]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:48.452]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.452]                         fi_tmp[["mtime"]], msg)
[16:20:48.452]                       ex$message <- msg
[16:20:48.452]                       stop(ex)
[16:20:48.452]                     })
[16:20:48.452]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:48.452]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:48.452]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:48.452]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.452]                       fi <- file.info(pathname)
[16:20:48.452]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:48.452]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.452]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:48.452]                         fi[["size"]], fi[["mtime"]])
[16:20:48.452]                       stop(msg)
[16:20:48.452]                     }
[16:20:48.452]                     invisible(pathname)
[16:20:48.452]                   }
[16:20:48.452]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:48.452]                     rootPath = tempdir()) 
[16:20:48.452]                   {
[16:20:48.452]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:48.452]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:48.452]                       tmpdir = path, fileext = ".rds")
[16:20:48.452]                     save_rds(obj, file)
[16:20:48.452]                   }
[16:20:48.452]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4Mnhkl/.future/immediateConditions")
[16:20:48.452]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.452]                   {
[16:20:48.452]                     inherits <- base::inherits
[16:20:48.452]                     invokeRestart <- base::invokeRestart
[16:20:48.452]                     is.null <- base::is.null
[16:20:48.452]                     muffled <- FALSE
[16:20:48.452]                     if (inherits(cond, "message")) {
[16:20:48.452]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:48.452]                       if (muffled) 
[16:20:48.452]                         invokeRestart("muffleMessage")
[16:20:48.452]                     }
[16:20:48.452]                     else if (inherits(cond, "warning")) {
[16:20:48.452]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:48.452]                       if (muffled) 
[16:20:48.452]                         invokeRestart("muffleWarning")
[16:20:48.452]                     }
[16:20:48.452]                     else if (inherits(cond, "condition")) {
[16:20:48.452]                       if (!is.null(pattern)) {
[16:20:48.452]                         computeRestarts <- base::computeRestarts
[16:20:48.452]                         grepl <- base::grepl
[16:20:48.452]                         restarts <- computeRestarts(cond)
[16:20:48.452]                         for (restart in restarts) {
[16:20:48.452]                           name <- restart$name
[16:20:48.452]                           if (is.null(name)) 
[16:20:48.452]                             next
[16:20:48.452]                           if (!grepl(pattern, name)) 
[16:20:48.452]                             next
[16:20:48.452]                           invokeRestart(restart)
[16:20:48.452]                           muffled <- TRUE
[16:20:48.452]                           break
[16:20:48.452]                         }
[16:20:48.452]                       }
[16:20:48.452]                     }
[16:20:48.452]                     invisible(muffled)
[16:20:48.452]                   }
[16:20:48.452]                   muffleCondition(cond)
[16:20:48.452]                 })
[16:20:48.452]             }))
[16:20:48.452]             future::FutureResult(value = ...future.value$value, 
[16:20:48.452]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.452]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.452]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.452]                     ...future.globalenv.names))
[16:20:48.452]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.452]         }, condition = base::local({
[16:20:48.452]             c <- base::c
[16:20:48.452]             inherits <- base::inherits
[16:20:48.452]             invokeRestart <- base::invokeRestart
[16:20:48.452]             length <- base::length
[16:20:48.452]             list <- base::list
[16:20:48.452]             seq.int <- base::seq.int
[16:20:48.452]             signalCondition <- base::signalCondition
[16:20:48.452]             sys.calls <- base::sys.calls
[16:20:48.452]             `[[` <- base::`[[`
[16:20:48.452]             `+` <- base::`+`
[16:20:48.452]             `<<-` <- base::`<<-`
[16:20:48.452]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.452]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.452]                   3L)]
[16:20:48.452]             }
[16:20:48.452]             function(cond) {
[16:20:48.452]                 is_error <- inherits(cond, "error")
[16:20:48.452]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.452]                   NULL)
[16:20:48.452]                 if (is_error) {
[16:20:48.452]                   sessionInformation <- function() {
[16:20:48.452]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.452]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.452]                       search = base::search(), system = base::Sys.info())
[16:20:48.452]                   }
[16:20:48.452]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.452]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.452]                     cond$call), session = sessionInformation(), 
[16:20:48.452]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.452]                   signalCondition(cond)
[16:20:48.452]                 }
[16:20:48.452]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.452]                 "immediateCondition"))) {
[16:20:48.452]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.452]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.452]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.452]                   if (TRUE && !signal) {
[16:20:48.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.452]                     {
[16:20:48.452]                       inherits <- base::inherits
[16:20:48.452]                       invokeRestart <- base::invokeRestart
[16:20:48.452]                       is.null <- base::is.null
[16:20:48.452]                       muffled <- FALSE
[16:20:48.452]                       if (inherits(cond, "message")) {
[16:20:48.452]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.452]                         if (muffled) 
[16:20:48.452]                           invokeRestart("muffleMessage")
[16:20:48.452]                       }
[16:20:48.452]                       else if (inherits(cond, "warning")) {
[16:20:48.452]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.452]                         if (muffled) 
[16:20:48.452]                           invokeRestart("muffleWarning")
[16:20:48.452]                       }
[16:20:48.452]                       else if (inherits(cond, "condition")) {
[16:20:48.452]                         if (!is.null(pattern)) {
[16:20:48.452]                           computeRestarts <- base::computeRestarts
[16:20:48.452]                           grepl <- base::grepl
[16:20:48.452]                           restarts <- computeRestarts(cond)
[16:20:48.452]                           for (restart in restarts) {
[16:20:48.452]                             name <- restart$name
[16:20:48.452]                             if (is.null(name)) 
[16:20:48.452]                               next
[16:20:48.452]                             if (!grepl(pattern, name)) 
[16:20:48.452]                               next
[16:20:48.452]                             invokeRestart(restart)
[16:20:48.452]                             muffled <- TRUE
[16:20:48.452]                             break
[16:20:48.452]                           }
[16:20:48.452]                         }
[16:20:48.452]                       }
[16:20:48.452]                       invisible(muffled)
[16:20:48.452]                     }
[16:20:48.452]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.452]                   }
[16:20:48.452]                 }
[16:20:48.452]                 else {
[16:20:48.452]                   if (TRUE) {
[16:20:48.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.452]                     {
[16:20:48.452]                       inherits <- base::inherits
[16:20:48.452]                       invokeRestart <- base::invokeRestart
[16:20:48.452]                       is.null <- base::is.null
[16:20:48.452]                       muffled <- FALSE
[16:20:48.452]                       if (inherits(cond, "message")) {
[16:20:48.452]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.452]                         if (muffled) 
[16:20:48.452]                           invokeRestart("muffleMessage")
[16:20:48.452]                       }
[16:20:48.452]                       else if (inherits(cond, "warning")) {
[16:20:48.452]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.452]                         if (muffled) 
[16:20:48.452]                           invokeRestart("muffleWarning")
[16:20:48.452]                       }
[16:20:48.452]                       else if (inherits(cond, "condition")) {
[16:20:48.452]                         if (!is.null(pattern)) {
[16:20:48.452]                           computeRestarts <- base::computeRestarts
[16:20:48.452]                           grepl <- base::grepl
[16:20:48.452]                           restarts <- computeRestarts(cond)
[16:20:48.452]                           for (restart in restarts) {
[16:20:48.452]                             name <- restart$name
[16:20:48.452]                             if (is.null(name)) 
[16:20:48.452]                               next
[16:20:48.452]                             if (!grepl(pattern, name)) 
[16:20:48.452]                               next
[16:20:48.452]                             invokeRestart(restart)
[16:20:48.452]                             muffled <- TRUE
[16:20:48.452]                             break
[16:20:48.452]                           }
[16:20:48.452]                         }
[16:20:48.452]                       }
[16:20:48.452]                       invisible(muffled)
[16:20:48.452]                     }
[16:20:48.452]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.452]                   }
[16:20:48.452]                 }
[16:20:48.452]             }
[16:20:48.452]         }))
[16:20:48.452]     }, error = function(ex) {
[16:20:48.452]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.452]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.452]                 ...future.rng), started = ...future.startTime, 
[16:20:48.452]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.452]             version = "1.8"), class = "FutureResult")
[16:20:48.452]     }, finally = {
[16:20:48.452]         if (!identical(...future.workdir, getwd())) 
[16:20:48.452]             setwd(...future.workdir)
[16:20:48.452]         {
[16:20:48.452]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.452]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.452]             }
[16:20:48.452]             base::options(...future.oldOptions)
[16:20:48.452]             if (.Platform$OS.type == "windows") {
[16:20:48.452]                 old_names <- names(...future.oldEnvVars)
[16:20:48.452]                 envs <- base::Sys.getenv()
[16:20:48.452]                 names <- names(envs)
[16:20:48.452]                 common <- intersect(names, old_names)
[16:20:48.452]                 added <- setdiff(names, old_names)
[16:20:48.452]                 removed <- setdiff(old_names, names)
[16:20:48.452]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.452]                   envs[common]]
[16:20:48.452]                 NAMES <- toupper(changed)
[16:20:48.452]                 args <- list()
[16:20:48.452]                 for (kk in seq_along(NAMES)) {
[16:20:48.452]                   name <- changed[[kk]]
[16:20:48.452]                   NAME <- NAMES[[kk]]
[16:20:48.452]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.452]                     next
[16:20:48.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.452]                 }
[16:20:48.452]                 NAMES <- toupper(added)
[16:20:48.452]                 for (kk in seq_along(NAMES)) {
[16:20:48.452]                   name <- added[[kk]]
[16:20:48.452]                   NAME <- NAMES[[kk]]
[16:20:48.452]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.452]                     next
[16:20:48.452]                   args[[name]] <- ""
[16:20:48.452]                 }
[16:20:48.452]                 NAMES <- toupper(removed)
[16:20:48.452]                 for (kk in seq_along(NAMES)) {
[16:20:48.452]                   name <- removed[[kk]]
[16:20:48.452]                   NAME <- NAMES[[kk]]
[16:20:48.452]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.452]                     next
[16:20:48.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.452]                 }
[16:20:48.452]                 if (length(args) > 0) 
[16:20:48.452]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.452]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.452]             }
[16:20:48.452]             else {
[16:20:48.452]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.452]             }
[16:20:48.452]             {
[16:20:48.452]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.452]                   0L) {
[16:20:48.452]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.452]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.452]                   base::options(opts)
[16:20:48.452]                 }
[16:20:48.452]                 {
[16:20:48.452]                   {
[16:20:48.452]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:48.452]                     NULL
[16:20:48.452]                   }
[16:20:48.452]                   options(future.plan = NULL)
[16:20:48.452]                   if (is.na(NA_character_)) 
[16:20:48.452]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.452]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.452]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.452]                     .init = FALSE)
[16:20:48.452]                 }
[16:20:48.452]             }
[16:20:48.452]         }
[16:20:48.452]     })
[16:20:48.452]     if (TRUE) {
[16:20:48.452]         base::sink(type = "output", split = FALSE)
[16:20:48.452]         if (TRUE) {
[16:20:48.452]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.452]         }
[16:20:48.452]         else {
[16:20:48.452]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.452]         }
[16:20:48.452]         base::close(...future.stdout)
[16:20:48.452]         ...future.stdout <- NULL
[16:20:48.452]     }
[16:20:48.452]     ...future.result$conditions <- ...future.conditions
[16:20:48.452]     ...future.result$finished <- base::Sys.time()
[16:20:48.452]     ...future.result
[16:20:48.452] }
[16:20:48.455] assign_globals() ...
[16:20:48.455] List of 2
[16:20:48.455]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:20:48.455]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:20:48.455]  - attr(*, "where")=List of 2
[16:20:48.455]   ..$ weight:<environment: R_EmptyEnv> 
[16:20:48.455]   ..$ group :<environment: R_EmptyEnv> 
[16:20:48.455]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:48.455]  - attr(*, "resolved")= logi FALSE
[16:20:48.455]  - attr(*, "total_size")= num 896
[16:20:48.455]  - attr(*, "already-done")= logi TRUE
[16:20:48.459] - copied ‘weight’ to environment
[16:20:48.459] - copied ‘group’ to environment
[16:20:48.459] assign_globals() ... done
[16:20:48.459] requestCore(): workers = 2
[16:20:48.461] MulticoreFuture started
[16:20:48.461] - Launch lazy future ... done
[16:20:48.462] run() for ‘MulticoreFuture’ ... done
[16:20:48.462] result() for MulticoreFuture ...
[16:20:48.463] plan(): Setting new future strategy stack:
[16:20:48.463] List of future strategies:
[16:20:48.463] 1. sequential:
[16:20:48.463]    - args: function (..., envir = parent.frame())
[16:20:48.463]    - tweaked: FALSE
[16:20:48.463]    - call: NULL
[16:20:48.464] plan(): nbrOfWorkers() = 1
[16:20:48.467] plan(): Setting new future strategy stack:
[16:20:48.467] List of future strategies:
[16:20:48.467] 1. multicore:
[16:20:48.467]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:48.467]    - tweaked: FALSE
[16:20:48.467]    - call: plan(strategy)
[16:20:48.472] plan(): nbrOfWorkers() = 2
[16:20:48.475] result() for MulticoreFuture ...
[16:20:48.475] result() for MulticoreFuture ... done
[16:20:48.475] result() for MulticoreFuture ... done
[16:20:48.475] result() for MulticoreFuture ...
[16:20:48.475] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:20:48.478] getGlobalsAndPackages() ...
[16:20:48.478] Searching for globals...
[16:20:48.480] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:20:48.480] Searching for globals ... DONE
[16:20:48.480] Resolving globals: FALSE
[16:20:48.481] The total size of the 2 globals is 896 bytes (896 bytes)
[16:20:48.481] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:20:48.482] - globals: [2] ‘weight’, ‘group’
[16:20:48.482] - packages: [1] ‘stats’
[16:20:48.482] getGlobalsAndPackages() ... DONE
[16:20:48.482] run() for ‘Future’ ...
[16:20:48.482] - state: ‘created’
[16:20:48.483] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:48.486] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:48.487] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:48.487]   - Field: ‘label’
[16:20:48.487]   - Field: ‘local’
[16:20:48.487]   - Field: ‘owner’
[16:20:48.487]   - Field: ‘envir’
[16:20:48.487]   - Field: ‘workers’
[16:20:48.490]   - Field: ‘packages’
[16:20:48.490]   - Field: ‘gc’
[16:20:48.490]   - Field: ‘job’
[16:20:48.490]   - Field: ‘conditions’
[16:20:48.490]   - Field: ‘expr’
[16:20:48.490]   - Field: ‘uuid’
[16:20:48.491]   - Field: ‘seed’
[16:20:48.491]   - Field: ‘version’
[16:20:48.491]   - Field: ‘result’
[16:20:48.491]   - Field: ‘asynchronous’
[16:20:48.491]   - Field: ‘calls’
[16:20:48.491]   - Field: ‘globals’
[16:20:48.491]   - Field: ‘stdout’
[16:20:48.492]   - Field: ‘earlySignal’
[16:20:48.492]   - Field: ‘lazy’
[16:20:48.492]   - Field: ‘state’
[16:20:48.492] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:48.492] - Launch lazy future ...
[16:20:48.492] Packages needed by the future expression (n = 1): ‘stats’
[16:20:48.493] Packages needed by future strategies (n = 0): <none>
[16:20:48.493] {
[16:20:48.493]     {
[16:20:48.493]         {
[16:20:48.493]             ...future.startTime <- base::Sys.time()
[16:20:48.493]             {
[16:20:48.493]                 {
[16:20:48.493]                   {
[16:20:48.493]                     {
[16:20:48.493]                       {
[16:20:48.493]                         base::local({
[16:20:48.493]                           has_future <- base::requireNamespace("future", 
[16:20:48.493]                             quietly = TRUE)
[16:20:48.493]                           if (has_future) {
[16:20:48.493]                             ns <- base::getNamespace("future")
[16:20:48.493]                             version <- ns[[".package"]][["version"]]
[16:20:48.493]                             if (is.null(version)) 
[16:20:48.493]                               version <- utils::packageVersion("future")
[16:20:48.493]                           }
[16:20:48.493]                           else {
[16:20:48.493]                             version <- NULL
[16:20:48.493]                           }
[16:20:48.493]                           if (!has_future || version < "1.8.0") {
[16:20:48.493]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.493]                               "", base::R.version$version.string), 
[16:20:48.493]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:48.493]                                 base::R.version$platform, 8 * 
[16:20:48.493]                                   base::.Machine$sizeof.pointer), 
[16:20:48.493]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.493]                                 "release", "version")], collapse = " "), 
[16:20:48.493]                               hostname = base::Sys.info()[["nodename"]])
[16:20:48.493]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.493]                               info)
[16:20:48.493]                             info <- base::paste(info, collapse = "; ")
[16:20:48.493]                             if (!has_future) {
[16:20:48.493]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.493]                                 info)
[16:20:48.493]                             }
[16:20:48.493]                             else {
[16:20:48.493]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.493]                                 info, version)
[16:20:48.493]                             }
[16:20:48.493]                             base::stop(msg)
[16:20:48.493]                           }
[16:20:48.493]                         })
[16:20:48.493]                       }
[16:20:48.493]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:48.493]                       base::options(mc.cores = 1L)
[16:20:48.493]                     }
[16:20:48.493]                     base::local({
[16:20:48.493]                       for (pkg in "stats") {
[16:20:48.493]                         base::loadNamespace(pkg)
[16:20:48.493]                         base::library(pkg, character.only = TRUE)
[16:20:48.493]                       }
[16:20:48.493]                     })
[16:20:48.493]                   }
[16:20:48.493]                   ...future.strategy.old <- future::plan("list")
[16:20:48.493]                   options(future.plan = NULL)
[16:20:48.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.493]                 }
[16:20:48.493]                 ...future.workdir <- getwd()
[16:20:48.493]             }
[16:20:48.493]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.493]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.493]         }
[16:20:48.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.493]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.493]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.493]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.493]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.493]             base::names(...future.oldOptions))
[16:20:48.493]     }
[16:20:48.493]     if (FALSE) {
[16:20:48.493]     }
[16:20:48.493]     else {
[16:20:48.493]         if (TRUE) {
[16:20:48.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.493]                 open = "w")
[16:20:48.493]         }
[16:20:48.493]         else {
[16:20:48.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.493]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.493]         }
[16:20:48.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.493]             base::sink(type = "output", split = FALSE)
[16:20:48.493]             base::close(...future.stdout)
[16:20:48.493]         }, add = TRUE)
[16:20:48.493]     }
[16:20:48.493]     ...future.frame <- base::sys.nframe()
[16:20:48.493]     ...future.conditions <- base::list()
[16:20:48.493]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.493]     if (FALSE) {
[16:20:48.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.493]     }
[16:20:48.493]     ...future.result <- base::tryCatch({
[16:20:48.493]         base::withCallingHandlers({
[16:20:48.493]             ...future.value <- base::withVisible(base::local({
[16:20:48.493]                 withCallingHandlers({
[16:20:48.493]                   {
[16:20:48.493]                     lm(weight ~ group - 1)
[16:20:48.493]                   }
[16:20:48.493]                 }, immediateCondition = function(cond) {
[16:20:48.493]                   save_rds <- function (object, pathname, ...) 
[16:20:48.493]                   {
[16:20:48.493]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:48.493]                     if (file_test("-f", pathname_tmp)) {
[16:20:48.493]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.493]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:48.493]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.493]                         fi_tmp[["mtime"]])
[16:20:48.493]                     }
[16:20:48.493]                     tryCatch({
[16:20:48.493]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:48.493]                     }, error = function(ex) {
[16:20:48.493]                       msg <- conditionMessage(ex)
[16:20:48.493]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.493]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:48.493]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.493]                         fi_tmp[["mtime"]], msg)
[16:20:48.493]                       ex$message <- msg
[16:20:48.493]                       stop(ex)
[16:20:48.493]                     })
[16:20:48.493]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:48.493]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:48.493]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:48.493]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.493]                       fi <- file.info(pathname)
[16:20:48.493]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:48.493]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.493]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:48.493]                         fi[["size"]], fi[["mtime"]])
[16:20:48.493]                       stop(msg)
[16:20:48.493]                     }
[16:20:48.493]                     invisible(pathname)
[16:20:48.493]                   }
[16:20:48.493]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:48.493]                     rootPath = tempdir()) 
[16:20:48.493]                   {
[16:20:48.493]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:48.493]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:48.493]                       tmpdir = path, fileext = ".rds")
[16:20:48.493]                     save_rds(obj, file)
[16:20:48.493]                   }
[16:20:48.493]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4Mnhkl/.future/immediateConditions")
[16:20:48.493]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.493]                   {
[16:20:48.493]                     inherits <- base::inherits
[16:20:48.493]                     invokeRestart <- base::invokeRestart
[16:20:48.493]                     is.null <- base::is.null
[16:20:48.493]                     muffled <- FALSE
[16:20:48.493]                     if (inherits(cond, "message")) {
[16:20:48.493]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:48.493]                       if (muffled) 
[16:20:48.493]                         invokeRestart("muffleMessage")
[16:20:48.493]                     }
[16:20:48.493]                     else if (inherits(cond, "warning")) {
[16:20:48.493]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:48.493]                       if (muffled) 
[16:20:48.493]                         invokeRestart("muffleWarning")
[16:20:48.493]                     }
[16:20:48.493]                     else if (inherits(cond, "condition")) {
[16:20:48.493]                       if (!is.null(pattern)) {
[16:20:48.493]                         computeRestarts <- base::computeRestarts
[16:20:48.493]                         grepl <- base::grepl
[16:20:48.493]                         restarts <- computeRestarts(cond)
[16:20:48.493]                         for (restart in restarts) {
[16:20:48.493]                           name <- restart$name
[16:20:48.493]                           if (is.null(name)) 
[16:20:48.493]                             next
[16:20:48.493]                           if (!grepl(pattern, name)) 
[16:20:48.493]                             next
[16:20:48.493]                           invokeRestart(restart)
[16:20:48.493]                           muffled <- TRUE
[16:20:48.493]                           break
[16:20:48.493]                         }
[16:20:48.493]                       }
[16:20:48.493]                     }
[16:20:48.493]                     invisible(muffled)
[16:20:48.493]                   }
[16:20:48.493]                   muffleCondition(cond)
[16:20:48.493]                 })
[16:20:48.493]             }))
[16:20:48.493]             future::FutureResult(value = ...future.value$value, 
[16:20:48.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.493]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.493]                     ...future.globalenv.names))
[16:20:48.493]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.493]         }, condition = base::local({
[16:20:48.493]             c <- base::c
[16:20:48.493]             inherits <- base::inherits
[16:20:48.493]             invokeRestart <- base::invokeRestart
[16:20:48.493]             length <- base::length
[16:20:48.493]             list <- base::list
[16:20:48.493]             seq.int <- base::seq.int
[16:20:48.493]             signalCondition <- base::signalCondition
[16:20:48.493]             sys.calls <- base::sys.calls
[16:20:48.493]             `[[` <- base::`[[`
[16:20:48.493]             `+` <- base::`+`
[16:20:48.493]             `<<-` <- base::`<<-`
[16:20:48.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.493]                   3L)]
[16:20:48.493]             }
[16:20:48.493]             function(cond) {
[16:20:48.493]                 is_error <- inherits(cond, "error")
[16:20:48.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.493]                   NULL)
[16:20:48.493]                 if (is_error) {
[16:20:48.493]                   sessionInformation <- function() {
[16:20:48.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.493]                       search = base::search(), system = base::Sys.info())
[16:20:48.493]                   }
[16:20:48.493]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.493]                     cond$call), session = sessionInformation(), 
[16:20:48.493]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.493]                   signalCondition(cond)
[16:20:48.493]                 }
[16:20:48.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.493]                 "immediateCondition"))) {
[16:20:48.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.493]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.493]                   if (TRUE && !signal) {
[16:20:48.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.493]                     {
[16:20:48.493]                       inherits <- base::inherits
[16:20:48.493]                       invokeRestart <- base::invokeRestart
[16:20:48.493]                       is.null <- base::is.null
[16:20:48.493]                       muffled <- FALSE
[16:20:48.493]                       if (inherits(cond, "message")) {
[16:20:48.493]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.493]                         if (muffled) 
[16:20:48.493]                           invokeRestart("muffleMessage")
[16:20:48.493]                       }
[16:20:48.493]                       else if (inherits(cond, "warning")) {
[16:20:48.493]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.493]                         if (muffled) 
[16:20:48.493]                           invokeRestart("muffleWarning")
[16:20:48.493]                       }
[16:20:48.493]                       else if (inherits(cond, "condition")) {
[16:20:48.493]                         if (!is.null(pattern)) {
[16:20:48.493]                           computeRestarts <- base::computeRestarts
[16:20:48.493]                           grepl <- base::grepl
[16:20:48.493]                           restarts <- computeRestarts(cond)
[16:20:48.493]                           for (restart in restarts) {
[16:20:48.493]                             name <- restart$name
[16:20:48.493]                             if (is.null(name)) 
[16:20:48.493]                               next
[16:20:48.493]                             if (!grepl(pattern, name)) 
[16:20:48.493]                               next
[16:20:48.493]                             invokeRestart(restart)
[16:20:48.493]                             muffled <- TRUE
[16:20:48.493]                             break
[16:20:48.493]                           }
[16:20:48.493]                         }
[16:20:48.493]                       }
[16:20:48.493]                       invisible(muffled)
[16:20:48.493]                     }
[16:20:48.493]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.493]                   }
[16:20:48.493]                 }
[16:20:48.493]                 else {
[16:20:48.493]                   if (TRUE) {
[16:20:48.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.493]                     {
[16:20:48.493]                       inherits <- base::inherits
[16:20:48.493]                       invokeRestart <- base::invokeRestart
[16:20:48.493]                       is.null <- base::is.null
[16:20:48.493]                       muffled <- FALSE
[16:20:48.493]                       if (inherits(cond, "message")) {
[16:20:48.493]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.493]                         if (muffled) 
[16:20:48.493]                           invokeRestart("muffleMessage")
[16:20:48.493]                       }
[16:20:48.493]                       else if (inherits(cond, "warning")) {
[16:20:48.493]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.493]                         if (muffled) 
[16:20:48.493]                           invokeRestart("muffleWarning")
[16:20:48.493]                       }
[16:20:48.493]                       else if (inherits(cond, "condition")) {
[16:20:48.493]                         if (!is.null(pattern)) {
[16:20:48.493]                           computeRestarts <- base::computeRestarts
[16:20:48.493]                           grepl <- base::grepl
[16:20:48.493]                           restarts <- computeRestarts(cond)
[16:20:48.493]                           for (restart in restarts) {
[16:20:48.493]                             name <- restart$name
[16:20:48.493]                             if (is.null(name)) 
[16:20:48.493]                               next
[16:20:48.493]                             if (!grepl(pattern, name)) 
[16:20:48.493]                               next
[16:20:48.493]                             invokeRestart(restart)
[16:20:48.493]                             muffled <- TRUE
[16:20:48.493]                             break
[16:20:48.493]                           }
[16:20:48.493]                         }
[16:20:48.493]                       }
[16:20:48.493]                       invisible(muffled)
[16:20:48.493]                     }
[16:20:48.493]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.493]                   }
[16:20:48.493]                 }
[16:20:48.493]             }
[16:20:48.493]         }))
[16:20:48.493]     }, error = function(ex) {
[16:20:48.493]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.493]                 ...future.rng), started = ...future.startTime, 
[16:20:48.493]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.493]             version = "1.8"), class = "FutureResult")
[16:20:48.493]     }, finally = {
[16:20:48.493]         if (!identical(...future.workdir, getwd())) 
[16:20:48.493]             setwd(...future.workdir)
[16:20:48.493]         {
[16:20:48.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.493]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.493]             }
[16:20:48.493]             base::options(...future.oldOptions)
[16:20:48.493]             if (.Platform$OS.type == "windows") {
[16:20:48.493]                 old_names <- names(...future.oldEnvVars)
[16:20:48.493]                 envs <- base::Sys.getenv()
[16:20:48.493]                 names <- names(envs)
[16:20:48.493]                 common <- intersect(names, old_names)
[16:20:48.493]                 added <- setdiff(names, old_names)
[16:20:48.493]                 removed <- setdiff(old_names, names)
[16:20:48.493]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.493]                   envs[common]]
[16:20:48.493]                 NAMES <- toupper(changed)
[16:20:48.493]                 args <- list()
[16:20:48.493]                 for (kk in seq_along(NAMES)) {
[16:20:48.493]                   name <- changed[[kk]]
[16:20:48.493]                   NAME <- NAMES[[kk]]
[16:20:48.493]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.493]                     next
[16:20:48.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.493]                 }
[16:20:48.493]                 NAMES <- toupper(added)
[16:20:48.493]                 for (kk in seq_along(NAMES)) {
[16:20:48.493]                   name <- added[[kk]]
[16:20:48.493]                   NAME <- NAMES[[kk]]
[16:20:48.493]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.493]                     next
[16:20:48.493]                   args[[name]] <- ""
[16:20:48.493]                 }
[16:20:48.493]                 NAMES <- toupper(removed)
[16:20:48.493]                 for (kk in seq_along(NAMES)) {
[16:20:48.493]                   name <- removed[[kk]]
[16:20:48.493]                   NAME <- NAMES[[kk]]
[16:20:48.493]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.493]                     next
[16:20:48.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.493]                 }
[16:20:48.493]                 if (length(args) > 0) 
[16:20:48.493]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.493]             }
[16:20:48.493]             else {
[16:20:48.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.493]             }
[16:20:48.493]             {
[16:20:48.493]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.493]                   0L) {
[16:20:48.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.493]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.493]                   base::options(opts)
[16:20:48.493]                 }
[16:20:48.493]                 {
[16:20:48.493]                   {
[16:20:48.493]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:48.493]                     NULL
[16:20:48.493]                   }
[16:20:48.493]                   options(future.plan = NULL)
[16:20:48.493]                   if (is.na(NA_character_)) 
[16:20:48.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.493]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.493]                     .init = FALSE)
[16:20:48.493]                 }
[16:20:48.493]             }
[16:20:48.493]         }
[16:20:48.493]     })
[16:20:48.493]     if (TRUE) {
[16:20:48.493]         base::sink(type = "output", split = FALSE)
[16:20:48.493]         if (TRUE) {
[16:20:48.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.493]         }
[16:20:48.493]         else {
[16:20:48.493]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.493]         }
[16:20:48.493]         base::close(...future.stdout)
[16:20:48.493]         ...future.stdout <- NULL
[16:20:48.493]     }
[16:20:48.493]     ...future.result$conditions <- ...future.conditions
[16:20:48.493]     ...future.result$finished <- base::Sys.time()
[16:20:48.493]     ...future.result
[16:20:48.493] }
[16:20:48.496] assign_globals() ...
[16:20:48.496] List of 2
[16:20:48.496]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:20:48.496]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:20:48.496]  - attr(*, "where")=List of 2
[16:20:48.496]   ..$ weight:<environment: R_EmptyEnv> 
[16:20:48.496]   ..$ group :<environment: R_EmptyEnv> 
[16:20:48.496]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:48.496]  - attr(*, "resolved")= logi FALSE
[16:20:48.496]  - attr(*, "total_size")= num 896
[16:20:48.496]  - attr(*, "already-done")= logi TRUE
[16:20:48.500] - copied ‘weight’ to environment
[16:20:48.500] - copied ‘group’ to environment
[16:20:48.500] assign_globals() ... done
[16:20:48.500] requestCore(): workers = 2
[16:20:48.502] MulticoreFuture started
[16:20:48.502] - Launch lazy future ... done
[16:20:48.503] run() for ‘MulticoreFuture’ ... done
[16:20:48.503] result() for MulticoreFuture ...
[16:20:48.503] plan(): Setting new future strategy stack:
[16:20:48.504] List of future strategies:
[16:20:48.504] 1. sequential:
[16:20:48.504]    - args: function (..., envir = parent.frame())
[16:20:48.504]    - tweaked: FALSE
[16:20:48.504]    - call: NULL
[16:20:48.504] plan(): nbrOfWorkers() = 1
[16:20:48.508] plan(): Setting new future strategy stack:
[16:20:48.508] List of future strategies:
[16:20:48.508] 1. multicore:
[16:20:48.508]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:48.508]    - tweaked: FALSE
[16:20:48.508]    - call: plan(strategy)
[16:20:48.513] plan(): nbrOfWorkers() = 2
[16:20:48.515] result() for MulticoreFuture ...
[16:20:48.516] result() for MulticoreFuture ... done
[16:20:48.516] result() for MulticoreFuture ... done
[16:20:48.516] result() for MulticoreFuture ...
[16:20:48.516] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[16:20:48.519] getGlobalsAndPackages() ...
[16:20:48.519] Searching for globals...
[16:20:48.520] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[16:20:48.520] Searching for globals ... DONE
[16:20:48.521] Resolving globals: FALSE
[16:20:48.521] The total size of the 1 globals is 96 bytes (96 bytes)
[16:20:48.522] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[16:20:48.522] - globals: [1] ‘x’
[16:20:48.522] - packages: [1] ‘stats’
[16:20:48.522] getGlobalsAndPackages() ... DONE
[16:20:48.522] run() for ‘Future’ ...
[16:20:48.523] - state: ‘created’
[16:20:48.523] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:48.527] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:48.527] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:48.527]   - Field: ‘label’
[16:20:48.527]   - Field: ‘local’
[16:20:48.527]   - Field: ‘owner’
[16:20:48.527]   - Field: ‘envir’
[16:20:48.528]   - Field: ‘workers’
[16:20:48.528]   - Field: ‘packages’
[16:20:48.528]   - Field: ‘gc’
[16:20:48.528]   - Field: ‘job’
[16:20:48.528]   - Field: ‘conditions’
[16:20:48.528]   - Field: ‘expr’
[16:20:48.528]   - Field: ‘uuid’
[16:20:48.528]   - Field: ‘seed’
[16:20:48.529]   - Field: ‘version’
[16:20:48.529]   - Field: ‘result’
[16:20:48.529]   - Field: ‘asynchronous’
[16:20:48.529]   - Field: ‘calls’
[16:20:48.529]   - Field: ‘globals’
[16:20:48.529]   - Field: ‘stdout’
[16:20:48.529]   - Field: ‘earlySignal’
[16:20:48.529]   - Field: ‘lazy’
[16:20:48.529]   - Field: ‘state’
[16:20:48.530] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:48.530] - Launch lazy future ...
[16:20:48.530] Packages needed by the future expression (n = 1): ‘stats’
[16:20:48.530] Packages needed by future strategies (n = 0): <none>
[16:20:48.531] {
[16:20:48.531]     {
[16:20:48.531]         {
[16:20:48.531]             ...future.startTime <- base::Sys.time()
[16:20:48.531]             {
[16:20:48.531]                 {
[16:20:48.531]                   {
[16:20:48.531]                     {
[16:20:48.531]                       {
[16:20:48.531]                         base::local({
[16:20:48.531]                           has_future <- base::requireNamespace("future", 
[16:20:48.531]                             quietly = TRUE)
[16:20:48.531]                           if (has_future) {
[16:20:48.531]                             ns <- base::getNamespace("future")
[16:20:48.531]                             version <- ns[[".package"]][["version"]]
[16:20:48.531]                             if (is.null(version)) 
[16:20:48.531]                               version <- utils::packageVersion("future")
[16:20:48.531]                           }
[16:20:48.531]                           else {
[16:20:48.531]                             version <- NULL
[16:20:48.531]                           }
[16:20:48.531]                           if (!has_future || version < "1.8.0") {
[16:20:48.531]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.531]                               "", base::R.version$version.string), 
[16:20:48.531]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:48.531]                                 base::R.version$platform, 8 * 
[16:20:48.531]                                   base::.Machine$sizeof.pointer), 
[16:20:48.531]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.531]                                 "release", "version")], collapse = " "), 
[16:20:48.531]                               hostname = base::Sys.info()[["nodename"]])
[16:20:48.531]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.531]                               info)
[16:20:48.531]                             info <- base::paste(info, collapse = "; ")
[16:20:48.531]                             if (!has_future) {
[16:20:48.531]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.531]                                 info)
[16:20:48.531]                             }
[16:20:48.531]                             else {
[16:20:48.531]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.531]                                 info, version)
[16:20:48.531]                             }
[16:20:48.531]                             base::stop(msg)
[16:20:48.531]                           }
[16:20:48.531]                         })
[16:20:48.531]                       }
[16:20:48.531]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:48.531]                       base::options(mc.cores = 1L)
[16:20:48.531]                     }
[16:20:48.531]                     base::local({
[16:20:48.531]                       for (pkg in "stats") {
[16:20:48.531]                         base::loadNamespace(pkg)
[16:20:48.531]                         base::library(pkg, character.only = TRUE)
[16:20:48.531]                       }
[16:20:48.531]                     })
[16:20:48.531]                   }
[16:20:48.531]                   ...future.strategy.old <- future::plan("list")
[16:20:48.531]                   options(future.plan = NULL)
[16:20:48.531]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.531]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.531]                 }
[16:20:48.531]                 ...future.workdir <- getwd()
[16:20:48.531]             }
[16:20:48.531]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.531]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.531]         }
[16:20:48.531]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.531]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.531]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.531]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.531]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.531]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.531]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.531]             base::names(...future.oldOptions))
[16:20:48.531]     }
[16:20:48.531]     if (FALSE) {
[16:20:48.531]     }
[16:20:48.531]     else {
[16:20:48.531]         if (TRUE) {
[16:20:48.531]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.531]                 open = "w")
[16:20:48.531]         }
[16:20:48.531]         else {
[16:20:48.531]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.531]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.531]         }
[16:20:48.531]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.531]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.531]             base::sink(type = "output", split = FALSE)
[16:20:48.531]             base::close(...future.stdout)
[16:20:48.531]         }, add = TRUE)
[16:20:48.531]     }
[16:20:48.531]     ...future.frame <- base::sys.nframe()
[16:20:48.531]     ...future.conditions <- base::list()
[16:20:48.531]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.531]     if (FALSE) {
[16:20:48.531]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.531]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.531]     }
[16:20:48.531]     ...future.result <- base::tryCatch({
[16:20:48.531]         base::withCallingHandlers({
[16:20:48.531]             ...future.value <- base::withVisible(base::local({
[16:20:48.531]                 withCallingHandlers({
[16:20:48.531]                   {
[16:20:48.531]                     xtabs(~x)
[16:20:48.531]                   }
[16:20:48.531]                 }, immediateCondition = function(cond) {
[16:20:48.531]                   save_rds <- function (object, pathname, ...) 
[16:20:48.531]                   {
[16:20:48.531]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:48.531]                     if (file_test("-f", pathname_tmp)) {
[16:20:48.531]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.531]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:48.531]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.531]                         fi_tmp[["mtime"]])
[16:20:48.531]                     }
[16:20:48.531]                     tryCatch({
[16:20:48.531]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:48.531]                     }, error = function(ex) {
[16:20:48.531]                       msg <- conditionMessage(ex)
[16:20:48.531]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.531]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:48.531]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.531]                         fi_tmp[["mtime"]], msg)
[16:20:48.531]                       ex$message <- msg
[16:20:48.531]                       stop(ex)
[16:20:48.531]                     })
[16:20:48.531]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:48.531]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:48.531]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:48.531]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.531]                       fi <- file.info(pathname)
[16:20:48.531]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:48.531]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.531]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:48.531]                         fi[["size"]], fi[["mtime"]])
[16:20:48.531]                       stop(msg)
[16:20:48.531]                     }
[16:20:48.531]                     invisible(pathname)
[16:20:48.531]                   }
[16:20:48.531]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:48.531]                     rootPath = tempdir()) 
[16:20:48.531]                   {
[16:20:48.531]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:48.531]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:48.531]                       tmpdir = path, fileext = ".rds")
[16:20:48.531]                     save_rds(obj, file)
[16:20:48.531]                   }
[16:20:48.531]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4Mnhkl/.future/immediateConditions")
[16:20:48.531]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.531]                   {
[16:20:48.531]                     inherits <- base::inherits
[16:20:48.531]                     invokeRestart <- base::invokeRestart
[16:20:48.531]                     is.null <- base::is.null
[16:20:48.531]                     muffled <- FALSE
[16:20:48.531]                     if (inherits(cond, "message")) {
[16:20:48.531]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:48.531]                       if (muffled) 
[16:20:48.531]                         invokeRestart("muffleMessage")
[16:20:48.531]                     }
[16:20:48.531]                     else if (inherits(cond, "warning")) {
[16:20:48.531]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:48.531]                       if (muffled) 
[16:20:48.531]                         invokeRestart("muffleWarning")
[16:20:48.531]                     }
[16:20:48.531]                     else if (inherits(cond, "condition")) {
[16:20:48.531]                       if (!is.null(pattern)) {
[16:20:48.531]                         computeRestarts <- base::computeRestarts
[16:20:48.531]                         grepl <- base::grepl
[16:20:48.531]                         restarts <- computeRestarts(cond)
[16:20:48.531]                         for (restart in restarts) {
[16:20:48.531]                           name <- restart$name
[16:20:48.531]                           if (is.null(name)) 
[16:20:48.531]                             next
[16:20:48.531]                           if (!grepl(pattern, name)) 
[16:20:48.531]                             next
[16:20:48.531]                           invokeRestart(restart)
[16:20:48.531]                           muffled <- TRUE
[16:20:48.531]                           break
[16:20:48.531]                         }
[16:20:48.531]                       }
[16:20:48.531]                     }
[16:20:48.531]                     invisible(muffled)
[16:20:48.531]                   }
[16:20:48.531]                   muffleCondition(cond)
[16:20:48.531]                 })
[16:20:48.531]             }))
[16:20:48.531]             future::FutureResult(value = ...future.value$value, 
[16:20:48.531]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.531]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.531]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.531]                     ...future.globalenv.names))
[16:20:48.531]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.531]         }, condition = base::local({
[16:20:48.531]             c <- base::c
[16:20:48.531]             inherits <- base::inherits
[16:20:48.531]             invokeRestart <- base::invokeRestart
[16:20:48.531]             length <- base::length
[16:20:48.531]             list <- base::list
[16:20:48.531]             seq.int <- base::seq.int
[16:20:48.531]             signalCondition <- base::signalCondition
[16:20:48.531]             sys.calls <- base::sys.calls
[16:20:48.531]             `[[` <- base::`[[`
[16:20:48.531]             `+` <- base::`+`
[16:20:48.531]             `<<-` <- base::`<<-`
[16:20:48.531]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.531]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.531]                   3L)]
[16:20:48.531]             }
[16:20:48.531]             function(cond) {
[16:20:48.531]                 is_error <- inherits(cond, "error")
[16:20:48.531]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.531]                   NULL)
[16:20:48.531]                 if (is_error) {
[16:20:48.531]                   sessionInformation <- function() {
[16:20:48.531]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.531]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.531]                       search = base::search(), system = base::Sys.info())
[16:20:48.531]                   }
[16:20:48.531]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.531]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.531]                     cond$call), session = sessionInformation(), 
[16:20:48.531]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.531]                   signalCondition(cond)
[16:20:48.531]                 }
[16:20:48.531]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.531]                 "immediateCondition"))) {
[16:20:48.531]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.531]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.531]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.531]                   if (TRUE && !signal) {
[16:20:48.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.531]                     {
[16:20:48.531]                       inherits <- base::inherits
[16:20:48.531]                       invokeRestart <- base::invokeRestart
[16:20:48.531]                       is.null <- base::is.null
[16:20:48.531]                       muffled <- FALSE
[16:20:48.531]                       if (inherits(cond, "message")) {
[16:20:48.531]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.531]                         if (muffled) 
[16:20:48.531]                           invokeRestart("muffleMessage")
[16:20:48.531]                       }
[16:20:48.531]                       else if (inherits(cond, "warning")) {
[16:20:48.531]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.531]                         if (muffled) 
[16:20:48.531]                           invokeRestart("muffleWarning")
[16:20:48.531]                       }
[16:20:48.531]                       else if (inherits(cond, "condition")) {
[16:20:48.531]                         if (!is.null(pattern)) {
[16:20:48.531]                           computeRestarts <- base::computeRestarts
[16:20:48.531]                           grepl <- base::grepl
[16:20:48.531]                           restarts <- computeRestarts(cond)
[16:20:48.531]                           for (restart in restarts) {
[16:20:48.531]                             name <- restart$name
[16:20:48.531]                             if (is.null(name)) 
[16:20:48.531]                               next
[16:20:48.531]                             if (!grepl(pattern, name)) 
[16:20:48.531]                               next
[16:20:48.531]                             invokeRestart(restart)
[16:20:48.531]                             muffled <- TRUE
[16:20:48.531]                             break
[16:20:48.531]                           }
[16:20:48.531]                         }
[16:20:48.531]                       }
[16:20:48.531]                       invisible(muffled)
[16:20:48.531]                     }
[16:20:48.531]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.531]                   }
[16:20:48.531]                 }
[16:20:48.531]                 else {
[16:20:48.531]                   if (TRUE) {
[16:20:48.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.531]                     {
[16:20:48.531]                       inherits <- base::inherits
[16:20:48.531]                       invokeRestart <- base::invokeRestart
[16:20:48.531]                       is.null <- base::is.null
[16:20:48.531]                       muffled <- FALSE
[16:20:48.531]                       if (inherits(cond, "message")) {
[16:20:48.531]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.531]                         if (muffled) 
[16:20:48.531]                           invokeRestart("muffleMessage")
[16:20:48.531]                       }
[16:20:48.531]                       else if (inherits(cond, "warning")) {
[16:20:48.531]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.531]                         if (muffled) 
[16:20:48.531]                           invokeRestart("muffleWarning")
[16:20:48.531]                       }
[16:20:48.531]                       else if (inherits(cond, "condition")) {
[16:20:48.531]                         if (!is.null(pattern)) {
[16:20:48.531]                           computeRestarts <- base::computeRestarts
[16:20:48.531]                           grepl <- base::grepl
[16:20:48.531]                           restarts <- computeRestarts(cond)
[16:20:48.531]                           for (restart in restarts) {
[16:20:48.531]                             name <- restart$name
[16:20:48.531]                             if (is.null(name)) 
[16:20:48.531]                               next
[16:20:48.531]                             if (!grepl(pattern, name)) 
[16:20:48.531]                               next
[16:20:48.531]                             invokeRestart(restart)
[16:20:48.531]                             muffled <- TRUE
[16:20:48.531]                             break
[16:20:48.531]                           }
[16:20:48.531]                         }
[16:20:48.531]                       }
[16:20:48.531]                       invisible(muffled)
[16:20:48.531]                     }
[16:20:48.531]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.531]                   }
[16:20:48.531]                 }
[16:20:48.531]             }
[16:20:48.531]         }))
[16:20:48.531]     }, error = function(ex) {
[16:20:48.531]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.531]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.531]                 ...future.rng), started = ...future.startTime, 
[16:20:48.531]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.531]             version = "1.8"), class = "FutureResult")
[16:20:48.531]     }, finally = {
[16:20:48.531]         if (!identical(...future.workdir, getwd())) 
[16:20:48.531]             setwd(...future.workdir)
[16:20:48.531]         {
[16:20:48.531]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.531]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.531]             }
[16:20:48.531]             base::options(...future.oldOptions)
[16:20:48.531]             if (.Platform$OS.type == "windows") {
[16:20:48.531]                 old_names <- names(...future.oldEnvVars)
[16:20:48.531]                 envs <- base::Sys.getenv()
[16:20:48.531]                 names <- names(envs)
[16:20:48.531]                 common <- intersect(names, old_names)
[16:20:48.531]                 added <- setdiff(names, old_names)
[16:20:48.531]                 removed <- setdiff(old_names, names)
[16:20:48.531]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.531]                   envs[common]]
[16:20:48.531]                 NAMES <- toupper(changed)
[16:20:48.531]                 args <- list()
[16:20:48.531]                 for (kk in seq_along(NAMES)) {
[16:20:48.531]                   name <- changed[[kk]]
[16:20:48.531]                   NAME <- NAMES[[kk]]
[16:20:48.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.531]                     next
[16:20:48.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.531]                 }
[16:20:48.531]                 NAMES <- toupper(added)
[16:20:48.531]                 for (kk in seq_along(NAMES)) {
[16:20:48.531]                   name <- added[[kk]]
[16:20:48.531]                   NAME <- NAMES[[kk]]
[16:20:48.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.531]                     next
[16:20:48.531]                   args[[name]] <- ""
[16:20:48.531]                 }
[16:20:48.531]                 NAMES <- toupper(removed)
[16:20:48.531]                 for (kk in seq_along(NAMES)) {
[16:20:48.531]                   name <- removed[[kk]]
[16:20:48.531]                   NAME <- NAMES[[kk]]
[16:20:48.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.531]                     next
[16:20:48.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.531]                 }
[16:20:48.531]                 if (length(args) > 0) 
[16:20:48.531]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.531]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.531]             }
[16:20:48.531]             else {
[16:20:48.531]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.531]             }
[16:20:48.531]             {
[16:20:48.531]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.531]                   0L) {
[16:20:48.531]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.531]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.531]                   base::options(opts)
[16:20:48.531]                 }
[16:20:48.531]                 {
[16:20:48.531]                   {
[16:20:48.531]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:48.531]                     NULL
[16:20:48.531]                   }
[16:20:48.531]                   options(future.plan = NULL)
[16:20:48.531]                   if (is.na(NA_character_)) 
[16:20:48.531]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.531]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.531]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.531]                     .init = FALSE)
[16:20:48.531]                 }
[16:20:48.531]             }
[16:20:48.531]         }
[16:20:48.531]     })
[16:20:48.531]     if (TRUE) {
[16:20:48.531]         base::sink(type = "output", split = FALSE)
[16:20:48.531]         if (TRUE) {
[16:20:48.531]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.531]         }
[16:20:48.531]         else {
[16:20:48.531]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.531]         }
[16:20:48.531]         base::close(...future.stdout)
[16:20:48.531]         ...future.stdout <- NULL
[16:20:48.531]     }
[16:20:48.531]     ...future.result$conditions <- ...future.conditions
[16:20:48.531]     ...future.result$finished <- base::Sys.time()
[16:20:48.531]     ...future.result
[16:20:48.531] }
[16:20:48.533] assign_globals() ...
[16:20:48.534] List of 1
[16:20:48.534]  $ x: num [1:5] 1 1 2 2 2
[16:20:48.534]  - attr(*, "where")=List of 1
[16:20:48.534]   ..$ x:<environment: R_EmptyEnv> 
[16:20:48.534]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:48.534]  - attr(*, "resolved")= logi FALSE
[16:20:48.534]  - attr(*, "total_size")= num 96
[16:20:48.534]  - attr(*, "already-done")= logi TRUE
[16:20:48.540] - copied ‘x’ to environment
[16:20:48.540] assign_globals() ... done
[16:20:48.540] requestCore(): workers = 2
[16:20:48.542] MulticoreFuture started
[16:20:48.542] - Launch lazy future ... done
[16:20:48.542] run() for ‘MulticoreFuture’ ... done
[16:20:48.543] result() for MulticoreFuture ...
[16:20:48.543] plan(): Setting new future strategy stack:
[16:20:48.543] List of future strategies:
[16:20:48.543] 1. sequential:
[16:20:48.543]    - args: function (..., envir = parent.frame())
[16:20:48.543]    - tweaked: FALSE
[16:20:48.543]    - call: NULL
[16:20:48.544] plan(): nbrOfWorkers() = 1
[16:20:48.547] plan(): Setting new future strategy stack:
[16:20:48.548] List of future strategies:
[16:20:48.548] 1. multicore:
[16:20:48.548]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:48.548]    - tweaked: FALSE
[16:20:48.548]    - call: plan(strategy)
[16:20:48.553] plan(): nbrOfWorkers() = 2
[16:20:48.554] result() for MulticoreFuture ...
[16:20:48.554] result() for MulticoreFuture ... done
[16:20:48.554] result() for MulticoreFuture ... done
[16:20:48.554] result() for MulticoreFuture ...
[16:20:48.554] result() for MulticoreFuture ... done
x
1 2 
2 3 
[16:20:48.556] getGlobalsAndPackages() ...
[16:20:48.556] Searching for globals...
[16:20:48.557] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[16:20:48.558] Searching for globals ... DONE
[16:20:48.558] Resolving globals: FALSE
[16:20:48.558] The total size of the 1 globals is 96 bytes (96 bytes)
[16:20:48.559] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[16:20:48.559] - globals: [1] ‘x’
[16:20:48.559] - packages: [1] ‘stats’
[16:20:48.559] getGlobalsAndPackages() ... DONE
[16:20:48.560] run() for ‘Future’ ...
[16:20:48.560] - state: ‘created’
[16:20:48.560] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:48.564] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:48.564] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:48.564]   - Field: ‘label’
[16:20:48.564]   - Field: ‘local’
[16:20:48.564]   - Field: ‘owner’
[16:20:48.565]   - Field: ‘envir’
[16:20:48.565]   - Field: ‘workers’
[16:20:48.565]   - Field: ‘packages’
[16:20:48.565]   - Field: ‘gc’
[16:20:48.565]   - Field: ‘job’
[16:20:48.565]   - Field: ‘conditions’
[16:20:48.565]   - Field: ‘expr’
[16:20:48.565]   - Field: ‘uuid’
[16:20:48.566]   - Field: ‘seed’
[16:20:48.566]   - Field: ‘version’
[16:20:48.566]   - Field: ‘result’
[16:20:48.566]   - Field: ‘asynchronous’
[16:20:48.566]   - Field: ‘calls’
[16:20:48.566]   - Field: ‘globals’
[16:20:48.566]   - Field: ‘stdout’
[16:20:48.567]   - Field: ‘earlySignal’
[16:20:48.567]   - Field: ‘lazy’
[16:20:48.567]   - Field: ‘state’
[16:20:48.567] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:48.567] - Launch lazy future ...
[16:20:48.568] Packages needed by the future expression (n = 1): ‘stats’
[16:20:48.568] Packages needed by future strategies (n = 0): <none>
[16:20:48.568] {
[16:20:48.568]     {
[16:20:48.568]         {
[16:20:48.568]             ...future.startTime <- base::Sys.time()
[16:20:48.568]             {
[16:20:48.568]                 {
[16:20:48.568]                   {
[16:20:48.568]                     {
[16:20:48.568]                       {
[16:20:48.568]                         base::local({
[16:20:48.568]                           has_future <- base::requireNamespace("future", 
[16:20:48.568]                             quietly = TRUE)
[16:20:48.568]                           if (has_future) {
[16:20:48.568]                             ns <- base::getNamespace("future")
[16:20:48.568]                             version <- ns[[".package"]][["version"]]
[16:20:48.568]                             if (is.null(version)) 
[16:20:48.568]                               version <- utils::packageVersion("future")
[16:20:48.568]                           }
[16:20:48.568]                           else {
[16:20:48.568]                             version <- NULL
[16:20:48.568]                           }
[16:20:48.568]                           if (!has_future || version < "1.8.0") {
[16:20:48.568]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.568]                               "", base::R.version$version.string), 
[16:20:48.568]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:48.568]                                 base::R.version$platform, 8 * 
[16:20:48.568]                                   base::.Machine$sizeof.pointer), 
[16:20:48.568]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.568]                                 "release", "version")], collapse = " "), 
[16:20:48.568]                               hostname = base::Sys.info()[["nodename"]])
[16:20:48.568]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.568]                               info)
[16:20:48.568]                             info <- base::paste(info, collapse = "; ")
[16:20:48.568]                             if (!has_future) {
[16:20:48.568]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.568]                                 info)
[16:20:48.568]                             }
[16:20:48.568]                             else {
[16:20:48.568]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.568]                                 info, version)
[16:20:48.568]                             }
[16:20:48.568]                             base::stop(msg)
[16:20:48.568]                           }
[16:20:48.568]                         })
[16:20:48.568]                       }
[16:20:48.568]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:48.568]                       base::options(mc.cores = 1L)
[16:20:48.568]                     }
[16:20:48.568]                     base::local({
[16:20:48.568]                       for (pkg in "stats") {
[16:20:48.568]                         base::loadNamespace(pkg)
[16:20:48.568]                         base::library(pkg, character.only = TRUE)
[16:20:48.568]                       }
[16:20:48.568]                     })
[16:20:48.568]                   }
[16:20:48.568]                   ...future.strategy.old <- future::plan("list")
[16:20:48.568]                   options(future.plan = NULL)
[16:20:48.568]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.568]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.568]                 }
[16:20:48.568]                 ...future.workdir <- getwd()
[16:20:48.568]             }
[16:20:48.568]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.568]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.568]         }
[16:20:48.568]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.568]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.568]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.568]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.568]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.568]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.568]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.568]             base::names(...future.oldOptions))
[16:20:48.568]     }
[16:20:48.568]     if (FALSE) {
[16:20:48.568]     }
[16:20:48.568]     else {
[16:20:48.568]         if (TRUE) {
[16:20:48.568]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.568]                 open = "w")
[16:20:48.568]         }
[16:20:48.568]         else {
[16:20:48.568]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.568]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.568]         }
[16:20:48.568]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.568]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.568]             base::sink(type = "output", split = FALSE)
[16:20:48.568]             base::close(...future.stdout)
[16:20:48.568]         }, add = TRUE)
[16:20:48.568]     }
[16:20:48.568]     ...future.frame <- base::sys.nframe()
[16:20:48.568]     ...future.conditions <- base::list()
[16:20:48.568]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.568]     if (FALSE) {
[16:20:48.568]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.568]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.568]     }
[16:20:48.568]     ...future.result <- base::tryCatch({
[16:20:48.568]         base::withCallingHandlers({
[16:20:48.568]             ...future.value <- base::withVisible(base::local({
[16:20:48.568]                 withCallingHandlers({
[16:20:48.568]                   {
[16:20:48.568]                     xtabs(~x)
[16:20:48.568]                   }
[16:20:48.568]                 }, immediateCondition = function(cond) {
[16:20:48.568]                   save_rds <- function (object, pathname, ...) 
[16:20:48.568]                   {
[16:20:48.568]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:48.568]                     if (file_test("-f", pathname_tmp)) {
[16:20:48.568]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.568]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:48.568]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.568]                         fi_tmp[["mtime"]])
[16:20:48.568]                     }
[16:20:48.568]                     tryCatch({
[16:20:48.568]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:48.568]                     }, error = function(ex) {
[16:20:48.568]                       msg <- conditionMessage(ex)
[16:20:48.568]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.568]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:48.568]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.568]                         fi_tmp[["mtime"]], msg)
[16:20:48.568]                       ex$message <- msg
[16:20:48.568]                       stop(ex)
[16:20:48.568]                     })
[16:20:48.568]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:48.568]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:48.568]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:48.568]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.568]                       fi <- file.info(pathname)
[16:20:48.568]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:48.568]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.568]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:48.568]                         fi[["size"]], fi[["mtime"]])
[16:20:48.568]                       stop(msg)
[16:20:48.568]                     }
[16:20:48.568]                     invisible(pathname)
[16:20:48.568]                   }
[16:20:48.568]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:48.568]                     rootPath = tempdir()) 
[16:20:48.568]                   {
[16:20:48.568]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:48.568]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:48.568]                       tmpdir = path, fileext = ".rds")
[16:20:48.568]                     save_rds(obj, file)
[16:20:48.568]                   }
[16:20:48.568]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4Mnhkl/.future/immediateConditions")
[16:20:48.568]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.568]                   {
[16:20:48.568]                     inherits <- base::inherits
[16:20:48.568]                     invokeRestart <- base::invokeRestart
[16:20:48.568]                     is.null <- base::is.null
[16:20:48.568]                     muffled <- FALSE
[16:20:48.568]                     if (inherits(cond, "message")) {
[16:20:48.568]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:48.568]                       if (muffled) 
[16:20:48.568]                         invokeRestart("muffleMessage")
[16:20:48.568]                     }
[16:20:48.568]                     else if (inherits(cond, "warning")) {
[16:20:48.568]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:48.568]                       if (muffled) 
[16:20:48.568]                         invokeRestart("muffleWarning")
[16:20:48.568]                     }
[16:20:48.568]                     else if (inherits(cond, "condition")) {
[16:20:48.568]                       if (!is.null(pattern)) {
[16:20:48.568]                         computeRestarts <- base::computeRestarts
[16:20:48.568]                         grepl <- base::grepl
[16:20:48.568]                         restarts <- computeRestarts(cond)
[16:20:48.568]                         for (restart in restarts) {
[16:20:48.568]                           name <- restart$name
[16:20:48.568]                           if (is.null(name)) 
[16:20:48.568]                             next
[16:20:48.568]                           if (!grepl(pattern, name)) 
[16:20:48.568]                             next
[16:20:48.568]                           invokeRestart(restart)
[16:20:48.568]                           muffled <- TRUE
[16:20:48.568]                           break
[16:20:48.568]                         }
[16:20:48.568]                       }
[16:20:48.568]                     }
[16:20:48.568]                     invisible(muffled)
[16:20:48.568]                   }
[16:20:48.568]                   muffleCondition(cond)
[16:20:48.568]                 })
[16:20:48.568]             }))
[16:20:48.568]             future::FutureResult(value = ...future.value$value, 
[16:20:48.568]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.568]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.568]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.568]                     ...future.globalenv.names))
[16:20:48.568]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.568]         }, condition = base::local({
[16:20:48.568]             c <- base::c
[16:20:48.568]             inherits <- base::inherits
[16:20:48.568]             invokeRestart <- base::invokeRestart
[16:20:48.568]             length <- base::length
[16:20:48.568]             list <- base::list
[16:20:48.568]             seq.int <- base::seq.int
[16:20:48.568]             signalCondition <- base::signalCondition
[16:20:48.568]             sys.calls <- base::sys.calls
[16:20:48.568]             `[[` <- base::`[[`
[16:20:48.568]             `+` <- base::`+`
[16:20:48.568]             `<<-` <- base::`<<-`
[16:20:48.568]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.568]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.568]                   3L)]
[16:20:48.568]             }
[16:20:48.568]             function(cond) {
[16:20:48.568]                 is_error <- inherits(cond, "error")
[16:20:48.568]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.568]                   NULL)
[16:20:48.568]                 if (is_error) {
[16:20:48.568]                   sessionInformation <- function() {
[16:20:48.568]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.568]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.568]                       search = base::search(), system = base::Sys.info())
[16:20:48.568]                   }
[16:20:48.568]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.568]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.568]                     cond$call), session = sessionInformation(), 
[16:20:48.568]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.568]                   signalCondition(cond)
[16:20:48.568]                 }
[16:20:48.568]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.568]                 "immediateCondition"))) {
[16:20:48.568]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.568]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.568]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.568]                   if (TRUE && !signal) {
[16:20:48.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.568]                     {
[16:20:48.568]                       inherits <- base::inherits
[16:20:48.568]                       invokeRestart <- base::invokeRestart
[16:20:48.568]                       is.null <- base::is.null
[16:20:48.568]                       muffled <- FALSE
[16:20:48.568]                       if (inherits(cond, "message")) {
[16:20:48.568]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.568]                         if (muffled) 
[16:20:48.568]                           invokeRestart("muffleMessage")
[16:20:48.568]                       }
[16:20:48.568]                       else if (inherits(cond, "warning")) {
[16:20:48.568]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.568]                         if (muffled) 
[16:20:48.568]                           invokeRestart("muffleWarning")
[16:20:48.568]                       }
[16:20:48.568]                       else if (inherits(cond, "condition")) {
[16:20:48.568]                         if (!is.null(pattern)) {
[16:20:48.568]                           computeRestarts <- base::computeRestarts
[16:20:48.568]                           grepl <- base::grepl
[16:20:48.568]                           restarts <- computeRestarts(cond)
[16:20:48.568]                           for (restart in restarts) {
[16:20:48.568]                             name <- restart$name
[16:20:48.568]                             if (is.null(name)) 
[16:20:48.568]                               next
[16:20:48.568]                             if (!grepl(pattern, name)) 
[16:20:48.568]                               next
[16:20:48.568]                             invokeRestart(restart)
[16:20:48.568]                             muffled <- TRUE
[16:20:48.568]                             break
[16:20:48.568]                           }
[16:20:48.568]                         }
[16:20:48.568]                       }
[16:20:48.568]                       invisible(muffled)
[16:20:48.568]                     }
[16:20:48.568]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.568]                   }
[16:20:48.568]                 }
[16:20:48.568]                 else {
[16:20:48.568]                   if (TRUE) {
[16:20:48.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.568]                     {
[16:20:48.568]                       inherits <- base::inherits
[16:20:48.568]                       invokeRestart <- base::invokeRestart
[16:20:48.568]                       is.null <- base::is.null
[16:20:48.568]                       muffled <- FALSE
[16:20:48.568]                       if (inherits(cond, "message")) {
[16:20:48.568]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.568]                         if (muffled) 
[16:20:48.568]                           invokeRestart("muffleMessage")
[16:20:48.568]                       }
[16:20:48.568]                       else if (inherits(cond, "warning")) {
[16:20:48.568]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.568]                         if (muffled) 
[16:20:48.568]                           invokeRestart("muffleWarning")
[16:20:48.568]                       }
[16:20:48.568]                       else if (inherits(cond, "condition")) {
[16:20:48.568]                         if (!is.null(pattern)) {
[16:20:48.568]                           computeRestarts <- base::computeRestarts
[16:20:48.568]                           grepl <- base::grepl
[16:20:48.568]                           restarts <- computeRestarts(cond)
[16:20:48.568]                           for (restart in restarts) {
[16:20:48.568]                             name <- restart$name
[16:20:48.568]                             if (is.null(name)) 
[16:20:48.568]                               next
[16:20:48.568]                             if (!grepl(pattern, name)) 
[16:20:48.568]                               next
[16:20:48.568]                             invokeRestart(restart)
[16:20:48.568]                             muffled <- TRUE
[16:20:48.568]                             break
[16:20:48.568]                           }
[16:20:48.568]                         }
[16:20:48.568]                       }
[16:20:48.568]                       invisible(muffled)
[16:20:48.568]                     }
[16:20:48.568]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.568]                   }
[16:20:48.568]                 }
[16:20:48.568]             }
[16:20:48.568]         }))
[16:20:48.568]     }, error = function(ex) {
[16:20:48.568]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.568]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.568]                 ...future.rng), started = ...future.startTime, 
[16:20:48.568]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.568]             version = "1.8"), class = "FutureResult")
[16:20:48.568]     }, finally = {
[16:20:48.568]         if (!identical(...future.workdir, getwd())) 
[16:20:48.568]             setwd(...future.workdir)
[16:20:48.568]         {
[16:20:48.568]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.568]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.568]             }
[16:20:48.568]             base::options(...future.oldOptions)
[16:20:48.568]             if (.Platform$OS.type == "windows") {
[16:20:48.568]                 old_names <- names(...future.oldEnvVars)
[16:20:48.568]                 envs <- base::Sys.getenv()
[16:20:48.568]                 names <- names(envs)
[16:20:48.568]                 common <- intersect(names, old_names)
[16:20:48.568]                 added <- setdiff(names, old_names)
[16:20:48.568]                 removed <- setdiff(old_names, names)
[16:20:48.568]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.568]                   envs[common]]
[16:20:48.568]                 NAMES <- toupper(changed)
[16:20:48.568]                 args <- list()
[16:20:48.568]                 for (kk in seq_along(NAMES)) {
[16:20:48.568]                   name <- changed[[kk]]
[16:20:48.568]                   NAME <- NAMES[[kk]]
[16:20:48.568]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.568]                     next
[16:20:48.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.568]                 }
[16:20:48.568]                 NAMES <- toupper(added)
[16:20:48.568]                 for (kk in seq_along(NAMES)) {
[16:20:48.568]                   name <- added[[kk]]
[16:20:48.568]                   NAME <- NAMES[[kk]]
[16:20:48.568]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.568]                     next
[16:20:48.568]                   args[[name]] <- ""
[16:20:48.568]                 }
[16:20:48.568]                 NAMES <- toupper(removed)
[16:20:48.568]                 for (kk in seq_along(NAMES)) {
[16:20:48.568]                   name <- removed[[kk]]
[16:20:48.568]                   NAME <- NAMES[[kk]]
[16:20:48.568]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.568]                     next
[16:20:48.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.568]                 }
[16:20:48.568]                 if (length(args) > 0) 
[16:20:48.568]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.568]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.568]             }
[16:20:48.568]             else {
[16:20:48.568]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.568]             }
[16:20:48.568]             {
[16:20:48.568]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.568]                   0L) {
[16:20:48.568]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.568]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.568]                   base::options(opts)
[16:20:48.568]                 }
[16:20:48.568]                 {
[16:20:48.568]                   {
[16:20:48.568]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:48.568]                     NULL
[16:20:48.568]                   }
[16:20:48.568]                   options(future.plan = NULL)
[16:20:48.568]                   if (is.na(NA_character_)) 
[16:20:48.568]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.568]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.568]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.568]                     .init = FALSE)
[16:20:48.568]                 }
[16:20:48.568]             }
[16:20:48.568]         }
[16:20:48.568]     })
[16:20:48.568]     if (TRUE) {
[16:20:48.568]         base::sink(type = "output", split = FALSE)
[16:20:48.568]         if (TRUE) {
[16:20:48.568]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.568]         }
[16:20:48.568]         else {
[16:20:48.568]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.568]         }
[16:20:48.568]         base::close(...future.stdout)
[16:20:48.568]         ...future.stdout <- NULL
[16:20:48.568]     }
[16:20:48.568]     ...future.result$conditions <- ...future.conditions
[16:20:48.568]     ...future.result$finished <- base::Sys.time()
[16:20:48.568]     ...future.result
[16:20:48.568] }
[16:20:48.571] assign_globals() ...
[16:20:48.571] List of 1
[16:20:48.571]  $ x: num [1:5] 1 1 2 2 2
[16:20:48.571]  - attr(*, "where")=List of 1
[16:20:48.571]   ..$ x:<environment: R_EmptyEnv> 
[16:20:48.571]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:48.571]  - attr(*, "resolved")= logi FALSE
[16:20:48.571]  - attr(*, "total_size")= num 96
[16:20:48.571]  - attr(*, "already-done")= logi TRUE
[16:20:48.574] - copied ‘x’ to environment
[16:20:48.574] assign_globals() ... done
[16:20:48.574] requestCore(): workers = 2
[16:20:48.576] MulticoreFuture started
[16:20:48.577] - Launch lazy future ... done
[16:20:48.577] run() for ‘MulticoreFuture’ ... done
[16:20:48.577] result() for MulticoreFuture ...
[16:20:48.578] plan(): Setting new future strategy stack:
[16:20:48.578] List of future strategies:
[16:20:48.578] 1. sequential:
[16:20:48.578]    - args: function (..., envir = parent.frame())
[16:20:48.578]    - tweaked: FALSE
[16:20:48.578]    - call: NULL
[16:20:48.579] plan(): nbrOfWorkers() = 1
[16:20:48.582] plan(): Setting new future strategy stack:
[16:20:48.582] List of future strategies:
[16:20:48.582] 1. multicore:
[16:20:48.582]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:48.582]    - tweaked: FALSE
[16:20:48.582]    - call: plan(strategy)
[16:20:48.591] plan(): nbrOfWorkers() = 2
[16:20:48.592] result() for MulticoreFuture ...
[16:20:48.592] result() for MulticoreFuture ... done
[16:20:48.592] result() for MulticoreFuture ... done
[16:20:48.593] result() for MulticoreFuture ...
[16:20:48.593] result() for MulticoreFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[16:20:48.595] getGlobalsAndPackages() ...
[16:20:48.595] Searching for globals...
[16:20:48.600] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[16:20:48.600] Searching for globals ... DONE
[16:20:48.600] Resolving globals: FALSE
[16:20:48.601] 
[16:20:48.601] - packages: [2] ‘stats’, ‘datasets’
[16:20:48.601] getGlobalsAndPackages() ... DONE
[16:20:48.602] run() for ‘Future’ ...
[16:20:48.602] - state: ‘created’
[16:20:48.602] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:48.606] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:48.606] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:48.606]   - Field: ‘label’
[16:20:48.607]   - Field: ‘local’
[16:20:48.607]   - Field: ‘owner’
[16:20:48.607]   - Field: ‘envir’
[16:20:48.607]   - Field: ‘workers’
[16:20:48.607]   - Field: ‘packages’
[16:20:48.607]   - Field: ‘gc’
[16:20:48.607]   - Field: ‘job’
[16:20:48.607]   - Field: ‘conditions’
[16:20:48.607]   - Field: ‘expr’
[16:20:48.608]   - Field: ‘uuid’
[16:20:48.608]   - Field: ‘seed’
[16:20:48.608]   - Field: ‘version’
[16:20:48.608]   - Field: ‘result’
[16:20:48.608]   - Field: ‘asynchronous’
[16:20:48.608]   - Field: ‘calls’
[16:20:48.608]   - Field: ‘globals’
[16:20:48.609]   - Field: ‘stdout’
[16:20:48.609]   - Field: ‘earlySignal’
[16:20:48.609]   - Field: ‘lazy’
[16:20:48.609]   - Field: ‘state’
[16:20:48.609] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:48.609] - Launch lazy future ...
[16:20:48.609] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:20:48.610] Packages needed by future strategies (n = 0): <none>
[16:20:48.610] {
[16:20:48.610]     {
[16:20:48.610]         {
[16:20:48.610]             ...future.startTime <- base::Sys.time()
[16:20:48.610]             {
[16:20:48.610]                 {
[16:20:48.610]                   {
[16:20:48.610]                     {
[16:20:48.610]                       {
[16:20:48.610]                         base::local({
[16:20:48.610]                           has_future <- base::requireNamespace("future", 
[16:20:48.610]                             quietly = TRUE)
[16:20:48.610]                           if (has_future) {
[16:20:48.610]                             ns <- base::getNamespace("future")
[16:20:48.610]                             version <- ns[[".package"]][["version"]]
[16:20:48.610]                             if (is.null(version)) 
[16:20:48.610]                               version <- utils::packageVersion("future")
[16:20:48.610]                           }
[16:20:48.610]                           else {
[16:20:48.610]                             version <- NULL
[16:20:48.610]                           }
[16:20:48.610]                           if (!has_future || version < "1.8.0") {
[16:20:48.610]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.610]                               "", base::R.version$version.string), 
[16:20:48.610]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:48.610]                                 base::R.version$platform, 8 * 
[16:20:48.610]                                   base::.Machine$sizeof.pointer), 
[16:20:48.610]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.610]                                 "release", "version")], collapse = " "), 
[16:20:48.610]                               hostname = base::Sys.info()[["nodename"]])
[16:20:48.610]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.610]                               info)
[16:20:48.610]                             info <- base::paste(info, collapse = "; ")
[16:20:48.610]                             if (!has_future) {
[16:20:48.610]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.610]                                 info)
[16:20:48.610]                             }
[16:20:48.610]                             else {
[16:20:48.610]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.610]                                 info, version)
[16:20:48.610]                             }
[16:20:48.610]                             base::stop(msg)
[16:20:48.610]                           }
[16:20:48.610]                         })
[16:20:48.610]                       }
[16:20:48.610]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:48.610]                       base::options(mc.cores = 1L)
[16:20:48.610]                     }
[16:20:48.610]                     base::local({
[16:20:48.610]                       for (pkg in c("stats", "datasets")) {
[16:20:48.610]                         base::loadNamespace(pkg)
[16:20:48.610]                         base::library(pkg, character.only = TRUE)
[16:20:48.610]                       }
[16:20:48.610]                     })
[16:20:48.610]                   }
[16:20:48.610]                   ...future.strategy.old <- future::plan("list")
[16:20:48.610]                   options(future.plan = NULL)
[16:20:48.610]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.610]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.610]                 }
[16:20:48.610]                 ...future.workdir <- getwd()
[16:20:48.610]             }
[16:20:48.610]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.610]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.610]         }
[16:20:48.610]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.610]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.610]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.610]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.610]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.610]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.610]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.610]             base::names(...future.oldOptions))
[16:20:48.610]     }
[16:20:48.610]     if (FALSE) {
[16:20:48.610]     }
[16:20:48.610]     else {
[16:20:48.610]         if (TRUE) {
[16:20:48.610]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.610]                 open = "w")
[16:20:48.610]         }
[16:20:48.610]         else {
[16:20:48.610]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.610]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.610]         }
[16:20:48.610]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.610]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.610]             base::sink(type = "output", split = FALSE)
[16:20:48.610]             base::close(...future.stdout)
[16:20:48.610]         }, add = TRUE)
[16:20:48.610]     }
[16:20:48.610]     ...future.frame <- base::sys.nframe()
[16:20:48.610]     ...future.conditions <- base::list()
[16:20:48.610]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.610]     if (FALSE) {
[16:20:48.610]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.610]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.610]     }
[16:20:48.610]     ...future.result <- base::tryCatch({
[16:20:48.610]         base::withCallingHandlers({
[16:20:48.610]             ...future.value <- base::withVisible(base::local({
[16:20:48.610]                 withCallingHandlers({
[16:20:48.610]                   {
[16:20:48.610]                     lm(dist ~ . - 1, data = cars)
[16:20:48.610]                   }
[16:20:48.610]                 }, immediateCondition = function(cond) {
[16:20:48.610]                   save_rds <- function (object, pathname, ...) 
[16:20:48.610]                   {
[16:20:48.610]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:48.610]                     if (file_test("-f", pathname_tmp)) {
[16:20:48.610]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.610]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:48.610]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.610]                         fi_tmp[["mtime"]])
[16:20:48.610]                     }
[16:20:48.610]                     tryCatch({
[16:20:48.610]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:48.610]                     }, error = function(ex) {
[16:20:48.610]                       msg <- conditionMessage(ex)
[16:20:48.610]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.610]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:48.610]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.610]                         fi_tmp[["mtime"]], msg)
[16:20:48.610]                       ex$message <- msg
[16:20:48.610]                       stop(ex)
[16:20:48.610]                     })
[16:20:48.610]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:48.610]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:48.610]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:48.610]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.610]                       fi <- file.info(pathname)
[16:20:48.610]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:48.610]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.610]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:48.610]                         fi[["size"]], fi[["mtime"]])
[16:20:48.610]                       stop(msg)
[16:20:48.610]                     }
[16:20:48.610]                     invisible(pathname)
[16:20:48.610]                   }
[16:20:48.610]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:48.610]                     rootPath = tempdir()) 
[16:20:48.610]                   {
[16:20:48.610]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:48.610]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:48.610]                       tmpdir = path, fileext = ".rds")
[16:20:48.610]                     save_rds(obj, file)
[16:20:48.610]                   }
[16:20:48.610]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4Mnhkl/.future/immediateConditions")
[16:20:48.610]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.610]                   {
[16:20:48.610]                     inherits <- base::inherits
[16:20:48.610]                     invokeRestart <- base::invokeRestart
[16:20:48.610]                     is.null <- base::is.null
[16:20:48.610]                     muffled <- FALSE
[16:20:48.610]                     if (inherits(cond, "message")) {
[16:20:48.610]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:48.610]                       if (muffled) 
[16:20:48.610]                         invokeRestart("muffleMessage")
[16:20:48.610]                     }
[16:20:48.610]                     else if (inherits(cond, "warning")) {
[16:20:48.610]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:48.610]                       if (muffled) 
[16:20:48.610]                         invokeRestart("muffleWarning")
[16:20:48.610]                     }
[16:20:48.610]                     else if (inherits(cond, "condition")) {
[16:20:48.610]                       if (!is.null(pattern)) {
[16:20:48.610]                         computeRestarts <- base::computeRestarts
[16:20:48.610]                         grepl <- base::grepl
[16:20:48.610]                         restarts <- computeRestarts(cond)
[16:20:48.610]                         for (restart in restarts) {
[16:20:48.610]                           name <- restart$name
[16:20:48.610]                           if (is.null(name)) 
[16:20:48.610]                             next
[16:20:48.610]                           if (!grepl(pattern, name)) 
[16:20:48.610]                             next
[16:20:48.610]                           invokeRestart(restart)
[16:20:48.610]                           muffled <- TRUE
[16:20:48.610]                           break
[16:20:48.610]                         }
[16:20:48.610]                       }
[16:20:48.610]                     }
[16:20:48.610]                     invisible(muffled)
[16:20:48.610]                   }
[16:20:48.610]                   muffleCondition(cond)
[16:20:48.610]                 })
[16:20:48.610]             }))
[16:20:48.610]             future::FutureResult(value = ...future.value$value, 
[16:20:48.610]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.610]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.610]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.610]                     ...future.globalenv.names))
[16:20:48.610]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.610]         }, condition = base::local({
[16:20:48.610]             c <- base::c
[16:20:48.610]             inherits <- base::inherits
[16:20:48.610]             invokeRestart <- base::invokeRestart
[16:20:48.610]             length <- base::length
[16:20:48.610]             list <- base::list
[16:20:48.610]             seq.int <- base::seq.int
[16:20:48.610]             signalCondition <- base::signalCondition
[16:20:48.610]             sys.calls <- base::sys.calls
[16:20:48.610]             `[[` <- base::`[[`
[16:20:48.610]             `+` <- base::`+`
[16:20:48.610]             `<<-` <- base::`<<-`
[16:20:48.610]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.610]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.610]                   3L)]
[16:20:48.610]             }
[16:20:48.610]             function(cond) {
[16:20:48.610]                 is_error <- inherits(cond, "error")
[16:20:48.610]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.610]                   NULL)
[16:20:48.610]                 if (is_error) {
[16:20:48.610]                   sessionInformation <- function() {
[16:20:48.610]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.610]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.610]                       search = base::search(), system = base::Sys.info())
[16:20:48.610]                   }
[16:20:48.610]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.610]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.610]                     cond$call), session = sessionInformation(), 
[16:20:48.610]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.610]                   signalCondition(cond)
[16:20:48.610]                 }
[16:20:48.610]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.610]                 "immediateCondition"))) {
[16:20:48.610]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.610]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.610]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.610]                   if (TRUE && !signal) {
[16:20:48.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.610]                     {
[16:20:48.610]                       inherits <- base::inherits
[16:20:48.610]                       invokeRestart <- base::invokeRestart
[16:20:48.610]                       is.null <- base::is.null
[16:20:48.610]                       muffled <- FALSE
[16:20:48.610]                       if (inherits(cond, "message")) {
[16:20:48.610]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.610]                         if (muffled) 
[16:20:48.610]                           invokeRestart("muffleMessage")
[16:20:48.610]                       }
[16:20:48.610]                       else if (inherits(cond, "warning")) {
[16:20:48.610]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.610]                         if (muffled) 
[16:20:48.610]                           invokeRestart("muffleWarning")
[16:20:48.610]                       }
[16:20:48.610]                       else if (inherits(cond, "condition")) {
[16:20:48.610]                         if (!is.null(pattern)) {
[16:20:48.610]                           computeRestarts <- base::computeRestarts
[16:20:48.610]                           grepl <- base::grepl
[16:20:48.610]                           restarts <- computeRestarts(cond)
[16:20:48.610]                           for (restart in restarts) {
[16:20:48.610]                             name <- restart$name
[16:20:48.610]                             if (is.null(name)) 
[16:20:48.610]                               next
[16:20:48.610]                             if (!grepl(pattern, name)) 
[16:20:48.610]                               next
[16:20:48.610]                             invokeRestart(restart)
[16:20:48.610]                             muffled <- TRUE
[16:20:48.610]                             break
[16:20:48.610]                           }
[16:20:48.610]                         }
[16:20:48.610]                       }
[16:20:48.610]                       invisible(muffled)
[16:20:48.610]                     }
[16:20:48.610]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.610]                   }
[16:20:48.610]                 }
[16:20:48.610]                 else {
[16:20:48.610]                   if (TRUE) {
[16:20:48.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.610]                     {
[16:20:48.610]                       inherits <- base::inherits
[16:20:48.610]                       invokeRestart <- base::invokeRestart
[16:20:48.610]                       is.null <- base::is.null
[16:20:48.610]                       muffled <- FALSE
[16:20:48.610]                       if (inherits(cond, "message")) {
[16:20:48.610]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.610]                         if (muffled) 
[16:20:48.610]                           invokeRestart("muffleMessage")
[16:20:48.610]                       }
[16:20:48.610]                       else if (inherits(cond, "warning")) {
[16:20:48.610]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.610]                         if (muffled) 
[16:20:48.610]                           invokeRestart("muffleWarning")
[16:20:48.610]                       }
[16:20:48.610]                       else if (inherits(cond, "condition")) {
[16:20:48.610]                         if (!is.null(pattern)) {
[16:20:48.610]                           computeRestarts <- base::computeRestarts
[16:20:48.610]                           grepl <- base::grepl
[16:20:48.610]                           restarts <- computeRestarts(cond)
[16:20:48.610]                           for (restart in restarts) {
[16:20:48.610]                             name <- restart$name
[16:20:48.610]                             if (is.null(name)) 
[16:20:48.610]                               next
[16:20:48.610]                             if (!grepl(pattern, name)) 
[16:20:48.610]                               next
[16:20:48.610]                             invokeRestart(restart)
[16:20:48.610]                             muffled <- TRUE
[16:20:48.610]                             break
[16:20:48.610]                           }
[16:20:48.610]                         }
[16:20:48.610]                       }
[16:20:48.610]                       invisible(muffled)
[16:20:48.610]                     }
[16:20:48.610]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.610]                   }
[16:20:48.610]                 }
[16:20:48.610]             }
[16:20:48.610]         }))
[16:20:48.610]     }, error = function(ex) {
[16:20:48.610]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.610]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.610]                 ...future.rng), started = ...future.startTime, 
[16:20:48.610]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.610]             version = "1.8"), class = "FutureResult")
[16:20:48.610]     }, finally = {
[16:20:48.610]         if (!identical(...future.workdir, getwd())) 
[16:20:48.610]             setwd(...future.workdir)
[16:20:48.610]         {
[16:20:48.610]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.610]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.610]             }
[16:20:48.610]             base::options(...future.oldOptions)
[16:20:48.610]             if (.Platform$OS.type == "windows") {
[16:20:48.610]                 old_names <- names(...future.oldEnvVars)
[16:20:48.610]                 envs <- base::Sys.getenv()
[16:20:48.610]                 names <- names(envs)
[16:20:48.610]                 common <- intersect(names, old_names)
[16:20:48.610]                 added <- setdiff(names, old_names)
[16:20:48.610]                 removed <- setdiff(old_names, names)
[16:20:48.610]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.610]                   envs[common]]
[16:20:48.610]                 NAMES <- toupper(changed)
[16:20:48.610]                 args <- list()
[16:20:48.610]                 for (kk in seq_along(NAMES)) {
[16:20:48.610]                   name <- changed[[kk]]
[16:20:48.610]                   NAME <- NAMES[[kk]]
[16:20:48.610]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.610]                     next
[16:20:48.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.610]                 }
[16:20:48.610]                 NAMES <- toupper(added)
[16:20:48.610]                 for (kk in seq_along(NAMES)) {
[16:20:48.610]                   name <- added[[kk]]
[16:20:48.610]                   NAME <- NAMES[[kk]]
[16:20:48.610]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.610]                     next
[16:20:48.610]                   args[[name]] <- ""
[16:20:48.610]                 }
[16:20:48.610]                 NAMES <- toupper(removed)
[16:20:48.610]                 for (kk in seq_along(NAMES)) {
[16:20:48.610]                   name <- removed[[kk]]
[16:20:48.610]                   NAME <- NAMES[[kk]]
[16:20:48.610]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.610]                     next
[16:20:48.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.610]                 }
[16:20:48.610]                 if (length(args) > 0) 
[16:20:48.610]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.610]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.610]             }
[16:20:48.610]             else {
[16:20:48.610]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.610]             }
[16:20:48.610]             {
[16:20:48.610]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.610]                   0L) {
[16:20:48.610]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.610]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.610]                   base::options(opts)
[16:20:48.610]                 }
[16:20:48.610]                 {
[16:20:48.610]                   {
[16:20:48.610]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:48.610]                     NULL
[16:20:48.610]                   }
[16:20:48.610]                   options(future.plan = NULL)
[16:20:48.610]                   if (is.na(NA_character_)) 
[16:20:48.610]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.610]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.610]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.610]                     .init = FALSE)
[16:20:48.610]                 }
[16:20:48.610]             }
[16:20:48.610]         }
[16:20:48.610]     })
[16:20:48.610]     if (TRUE) {
[16:20:48.610]         base::sink(type = "output", split = FALSE)
[16:20:48.610]         if (TRUE) {
[16:20:48.610]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.610]         }
[16:20:48.610]         else {
[16:20:48.610]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.610]         }
[16:20:48.610]         base::close(...future.stdout)
[16:20:48.610]         ...future.stdout <- NULL
[16:20:48.610]     }
[16:20:48.610]     ...future.result$conditions <- ...future.conditions
[16:20:48.610]     ...future.result$finished <- base::Sys.time()
[16:20:48.610]     ...future.result
[16:20:48.610] }
[16:20:48.613] requestCore(): workers = 2
[16:20:48.614] MulticoreFuture started
[16:20:48.615] - Launch lazy future ... done
[16:20:48.615] run() for ‘MulticoreFuture’ ... done
[16:20:48.615] result() for MulticoreFuture ...
[16:20:48.616] plan(): Setting new future strategy stack:
[16:20:48.616] List of future strategies:
[16:20:48.616] 1. sequential:
[16:20:48.616]    - args: function (..., envir = parent.frame())
[16:20:48.616]    - tweaked: FALSE
[16:20:48.616]    - call: NULL
[16:20:48.617] plan(): nbrOfWorkers() = 1
[16:20:48.621] plan(): Setting new future strategy stack:
[16:20:48.621] List of future strategies:
[16:20:48.621] 1. multicore:
[16:20:48.621]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:48.621]    - tweaked: FALSE
[16:20:48.621]    - call: plan(strategy)
[16:20:48.626] plan(): nbrOfWorkers() = 2
[16:20:48.628] result() for MulticoreFuture ...
[16:20:48.628] result() for MulticoreFuture ... done
[16:20:48.629] result() for MulticoreFuture ... done
[16:20:48.629] result() for MulticoreFuture ...
[16:20:48.629] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[16:20:48.632] getGlobalsAndPackages() ...
[16:20:48.632] Searching for globals...
[16:20:48.635] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[16:20:48.635] Searching for globals ... DONE
[16:20:48.635] Resolving globals: FALSE
[16:20:48.635] 
[16:20:48.636] - packages: [2] ‘stats’, ‘datasets’
[16:20:48.636] getGlobalsAndPackages() ... DONE
[16:20:48.636] run() for ‘Future’ ...
[16:20:48.636] - state: ‘created’
[16:20:48.636] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:48.640] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:48.640] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:48.641]   - Field: ‘label’
[16:20:48.641]   - Field: ‘local’
[16:20:48.641]   - Field: ‘owner’
[16:20:48.641]   - Field: ‘envir’
[16:20:48.641]   - Field: ‘workers’
[16:20:48.641]   - Field: ‘packages’
[16:20:48.641]   - Field: ‘gc’
[16:20:48.641]   - Field: ‘job’
[16:20:48.642]   - Field: ‘conditions’
[16:20:48.642]   - Field: ‘expr’
[16:20:48.642]   - Field: ‘uuid’
[16:20:48.677]   - Field: ‘seed’
[16:20:48.678]   - Field: ‘version’
[16:20:48.678]   - Field: ‘result’
[16:20:48.678]   - Field: ‘asynchronous’
[16:20:48.678]   - Field: ‘calls’
[16:20:48.678]   - Field: ‘globals’
[16:20:48.678]   - Field: ‘stdout’
[16:20:48.678]   - Field: ‘earlySignal’
[16:20:48.678]   - Field: ‘lazy’
[16:20:48.679]   - Field: ‘state’
[16:20:48.679] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:48.679] - Launch lazy future ...
[16:20:48.679] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:20:48.679] Packages needed by future strategies (n = 0): <none>
[16:20:48.680] {
[16:20:48.680]     {
[16:20:48.680]         {
[16:20:48.680]             ...future.startTime <- base::Sys.time()
[16:20:48.680]             {
[16:20:48.680]                 {
[16:20:48.680]                   {
[16:20:48.680]                     {
[16:20:48.680]                       {
[16:20:48.680]                         base::local({
[16:20:48.680]                           has_future <- base::requireNamespace("future", 
[16:20:48.680]                             quietly = TRUE)
[16:20:48.680]                           if (has_future) {
[16:20:48.680]                             ns <- base::getNamespace("future")
[16:20:48.680]                             version <- ns[[".package"]][["version"]]
[16:20:48.680]                             if (is.null(version)) 
[16:20:48.680]                               version <- utils::packageVersion("future")
[16:20:48.680]                           }
[16:20:48.680]                           else {
[16:20:48.680]                             version <- NULL
[16:20:48.680]                           }
[16:20:48.680]                           if (!has_future || version < "1.8.0") {
[16:20:48.680]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.680]                               "", base::R.version$version.string), 
[16:20:48.680]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:48.680]                                 base::R.version$platform, 8 * 
[16:20:48.680]                                   base::.Machine$sizeof.pointer), 
[16:20:48.680]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.680]                                 "release", "version")], collapse = " "), 
[16:20:48.680]                               hostname = base::Sys.info()[["nodename"]])
[16:20:48.680]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.680]                               info)
[16:20:48.680]                             info <- base::paste(info, collapse = "; ")
[16:20:48.680]                             if (!has_future) {
[16:20:48.680]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.680]                                 info)
[16:20:48.680]                             }
[16:20:48.680]                             else {
[16:20:48.680]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.680]                                 info, version)
[16:20:48.680]                             }
[16:20:48.680]                             base::stop(msg)
[16:20:48.680]                           }
[16:20:48.680]                         })
[16:20:48.680]                       }
[16:20:48.680]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:48.680]                       base::options(mc.cores = 1L)
[16:20:48.680]                     }
[16:20:48.680]                     base::local({
[16:20:48.680]                       for (pkg in c("stats", "datasets")) {
[16:20:48.680]                         base::loadNamespace(pkg)
[16:20:48.680]                         base::library(pkg, character.only = TRUE)
[16:20:48.680]                       }
[16:20:48.680]                     })
[16:20:48.680]                   }
[16:20:48.680]                   ...future.strategy.old <- future::plan("list")
[16:20:48.680]                   options(future.plan = NULL)
[16:20:48.680]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.680]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.680]                 }
[16:20:48.680]                 ...future.workdir <- getwd()
[16:20:48.680]             }
[16:20:48.680]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.680]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.680]         }
[16:20:48.680]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.680]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.680]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.680]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.680]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.680]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.680]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.680]             base::names(...future.oldOptions))
[16:20:48.680]     }
[16:20:48.680]     if (FALSE) {
[16:20:48.680]     }
[16:20:48.680]     else {
[16:20:48.680]         if (TRUE) {
[16:20:48.680]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.680]                 open = "w")
[16:20:48.680]         }
[16:20:48.680]         else {
[16:20:48.680]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.680]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.680]         }
[16:20:48.680]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.680]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.680]             base::sink(type = "output", split = FALSE)
[16:20:48.680]             base::close(...future.stdout)
[16:20:48.680]         }, add = TRUE)
[16:20:48.680]     }
[16:20:48.680]     ...future.frame <- base::sys.nframe()
[16:20:48.680]     ...future.conditions <- base::list()
[16:20:48.680]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.680]     if (FALSE) {
[16:20:48.680]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.680]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.680]     }
[16:20:48.680]     ...future.result <- base::tryCatch({
[16:20:48.680]         base::withCallingHandlers({
[16:20:48.680]             ...future.value <- base::withVisible(base::local({
[16:20:48.680]                 withCallingHandlers({
[16:20:48.680]                   {
[16:20:48.680]                     lm(dist ~ . + 0, data = cars)
[16:20:48.680]                   }
[16:20:48.680]                 }, immediateCondition = function(cond) {
[16:20:48.680]                   save_rds <- function (object, pathname, ...) 
[16:20:48.680]                   {
[16:20:48.680]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:48.680]                     if (file_test("-f", pathname_tmp)) {
[16:20:48.680]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.680]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:48.680]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.680]                         fi_tmp[["mtime"]])
[16:20:48.680]                     }
[16:20:48.680]                     tryCatch({
[16:20:48.680]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:48.680]                     }, error = function(ex) {
[16:20:48.680]                       msg <- conditionMessage(ex)
[16:20:48.680]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.680]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:48.680]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.680]                         fi_tmp[["mtime"]], msg)
[16:20:48.680]                       ex$message <- msg
[16:20:48.680]                       stop(ex)
[16:20:48.680]                     })
[16:20:48.680]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:48.680]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:48.680]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:48.680]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.680]                       fi <- file.info(pathname)
[16:20:48.680]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:48.680]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.680]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:48.680]                         fi[["size"]], fi[["mtime"]])
[16:20:48.680]                       stop(msg)
[16:20:48.680]                     }
[16:20:48.680]                     invisible(pathname)
[16:20:48.680]                   }
[16:20:48.680]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:48.680]                     rootPath = tempdir()) 
[16:20:48.680]                   {
[16:20:48.680]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:48.680]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:48.680]                       tmpdir = path, fileext = ".rds")
[16:20:48.680]                     save_rds(obj, file)
[16:20:48.680]                   }
[16:20:48.680]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4Mnhkl/.future/immediateConditions")
[16:20:48.680]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.680]                   {
[16:20:48.680]                     inherits <- base::inherits
[16:20:48.680]                     invokeRestart <- base::invokeRestart
[16:20:48.680]                     is.null <- base::is.null
[16:20:48.680]                     muffled <- FALSE
[16:20:48.680]                     if (inherits(cond, "message")) {
[16:20:48.680]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:48.680]                       if (muffled) 
[16:20:48.680]                         invokeRestart("muffleMessage")
[16:20:48.680]                     }
[16:20:48.680]                     else if (inherits(cond, "warning")) {
[16:20:48.680]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:48.680]                       if (muffled) 
[16:20:48.680]                         invokeRestart("muffleWarning")
[16:20:48.680]                     }
[16:20:48.680]                     else if (inherits(cond, "condition")) {
[16:20:48.680]                       if (!is.null(pattern)) {
[16:20:48.680]                         computeRestarts <- base::computeRestarts
[16:20:48.680]                         grepl <- base::grepl
[16:20:48.680]                         restarts <- computeRestarts(cond)
[16:20:48.680]                         for (restart in restarts) {
[16:20:48.680]                           name <- restart$name
[16:20:48.680]                           if (is.null(name)) 
[16:20:48.680]                             next
[16:20:48.680]                           if (!grepl(pattern, name)) 
[16:20:48.680]                             next
[16:20:48.680]                           invokeRestart(restart)
[16:20:48.680]                           muffled <- TRUE
[16:20:48.680]                           break
[16:20:48.680]                         }
[16:20:48.680]                       }
[16:20:48.680]                     }
[16:20:48.680]                     invisible(muffled)
[16:20:48.680]                   }
[16:20:48.680]                   muffleCondition(cond)
[16:20:48.680]                 })
[16:20:48.680]             }))
[16:20:48.680]             future::FutureResult(value = ...future.value$value, 
[16:20:48.680]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.680]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.680]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.680]                     ...future.globalenv.names))
[16:20:48.680]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.680]         }, condition = base::local({
[16:20:48.680]             c <- base::c
[16:20:48.680]             inherits <- base::inherits
[16:20:48.680]             invokeRestart <- base::invokeRestart
[16:20:48.680]             length <- base::length
[16:20:48.680]             list <- base::list
[16:20:48.680]             seq.int <- base::seq.int
[16:20:48.680]             signalCondition <- base::signalCondition
[16:20:48.680]             sys.calls <- base::sys.calls
[16:20:48.680]             `[[` <- base::`[[`
[16:20:48.680]             `+` <- base::`+`
[16:20:48.680]             `<<-` <- base::`<<-`
[16:20:48.680]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.680]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.680]                   3L)]
[16:20:48.680]             }
[16:20:48.680]             function(cond) {
[16:20:48.680]                 is_error <- inherits(cond, "error")
[16:20:48.680]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.680]                   NULL)
[16:20:48.680]                 if (is_error) {
[16:20:48.680]                   sessionInformation <- function() {
[16:20:48.680]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.680]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.680]                       search = base::search(), system = base::Sys.info())
[16:20:48.680]                   }
[16:20:48.680]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.680]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.680]                     cond$call), session = sessionInformation(), 
[16:20:48.680]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.680]                   signalCondition(cond)
[16:20:48.680]                 }
[16:20:48.680]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.680]                 "immediateCondition"))) {
[16:20:48.680]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.680]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.680]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.680]                   if (TRUE && !signal) {
[16:20:48.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.680]                     {
[16:20:48.680]                       inherits <- base::inherits
[16:20:48.680]                       invokeRestart <- base::invokeRestart
[16:20:48.680]                       is.null <- base::is.null
[16:20:48.680]                       muffled <- FALSE
[16:20:48.680]                       if (inherits(cond, "message")) {
[16:20:48.680]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.680]                         if (muffled) 
[16:20:48.680]                           invokeRestart("muffleMessage")
[16:20:48.680]                       }
[16:20:48.680]                       else if (inherits(cond, "warning")) {
[16:20:48.680]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.680]                         if (muffled) 
[16:20:48.680]                           invokeRestart("muffleWarning")
[16:20:48.680]                       }
[16:20:48.680]                       else if (inherits(cond, "condition")) {
[16:20:48.680]                         if (!is.null(pattern)) {
[16:20:48.680]                           computeRestarts <- base::computeRestarts
[16:20:48.680]                           grepl <- base::grepl
[16:20:48.680]                           restarts <- computeRestarts(cond)
[16:20:48.680]                           for (restart in restarts) {
[16:20:48.680]                             name <- restart$name
[16:20:48.680]                             if (is.null(name)) 
[16:20:48.680]                               next
[16:20:48.680]                             if (!grepl(pattern, name)) 
[16:20:48.680]                               next
[16:20:48.680]                             invokeRestart(restart)
[16:20:48.680]                             muffled <- TRUE
[16:20:48.680]                             break
[16:20:48.680]                           }
[16:20:48.680]                         }
[16:20:48.680]                       }
[16:20:48.680]                       invisible(muffled)
[16:20:48.680]                     }
[16:20:48.680]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.680]                   }
[16:20:48.680]                 }
[16:20:48.680]                 else {
[16:20:48.680]                   if (TRUE) {
[16:20:48.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.680]                     {
[16:20:48.680]                       inherits <- base::inherits
[16:20:48.680]                       invokeRestart <- base::invokeRestart
[16:20:48.680]                       is.null <- base::is.null
[16:20:48.680]                       muffled <- FALSE
[16:20:48.680]                       if (inherits(cond, "message")) {
[16:20:48.680]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.680]                         if (muffled) 
[16:20:48.680]                           invokeRestart("muffleMessage")
[16:20:48.680]                       }
[16:20:48.680]                       else if (inherits(cond, "warning")) {
[16:20:48.680]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.680]                         if (muffled) 
[16:20:48.680]                           invokeRestart("muffleWarning")
[16:20:48.680]                       }
[16:20:48.680]                       else if (inherits(cond, "condition")) {
[16:20:48.680]                         if (!is.null(pattern)) {
[16:20:48.680]                           computeRestarts <- base::computeRestarts
[16:20:48.680]                           grepl <- base::grepl
[16:20:48.680]                           restarts <- computeRestarts(cond)
[16:20:48.680]                           for (restart in restarts) {
[16:20:48.680]                             name <- restart$name
[16:20:48.680]                             if (is.null(name)) 
[16:20:48.680]                               next
[16:20:48.680]                             if (!grepl(pattern, name)) 
[16:20:48.680]                               next
[16:20:48.680]                             invokeRestart(restart)
[16:20:48.680]                             muffled <- TRUE
[16:20:48.680]                             break
[16:20:48.680]                           }
[16:20:48.680]                         }
[16:20:48.680]                       }
[16:20:48.680]                       invisible(muffled)
[16:20:48.680]                     }
[16:20:48.680]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.680]                   }
[16:20:48.680]                 }
[16:20:48.680]             }
[16:20:48.680]         }))
[16:20:48.680]     }, error = function(ex) {
[16:20:48.680]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.680]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.680]                 ...future.rng), started = ...future.startTime, 
[16:20:48.680]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.680]             version = "1.8"), class = "FutureResult")
[16:20:48.680]     }, finally = {
[16:20:48.680]         if (!identical(...future.workdir, getwd())) 
[16:20:48.680]             setwd(...future.workdir)
[16:20:48.680]         {
[16:20:48.680]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.680]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.680]             }
[16:20:48.680]             base::options(...future.oldOptions)
[16:20:48.680]             if (.Platform$OS.type == "windows") {
[16:20:48.680]                 old_names <- names(...future.oldEnvVars)
[16:20:48.680]                 envs <- base::Sys.getenv()
[16:20:48.680]                 names <- names(envs)
[16:20:48.680]                 common <- intersect(names, old_names)
[16:20:48.680]                 added <- setdiff(names, old_names)
[16:20:48.680]                 removed <- setdiff(old_names, names)
[16:20:48.680]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.680]                   envs[common]]
[16:20:48.680]                 NAMES <- toupper(changed)
[16:20:48.680]                 args <- list()
[16:20:48.680]                 for (kk in seq_along(NAMES)) {
[16:20:48.680]                   name <- changed[[kk]]
[16:20:48.680]                   NAME <- NAMES[[kk]]
[16:20:48.680]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.680]                     next
[16:20:48.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.680]                 }
[16:20:48.680]                 NAMES <- toupper(added)
[16:20:48.680]                 for (kk in seq_along(NAMES)) {
[16:20:48.680]                   name <- added[[kk]]
[16:20:48.680]                   NAME <- NAMES[[kk]]
[16:20:48.680]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.680]                     next
[16:20:48.680]                   args[[name]] <- ""
[16:20:48.680]                 }
[16:20:48.680]                 NAMES <- toupper(removed)
[16:20:48.680]                 for (kk in seq_along(NAMES)) {
[16:20:48.680]                   name <- removed[[kk]]
[16:20:48.680]                   NAME <- NAMES[[kk]]
[16:20:48.680]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.680]                     next
[16:20:48.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.680]                 }
[16:20:48.680]                 if (length(args) > 0) 
[16:20:48.680]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.680]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.680]             }
[16:20:48.680]             else {
[16:20:48.680]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.680]             }
[16:20:48.680]             {
[16:20:48.680]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.680]                   0L) {
[16:20:48.680]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.680]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.680]                   base::options(opts)
[16:20:48.680]                 }
[16:20:48.680]                 {
[16:20:48.680]                   {
[16:20:48.680]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:48.680]                     NULL
[16:20:48.680]                   }
[16:20:48.680]                   options(future.plan = NULL)
[16:20:48.680]                   if (is.na(NA_character_)) 
[16:20:48.680]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.680]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.680]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.680]                     .init = FALSE)
[16:20:48.680]                 }
[16:20:48.680]             }
[16:20:48.680]         }
[16:20:48.680]     })
[16:20:48.680]     if (TRUE) {
[16:20:48.680]         base::sink(type = "output", split = FALSE)
[16:20:48.680]         if (TRUE) {
[16:20:48.680]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.680]         }
[16:20:48.680]         else {
[16:20:48.680]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.680]         }
[16:20:48.680]         base::close(...future.stdout)
[16:20:48.680]         ...future.stdout <- NULL
[16:20:48.680]     }
[16:20:48.680]     ...future.result$conditions <- ...future.conditions
[16:20:48.680]     ...future.result$finished <- base::Sys.time()
[16:20:48.680]     ...future.result
[16:20:48.680] }
[16:20:48.682] requestCore(): workers = 2
[16:20:48.685] MulticoreFuture started
[16:20:48.685] - Launch lazy future ... done
[16:20:48.686] run() for ‘MulticoreFuture’ ... done
[16:20:48.686] result() for MulticoreFuture ...
[16:20:48.687] plan(): Setting new future strategy stack:
[16:20:48.687] List of future strategies:
[16:20:48.687] 1. sequential:
[16:20:48.687]    - args: function (..., envir = parent.frame())
[16:20:48.687]    - tweaked: FALSE
[16:20:48.687]    - call: NULL
[16:20:48.688] plan(): nbrOfWorkers() = 1
[16:20:48.692] plan(): Setting new future strategy stack:
[16:20:48.693] List of future strategies:
[16:20:48.693] 1. multicore:
[16:20:48.693]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:48.693]    - tweaked: FALSE
[16:20:48.693]    - call: plan(strategy)
[16:20:48.698] plan(): nbrOfWorkers() = 2
[16:20:48.701] result() for MulticoreFuture ...
[16:20:48.701] result() for MulticoreFuture ... done
[16:20:48.701] result() for MulticoreFuture ... done
[16:20:48.701] result() for MulticoreFuture ...
[16:20:48.701] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[16:20:48.705] getGlobalsAndPackages() ...
[16:20:48.706] Searching for globals...
[16:20:48.708] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[16:20:48.709] Searching for globals ... DONE
[16:20:48.709] Resolving globals: FALSE
[16:20:48.709] 
[16:20:48.709] - packages: [2] ‘stats’, ‘datasets’
[16:20:48.710] getGlobalsAndPackages() ... DONE
[16:20:48.710] run() for ‘Future’ ...
[16:20:48.710] - state: ‘created’
[16:20:48.710] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:48.715] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:48.715] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:48.715]   - Field: ‘label’
[16:20:48.715]   - Field: ‘local’
[16:20:48.715]   - Field: ‘owner’
[16:20:48.715]   - Field: ‘envir’
[16:20:48.716]   - Field: ‘workers’
[16:20:48.716]   - Field: ‘packages’
[16:20:48.716]   - Field: ‘gc’
[16:20:48.716]   - Field: ‘job’
[16:20:48.716]   - Field: ‘conditions’
[16:20:48.716]   - Field: ‘expr’
[16:20:48.716]   - Field: ‘uuid’
[16:20:48.716]   - Field: ‘seed’
[16:20:48.717]   - Field: ‘version’
[16:20:48.717]   - Field: ‘result’
[16:20:48.717]   - Field: ‘asynchronous’
[16:20:48.717]   - Field: ‘calls’
[16:20:48.717]   - Field: ‘globals’
[16:20:48.717]   - Field: ‘stdout’
[16:20:48.717]   - Field: ‘earlySignal’
[16:20:48.717]   - Field: ‘lazy’
[16:20:48.718]   - Field: ‘state’
[16:20:48.718] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:48.718] - Launch lazy future ...
[16:20:48.718] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:20:48.718] Packages needed by future strategies (n = 0): <none>
[16:20:48.719] {
[16:20:48.719]     {
[16:20:48.719]         {
[16:20:48.719]             ...future.startTime <- base::Sys.time()
[16:20:48.719]             {
[16:20:48.719]                 {
[16:20:48.719]                   {
[16:20:48.719]                     {
[16:20:48.719]                       {
[16:20:48.719]                         base::local({
[16:20:48.719]                           has_future <- base::requireNamespace("future", 
[16:20:48.719]                             quietly = TRUE)
[16:20:48.719]                           if (has_future) {
[16:20:48.719]                             ns <- base::getNamespace("future")
[16:20:48.719]                             version <- ns[[".package"]][["version"]]
[16:20:48.719]                             if (is.null(version)) 
[16:20:48.719]                               version <- utils::packageVersion("future")
[16:20:48.719]                           }
[16:20:48.719]                           else {
[16:20:48.719]                             version <- NULL
[16:20:48.719]                           }
[16:20:48.719]                           if (!has_future || version < "1.8.0") {
[16:20:48.719]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.719]                               "", base::R.version$version.string), 
[16:20:48.719]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:48.719]                                 base::R.version$platform, 8 * 
[16:20:48.719]                                   base::.Machine$sizeof.pointer), 
[16:20:48.719]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.719]                                 "release", "version")], collapse = " "), 
[16:20:48.719]                               hostname = base::Sys.info()[["nodename"]])
[16:20:48.719]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.719]                               info)
[16:20:48.719]                             info <- base::paste(info, collapse = "; ")
[16:20:48.719]                             if (!has_future) {
[16:20:48.719]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.719]                                 info)
[16:20:48.719]                             }
[16:20:48.719]                             else {
[16:20:48.719]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.719]                                 info, version)
[16:20:48.719]                             }
[16:20:48.719]                             base::stop(msg)
[16:20:48.719]                           }
[16:20:48.719]                         })
[16:20:48.719]                       }
[16:20:48.719]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:48.719]                       base::options(mc.cores = 1L)
[16:20:48.719]                     }
[16:20:48.719]                     base::local({
[16:20:48.719]                       for (pkg in c("stats", "datasets")) {
[16:20:48.719]                         base::loadNamespace(pkg)
[16:20:48.719]                         base::library(pkg, character.only = TRUE)
[16:20:48.719]                       }
[16:20:48.719]                     })
[16:20:48.719]                   }
[16:20:48.719]                   ...future.strategy.old <- future::plan("list")
[16:20:48.719]                   options(future.plan = NULL)
[16:20:48.719]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.719]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.719]                 }
[16:20:48.719]                 ...future.workdir <- getwd()
[16:20:48.719]             }
[16:20:48.719]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.719]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.719]         }
[16:20:48.719]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.719]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.719]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.719]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.719]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.719]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.719]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.719]             base::names(...future.oldOptions))
[16:20:48.719]     }
[16:20:48.719]     if (FALSE) {
[16:20:48.719]     }
[16:20:48.719]     else {
[16:20:48.719]         if (TRUE) {
[16:20:48.719]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.719]                 open = "w")
[16:20:48.719]         }
[16:20:48.719]         else {
[16:20:48.719]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.719]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.719]         }
[16:20:48.719]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.719]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.719]             base::sink(type = "output", split = FALSE)
[16:20:48.719]             base::close(...future.stdout)
[16:20:48.719]         }, add = TRUE)
[16:20:48.719]     }
[16:20:48.719]     ...future.frame <- base::sys.nframe()
[16:20:48.719]     ...future.conditions <- base::list()
[16:20:48.719]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.719]     if (FALSE) {
[16:20:48.719]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.719]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.719]     }
[16:20:48.719]     ...future.result <- base::tryCatch({
[16:20:48.719]         base::withCallingHandlers({
[16:20:48.719]             ...future.value <- base::withVisible(base::local({
[16:20:48.719]                 withCallingHandlers({
[16:20:48.719]                   {
[16:20:48.719]                     lm(dist ~ speed + speed^2, data = cars)
[16:20:48.719]                   }
[16:20:48.719]                 }, immediateCondition = function(cond) {
[16:20:48.719]                   save_rds <- function (object, pathname, ...) 
[16:20:48.719]                   {
[16:20:48.719]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:48.719]                     if (file_test("-f", pathname_tmp)) {
[16:20:48.719]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.719]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:48.719]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.719]                         fi_tmp[["mtime"]])
[16:20:48.719]                     }
[16:20:48.719]                     tryCatch({
[16:20:48.719]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:48.719]                     }, error = function(ex) {
[16:20:48.719]                       msg <- conditionMessage(ex)
[16:20:48.719]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.719]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:48.719]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.719]                         fi_tmp[["mtime"]], msg)
[16:20:48.719]                       ex$message <- msg
[16:20:48.719]                       stop(ex)
[16:20:48.719]                     })
[16:20:48.719]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:48.719]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:48.719]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:48.719]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.719]                       fi <- file.info(pathname)
[16:20:48.719]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:48.719]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.719]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:48.719]                         fi[["size"]], fi[["mtime"]])
[16:20:48.719]                       stop(msg)
[16:20:48.719]                     }
[16:20:48.719]                     invisible(pathname)
[16:20:48.719]                   }
[16:20:48.719]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:48.719]                     rootPath = tempdir()) 
[16:20:48.719]                   {
[16:20:48.719]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:48.719]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:48.719]                       tmpdir = path, fileext = ".rds")
[16:20:48.719]                     save_rds(obj, file)
[16:20:48.719]                   }
[16:20:48.719]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4Mnhkl/.future/immediateConditions")
[16:20:48.719]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.719]                   {
[16:20:48.719]                     inherits <- base::inherits
[16:20:48.719]                     invokeRestart <- base::invokeRestart
[16:20:48.719]                     is.null <- base::is.null
[16:20:48.719]                     muffled <- FALSE
[16:20:48.719]                     if (inherits(cond, "message")) {
[16:20:48.719]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:48.719]                       if (muffled) 
[16:20:48.719]                         invokeRestart("muffleMessage")
[16:20:48.719]                     }
[16:20:48.719]                     else if (inherits(cond, "warning")) {
[16:20:48.719]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:48.719]                       if (muffled) 
[16:20:48.719]                         invokeRestart("muffleWarning")
[16:20:48.719]                     }
[16:20:48.719]                     else if (inherits(cond, "condition")) {
[16:20:48.719]                       if (!is.null(pattern)) {
[16:20:48.719]                         computeRestarts <- base::computeRestarts
[16:20:48.719]                         grepl <- base::grepl
[16:20:48.719]                         restarts <- computeRestarts(cond)
[16:20:48.719]                         for (restart in restarts) {
[16:20:48.719]                           name <- restart$name
[16:20:48.719]                           if (is.null(name)) 
[16:20:48.719]                             next
[16:20:48.719]                           if (!grepl(pattern, name)) 
[16:20:48.719]                             next
[16:20:48.719]                           invokeRestart(restart)
[16:20:48.719]                           muffled <- TRUE
[16:20:48.719]                           break
[16:20:48.719]                         }
[16:20:48.719]                       }
[16:20:48.719]                     }
[16:20:48.719]                     invisible(muffled)
[16:20:48.719]                   }
[16:20:48.719]                   muffleCondition(cond)
[16:20:48.719]                 })
[16:20:48.719]             }))
[16:20:48.719]             future::FutureResult(value = ...future.value$value, 
[16:20:48.719]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.719]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.719]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.719]                     ...future.globalenv.names))
[16:20:48.719]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.719]         }, condition = base::local({
[16:20:48.719]             c <- base::c
[16:20:48.719]             inherits <- base::inherits
[16:20:48.719]             invokeRestart <- base::invokeRestart
[16:20:48.719]             length <- base::length
[16:20:48.719]             list <- base::list
[16:20:48.719]             seq.int <- base::seq.int
[16:20:48.719]             signalCondition <- base::signalCondition
[16:20:48.719]             sys.calls <- base::sys.calls
[16:20:48.719]             `[[` <- base::`[[`
[16:20:48.719]             `+` <- base::`+`
[16:20:48.719]             `<<-` <- base::`<<-`
[16:20:48.719]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.719]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.719]                   3L)]
[16:20:48.719]             }
[16:20:48.719]             function(cond) {
[16:20:48.719]                 is_error <- inherits(cond, "error")
[16:20:48.719]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.719]                   NULL)
[16:20:48.719]                 if (is_error) {
[16:20:48.719]                   sessionInformation <- function() {
[16:20:48.719]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.719]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.719]                       search = base::search(), system = base::Sys.info())
[16:20:48.719]                   }
[16:20:48.719]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.719]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.719]                     cond$call), session = sessionInformation(), 
[16:20:48.719]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.719]                   signalCondition(cond)
[16:20:48.719]                 }
[16:20:48.719]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.719]                 "immediateCondition"))) {
[16:20:48.719]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.719]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.719]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.719]                   if (TRUE && !signal) {
[16:20:48.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.719]                     {
[16:20:48.719]                       inherits <- base::inherits
[16:20:48.719]                       invokeRestart <- base::invokeRestart
[16:20:48.719]                       is.null <- base::is.null
[16:20:48.719]                       muffled <- FALSE
[16:20:48.719]                       if (inherits(cond, "message")) {
[16:20:48.719]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.719]                         if (muffled) 
[16:20:48.719]                           invokeRestart("muffleMessage")
[16:20:48.719]                       }
[16:20:48.719]                       else if (inherits(cond, "warning")) {
[16:20:48.719]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.719]                         if (muffled) 
[16:20:48.719]                           invokeRestart("muffleWarning")
[16:20:48.719]                       }
[16:20:48.719]                       else if (inherits(cond, "condition")) {
[16:20:48.719]                         if (!is.null(pattern)) {
[16:20:48.719]                           computeRestarts <- base::computeRestarts
[16:20:48.719]                           grepl <- base::grepl
[16:20:48.719]                           restarts <- computeRestarts(cond)
[16:20:48.719]                           for (restart in restarts) {
[16:20:48.719]                             name <- restart$name
[16:20:48.719]                             if (is.null(name)) 
[16:20:48.719]                               next
[16:20:48.719]                             if (!grepl(pattern, name)) 
[16:20:48.719]                               next
[16:20:48.719]                             invokeRestart(restart)
[16:20:48.719]                             muffled <- TRUE
[16:20:48.719]                             break
[16:20:48.719]                           }
[16:20:48.719]                         }
[16:20:48.719]                       }
[16:20:48.719]                       invisible(muffled)
[16:20:48.719]                     }
[16:20:48.719]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.719]                   }
[16:20:48.719]                 }
[16:20:48.719]                 else {
[16:20:48.719]                   if (TRUE) {
[16:20:48.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.719]                     {
[16:20:48.719]                       inherits <- base::inherits
[16:20:48.719]                       invokeRestart <- base::invokeRestart
[16:20:48.719]                       is.null <- base::is.null
[16:20:48.719]                       muffled <- FALSE
[16:20:48.719]                       if (inherits(cond, "message")) {
[16:20:48.719]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.719]                         if (muffled) 
[16:20:48.719]                           invokeRestart("muffleMessage")
[16:20:48.719]                       }
[16:20:48.719]                       else if (inherits(cond, "warning")) {
[16:20:48.719]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.719]                         if (muffled) 
[16:20:48.719]                           invokeRestart("muffleWarning")
[16:20:48.719]                       }
[16:20:48.719]                       else if (inherits(cond, "condition")) {
[16:20:48.719]                         if (!is.null(pattern)) {
[16:20:48.719]                           computeRestarts <- base::computeRestarts
[16:20:48.719]                           grepl <- base::grepl
[16:20:48.719]                           restarts <- computeRestarts(cond)
[16:20:48.719]                           for (restart in restarts) {
[16:20:48.719]                             name <- restart$name
[16:20:48.719]                             if (is.null(name)) 
[16:20:48.719]                               next
[16:20:48.719]                             if (!grepl(pattern, name)) 
[16:20:48.719]                               next
[16:20:48.719]                             invokeRestart(restart)
[16:20:48.719]                             muffled <- TRUE
[16:20:48.719]                             break
[16:20:48.719]                           }
[16:20:48.719]                         }
[16:20:48.719]                       }
[16:20:48.719]                       invisible(muffled)
[16:20:48.719]                     }
[16:20:48.719]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.719]                   }
[16:20:48.719]                 }
[16:20:48.719]             }
[16:20:48.719]         }))
[16:20:48.719]     }, error = function(ex) {
[16:20:48.719]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.719]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.719]                 ...future.rng), started = ...future.startTime, 
[16:20:48.719]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.719]             version = "1.8"), class = "FutureResult")
[16:20:48.719]     }, finally = {
[16:20:48.719]         if (!identical(...future.workdir, getwd())) 
[16:20:48.719]             setwd(...future.workdir)
[16:20:48.719]         {
[16:20:48.719]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.719]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.719]             }
[16:20:48.719]             base::options(...future.oldOptions)
[16:20:48.719]             if (.Platform$OS.type == "windows") {
[16:20:48.719]                 old_names <- names(...future.oldEnvVars)
[16:20:48.719]                 envs <- base::Sys.getenv()
[16:20:48.719]                 names <- names(envs)
[16:20:48.719]                 common <- intersect(names, old_names)
[16:20:48.719]                 added <- setdiff(names, old_names)
[16:20:48.719]                 removed <- setdiff(old_names, names)
[16:20:48.719]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.719]                   envs[common]]
[16:20:48.719]                 NAMES <- toupper(changed)
[16:20:48.719]                 args <- list()
[16:20:48.719]                 for (kk in seq_along(NAMES)) {
[16:20:48.719]                   name <- changed[[kk]]
[16:20:48.719]                   NAME <- NAMES[[kk]]
[16:20:48.719]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.719]                     next
[16:20:48.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.719]                 }
[16:20:48.719]                 NAMES <- toupper(added)
[16:20:48.719]                 for (kk in seq_along(NAMES)) {
[16:20:48.719]                   name <- added[[kk]]
[16:20:48.719]                   NAME <- NAMES[[kk]]
[16:20:48.719]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.719]                     next
[16:20:48.719]                   args[[name]] <- ""
[16:20:48.719]                 }
[16:20:48.719]                 NAMES <- toupper(removed)
[16:20:48.719]                 for (kk in seq_along(NAMES)) {
[16:20:48.719]                   name <- removed[[kk]]
[16:20:48.719]                   NAME <- NAMES[[kk]]
[16:20:48.719]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.719]                     next
[16:20:48.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.719]                 }
[16:20:48.719]                 if (length(args) > 0) 
[16:20:48.719]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.719]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.719]             }
[16:20:48.719]             else {
[16:20:48.719]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.719]             }
[16:20:48.719]             {
[16:20:48.719]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.719]                   0L) {
[16:20:48.719]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.719]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.719]                   base::options(opts)
[16:20:48.719]                 }
[16:20:48.719]                 {
[16:20:48.719]                   {
[16:20:48.719]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:48.719]                     NULL
[16:20:48.719]                   }
[16:20:48.719]                   options(future.plan = NULL)
[16:20:48.719]                   if (is.na(NA_character_)) 
[16:20:48.719]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.719]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.719]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.719]                     .init = FALSE)
[16:20:48.719]                 }
[16:20:48.719]             }
[16:20:48.719]         }
[16:20:48.719]     })
[16:20:48.719]     if (TRUE) {
[16:20:48.719]         base::sink(type = "output", split = FALSE)
[16:20:48.719]         if (TRUE) {
[16:20:48.719]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.719]         }
[16:20:48.719]         else {
[16:20:48.719]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.719]         }
[16:20:48.719]         base::close(...future.stdout)
[16:20:48.719]         ...future.stdout <- NULL
[16:20:48.719]     }
[16:20:48.719]     ...future.result$conditions <- ...future.conditions
[16:20:48.719]     ...future.result$finished <- base::Sys.time()
[16:20:48.719]     ...future.result
[16:20:48.719] }
[16:20:48.722] requestCore(): workers = 2
[16:20:48.724] MulticoreFuture started
[16:20:48.724] - Launch lazy future ... done
[16:20:48.725] run() for ‘MulticoreFuture’ ... done
[16:20:48.725] result() for MulticoreFuture ...
[16:20:48.726] plan(): Setting new future strategy stack:
[16:20:48.726] List of future strategies:
[16:20:48.726] 1. sequential:
[16:20:48.726]    - args: function (..., envir = parent.frame())
[16:20:48.726]    - tweaked: FALSE
[16:20:48.726]    - call: NULL
[16:20:48.727] plan(): nbrOfWorkers() = 1
[16:20:48.731] plan(): Setting new future strategy stack:
[16:20:48.731] List of future strategies:
[16:20:48.731] 1. multicore:
[16:20:48.731]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:48.731]    - tweaked: FALSE
[16:20:48.731]    - call: plan(strategy)
[16:20:48.736] plan(): nbrOfWorkers() = 2
[16:20:48.738] result() for MulticoreFuture ...
[16:20:48.738] result() for MulticoreFuture ... done
[16:20:48.738] result() for MulticoreFuture ... done
[16:20:48.738] result() for MulticoreFuture ...
[16:20:48.739] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[16:20:48.742] getGlobalsAndPackages() ...
[16:20:48.743] Searching for globals...
[16:20:48.749] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[16:20:48.749] Searching for globals ... DONE
[16:20:48.749] Resolving globals: FALSE
[16:20:48.750] 
[16:20:48.750] - packages: [2] ‘stats’, ‘datasets’
[16:20:48.751] getGlobalsAndPackages() ... DONE
[16:20:48.751] run() for ‘Future’ ...
[16:20:48.751] - state: ‘created’
[16:20:48.752] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:48.756] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:48.756] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:48.756]   - Field: ‘label’
[16:20:48.757]   - Field: ‘local’
[16:20:48.757]   - Field: ‘owner’
[16:20:48.757]   - Field: ‘envir’
[16:20:48.757]   - Field: ‘workers’
[16:20:48.757]   - Field: ‘packages’
[16:20:48.757]   - Field: ‘gc’
[16:20:48.757]   - Field: ‘job’
[16:20:48.757]   - Field: ‘conditions’
[16:20:48.758]   - Field: ‘expr’
[16:20:48.758]   - Field: ‘uuid’
[16:20:48.758]   - Field: ‘seed’
[16:20:48.758]   - Field: ‘version’
[16:20:48.758]   - Field: ‘result’
[16:20:48.758]   - Field: ‘asynchronous’
[16:20:48.758]   - Field: ‘calls’
[16:20:48.758]   - Field: ‘globals’
[16:20:48.758]   - Field: ‘stdout’
[16:20:48.759]   - Field: ‘earlySignal’
[16:20:48.759]   - Field: ‘lazy’
[16:20:48.759]   - Field: ‘state’
[16:20:48.759] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:48.759] - Launch lazy future ...
[16:20:48.760] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:20:48.760] Packages needed by future strategies (n = 0): <none>
[16:20:48.760] {
[16:20:48.760]     {
[16:20:48.760]         {
[16:20:48.760]             ...future.startTime <- base::Sys.time()
[16:20:48.760]             {
[16:20:48.760]                 {
[16:20:48.760]                   {
[16:20:48.760]                     {
[16:20:48.760]                       {
[16:20:48.760]                         base::local({
[16:20:48.760]                           has_future <- base::requireNamespace("future", 
[16:20:48.760]                             quietly = TRUE)
[16:20:48.760]                           if (has_future) {
[16:20:48.760]                             ns <- base::getNamespace("future")
[16:20:48.760]                             version <- ns[[".package"]][["version"]]
[16:20:48.760]                             if (is.null(version)) 
[16:20:48.760]                               version <- utils::packageVersion("future")
[16:20:48.760]                           }
[16:20:48.760]                           else {
[16:20:48.760]                             version <- NULL
[16:20:48.760]                           }
[16:20:48.760]                           if (!has_future || version < "1.8.0") {
[16:20:48.760]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.760]                               "", base::R.version$version.string), 
[16:20:48.760]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:48.760]                                 base::R.version$platform, 8 * 
[16:20:48.760]                                   base::.Machine$sizeof.pointer), 
[16:20:48.760]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.760]                                 "release", "version")], collapse = " "), 
[16:20:48.760]                               hostname = base::Sys.info()[["nodename"]])
[16:20:48.760]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.760]                               info)
[16:20:48.760]                             info <- base::paste(info, collapse = "; ")
[16:20:48.760]                             if (!has_future) {
[16:20:48.760]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.760]                                 info)
[16:20:48.760]                             }
[16:20:48.760]                             else {
[16:20:48.760]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.760]                                 info, version)
[16:20:48.760]                             }
[16:20:48.760]                             base::stop(msg)
[16:20:48.760]                           }
[16:20:48.760]                         })
[16:20:48.760]                       }
[16:20:48.760]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:48.760]                       base::options(mc.cores = 1L)
[16:20:48.760]                     }
[16:20:48.760]                     base::local({
[16:20:48.760]                       for (pkg in c("stats", "datasets")) {
[16:20:48.760]                         base::loadNamespace(pkg)
[16:20:48.760]                         base::library(pkg, character.only = TRUE)
[16:20:48.760]                       }
[16:20:48.760]                     })
[16:20:48.760]                   }
[16:20:48.760]                   ...future.strategy.old <- future::plan("list")
[16:20:48.760]                   options(future.plan = NULL)
[16:20:48.760]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.760]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.760]                 }
[16:20:48.760]                 ...future.workdir <- getwd()
[16:20:48.760]             }
[16:20:48.760]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.760]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.760]         }
[16:20:48.760]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.760]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.760]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.760]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.760]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.760]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.760]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.760]             base::names(...future.oldOptions))
[16:20:48.760]     }
[16:20:48.760]     if (FALSE) {
[16:20:48.760]     }
[16:20:48.760]     else {
[16:20:48.760]         if (TRUE) {
[16:20:48.760]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.760]                 open = "w")
[16:20:48.760]         }
[16:20:48.760]         else {
[16:20:48.760]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.760]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.760]         }
[16:20:48.760]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.760]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.760]             base::sink(type = "output", split = FALSE)
[16:20:48.760]             base::close(...future.stdout)
[16:20:48.760]         }, add = TRUE)
[16:20:48.760]     }
[16:20:48.760]     ...future.frame <- base::sys.nframe()
[16:20:48.760]     ...future.conditions <- base::list()
[16:20:48.760]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.760]     if (FALSE) {
[16:20:48.760]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.760]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.760]     }
[16:20:48.760]     ...future.result <- base::tryCatch({
[16:20:48.760]         base::withCallingHandlers({
[16:20:48.760]             ...future.value <- base::withVisible(base::local({
[16:20:48.760]                 withCallingHandlers({
[16:20:48.760]                   {
[16:20:48.760]                     lm(dist ~ speed + I(speed^2), data = cars)
[16:20:48.760]                   }
[16:20:48.760]                 }, immediateCondition = function(cond) {
[16:20:48.760]                   save_rds <- function (object, pathname, ...) 
[16:20:48.760]                   {
[16:20:48.760]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:48.760]                     if (file_test("-f", pathname_tmp)) {
[16:20:48.760]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.760]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:48.760]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.760]                         fi_tmp[["mtime"]])
[16:20:48.760]                     }
[16:20:48.760]                     tryCatch({
[16:20:48.760]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:48.760]                     }, error = function(ex) {
[16:20:48.760]                       msg <- conditionMessage(ex)
[16:20:48.760]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.760]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:48.760]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.760]                         fi_tmp[["mtime"]], msg)
[16:20:48.760]                       ex$message <- msg
[16:20:48.760]                       stop(ex)
[16:20:48.760]                     })
[16:20:48.760]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:48.760]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:48.760]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:48.760]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.760]                       fi <- file.info(pathname)
[16:20:48.760]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:48.760]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.760]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:48.760]                         fi[["size"]], fi[["mtime"]])
[16:20:48.760]                       stop(msg)
[16:20:48.760]                     }
[16:20:48.760]                     invisible(pathname)
[16:20:48.760]                   }
[16:20:48.760]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:48.760]                     rootPath = tempdir()) 
[16:20:48.760]                   {
[16:20:48.760]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:48.760]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:48.760]                       tmpdir = path, fileext = ".rds")
[16:20:48.760]                     save_rds(obj, file)
[16:20:48.760]                   }
[16:20:48.760]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4Mnhkl/.future/immediateConditions")
[16:20:48.760]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.760]                   {
[16:20:48.760]                     inherits <- base::inherits
[16:20:48.760]                     invokeRestart <- base::invokeRestart
[16:20:48.760]                     is.null <- base::is.null
[16:20:48.760]                     muffled <- FALSE
[16:20:48.760]                     if (inherits(cond, "message")) {
[16:20:48.760]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:48.760]                       if (muffled) 
[16:20:48.760]                         invokeRestart("muffleMessage")
[16:20:48.760]                     }
[16:20:48.760]                     else if (inherits(cond, "warning")) {
[16:20:48.760]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:48.760]                       if (muffled) 
[16:20:48.760]                         invokeRestart("muffleWarning")
[16:20:48.760]                     }
[16:20:48.760]                     else if (inherits(cond, "condition")) {
[16:20:48.760]                       if (!is.null(pattern)) {
[16:20:48.760]                         computeRestarts <- base::computeRestarts
[16:20:48.760]                         grepl <- base::grepl
[16:20:48.760]                         restarts <- computeRestarts(cond)
[16:20:48.760]                         for (restart in restarts) {
[16:20:48.760]                           name <- restart$name
[16:20:48.760]                           if (is.null(name)) 
[16:20:48.760]                             next
[16:20:48.760]                           if (!grepl(pattern, name)) 
[16:20:48.760]                             next
[16:20:48.760]                           invokeRestart(restart)
[16:20:48.760]                           muffled <- TRUE
[16:20:48.760]                           break
[16:20:48.760]                         }
[16:20:48.760]                       }
[16:20:48.760]                     }
[16:20:48.760]                     invisible(muffled)
[16:20:48.760]                   }
[16:20:48.760]                   muffleCondition(cond)
[16:20:48.760]                 })
[16:20:48.760]             }))
[16:20:48.760]             future::FutureResult(value = ...future.value$value, 
[16:20:48.760]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.760]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.760]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.760]                     ...future.globalenv.names))
[16:20:48.760]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.760]         }, condition = base::local({
[16:20:48.760]             c <- base::c
[16:20:48.760]             inherits <- base::inherits
[16:20:48.760]             invokeRestart <- base::invokeRestart
[16:20:48.760]             length <- base::length
[16:20:48.760]             list <- base::list
[16:20:48.760]             seq.int <- base::seq.int
[16:20:48.760]             signalCondition <- base::signalCondition
[16:20:48.760]             sys.calls <- base::sys.calls
[16:20:48.760]             `[[` <- base::`[[`
[16:20:48.760]             `+` <- base::`+`
[16:20:48.760]             `<<-` <- base::`<<-`
[16:20:48.760]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.760]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.760]                   3L)]
[16:20:48.760]             }
[16:20:48.760]             function(cond) {
[16:20:48.760]                 is_error <- inherits(cond, "error")
[16:20:48.760]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.760]                   NULL)
[16:20:48.760]                 if (is_error) {
[16:20:48.760]                   sessionInformation <- function() {
[16:20:48.760]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.760]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.760]                       search = base::search(), system = base::Sys.info())
[16:20:48.760]                   }
[16:20:48.760]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.760]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.760]                     cond$call), session = sessionInformation(), 
[16:20:48.760]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.760]                   signalCondition(cond)
[16:20:48.760]                 }
[16:20:48.760]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.760]                 "immediateCondition"))) {
[16:20:48.760]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.760]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.760]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.760]                   if (TRUE && !signal) {
[16:20:48.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.760]                     {
[16:20:48.760]                       inherits <- base::inherits
[16:20:48.760]                       invokeRestart <- base::invokeRestart
[16:20:48.760]                       is.null <- base::is.null
[16:20:48.760]                       muffled <- FALSE
[16:20:48.760]                       if (inherits(cond, "message")) {
[16:20:48.760]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.760]                         if (muffled) 
[16:20:48.760]                           invokeRestart("muffleMessage")
[16:20:48.760]                       }
[16:20:48.760]                       else if (inherits(cond, "warning")) {
[16:20:48.760]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.760]                         if (muffled) 
[16:20:48.760]                           invokeRestart("muffleWarning")
[16:20:48.760]                       }
[16:20:48.760]                       else if (inherits(cond, "condition")) {
[16:20:48.760]                         if (!is.null(pattern)) {
[16:20:48.760]                           computeRestarts <- base::computeRestarts
[16:20:48.760]                           grepl <- base::grepl
[16:20:48.760]                           restarts <- computeRestarts(cond)
[16:20:48.760]                           for (restart in restarts) {
[16:20:48.760]                             name <- restart$name
[16:20:48.760]                             if (is.null(name)) 
[16:20:48.760]                               next
[16:20:48.760]                             if (!grepl(pattern, name)) 
[16:20:48.760]                               next
[16:20:48.760]                             invokeRestart(restart)
[16:20:48.760]                             muffled <- TRUE
[16:20:48.760]                             break
[16:20:48.760]                           }
[16:20:48.760]                         }
[16:20:48.760]                       }
[16:20:48.760]                       invisible(muffled)
[16:20:48.760]                     }
[16:20:48.760]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.760]                   }
[16:20:48.760]                 }
[16:20:48.760]                 else {
[16:20:48.760]                   if (TRUE) {
[16:20:48.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.760]                     {
[16:20:48.760]                       inherits <- base::inherits
[16:20:48.760]                       invokeRestart <- base::invokeRestart
[16:20:48.760]                       is.null <- base::is.null
[16:20:48.760]                       muffled <- FALSE
[16:20:48.760]                       if (inherits(cond, "message")) {
[16:20:48.760]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.760]                         if (muffled) 
[16:20:48.760]                           invokeRestart("muffleMessage")
[16:20:48.760]                       }
[16:20:48.760]                       else if (inherits(cond, "warning")) {
[16:20:48.760]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.760]                         if (muffled) 
[16:20:48.760]                           invokeRestart("muffleWarning")
[16:20:48.760]                       }
[16:20:48.760]                       else if (inherits(cond, "condition")) {
[16:20:48.760]                         if (!is.null(pattern)) {
[16:20:48.760]                           computeRestarts <- base::computeRestarts
[16:20:48.760]                           grepl <- base::grepl
[16:20:48.760]                           restarts <- computeRestarts(cond)
[16:20:48.760]                           for (restart in restarts) {
[16:20:48.760]                             name <- restart$name
[16:20:48.760]                             if (is.null(name)) 
[16:20:48.760]                               next
[16:20:48.760]                             if (!grepl(pattern, name)) 
[16:20:48.760]                               next
[16:20:48.760]                             invokeRestart(restart)
[16:20:48.760]                             muffled <- TRUE
[16:20:48.760]                             break
[16:20:48.760]                           }
[16:20:48.760]                         }
[16:20:48.760]                       }
[16:20:48.760]                       invisible(muffled)
[16:20:48.760]                     }
[16:20:48.760]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.760]                   }
[16:20:48.760]                 }
[16:20:48.760]             }
[16:20:48.760]         }))
[16:20:48.760]     }, error = function(ex) {
[16:20:48.760]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.760]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.760]                 ...future.rng), started = ...future.startTime, 
[16:20:48.760]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.760]             version = "1.8"), class = "FutureResult")
[16:20:48.760]     }, finally = {
[16:20:48.760]         if (!identical(...future.workdir, getwd())) 
[16:20:48.760]             setwd(...future.workdir)
[16:20:48.760]         {
[16:20:48.760]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.760]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.760]             }
[16:20:48.760]             base::options(...future.oldOptions)
[16:20:48.760]             if (.Platform$OS.type == "windows") {
[16:20:48.760]                 old_names <- names(...future.oldEnvVars)
[16:20:48.760]                 envs <- base::Sys.getenv()
[16:20:48.760]                 names <- names(envs)
[16:20:48.760]                 common <- intersect(names, old_names)
[16:20:48.760]                 added <- setdiff(names, old_names)
[16:20:48.760]                 removed <- setdiff(old_names, names)
[16:20:48.760]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.760]                   envs[common]]
[16:20:48.760]                 NAMES <- toupper(changed)
[16:20:48.760]                 args <- list()
[16:20:48.760]                 for (kk in seq_along(NAMES)) {
[16:20:48.760]                   name <- changed[[kk]]
[16:20:48.760]                   NAME <- NAMES[[kk]]
[16:20:48.760]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.760]                     next
[16:20:48.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.760]                 }
[16:20:48.760]                 NAMES <- toupper(added)
[16:20:48.760]                 for (kk in seq_along(NAMES)) {
[16:20:48.760]                   name <- added[[kk]]
[16:20:48.760]                   NAME <- NAMES[[kk]]
[16:20:48.760]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.760]                     next
[16:20:48.760]                   args[[name]] <- ""
[16:20:48.760]                 }
[16:20:48.760]                 NAMES <- toupper(removed)
[16:20:48.760]                 for (kk in seq_along(NAMES)) {
[16:20:48.760]                   name <- removed[[kk]]
[16:20:48.760]                   NAME <- NAMES[[kk]]
[16:20:48.760]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.760]                     next
[16:20:48.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.760]                 }
[16:20:48.760]                 if (length(args) > 0) 
[16:20:48.760]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.760]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.760]             }
[16:20:48.760]             else {
[16:20:48.760]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.760]             }
[16:20:48.760]             {
[16:20:48.760]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.760]                   0L) {
[16:20:48.760]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.760]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.760]                   base::options(opts)
[16:20:48.760]                 }
[16:20:48.760]                 {
[16:20:48.760]                   {
[16:20:48.760]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:48.760]                     NULL
[16:20:48.760]                   }
[16:20:48.760]                   options(future.plan = NULL)
[16:20:48.760]                   if (is.na(NA_character_)) 
[16:20:48.760]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.760]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.760]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.760]                     .init = FALSE)
[16:20:48.760]                 }
[16:20:48.760]             }
[16:20:48.760]         }
[16:20:48.760]     })
[16:20:48.760]     if (TRUE) {
[16:20:48.760]         base::sink(type = "output", split = FALSE)
[16:20:48.760]         if (TRUE) {
[16:20:48.760]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.760]         }
[16:20:48.760]         else {
[16:20:48.760]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.760]         }
[16:20:48.760]         base::close(...future.stdout)
[16:20:48.760]         ...future.stdout <- NULL
[16:20:48.760]     }
[16:20:48.760]     ...future.result$conditions <- ...future.conditions
[16:20:48.760]     ...future.result$finished <- base::Sys.time()
[16:20:48.760]     ...future.result
[16:20:48.760] }
[16:20:48.763] requestCore(): workers = 2
[16:20:48.765] MulticoreFuture started
[16:20:48.766] - Launch lazy future ... done
[16:20:48.766] run() for ‘MulticoreFuture’ ... done
[16:20:48.766] result() for MulticoreFuture ...
[16:20:48.767] plan(): Setting new future strategy stack:
[16:20:48.767] List of future strategies:
[16:20:48.767] 1. sequential:
[16:20:48.767]    - args: function (..., envir = parent.frame())
[16:20:48.767]    - tweaked: FALSE
[16:20:48.767]    - call: NULL
[16:20:48.768] plan(): nbrOfWorkers() = 1
[16:20:48.772] plan(): Setting new future strategy stack:
[16:20:48.773] List of future strategies:
[16:20:48.773] 1. multicore:
[16:20:48.773]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:48.773]    - tweaked: FALSE
[16:20:48.773]    - call: plan(strategy)
[16:20:48.778] plan(): nbrOfWorkers() = 2
[16:20:48.781] result() for MulticoreFuture ...
[16:20:48.781] result() for MulticoreFuture ... done
[16:20:48.781] result() for MulticoreFuture ... done
[16:20:48.781] result() for MulticoreFuture ...
[16:20:48.781] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[16:20:48.786] getGlobalsAndPackages() ...
[16:20:48.786] Searching for globals...
[16:20:48.788] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[16:20:48.788] Searching for globals ... DONE
[16:20:48.788] Resolving globals: FALSE
[16:20:48.789] 
[16:20:48.789] - packages: [2] ‘stats’, ‘datasets’
[16:20:48.789] getGlobalsAndPackages() ... DONE
[16:20:48.790] run() for ‘Future’ ...
[16:20:48.790] - state: ‘created’
[16:20:48.790] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:48.794] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:48.794] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:48.795]   - Field: ‘label’
[16:20:48.795]   - Field: ‘local’
[16:20:48.795]   - Field: ‘owner’
[16:20:48.795]   - Field: ‘envir’
[16:20:48.795]   - Field: ‘workers’
[16:20:48.795]   - Field: ‘packages’
[16:20:48.795]   - Field: ‘gc’
[16:20:48.795]   - Field: ‘job’
[16:20:48.796]   - Field: ‘conditions’
[16:20:48.796]   - Field: ‘expr’
[16:20:48.796]   - Field: ‘uuid’
[16:20:48.796]   - Field: ‘seed’
[16:20:48.796]   - Field: ‘version’
[16:20:48.796]   - Field: ‘result’
[16:20:48.796]   - Field: ‘asynchronous’
[16:20:48.796]   - Field: ‘calls’
[16:20:48.796]   - Field: ‘globals’
[16:20:48.797]   - Field: ‘stdout’
[16:20:48.797]   - Field: ‘earlySignal’
[16:20:48.797]   - Field: ‘lazy’
[16:20:48.797]   - Field: ‘state’
[16:20:48.797] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:48.797] - Launch lazy future ...
[16:20:48.798] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:20:48.798] Packages needed by future strategies (n = 0): <none>
[16:20:48.798] {
[16:20:48.798]     {
[16:20:48.798]         {
[16:20:48.798]             ...future.startTime <- base::Sys.time()
[16:20:48.798]             {
[16:20:48.798]                 {
[16:20:48.798]                   {
[16:20:48.798]                     {
[16:20:48.798]                       {
[16:20:48.798]                         base::local({
[16:20:48.798]                           has_future <- base::requireNamespace("future", 
[16:20:48.798]                             quietly = TRUE)
[16:20:48.798]                           if (has_future) {
[16:20:48.798]                             ns <- base::getNamespace("future")
[16:20:48.798]                             version <- ns[[".package"]][["version"]]
[16:20:48.798]                             if (is.null(version)) 
[16:20:48.798]                               version <- utils::packageVersion("future")
[16:20:48.798]                           }
[16:20:48.798]                           else {
[16:20:48.798]                             version <- NULL
[16:20:48.798]                           }
[16:20:48.798]                           if (!has_future || version < "1.8.0") {
[16:20:48.798]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.798]                               "", base::R.version$version.string), 
[16:20:48.798]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:48.798]                                 base::R.version$platform, 8 * 
[16:20:48.798]                                   base::.Machine$sizeof.pointer), 
[16:20:48.798]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.798]                                 "release", "version")], collapse = " "), 
[16:20:48.798]                               hostname = base::Sys.info()[["nodename"]])
[16:20:48.798]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.798]                               info)
[16:20:48.798]                             info <- base::paste(info, collapse = "; ")
[16:20:48.798]                             if (!has_future) {
[16:20:48.798]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.798]                                 info)
[16:20:48.798]                             }
[16:20:48.798]                             else {
[16:20:48.798]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.798]                                 info, version)
[16:20:48.798]                             }
[16:20:48.798]                             base::stop(msg)
[16:20:48.798]                           }
[16:20:48.798]                         })
[16:20:48.798]                       }
[16:20:48.798]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:48.798]                       base::options(mc.cores = 1L)
[16:20:48.798]                     }
[16:20:48.798]                     base::local({
[16:20:48.798]                       for (pkg in c("stats", "datasets")) {
[16:20:48.798]                         base::loadNamespace(pkg)
[16:20:48.798]                         base::library(pkg, character.only = TRUE)
[16:20:48.798]                       }
[16:20:48.798]                     })
[16:20:48.798]                   }
[16:20:48.798]                   ...future.strategy.old <- future::plan("list")
[16:20:48.798]                   options(future.plan = NULL)
[16:20:48.798]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.798]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.798]                 }
[16:20:48.798]                 ...future.workdir <- getwd()
[16:20:48.798]             }
[16:20:48.798]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.798]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.798]         }
[16:20:48.798]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.798]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.798]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.798]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.798]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.798]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.798]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.798]             base::names(...future.oldOptions))
[16:20:48.798]     }
[16:20:48.798]     if (FALSE) {
[16:20:48.798]     }
[16:20:48.798]     else {
[16:20:48.798]         if (TRUE) {
[16:20:48.798]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.798]                 open = "w")
[16:20:48.798]         }
[16:20:48.798]         else {
[16:20:48.798]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.798]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.798]         }
[16:20:48.798]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.798]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.798]             base::sink(type = "output", split = FALSE)
[16:20:48.798]             base::close(...future.stdout)
[16:20:48.798]         }, add = TRUE)
[16:20:48.798]     }
[16:20:48.798]     ...future.frame <- base::sys.nframe()
[16:20:48.798]     ...future.conditions <- base::list()
[16:20:48.798]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.798]     if (FALSE) {
[16:20:48.798]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.798]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.798]     }
[16:20:48.798]     ...future.result <- base::tryCatch({
[16:20:48.798]         base::withCallingHandlers({
[16:20:48.798]             ...future.value <- base::withVisible(base::local({
[16:20:48.798]                 withCallingHandlers({
[16:20:48.798]                   {
[16:20:48.798]                     lm(dist ~ poly(speed, 2), data = cars)
[16:20:48.798]                   }
[16:20:48.798]                 }, immediateCondition = function(cond) {
[16:20:48.798]                   save_rds <- function (object, pathname, ...) 
[16:20:48.798]                   {
[16:20:48.798]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:48.798]                     if (file_test("-f", pathname_tmp)) {
[16:20:48.798]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.798]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:48.798]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.798]                         fi_tmp[["mtime"]])
[16:20:48.798]                     }
[16:20:48.798]                     tryCatch({
[16:20:48.798]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:48.798]                     }, error = function(ex) {
[16:20:48.798]                       msg <- conditionMessage(ex)
[16:20:48.798]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.798]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:48.798]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.798]                         fi_tmp[["mtime"]], msg)
[16:20:48.798]                       ex$message <- msg
[16:20:48.798]                       stop(ex)
[16:20:48.798]                     })
[16:20:48.798]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:48.798]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:48.798]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:48.798]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.798]                       fi <- file.info(pathname)
[16:20:48.798]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:48.798]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.798]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:48.798]                         fi[["size"]], fi[["mtime"]])
[16:20:48.798]                       stop(msg)
[16:20:48.798]                     }
[16:20:48.798]                     invisible(pathname)
[16:20:48.798]                   }
[16:20:48.798]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:48.798]                     rootPath = tempdir()) 
[16:20:48.798]                   {
[16:20:48.798]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:48.798]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:48.798]                       tmpdir = path, fileext = ".rds")
[16:20:48.798]                     save_rds(obj, file)
[16:20:48.798]                   }
[16:20:48.798]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4Mnhkl/.future/immediateConditions")
[16:20:48.798]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.798]                   {
[16:20:48.798]                     inherits <- base::inherits
[16:20:48.798]                     invokeRestart <- base::invokeRestart
[16:20:48.798]                     is.null <- base::is.null
[16:20:48.798]                     muffled <- FALSE
[16:20:48.798]                     if (inherits(cond, "message")) {
[16:20:48.798]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:48.798]                       if (muffled) 
[16:20:48.798]                         invokeRestart("muffleMessage")
[16:20:48.798]                     }
[16:20:48.798]                     else if (inherits(cond, "warning")) {
[16:20:48.798]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:48.798]                       if (muffled) 
[16:20:48.798]                         invokeRestart("muffleWarning")
[16:20:48.798]                     }
[16:20:48.798]                     else if (inherits(cond, "condition")) {
[16:20:48.798]                       if (!is.null(pattern)) {
[16:20:48.798]                         computeRestarts <- base::computeRestarts
[16:20:48.798]                         grepl <- base::grepl
[16:20:48.798]                         restarts <- computeRestarts(cond)
[16:20:48.798]                         for (restart in restarts) {
[16:20:48.798]                           name <- restart$name
[16:20:48.798]                           if (is.null(name)) 
[16:20:48.798]                             next
[16:20:48.798]                           if (!grepl(pattern, name)) 
[16:20:48.798]                             next
[16:20:48.798]                           invokeRestart(restart)
[16:20:48.798]                           muffled <- TRUE
[16:20:48.798]                           break
[16:20:48.798]                         }
[16:20:48.798]                       }
[16:20:48.798]                     }
[16:20:48.798]                     invisible(muffled)
[16:20:48.798]                   }
[16:20:48.798]                   muffleCondition(cond)
[16:20:48.798]                 })
[16:20:48.798]             }))
[16:20:48.798]             future::FutureResult(value = ...future.value$value, 
[16:20:48.798]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.798]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.798]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.798]                     ...future.globalenv.names))
[16:20:48.798]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.798]         }, condition = base::local({
[16:20:48.798]             c <- base::c
[16:20:48.798]             inherits <- base::inherits
[16:20:48.798]             invokeRestart <- base::invokeRestart
[16:20:48.798]             length <- base::length
[16:20:48.798]             list <- base::list
[16:20:48.798]             seq.int <- base::seq.int
[16:20:48.798]             signalCondition <- base::signalCondition
[16:20:48.798]             sys.calls <- base::sys.calls
[16:20:48.798]             `[[` <- base::`[[`
[16:20:48.798]             `+` <- base::`+`
[16:20:48.798]             `<<-` <- base::`<<-`
[16:20:48.798]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.798]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.798]                   3L)]
[16:20:48.798]             }
[16:20:48.798]             function(cond) {
[16:20:48.798]                 is_error <- inherits(cond, "error")
[16:20:48.798]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.798]                   NULL)
[16:20:48.798]                 if (is_error) {
[16:20:48.798]                   sessionInformation <- function() {
[16:20:48.798]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.798]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.798]                       search = base::search(), system = base::Sys.info())
[16:20:48.798]                   }
[16:20:48.798]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.798]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.798]                     cond$call), session = sessionInformation(), 
[16:20:48.798]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.798]                   signalCondition(cond)
[16:20:48.798]                 }
[16:20:48.798]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.798]                 "immediateCondition"))) {
[16:20:48.798]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.798]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.798]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.798]                   if (TRUE && !signal) {
[16:20:48.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.798]                     {
[16:20:48.798]                       inherits <- base::inherits
[16:20:48.798]                       invokeRestart <- base::invokeRestart
[16:20:48.798]                       is.null <- base::is.null
[16:20:48.798]                       muffled <- FALSE
[16:20:48.798]                       if (inherits(cond, "message")) {
[16:20:48.798]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.798]                         if (muffled) 
[16:20:48.798]                           invokeRestart("muffleMessage")
[16:20:48.798]                       }
[16:20:48.798]                       else if (inherits(cond, "warning")) {
[16:20:48.798]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.798]                         if (muffled) 
[16:20:48.798]                           invokeRestart("muffleWarning")
[16:20:48.798]                       }
[16:20:48.798]                       else if (inherits(cond, "condition")) {
[16:20:48.798]                         if (!is.null(pattern)) {
[16:20:48.798]                           computeRestarts <- base::computeRestarts
[16:20:48.798]                           grepl <- base::grepl
[16:20:48.798]                           restarts <- computeRestarts(cond)
[16:20:48.798]                           for (restart in restarts) {
[16:20:48.798]                             name <- restart$name
[16:20:48.798]                             if (is.null(name)) 
[16:20:48.798]                               next
[16:20:48.798]                             if (!grepl(pattern, name)) 
[16:20:48.798]                               next
[16:20:48.798]                             invokeRestart(restart)
[16:20:48.798]                             muffled <- TRUE
[16:20:48.798]                             break
[16:20:48.798]                           }
[16:20:48.798]                         }
[16:20:48.798]                       }
[16:20:48.798]                       invisible(muffled)
[16:20:48.798]                     }
[16:20:48.798]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.798]                   }
[16:20:48.798]                 }
[16:20:48.798]                 else {
[16:20:48.798]                   if (TRUE) {
[16:20:48.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.798]                     {
[16:20:48.798]                       inherits <- base::inherits
[16:20:48.798]                       invokeRestart <- base::invokeRestart
[16:20:48.798]                       is.null <- base::is.null
[16:20:48.798]                       muffled <- FALSE
[16:20:48.798]                       if (inherits(cond, "message")) {
[16:20:48.798]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.798]                         if (muffled) 
[16:20:48.798]                           invokeRestart("muffleMessage")
[16:20:48.798]                       }
[16:20:48.798]                       else if (inherits(cond, "warning")) {
[16:20:48.798]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.798]                         if (muffled) 
[16:20:48.798]                           invokeRestart("muffleWarning")
[16:20:48.798]                       }
[16:20:48.798]                       else if (inherits(cond, "condition")) {
[16:20:48.798]                         if (!is.null(pattern)) {
[16:20:48.798]                           computeRestarts <- base::computeRestarts
[16:20:48.798]                           grepl <- base::grepl
[16:20:48.798]                           restarts <- computeRestarts(cond)
[16:20:48.798]                           for (restart in restarts) {
[16:20:48.798]                             name <- restart$name
[16:20:48.798]                             if (is.null(name)) 
[16:20:48.798]                               next
[16:20:48.798]                             if (!grepl(pattern, name)) 
[16:20:48.798]                               next
[16:20:48.798]                             invokeRestart(restart)
[16:20:48.798]                             muffled <- TRUE
[16:20:48.798]                             break
[16:20:48.798]                           }
[16:20:48.798]                         }
[16:20:48.798]                       }
[16:20:48.798]                       invisible(muffled)
[16:20:48.798]                     }
[16:20:48.798]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.798]                   }
[16:20:48.798]                 }
[16:20:48.798]             }
[16:20:48.798]         }))
[16:20:48.798]     }, error = function(ex) {
[16:20:48.798]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.798]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.798]                 ...future.rng), started = ...future.startTime, 
[16:20:48.798]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.798]             version = "1.8"), class = "FutureResult")
[16:20:48.798]     }, finally = {
[16:20:48.798]         if (!identical(...future.workdir, getwd())) 
[16:20:48.798]             setwd(...future.workdir)
[16:20:48.798]         {
[16:20:48.798]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.798]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.798]             }
[16:20:48.798]             base::options(...future.oldOptions)
[16:20:48.798]             if (.Platform$OS.type == "windows") {
[16:20:48.798]                 old_names <- names(...future.oldEnvVars)
[16:20:48.798]                 envs <- base::Sys.getenv()
[16:20:48.798]                 names <- names(envs)
[16:20:48.798]                 common <- intersect(names, old_names)
[16:20:48.798]                 added <- setdiff(names, old_names)
[16:20:48.798]                 removed <- setdiff(old_names, names)
[16:20:48.798]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.798]                   envs[common]]
[16:20:48.798]                 NAMES <- toupper(changed)
[16:20:48.798]                 args <- list()
[16:20:48.798]                 for (kk in seq_along(NAMES)) {
[16:20:48.798]                   name <- changed[[kk]]
[16:20:48.798]                   NAME <- NAMES[[kk]]
[16:20:48.798]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.798]                     next
[16:20:48.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.798]                 }
[16:20:48.798]                 NAMES <- toupper(added)
[16:20:48.798]                 for (kk in seq_along(NAMES)) {
[16:20:48.798]                   name <- added[[kk]]
[16:20:48.798]                   NAME <- NAMES[[kk]]
[16:20:48.798]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.798]                     next
[16:20:48.798]                   args[[name]] <- ""
[16:20:48.798]                 }
[16:20:48.798]                 NAMES <- toupper(removed)
[16:20:48.798]                 for (kk in seq_along(NAMES)) {
[16:20:48.798]                   name <- removed[[kk]]
[16:20:48.798]                   NAME <- NAMES[[kk]]
[16:20:48.798]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.798]                     next
[16:20:48.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.798]                 }
[16:20:48.798]                 if (length(args) > 0) 
[16:20:48.798]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.798]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.798]             }
[16:20:48.798]             else {
[16:20:48.798]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.798]             }
[16:20:48.798]             {
[16:20:48.798]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.798]                   0L) {
[16:20:48.798]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.798]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.798]                   base::options(opts)
[16:20:48.798]                 }
[16:20:48.798]                 {
[16:20:48.798]                   {
[16:20:48.798]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:48.798]                     NULL
[16:20:48.798]                   }
[16:20:48.798]                   options(future.plan = NULL)
[16:20:48.798]                   if (is.na(NA_character_)) 
[16:20:48.798]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.798]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.798]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.798]                     .init = FALSE)
[16:20:48.798]                 }
[16:20:48.798]             }
[16:20:48.798]         }
[16:20:48.798]     })
[16:20:48.798]     if (TRUE) {
[16:20:48.798]         base::sink(type = "output", split = FALSE)
[16:20:48.798]         if (TRUE) {
[16:20:48.798]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.798]         }
[16:20:48.798]         else {
[16:20:48.798]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.798]         }
[16:20:48.798]         base::close(...future.stdout)
[16:20:48.798]         ...future.stdout <- NULL
[16:20:48.798]     }
[16:20:48.798]     ...future.result$conditions <- ...future.conditions
[16:20:48.798]     ...future.result$finished <- base::Sys.time()
[16:20:48.798]     ...future.result
[16:20:48.798] }
[16:20:48.801] requestCore(): workers = 2
[16:20:48.803] MulticoreFuture started
[16:20:48.803] - Launch lazy future ... done
[16:20:48.804] run() for ‘MulticoreFuture’ ... done
[16:20:48.804] result() for MulticoreFuture ...
[16:20:48.805] plan(): Setting new future strategy stack:
[16:20:48.805] List of future strategies:
[16:20:48.805] 1. sequential:
[16:20:48.805]    - args: function (..., envir = parent.frame())
[16:20:48.805]    - tweaked: FALSE
[16:20:48.805]    - call: NULL
[16:20:48.806] plan(): nbrOfWorkers() = 1
[16:20:48.815] plan(): Setting new future strategy stack:
[16:20:48.815] List of future strategies:
[16:20:48.815] 1. multicore:
[16:20:48.815]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:48.815]    - tweaked: FALSE
[16:20:48.815]    - call: plan(strategy)
[16:20:48.822] plan(): nbrOfWorkers() = 2
[16:20:48.825] result() for MulticoreFuture ...
[16:20:48.825] result() for MulticoreFuture ... done
[16:20:48.825] result() for MulticoreFuture ... done
[16:20:48.825] result() for MulticoreFuture ...
[16:20:48.825] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[16:20:48.832] getGlobalsAndPackages() ...
[16:20:48.832] Searching for globals...
[16:20:48.838] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[16:20:48.839] Searching for globals ... DONE
[16:20:48.839] Resolving globals: FALSE
[16:20:48.840] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[16:20:48.840] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[16:20:48.840] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[16:20:48.840] 
[16:20:48.840] getGlobalsAndPackages() ... DONE
[16:20:48.841] run() for ‘Future’ ...
[16:20:48.841] - state: ‘created’
[16:20:48.841] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:48.845] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:48.845] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:48.845]   - Field: ‘label’
[16:20:48.845]   - Field: ‘local’
[16:20:48.845]   - Field: ‘owner’
[16:20:48.846]   - Field: ‘envir’
[16:20:48.846]   - Field: ‘workers’
[16:20:48.846]   - Field: ‘packages’
[16:20:48.846]   - Field: ‘gc’
[16:20:48.846]   - Field: ‘job’
[16:20:48.846]   - Field: ‘conditions’
[16:20:48.846]   - Field: ‘expr’
[16:20:48.846]   - Field: ‘uuid’
[16:20:48.846]   - Field: ‘seed’
[16:20:48.846]   - Field: ‘version’
[16:20:48.847]   - Field: ‘result’
[16:20:48.847]   - Field: ‘asynchronous’
[16:20:48.847]   - Field: ‘calls’
[16:20:48.847]   - Field: ‘globals’
[16:20:48.847]   - Field: ‘stdout’
[16:20:48.847]   - Field: ‘earlySignal’
[16:20:48.847]   - Field: ‘lazy’
[16:20:48.847]   - Field: ‘state’
[16:20:48.847] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:48.848] - Launch lazy future ...
[16:20:48.848] Packages needed by the future expression (n = 0): <none>
[16:20:48.848] Packages needed by future strategies (n = 0): <none>
[16:20:48.849] {
[16:20:48.849]     {
[16:20:48.849]         {
[16:20:48.849]             ...future.startTime <- base::Sys.time()
[16:20:48.849]             {
[16:20:48.849]                 {
[16:20:48.849]                   {
[16:20:48.849]                     {
[16:20:48.849]                       base::local({
[16:20:48.849]                         has_future <- base::requireNamespace("future", 
[16:20:48.849]                           quietly = TRUE)
[16:20:48.849]                         if (has_future) {
[16:20:48.849]                           ns <- base::getNamespace("future")
[16:20:48.849]                           version <- ns[[".package"]][["version"]]
[16:20:48.849]                           if (is.null(version)) 
[16:20:48.849]                             version <- utils::packageVersion("future")
[16:20:48.849]                         }
[16:20:48.849]                         else {
[16:20:48.849]                           version <- NULL
[16:20:48.849]                         }
[16:20:48.849]                         if (!has_future || version < "1.8.0") {
[16:20:48.849]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.849]                             "", base::R.version$version.string), 
[16:20:48.849]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:48.849]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:48.849]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.849]                               "release", "version")], collapse = " "), 
[16:20:48.849]                             hostname = base::Sys.info()[["nodename"]])
[16:20:48.849]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.849]                             info)
[16:20:48.849]                           info <- base::paste(info, collapse = "; ")
[16:20:48.849]                           if (!has_future) {
[16:20:48.849]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.849]                               info)
[16:20:48.849]                           }
[16:20:48.849]                           else {
[16:20:48.849]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.849]                               info, version)
[16:20:48.849]                           }
[16:20:48.849]                           base::stop(msg)
[16:20:48.849]                         }
[16:20:48.849]                       })
[16:20:48.849]                     }
[16:20:48.849]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:48.849]                     base::options(mc.cores = 1L)
[16:20:48.849]                   }
[16:20:48.849]                   ...future.strategy.old <- future::plan("list")
[16:20:48.849]                   options(future.plan = NULL)
[16:20:48.849]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.849]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.849]                 }
[16:20:48.849]                 ...future.workdir <- getwd()
[16:20:48.849]             }
[16:20:48.849]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.849]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.849]         }
[16:20:48.849]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.849]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.849]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.849]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.849]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.849]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.849]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.849]             base::names(...future.oldOptions))
[16:20:48.849]     }
[16:20:48.849]     if (FALSE) {
[16:20:48.849]     }
[16:20:48.849]     else {
[16:20:48.849]         if (TRUE) {
[16:20:48.849]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.849]                 open = "w")
[16:20:48.849]         }
[16:20:48.849]         else {
[16:20:48.849]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.849]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.849]         }
[16:20:48.849]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.849]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.849]             base::sink(type = "output", split = FALSE)
[16:20:48.849]             base::close(...future.stdout)
[16:20:48.849]         }, add = TRUE)
[16:20:48.849]     }
[16:20:48.849]     ...future.frame <- base::sys.nframe()
[16:20:48.849]     ...future.conditions <- base::list()
[16:20:48.849]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.849]     if (FALSE) {
[16:20:48.849]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.849]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.849]     }
[16:20:48.849]     ...future.result <- base::tryCatch({
[16:20:48.849]         base::withCallingHandlers({
[16:20:48.849]             ...future.value <- base::withVisible(base::local({
[16:20:48.849]                 withCallingHandlers({
[16:20:48.849]                   {
[16:20:48.849]                     outer_function(1L)
[16:20:48.849]                   }
[16:20:48.849]                 }, immediateCondition = function(cond) {
[16:20:48.849]                   save_rds <- function (object, pathname, ...) 
[16:20:48.849]                   {
[16:20:48.849]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:48.849]                     if (file_test("-f", pathname_tmp)) {
[16:20:48.849]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.849]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:48.849]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.849]                         fi_tmp[["mtime"]])
[16:20:48.849]                     }
[16:20:48.849]                     tryCatch({
[16:20:48.849]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:48.849]                     }, error = function(ex) {
[16:20:48.849]                       msg <- conditionMessage(ex)
[16:20:48.849]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.849]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:48.849]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.849]                         fi_tmp[["mtime"]], msg)
[16:20:48.849]                       ex$message <- msg
[16:20:48.849]                       stop(ex)
[16:20:48.849]                     })
[16:20:48.849]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:48.849]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:48.849]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:48.849]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.849]                       fi <- file.info(pathname)
[16:20:48.849]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:48.849]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.849]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:48.849]                         fi[["size"]], fi[["mtime"]])
[16:20:48.849]                       stop(msg)
[16:20:48.849]                     }
[16:20:48.849]                     invisible(pathname)
[16:20:48.849]                   }
[16:20:48.849]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:48.849]                     rootPath = tempdir()) 
[16:20:48.849]                   {
[16:20:48.849]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:48.849]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:48.849]                       tmpdir = path, fileext = ".rds")
[16:20:48.849]                     save_rds(obj, file)
[16:20:48.849]                   }
[16:20:48.849]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4Mnhkl/.future/immediateConditions")
[16:20:48.849]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.849]                   {
[16:20:48.849]                     inherits <- base::inherits
[16:20:48.849]                     invokeRestart <- base::invokeRestart
[16:20:48.849]                     is.null <- base::is.null
[16:20:48.849]                     muffled <- FALSE
[16:20:48.849]                     if (inherits(cond, "message")) {
[16:20:48.849]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:48.849]                       if (muffled) 
[16:20:48.849]                         invokeRestart("muffleMessage")
[16:20:48.849]                     }
[16:20:48.849]                     else if (inherits(cond, "warning")) {
[16:20:48.849]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:48.849]                       if (muffled) 
[16:20:48.849]                         invokeRestart("muffleWarning")
[16:20:48.849]                     }
[16:20:48.849]                     else if (inherits(cond, "condition")) {
[16:20:48.849]                       if (!is.null(pattern)) {
[16:20:48.849]                         computeRestarts <- base::computeRestarts
[16:20:48.849]                         grepl <- base::grepl
[16:20:48.849]                         restarts <- computeRestarts(cond)
[16:20:48.849]                         for (restart in restarts) {
[16:20:48.849]                           name <- restart$name
[16:20:48.849]                           if (is.null(name)) 
[16:20:48.849]                             next
[16:20:48.849]                           if (!grepl(pattern, name)) 
[16:20:48.849]                             next
[16:20:48.849]                           invokeRestart(restart)
[16:20:48.849]                           muffled <- TRUE
[16:20:48.849]                           break
[16:20:48.849]                         }
[16:20:48.849]                       }
[16:20:48.849]                     }
[16:20:48.849]                     invisible(muffled)
[16:20:48.849]                   }
[16:20:48.849]                   muffleCondition(cond)
[16:20:48.849]                 })
[16:20:48.849]             }))
[16:20:48.849]             future::FutureResult(value = ...future.value$value, 
[16:20:48.849]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.849]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.849]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.849]                     ...future.globalenv.names))
[16:20:48.849]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.849]         }, condition = base::local({
[16:20:48.849]             c <- base::c
[16:20:48.849]             inherits <- base::inherits
[16:20:48.849]             invokeRestart <- base::invokeRestart
[16:20:48.849]             length <- base::length
[16:20:48.849]             list <- base::list
[16:20:48.849]             seq.int <- base::seq.int
[16:20:48.849]             signalCondition <- base::signalCondition
[16:20:48.849]             sys.calls <- base::sys.calls
[16:20:48.849]             `[[` <- base::`[[`
[16:20:48.849]             `+` <- base::`+`
[16:20:48.849]             `<<-` <- base::`<<-`
[16:20:48.849]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.849]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.849]                   3L)]
[16:20:48.849]             }
[16:20:48.849]             function(cond) {
[16:20:48.849]                 is_error <- inherits(cond, "error")
[16:20:48.849]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.849]                   NULL)
[16:20:48.849]                 if (is_error) {
[16:20:48.849]                   sessionInformation <- function() {
[16:20:48.849]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.849]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.849]                       search = base::search(), system = base::Sys.info())
[16:20:48.849]                   }
[16:20:48.849]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.849]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.849]                     cond$call), session = sessionInformation(), 
[16:20:48.849]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.849]                   signalCondition(cond)
[16:20:48.849]                 }
[16:20:48.849]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.849]                 "immediateCondition"))) {
[16:20:48.849]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.849]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.849]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.849]                   if (TRUE && !signal) {
[16:20:48.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.849]                     {
[16:20:48.849]                       inherits <- base::inherits
[16:20:48.849]                       invokeRestart <- base::invokeRestart
[16:20:48.849]                       is.null <- base::is.null
[16:20:48.849]                       muffled <- FALSE
[16:20:48.849]                       if (inherits(cond, "message")) {
[16:20:48.849]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.849]                         if (muffled) 
[16:20:48.849]                           invokeRestart("muffleMessage")
[16:20:48.849]                       }
[16:20:48.849]                       else if (inherits(cond, "warning")) {
[16:20:48.849]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.849]                         if (muffled) 
[16:20:48.849]                           invokeRestart("muffleWarning")
[16:20:48.849]                       }
[16:20:48.849]                       else if (inherits(cond, "condition")) {
[16:20:48.849]                         if (!is.null(pattern)) {
[16:20:48.849]                           computeRestarts <- base::computeRestarts
[16:20:48.849]                           grepl <- base::grepl
[16:20:48.849]                           restarts <- computeRestarts(cond)
[16:20:48.849]                           for (restart in restarts) {
[16:20:48.849]                             name <- restart$name
[16:20:48.849]                             if (is.null(name)) 
[16:20:48.849]                               next
[16:20:48.849]                             if (!grepl(pattern, name)) 
[16:20:48.849]                               next
[16:20:48.849]                             invokeRestart(restart)
[16:20:48.849]                             muffled <- TRUE
[16:20:48.849]                             break
[16:20:48.849]                           }
[16:20:48.849]                         }
[16:20:48.849]                       }
[16:20:48.849]                       invisible(muffled)
[16:20:48.849]                     }
[16:20:48.849]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.849]                   }
[16:20:48.849]                 }
[16:20:48.849]                 else {
[16:20:48.849]                   if (TRUE) {
[16:20:48.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.849]                     {
[16:20:48.849]                       inherits <- base::inherits
[16:20:48.849]                       invokeRestart <- base::invokeRestart
[16:20:48.849]                       is.null <- base::is.null
[16:20:48.849]                       muffled <- FALSE
[16:20:48.849]                       if (inherits(cond, "message")) {
[16:20:48.849]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.849]                         if (muffled) 
[16:20:48.849]                           invokeRestart("muffleMessage")
[16:20:48.849]                       }
[16:20:48.849]                       else if (inherits(cond, "warning")) {
[16:20:48.849]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.849]                         if (muffled) 
[16:20:48.849]                           invokeRestart("muffleWarning")
[16:20:48.849]                       }
[16:20:48.849]                       else if (inherits(cond, "condition")) {
[16:20:48.849]                         if (!is.null(pattern)) {
[16:20:48.849]                           computeRestarts <- base::computeRestarts
[16:20:48.849]                           grepl <- base::grepl
[16:20:48.849]                           restarts <- computeRestarts(cond)
[16:20:48.849]                           for (restart in restarts) {
[16:20:48.849]                             name <- restart$name
[16:20:48.849]                             if (is.null(name)) 
[16:20:48.849]                               next
[16:20:48.849]                             if (!grepl(pattern, name)) 
[16:20:48.849]                               next
[16:20:48.849]                             invokeRestart(restart)
[16:20:48.849]                             muffled <- TRUE
[16:20:48.849]                             break
[16:20:48.849]                           }
[16:20:48.849]                         }
[16:20:48.849]                       }
[16:20:48.849]                       invisible(muffled)
[16:20:48.849]                     }
[16:20:48.849]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.849]                   }
[16:20:48.849]                 }
[16:20:48.849]             }
[16:20:48.849]         }))
[16:20:48.849]     }, error = function(ex) {
[16:20:48.849]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.849]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.849]                 ...future.rng), started = ...future.startTime, 
[16:20:48.849]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.849]             version = "1.8"), class = "FutureResult")
[16:20:48.849]     }, finally = {
[16:20:48.849]         if (!identical(...future.workdir, getwd())) 
[16:20:48.849]             setwd(...future.workdir)
[16:20:48.849]         {
[16:20:48.849]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.849]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.849]             }
[16:20:48.849]             base::options(...future.oldOptions)
[16:20:48.849]             if (.Platform$OS.type == "windows") {
[16:20:48.849]                 old_names <- names(...future.oldEnvVars)
[16:20:48.849]                 envs <- base::Sys.getenv()
[16:20:48.849]                 names <- names(envs)
[16:20:48.849]                 common <- intersect(names, old_names)
[16:20:48.849]                 added <- setdiff(names, old_names)
[16:20:48.849]                 removed <- setdiff(old_names, names)
[16:20:48.849]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.849]                   envs[common]]
[16:20:48.849]                 NAMES <- toupper(changed)
[16:20:48.849]                 args <- list()
[16:20:48.849]                 for (kk in seq_along(NAMES)) {
[16:20:48.849]                   name <- changed[[kk]]
[16:20:48.849]                   NAME <- NAMES[[kk]]
[16:20:48.849]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.849]                     next
[16:20:48.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.849]                 }
[16:20:48.849]                 NAMES <- toupper(added)
[16:20:48.849]                 for (kk in seq_along(NAMES)) {
[16:20:48.849]                   name <- added[[kk]]
[16:20:48.849]                   NAME <- NAMES[[kk]]
[16:20:48.849]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.849]                     next
[16:20:48.849]                   args[[name]] <- ""
[16:20:48.849]                 }
[16:20:48.849]                 NAMES <- toupper(removed)
[16:20:48.849]                 for (kk in seq_along(NAMES)) {
[16:20:48.849]                   name <- removed[[kk]]
[16:20:48.849]                   NAME <- NAMES[[kk]]
[16:20:48.849]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.849]                     next
[16:20:48.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.849]                 }
[16:20:48.849]                 if (length(args) > 0) 
[16:20:48.849]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.849]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.849]             }
[16:20:48.849]             else {
[16:20:48.849]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.849]             }
[16:20:48.849]             {
[16:20:48.849]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.849]                   0L) {
[16:20:48.849]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.849]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.849]                   base::options(opts)
[16:20:48.849]                 }
[16:20:48.849]                 {
[16:20:48.849]                   {
[16:20:48.849]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:48.849]                     NULL
[16:20:48.849]                   }
[16:20:48.849]                   options(future.plan = NULL)
[16:20:48.849]                   if (is.na(NA_character_)) 
[16:20:48.849]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.849]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.849]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.849]                     .init = FALSE)
[16:20:48.849]                 }
[16:20:48.849]             }
[16:20:48.849]         }
[16:20:48.849]     })
[16:20:48.849]     if (TRUE) {
[16:20:48.849]         base::sink(type = "output", split = FALSE)
[16:20:48.849]         if (TRUE) {
[16:20:48.849]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.849]         }
[16:20:48.849]         else {
[16:20:48.849]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.849]         }
[16:20:48.849]         base::close(...future.stdout)
[16:20:48.849]         ...future.stdout <- NULL
[16:20:48.849]     }
[16:20:48.849]     ...future.result$conditions <- ...future.conditions
[16:20:48.849]     ...future.result$finished <- base::Sys.time()
[16:20:48.849]     ...future.result
[16:20:48.849] }
[16:20:48.851] assign_globals() ...
[16:20:48.851] List of 3
[16:20:48.851]  $ outer_function:function (x)  
[16:20:48.851]  $ map           :function (.x, .f, ...)  
[16:20:48.851]  $ inner_function:function (x)  
[16:20:48.851]  - attr(*, "where")=List of 3
[16:20:48.851]   ..$ outer_function:<environment: R_EmptyEnv> 
[16:20:48.851]   ..$ map           :<environment: R_EmptyEnv> 
[16:20:48.851]   ..$ inner_function:<environment: R_EmptyEnv> 
[16:20:48.851]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:48.851]  - attr(*, "resolved")= logi FALSE
[16:20:48.851]  - attr(*, "total_size")= num 7704
[16:20:48.851]  - attr(*, "already-done")= logi TRUE
[16:20:48.855] - reassign environment for ‘outer_function’
[16:20:48.855] - copied ‘outer_function’ to environment
[16:20:48.855] - reassign environment for ‘map’
[16:20:48.855] - copied ‘map’ to environment
[16:20:48.855] - reassign environment for ‘inner_function’
[16:20:48.855] - copied ‘inner_function’ to environment
[16:20:48.855] assign_globals() ... done
[16:20:48.855] requestCore(): workers = 2
[16:20:48.857] MulticoreFuture started
[16:20:48.858] - Launch lazy future ... done
[16:20:48.858] run() for ‘MulticoreFuture’ ... done
[16:20:48.858] result() for MulticoreFuture ...
[16:20:48.859] plan(): Setting new future strategy stack:
[16:20:48.859] List of future strategies:
[16:20:48.859] 1. sequential:
[16:20:48.859]    - args: function (..., envir = parent.frame())
[16:20:48.859]    - tweaked: FALSE
[16:20:48.859]    - call: NULL
[16:20:48.860] plan(): nbrOfWorkers() = 1
[16:20:48.862] plan(): Setting new future strategy stack:
[16:20:48.862] List of future strategies:
[16:20:48.862] 1. multicore:
[16:20:48.862]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:48.862]    - tweaked: FALSE
[16:20:48.862]    - call: plan(strategy)
[16:20:48.872] plan(): nbrOfWorkers() = 2
[16:20:48.873] result() for MulticoreFuture ...
[16:20:48.873] result() for MulticoreFuture ... done
[16:20:48.873] result() for MulticoreFuture ... done
[16:20:48.873] result() for MulticoreFuture ...
[16:20:48.873] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[16:20:48.875] getGlobalsAndPackages() ...
[16:20:48.878] Searching for globals...
[16:20:48.885] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[16:20:48.885] Searching for globals ... DONE
[16:20:48.885] Resolving globals: FALSE
[16:20:48.886] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[16:20:48.886] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[16:20:48.887] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[16:20:48.887] 
[16:20:48.887] getGlobalsAndPackages() ... DONE
[16:20:48.887] run() for ‘Future’ ...
[16:20:48.887] - state: ‘created’
[16:20:48.888] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:48.892] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:48.892] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:48.892]   - Field: ‘label’
[16:20:48.892]   - Field: ‘local’
[16:20:48.892]   - Field: ‘owner’
[16:20:48.892]   - Field: ‘envir’
[16:20:48.892]   - Field: ‘workers’
[16:20:48.892]   - Field: ‘packages’
[16:20:48.893]   - Field: ‘gc’
[16:20:48.893]   - Field: ‘job’
[16:20:48.893]   - Field: ‘conditions’
[16:20:48.893]   - Field: ‘expr’
[16:20:48.893]   - Field: ‘uuid’
[16:20:48.893]   - Field: ‘seed’
[16:20:48.893]   - Field: ‘version’
[16:20:48.893]   - Field: ‘result’
[16:20:48.893]   - Field: ‘asynchronous’
[16:20:48.894]   - Field: ‘calls’
[16:20:48.894]   - Field: ‘globals’
[16:20:48.894]   - Field: ‘stdout’
[16:20:48.894]   - Field: ‘earlySignal’
[16:20:48.894]   - Field: ‘lazy’
[16:20:48.894]   - Field: ‘state’
[16:20:48.894] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:48.894] - Launch lazy future ...
[16:20:48.895] Packages needed by the future expression (n = 0): <none>
[16:20:48.895] Packages needed by future strategies (n = 0): <none>
[16:20:48.895] {
[16:20:48.895]     {
[16:20:48.895]         {
[16:20:48.895]             ...future.startTime <- base::Sys.time()
[16:20:48.895]             {
[16:20:48.895]                 {
[16:20:48.895]                   {
[16:20:48.895]                     {
[16:20:48.895]                       base::local({
[16:20:48.895]                         has_future <- base::requireNamespace("future", 
[16:20:48.895]                           quietly = TRUE)
[16:20:48.895]                         if (has_future) {
[16:20:48.895]                           ns <- base::getNamespace("future")
[16:20:48.895]                           version <- ns[[".package"]][["version"]]
[16:20:48.895]                           if (is.null(version)) 
[16:20:48.895]                             version <- utils::packageVersion("future")
[16:20:48.895]                         }
[16:20:48.895]                         else {
[16:20:48.895]                           version <- NULL
[16:20:48.895]                         }
[16:20:48.895]                         if (!has_future || version < "1.8.0") {
[16:20:48.895]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:48.895]                             "", base::R.version$version.string), 
[16:20:48.895]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:48.895]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:48.895]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:48.895]                               "release", "version")], collapse = " "), 
[16:20:48.895]                             hostname = base::Sys.info()[["nodename"]])
[16:20:48.895]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:48.895]                             info)
[16:20:48.895]                           info <- base::paste(info, collapse = "; ")
[16:20:48.895]                           if (!has_future) {
[16:20:48.895]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:48.895]                               info)
[16:20:48.895]                           }
[16:20:48.895]                           else {
[16:20:48.895]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:48.895]                               info, version)
[16:20:48.895]                           }
[16:20:48.895]                           base::stop(msg)
[16:20:48.895]                         }
[16:20:48.895]                       })
[16:20:48.895]                     }
[16:20:48.895]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:48.895]                     base::options(mc.cores = 1L)
[16:20:48.895]                   }
[16:20:48.895]                   ...future.strategy.old <- future::plan("list")
[16:20:48.895]                   options(future.plan = NULL)
[16:20:48.895]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.895]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:48.895]                 }
[16:20:48.895]                 ...future.workdir <- getwd()
[16:20:48.895]             }
[16:20:48.895]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:48.895]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:48.895]         }
[16:20:48.895]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:48.895]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:48.895]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:48.895]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:48.895]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:48.895]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:48.895]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:48.895]             base::names(...future.oldOptions))
[16:20:48.895]     }
[16:20:48.895]     if (FALSE) {
[16:20:48.895]     }
[16:20:48.895]     else {
[16:20:48.895]         if (TRUE) {
[16:20:48.895]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:48.895]                 open = "w")
[16:20:48.895]         }
[16:20:48.895]         else {
[16:20:48.895]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:48.895]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:48.895]         }
[16:20:48.895]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:48.895]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:48.895]             base::sink(type = "output", split = FALSE)
[16:20:48.895]             base::close(...future.stdout)
[16:20:48.895]         }, add = TRUE)
[16:20:48.895]     }
[16:20:48.895]     ...future.frame <- base::sys.nframe()
[16:20:48.895]     ...future.conditions <- base::list()
[16:20:48.895]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:48.895]     if (FALSE) {
[16:20:48.895]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:48.895]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:48.895]     }
[16:20:48.895]     ...future.result <- base::tryCatch({
[16:20:48.895]         base::withCallingHandlers({
[16:20:48.895]             ...future.value <- base::withVisible(base::local({
[16:20:48.895]                 withCallingHandlers({
[16:20:48.895]                   {
[16:20:48.895]                     outer_function(1L)
[16:20:48.895]                   }
[16:20:48.895]                 }, immediateCondition = function(cond) {
[16:20:48.895]                   save_rds <- function (object, pathname, ...) 
[16:20:48.895]                   {
[16:20:48.895]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:48.895]                     if (file_test("-f", pathname_tmp)) {
[16:20:48.895]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.895]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:48.895]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.895]                         fi_tmp[["mtime"]])
[16:20:48.895]                     }
[16:20:48.895]                     tryCatch({
[16:20:48.895]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:48.895]                     }, error = function(ex) {
[16:20:48.895]                       msg <- conditionMessage(ex)
[16:20:48.895]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.895]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:48.895]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.895]                         fi_tmp[["mtime"]], msg)
[16:20:48.895]                       ex$message <- msg
[16:20:48.895]                       stop(ex)
[16:20:48.895]                     })
[16:20:48.895]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:48.895]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:48.895]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:48.895]                       fi_tmp <- file.info(pathname_tmp)
[16:20:48.895]                       fi <- file.info(pathname)
[16:20:48.895]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:48.895]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:48.895]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:48.895]                         fi[["size"]], fi[["mtime"]])
[16:20:48.895]                       stop(msg)
[16:20:48.895]                     }
[16:20:48.895]                     invisible(pathname)
[16:20:48.895]                   }
[16:20:48.895]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:48.895]                     rootPath = tempdir()) 
[16:20:48.895]                   {
[16:20:48.895]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:48.895]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:48.895]                       tmpdir = path, fileext = ".rds")
[16:20:48.895]                     save_rds(obj, file)
[16:20:48.895]                   }
[16:20:48.895]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4Mnhkl/.future/immediateConditions")
[16:20:48.895]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.895]                   {
[16:20:48.895]                     inherits <- base::inherits
[16:20:48.895]                     invokeRestart <- base::invokeRestart
[16:20:48.895]                     is.null <- base::is.null
[16:20:48.895]                     muffled <- FALSE
[16:20:48.895]                     if (inherits(cond, "message")) {
[16:20:48.895]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:48.895]                       if (muffled) 
[16:20:48.895]                         invokeRestart("muffleMessage")
[16:20:48.895]                     }
[16:20:48.895]                     else if (inherits(cond, "warning")) {
[16:20:48.895]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:48.895]                       if (muffled) 
[16:20:48.895]                         invokeRestart("muffleWarning")
[16:20:48.895]                     }
[16:20:48.895]                     else if (inherits(cond, "condition")) {
[16:20:48.895]                       if (!is.null(pattern)) {
[16:20:48.895]                         computeRestarts <- base::computeRestarts
[16:20:48.895]                         grepl <- base::grepl
[16:20:48.895]                         restarts <- computeRestarts(cond)
[16:20:48.895]                         for (restart in restarts) {
[16:20:48.895]                           name <- restart$name
[16:20:48.895]                           if (is.null(name)) 
[16:20:48.895]                             next
[16:20:48.895]                           if (!grepl(pattern, name)) 
[16:20:48.895]                             next
[16:20:48.895]                           invokeRestart(restart)
[16:20:48.895]                           muffled <- TRUE
[16:20:48.895]                           break
[16:20:48.895]                         }
[16:20:48.895]                       }
[16:20:48.895]                     }
[16:20:48.895]                     invisible(muffled)
[16:20:48.895]                   }
[16:20:48.895]                   muffleCondition(cond)
[16:20:48.895]                 })
[16:20:48.895]             }))
[16:20:48.895]             future::FutureResult(value = ...future.value$value, 
[16:20:48.895]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.895]                   ...future.rng), globalenv = if (FALSE) 
[16:20:48.895]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:48.895]                     ...future.globalenv.names))
[16:20:48.895]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:48.895]         }, condition = base::local({
[16:20:48.895]             c <- base::c
[16:20:48.895]             inherits <- base::inherits
[16:20:48.895]             invokeRestart <- base::invokeRestart
[16:20:48.895]             length <- base::length
[16:20:48.895]             list <- base::list
[16:20:48.895]             seq.int <- base::seq.int
[16:20:48.895]             signalCondition <- base::signalCondition
[16:20:48.895]             sys.calls <- base::sys.calls
[16:20:48.895]             `[[` <- base::`[[`
[16:20:48.895]             `+` <- base::`+`
[16:20:48.895]             `<<-` <- base::`<<-`
[16:20:48.895]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:48.895]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:48.895]                   3L)]
[16:20:48.895]             }
[16:20:48.895]             function(cond) {
[16:20:48.895]                 is_error <- inherits(cond, "error")
[16:20:48.895]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:48.895]                   NULL)
[16:20:48.895]                 if (is_error) {
[16:20:48.895]                   sessionInformation <- function() {
[16:20:48.895]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:48.895]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:48.895]                       search = base::search(), system = base::Sys.info())
[16:20:48.895]                   }
[16:20:48.895]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.895]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:48.895]                     cond$call), session = sessionInformation(), 
[16:20:48.895]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:48.895]                   signalCondition(cond)
[16:20:48.895]                 }
[16:20:48.895]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:48.895]                 "immediateCondition"))) {
[16:20:48.895]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:48.895]                   ...future.conditions[[length(...future.conditions) + 
[16:20:48.895]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:48.895]                   if (TRUE && !signal) {
[16:20:48.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.895]                     {
[16:20:48.895]                       inherits <- base::inherits
[16:20:48.895]                       invokeRestart <- base::invokeRestart
[16:20:48.895]                       is.null <- base::is.null
[16:20:48.895]                       muffled <- FALSE
[16:20:48.895]                       if (inherits(cond, "message")) {
[16:20:48.895]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.895]                         if (muffled) 
[16:20:48.895]                           invokeRestart("muffleMessage")
[16:20:48.895]                       }
[16:20:48.895]                       else if (inherits(cond, "warning")) {
[16:20:48.895]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.895]                         if (muffled) 
[16:20:48.895]                           invokeRestart("muffleWarning")
[16:20:48.895]                       }
[16:20:48.895]                       else if (inherits(cond, "condition")) {
[16:20:48.895]                         if (!is.null(pattern)) {
[16:20:48.895]                           computeRestarts <- base::computeRestarts
[16:20:48.895]                           grepl <- base::grepl
[16:20:48.895]                           restarts <- computeRestarts(cond)
[16:20:48.895]                           for (restart in restarts) {
[16:20:48.895]                             name <- restart$name
[16:20:48.895]                             if (is.null(name)) 
[16:20:48.895]                               next
[16:20:48.895]                             if (!grepl(pattern, name)) 
[16:20:48.895]                               next
[16:20:48.895]                             invokeRestart(restart)
[16:20:48.895]                             muffled <- TRUE
[16:20:48.895]                             break
[16:20:48.895]                           }
[16:20:48.895]                         }
[16:20:48.895]                       }
[16:20:48.895]                       invisible(muffled)
[16:20:48.895]                     }
[16:20:48.895]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.895]                   }
[16:20:48.895]                 }
[16:20:48.895]                 else {
[16:20:48.895]                   if (TRUE) {
[16:20:48.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:48.895]                     {
[16:20:48.895]                       inherits <- base::inherits
[16:20:48.895]                       invokeRestart <- base::invokeRestart
[16:20:48.895]                       is.null <- base::is.null
[16:20:48.895]                       muffled <- FALSE
[16:20:48.895]                       if (inherits(cond, "message")) {
[16:20:48.895]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:48.895]                         if (muffled) 
[16:20:48.895]                           invokeRestart("muffleMessage")
[16:20:48.895]                       }
[16:20:48.895]                       else if (inherits(cond, "warning")) {
[16:20:48.895]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:48.895]                         if (muffled) 
[16:20:48.895]                           invokeRestart("muffleWarning")
[16:20:48.895]                       }
[16:20:48.895]                       else if (inherits(cond, "condition")) {
[16:20:48.895]                         if (!is.null(pattern)) {
[16:20:48.895]                           computeRestarts <- base::computeRestarts
[16:20:48.895]                           grepl <- base::grepl
[16:20:48.895]                           restarts <- computeRestarts(cond)
[16:20:48.895]                           for (restart in restarts) {
[16:20:48.895]                             name <- restart$name
[16:20:48.895]                             if (is.null(name)) 
[16:20:48.895]                               next
[16:20:48.895]                             if (!grepl(pattern, name)) 
[16:20:48.895]                               next
[16:20:48.895]                             invokeRestart(restart)
[16:20:48.895]                             muffled <- TRUE
[16:20:48.895]                             break
[16:20:48.895]                           }
[16:20:48.895]                         }
[16:20:48.895]                       }
[16:20:48.895]                       invisible(muffled)
[16:20:48.895]                     }
[16:20:48.895]                     muffleCondition(cond, pattern = "^muffle")
[16:20:48.895]                   }
[16:20:48.895]                 }
[16:20:48.895]             }
[16:20:48.895]         }))
[16:20:48.895]     }, error = function(ex) {
[16:20:48.895]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:48.895]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:48.895]                 ...future.rng), started = ...future.startTime, 
[16:20:48.895]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:48.895]             version = "1.8"), class = "FutureResult")
[16:20:48.895]     }, finally = {
[16:20:48.895]         if (!identical(...future.workdir, getwd())) 
[16:20:48.895]             setwd(...future.workdir)
[16:20:48.895]         {
[16:20:48.895]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:48.895]                 ...future.oldOptions$nwarnings <- NULL
[16:20:48.895]             }
[16:20:48.895]             base::options(...future.oldOptions)
[16:20:48.895]             if (.Platform$OS.type == "windows") {
[16:20:48.895]                 old_names <- names(...future.oldEnvVars)
[16:20:48.895]                 envs <- base::Sys.getenv()
[16:20:48.895]                 names <- names(envs)
[16:20:48.895]                 common <- intersect(names, old_names)
[16:20:48.895]                 added <- setdiff(names, old_names)
[16:20:48.895]                 removed <- setdiff(old_names, names)
[16:20:48.895]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:48.895]                   envs[common]]
[16:20:48.895]                 NAMES <- toupper(changed)
[16:20:48.895]                 args <- list()
[16:20:48.895]                 for (kk in seq_along(NAMES)) {
[16:20:48.895]                   name <- changed[[kk]]
[16:20:48.895]                   NAME <- NAMES[[kk]]
[16:20:48.895]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.895]                     next
[16:20:48.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.895]                 }
[16:20:48.895]                 NAMES <- toupper(added)
[16:20:48.895]                 for (kk in seq_along(NAMES)) {
[16:20:48.895]                   name <- added[[kk]]
[16:20:48.895]                   NAME <- NAMES[[kk]]
[16:20:48.895]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.895]                     next
[16:20:48.895]                   args[[name]] <- ""
[16:20:48.895]                 }
[16:20:48.895]                 NAMES <- toupper(removed)
[16:20:48.895]                 for (kk in seq_along(NAMES)) {
[16:20:48.895]                   name <- removed[[kk]]
[16:20:48.895]                   NAME <- NAMES[[kk]]
[16:20:48.895]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:48.895]                     next
[16:20:48.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:48.895]                 }
[16:20:48.895]                 if (length(args) > 0) 
[16:20:48.895]                   base::do.call(base::Sys.setenv, args = args)
[16:20:48.895]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:48.895]             }
[16:20:48.895]             else {
[16:20:48.895]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:48.895]             }
[16:20:48.895]             {
[16:20:48.895]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:48.895]                   0L) {
[16:20:48.895]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:48.895]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:48.895]                   base::options(opts)
[16:20:48.895]                 }
[16:20:48.895]                 {
[16:20:48.895]                   {
[16:20:48.895]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:48.895]                     NULL
[16:20:48.895]                   }
[16:20:48.895]                   options(future.plan = NULL)
[16:20:48.895]                   if (is.na(NA_character_)) 
[16:20:48.895]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:48.895]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:48.895]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:48.895]                     .init = FALSE)
[16:20:48.895]                 }
[16:20:48.895]             }
[16:20:48.895]         }
[16:20:48.895]     })
[16:20:48.895]     if (TRUE) {
[16:20:48.895]         base::sink(type = "output", split = FALSE)
[16:20:48.895]         if (TRUE) {
[16:20:48.895]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:48.895]         }
[16:20:48.895]         else {
[16:20:48.895]             ...future.result["stdout"] <- base::list(NULL)
[16:20:48.895]         }
[16:20:48.895]         base::close(...future.stdout)
[16:20:48.895]         ...future.stdout <- NULL
[16:20:48.895]     }
[16:20:48.895]     ...future.result$conditions <- ...future.conditions
[16:20:48.895]     ...future.result$finished <- base::Sys.time()
[16:20:48.895]     ...future.result
[16:20:48.895] }
[16:20:48.898] assign_globals() ...
[16:20:48.898] List of 3
[16:20:48.898]  $ outer_function:function (x)  
[16:20:48.898]  $ map           :function (.x, .f, ...)  
[16:20:48.898]  $ inner_function:function (x)  
[16:20:48.898]  - attr(*, "where")=List of 3
[16:20:48.898]   ..$ outer_function:<environment: R_EmptyEnv> 
[16:20:48.898]   ..$ map           :<environment: R_EmptyEnv> 
[16:20:48.898]   ..$ inner_function:<environment: R_EmptyEnv> 
[16:20:48.898]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:48.898]  - attr(*, "resolved")= logi FALSE
[16:20:48.898]  - attr(*, "total_size")= num 7704
[16:20:48.898]  - attr(*, "already-done")= logi TRUE
[16:20:48.901] - reassign environment for ‘outer_function’
[16:20:48.901] - copied ‘outer_function’ to environment
[16:20:48.902] - reassign environment for ‘map’
[16:20:48.902] - copied ‘map’ to environment
[16:20:48.902] - reassign environment for ‘inner_function’
[16:20:48.902] - copied ‘inner_function’ to environment
[16:20:48.902] assign_globals() ... done
[16:20:48.902] requestCore(): workers = 2
[16:20:48.904] MulticoreFuture started
[16:20:48.904] - Launch lazy future ... done
[16:20:48.905] run() for ‘MulticoreFuture’ ... done
[16:20:48.905] result() for MulticoreFuture ...
[16:20:48.905] plan(): Setting new future strategy stack:
[16:20:48.905] List of future strategies:
[16:20:48.905] 1. sequential:
[16:20:48.905]    - args: function (..., envir = parent.frame())
[16:20:48.905]    - tweaked: FALSE
[16:20:48.905]    - call: NULL
[16:20:48.906] plan(): nbrOfWorkers() = 1
[16:20:48.909] plan(): Setting new future strategy stack:
[16:20:48.909] List of future strategies:
[16:20:48.909] 1. multicore:
[16:20:48.909]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:48.909]    - tweaked: FALSE
[16:20:48.909]    - call: plan(strategy)
[16:20:48.914] plan(): nbrOfWorkers() = 2
[16:20:48.915] result() for MulticoreFuture ...
[16:20:48.915] result() for MulticoreFuture ... done
[16:20:48.915] result() for MulticoreFuture ... done
[16:20:48.915] result() for MulticoreFuture ...
[16:20:48.915] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
- plan('multisession') ...
[16:20:48.918] plan(): Setting new future strategy stack:
[16:20:48.918] List of future strategies:
[16:20:48.918] 1. multisession:
[16:20:48.918]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:20:48.918]    - tweaked: FALSE
[16:20:48.918]    - call: plan(strategy)
[16:20:48.918] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:20:48.918] multisession:
[16:20:48.918] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:20:48.918] - tweaked: FALSE
[16:20:48.918] - call: plan(strategy)
[16:20:48.928] getGlobalsAndPackages() ...
[16:20:48.929] Not searching for globals
[16:20:48.929] - globals: [0] <none>
[16:20:48.929] getGlobalsAndPackages() ... DONE
[16:20:48.930] [local output] makeClusterPSOCK() ...
[16:20:48.973] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:20:48.974] [local output] Base port: 11677
[16:20:48.974] [local output] Getting setup options for 2 cluster nodes ...
[16:20:48.974] [local output]  - Node 1 of 2 ...
[16:20:48.975] [local output] localMachine=TRUE => revtunnel=FALSE

[16:20:48.976] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp4Mnhkl/worker.rank=1.parallelly.parent=82163.140f358c4c7d.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp4Mnhkl/worker.rank=1.parallelly.parent=82163.140f358c4c7d.pid")'’
[16:20:49.165] - Possible to infer worker's PID: TRUE
[16:20:49.166] [local output] Rscript port: 11677

[16:20:49.166] [local output]  - Node 2 of 2 ...
[16:20:49.166] [local output] localMachine=TRUE => revtunnel=FALSE

[16:20:49.167] [local output] Rscript port: 11677

[16:20:49.167] [local output] Getting setup options for 2 cluster nodes ... done
[16:20:49.167] [local output]  - Parallel setup requested for some PSOCK nodes
[16:20:49.168] [local output] Setting up PSOCK nodes in parallel
[16:20:49.168] List of 36
[16:20:49.168]  $ worker          : chr "localhost"
[16:20:49.168]   ..- attr(*, "localhost")= logi TRUE
[16:20:49.168]  $ master          : chr "localhost"
[16:20:49.168]  $ port            : int 11677
[16:20:49.168]  $ connectTimeout  : num 120
[16:20:49.168]  $ timeout         : num 2592000
[16:20:49.168]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:20:49.168]  $ homogeneous     : logi TRUE
[16:20:49.168]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:20:49.168]  $ rscript_envs    : NULL
[16:20:49.168]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:20:49.168]  $ rscript_startup : NULL
[16:20:49.168]  $ rscript_sh      : chr "sh"
[16:20:49.168]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:20:49.168]  $ methods         : logi TRUE
[16:20:49.168]  $ socketOptions   : chr "no-delay"
[16:20:49.168]  $ useXDR          : logi FALSE
[16:20:49.168]  $ outfile         : chr "/dev/null"
[16:20:49.168]  $ renice          : int NA
[16:20:49.168]  $ rshcmd          : NULL
[16:20:49.168]  $ user            : chr(0) 
[16:20:49.168]  $ revtunnel       : logi FALSE
[16:20:49.168]  $ rshlogfile      : NULL
[16:20:49.168]  $ rshopts         : chr(0) 
[16:20:49.168]  $ rank            : int 1
[16:20:49.168]  $ manual          : logi FALSE
[16:20:49.168]  $ dryrun          : logi FALSE
[16:20:49.168]  $ quiet           : logi FALSE
[16:20:49.168]  $ setup_strategy  : chr "parallel"
[16:20:49.168]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:20:49.168]  $ pidfile         : chr "/tmp/Rtmp4Mnhkl/worker.rank=1.parallelly.parent=82163.140f358c4c7d.pid"
[16:20:49.168]  $ rshcmd_label    : NULL
[16:20:49.168]  $ rsh_call        : NULL
[16:20:49.168]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:20:49.168]  $ localMachine    : logi TRUE
[16:20:49.168]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:20:49.168]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:20:49.168]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:20:49.168]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:20:49.168]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:20:49.168]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:20:49.168]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:20:49.168]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:20:49.168]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:20:49.168]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:20:49.168]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:20:49.168]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:20:49.168]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:20:49.168]  $ arguments       :List of 28
[16:20:49.168]   ..$ worker          : chr "localhost"
[16:20:49.168]   ..$ master          : NULL
[16:20:49.168]   ..$ port            : int 11677
[16:20:49.168]   ..$ connectTimeout  : num 120
[16:20:49.168]   ..$ timeout         : num 2592000
[16:20:49.168]   ..$ rscript         : NULL
[16:20:49.168]   ..$ homogeneous     : NULL
[16:20:49.168]   ..$ rscript_args    : NULL
[16:20:49.168]   ..$ rscript_envs    : NULL
[16:20:49.168]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:20:49.168]   ..$ rscript_startup : NULL
[16:20:49.168]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:20:49.168]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:20:49.168]   ..$ methods         : logi TRUE
[16:20:49.168]   ..$ socketOptions   : chr "no-delay"
[16:20:49.168]   ..$ useXDR          : logi FALSE
[16:20:49.168]   ..$ outfile         : chr "/dev/null"
[16:20:49.168]   ..$ renice          : int NA
[16:20:49.168]   ..$ rshcmd          : NULL
[16:20:49.168]   ..$ user            : NULL
[16:20:49.168]   ..$ revtunnel       : logi NA
[16:20:49.168]   ..$ rshlogfile      : NULL
[16:20:49.168]   ..$ rshopts         : NULL
[16:20:49.168]   ..$ rank            : int 1
[16:20:49.168]   ..$ manual          : logi FALSE
[16:20:49.168]   ..$ dryrun          : logi FALSE
[16:20:49.168]   ..$ quiet           : logi FALSE
[16:20:49.168]   ..$ setup_strategy  : chr "parallel"
[16:20:49.168]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:20:49.185] [local output] System call to launch all workers:
[16:20:49.185] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp4Mnhkl/worker.rank=1.parallelly.parent=82163.140f358c4c7d.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11677 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:20:49.185] [local output] Starting PSOCK main server
[16:20:49.191] [local output] Workers launched
[16:20:49.191] [local output] Waiting for workers to connect back
[16:20:49.191]  - [local output] 0 workers out of 2 ready
[16:20:49.438]  - [local output] 0 workers out of 2 ready
[16:20:49.438]  - [local output] 1 workers out of 2 ready
[16:20:49.442]  - [local output] 1 workers out of 2 ready
[16:20:49.442]  - [local output] 2 workers out of 2 ready
[16:20:49.442] [local output] Launching of workers completed
[16:20:49.443] [local output] Collecting session information from workers
[16:20:49.443] [local output]  - Worker #1 of 2
[16:20:49.444] [local output]  - Worker #2 of 2
[16:20:49.444] [local output] makeClusterPSOCK() ... done
[16:20:49.456] Packages needed by the future expression (n = 0): <none>
[16:20:49.456] Packages needed by future strategies (n = 0): <none>
[16:20:49.456] {
[16:20:49.456]     {
[16:20:49.456]         {
[16:20:49.456]             ...future.startTime <- base::Sys.time()
[16:20:49.456]             {
[16:20:49.456]                 {
[16:20:49.456]                   {
[16:20:49.456]                     {
[16:20:49.456]                       base::local({
[16:20:49.456]                         has_future <- base::requireNamespace("future", 
[16:20:49.456]                           quietly = TRUE)
[16:20:49.456]                         if (has_future) {
[16:20:49.456]                           ns <- base::getNamespace("future")
[16:20:49.456]                           version <- ns[[".package"]][["version"]]
[16:20:49.456]                           if (is.null(version)) 
[16:20:49.456]                             version <- utils::packageVersion("future")
[16:20:49.456]                         }
[16:20:49.456]                         else {
[16:20:49.456]                           version <- NULL
[16:20:49.456]                         }
[16:20:49.456]                         if (!has_future || version < "1.8.0") {
[16:20:49.456]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:49.456]                             "", base::R.version$version.string), 
[16:20:49.456]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:49.456]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:49.456]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:49.456]                               "release", "version")], collapse = " "), 
[16:20:49.456]                             hostname = base::Sys.info()[["nodename"]])
[16:20:49.456]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:49.456]                             info)
[16:20:49.456]                           info <- base::paste(info, collapse = "; ")
[16:20:49.456]                           if (!has_future) {
[16:20:49.456]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:49.456]                               info)
[16:20:49.456]                           }
[16:20:49.456]                           else {
[16:20:49.456]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:49.456]                               info, version)
[16:20:49.456]                           }
[16:20:49.456]                           base::stop(msg)
[16:20:49.456]                         }
[16:20:49.456]                       })
[16:20:49.456]                     }
[16:20:49.456]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:49.456]                     base::options(mc.cores = 1L)
[16:20:49.456]                   }
[16:20:49.456]                   ...future.strategy.old <- future::plan("list")
[16:20:49.456]                   options(future.plan = NULL)
[16:20:49.456]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:49.456]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:49.456]                 }
[16:20:49.456]                 ...future.workdir <- getwd()
[16:20:49.456]             }
[16:20:49.456]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:49.456]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:49.456]         }
[16:20:49.456]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:49.456]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:49.456]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:49.456]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:49.456]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:49.456]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:49.456]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:49.456]             base::names(...future.oldOptions))
[16:20:49.456]     }
[16:20:49.456]     if (FALSE) {
[16:20:49.456]     }
[16:20:49.456]     else {
[16:20:49.456]         if (TRUE) {
[16:20:49.456]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:49.456]                 open = "w")
[16:20:49.456]         }
[16:20:49.456]         else {
[16:20:49.456]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:49.456]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:49.456]         }
[16:20:49.456]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:49.456]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:49.456]             base::sink(type = "output", split = FALSE)
[16:20:49.456]             base::close(...future.stdout)
[16:20:49.456]         }, add = TRUE)
[16:20:49.456]     }
[16:20:49.456]     ...future.frame <- base::sys.nframe()
[16:20:49.456]     ...future.conditions <- base::list()
[16:20:49.456]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:49.456]     if (FALSE) {
[16:20:49.456]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:49.456]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:49.456]     }
[16:20:49.456]     ...future.result <- base::tryCatch({
[16:20:49.456]         base::withCallingHandlers({
[16:20:49.456]             ...future.value <- base::withVisible(base::local({
[16:20:49.456]                 ...future.makeSendCondition <- base::local({
[16:20:49.456]                   sendCondition <- NULL
[16:20:49.456]                   function(frame = 1L) {
[16:20:49.456]                     if (is.function(sendCondition)) 
[16:20:49.456]                       return(sendCondition)
[16:20:49.456]                     ns <- getNamespace("parallel")
[16:20:49.456]                     if (exists("sendData", mode = "function", 
[16:20:49.456]                       envir = ns)) {
[16:20:49.456]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:49.456]                         envir = ns)
[16:20:49.456]                       envir <- sys.frame(frame)
[16:20:49.456]                       master <- NULL
[16:20:49.456]                       while (!identical(envir, .GlobalEnv) && 
[16:20:49.456]                         !identical(envir, emptyenv())) {
[16:20:49.456]                         if (exists("master", mode = "list", envir = envir, 
[16:20:49.456]                           inherits = FALSE)) {
[16:20:49.456]                           master <- get("master", mode = "list", 
[16:20:49.456]                             envir = envir, inherits = FALSE)
[16:20:49.456]                           if (inherits(master, c("SOCKnode", 
[16:20:49.456]                             "SOCK0node"))) {
[16:20:49.456]                             sendCondition <<- function(cond) {
[16:20:49.456]                               data <- list(type = "VALUE", value = cond, 
[16:20:49.456]                                 success = TRUE)
[16:20:49.456]                               parallel_sendData(master, data)
[16:20:49.456]                             }
[16:20:49.456]                             return(sendCondition)
[16:20:49.456]                           }
[16:20:49.456]                         }
[16:20:49.456]                         frame <- frame + 1L
[16:20:49.456]                         envir <- sys.frame(frame)
[16:20:49.456]                       }
[16:20:49.456]                     }
[16:20:49.456]                     sendCondition <<- function(cond) NULL
[16:20:49.456]                   }
[16:20:49.456]                 })
[16:20:49.456]                 withCallingHandlers({
[16:20:49.456]                   NA
[16:20:49.456]                 }, immediateCondition = function(cond) {
[16:20:49.456]                   sendCondition <- ...future.makeSendCondition()
[16:20:49.456]                   sendCondition(cond)
[16:20:49.456]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:49.456]                   {
[16:20:49.456]                     inherits <- base::inherits
[16:20:49.456]                     invokeRestart <- base::invokeRestart
[16:20:49.456]                     is.null <- base::is.null
[16:20:49.456]                     muffled <- FALSE
[16:20:49.456]                     if (inherits(cond, "message")) {
[16:20:49.456]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:49.456]                       if (muffled) 
[16:20:49.456]                         invokeRestart("muffleMessage")
[16:20:49.456]                     }
[16:20:49.456]                     else if (inherits(cond, "warning")) {
[16:20:49.456]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:49.456]                       if (muffled) 
[16:20:49.456]                         invokeRestart("muffleWarning")
[16:20:49.456]                     }
[16:20:49.456]                     else if (inherits(cond, "condition")) {
[16:20:49.456]                       if (!is.null(pattern)) {
[16:20:49.456]                         computeRestarts <- base::computeRestarts
[16:20:49.456]                         grepl <- base::grepl
[16:20:49.456]                         restarts <- computeRestarts(cond)
[16:20:49.456]                         for (restart in restarts) {
[16:20:49.456]                           name <- restart$name
[16:20:49.456]                           if (is.null(name)) 
[16:20:49.456]                             next
[16:20:49.456]                           if (!grepl(pattern, name)) 
[16:20:49.456]                             next
[16:20:49.456]                           invokeRestart(restart)
[16:20:49.456]                           muffled <- TRUE
[16:20:49.456]                           break
[16:20:49.456]                         }
[16:20:49.456]                       }
[16:20:49.456]                     }
[16:20:49.456]                     invisible(muffled)
[16:20:49.456]                   }
[16:20:49.456]                   muffleCondition(cond)
[16:20:49.456]                 })
[16:20:49.456]             }))
[16:20:49.456]             future::FutureResult(value = ...future.value$value, 
[16:20:49.456]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:49.456]                   ...future.rng), globalenv = if (FALSE) 
[16:20:49.456]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:49.456]                     ...future.globalenv.names))
[16:20:49.456]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:49.456]         }, condition = base::local({
[16:20:49.456]             c <- base::c
[16:20:49.456]             inherits <- base::inherits
[16:20:49.456]             invokeRestart <- base::invokeRestart
[16:20:49.456]             length <- base::length
[16:20:49.456]             list <- base::list
[16:20:49.456]             seq.int <- base::seq.int
[16:20:49.456]             signalCondition <- base::signalCondition
[16:20:49.456]             sys.calls <- base::sys.calls
[16:20:49.456]             `[[` <- base::`[[`
[16:20:49.456]             `+` <- base::`+`
[16:20:49.456]             `<<-` <- base::`<<-`
[16:20:49.456]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:49.456]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:49.456]                   3L)]
[16:20:49.456]             }
[16:20:49.456]             function(cond) {
[16:20:49.456]                 is_error <- inherits(cond, "error")
[16:20:49.456]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:49.456]                   NULL)
[16:20:49.456]                 if (is_error) {
[16:20:49.456]                   sessionInformation <- function() {
[16:20:49.456]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:49.456]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:49.456]                       search = base::search(), system = base::Sys.info())
[16:20:49.456]                   }
[16:20:49.456]                   ...future.conditions[[length(...future.conditions) + 
[16:20:49.456]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:49.456]                     cond$call), session = sessionInformation(), 
[16:20:49.456]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:49.456]                   signalCondition(cond)
[16:20:49.456]                 }
[16:20:49.456]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:49.456]                 "immediateCondition"))) {
[16:20:49.456]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:49.456]                   ...future.conditions[[length(...future.conditions) + 
[16:20:49.456]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:49.456]                   if (TRUE && !signal) {
[16:20:49.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:49.456]                     {
[16:20:49.456]                       inherits <- base::inherits
[16:20:49.456]                       invokeRestart <- base::invokeRestart
[16:20:49.456]                       is.null <- base::is.null
[16:20:49.456]                       muffled <- FALSE
[16:20:49.456]                       if (inherits(cond, "message")) {
[16:20:49.456]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:49.456]                         if (muffled) 
[16:20:49.456]                           invokeRestart("muffleMessage")
[16:20:49.456]                       }
[16:20:49.456]                       else if (inherits(cond, "warning")) {
[16:20:49.456]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:49.456]                         if (muffled) 
[16:20:49.456]                           invokeRestart("muffleWarning")
[16:20:49.456]                       }
[16:20:49.456]                       else if (inherits(cond, "condition")) {
[16:20:49.456]                         if (!is.null(pattern)) {
[16:20:49.456]                           computeRestarts <- base::computeRestarts
[16:20:49.456]                           grepl <- base::grepl
[16:20:49.456]                           restarts <- computeRestarts(cond)
[16:20:49.456]                           for (restart in restarts) {
[16:20:49.456]                             name <- restart$name
[16:20:49.456]                             if (is.null(name)) 
[16:20:49.456]                               next
[16:20:49.456]                             if (!grepl(pattern, name)) 
[16:20:49.456]                               next
[16:20:49.456]                             invokeRestart(restart)
[16:20:49.456]                             muffled <- TRUE
[16:20:49.456]                             break
[16:20:49.456]                           }
[16:20:49.456]                         }
[16:20:49.456]                       }
[16:20:49.456]                       invisible(muffled)
[16:20:49.456]                     }
[16:20:49.456]                     muffleCondition(cond, pattern = "^muffle")
[16:20:49.456]                   }
[16:20:49.456]                 }
[16:20:49.456]                 else {
[16:20:49.456]                   if (TRUE) {
[16:20:49.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:49.456]                     {
[16:20:49.456]                       inherits <- base::inherits
[16:20:49.456]                       invokeRestart <- base::invokeRestart
[16:20:49.456]                       is.null <- base::is.null
[16:20:49.456]                       muffled <- FALSE
[16:20:49.456]                       if (inherits(cond, "message")) {
[16:20:49.456]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:49.456]                         if (muffled) 
[16:20:49.456]                           invokeRestart("muffleMessage")
[16:20:49.456]                       }
[16:20:49.456]                       else if (inherits(cond, "warning")) {
[16:20:49.456]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:49.456]                         if (muffled) 
[16:20:49.456]                           invokeRestart("muffleWarning")
[16:20:49.456]                       }
[16:20:49.456]                       else if (inherits(cond, "condition")) {
[16:20:49.456]                         if (!is.null(pattern)) {
[16:20:49.456]                           computeRestarts <- base::computeRestarts
[16:20:49.456]                           grepl <- base::grepl
[16:20:49.456]                           restarts <- computeRestarts(cond)
[16:20:49.456]                           for (restart in restarts) {
[16:20:49.456]                             name <- restart$name
[16:20:49.456]                             if (is.null(name)) 
[16:20:49.456]                               next
[16:20:49.456]                             if (!grepl(pattern, name)) 
[16:20:49.456]                               next
[16:20:49.456]                             invokeRestart(restart)
[16:20:49.456]                             muffled <- TRUE
[16:20:49.456]                             break
[16:20:49.456]                           }
[16:20:49.456]                         }
[16:20:49.456]                       }
[16:20:49.456]                       invisible(muffled)
[16:20:49.456]                     }
[16:20:49.456]                     muffleCondition(cond, pattern = "^muffle")
[16:20:49.456]                   }
[16:20:49.456]                 }
[16:20:49.456]             }
[16:20:49.456]         }))
[16:20:49.456]     }, error = function(ex) {
[16:20:49.456]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:49.456]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:49.456]                 ...future.rng), started = ...future.startTime, 
[16:20:49.456]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:49.456]             version = "1.8"), class = "FutureResult")
[16:20:49.456]     }, finally = {
[16:20:49.456]         if (!identical(...future.workdir, getwd())) 
[16:20:49.456]             setwd(...future.workdir)
[16:20:49.456]         {
[16:20:49.456]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:49.456]                 ...future.oldOptions$nwarnings <- NULL
[16:20:49.456]             }
[16:20:49.456]             base::options(...future.oldOptions)
[16:20:49.456]             if (.Platform$OS.type == "windows") {
[16:20:49.456]                 old_names <- names(...future.oldEnvVars)
[16:20:49.456]                 envs <- base::Sys.getenv()
[16:20:49.456]                 names <- names(envs)
[16:20:49.456]                 common <- intersect(names, old_names)
[16:20:49.456]                 added <- setdiff(names, old_names)
[16:20:49.456]                 removed <- setdiff(old_names, names)
[16:20:49.456]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:49.456]                   envs[common]]
[16:20:49.456]                 NAMES <- toupper(changed)
[16:20:49.456]                 args <- list()
[16:20:49.456]                 for (kk in seq_along(NAMES)) {
[16:20:49.456]                   name <- changed[[kk]]
[16:20:49.456]                   NAME <- NAMES[[kk]]
[16:20:49.456]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:49.456]                     next
[16:20:49.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:49.456]                 }
[16:20:49.456]                 NAMES <- toupper(added)
[16:20:49.456]                 for (kk in seq_along(NAMES)) {
[16:20:49.456]                   name <- added[[kk]]
[16:20:49.456]                   NAME <- NAMES[[kk]]
[16:20:49.456]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:49.456]                     next
[16:20:49.456]                   args[[name]] <- ""
[16:20:49.456]                 }
[16:20:49.456]                 NAMES <- toupper(removed)
[16:20:49.456]                 for (kk in seq_along(NAMES)) {
[16:20:49.456]                   name <- removed[[kk]]
[16:20:49.456]                   NAME <- NAMES[[kk]]
[16:20:49.456]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:49.456]                     next
[16:20:49.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:49.456]                 }
[16:20:49.456]                 if (length(args) > 0) 
[16:20:49.456]                   base::do.call(base::Sys.setenv, args = args)
[16:20:49.456]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:49.456]             }
[16:20:49.456]             else {
[16:20:49.456]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:49.456]             }
[16:20:49.456]             {
[16:20:49.456]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:49.456]                   0L) {
[16:20:49.456]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:49.456]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:49.456]                   base::options(opts)
[16:20:49.456]                 }
[16:20:49.456]                 {
[16:20:49.456]                   {
[16:20:49.456]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:49.456]                     NULL
[16:20:49.456]                   }
[16:20:49.456]                   options(future.plan = NULL)
[16:20:49.456]                   if (is.na(NA_character_)) 
[16:20:49.456]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:49.456]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:49.456]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:49.456]                     .init = FALSE)
[16:20:49.456]                 }
[16:20:49.456]             }
[16:20:49.456]         }
[16:20:49.456]     })
[16:20:49.456]     if (TRUE) {
[16:20:49.456]         base::sink(type = "output", split = FALSE)
[16:20:49.456]         if (TRUE) {
[16:20:49.456]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:49.456]         }
[16:20:49.456]         else {
[16:20:49.456]             ...future.result["stdout"] <- base::list(NULL)
[16:20:49.456]         }
[16:20:49.456]         base::close(...future.stdout)
[16:20:49.456]         ...future.stdout <- NULL
[16:20:49.456]     }
[16:20:49.456]     ...future.result$conditions <- ...future.conditions
[16:20:49.456]     ...future.result$finished <- base::Sys.time()
[16:20:49.456]     ...future.result
[16:20:49.456] }
[16:20:49.509] MultisessionFuture started
[16:20:49.510] result() for ClusterFuture ...
[16:20:49.511] receiveMessageFromWorker() for ClusterFuture ...
[16:20:49.511] - Validating connection of MultisessionFuture
[16:20:49.543] - received message: FutureResult
[16:20:49.544] - Received FutureResult
[16:20:49.544] - Erased future from FutureRegistry
[16:20:49.544] result() for ClusterFuture ...
[16:20:49.544] - result already collected: FutureResult
[16:20:49.544] result() for ClusterFuture ... done
[16:20:49.544] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:49.544] result() for ClusterFuture ... done
[16:20:49.545] result() for ClusterFuture ...
[16:20:49.545] - result already collected: FutureResult
[16:20:49.545] result() for ClusterFuture ... done
[16:20:49.545] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:20:49.549] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[16:20:49.549] getGlobalsAndPackages() ...
[16:20:49.549] Searching for globals...
[16:20:49.551] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:20:49.551] Searching for globals ... DONE
[16:20:49.551] Resolving globals: FALSE
[16:20:49.552] The total size of the 2 globals is 896 bytes (896 bytes)
[16:20:49.553] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:20:49.553] - globals: [2] ‘weight’, ‘group’
[16:20:49.553] - packages: [1] ‘stats’
[16:20:49.553] getGlobalsAndPackages() ... DONE
[16:20:49.553] run() for ‘Future’ ...
[16:20:49.553] - state: ‘created’
[16:20:49.554] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:49.568] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:49.568] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:49.568]   - Field: ‘node’
[16:20:49.569]   - Field: ‘label’
[16:20:49.569]   - Field: ‘local’
[16:20:49.569]   - Field: ‘owner’
[16:20:49.569]   - Field: ‘envir’
[16:20:49.569]   - Field: ‘workers’
[16:20:49.569]   - Field: ‘packages’
[16:20:49.569]   - Field: ‘gc’
[16:20:49.569]   - Field: ‘conditions’
[16:20:49.569]   - Field: ‘persistent’
[16:20:49.570]   - Field: ‘expr’
[16:20:49.570]   - Field: ‘uuid’
[16:20:49.570]   - Field: ‘seed’
[16:20:49.570]   - Field: ‘version’
[16:20:49.570]   - Field: ‘result’
[16:20:49.570]   - Field: ‘asynchronous’
[16:20:49.570]   - Field: ‘calls’
[16:20:49.570]   - Field: ‘globals’
[16:20:49.570]   - Field: ‘stdout’
[16:20:49.571]   - Field: ‘earlySignal’
[16:20:49.571]   - Field: ‘lazy’
[16:20:49.571]   - Field: ‘state’
[16:20:49.571] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:49.571] - Launch lazy future ...
[16:20:49.571] Packages needed by the future expression (n = 1): ‘stats’
[16:20:49.572] Packages needed by future strategies (n = 0): <none>
[16:20:49.572] {
[16:20:49.572]     {
[16:20:49.572]         {
[16:20:49.572]             ...future.startTime <- base::Sys.time()
[16:20:49.572]             {
[16:20:49.572]                 {
[16:20:49.572]                   {
[16:20:49.572]                     {
[16:20:49.572]                       {
[16:20:49.572]                         base::local({
[16:20:49.572]                           has_future <- base::requireNamespace("future", 
[16:20:49.572]                             quietly = TRUE)
[16:20:49.572]                           if (has_future) {
[16:20:49.572]                             ns <- base::getNamespace("future")
[16:20:49.572]                             version <- ns[[".package"]][["version"]]
[16:20:49.572]                             if (is.null(version)) 
[16:20:49.572]                               version <- utils::packageVersion("future")
[16:20:49.572]                           }
[16:20:49.572]                           else {
[16:20:49.572]                             version <- NULL
[16:20:49.572]                           }
[16:20:49.572]                           if (!has_future || version < "1.8.0") {
[16:20:49.572]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:49.572]                               "", base::R.version$version.string), 
[16:20:49.572]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:49.572]                                 base::R.version$platform, 8 * 
[16:20:49.572]                                   base::.Machine$sizeof.pointer), 
[16:20:49.572]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:49.572]                                 "release", "version")], collapse = " "), 
[16:20:49.572]                               hostname = base::Sys.info()[["nodename"]])
[16:20:49.572]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:49.572]                               info)
[16:20:49.572]                             info <- base::paste(info, collapse = "; ")
[16:20:49.572]                             if (!has_future) {
[16:20:49.572]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:49.572]                                 info)
[16:20:49.572]                             }
[16:20:49.572]                             else {
[16:20:49.572]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:49.572]                                 info, version)
[16:20:49.572]                             }
[16:20:49.572]                             base::stop(msg)
[16:20:49.572]                           }
[16:20:49.572]                         })
[16:20:49.572]                       }
[16:20:49.572]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:49.572]                       base::options(mc.cores = 1L)
[16:20:49.572]                     }
[16:20:49.572]                     base::local({
[16:20:49.572]                       for (pkg in "stats") {
[16:20:49.572]                         base::loadNamespace(pkg)
[16:20:49.572]                         base::library(pkg, character.only = TRUE)
[16:20:49.572]                       }
[16:20:49.572]                     })
[16:20:49.572]                   }
[16:20:49.572]                   ...future.strategy.old <- future::plan("list")
[16:20:49.572]                   options(future.plan = NULL)
[16:20:49.572]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:49.572]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:49.572]                 }
[16:20:49.572]                 ...future.workdir <- getwd()
[16:20:49.572]             }
[16:20:49.572]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:49.572]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:49.572]         }
[16:20:49.572]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:49.572]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:49.572]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:49.572]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:49.572]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:49.572]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:49.572]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:49.572]             base::names(...future.oldOptions))
[16:20:49.572]     }
[16:20:49.572]     if (FALSE) {
[16:20:49.572]     }
[16:20:49.572]     else {
[16:20:49.572]         if (TRUE) {
[16:20:49.572]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:49.572]                 open = "w")
[16:20:49.572]         }
[16:20:49.572]         else {
[16:20:49.572]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:49.572]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:49.572]         }
[16:20:49.572]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:49.572]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:49.572]             base::sink(type = "output", split = FALSE)
[16:20:49.572]             base::close(...future.stdout)
[16:20:49.572]         }, add = TRUE)
[16:20:49.572]     }
[16:20:49.572]     ...future.frame <- base::sys.nframe()
[16:20:49.572]     ...future.conditions <- base::list()
[16:20:49.572]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:49.572]     if (FALSE) {
[16:20:49.572]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:49.572]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:49.572]     }
[16:20:49.572]     ...future.result <- base::tryCatch({
[16:20:49.572]         base::withCallingHandlers({
[16:20:49.572]             ...future.value <- base::withVisible(base::local({
[16:20:49.572]                 ...future.makeSendCondition <- base::local({
[16:20:49.572]                   sendCondition <- NULL
[16:20:49.572]                   function(frame = 1L) {
[16:20:49.572]                     if (is.function(sendCondition)) 
[16:20:49.572]                       return(sendCondition)
[16:20:49.572]                     ns <- getNamespace("parallel")
[16:20:49.572]                     if (exists("sendData", mode = "function", 
[16:20:49.572]                       envir = ns)) {
[16:20:49.572]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:49.572]                         envir = ns)
[16:20:49.572]                       envir <- sys.frame(frame)
[16:20:49.572]                       master <- NULL
[16:20:49.572]                       while (!identical(envir, .GlobalEnv) && 
[16:20:49.572]                         !identical(envir, emptyenv())) {
[16:20:49.572]                         if (exists("master", mode = "list", envir = envir, 
[16:20:49.572]                           inherits = FALSE)) {
[16:20:49.572]                           master <- get("master", mode = "list", 
[16:20:49.572]                             envir = envir, inherits = FALSE)
[16:20:49.572]                           if (inherits(master, c("SOCKnode", 
[16:20:49.572]                             "SOCK0node"))) {
[16:20:49.572]                             sendCondition <<- function(cond) {
[16:20:49.572]                               data <- list(type = "VALUE", value = cond, 
[16:20:49.572]                                 success = TRUE)
[16:20:49.572]                               parallel_sendData(master, data)
[16:20:49.572]                             }
[16:20:49.572]                             return(sendCondition)
[16:20:49.572]                           }
[16:20:49.572]                         }
[16:20:49.572]                         frame <- frame + 1L
[16:20:49.572]                         envir <- sys.frame(frame)
[16:20:49.572]                       }
[16:20:49.572]                     }
[16:20:49.572]                     sendCondition <<- function(cond) NULL
[16:20:49.572]                   }
[16:20:49.572]                 })
[16:20:49.572]                 withCallingHandlers({
[16:20:49.572]                   {
[16:20:49.572]                     lm(weight ~ group - 1)
[16:20:49.572]                   }
[16:20:49.572]                 }, immediateCondition = function(cond) {
[16:20:49.572]                   sendCondition <- ...future.makeSendCondition()
[16:20:49.572]                   sendCondition(cond)
[16:20:49.572]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:49.572]                   {
[16:20:49.572]                     inherits <- base::inherits
[16:20:49.572]                     invokeRestart <- base::invokeRestart
[16:20:49.572]                     is.null <- base::is.null
[16:20:49.572]                     muffled <- FALSE
[16:20:49.572]                     if (inherits(cond, "message")) {
[16:20:49.572]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:49.572]                       if (muffled) 
[16:20:49.572]                         invokeRestart("muffleMessage")
[16:20:49.572]                     }
[16:20:49.572]                     else if (inherits(cond, "warning")) {
[16:20:49.572]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:49.572]                       if (muffled) 
[16:20:49.572]                         invokeRestart("muffleWarning")
[16:20:49.572]                     }
[16:20:49.572]                     else if (inherits(cond, "condition")) {
[16:20:49.572]                       if (!is.null(pattern)) {
[16:20:49.572]                         computeRestarts <- base::computeRestarts
[16:20:49.572]                         grepl <- base::grepl
[16:20:49.572]                         restarts <- computeRestarts(cond)
[16:20:49.572]                         for (restart in restarts) {
[16:20:49.572]                           name <- restart$name
[16:20:49.572]                           if (is.null(name)) 
[16:20:49.572]                             next
[16:20:49.572]                           if (!grepl(pattern, name)) 
[16:20:49.572]                             next
[16:20:49.572]                           invokeRestart(restart)
[16:20:49.572]                           muffled <- TRUE
[16:20:49.572]                           break
[16:20:49.572]                         }
[16:20:49.572]                       }
[16:20:49.572]                     }
[16:20:49.572]                     invisible(muffled)
[16:20:49.572]                   }
[16:20:49.572]                   muffleCondition(cond)
[16:20:49.572]                 })
[16:20:49.572]             }))
[16:20:49.572]             future::FutureResult(value = ...future.value$value, 
[16:20:49.572]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:49.572]                   ...future.rng), globalenv = if (FALSE) 
[16:20:49.572]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:49.572]                     ...future.globalenv.names))
[16:20:49.572]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:49.572]         }, condition = base::local({
[16:20:49.572]             c <- base::c
[16:20:49.572]             inherits <- base::inherits
[16:20:49.572]             invokeRestart <- base::invokeRestart
[16:20:49.572]             length <- base::length
[16:20:49.572]             list <- base::list
[16:20:49.572]             seq.int <- base::seq.int
[16:20:49.572]             signalCondition <- base::signalCondition
[16:20:49.572]             sys.calls <- base::sys.calls
[16:20:49.572]             `[[` <- base::`[[`
[16:20:49.572]             `+` <- base::`+`
[16:20:49.572]             `<<-` <- base::`<<-`
[16:20:49.572]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:49.572]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:49.572]                   3L)]
[16:20:49.572]             }
[16:20:49.572]             function(cond) {
[16:20:49.572]                 is_error <- inherits(cond, "error")
[16:20:49.572]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:49.572]                   NULL)
[16:20:49.572]                 if (is_error) {
[16:20:49.572]                   sessionInformation <- function() {
[16:20:49.572]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:49.572]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:49.572]                       search = base::search(), system = base::Sys.info())
[16:20:49.572]                   }
[16:20:49.572]                   ...future.conditions[[length(...future.conditions) + 
[16:20:49.572]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:49.572]                     cond$call), session = sessionInformation(), 
[16:20:49.572]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:49.572]                   signalCondition(cond)
[16:20:49.572]                 }
[16:20:49.572]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:49.572]                 "immediateCondition"))) {
[16:20:49.572]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:49.572]                   ...future.conditions[[length(...future.conditions) + 
[16:20:49.572]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:49.572]                   if (TRUE && !signal) {
[16:20:49.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:49.572]                     {
[16:20:49.572]                       inherits <- base::inherits
[16:20:49.572]                       invokeRestart <- base::invokeRestart
[16:20:49.572]                       is.null <- base::is.null
[16:20:49.572]                       muffled <- FALSE
[16:20:49.572]                       if (inherits(cond, "message")) {
[16:20:49.572]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:49.572]                         if (muffled) 
[16:20:49.572]                           invokeRestart("muffleMessage")
[16:20:49.572]                       }
[16:20:49.572]                       else if (inherits(cond, "warning")) {
[16:20:49.572]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:49.572]                         if (muffled) 
[16:20:49.572]                           invokeRestart("muffleWarning")
[16:20:49.572]                       }
[16:20:49.572]                       else if (inherits(cond, "condition")) {
[16:20:49.572]                         if (!is.null(pattern)) {
[16:20:49.572]                           computeRestarts <- base::computeRestarts
[16:20:49.572]                           grepl <- base::grepl
[16:20:49.572]                           restarts <- computeRestarts(cond)
[16:20:49.572]                           for (restart in restarts) {
[16:20:49.572]                             name <- restart$name
[16:20:49.572]                             if (is.null(name)) 
[16:20:49.572]                               next
[16:20:49.572]                             if (!grepl(pattern, name)) 
[16:20:49.572]                               next
[16:20:49.572]                             invokeRestart(restart)
[16:20:49.572]                             muffled <- TRUE
[16:20:49.572]                             break
[16:20:49.572]                           }
[16:20:49.572]                         }
[16:20:49.572]                       }
[16:20:49.572]                       invisible(muffled)
[16:20:49.572]                     }
[16:20:49.572]                     muffleCondition(cond, pattern = "^muffle")
[16:20:49.572]                   }
[16:20:49.572]                 }
[16:20:49.572]                 else {
[16:20:49.572]                   if (TRUE) {
[16:20:49.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:49.572]                     {
[16:20:49.572]                       inherits <- base::inherits
[16:20:49.572]                       invokeRestart <- base::invokeRestart
[16:20:49.572]                       is.null <- base::is.null
[16:20:49.572]                       muffled <- FALSE
[16:20:49.572]                       if (inherits(cond, "message")) {
[16:20:49.572]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:49.572]                         if (muffled) 
[16:20:49.572]                           invokeRestart("muffleMessage")
[16:20:49.572]                       }
[16:20:49.572]                       else if (inherits(cond, "warning")) {
[16:20:49.572]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:49.572]                         if (muffled) 
[16:20:49.572]                           invokeRestart("muffleWarning")
[16:20:49.572]                       }
[16:20:49.572]                       else if (inherits(cond, "condition")) {
[16:20:49.572]                         if (!is.null(pattern)) {
[16:20:49.572]                           computeRestarts <- base::computeRestarts
[16:20:49.572]                           grepl <- base::grepl
[16:20:49.572]                           restarts <- computeRestarts(cond)
[16:20:49.572]                           for (restart in restarts) {
[16:20:49.572]                             name <- restart$name
[16:20:49.572]                             if (is.null(name)) 
[16:20:49.572]                               next
[16:20:49.572]                             if (!grepl(pattern, name)) 
[16:20:49.572]                               next
[16:20:49.572]                             invokeRestart(restart)
[16:20:49.572]                             muffled <- TRUE
[16:20:49.572]                             break
[16:20:49.572]                           }
[16:20:49.572]                         }
[16:20:49.572]                       }
[16:20:49.572]                       invisible(muffled)
[16:20:49.572]                     }
[16:20:49.572]                     muffleCondition(cond, pattern = "^muffle")
[16:20:49.572]                   }
[16:20:49.572]                 }
[16:20:49.572]             }
[16:20:49.572]         }))
[16:20:49.572]     }, error = function(ex) {
[16:20:49.572]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:49.572]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:49.572]                 ...future.rng), started = ...future.startTime, 
[16:20:49.572]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:49.572]             version = "1.8"), class = "FutureResult")
[16:20:49.572]     }, finally = {
[16:20:49.572]         if (!identical(...future.workdir, getwd())) 
[16:20:49.572]             setwd(...future.workdir)
[16:20:49.572]         {
[16:20:49.572]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:49.572]                 ...future.oldOptions$nwarnings <- NULL
[16:20:49.572]             }
[16:20:49.572]             base::options(...future.oldOptions)
[16:20:49.572]             if (.Platform$OS.type == "windows") {
[16:20:49.572]                 old_names <- names(...future.oldEnvVars)
[16:20:49.572]                 envs <- base::Sys.getenv()
[16:20:49.572]                 names <- names(envs)
[16:20:49.572]                 common <- intersect(names, old_names)
[16:20:49.572]                 added <- setdiff(names, old_names)
[16:20:49.572]                 removed <- setdiff(old_names, names)
[16:20:49.572]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:49.572]                   envs[common]]
[16:20:49.572]                 NAMES <- toupper(changed)
[16:20:49.572]                 args <- list()
[16:20:49.572]                 for (kk in seq_along(NAMES)) {
[16:20:49.572]                   name <- changed[[kk]]
[16:20:49.572]                   NAME <- NAMES[[kk]]
[16:20:49.572]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:49.572]                     next
[16:20:49.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:49.572]                 }
[16:20:49.572]                 NAMES <- toupper(added)
[16:20:49.572]                 for (kk in seq_along(NAMES)) {
[16:20:49.572]                   name <- added[[kk]]
[16:20:49.572]                   NAME <- NAMES[[kk]]
[16:20:49.572]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:49.572]                     next
[16:20:49.572]                   args[[name]] <- ""
[16:20:49.572]                 }
[16:20:49.572]                 NAMES <- toupper(removed)
[16:20:49.572]                 for (kk in seq_along(NAMES)) {
[16:20:49.572]                   name <- removed[[kk]]
[16:20:49.572]                   NAME <- NAMES[[kk]]
[16:20:49.572]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:49.572]                     next
[16:20:49.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:49.572]                 }
[16:20:49.572]                 if (length(args) > 0) 
[16:20:49.572]                   base::do.call(base::Sys.setenv, args = args)
[16:20:49.572]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:49.572]             }
[16:20:49.572]             else {
[16:20:49.572]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:49.572]             }
[16:20:49.572]             {
[16:20:49.572]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:49.572]                   0L) {
[16:20:49.572]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:49.572]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:49.572]                   base::options(opts)
[16:20:49.572]                 }
[16:20:49.572]                 {
[16:20:49.572]                   {
[16:20:49.572]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:49.572]                     NULL
[16:20:49.572]                   }
[16:20:49.572]                   options(future.plan = NULL)
[16:20:49.572]                   if (is.na(NA_character_)) 
[16:20:49.572]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:49.572]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:49.572]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:49.572]                     .init = FALSE)
[16:20:49.572]                 }
[16:20:49.572]             }
[16:20:49.572]         }
[16:20:49.572]     })
[16:20:49.572]     if (TRUE) {
[16:20:49.572]         base::sink(type = "output", split = FALSE)
[16:20:49.572]         if (TRUE) {
[16:20:49.572]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:49.572]         }
[16:20:49.572]         else {
[16:20:49.572]             ...future.result["stdout"] <- base::list(NULL)
[16:20:49.572]         }
[16:20:49.572]         base::close(...future.stdout)
[16:20:49.572]         ...future.stdout <- NULL
[16:20:49.572]     }
[16:20:49.572]     ...future.result$conditions <- ...future.conditions
[16:20:49.572]     ...future.result$finished <- base::Sys.time()
[16:20:49.572]     ...future.result
[16:20:49.572] }
[16:20:49.575] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[16:20:49.575] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[16:20:49.576] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[16:20:49.576] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[16:20:49.576] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[16:20:49.577] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[16:20:49.577] MultisessionFuture started
[16:20:49.577] - Launch lazy future ... done
[16:20:49.577] run() for ‘MultisessionFuture’ ... done
[16:20:49.578] result() for ClusterFuture ...
[16:20:49.578] receiveMessageFromWorker() for ClusterFuture ...
[16:20:49.578] - Validating connection of MultisessionFuture
[16:20:49.629] - received message: FutureResult
[16:20:49.629] - Received FutureResult
[16:20:49.629] - Erased future from FutureRegistry
[16:20:49.629] result() for ClusterFuture ...
[16:20:49.629] - result already collected: FutureResult
[16:20:49.629] result() for ClusterFuture ... done
[16:20:49.629] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:49.630] result() for ClusterFuture ... done
[16:20:49.630] result() for ClusterFuture ...
[16:20:49.630] - result already collected: FutureResult
[16:20:49.630] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:20:49.632] getGlobalsAndPackages() ...
[16:20:49.632] Searching for globals...
[16:20:49.634] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:20:49.634] Searching for globals ... DONE
[16:20:49.634] Resolving globals: FALSE
[16:20:49.635] The total size of the 2 globals is 896 bytes (896 bytes)
[16:20:49.635] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:20:49.636] - globals: [2] ‘weight’, ‘group’
[16:20:49.636] - packages: [1] ‘stats’
[16:20:49.636] getGlobalsAndPackages() ... DONE
[16:20:49.636] run() for ‘Future’ ...
[16:20:49.636] - state: ‘created’
[16:20:49.637] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:49.651] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:49.651] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:49.652]   - Field: ‘node’
[16:20:49.652]   - Field: ‘label’
[16:20:49.652]   - Field: ‘local’
[16:20:49.652]   - Field: ‘owner’
[16:20:49.652]   - Field: ‘envir’
[16:20:49.652]   - Field: ‘workers’
[16:20:49.652]   - Field: ‘packages’
[16:20:49.652]   - Field: ‘gc’
[16:20:49.652]   - Field: ‘conditions’
[16:20:49.653]   - Field: ‘persistent’
[16:20:49.653]   - Field: ‘expr’
[16:20:49.653]   - Field: ‘uuid’
[16:20:49.653]   - Field: ‘seed’
[16:20:49.653]   - Field: ‘version’
[16:20:49.653]   - Field: ‘result’
[16:20:49.653]   - Field: ‘asynchronous’
[16:20:49.653]   - Field: ‘calls’
[16:20:49.653]   - Field: ‘globals’
[16:20:49.654]   - Field: ‘stdout’
[16:20:49.654]   - Field: ‘earlySignal’
[16:20:49.654]   - Field: ‘lazy’
[16:20:49.654]   - Field: ‘state’
[16:20:49.654] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:49.654] - Launch lazy future ...
[16:20:49.654] Packages needed by the future expression (n = 1): ‘stats’
[16:20:49.655] Packages needed by future strategies (n = 0): <none>
[16:20:49.655] {
[16:20:49.655]     {
[16:20:49.655]         {
[16:20:49.655]             ...future.startTime <- base::Sys.time()
[16:20:49.655]             {
[16:20:49.655]                 {
[16:20:49.655]                   {
[16:20:49.655]                     {
[16:20:49.655]                       {
[16:20:49.655]                         base::local({
[16:20:49.655]                           has_future <- base::requireNamespace("future", 
[16:20:49.655]                             quietly = TRUE)
[16:20:49.655]                           if (has_future) {
[16:20:49.655]                             ns <- base::getNamespace("future")
[16:20:49.655]                             version <- ns[[".package"]][["version"]]
[16:20:49.655]                             if (is.null(version)) 
[16:20:49.655]                               version <- utils::packageVersion("future")
[16:20:49.655]                           }
[16:20:49.655]                           else {
[16:20:49.655]                             version <- NULL
[16:20:49.655]                           }
[16:20:49.655]                           if (!has_future || version < "1.8.0") {
[16:20:49.655]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:49.655]                               "", base::R.version$version.string), 
[16:20:49.655]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:49.655]                                 base::R.version$platform, 8 * 
[16:20:49.655]                                   base::.Machine$sizeof.pointer), 
[16:20:49.655]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:49.655]                                 "release", "version")], collapse = " "), 
[16:20:49.655]                               hostname = base::Sys.info()[["nodename"]])
[16:20:49.655]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:49.655]                               info)
[16:20:49.655]                             info <- base::paste(info, collapse = "; ")
[16:20:49.655]                             if (!has_future) {
[16:20:49.655]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:49.655]                                 info)
[16:20:49.655]                             }
[16:20:49.655]                             else {
[16:20:49.655]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:49.655]                                 info, version)
[16:20:49.655]                             }
[16:20:49.655]                             base::stop(msg)
[16:20:49.655]                           }
[16:20:49.655]                         })
[16:20:49.655]                       }
[16:20:49.655]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:49.655]                       base::options(mc.cores = 1L)
[16:20:49.655]                     }
[16:20:49.655]                     base::local({
[16:20:49.655]                       for (pkg in "stats") {
[16:20:49.655]                         base::loadNamespace(pkg)
[16:20:49.655]                         base::library(pkg, character.only = TRUE)
[16:20:49.655]                       }
[16:20:49.655]                     })
[16:20:49.655]                   }
[16:20:49.655]                   ...future.strategy.old <- future::plan("list")
[16:20:49.655]                   options(future.plan = NULL)
[16:20:49.655]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:49.655]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:49.655]                 }
[16:20:49.655]                 ...future.workdir <- getwd()
[16:20:49.655]             }
[16:20:49.655]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:49.655]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:49.655]         }
[16:20:49.655]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:49.655]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:49.655]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:49.655]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:49.655]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:49.655]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:49.655]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:49.655]             base::names(...future.oldOptions))
[16:20:49.655]     }
[16:20:49.655]     if (FALSE) {
[16:20:49.655]     }
[16:20:49.655]     else {
[16:20:49.655]         if (TRUE) {
[16:20:49.655]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:49.655]                 open = "w")
[16:20:49.655]         }
[16:20:49.655]         else {
[16:20:49.655]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:49.655]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:49.655]         }
[16:20:49.655]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:49.655]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:49.655]             base::sink(type = "output", split = FALSE)
[16:20:49.655]             base::close(...future.stdout)
[16:20:49.655]         }, add = TRUE)
[16:20:49.655]     }
[16:20:49.655]     ...future.frame <- base::sys.nframe()
[16:20:49.655]     ...future.conditions <- base::list()
[16:20:49.655]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:49.655]     if (FALSE) {
[16:20:49.655]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:49.655]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:49.655]     }
[16:20:49.655]     ...future.result <- base::tryCatch({
[16:20:49.655]         base::withCallingHandlers({
[16:20:49.655]             ...future.value <- base::withVisible(base::local({
[16:20:49.655]                 ...future.makeSendCondition <- base::local({
[16:20:49.655]                   sendCondition <- NULL
[16:20:49.655]                   function(frame = 1L) {
[16:20:49.655]                     if (is.function(sendCondition)) 
[16:20:49.655]                       return(sendCondition)
[16:20:49.655]                     ns <- getNamespace("parallel")
[16:20:49.655]                     if (exists("sendData", mode = "function", 
[16:20:49.655]                       envir = ns)) {
[16:20:49.655]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:49.655]                         envir = ns)
[16:20:49.655]                       envir <- sys.frame(frame)
[16:20:49.655]                       master <- NULL
[16:20:49.655]                       while (!identical(envir, .GlobalEnv) && 
[16:20:49.655]                         !identical(envir, emptyenv())) {
[16:20:49.655]                         if (exists("master", mode = "list", envir = envir, 
[16:20:49.655]                           inherits = FALSE)) {
[16:20:49.655]                           master <- get("master", mode = "list", 
[16:20:49.655]                             envir = envir, inherits = FALSE)
[16:20:49.655]                           if (inherits(master, c("SOCKnode", 
[16:20:49.655]                             "SOCK0node"))) {
[16:20:49.655]                             sendCondition <<- function(cond) {
[16:20:49.655]                               data <- list(type = "VALUE", value = cond, 
[16:20:49.655]                                 success = TRUE)
[16:20:49.655]                               parallel_sendData(master, data)
[16:20:49.655]                             }
[16:20:49.655]                             return(sendCondition)
[16:20:49.655]                           }
[16:20:49.655]                         }
[16:20:49.655]                         frame <- frame + 1L
[16:20:49.655]                         envir <- sys.frame(frame)
[16:20:49.655]                       }
[16:20:49.655]                     }
[16:20:49.655]                     sendCondition <<- function(cond) NULL
[16:20:49.655]                   }
[16:20:49.655]                 })
[16:20:49.655]                 withCallingHandlers({
[16:20:49.655]                   {
[16:20:49.655]                     lm(weight ~ group - 1)
[16:20:49.655]                   }
[16:20:49.655]                 }, immediateCondition = function(cond) {
[16:20:49.655]                   sendCondition <- ...future.makeSendCondition()
[16:20:49.655]                   sendCondition(cond)
[16:20:49.655]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:49.655]                   {
[16:20:49.655]                     inherits <- base::inherits
[16:20:49.655]                     invokeRestart <- base::invokeRestart
[16:20:49.655]                     is.null <- base::is.null
[16:20:49.655]                     muffled <- FALSE
[16:20:49.655]                     if (inherits(cond, "message")) {
[16:20:49.655]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:49.655]                       if (muffled) 
[16:20:49.655]                         invokeRestart("muffleMessage")
[16:20:49.655]                     }
[16:20:49.655]                     else if (inherits(cond, "warning")) {
[16:20:49.655]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:49.655]                       if (muffled) 
[16:20:49.655]                         invokeRestart("muffleWarning")
[16:20:49.655]                     }
[16:20:49.655]                     else if (inherits(cond, "condition")) {
[16:20:49.655]                       if (!is.null(pattern)) {
[16:20:49.655]                         computeRestarts <- base::computeRestarts
[16:20:49.655]                         grepl <- base::grepl
[16:20:49.655]                         restarts <- computeRestarts(cond)
[16:20:49.655]                         for (restart in restarts) {
[16:20:49.655]                           name <- restart$name
[16:20:49.655]                           if (is.null(name)) 
[16:20:49.655]                             next
[16:20:49.655]                           if (!grepl(pattern, name)) 
[16:20:49.655]                             next
[16:20:49.655]                           invokeRestart(restart)
[16:20:49.655]                           muffled <- TRUE
[16:20:49.655]                           break
[16:20:49.655]                         }
[16:20:49.655]                       }
[16:20:49.655]                     }
[16:20:49.655]                     invisible(muffled)
[16:20:49.655]                   }
[16:20:49.655]                   muffleCondition(cond)
[16:20:49.655]                 })
[16:20:49.655]             }))
[16:20:49.655]             future::FutureResult(value = ...future.value$value, 
[16:20:49.655]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:49.655]                   ...future.rng), globalenv = if (FALSE) 
[16:20:49.655]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:49.655]                     ...future.globalenv.names))
[16:20:49.655]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:49.655]         }, condition = base::local({
[16:20:49.655]             c <- base::c
[16:20:49.655]             inherits <- base::inherits
[16:20:49.655]             invokeRestart <- base::invokeRestart
[16:20:49.655]             length <- base::length
[16:20:49.655]             list <- base::list
[16:20:49.655]             seq.int <- base::seq.int
[16:20:49.655]             signalCondition <- base::signalCondition
[16:20:49.655]             sys.calls <- base::sys.calls
[16:20:49.655]             `[[` <- base::`[[`
[16:20:49.655]             `+` <- base::`+`
[16:20:49.655]             `<<-` <- base::`<<-`
[16:20:49.655]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:49.655]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:49.655]                   3L)]
[16:20:49.655]             }
[16:20:49.655]             function(cond) {
[16:20:49.655]                 is_error <- inherits(cond, "error")
[16:20:49.655]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:49.655]                   NULL)
[16:20:49.655]                 if (is_error) {
[16:20:49.655]                   sessionInformation <- function() {
[16:20:49.655]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:49.655]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:49.655]                       search = base::search(), system = base::Sys.info())
[16:20:49.655]                   }
[16:20:49.655]                   ...future.conditions[[length(...future.conditions) + 
[16:20:49.655]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:49.655]                     cond$call), session = sessionInformation(), 
[16:20:49.655]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:49.655]                   signalCondition(cond)
[16:20:49.655]                 }
[16:20:49.655]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:49.655]                 "immediateCondition"))) {
[16:20:49.655]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:49.655]                   ...future.conditions[[length(...future.conditions) + 
[16:20:49.655]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:49.655]                   if (TRUE && !signal) {
[16:20:49.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:49.655]                     {
[16:20:49.655]                       inherits <- base::inherits
[16:20:49.655]                       invokeRestart <- base::invokeRestart
[16:20:49.655]                       is.null <- base::is.null
[16:20:49.655]                       muffled <- FALSE
[16:20:49.655]                       if (inherits(cond, "message")) {
[16:20:49.655]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:49.655]                         if (muffled) 
[16:20:49.655]                           invokeRestart("muffleMessage")
[16:20:49.655]                       }
[16:20:49.655]                       else if (inherits(cond, "warning")) {
[16:20:49.655]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:49.655]                         if (muffled) 
[16:20:49.655]                           invokeRestart("muffleWarning")
[16:20:49.655]                       }
[16:20:49.655]                       else if (inherits(cond, "condition")) {
[16:20:49.655]                         if (!is.null(pattern)) {
[16:20:49.655]                           computeRestarts <- base::computeRestarts
[16:20:49.655]                           grepl <- base::grepl
[16:20:49.655]                           restarts <- computeRestarts(cond)
[16:20:49.655]                           for (restart in restarts) {
[16:20:49.655]                             name <- restart$name
[16:20:49.655]                             if (is.null(name)) 
[16:20:49.655]                               next
[16:20:49.655]                             if (!grepl(pattern, name)) 
[16:20:49.655]                               next
[16:20:49.655]                             invokeRestart(restart)
[16:20:49.655]                             muffled <- TRUE
[16:20:49.655]                             break
[16:20:49.655]                           }
[16:20:49.655]                         }
[16:20:49.655]                       }
[16:20:49.655]                       invisible(muffled)
[16:20:49.655]                     }
[16:20:49.655]                     muffleCondition(cond, pattern = "^muffle")
[16:20:49.655]                   }
[16:20:49.655]                 }
[16:20:49.655]                 else {
[16:20:49.655]                   if (TRUE) {
[16:20:49.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:49.655]                     {
[16:20:49.655]                       inherits <- base::inherits
[16:20:49.655]                       invokeRestart <- base::invokeRestart
[16:20:49.655]                       is.null <- base::is.null
[16:20:49.655]                       muffled <- FALSE
[16:20:49.655]                       if (inherits(cond, "message")) {
[16:20:49.655]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:49.655]                         if (muffled) 
[16:20:49.655]                           invokeRestart("muffleMessage")
[16:20:49.655]                       }
[16:20:49.655]                       else if (inherits(cond, "warning")) {
[16:20:49.655]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:49.655]                         if (muffled) 
[16:20:49.655]                           invokeRestart("muffleWarning")
[16:20:49.655]                       }
[16:20:49.655]                       else if (inherits(cond, "condition")) {
[16:20:49.655]                         if (!is.null(pattern)) {
[16:20:49.655]                           computeRestarts <- base::computeRestarts
[16:20:49.655]                           grepl <- base::grepl
[16:20:49.655]                           restarts <- computeRestarts(cond)
[16:20:49.655]                           for (restart in restarts) {
[16:20:49.655]                             name <- restart$name
[16:20:49.655]                             if (is.null(name)) 
[16:20:49.655]                               next
[16:20:49.655]                             if (!grepl(pattern, name)) 
[16:20:49.655]                               next
[16:20:49.655]                             invokeRestart(restart)
[16:20:49.655]                             muffled <- TRUE
[16:20:49.655]                             break
[16:20:49.655]                           }
[16:20:49.655]                         }
[16:20:49.655]                       }
[16:20:49.655]                       invisible(muffled)
[16:20:49.655]                     }
[16:20:49.655]                     muffleCondition(cond, pattern = "^muffle")
[16:20:49.655]                   }
[16:20:49.655]                 }
[16:20:49.655]             }
[16:20:49.655]         }))
[16:20:49.655]     }, error = function(ex) {
[16:20:49.655]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:49.655]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:49.655]                 ...future.rng), started = ...future.startTime, 
[16:20:49.655]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:49.655]             version = "1.8"), class = "FutureResult")
[16:20:49.655]     }, finally = {
[16:20:49.655]         if (!identical(...future.workdir, getwd())) 
[16:20:49.655]             setwd(...future.workdir)
[16:20:49.655]         {
[16:20:49.655]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:49.655]                 ...future.oldOptions$nwarnings <- NULL
[16:20:49.655]             }
[16:20:49.655]             base::options(...future.oldOptions)
[16:20:49.655]             if (.Platform$OS.type == "windows") {
[16:20:49.655]                 old_names <- names(...future.oldEnvVars)
[16:20:49.655]                 envs <- base::Sys.getenv()
[16:20:49.655]                 names <- names(envs)
[16:20:49.655]                 common <- intersect(names, old_names)
[16:20:49.655]                 added <- setdiff(names, old_names)
[16:20:49.655]                 removed <- setdiff(old_names, names)
[16:20:49.655]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:49.655]                   envs[common]]
[16:20:49.655]                 NAMES <- toupper(changed)
[16:20:49.655]                 args <- list()
[16:20:49.655]                 for (kk in seq_along(NAMES)) {
[16:20:49.655]                   name <- changed[[kk]]
[16:20:49.655]                   NAME <- NAMES[[kk]]
[16:20:49.655]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:49.655]                     next
[16:20:49.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:49.655]                 }
[16:20:49.655]                 NAMES <- toupper(added)
[16:20:49.655]                 for (kk in seq_along(NAMES)) {
[16:20:49.655]                   name <- added[[kk]]
[16:20:49.655]                   NAME <- NAMES[[kk]]
[16:20:49.655]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:49.655]                     next
[16:20:49.655]                   args[[name]] <- ""
[16:20:49.655]                 }
[16:20:49.655]                 NAMES <- toupper(removed)
[16:20:49.655]                 for (kk in seq_along(NAMES)) {
[16:20:49.655]                   name <- removed[[kk]]
[16:20:49.655]                   NAME <- NAMES[[kk]]
[16:20:49.655]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:49.655]                     next
[16:20:49.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:49.655]                 }
[16:20:49.655]                 if (length(args) > 0) 
[16:20:49.655]                   base::do.call(base::Sys.setenv, args = args)
[16:20:49.655]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:49.655]             }
[16:20:49.655]             else {
[16:20:49.655]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:49.655]             }
[16:20:49.655]             {
[16:20:49.655]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:49.655]                   0L) {
[16:20:49.655]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:49.655]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:49.655]                   base::options(opts)
[16:20:49.655]                 }
[16:20:49.655]                 {
[16:20:49.655]                   {
[16:20:49.655]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:49.655]                     NULL
[16:20:49.655]                   }
[16:20:49.655]                   options(future.plan = NULL)
[16:20:49.655]                   if (is.na(NA_character_)) 
[16:20:49.655]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:49.655]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:49.655]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:49.655]                     .init = FALSE)
[16:20:49.655]                 }
[16:20:49.655]             }
[16:20:49.655]         }
[16:20:49.655]     })
[16:20:49.655]     if (TRUE) {
[16:20:49.655]         base::sink(type = "output", split = FALSE)
[16:20:49.655]         if (TRUE) {
[16:20:49.655]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:49.655]         }
[16:20:49.655]         else {
[16:20:49.655]             ...future.result["stdout"] <- base::list(NULL)
[16:20:49.655]         }
[16:20:49.655]         base::close(...future.stdout)
[16:20:49.655]         ...future.stdout <- NULL
[16:20:49.655]     }
[16:20:49.655]     ...future.result$conditions <- ...future.conditions
[16:20:49.655]     ...future.result$finished <- base::Sys.time()
[16:20:49.655]     ...future.result
[16:20:49.655] }
[16:20:49.658] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[16:20:49.658] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[16:20:49.659] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[16:20:49.659] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[16:20:49.659] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[16:20:49.660] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[16:20:49.660] MultisessionFuture started
[16:20:49.660] - Launch lazy future ... done
[16:20:49.661] run() for ‘MultisessionFuture’ ... done
[16:20:49.661] result() for ClusterFuture ...
[16:20:49.661] receiveMessageFromWorker() for ClusterFuture ...
[16:20:49.661] - Validating connection of MultisessionFuture
[16:20:49.703] - received message: FutureResult
[16:20:49.703] - Received FutureResult
[16:20:49.704] - Erased future from FutureRegistry
[16:20:49.704] result() for ClusterFuture ...
[16:20:49.704] - result already collected: FutureResult
[16:20:49.704] result() for ClusterFuture ... done
[16:20:49.704] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:49.704] result() for ClusterFuture ... done
[16:20:49.704] result() for ClusterFuture ...
[16:20:49.704] - result already collected: FutureResult
[16:20:49.705] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:20:49.707] getGlobalsAndPackages() ...
[16:20:49.707] Searching for globals...
[16:20:49.709] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:20:49.709] Searching for globals ... DONE
[16:20:49.709] Resolving globals: FALSE
[16:20:49.710] The total size of the 2 globals is 896 bytes (896 bytes)
[16:20:49.710] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:20:49.711] - globals: [2] ‘weight’, ‘group’
[16:20:49.711] - packages: [1] ‘stats’
[16:20:49.711] getGlobalsAndPackages() ... DONE
[16:20:49.711] run() for ‘Future’ ...
[16:20:49.711] - state: ‘created’
[16:20:49.711] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:49.727] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:49.727] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:49.727]   - Field: ‘node’
[16:20:49.727]   - Field: ‘label’
[16:20:49.727]   - Field: ‘local’
[16:20:49.728]   - Field: ‘owner’
[16:20:49.728]   - Field: ‘envir’
[16:20:49.728]   - Field: ‘workers’
[16:20:49.728]   - Field: ‘packages’
[16:20:49.728]   - Field: ‘gc’
[16:20:49.728]   - Field: ‘conditions’
[16:20:49.728]   - Field: ‘persistent’
[16:20:49.728]   - Field: ‘expr’
[16:20:49.728]   - Field: ‘uuid’
[16:20:49.729]   - Field: ‘seed’
[16:20:49.729]   - Field: ‘version’
[16:20:49.729]   - Field: ‘result’
[16:20:49.729]   - Field: ‘asynchronous’
[16:20:49.729]   - Field: ‘calls’
[16:20:49.729]   - Field: ‘globals’
[16:20:49.729]   - Field: ‘stdout’
[16:20:49.729]   - Field: ‘earlySignal’
[16:20:49.729]   - Field: ‘lazy’
[16:20:49.730]   - Field: ‘state’
[16:20:49.730] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:49.730] - Launch lazy future ...
[16:20:49.730] Packages needed by the future expression (n = 1): ‘stats’
[16:20:49.730] Packages needed by future strategies (n = 0): <none>
[16:20:49.731] {
[16:20:49.731]     {
[16:20:49.731]         {
[16:20:49.731]             ...future.startTime <- base::Sys.time()
[16:20:49.731]             {
[16:20:49.731]                 {
[16:20:49.731]                   {
[16:20:49.731]                     {
[16:20:49.731]                       {
[16:20:49.731]                         base::local({
[16:20:49.731]                           has_future <- base::requireNamespace("future", 
[16:20:49.731]                             quietly = TRUE)
[16:20:49.731]                           if (has_future) {
[16:20:49.731]                             ns <- base::getNamespace("future")
[16:20:49.731]                             version <- ns[[".package"]][["version"]]
[16:20:49.731]                             if (is.null(version)) 
[16:20:49.731]                               version <- utils::packageVersion("future")
[16:20:49.731]                           }
[16:20:49.731]                           else {
[16:20:49.731]                             version <- NULL
[16:20:49.731]                           }
[16:20:49.731]                           if (!has_future || version < "1.8.0") {
[16:20:49.731]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:49.731]                               "", base::R.version$version.string), 
[16:20:49.731]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:49.731]                                 base::R.version$platform, 8 * 
[16:20:49.731]                                   base::.Machine$sizeof.pointer), 
[16:20:49.731]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:49.731]                                 "release", "version")], collapse = " "), 
[16:20:49.731]                               hostname = base::Sys.info()[["nodename"]])
[16:20:49.731]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:49.731]                               info)
[16:20:49.731]                             info <- base::paste(info, collapse = "; ")
[16:20:49.731]                             if (!has_future) {
[16:20:49.731]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:49.731]                                 info)
[16:20:49.731]                             }
[16:20:49.731]                             else {
[16:20:49.731]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:49.731]                                 info, version)
[16:20:49.731]                             }
[16:20:49.731]                             base::stop(msg)
[16:20:49.731]                           }
[16:20:49.731]                         })
[16:20:49.731]                       }
[16:20:49.731]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:49.731]                       base::options(mc.cores = 1L)
[16:20:49.731]                     }
[16:20:49.731]                     base::local({
[16:20:49.731]                       for (pkg in "stats") {
[16:20:49.731]                         base::loadNamespace(pkg)
[16:20:49.731]                         base::library(pkg, character.only = TRUE)
[16:20:49.731]                       }
[16:20:49.731]                     })
[16:20:49.731]                   }
[16:20:49.731]                   ...future.strategy.old <- future::plan("list")
[16:20:49.731]                   options(future.plan = NULL)
[16:20:49.731]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:49.731]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:49.731]                 }
[16:20:49.731]                 ...future.workdir <- getwd()
[16:20:49.731]             }
[16:20:49.731]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:49.731]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:49.731]         }
[16:20:49.731]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:49.731]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:49.731]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:49.731]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:49.731]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:49.731]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:49.731]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:49.731]             base::names(...future.oldOptions))
[16:20:49.731]     }
[16:20:49.731]     if (FALSE) {
[16:20:49.731]     }
[16:20:49.731]     else {
[16:20:49.731]         if (TRUE) {
[16:20:49.731]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:49.731]                 open = "w")
[16:20:49.731]         }
[16:20:49.731]         else {
[16:20:49.731]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:49.731]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:49.731]         }
[16:20:49.731]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:49.731]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:49.731]             base::sink(type = "output", split = FALSE)
[16:20:49.731]             base::close(...future.stdout)
[16:20:49.731]         }, add = TRUE)
[16:20:49.731]     }
[16:20:49.731]     ...future.frame <- base::sys.nframe()
[16:20:49.731]     ...future.conditions <- base::list()
[16:20:49.731]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:49.731]     if (FALSE) {
[16:20:49.731]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:49.731]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:49.731]     }
[16:20:49.731]     ...future.result <- base::tryCatch({
[16:20:49.731]         base::withCallingHandlers({
[16:20:49.731]             ...future.value <- base::withVisible(base::local({
[16:20:49.731]                 ...future.makeSendCondition <- base::local({
[16:20:49.731]                   sendCondition <- NULL
[16:20:49.731]                   function(frame = 1L) {
[16:20:49.731]                     if (is.function(sendCondition)) 
[16:20:49.731]                       return(sendCondition)
[16:20:49.731]                     ns <- getNamespace("parallel")
[16:20:49.731]                     if (exists("sendData", mode = "function", 
[16:20:49.731]                       envir = ns)) {
[16:20:49.731]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:49.731]                         envir = ns)
[16:20:49.731]                       envir <- sys.frame(frame)
[16:20:49.731]                       master <- NULL
[16:20:49.731]                       while (!identical(envir, .GlobalEnv) && 
[16:20:49.731]                         !identical(envir, emptyenv())) {
[16:20:49.731]                         if (exists("master", mode = "list", envir = envir, 
[16:20:49.731]                           inherits = FALSE)) {
[16:20:49.731]                           master <- get("master", mode = "list", 
[16:20:49.731]                             envir = envir, inherits = FALSE)
[16:20:49.731]                           if (inherits(master, c("SOCKnode", 
[16:20:49.731]                             "SOCK0node"))) {
[16:20:49.731]                             sendCondition <<- function(cond) {
[16:20:49.731]                               data <- list(type = "VALUE", value = cond, 
[16:20:49.731]                                 success = TRUE)
[16:20:49.731]                               parallel_sendData(master, data)
[16:20:49.731]                             }
[16:20:49.731]                             return(sendCondition)
[16:20:49.731]                           }
[16:20:49.731]                         }
[16:20:49.731]                         frame <- frame + 1L
[16:20:49.731]                         envir <- sys.frame(frame)
[16:20:49.731]                       }
[16:20:49.731]                     }
[16:20:49.731]                     sendCondition <<- function(cond) NULL
[16:20:49.731]                   }
[16:20:49.731]                 })
[16:20:49.731]                 withCallingHandlers({
[16:20:49.731]                   {
[16:20:49.731]                     lm(weight ~ group - 1)
[16:20:49.731]                   }
[16:20:49.731]                 }, immediateCondition = function(cond) {
[16:20:49.731]                   sendCondition <- ...future.makeSendCondition()
[16:20:49.731]                   sendCondition(cond)
[16:20:49.731]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:49.731]                   {
[16:20:49.731]                     inherits <- base::inherits
[16:20:49.731]                     invokeRestart <- base::invokeRestart
[16:20:49.731]                     is.null <- base::is.null
[16:20:49.731]                     muffled <- FALSE
[16:20:49.731]                     if (inherits(cond, "message")) {
[16:20:49.731]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:49.731]                       if (muffled) 
[16:20:49.731]                         invokeRestart("muffleMessage")
[16:20:49.731]                     }
[16:20:49.731]                     else if (inherits(cond, "warning")) {
[16:20:49.731]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:49.731]                       if (muffled) 
[16:20:49.731]                         invokeRestart("muffleWarning")
[16:20:49.731]                     }
[16:20:49.731]                     else if (inherits(cond, "condition")) {
[16:20:49.731]                       if (!is.null(pattern)) {
[16:20:49.731]                         computeRestarts <- base::computeRestarts
[16:20:49.731]                         grepl <- base::grepl
[16:20:49.731]                         restarts <- computeRestarts(cond)
[16:20:49.731]                         for (restart in restarts) {
[16:20:49.731]                           name <- restart$name
[16:20:49.731]                           if (is.null(name)) 
[16:20:49.731]                             next
[16:20:49.731]                           if (!grepl(pattern, name)) 
[16:20:49.731]                             next
[16:20:49.731]                           invokeRestart(restart)
[16:20:49.731]                           muffled <- TRUE
[16:20:49.731]                           break
[16:20:49.731]                         }
[16:20:49.731]                       }
[16:20:49.731]                     }
[16:20:49.731]                     invisible(muffled)
[16:20:49.731]                   }
[16:20:49.731]                   muffleCondition(cond)
[16:20:49.731]                 })
[16:20:49.731]             }))
[16:20:49.731]             future::FutureResult(value = ...future.value$value, 
[16:20:49.731]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:49.731]                   ...future.rng), globalenv = if (FALSE) 
[16:20:49.731]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:49.731]                     ...future.globalenv.names))
[16:20:49.731]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:49.731]         }, condition = base::local({
[16:20:49.731]             c <- base::c
[16:20:49.731]             inherits <- base::inherits
[16:20:49.731]             invokeRestart <- base::invokeRestart
[16:20:49.731]             length <- base::length
[16:20:49.731]             list <- base::list
[16:20:49.731]             seq.int <- base::seq.int
[16:20:49.731]             signalCondition <- base::signalCondition
[16:20:49.731]             sys.calls <- base::sys.calls
[16:20:49.731]             `[[` <- base::`[[`
[16:20:49.731]             `+` <- base::`+`
[16:20:49.731]             `<<-` <- base::`<<-`
[16:20:49.731]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:49.731]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:49.731]                   3L)]
[16:20:49.731]             }
[16:20:49.731]             function(cond) {
[16:20:49.731]                 is_error <- inherits(cond, "error")
[16:20:49.731]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:49.731]                   NULL)
[16:20:49.731]                 if (is_error) {
[16:20:49.731]                   sessionInformation <- function() {
[16:20:49.731]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:49.731]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:49.731]                       search = base::search(), system = base::Sys.info())
[16:20:49.731]                   }
[16:20:49.731]                   ...future.conditions[[length(...future.conditions) + 
[16:20:49.731]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:49.731]                     cond$call), session = sessionInformation(), 
[16:20:49.731]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:49.731]                   signalCondition(cond)
[16:20:49.731]                 }
[16:20:49.731]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:49.731]                 "immediateCondition"))) {
[16:20:49.731]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:49.731]                   ...future.conditions[[length(...future.conditions) + 
[16:20:49.731]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:49.731]                   if (TRUE && !signal) {
[16:20:49.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:49.731]                     {
[16:20:49.731]                       inherits <- base::inherits
[16:20:49.731]                       invokeRestart <- base::invokeRestart
[16:20:49.731]                       is.null <- base::is.null
[16:20:49.731]                       muffled <- FALSE
[16:20:49.731]                       if (inherits(cond, "message")) {
[16:20:49.731]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:49.731]                         if (muffled) 
[16:20:49.731]                           invokeRestart("muffleMessage")
[16:20:49.731]                       }
[16:20:49.731]                       else if (inherits(cond, "warning")) {
[16:20:49.731]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:49.731]                         if (muffled) 
[16:20:49.731]                           invokeRestart("muffleWarning")
[16:20:49.731]                       }
[16:20:49.731]                       else if (inherits(cond, "condition")) {
[16:20:49.731]                         if (!is.null(pattern)) {
[16:20:49.731]                           computeRestarts <- base::computeRestarts
[16:20:49.731]                           grepl <- base::grepl
[16:20:49.731]                           restarts <- computeRestarts(cond)
[16:20:49.731]                           for (restart in restarts) {
[16:20:49.731]                             name <- restart$name
[16:20:49.731]                             if (is.null(name)) 
[16:20:49.731]                               next
[16:20:49.731]                             if (!grepl(pattern, name)) 
[16:20:49.731]                               next
[16:20:49.731]                             invokeRestart(restart)
[16:20:49.731]                             muffled <- TRUE
[16:20:49.731]                             break
[16:20:49.731]                           }
[16:20:49.731]                         }
[16:20:49.731]                       }
[16:20:49.731]                       invisible(muffled)
[16:20:49.731]                     }
[16:20:49.731]                     muffleCondition(cond, pattern = "^muffle")
[16:20:49.731]                   }
[16:20:49.731]                 }
[16:20:49.731]                 else {
[16:20:49.731]                   if (TRUE) {
[16:20:49.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:49.731]                     {
[16:20:49.731]                       inherits <- base::inherits
[16:20:49.731]                       invokeRestart <- base::invokeRestart
[16:20:49.731]                       is.null <- base::is.null
[16:20:49.731]                       muffled <- FALSE
[16:20:49.731]                       if (inherits(cond, "message")) {
[16:20:49.731]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:49.731]                         if (muffled) 
[16:20:49.731]                           invokeRestart("muffleMessage")
[16:20:49.731]                       }
[16:20:49.731]                       else if (inherits(cond, "warning")) {
[16:20:49.731]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:49.731]                         if (muffled) 
[16:20:49.731]                           invokeRestart("muffleWarning")
[16:20:49.731]                       }
[16:20:49.731]                       else if (inherits(cond, "condition")) {
[16:20:49.731]                         if (!is.null(pattern)) {
[16:20:49.731]                           computeRestarts <- base::computeRestarts
[16:20:49.731]                           grepl <- base::grepl
[16:20:49.731]                           restarts <- computeRestarts(cond)
[16:20:49.731]                           for (restart in restarts) {
[16:20:49.731]                             name <- restart$name
[16:20:49.731]                             if (is.null(name)) 
[16:20:49.731]                               next
[16:20:49.731]                             if (!grepl(pattern, name)) 
[16:20:49.731]                               next
[16:20:49.731]                             invokeRestart(restart)
[16:20:49.731]                             muffled <- TRUE
[16:20:49.731]                             break
[16:20:49.731]                           }
[16:20:49.731]                         }
[16:20:49.731]                       }
[16:20:49.731]                       invisible(muffled)
[16:20:49.731]                     }
[16:20:49.731]                     muffleCondition(cond, pattern = "^muffle")
[16:20:49.731]                   }
[16:20:49.731]                 }
[16:20:49.731]             }
[16:20:49.731]         }))
[16:20:49.731]     }, error = function(ex) {
[16:20:49.731]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:49.731]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:49.731]                 ...future.rng), started = ...future.startTime, 
[16:20:49.731]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:49.731]             version = "1.8"), class = "FutureResult")
[16:20:49.731]     }, finally = {
[16:20:49.731]         if (!identical(...future.workdir, getwd())) 
[16:20:49.731]             setwd(...future.workdir)
[16:20:49.731]         {
[16:20:49.731]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:49.731]                 ...future.oldOptions$nwarnings <- NULL
[16:20:49.731]             }
[16:20:49.731]             base::options(...future.oldOptions)
[16:20:49.731]             if (.Platform$OS.type == "windows") {
[16:20:49.731]                 old_names <- names(...future.oldEnvVars)
[16:20:49.731]                 envs <- base::Sys.getenv()
[16:20:49.731]                 names <- names(envs)
[16:20:49.731]                 common <- intersect(names, old_names)
[16:20:49.731]                 added <- setdiff(names, old_names)
[16:20:49.731]                 removed <- setdiff(old_names, names)
[16:20:49.731]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:49.731]                   envs[common]]
[16:20:49.731]                 NAMES <- toupper(changed)
[16:20:49.731]                 args <- list()
[16:20:49.731]                 for (kk in seq_along(NAMES)) {
[16:20:49.731]                   name <- changed[[kk]]
[16:20:49.731]                   NAME <- NAMES[[kk]]
[16:20:49.731]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:49.731]                     next
[16:20:49.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:49.731]                 }
[16:20:49.731]                 NAMES <- toupper(added)
[16:20:49.731]                 for (kk in seq_along(NAMES)) {
[16:20:49.731]                   name <- added[[kk]]
[16:20:49.731]                   NAME <- NAMES[[kk]]
[16:20:49.731]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:49.731]                     next
[16:20:49.731]                   args[[name]] <- ""
[16:20:49.731]                 }
[16:20:49.731]                 NAMES <- toupper(removed)
[16:20:49.731]                 for (kk in seq_along(NAMES)) {
[16:20:49.731]                   name <- removed[[kk]]
[16:20:49.731]                   NAME <- NAMES[[kk]]
[16:20:49.731]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:49.731]                     next
[16:20:49.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:49.731]                 }
[16:20:49.731]                 if (length(args) > 0) 
[16:20:49.731]                   base::do.call(base::Sys.setenv, args = args)
[16:20:49.731]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:49.731]             }
[16:20:49.731]             else {
[16:20:49.731]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:49.731]             }
[16:20:49.731]             {
[16:20:49.731]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:49.731]                   0L) {
[16:20:49.731]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:49.731]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:49.731]                   base::options(opts)
[16:20:49.731]                 }
[16:20:49.731]                 {
[16:20:49.731]                   {
[16:20:49.731]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:49.731]                     NULL
[16:20:49.731]                   }
[16:20:49.731]                   options(future.plan = NULL)
[16:20:49.731]                   if (is.na(NA_character_)) 
[16:20:49.731]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:49.731]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:49.731]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:49.731]                     .init = FALSE)
[16:20:49.731]                 }
[16:20:49.731]             }
[16:20:49.731]         }
[16:20:49.731]     })
[16:20:49.731]     if (TRUE) {
[16:20:49.731]         base::sink(type = "output", split = FALSE)
[16:20:49.731]         if (TRUE) {
[16:20:49.731]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:49.731]         }
[16:20:49.731]         else {
[16:20:49.731]             ...future.result["stdout"] <- base::list(NULL)
[16:20:49.731]         }
[16:20:49.731]         base::close(...future.stdout)
[16:20:49.731]         ...future.stdout <- NULL
[16:20:49.731]     }
[16:20:49.731]     ...future.result$conditions <- ...future.conditions
[16:20:49.731]     ...future.result$finished <- base::Sys.time()
[16:20:49.731]     ...future.result
[16:20:49.731] }
[16:20:49.734] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[16:20:49.734] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[16:20:49.735] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[16:20:49.735] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[16:20:49.737] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[16:20:49.738] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[16:20:49.738] MultisessionFuture started
[16:20:49.738] - Launch lazy future ... done
[16:20:49.738] run() for ‘MultisessionFuture’ ... done
[16:20:49.739] result() for ClusterFuture ...
[16:20:49.739] receiveMessageFromWorker() for ClusterFuture ...
[16:20:49.739] - Validating connection of MultisessionFuture
[16:20:49.783] - received message: FutureResult
[16:20:49.783] - Received FutureResult
[16:20:49.783] - Erased future from FutureRegistry
[16:20:49.783] result() for ClusterFuture ...
[16:20:49.783] - result already collected: FutureResult
[16:20:49.783] result() for ClusterFuture ... done
[16:20:49.783] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:49.784] result() for ClusterFuture ... done
[16:20:49.784] result() for ClusterFuture ...
[16:20:49.784] - result already collected: FutureResult
[16:20:49.784] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:20:49.786] getGlobalsAndPackages() ...
[16:20:49.786] Searching for globals...
[16:20:49.787] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:20:49.787] Searching for globals ... DONE
[16:20:49.787] Resolving globals: FALSE
[16:20:49.788] The total size of the 2 globals is 896 bytes (896 bytes)
[16:20:49.788] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:20:49.788] - globals: [2] ‘weight’, ‘group’
[16:20:49.789] - packages: [1] ‘stats’
[16:20:49.789] getGlobalsAndPackages() ... DONE
[16:20:49.789] run() for ‘Future’ ...
[16:20:49.789] - state: ‘created’
[16:20:49.789] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:49.803] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:49.803] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:49.804]   - Field: ‘node’
[16:20:49.804]   - Field: ‘label’
[16:20:49.804]   - Field: ‘local’
[16:20:49.804]   - Field: ‘owner’
[16:20:49.804]   - Field: ‘envir’
[16:20:49.804]   - Field: ‘workers’
[16:20:49.804]   - Field: ‘packages’
[16:20:49.804]   - Field: ‘gc’
[16:20:49.804]   - Field: ‘conditions’
[16:20:49.804]   - Field: ‘persistent’
[16:20:49.805]   - Field: ‘expr’
[16:20:49.805]   - Field: ‘uuid’
[16:20:49.805]   - Field: ‘seed’
[16:20:49.805]   - Field: ‘version’
[16:20:49.805]   - Field: ‘result’
[16:20:49.805]   - Field: ‘asynchronous’
[16:20:49.805]   - Field: ‘calls’
[16:20:49.805]   - Field: ‘globals’
[16:20:49.805]   - Field: ‘stdout’
[16:20:49.805]   - Field: ‘earlySignal’
[16:20:49.805]   - Field: ‘lazy’
[16:20:49.806]   - Field: ‘state’
[16:20:49.806] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:49.806] - Launch lazy future ...
[16:20:49.806] Packages needed by the future expression (n = 1): ‘stats’
[16:20:49.806] Packages needed by future strategies (n = 0): <none>
[16:20:49.807] {
[16:20:49.807]     {
[16:20:49.807]         {
[16:20:49.807]             ...future.startTime <- base::Sys.time()
[16:20:49.807]             {
[16:20:49.807]                 {
[16:20:49.807]                   {
[16:20:49.807]                     {
[16:20:49.807]                       {
[16:20:49.807]                         base::local({
[16:20:49.807]                           has_future <- base::requireNamespace("future", 
[16:20:49.807]                             quietly = TRUE)
[16:20:49.807]                           if (has_future) {
[16:20:49.807]                             ns <- base::getNamespace("future")
[16:20:49.807]                             version <- ns[[".package"]][["version"]]
[16:20:49.807]                             if (is.null(version)) 
[16:20:49.807]                               version <- utils::packageVersion("future")
[16:20:49.807]                           }
[16:20:49.807]                           else {
[16:20:49.807]                             version <- NULL
[16:20:49.807]                           }
[16:20:49.807]                           if (!has_future || version < "1.8.0") {
[16:20:49.807]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:49.807]                               "", base::R.version$version.string), 
[16:20:49.807]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:49.807]                                 base::R.version$platform, 8 * 
[16:20:49.807]                                   base::.Machine$sizeof.pointer), 
[16:20:49.807]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:49.807]                                 "release", "version")], collapse = " "), 
[16:20:49.807]                               hostname = base::Sys.info()[["nodename"]])
[16:20:49.807]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:49.807]                               info)
[16:20:49.807]                             info <- base::paste(info, collapse = "; ")
[16:20:49.807]                             if (!has_future) {
[16:20:49.807]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:49.807]                                 info)
[16:20:49.807]                             }
[16:20:49.807]                             else {
[16:20:49.807]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:49.807]                                 info, version)
[16:20:49.807]                             }
[16:20:49.807]                             base::stop(msg)
[16:20:49.807]                           }
[16:20:49.807]                         })
[16:20:49.807]                       }
[16:20:49.807]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:49.807]                       base::options(mc.cores = 1L)
[16:20:49.807]                     }
[16:20:49.807]                     base::local({
[16:20:49.807]                       for (pkg in "stats") {
[16:20:49.807]                         base::loadNamespace(pkg)
[16:20:49.807]                         base::library(pkg, character.only = TRUE)
[16:20:49.807]                       }
[16:20:49.807]                     })
[16:20:49.807]                   }
[16:20:49.807]                   ...future.strategy.old <- future::plan("list")
[16:20:49.807]                   options(future.plan = NULL)
[16:20:49.807]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:49.807]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:49.807]                 }
[16:20:49.807]                 ...future.workdir <- getwd()
[16:20:49.807]             }
[16:20:49.807]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:49.807]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:49.807]         }
[16:20:49.807]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:49.807]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:49.807]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:49.807]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:49.807]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:49.807]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:49.807]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:49.807]             base::names(...future.oldOptions))
[16:20:49.807]     }
[16:20:49.807]     if (FALSE) {
[16:20:49.807]     }
[16:20:49.807]     else {
[16:20:49.807]         if (TRUE) {
[16:20:49.807]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:49.807]                 open = "w")
[16:20:49.807]         }
[16:20:49.807]         else {
[16:20:49.807]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:49.807]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:49.807]         }
[16:20:49.807]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:49.807]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:49.807]             base::sink(type = "output", split = FALSE)
[16:20:49.807]             base::close(...future.stdout)
[16:20:49.807]         }, add = TRUE)
[16:20:49.807]     }
[16:20:49.807]     ...future.frame <- base::sys.nframe()
[16:20:49.807]     ...future.conditions <- base::list()
[16:20:49.807]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:49.807]     if (FALSE) {
[16:20:49.807]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:49.807]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:49.807]     }
[16:20:49.807]     ...future.result <- base::tryCatch({
[16:20:49.807]         base::withCallingHandlers({
[16:20:49.807]             ...future.value <- base::withVisible(base::local({
[16:20:49.807]                 ...future.makeSendCondition <- base::local({
[16:20:49.807]                   sendCondition <- NULL
[16:20:49.807]                   function(frame = 1L) {
[16:20:49.807]                     if (is.function(sendCondition)) 
[16:20:49.807]                       return(sendCondition)
[16:20:49.807]                     ns <- getNamespace("parallel")
[16:20:49.807]                     if (exists("sendData", mode = "function", 
[16:20:49.807]                       envir = ns)) {
[16:20:49.807]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:49.807]                         envir = ns)
[16:20:49.807]                       envir <- sys.frame(frame)
[16:20:49.807]                       master <- NULL
[16:20:49.807]                       while (!identical(envir, .GlobalEnv) && 
[16:20:49.807]                         !identical(envir, emptyenv())) {
[16:20:49.807]                         if (exists("master", mode = "list", envir = envir, 
[16:20:49.807]                           inherits = FALSE)) {
[16:20:49.807]                           master <- get("master", mode = "list", 
[16:20:49.807]                             envir = envir, inherits = FALSE)
[16:20:49.807]                           if (inherits(master, c("SOCKnode", 
[16:20:49.807]                             "SOCK0node"))) {
[16:20:49.807]                             sendCondition <<- function(cond) {
[16:20:49.807]                               data <- list(type = "VALUE", value = cond, 
[16:20:49.807]                                 success = TRUE)
[16:20:49.807]                               parallel_sendData(master, data)
[16:20:49.807]                             }
[16:20:49.807]                             return(sendCondition)
[16:20:49.807]                           }
[16:20:49.807]                         }
[16:20:49.807]                         frame <- frame + 1L
[16:20:49.807]                         envir <- sys.frame(frame)
[16:20:49.807]                       }
[16:20:49.807]                     }
[16:20:49.807]                     sendCondition <<- function(cond) NULL
[16:20:49.807]                   }
[16:20:49.807]                 })
[16:20:49.807]                 withCallingHandlers({
[16:20:49.807]                   {
[16:20:49.807]                     lm(weight ~ group - 1)
[16:20:49.807]                   }
[16:20:49.807]                 }, immediateCondition = function(cond) {
[16:20:49.807]                   sendCondition <- ...future.makeSendCondition()
[16:20:49.807]                   sendCondition(cond)
[16:20:49.807]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:49.807]                   {
[16:20:49.807]                     inherits <- base::inherits
[16:20:49.807]                     invokeRestart <- base::invokeRestart
[16:20:49.807]                     is.null <- base::is.null
[16:20:49.807]                     muffled <- FALSE
[16:20:49.807]                     if (inherits(cond, "message")) {
[16:20:49.807]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:49.807]                       if (muffled) 
[16:20:49.807]                         invokeRestart("muffleMessage")
[16:20:49.807]                     }
[16:20:49.807]                     else if (inherits(cond, "warning")) {
[16:20:49.807]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:49.807]                       if (muffled) 
[16:20:49.807]                         invokeRestart("muffleWarning")
[16:20:49.807]                     }
[16:20:49.807]                     else if (inherits(cond, "condition")) {
[16:20:49.807]                       if (!is.null(pattern)) {
[16:20:49.807]                         computeRestarts <- base::computeRestarts
[16:20:49.807]                         grepl <- base::grepl
[16:20:49.807]                         restarts <- computeRestarts(cond)
[16:20:49.807]                         for (restart in restarts) {
[16:20:49.807]                           name <- restart$name
[16:20:49.807]                           if (is.null(name)) 
[16:20:49.807]                             next
[16:20:49.807]                           if (!grepl(pattern, name)) 
[16:20:49.807]                             next
[16:20:49.807]                           invokeRestart(restart)
[16:20:49.807]                           muffled <- TRUE
[16:20:49.807]                           break
[16:20:49.807]                         }
[16:20:49.807]                       }
[16:20:49.807]                     }
[16:20:49.807]                     invisible(muffled)
[16:20:49.807]                   }
[16:20:49.807]                   muffleCondition(cond)
[16:20:49.807]                 })
[16:20:49.807]             }))
[16:20:49.807]             future::FutureResult(value = ...future.value$value, 
[16:20:49.807]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:49.807]                   ...future.rng), globalenv = if (FALSE) 
[16:20:49.807]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:49.807]                     ...future.globalenv.names))
[16:20:49.807]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:49.807]         }, condition = base::local({
[16:20:49.807]             c <- base::c
[16:20:49.807]             inherits <- base::inherits
[16:20:49.807]             invokeRestart <- base::invokeRestart
[16:20:49.807]             length <- base::length
[16:20:49.807]             list <- base::list
[16:20:49.807]             seq.int <- base::seq.int
[16:20:49.807]             signalCondition <- base::signalCondition
[16:20:49.807]             sys.calls <- base::sys.calls
[16:20:49.807]             `[[` <- base::`[[`
[16:20:49.807]             `+` <- base::`+`
[16:20:49.807]             `<<-` <- base::`<<-`
[16:20:49.807]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:49.807]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:49.807]                   3L)]
[16:20:49.807]             }
[16:20:49.807]             function(cond) {
[16:20:49.807]                 is_error <- inherits(cond, "error")
[16:20:49.807]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:49.807]                   NULL)
[16:20:49.807]                 if (is_error) {
[16:20:49.807]                   sessionInformation <- function() {
[16:20:49.807]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:49.807]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:49.807]                       search = base::search(), system = base::Sys.info())
[16:20:49.807]                   }
[16:20:49.807]                   ...future.conditions[[length(...future.conditions) + 
[16:20:49.807]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:49.807]                     cond$call), session = sessionInformation(), 
[16:20:49.807]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:49.807]                   signalCondition(cond)
[16:20:49.807]                 }
[16:20:49.807]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:49.807]                 "immediateCondition"))) {
[16:20:49.807]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:49.807]                   ...future.conditions[[length(...future.conditions) + 
[16:20:49.807]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:49.807]                   if (TRUE && !signal) {
[16:20:49.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:49.807]                     {
[16:20:49.807]                       inherits <- base::inherits
[16:20:49.807]                       invokeRestart <- base::invokeRestart
[16:20:49.807]                       is.null <- base::is.null
[16:20:49.807]                       muffled <- FALSE
[16:20:49.807]                       if (inherits(cond, "message")) {
[16:20:49.807]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:49.807]                         if (muffled) 
[16:20:49.807]                           invokeRestart("muffleMessage")
[16:20:49.807]                       }
[16:20:49.807]                       else if (inherits(cond, "warning")) {
[16:20:49.807]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:49.807]                         if (muffled) 
[16:20:49.807]                           invokeRestart("muffleWarning")
[16:20:49.807]                       }
[16:20:49.807]                       else if (inherits(cond, "condition")) {
[16:20:49.807]                         if (!is.null(pattern)) {
[16:20:49.807]                           computeRestarts <- base::computeRestarts
[16:20:49.807]                           grepl <- base::grepl
[16:20:49.807]                           restarts <- computeRestarts(cond)
[16:20:49.807]                           for (restart in restarts) {
[16:20:49.807]                             name <- restart$name
[16:20:49.807]                             if (is.null(name)) 
[16:20:49.807]                               next
[16:20:49.807]                             if (!grepl(pattern, name)) 
[16:20:49.807]                               next
[16:20:49.807]                             invokeRestart(restart)
[16:20:49.807]                             muffled <- TRUE
[16:20:49.807]                             break
[16:20:49.807]                           }
[16:20:49.807]                         }
[16:20:49.807]                       }
[16:20:49.807]                       invisible(muffled)
[16:20:49.807]                     }
[16:20:49.807]                     muffleCondition(cond, pattern = "^muffle")
[16:20:49.807]                   }
[16:20:49.807]                 }
[16:20:49.807]                 else {
[16:20:49.807]                   if (TRUE) {
[16:20:49.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:49.807]                     {
[16:20:49.807]                       inherits <- base::inherits
[16:20:49.807]                       invokeRestart <- base::invokeRestart
[16:20:49.807]                       is.null <- base::is.null
[16:20:49.807]                       muffled <- FALSE
[16:20:49.807]                       if (inherits(cond, "message")) {
[16:20:49.807]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:49.807]                         if (muffled) 
[16:20:49.807]                           invokeRestart("muffleMessage")
[16:20:49.807]                       }
[16:20:49.807]                       else if (inherits(cond, "warning")) {
[16:20:49.807]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:49.807]                         if (muffled) 
[16:20:49.807]                           invokeRestart("muffleWarning")
[16:20:49.807]                       }
[16:20:49.807]                       else if (inherits(cond, "condition")) {
[16:20:49.807]                         if (!is.null(pattern)) {
[16:20:49.807]                           computeRestarts <- base::computeRestarts
[16:20:49.807]                           grepl <- base::grepl
[16:20:49.807]                           restarts <- computeRestarts(cond)
[16:20:49.807]                           for (restart in restarts) {
[16:20:49.807]                             name <- restart$name
[16:20:49.807]                             if (is.null(name)) 
[16:20:49.807]                               next
[16:20:49.807]                             if (!grepl(pattern, name)) 
[16:20:49.807]                               next
[16:20:49.807]                             invokeRestart(restart)
[16:20:49.807]                             muffled <- TRUE
[16:20:49.807]                             break
[16:20:49.807]                           }
[16:20:49.807]                         }
[16:20:49.807]                       }
[16:20:49.807]                       invisible(muffled)
[16:20:49.807]                     }
[16:20:49.807]                     muffleCondition(cond, pattern = "^muffle")
[16:20:49.807]                   }
[16:20:49.807]                 }
[16:20:49.807]             }
[16:20:49.807]         }))
[16:20:49.807]     }, error = function(ex) {
[16:20:49.807]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:49.807]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:49.807]                 ...future.rng), started = ...future.startTime, 
[16:20:49.807]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:49.807]             version = "1.8"), class = "FutureResult")
[16:20:49.807]     }, finally = {
[16:20:49.807]         if (!identical(...future.workdir, getwd())) 
[16:20:49.807]             setwd(...future.workdir)
[16:20:49.807]         {
[16:20:49.807]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:49.807]                 ...future.oldOptions$nwarnings <- NULL
[16:20:49.807]             }
[16:20:49.807]             base::options(...future.oldOptions)
[16:20:49.807]             if (.Platform$OS.type == "windows") {
[16:20:49.807]                 old_names <- names(...future.oldEnvVars)
[16:20:49.807]                 envs <- base::Sys.getenv()
[16:20:49.807]                 names <- names(envs)
[16:20:49.807]                 common <- intersect(names, old_names)
[16:20:49.807]                 added <- setdiff(names, old_names)
[16:20:49.807]                 removed <- setdiff(old_names, names)
[16:20:49.807]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:49.807]                   envs[common]]
[16:20:49.807]                 NAMES <- toupper(changed)
[16:20:49.807]                 args <- list()
[16:20:49.807]                 for (kk in seq_along(NAMES)) {
[16:20:49.807]                   name <- changed[[kk]]
[16:20:49.807]                   NAME <- NAMES[[kk]]
[16:20:49.807]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:49.807]                     next
[16:20:49.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:49.807]                 }
[16:20:49.807]                 NAMES <- toupper(added)
[16:20:49.807]                 for (kk in seq_along(NAMES)) {
[16:20:49.807]                   name <- added[[kk]]
[16:20:49.807]                   NAME <- NAMES[[kk]]
[16:20:49.807]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:49.807]                     next
[16:20:49.807]                   args[[name]] <- ""
[16:20:49.807]                 }
[16:20:49.807]                 NAMES <- toupper(removed)
[16:20:49.807]                 for (kk in seq_along(NAMES)) {
[16:20:49.807]                   name <- removed[[kk]]
[16:20:49.807]                   NAME <- NAMES[[kk]]
[16:20:49.807]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:49.807]                     next
[16:20:49.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:49.807]                 }
[16:20:49.807]                 if (length(args) > 0) 
[16:20:49.807]                   base::do.call(base::Sys.setenv, args = args)
[16:20:49.807]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:49.807]             }
[16:20:49.807]             else {
[16:20:49.807]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:49.807]             }
[16:20:49.807]             {
[16:20:49.807]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:49.807]                   0L) {
[16:20:49.807]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:49.807]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:49.807]                   base::options(opts)
[16:20:49.807]                 }
[16:20:49.807]                 {
[16:20:49.807]                   {
[16:20:49.807]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:49.807]                     NULL
[16:20:49.807]                   }
[16:20:49.807]                   options(future.plan = NULL)
[16:20:49.807]                   if (is.na(NA_character_)) 
[16:20:49.807]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:49.807]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:49.807]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:49.807]                     .init = FALSE)
[16:20:49.807]                 }
[16:20:49.807]             }
[16:20:49.807]         }
[16:20:49.807]     })
[16:20:49.807]     if (TRUE) {
[16:20:49.807]         base::sink(type = "output", split = FALSE)
[16:20:49.807]         if (TRUE) {
[16:20:49.807]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:49.807]         }
[16:20:49.807]         else {
[16:20:49.807]             ...future.result["stdout"] <- base::list(NULL)
[16:20:49.807]         }
[16:20:49.807]         base::close(...future.stdout)
[16:20:49.807]         ...future.stdout <- NULL
[16:20:49.807]     }
[16:20:49.807]     ...future.result$conditions <- ...future.conditions
[16:20:49.807]     ...future.result$finished <- base::Sys.time()
[16:20:49.807]     ...future.result
[16:20:49.807] }
[16:20:49.809] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[16:20:49.809] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[16:20:49.810] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[16:20:49.810] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[16:20:49.810] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[16:20:49.810] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[16:20:49.811] MultisessionFuture started
[16:20:49.811] - Launch lazy future ... done
[16:20:49.811] run() for ‘MultisessionFuture’ ... done
[16:20:49.811] result() for ClusterFuture ...
[16:20:49.811] receiveMessageFromWorker() for ClusterFuture ...
[16:20:49.812] - Validating connection of MultisessionFuture
[16:20:49.855] - received message: FutureResult
[16:20:49.855] - Received FutureResult
[16:20:49.855] - Erased future from FutureRegistry
[16:20:49.855] result() for ClusterFuture ...
[16:20:49.855] - result already collected: FutureResult
[16:20:49.855] result() for ClusterFuture ... done
[16:20:49.855] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:49.855] result() for ClusterFuture ... done
[16:20:49.856] result() for ClusterFuture ...
[16:20:49.856] - result already collected: FutureResult
[16:20:49.856] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:20:49.858] getGlobalsAndPackages() ...
[16:20:49.858] Searching for globals...
[16:20:49.859] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:20:49.859] Searching for globals ... DONE
[16:20:49.859] Resolving globals: FALSE
[16:20:49.860] The total size of the 2 globals is 896 bytes (896 bytes)
[16:20:49.860] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:20:49.860] - globals: [2] ‘weight’, ‘group’
[16:20:49.860] - packages: [1] ‘stats’
[16:20:49.861] getGlobalsAndPackages() ... DONE
[16:20:49.861] run() for ‘Future’ ...
[16:20:49.861] - state: ‘created’
[16:20:49.861] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:49.876] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:49.876] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:49.876]   - Field: ‘node’
[16:20:49.876]   - Field: ‘label’
[16:20:49.877]   - Field: ‘local’
[16:20:49.877]   - Field: ‘owner’
[16:20:49.877]   - Field: ‘envir’
[16:20:49.877]   - Field: ‘workers’
[16:20:49.877]   - Field: ‘packages’
[16:20:49.877]   - Field: ‘gc’
[16:20:49.877]   - Field: ‘conditions’
[16:20:49.877]   - Field: ‘persistent’
[16:20:49.877]   - Field: ‘expr’
[16:20:49.877]   - Field: ‘uuid’
[16:20:49.877]   - Field: ‘seed’
[16:20:49.878]   - Field: ‘version’
[16:20:49.878]   - Field: ‘result’
[16:20:49.878]   - Field: ‘asynchronous’
[16:20:49.878]   - Field: ‘calls’
[16:20:49.878]   - Field: ‘globals’
[16:20:49.878]   - Field: ‘stdout’
[16:20:49.878]   - Field: ‘earlySignal’
[16:20:49.878]   - Field: ‘lazy’
[16:20:49.878]   - Field: ‘state’
[16:20:49.878] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:49.878] - Launch lazy future ...
[16:20:49.879] Packages needed by the future expression (n = 1): ‘stats’
[16:20:49.879] Packages needed by future strategies (n = 0): <none>
[16:20:49.879] {
[16:20:49.879]     {
[16:20:49.879]         {
[16:20:49.879]             ...future.startTime <- base::Sys.time()
[16:20:49.879]             {
[16:20:49.879]                 {
[16:20:49.879]                   {
[16:20:49.879]                     {
[16:20:49.879]                       {
[16:20:49.879]                         base::local({
[16:20:49.879]                           has_future <- base::requireNamespace("future", 
[16:20:49.879]                             quietly = TRUE)
[16:20:49.879]                           if (has_future) {
[16:20:49.879]                             ns <- base::getNamespace("future")
[16:20:49.879]                             version <- ns[[".package"]][["version"]]
[16:20:49.879]                             if (is.null(version)) 
[16:20:49.879]                               version <- utils::packageVersion("future")
[16:20:49.879]                           }
[16:20:49.879]                           else {
[16:20:49.879]                             version <- NULL
[16:20:49.879]                           }
[16:20:49.879]                           if (!has_future || version < "1.8.0") {
[16:20:49.879]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:49.879]                               "", base::R.version$version.string), 
[16:20:49.879]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:49.879]                                 base::R.version$platform, 8 * 
[16:20:49.879]                                   base::.Machine$sizeof.pointer), 
[16:20:49.879]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:49.879]                                 "release", "version")], collapse = " "), 
[16:20:49.879]                               hostname = base::Sys.info()[["nodename"]])
[16:20:49.879]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:49.879]                               info)
[16:20:49.879]                             info <- base::paste(info, collapse = "; ")
[16:20:49.879]                             if (!has_future) {
[16:20:49.879]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:49.879]                                 info)
[16:20:49.879]                             }
[16:20:49.879]                             else {
[16:20:49.879]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:49.879]                                 info, version)
[16:20:49.879]                             }
[16:20:49.879]                             base::stop(msg)
[16:20:49.879]                           }
[16:20:49.879]                         })
[16:20:49.879]                       }
[16:20:49.879]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:49.879]                       base::options(mc.cores = 1L)
[16:20:49.879]                     }
[16:20:49.879]                     base::local({
[16:20:49.879]                       for (pkg in "stats") {
[16:20:49.879]                         base::loadNamespace(pkg)
[16:20:49.879]                         base::library(pkg, character.only = TRUE)
[16:20:49.879]                       }
[16:20:49.879]                     })
[16:20:49.879]                   }
[16:20:49.879]                   ...future.strategy.old <- future::plan("list")
[16:20:49.879]                   options(future.plan = NULL)
[16:20:49.879]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:49.879]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:49.879]                 }
[16:20:49.879]                 ...future.workdir <- getwd()
[16:20:49.879]             }
[16:20:49.879]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:49.879]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:49.879]         }
[16:20:49.879]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:49.879]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:49.879]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:49.879]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:49.879]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:49.879]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:49.879]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:49.879]             base::names(...future.oldOptions))
[16:20:49.879]     }
[16:20:49.879]     if (FALSE) {
[16:20:49.879]     }
[16:20:49.879]     else {
[16:20:49.879]         if (TRUE) {
[16:20:49.879]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:49.879]                 open = "w")
[16:20:49.879]         }
[16:20:49.879]         else {
[16:20:49.879]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:49.879]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:49.879]         }
[16:20:49.879]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:49.879]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:49.879]             base::sink(type = "output", split = FALSE)
[16:20:49.879]             base::close(...future.stdout)
[16:20:49.879]         }, add = TRUE)
[16:20:49.879]     }
[16:20:49.879]     ...future.frame <- base::sys.nframe()
[16:20:49.879]     ...future.conditions <- base::list()
[16:20:49.879]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:49.879]     if (FALSE) {
[16:20:49.879]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:49.879]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:49.879]     }
[16:20:49.879]     ...future.result <- base::tryCatch({
[16:20:49.879]         base::withCallingHandlers({
[16:20:49.879]             ...future.value <- base::withVisible(base::local({
[16:20:49.879]                 ...future.makeSendCondition <- base::local({
[16:20:49.879]                   sendCondition <- NULL
[16:20:49.879]                   function(frame = 1L) {
[16:20:49.879]                     if (is.function(sendCondition)) 
[16:20:49.879]                       return(sendCondition)
[16:20:49.879]                     ns <- getNamespace("parallel")
[16:20:49.879]                     if (exists("sendData", mode = "function", 
[16:20:49.879]                       envir = ns)) {
[16:20:49.879]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:49.879]                         envir = ns)
[16:20:49.879]                       envir <- sys.frame(frame)
[16:20:49.879]                       master <- NULL
[16:20:49.879]                       while (!identical(envir, .GlobalEnv) && 
[16:20:49.879]                         !identical(envir, emptyenv())) {
[16:20:49.879]                         if (exists("master", mode = "list", envir = envir, 
[16:20:49.879]                           inherits = FALSE)) {
[16:20:49.879]                           master <- get("master", mode = "list", 
[16:20:49.879]                             envir = envir, inherits = FALSE)
[16:20:49.879]                           if (inherits(master, c("SOCKnode", 
[16:20:49.879]                             "SOCK0node"))) {
[16:20:49.879]                             sendCondition <<- function(cond) {
[16:20:49.879]                               data <- list(type = "VALUE", value = cond, 
[16:20:49.879]                                 success = TRUE)
[16:20:49.879]                               parallel_sendData(master, data)
[16:20:49.879]                             }
[16:20:49.879]                             return(sendCondition)
[16:20:49.879]                           }
[16:20:49.879]                         }
[16:20:49.879]                         frame <- frame + 1L
[16:20:49.879]                         envir <- sys.frame(frame)
[16:20:49.879]                       }
[16:20:49.879]                     }
[16:20:49.879]                     sendCondition <<- function(cond) NULL
[16:20:49.879]                   }
[16:20:49.879]                 })
[16:20:49.879]                 withCallingHandlers({
[16:20:49.879]                   {
[16:20:49.879]                     lm(weight ~ group - 1)
[16:20:49.879]                   }
[16:20:49.879]                 }, immediateCondition = function(cond) {
[16:20:49.879]                   sendCondition <- ...future.makeSendCondition()
[16:20:49.879]                   sendCondition(cond)
[16:20:49.879]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:49.879]                   {
[16:20:49.879]                     inherits <- base::inherits
[16:20:49.879]                     invokeRestart <- base::invokeRestart
[16:20:49.879]                     is.null <- base::is.null
[16:20:49.879]                     muffled <- FALSE
[16:20:49.879]                     if (inherits(cond, "message")) {
[16:20:49.879]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:49.879]                       if (muffled) 
[16:20:49.879]                         invokeRestart("muffleMessage")
[16:20:49.879]                     }
[16:20:49.879]                     else if (inherits(cond, "warning")) {
[16:20:49.879]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:49.879]                       if (muffled) 
[16:20:49.879]                         invokeRestart("muffleWarning")
[16:20:49.879]                     }
[16:20:49.879]                     else if (inherits(cond, "condition")) {
[16:20:49.879]                       if (!is.null(pattern)) {
[16:20:49.879]                         computeRestarts <- base::computeRestarts
[16:20:49.879]                         grepl <- base::grepl
[16:20:49.879]                         restarts <- computeRestarts(cond)
[16:20:49.879]                         for (restart in restarts) {
[16:20:49.879]                           name <- restart$name
[16:20:49.879]                           if (is.null(name)) 
[16:20:49.879]                             next
[16:20:49.879]                           if (!grepl(pattern, name)) 
[16:20:49.879]                             next
[16:20:49.879]                           invokeRestart(restart)
[16:20:49.879]                           muffled <- TRUE
[16:20:49.879]                           break
[16:20:49.879]                         }
[16:20:49.879]                       }
[16:20:49.879]                     }
[16:20:49.879]                     invisible(muffled)
[16:20:49.879]                   }
[16:20:49.879]                   muffleCondition(cond)
[16:20:49.879]                 })
[16:20:49.879]             }))
[16:20:49.879]             future::FutureResult(value = ...future.value$value, 
[16:20:49.879]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:49.879]                   ...future.rng), globalenv = if (FALSE) 
[16:20:49.879]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:49.879]                     ...future.globalenv.names))
[16:20:49.879]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:49.879]         }, condition = base::local({
[16:20:49.879]             c <- base::c
[16:20:49.879]             inherits <- base::inherits
[16:20:49.879]             invokeRestart <- base::invokeRestart
[16:20:49.879]             length <- base::length
[16:20:49.879]             list <- base::list
[16:20:49.879]             seq.int <- base::seq.int
[16:20:49.879]             signalCondition <- base::signalCondition
[16:20:49.879]             sys.calls <- base::sys.calls
[16:20:49.879]             `[[` <- base::`[[`
[16:20:49.879]             `+` <- base::`+`
[16:20:49.879]             `<<-` <- base::`<<-`
[16:20:49.879]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:49.879]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:49.879]                   3L)]
[16:20:49.879]             }
[16:20:49.879]             function(cond) {
[16:20:49.879]                 is_error <- inherits(cond, "error")
[16:20:49.879]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:49.879]                   NULL)
[16:20:49.879]                 if (is_error) {
[16:20:49.879]                   sessionInformation <- function() {
[16:20:49.879]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:49.879]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:49.879]                       search = base::search(), system = base::Sys.info())
[16:20:49.879]                   }
[16:20:49.879]                   ...future.conditions[[length(...future.conditions) + 
[16:20:49.879]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:49.879]                     cond$call), session = sessionInformation(), 
[16:20:49.879]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:49.879]                   signalCondition(cond)
[16:20:49.879]                 }
[16:20:49.879]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:49.879]                 "immediateCondition"))) {
[16:20:49.879]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:49.879]                   ...future.conditions[[length(...future.conditions) + 
[16:20:49.879]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:49.879]                   if (TRUE && !signal) {
[16:20:49.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:49.879]                     {
[16:20:49.879]                       inherits <- base::inherits
[16:20:49.879]                       invokeRestart <- base::invokeRestart
[16:20:49.879]                       is.null <- base::is.null
[16:20:49.879]                       muffled <- FALSE
[16:20:49.879]                       if (inherits(cond, "message")) {
[16:20:49.879]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:49.879]                         if (muffled) 
[16:20:49.879]                           invokeRestart("muffleMessage")
[16:20:49.879]                       }
[16:20:49.879]                       else if (inherits(cond, "warning")) {
[16:20:49.879]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:49.879]                         if (muffled) 
[16:20:49.879]                           invokeRestart("muffleWarning")
[16:20:49.879]                       }
[16:20:49.879]                       else if (inherits(cond, "condition")) {
[16:20:49.879]                         if (!is.null(pattern)) {
[16:20:49.879]                           computeRestarts <- base::computeRestarts
[16:20:49.879]                           grepl <- base::grepl
[16:20:49.879]                           restarts <- computeRestarts(cond)
[16:20:49.879]                           for (restart in restarts) {
[16:20:49.879]                             name <- restart$name
[16:20:49.879]                             if (is.null(name)) 
[16:20:49.879]                               next
[16:20:49.879]                             if (!grepl(pattern, name)) 
[16:20:49.879]                               next
[16:20:49.879]                             invokeRestart(restart)
[16:20:49.879]                             muffled <- TRUE
[16:20:49.879]                             break
[16:20:49.879]                           }
[16:20:49.879]                         }
[16:20:49.879]                       }
[16:20:49.879]                       invisible(muffled)
[16:20:49.879]                     }
[16:20:49.879]                     muffleCondition(cond, pattern = "^muffle")
[16:20:49.879]                   }
[16:20:49.879]                 }
[16:20:49.879]                 else {
[16:20:49.879]                   if (TRUE) {
[16:20:49.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:49.879]                     {
[16:20:49.879]                       inherits <- base::inherits
[16:20:49.879]                       invokeRestart <- base::invokeRestart
[16:20:49.879]                       is.null <- base::is.null
[16:20:49.879]                       muffled <- FALSE
[16:20:49.879]                       if (inherits(cond, "message")) {
[16:20:49.879]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:49.879]                         if (muffled) 
[16:20:49.879]                           invokeRestart("muffleMessage")
[16:20:49.879]                       }
[16:20:49.879]                       else if (inherits(cond, "warning")) {
[16:20:49.879]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:49.879]                         if (muffled) 
[16:20:49.879]                           invokeRestart("muffleWarning")
[16:20:49.879]                       }
[16:20:49.879]                       else if (inherits(cond, "condition")) {
[16:20:49.879]                         if (!is.null(pattern)) {
[16:20:49.879]                           computeRestarts <- base::computeRestarts
[16:20:49.879]                           grepl <- base::grepl
[16:20:49.879]                           restarts <- computeRestarts(cond)
[16:20:49.879]                           for (restart in restarts) {
[16:20:49.879]                             name <- restart$name
[16:20:49.879]                             if (is.null(name)) 
[16:20:49.879]                               next
[16:20:49.879]                             if (!grepl(pattern, name)) 
[16:20:49.879]                               next
[16:20:49.879]                             invokeRestart(restart)
[16:20:49.879]                             muffled <- TRUE
[16:20:49.879]                             break
[16:20:49.879]                           }
[16:20:49.879]                         }
[16:20:49.879]                       }
[16:20:49.879]                       invisible(muffled)
[16:20:49.879]                     }
[16:20:49.879]                     muffleCondition(cond, pattern = "^muffle")
[16:20:49.879]                   }
[16:20:49.879]                 }
[16:20:49.879]             }
[16:20:49.879]         }))
[16:20:49.879]     }, error = function(ex) {
[16:20:49.879]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:49.879]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:49.879]                 ...future.rng), started = ...future.startTime, 
[16:20:49.879]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:49.879]             version = "1.8"), class = "FutureResult")
[16:20:49.879]     }, finally = {
[16:20:49.879]         if (!identical(...future.workdir, getwd())) 
[16:20:49.879]             setwd(...future.workdir)
[16:20:49.879]         {
[16:20:49.879]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:49.879]                 ...future.oldOptions$nwarnings <- NULL
[16:20:49.879]             }
[16:20:49.879]             base::options(...future.oldOptions)
[16:20:49.879]             if (.Platform$OS.type == "windows") {
[16:20:49.879]                 old_names <- names(...future.oldEnvVars)
[16:20:49.879]                 envs <- base::Sys.getenv()
[16:20:49.879]                 names <- names(envs)
[16:20:49.879]                 common <- intersect(names, old_names)
[16:20:49.879]                 added <- setdiff(names, old_names)
[16:20:49.879]                 removed <- setdiff(old_names, names)
[16:20:49.879]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:49.879]                   envs[common]]
[16:20:49.879]                 NAMES <- toupper(changed)
[16:20:49.879]                 args <- list()
[16:20:49.879]                 for (kk in seq_along(NAMES)) {
[16:20:49.879]                   name <- changed[[kk]]
[16:20:49.879]                   NAME <- NAMES[[kk]]
[16:20:49.879]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:49.879]                     next
[16:20:49.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:49.879]                 }
[16:20:49.879]                 NAMES <- toupper(added)
[16:20:49.879]                 for (kk in seq_along(NAMES)) {
[16:20:49.879]                   name <- added[[kk]]
[16:20:49.879]                   NAME <- NAMES[[kk]]
[16:20:49.879]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:49.879]                     next
[16:20:49.879]                   args[[name]] <- ""
[16:20:49.879]                 }
[16:20:49.879]                 NAMES <- toupper(removed)
[16:20:49.879]                 for (kk in seq_along(NAMES)) {
[16:20:49.879]                   name <- removed[[kk]]
[16:20:49.879]                   NAME <- NAMES[[kk]]
[16:20:49.879]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:49.879]                     next
[16:20:49.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:49.879]                 }
[16:20:49.879]                 if (length(args) > 0) 
[16:20:49.879]                   base::do.call(base::Sys.setenv, args = args)
[16:20:49.879]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:49.879]             }
[16:20:49.879]             else {
[16:20:49.879]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:49.879]             }
[16:20:49.879]             {
[16:20:49.879]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:49.879]                   0L) {
[16:20:49.879]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:49.879]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:49.879]                   base::options(opts)
[16:20:49.879]                 }
[16:20:49.879]                 {
[16:20:49.879]                   {
[16:20:49.879]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:49.879]                     NULL
[16:20:49.879]                   }
[16:20:49.879]                   options(future.plan = NULL)
[16:20:49.879]                   if (is.na(NA_character_)) 
[16:20:49.879]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:49.879]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:49.879]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:49.879]                     .init = FALSE)
[16:20:49.879]                 }
[16:20:49.879]             }
[16:20:49.879]         }
[16:20:49.879]     })
[16:20:49.879]     if (TRUE) {
[16:20:49.879]         base::sink(type = "output", split = FALSE)
[16:20:49.879]         if (TRUE) {
[16:20:49.879]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:49.879]         }
[16:20:49.879]         else {
[16:20:49.879]             ...future.result["stdout"] <- base::list(NULL)
[16:20:49.879]         }
[16:20:49.879]         base::close(...future.stdout)
[16:20:49.879]         ...future.stdout <- NULL
[16:20:49.879]     }
[16:20:49.879]     ...future.result$conditions <- ...future.conditions
[16:20:49.879]     ...future.result$finished <- base::Sys.time()
[16:20:49.879]     ...future.result
[16:20:49.879] }
[16:20:49.882] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[16:20:49.882] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[16:20:49.883] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[16:20:49.883] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[16:20:49.883] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[16:20:49.883] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[16:20:49.884] MultisessionFuture started
[16:20:49.884] - Launch lazy future ... done
[16:20:49.884] run() for ‘MultisessionFuture’ ... done
[16:20:49.884] result() for ClusterFuture ...
[16:20:49.884] receiveMessageFromWorker() for ClusterFuture ...
[16:20:49.884] - Validating connection of MultisessionFuture
[16:20:49.927] - received message: FutureResult
[16:20:49.927] - Received FutureResult
[16:20:49.927] - Erased future from FutureRegistry
[16:20:49.927] result() for ClusterFuture ...
[16:20:49.927] - result already collected: FutureResult
[16:20:49.927] result() for ClusterFuture ... done
[16:20:49.928] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:49.928] result() for ClusterFuture ... done
[16:20:49.928] result() for ClusterFuture ...
[16:20:49.928] - result already collected: FutureResult
[16:20:49.928] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[16:20:49.930] getGlobalsAndPackages() ...
[16:20:49.930] Searching for globals...
[16:20:49.931] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[16:20:49.931] Searching for globals ... DONE
[16:20:49.931] Resolving globals: FALSE
[16:20:49.931] The total size of the 1 globals is 96 bytes (96 bytes)
[16:20:49.932] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[16:20:49.932] - globals: [1] ‘x’
[16:20:49.932] - packages: [1] ‘stats’
[16:20:49.932] getGlobalsAndPackages() ... DONE
[16:20:49.932] run() for ‘Future’ ...
[16:20:49.933] - state: ‘created’
[16:20:49.933] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:49.947] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:49.947] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:49.947]   - Field: ‘node’
[16:20:49.947]   - Field: ‘label’
[16:20:49.947]   - Field: ‘local’
[16:20:49.947]   - Field: ‘owner’
[16:20:49.947]   - Field: ‘envir’
[16:20:49.947]   - Field: ‘workers’
[16:20:49.947]   - Field: ‘packages’
[16:20:49.948]   - Field: ‘gc’
[16:20:49.948]   - Field: ‘conditions’
[16:20:49.948]   - Field: ‘persistent’
[16:20:49.948]   - Field: ‘expr’
[16:20:49.948]   - Field: ‘uuid’
[16:20:49.948]   - Field: ‘seed’
[16:20:49.948]   - Field: ‘version’
[16:20:49.948]   - Field: ‘result’
[16:20:49.948]   - Field: ‘asynchronous’
[16:20:49.948]   - Field: ‘calls’
[16:20:49.949]   - Field: ‘globals’
[16:20:49.949]   - Field: ‘stdout’
[16:20:49.949]   - Field: ‘earlySignal’
[16:20:49.949]   - Field: ‘lazy’
[16:20:49.949]   - Field: ‘state’
[16:20:49.949] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:49.949] - Launch lazy future ...
[16:20:49.949] Packages needed by the future expression (n = 1): ‘stats’
[16:20:49.949] Packages needed by future strategies (n = 0): <none>
[16:20:49.950] {
[16:20:49.950]     {
[16:20:49.950]         {
[16:20:49.950]             ...future.startTime <- base::Sys.time()
[16:20:49.950]             {
[16:20:49.950]                 {
[16:20:49.950]                   {
[16:20:49.950]                     {
[16:20:49.950]                       {
[16:20:49.950]                         base::local({
[16:20:49.950]                           has_future <- base::requireNamespace("future", 
[16:20:49.950]                             quietly = TRUE)
[16:20:49.950]                           if (has_future) {
[16:20:49.950]                             ns <- base::getNamespace("future")
[16:20:49.950]                             version <- ns[[".package"]][["version"]]
[16:20:49.950]                             if (is.null(version)) 
[16:20:49.950]                               version <- utils::packageVersion("future")
[16:20:49.950]                           }
[16:20:49.950]                           else {
[16:20:49.950]                             version <- NULL
[16:20:49.950]                           }
[16:20:49.950]                           if (!has_future || version < "1.8.0") {
[16:20:49.950]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:49.950]                               "", base::R.version$version.string), 
[16:20:49.950]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:49.950]                                 base::R.version$platform, 8 * 
[16:20:49.950]                                   base::.Machine$sizeof.pointer), 
[16:20:49.950]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:49.950]                                 "release", "version")], collapse = " "), 
[16:20:49.950]                               hostname = base::Sys.info()[["nodename"]])
[16:20:49.950]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:49.950]                               info)
[16:20:49.950]                             info <- base::paste(info, collapse = "; ")
[16:20:49.950]                             if (!has_future) {
[16:20:49.950]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:49.950]                                 info)
[16:20:49.950]                             }
[16:20:49.950]                             else {
[16:20:49.950]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:49.950]                                 info, version)
[16:20:49.950]                             }
[16:20:49.950]                             base::stop(msg)
[16:20:49.950]                           }
[16:20:49.950]                         })
[16:20:49.950]                       }
[16:20:49.950]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:49.950]                       base::options(mc.cores = 1L)
[16:20:49.950]                     }
[16:20:49.950]                     base::local({
[16:20:49.950]                       for (pkg in "stats") {
[16:20:49.950]                         base::loadNamespace(pkg)
[16:20:49.950]                         base::library(pkg, character.only = TRUE)
[16:20:49.950]                       }
[16:20:49.950]                     })
[16:20:49.950]                   }
[16:20:49.950]                   ...future.strategy.old <- future::plan("list")
[16:20:49.950]                   options(future.plan = NULL)
[16:20:49.950]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:49.950]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:49.950]                 }
[16:20:49.950]                 ...future.workdir <- getwd()
[16:20:49.950]             }
[16:20:49.950]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:49.950]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:49.950]         }
[16:20:49.950]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:49.950]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:49.950]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:49.950]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:49.950]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:49.950]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:49.950]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:49.950]             base::names(...future.oldOptions))
[16:20:49.950]     }
[16:20:49.950]     if (FALSE) {
[16:20:49.950]     }
[16:20:49.950]     else {
[16:20:49.950]         if (TRUE) {
[16:20:49.950]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:49.950]                 open = "w")
[16:20:49.950]         }
[16:20:49.950]         else {
[16:20:49.950]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:49.950]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:49.950]         }
[16:20:49.950]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:49.950]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:49.950]             base::sink(type = "output", split = FALSE)
[16:20:49.950]             base::close(...future.stdout)
[16:20:49.950]         }, add = TRUE)
[16:20:49.950]     }
[16:20:49.950]     ...future.frame <- base::sys.nframe()
[16:20:49.950]     ...future.conditions <- base::list()
[16:20:49.950]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:49.950]     if (FALSE) {
[16:20:49.950]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:49.950]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:49.950]     }
[16:20:49.950]     ...future.result <- base::tryCatch({
[16:20:49.950]         base::withCallingHandlers({
[16:20:49.950]             ...future.value <- base::withVisible(base::local({
[16:20:49.950]                 ...future.makeSendCondition <- base::local({
[16:20:49.950]                   sendCondition <- NULL
[16:20:49.950]                   function(frame = 1L) {
[16:20:49.950]                     if (is.function(sendCondition)) 
[16:20:49.950]                       return(sendCondition)
[16:20:49.950]                     ns <- getNamespace("parallel")
[16:20:49.950]                     if (exists("sendData", mode = "function", 
[16:20:49.950]                       envir = ns)) {
[16:20:49.950]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:49.950]                         envir = ns)
[16:20:49.950]                       envir <- sys.frame(frame)
[16:20:49.950]                       master <- NULL
[16:20:49.950]                       while (!identical(envir, .GlobalEnv) && 
[16:20:49.950]                         !identical(envir, emptyenv())) {
[16:20:49.950]                         if (exists("master", mode = "list", envir = envir, 
[16:20:49.950]                           inherits = FALSE)) {
[16:20:49.950]                           master <- get("master", mode = "list", 
[16:20:49.950]                             envir = envir, inherits = FALSE)
[16:20:49.950]                           if (inherits(master, c("SOCKnode", 
[16:20:49.950]                             "SOCK0node"))) {
[16:20:49.950]                             sendCondition <<- function(cond) {
[16:20:49.950]                               data <- list(type = "VALUE", value = cond, 
[16:20:49.950]                                 success = TRUE)
[16:20:49.950]                               parallel_sendData(master, data)
[16:20:49.950]                             }
[16:20:49.950]                             return(sendCondition)
[16:20:49.950]                           }
[16:20:49.950]                         }
[16:20:49.950]                         frame <- frame + 1L
[16:20:49.950]                         envir <- sys.frame(frame)
[16:20:49.950]                       }
[16:20:49.950]                     }
[16:20:49.950]                     sendCondition <<- function(cond) NULL
[16:20:49.950]                   }
[16:20:49.950]                 })
[16:20:49.950]                 withCallingHandlers({
[16:20:49.950]                   {
[16:20:49.950]                     xtabs(~x)
[16:20:49.950]                   }
[16:20:49.950]                 }, immediateCondition = function(cond) {
[16:20:49.950]                   sendCondition <- ...future.makeSendCondition()
[16:20:49.950]                   sendCondition(cond)
[16:20:49.950]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:49.950]                   {
[16:20:49.950]                     inherits <- base::inherits
[16:20:49.950]                     invokeRestart <- base::invokeRestart
[16:20:49.950]                     is.null <- base::is.null
[16:20:49.950]                     muffled <- FALSE
[16:20:49.950]                     if (inherits(cond, "message")) {
[16:20:49.950]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:49.950]                       if (muffled) 
[16:20:49.950]                         invokeRestart("muffleMessage")
[16:20:49.950]                     }
[16:20:49.950]                     else if (inherits(cond, "warning")) {
[16:20:49.950]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:49.950]                       if (muffled) 
[16:20:49.950]                         invokeRestart("muffleWarning")
[16:20:49.950]                     }
[16:20:49.950]                     else if (inherits(cond, "condition")) {
[16:20:49.950]                       if (!is.null(pattern)) {
[16:20:49.950]                         computeRestarts <- base::computeRestarts
[16:20:49.950]                         grepl <- base::grepl
[16:20:49.950]                         restarts <- computeRestarts(cond)
[16:20:49.950]                         for (restart in restarts) {
[16:20:49.950]                           name <- restart$name
[16:20:49.950]                           if (is.null(name)) 
[16:20:49.950]                             next
[16:20:49.950]                           if (!grepl(pattern, name)) 
[16:20:49.950]                             next
[16:20:49.950]                           invokeRestart(restart)
[16:20:49.950]                           muffled <- TRUE
[16:20:49.950]                           break
[16:20:49.950]                         }
[16:20:49.950]                       }
[16:20:49.950]                     }
[16:20:49.950]                     invisible(muffled)
[16:20:49.950]                   }
[16:20:49.950]                   muffleCondition(cond)
[16:20:49.950]                 })
[16:20:49.950]             }))
[16:20:49.950]             future::FutureResult(value = ...future.value$value, 
[16:20:49.950]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:49.950]                   ...future.rng), globalenv = if (FALSE) 
[16:20:49.950]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:49.950]                     ...future.globalenv.names))
[16:20:49.950]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:49.950]         }, condition = base::local({
[16:20:49.950]             c <- base::c
[16:20:49.950]             inherits <- base::inherits
[16:20:49.950]             invokeRestart <- base::invokeRestart
[16:20:49.950]             length <- base::length
[16:20:49.950]             list <- base::list
[16:20:49.950]             seq.int <- base::seq.int
[16:20:49.950]             signalCondition <- base::signalCondition
[16:20:49.950]             sys.calls <- base::sys.calls
[16:20:49.950]             `[[` <- base::`[[`
[16:20:49.950]             `+` <- base::`+`
[16:20:49.950]             `<<-` <- base::`<<-`
[16:20:49.950]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:49.950]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:49.950]                   3L)]
[16:20:49.950]             }
[16:20:49.950]             function(cond) {
[16:20:49.950]                 is_error <- inherits(cond, "error")
[16:20:49.950]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:49.950]                   NULL)
[16:20:49.950]                 if (is_error) {
[16:20:49.950]                   sessionInformation <- function() {
[16:20:49.950]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:49.950]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:49.950]                       search = base::search(), system = base::Sys.info())
[16:20:49.950]                   }
[16:20:49.950]                   ...future.conditions[[length(...future.conditions) + 
[16:20:49.950]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:49.950]                     cond$call), session = sessionInformation(), 
[16:20:49.950]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:49.950]                   signalCondition(cond)
[16:20:49.950]                 }
[16:20:49.950]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:49.950]                 "immediateCondition"))) {
[16:20:49.950]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:49.950]                   ...future.conditions[[length(...future.conditions) + 
[16:20:49.950]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:49.950]                   if (TRUE && !signal) {
[16:20:49.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:49.950]                     {
[16:20:49.950]                       inherits <- base::inherits
[16:20:49.950]                       invokeRestart <- base::invokeRestart
[16:20:49.950]                       is.null <- base::is.null
[16:20:49.950]                       muffled <- FALSE
[16:20:49.950]                       if (inherits(cond, "message")) {
[16:20:49.950]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:49.950]                         if (muffled) 
[16:20:49.950]                           invokeRestart("muffleMessage")
[16:20:49.950]                       }
[16:20:49.950]                       else if (inherits(cond, "warning")) {
[16:20:49.950]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:49.950]                         if (muffled) 
[16:20:49.950]                           invokeRestart("muffleWarning")
[16:20:49.950]                       }
[16:20:49.950]                       else if (inherits(cond, "condition")) {
[16:20:49.950]                         if (!is.null(pattern)) {
[16:20:49.950]                           computeRestarts <- base::computeRestarts
[16:20:49.950]                           grepl <- base::grepl
[16:20:49.950]                           restarts <- computeRestarts(cond)
[16:20:49.950]                           for (restart in restarts) {
[16:20:49.950]                             name <- restart$name
[16:20:49.950]                             if (is.null(name)) 
[16:20:49.950]                               next
[16:20:49.950]                             if (!grepl(pattern, name)) 
[16:20:49.950]                               next
[16:20:49.950]                             invokeRestart(restart)
[16:20:49.950]                             muffled <- TRUE
[16:20:49.950]                             break
[16:20:49.950]                           }
[16:20:49.950]                         }
[16:20:49.950]                       }
[16:20:49.950]                       invisible(muffled)
[16:20:49.950]                     }
[16:20:49.950]                     muffleCondition(cond, pattern = "^muffle")
[16:20:49.950]                   }
[16:20:49.950]                 }
[16:20:49.950]                 else {
[16:20:49.950]                   if (TRUE) {
[16:20:49.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:49.950]                     {
[16:20:49.950]                       inherits <- base::inherits
[16:20:49.950]                       invokeRestart <- base::invokeRestart
[16:20:49.950]                       is.null <- base::is.null
[16:20:49.950]                       muffled <- FALSE
[16:20:49.950]                       if (inherits(cond, "message")) {
[16:20:49.950]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:49.950]                         if (muffled) 
[16:20:49.950]                           invokeRestart("muffleMessage")
[16:20:49.950]                       }
[16:20:49.950]                       else if (inherits(cond, "warning")) {
[16:20:49.950]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:49.950]                         if (muffled) 
[16:20:49.950]                           invokeRestart("muffleWarning")
[16:20:49.950]                       }
[16:20:49.950]                       else if (inherits(cond, "condition")) {
[16:20:49.950]                         if (!is.null(pattern)) {
[16:20:49.950]                           computeRestarts <- base::computeRestarts
[16:20:49.950]                           grepl <- base::grepl
[16:20:49.950]                           restarts <- computeRestarts(cond)
[16:20:49.950]                           for (restart in restarts) {
[16:20:49.950]                             name <- restart$name
[16:20:49.950]                             if (is.null(name)) 
[16:20:49.950]                               next
[16:20:49.950]                             if (!grepl(pattern, name)) 
[16:20:49.950]                               next
[16:20:49.950]                             invokeRestart(restart)
[16:20:49.950]                             muffled <- TRUE
[16:20:49.950]                             break
[16:20:49.950]                           }
[16:20:49.950]                         }
[16:20:49.950]                       }
[16:20:49.950]                       invisible(muffled)
[16:20:49.950]                     }
[16:20:49.950]                     muffleCondition(cond, pattern = "^muffle")
[16:20:49.950]                   }
[16:20:49.950]                 }
[16:20:49.950]             }
[16:20:49.950]         }))
[16:20:49.950]     }, error = function(ex) {
[16:20:49.950]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:49.950]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:49.950]                 ...future.rng), started = ...future.startTime, 
[16:20:49.950]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:49.950]             version = "1.8"), class = "FutureResult")
[16:20:49.950]     }, finally = {
[16:20:49.950]         if (!identical(...future.workdir, getwd())) 
[16:20:49.950]             setwd(...future.workdir)
[16:20:49.950]         {
[16:20:49.950]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:49.950]                 ...future.oldOptions$nwarnings <- NULL
[16:20:49.950]             }
[16:20:49.950]             base::options(...future.oldOptions)
[16:20:49.950]             if (.Platform$OS.type == "windows") {
[16:20:49.950]                 old_names <- names(...future.oldEnvVars)
[16:20:49.950]                 envs <- base::Sys.getenv()
[16:20:49.950]                 names <- names(envs)
[16:20:49.950]                 common <- intersect(names, old_names)
[16:20:49.950]                 added <- setdiff(names, old_names)
[16:20:49.950]                 removed <- setdiff(old_names, names)
[16:20:49.950]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:49.950]                   envs[common]]
[16:20:49.950]                 NAMES <- toupper(changed)
[16:20:49.950]                 args <- list()
[16:20:49.950]                 for (kk in seq_along(NAMES)) {
[16:20:49.950]                   name <- changed[[kk]]
[16:20:49.950]                   NAME <- NAMES[[kk]]
[16:20:49.950]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:49.950]                     next
[16:20:49.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:49.950]                 }
[16:20:49.950]                 NAMES <- toupper(added)
[16:20:49.950]                 for (kk in seq_along(NAMES)) {
[16:20:49.950]                   name <- added[[kk]]
[16:20:49.950]                   NAME <- NAMES[[kk]]
[16:20:49.950]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:49.950]                     next
[16:20:49.950]                   args[[name]] <- ""
[16:20:49.950]                 }
[16:20:49.950]                 NAMES <- toupper(removed)
[16:20:49.950]                 for (kk in seq_along(NAMES)) {
[16:20:49.950]                   name <- removed[[kk]]
[16:20:49.950]                   NAME <- NAMES[[kk]]
[16:20:49.950]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:49.950]                     next
[16:20:49.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:49.950]                 }
[16:20:49.950]                 if (length(args) > 0) 
[16:20:49.950]                   base::do.call(base::Sys.setenv, args = args)
[16:20:49.950]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:49.950]             }
[16:20:49.950]             else {
[16:20:49.950]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:49.950]             }
[16:20:49.950]             {
[16:20:49.950]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:49.950]                   0L) {
[16:20:49.950]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:49.950]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:49.950]                   base::options(opts)
[16:20:49.950]                 }
[16:20:49.950]                 {
[16:20:49.950]                   {
[16:20:49.950]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:49.950]                     NULL
[16:20:49.950]                   }
[16:20:49.950]                   options(future.plan = NULL)
[16:20:49.950]                   if (is.na(NA_character_)) 
[16:20:49.950]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:49.950]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:49.950]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:49.950]                     .init = FALSE)
[16:20:49.950]                 }
[16:20:49.950]             }
[16:20:49.950]         }
[16:20:49.950]     })
[16:20:49.950]     if (TRUE) {
[16:20:49.950]         base::sink(type = "output", split = FALSE)
[16:20:49.950]         if (TRUE) {
[16:20:49.950]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:49.950]         }
[16:20:49.950]         else {
[16:20:49.950]             ...future.result["stdout"] <- base::list(NULL)
[16:20:49.950]         }
[16:20:49.950]         base::close(...future.stdout)
[16:20:49.950]         ...future.stdout <- NULL
[16:20:49.950]     }
[16:20:49.950]     ...future.result$conditions <- ...future.conditions
[16:20:49.950]     ...future.result$finished <- base::Sys.time()
[16:20:49.950]     ...future.result
[16:20:49.950] }
[16:20:49.953] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[16:20:49.953] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[16:20:49.953] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[16:20:49.953] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[16:20:49.954] MultisessionFuture started
[16:20:49.954] - Launch lazy future ... done
[16:20:49.954] run() for ‘MultisessionFuture’ ... done
[16:20:49.954] result() for ClusterFuture ...
[16:20:49.954] receiveMessageFromWorker() for ClusterFuture ...
[16:20:49.954] - Validating connection of MultisessionFuture
[16:20:49.999] - received message: FutureResult
[16:20:49.999] - Received FutureResult
[16:20:49.999] - Erased future from FutureRegistry
[16:20:49.999] result() for ClusterFuture ...
[16:20:49.999] - result already collected: FutureResult
[16:20:50.000] result() for ClusterFuture ... done
[16:20:50.000] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:50.000] result() for ClusterFuture ... done
[16:20:50.000] result() for ClusterFuture ...
[16:20:50.000] - result already collected: FutureResult
[16:20:50.000] result() for ClusterFuture ... done
x
1 2 
2 3 
[16:20:50.001] getGlobalsAndPackages() ...
[16:20:50.001] Searching for globals...
[16:20:50.002] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[16:20:50.002] Searching for globals ... DONE
[16:20:50.002] Resolving globals: FALSE
[16:20:50.003] The total size of the 1 globals is 96 bytes (96 bytes)
[16:20:50.003] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[16:20:50.003] - globals: [1] ‘x’
[16:20:50.003] - packages: [1] ‘stats’
[16:20:50.003] getGlobalsAndPackages() ... DONE
[16:20:50.004] run() for ‘Future’ ...
[16:20:50.004] - state: ‘created’
[16:20:50.004] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:50.018] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:50.018] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:50.018]   - Field: ‘node’
[16:20:50.018]   - Field: ‘label’
[16:20:50.018]   - Field: ‘local’
[16:20:50.018]   - Field: ‘owner’
[16:20:50.019]   - Field: ‘envir’
[16:20:50.019]   - Field: ‘workers’
[16:20:50.019]   - Field: ‘packages’
[16:20:50.019]   - Field: ‘gc’
[16:20:50.019]   - Field: ‘conditions’
[16:20:50.019]   - Field: ‘persistent’
[16:20:50.019]   - Field: ‘expr’
[16:20:50.019]   - Field: ‘uuid’
[16:20:50.019]   - Field: ‘seed’
[16:20:50.019]   - Field: ‘version’
[16:20:50.019]   - Field: ‘result’
[16:20:50.020]   - Field: ‘asynchronous’
[16:20:50.020]   - Field: ‘calls’
[16:20:50.020]   - Field: ‘globals’
[16:20:50.020]   - Field: ‘stdout’
[16:20:50.020]   - Field: ‘earlySignal’
[16:20:50.020]   - Field: ‘lazy’
[16:20:50.020]   - Field: ‘state’
[16:20:50.020] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:50.020] - Launch lazy future ...
[16:20:50.021] Packages needed by the future expression (n = 1): ‘stats’
[16:20:50.021] Packages needed by future strategies (n = 0): <none>
[16:20:50.021] {
[16:20:50.021]     {
[16:20:50.021]         {
[16:20:50.021]             ...future.startTime <- base::Sys.time()
[16:20:50.021]             {
[16:20:50.021]                 {
[16:20:50.021]                   {
[16:20:50.021]                     {
[16:20:50.021]                       {
[16:20:50.021]                         base::local({
[16:20:50.021]                           has_future <- base::requireNamespace("future", 
[16:20:50.021]                             quietly = TRUE)
[16:20:50.021]                           if (has_future) {
[16:20:50.021]                             ns <- base::getNamespace("future")
[16:20:50.021]                             version <- ns[[".package"]][["version"]]
[16:20:50.021]                             if (is.null(version)) 
[16:20:50.021]                               version <- utils::packageVersion("future")
[16:20:50.021]                           }
[16:20:50.021]                           else {
[16:20:50.021]                             version <- NULL
[16:20:50.021]                           }
[16:20:50.021]                           if (!has_future || version < "1.8.0") {
[16:20:50.021]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:50.021]                               "", base::R.version$version.string), 
[16:20:50.021]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:50.021]                                 base::R.version$platform, 8 * 
[16:20:50.021]                                   base::.Machine$sizeof.pointer), 
[16:20:50.021]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:50.021]                                 "release", "version")], collapse = " "), 
[16:20:50.021]                               hostname = base::Sys.info()[["nodename"]])
[16:20:50.021]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:50.021]                               info)
[16:20:50.021]                             info <- base::paste(info, collapse = "; ")
[16:20:50.021]                             if (!has_future) {
[16:20:50.021]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:50.021]                                 info)
[16:20:50.021]                             }
[16:20:50.021]                             else {
[16:20:50.021]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:50.021]                                 info, version)
[16:20:50.021]                             }
[16:20:50.021]                             base::stop(msg)
[16:20:50.021]                           }
[16:20:50.021]                         })
[16:20:50.021]                       }
[16:20:50.021]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:50.021]                       base::options(mc.cores = 1L)
[16:20:50.021]                     }
[16:20:50.021]                     base::local({
[16:20:50.021]                       for (pkg in "stats") {
[16:20:50.021]                         base::loadNamespace(pkg)
[16:20:50.021]                         base::library(pkg, character.only = TRUE)
[16:20:50.021]                       }
[16:20:50.021]                     })
[16:20:50.021]                   }
[16:20:50.021]                   ...future.strategy.old <- future::plan("list")
[16:20:50.021]                   options(future.plan = NULL)
[16:20:50.021]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:50.021]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:50.021]                 }
[16:20:50.021]                 ...future.workdir <- getwd()
[16:20:50.021]             }
[16:20:50.021]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:50.021]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:50.021]         }
[16:20:50.021]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:50.021]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:50.021]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:50.021]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:50.021]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:50.021]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:50.021]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:50.021]             base::names(...future.oldOptions))
[16:20:50.021]     }
[16:20:50.021]     if (FALSE) {
[16:20:50.021]     }
[16:20:50.021]     else {
[16:20:50.021]         if (TRUE) {
[16:20:50.021]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:50.021]                 open = "w")
[16:20:50.021]         }
[16:20:50.021]         else {
[16:20:50.021]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:50.021]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:50.021]         }
[16:20:50.021]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:50.021]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:50.021]             base::sink(type = "output", split = FALSE)
[16:20:50.021]             base::close(...future.stdout)
[16:20:50.021]         }, add = TRUE)
[16:20:50.021]     }
[16:20:50.021]     ...future.frame <- base::sys.nframe()
[16:20:50.021]     ...future.conditions <- base::list()
[16:20:50.021]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:50.021]     if (FALSE) {
[16:20:50.021]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:50.021]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:50.021]     }
[16:20:50.021]     ...future.result <- base::tryCatch({
[16:20:50.021]         base::withCallingHandlers({
[16:20:50.021]             ...future.value <- base::withVisible(base::local({
[16:20:50.021]                 ...future.makeSendCondition <- base::local({
[16:20:50.021]                   sendCondition <- NULL
[16:20:50.021]                   function(frame = 1L) {
[16:20:50.021]                     if (is.function(sendCondition)) 
[16:20:50.021]                       return(sendCondition)
[16:20:50.021]                     ns <- getNamespace("parallel")
[16:20:50.021]                     if (exists("sendData", mode = "function", 
[16:20:50.021]                       envir = ns)) {
[16:20:50.021]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:50.021]                         envir = ns)
[16:20:50.021]                       envir <- sys.frame(frame)
[16:20:50.021]                       master <- NULL
[16:20:50.021]                       while (!identical(envir, .GlobalEnv) && 
[16:20:50.021]                         !identical(envir, emptyenv())) {
[16:20:50.021]                         if (exists("master", mode = "list", envir = envir, 
[16:20:50.021]                           inherits = FALSE)) {
[16:20:50.021]                           master <- get("master", mode = "list", 
[16:20:50.021]                             envir = envir, inherits = FALSE)
[16:20:50.021]                           if (inherits(master, c("SOCKnode", 
[16:20:50.021]                             "SOCK0node"))) {
[16:20:50.021]                             sendCondition <<- function(cond) {
[16:20:50.021]                               data <- list(type = "VALUE", value = cond, 
[16:20:50.021]                                 success = TRUE)
[16:20:50.021]                               parallel_sendData(master, data)
[16:20:50.021]                             }
[16:20:50.021]                             return(sendCondition)
[16:20:50.021]                           }
[16:20:50.021]                         }
[16:20:50.021]                         frame <- frame + 1L
[16:20:50.021]                         envir <- sys.frame(frame)
[16:20:50.021]                       }
[16:20:50.021]                     }
[16:20:50.021]                     sendCondition <<- function(cond) NULL
[16:20:50.021]                   }
[16:20:50.021]                 })
[16:20:50.021]                 withCallingHandlers({
[16:20:50.021]                   {
[16:20:50.021]                     xtabs(~x)
[16:20:50.021]                   }
[16:20:50.021]                 }, immediateCondition = function(cond) {
[16:20:50.021]                   sendCondition <- ...future.makeSendCondition()
[16:20:50.021]                   sendCondition(cond)
[16:20:50.021]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.021]                   {
[16:20:50.021]                     inherits <- base::inherits
[16:20:50.021]                     invokeRestart <- base::invokeRestart
[16:20:50.021]                     is.null <- base::is.null
[16:20:50.021]                     muffled <- FALSE
[16:20:50.021]                     if (inherits(cond, "message")) {
[16:20:50.021]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:50.021]                       if (muffled) 
[16:20:50.021]                         invokeRestart("muffleMessage")
[16:20:50.021]                     }
[16:20:50.021]                     else if (inherits(cond, "warning")) {
[16:20:50.021]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:50.021]                       if (muffled) 
[16:20:50.021]                         invokeRestart("muffleWarning")
[16:20:50.021]                     }
[16:20:50.021]                     else if (inherits(cond, "condition")) {
[16:20:50.021]                       if (!is.null(pattern)) {
[16:20:50.021]                         computeRestarts <- base::computeRestarts
[16:20:50.021]                         grepl <- base::grepl
[16:20:50.021]                         restarts <- computeRestarts(cond)
[16:20:50.021]                         for (restart in restarts) {
[16:20:50.021]                           name <- restart$name
[16:20:50.021]                           if (is.null(name)) 
[16:20:50.021]                             next
[16:20:50.021]                           if (!grepl(pattern, name)) 
[16:20:50.021]                             next
[16:20:50.021]                           invokeRestart(restart)
[16:20:50.021]                           muffled <- TRUE
[16:20:50.021]                           break
[16:20:50.021]                         }
[16:20:50.021]                       }
[16:20:50.021]                     }
[16:20:50.021]                     invisible(muffled)
[16:20:50.021]                   }
[16:20:50.021]                   muffleCondition(cond)
[16:20:50.021]                 })
[16:20:50.021]             }))
[16:20:50.021]             future::FutureResult(value = ...future.value$value, 
[16:20:50.021]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:50.021]                   ...future.rng), globalenv = if (FALSE) 
[16:20:50.021]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:50.021]                     ...future.globalenv.names))
[16:20:50.021]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:50.021]         }, condition = base::local({
[16:20:50.021]             c <- base::c
[16:20:50.021]             inherits <- base::inherits
[16:20:50.021]             invokeRestart <- base::invokeRestart
[16:20:50.021]             length <- base::length
[16:20:50.021]             list <- base::list
[16:20:50.021]             seq.int <- base::seq.int
[16:20:50.021]             signalCondition <- base::signalCondition
[16:20:50.021]             sys.calls <- base::sys.calls
[16:20:50.021]             `[[` <- base::`[[`
[16:20:50.021]             `+` <- base::`+`
[16:20:50.021]             `<<-` <- base::`<<-`
[16:20:50.021]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:50.021]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:50.021]                   3L)]
[16:20:50.021]             }
[16:20:50.021]             function(cond) {
[16:20:50.021]                 is_error <- inherits(cond, "error")
[16:20:50.021]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:50.021]                   NULL)
[16:20:50.021]                 if (is_error) {
[16:20:50.021]                   sessionInformation <- function() {
[16:20:50.021]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:50.021]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:50.021]                       search = base::search(), system = base::Sys.info())
[16:20:50.021]                   }
[16:20:50.021]                   ...future.conditions[[length(...future.conditions) + 
[16:20:50.021]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:50.021]                     cond$call), session = sessionInformation(), 
[16:20:50.021]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:50.021]                   signalCondition(cond)
[16:20:50.021]                 }
[16:20:50.021]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:50.021]                 "immediateCondition"))) {
[16:20:50.021]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:50.021]                   ...future.conditions[[length(...future.conditions) + 
[16:20:50.021]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:50.021]                   if (TRUE && !signal) {
[16:20:50.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.021]                     {
[16:20:50.021]                       inherits <- base::inherits
[16:20:50.021]                       invokeRestart <- base::invokeRestart
[16:20:50.021]                       is.null <- base::is.null
[16:20:50.021]                       muffled <- FALSE
[16:20:50.021]                       if (inherits(cond, "message")) {
[16:20:50.021]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:50.021]                         if (muffled) 
[16:20:50.021]                           invokeRestart("muffleMessage")
[16:20:50.021]                       }
[16:20:50.021]                       else if (inherits(cond, "warning")) {
[16:20:50.021]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:50.021]                         if (muffled) 
[16:20:50.021]                           invokeRestart("muffleWarning")
[16:20:50.021]                       }
[16:20:50.021]                       else if (inherits(cond, "condition")) {
[16:20:50.021]                         if (!is.null(pattern)) {
[16:20:50.021]                           computeRestarts <- base::computeRestarts
[16:20:50.021]                           grepl <- base::grepl
[16:20:50.021]                           restarts <- computeRestarts(cond)
[16:20:50.021]                           for (restart in restarts) {
[16:20:50.021]                             name <- restart$name
[16:20:50.021]                             if (is.null(name)) 
[16:20:50.021]                               next
[16:20:50.021]                             if (!grepl(pattern, name)) 
[16:20:50.021]                               next
[16:20:50.021]                             invokeRestart(restart)
[16:20:50.021]                             muffled <- TRUE
[16:20:50.021]                             break
[16:20:50.021]                           }
[16:20:50.021]                         }
[16:20:50.021]                       }
[16:20:50.021]                       invisible(muffled)
[16:20:50.021]                     }
[16:20:50.021]                     muffleCondition(cond, pattern = "^muffle")
[16:20:50.021]                   }
[16:20:50.021]                 }
[16:20:50.021]                 else {
[16:20:50.021]                   if (TRUE) {
[16:20:50.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.021]                     {
[16:20:50.021]                       inherits <- base::inherits
[16:20:50.021]                       invokeRestart <- base::invokeRestart
[16:20:50.021]                       is.null <- base::is.null
[16:20:50.021]                       muffled <- FALSE
[16:20:50.021]                       if (inherits(cond, "message")) {
[16:20:50.021]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:50.021]                         if (muffled) 
[16:20:50.021]                           invokeRestart("muffleMessage")
[16:20:50.021]                       }
[16:20:50.021]                       else if (inherits(cond, "warning")) {
[16:20:50.021]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:50.021]                         if (muffled) 
[16:20:50.021]                           invokeRestart("muffleWarning")
[16:20:50.021]                       }
[16:20:50.021]                       else if (inherits(cond, "condition")) {
[16:20:50.021]                         if (!is.null(pattern)) {
[16:20:50.021]                           computeRestarts <- base::computeRestarts
[16:20:50.021]                           grepl <- base::grepl
[16:20:50.021]                           restarts <- computeRestarts(cond)
[16:20:50.021]                           for (restart in restarts) {
[16:20:50.021]                             name <- restart$name
[16:20:50.021]                             if (is.null(name)) 
[16:20:50.021]                               next
[16:20:50.021]                             if (!grepl(pattern, name)) 
[16:20:50.021]                               next
[16:20:50.021]                             invokeRestart(restart)
[16:20:50.021]                             muffled <- TRUE
[16:20:50.021]                             break
[16:20:50.021]                           }
[16:20:50.021]                         }
[16:20:50.021]                       }
[16:20:50.021]                       invisible(muffled)
[16:20:50.021]                     }
[16:20:50.021]                     muffleCondition(cond, pattern = "^muffle")
[16:20:50.021]                   }
[16:20:50.021]                 }
[16:20:50.021]             }
[16:20:50.021]         }))
[16:20:50.021]     }, error = function(ex) {
[16:20:50.021]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:50.021]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:50.021]                 ...future.rng), started = ...future.startTime, 
[16:20:50.021]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:50.021]             version = "1.8"), class = "FutureResult")
[16:20:50.021]     }, finally = {
[16:20:50.021]         if (!identical(...future.workdir, getwd())) 
[16:20:50.021]             setwd(...future.workdir)
[16:20:50.021]         {
[16:20:50.021]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:50.021]                 ...future.oldOptions$nwarnings <- NULL
[16:20:50.021]             }
[16:20:50.021]             base::options(...future.oldOptions)
[16:20:50.021]             if (.Platform$OS.type == "windows") {
[16:20:50.021]                 old_names <- names(...future.oldEnvVars)
[16:20:50.021]                 envs <- base::Sys.getenv()
[16:20:50.021]                 names <- names(envs)
[16:20:50.021]                 common <- intersect(names, old_names)
[16:20:50.021]                 added <- setdiff(names, old_names)
[16:20:50.021]                 removed <- setdiff(old_names, names)
[16:20:50.021]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:50.021]                   envs[common]]
[16:20:50.021]                 NAMES <- toupper(changed)
[16:20:50.021]                 args <- list()
[16:20:50.021]                 for (kk in seq_along(NAMES)) {
[16:20:50.021]                   name <- changed[[kk]]
[16:20:50.021]                   NAME <- NAMES[[kk]]
[16:20:50.021]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.021]                     next
[16:20:50.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:50.021]                 }
[16:20:50.021]                 NAMES <- toupper(added)
[16:20:50.021]                 for (kk in seq_along(NAMES)) {
[16:20:50.021]                   name <- added[[kk]]
[16:20:50.021]                   NAME <- NAMES[[kk]]
[16:20:50.021]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.021]                     next
[16:20:50.021]                   args[[name]] <- ""
[16:20:50.021]                 }
[16:20:50.021]                 NAMES <- toupper(removed)
[16:20:50.021]                 for (kk in seq_along(NAMES)) {
[16:20:50.021]                   name <- removed[[kk]]
[16:20:50.021]                   NAME <- NAMES[[kk]]
[16:20:50.021]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.021]                     next
[16:20:50.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:50.021]                 }
[16:20:50.021]                 if (length(args) > 0) 
[16:20:50.021]                   base::do.call(base::Sys.setenv, args = args)
[16:20:50.021]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:50.021]             }
[16:20:50.021]             else {
[16:20:50.021]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:50.021]             }
[16:20:50.021]             {
[16:20:50.021]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:50.021]                   0L) {
[16:20:50.021]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:50.021]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:50.021]                   base::options(opts)
[16:20:50.021]                 }
[16:20:50.021]                 {
[16:20:50.021]                   {
[16:20:50.021]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:50.021]                     NULL
[16:20:50.021]                   }
[16:20:50.021]                   options(future.plan = NULL)
[16:20:50.021]                   if (is.na(NA_character_)) 
[16:20:50.021]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:50.021]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:50.021]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:50.021]                     .init = FALSE)
[16:20:50.021]                 }
[16:20:50.021]             }
[16:20:50.021]         }
[16:20:50.021]     })
[16:20:50.021]     if (TRUE) {
[16:20:50.021]         base::sink(type = "output", split = FALSE)
[16:20:50.021]         if (TRUE) {
[16:20:50.021]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:50.021]         }
[16:20:50.021]         else {
[16:20:50.021]             ...future.result["stdout"] <- base::list(NULL)
[16:20:50.021]         }
[16:20:50.021]         base::close(...future.stdout)
[16:20:50.021]         ...future.stdout <- NULL
[16:20:50.021]     }
[16:20:50.021]     ...future.result$conditions <- ...future.conditions
[16:20:50.021]     ...future.result$finished <- base::Sys.time()
[16:20:50.021]     ...future.result
[16:20:50.021] }
[16:20:50.024] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[16:20:50.024] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[16:20:50.024] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[16:20:50.025] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[16:20:50.025] MultisessionFuture started
[16:20:50.025] - Launch lazy future ... done
[16:20:50.025] run() for ‘MultisessionFuture’ ... done
[16:20:50.026] result() for ClusterFuture ...
[16:20:50.026] receiveMessageFromWorker() for ClusterFuture ...
[16:20:50.026] - Validating connection of MultisessionFuture
[16:20:50.070] - received message: FutureResult
[16:20:50.071] - Received FutureResult
[16:20:50.071] - Erased future from FutureRegistry
[16:20:50.071] result() for ClusterFuture ...
[16:20:50.071] - result already collected: FutureResult
[16:20:50.071] result() for ClusterFuture ... done
[16:20:50.071] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:50.071] result() for ClusterFuture ... done
[16:20:50.071] result() for ClusterFuture ...
[16:20:50.071] - result already collected: FutureResult
[16:20:50.071] result() for ClusterFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[16:20:50.073] getGlobalsAndPackages() ...
[16:20:50.073] Searching for globals...
[16:20:50.075] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[16:20:50.075] Searching for globals ... DONE
[16:20:50.075] Resolving globals: FALSE
[16:20:50.075] 
[16:20:50.076] - packages: [2] ‘stats’, ‘datasets’
[16:20:50.076] getGlobalsAndPackages() ... DONE
[16:20:50.076] run() for ‘Future’ ...
[16:20:50.076] - state: ‘created’
[16:20:50.076] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:50.091] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:50.091] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:50.091]   - Field: ‘node’
[16:20:50.091]   - Field: ‘label’
[16:20:50.091]   - Field: ‘local’
[16:20:50.091]   - Field: ‘owner’
[16:20:50.091]   - Field: ‘envir’
[16:20:50.091]   - Field: ‘workers’
[16:20:50.091]   - Field: ‘packages’
[16:20:50.092]   - Field: ‘gc’
[16:20:50.092]   - Field: ‘conditions’
[16:20:50.092]   - Field: ‘persistent’
[16:20:50.092]   - Field: ‘expr’
[16:20:50.092]   - Field: ‘uuid’
[16:20:50.092]   - Field: ‘seed’
[16:20:50.092]   - Field: ‘version’
[16:20:50.092]   - Field: ‘result’
[16:20:50.092]   - Field: ‘asynchronous’
[16:20:50.092]   - Field: ‘calls’
[16:20:50.093]   - Field: ‘globals’
[16:20:50.093]   - Field: ‘stdout’
[16:20:50.093]   - Field: ‘earlySignal’
[16:20:50.093]   - Field: ‘lazy’
[16:20:50.093]   - Field: ‘state’
[16:20:50.093] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:50.093] - Launch lazy future ...
[16:20:50.093] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:20:50.093] Packages needed by future strategies (n = 0): <none>
[16:20:50.094] {
[16:20:50.094]     {
[16:20:50.094]         {
[16:20:50.094]             ...future.startTime <- base::Sys.time()
[16:20:50.094]             {
[16:20:50.094]                 {
[16:20:50.094]                   {
[16:20:50.094]                     {
[16:20:50.094]                       {
[16:20:50.094]                         base::local({
[16:20:50.094]                           has_future <- base::requireNamespace("future", 
[16:20:50.094]                             quietly = TRUE)
[16:20:50.094]                           if (has_future) {
[16:20:50.094]                             ns <- base::getNamespace("future")
[16:20:50.094]                             version <- ns[[".package"]][["version"]]
[16:20:50.094]                             if (is.null(version)) 
[16:20:50.094]                               version <- utils::packageVersion("future")
[16:20:50.094]                           }
[16:20:50.094]                           else {
[16:20:50.094]                             version <- NULL
[16:20:50.094]                           }
[16:20:50.094]                           if (!has_future || version < "1.8.0") {
[16:20:50.094]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:50.094]                               "", base::R.version$version.string), 
[16:20:50.094]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:50.094]                                 base::R.version$platform, 8 * 
[16:20:50.094]                                   base::.Machine$sizeof.pointer), 
[16:20:50.094]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:50.094]                                 "release", "version")], collapse = " "), 
[16:20:50.094]                               hostname = base::Sys.info()[["nodename"]])
[16:20:50.094]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:50.094]                               info)
[16:20:50.094]                             info <- base::paste(info, collapse = "; ")
[16:20:50.094]                             if (!has_future) {
[16:20:50.094]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:50.094]                                 info)
[16:20:50.094]                             }
[16:20:50.094]                             else {
[16:20:50.094]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:50.094]                                 info, version)
[16:20:50.094]                             }
[16:20:50.094]                             base::stop(msg)
[16:20:50.094]                           }
[16:20:50.094]                         })
[16:20:50.094]                       }
[16:20:50.094]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:50.094]                       base::options(mc.cores = 1L)
[16:20:50.094]                     }
[16:20:50.094]                     base::local({
[16:20:50.094]                       for (pkg in c("stats", "datasets")) {
[16:20:50.094]                         base::loadNamespace(pkg)
[16:20:50.094]                         base::library(pkg, character.only = TRUE)
[16:20:50.094]                       }
[16:20:50.094]                     })
[16:20:50.094]                   }
[16:20:50.094]                   ...future.strategy.old <- future::plan("list")
[16:20:50.094]                   options(future.plan = NULL)
[16:20:50.094]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:50.094]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:50.094]                 }
[16:20:50.094]                 ...future.workdir <- getwd()
[16:20:50.094]             }
[16:20:50.094]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:50.094]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:50.094]         }
[16:20:50.094]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:50.094]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:50.094]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:50.094]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:50.094]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:50.094]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:50.094]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:50.094]             base::names(...future.oldOptions))
[16:20:50.094]     }
[16:20:50.094]     if (FALSE) {
[16:20:50.094]     }
[16:20:50.094]     else {
[16:20:50.094]         if (TRUE) {
[16:20:50.094]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:50.094]                 open = "w")
[16:20:50.094]         }
[16:20:50.094]         else {
[16:20:50.094]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:50.094]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:50.094]         }
[16:20:50.094]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:50.094]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:50.094]             base::sink(type = "output", split = FALSE)
[16:20:50.094]             base::close(...future.stdout)
[16:20:50.094]         }, add = TRUE)
[16:20:50.094]     }
[16:20:50.094]     ...future.frame <- base::sys.nframe()
[16:20:50.094]     ...future.conditions <- base::list()
[16:20:50.094]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:50.094]     if (FALSE) {
[16:20:50.094]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:50.094]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:50.094]     }
[16:20:50.094]     ...future.result <- base::tryCatch({
[16:20:50.094]         base::withCallingHandlers({
[16:20:50.094]             ...future.value <- base::withVisible(base::local({
[16:20:50.094]                 ...future.makeSendCondition <- base::local({
[16:20:50.094]                   sendCondition <- NULL
[16:20:50.094]                   function(frame = 1L) {
[16:20:50.094]                     if (is.function(sendCondition)) 
[16:20:50.094]                       return(sendCondition)
[16:20:50.094]                     ns <- getNamespace("parallel")
[16:20:50.094]                     if (exists("sendData", mode = "function", 
[16:20:50.094]                       envir = ns)) {
[16:20:50.094]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:50.094]                         envir = ns)
[16:20:50.094]                       envir <- sys.frame(frame)
[16:20:50.094]                       master <- NULL
[16:20:50.094]                       while (!identical(envir, .GlobalEnv) && 
[16:20:50.094]                         !identical(envir, emptyenv())) {
[16:20:50.094]                         if (exists("master", mode = "list", envir = envir, 
[16:20:50.094]                           inherits = FALSE)) {
[16:20:50.094]                           master <- get("master", mode = "list", 
[16:20:50.094]                             envir = envir, inherits = FALSE)
[16:20:50.094]                           if (inherits(master, c("SOCKnode", 
[16:20:50.094]                             "SOCK0node"))) {
[16:20:50.094]                             sendCondition <<- function(cond) {
[16:20:50.094]                               data <- list(type = "VALUE", value = cond, 
[16:20:50.094]                                 success = TRUE)
[16:20:50.094]                               parallel_sendData(master, data)
[16:20:50.094]                             }
[16:20:50.094]                             return(sendCondition)
[16:20:50.094]                           }
[16:20:50.094]                         }
[16:20:50.094]                         frame <- frame + 1L
[16:20:50.094]                         envir <- sys.frame(frame)
[16:20:50.094]                       }
[16:20:50.094]                     }
[16:20:50.094]                     sendCondition <<- function(cond) NULL
[16:20:50.094]                   }
[16:20:50.094]                 })
[16:20:50.094]                 withCallingHandlers({
[16:20:50.094]                   {
[16:20:50.094]                     lm(dist ~ . - 1, data = cars)
[16:20:50.094]                   }
[16:20:50.094]                 }, immediateCondition = function(cond) {
[16:20:50.094]                   sendCondition <- ...future.makeSendCondition()
[16:20:50.094]                   sendCondition(cond)
[16:20:50.094]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.094]                   {
[16:20:50.094]                     inherits <- base::inherits
[16:20:50.094]                     invokeRestart <- base::invokeRestart
[16:20:50.094]                     is.null <- base::is.null
[16:20:50.094]                     muffled <- FALSE
[16:20:50.094]                     if (inherits(cond, "message")) {
[16:20:50.094]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:50.094]                       if (muffled) 
[16:20:50.094]                         invokeRestart("muffleMessage")
[16:20:50.094]                     }
[16:20:50.094]                     else if (inherits(cond, "warning")) {
[16:20:50.094]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:50.094]                       if (muffled) 
[16:20:50.094]                         invokeRestart("muffleWarning")
[16:20:50.094]                     }
[16:20:50.094]                     else if (inherits(cond, "condition")) {
[16:20:50.094]                       if (!is.null(pattern)) {
[16:20:50.094]                         computeRestarts <- base::computeRestarts
[16:20:50.094]                         grepl <- base::grepl
[16:20:50.094]                         restarts <- computeRestarts(cond)
[16:20:50.094]                         for (restart in restarts) {
[16:20:50.094]                           name <- restart$name
[16:20:50.094]                           if (is.null(name)) 
[16:20:50.094]                             next
[16:20:50.094]                           if (!grepl(pattern, name)) 
[16:20:50.094]                             next
[16:20:50.094]                           invokeRestart(restart)
[16:20:50.094]                           muffled <- TRUE
[16:20:50.094]                           break
[16:20:50.094]                         }
[16:20:50.094]                       }
[16:20:50.094]                     }
[16:20:50.094]                     invisible(muffled)
[16:20:50.094]                   }
[16:20:50.094]                   muffleCondition(cond)
[16:20:50.094]                 })
[16:20:50.094]             }))
[16:20:50.094]             future::FutureResult(value = ...future.value$value, 
[16:20:50.094]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:50.094]                   ...future.rng), globalenv = if (FALSE) 
[16:20:50.094]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:50.094]                     ...future.globalenv.names))
[16:20:50.094]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:50.094]         }, condition = base::local({
[16:20:50.094]             c <- base::c
[16:20:50.094]             inherits <- base::inherits
[16:20:50.094]             invokeRestart <- base::invokeRestart
[16:20:50.094]             length <- base::length
[16:20:50.094]             list <- base::list
[16:20:50.094]             seq.int <- base::seq.int
[16:20:50.094]             signalCondition <- base::signalCondition
[16:20:50.094]             sys.calls <- base::sys.calls
[16:20:50.094]             `[[` <- base::`[[`
[16:20:50.094]             `+` <- base::`+`
[16:20:50.094]             `<<-` <- base::`<<-`
[16:20:50.094]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:50.094]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:50.094]                   3L)]
[16:20:50.094]             }
[16:20:50.094]             function(cond) {
[16:20:50.094]                 is_error <- inherits(cond, "error")
[16:20:50.094]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:50.094]                   NULL)
[16:20:50.094]                 if (is_error) {
[16:20:50.094]                   sessionInformation <- function() {
[16:20:50.094]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:50.094]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:50.094]                       search = base::search(), system = base::Sys.info())
[16:20:50.094]                   }
[16:20:50.094]                   ...future.conditions[[length(...future.conditions) + 
[16:20:50.094]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:50.094]                     cond$call), session = sessionInformation(), 
[16:20:50.094]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:50.094]                   signalCondition(cond)
[16:20:50.094]                 }
[16:20:50.094]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:50.094]                 "immediateCondition"))) {
[16:20:50.094]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:50.094]                   ...future.conditions[[length(...future.conditions) + 
[16:20:50.094]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:50.094]                   if (TRUE && !signal) {
[16:20:50.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.094]                     {
[16:20:50.094]                       inherits <- base::inherits
[16:20:50.094]                       invokeRestart <- base::invokeRestart
[16:20:50.094]                       is.null <- base::is.null
[16:20:50.094]                       muffled <- FALSE
[16:20:50.094]                       if (inherits(cond, "message")) {
[16:20:50.094]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:50.094]                         if (muffled) 
[16:20:50.094]                           invokeRestart("muffleMessage")
[16:20:50.094]                       }
[16:20:50.094]                       else if (inherits(cond, "warning")) {
[16:20:50.094]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:50.094]                         if (muffled) 
[16:20:50.094]                           invokeRestart("muffleWarning")
[16:20:50.094]                       }
[16:20:50.094]                       else if (inherits(cond, "condition")) {
[16:20:50.094]                         if (!is.null(pattern)) {
[16:20:50.094]                           computeRestarts <- base::computeRestarts
[16:20:50.094]                           grepl <- base::grepl
[16:20:50.094]                           restarts <- computeRestarts(cond)
[16:20:50.094]                           for (restart in restarts) {
[16:20:50.094]                             name <- restart$name
[16:20:50.094]                             if (is.null(name)) 
[16:20:50.094]                               next
[16:20:50.094]                             if (!grepl(pattern, name)) 
[16:20:50.094]                               next
[16:20:50.094]                             invokeRestart(restart)
[16:20:50.094]                             muffled <- TRUE
[16:20:50.094]                             break
[16:20:50.094]                           }
[16:20:50.094]                         }
[16:20:50.094]                       }
[16:20:50.094]                       invisible(muffled)
[16:20:50.094]                     }
[16:20:50.094]                     muffleCondition(cond, pattern = "^muffle")
[16:20:50.094]                   }
[16:20:50.094]                 }
[16:20:50.094]                 else {
[16:20:50.094]                   if (TRUE) {
[16:20:50.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.094]                     {
[16:20:50.094]                       inherits <- base::inherits
[16:20:50.094]                       invokeRestart <- base::invokeRestart
[16:20:50.094]                       is.null <- base::is.null
[16:20:50.094]                       muffled <- FALSE
[16:20:50.094]                       if (inherits(cond, "message")) {
[16:20:50.094]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:50.094]                         if (muffled) 
[16:20:50.094]                           invokeRestart("muffleMessage")
[16:20:50.094]                       }
[16:20:50.094]                       else if (inherits(cond, "warning")) {
[16:20:50.094]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:50.094]                         if (muffled) 
[16:20:50.094]                           invokeRestart("muffleWarning")
[16:20:50.094]                       }
[16:20:50.094]                       else if (inherits(cond, "condition")) {
[16:20:50.094]                         if (!is.null(pattern)) {
[16:20:50.094]                           computeRestarts <- base::computeRestarts
[16:20:50.094]                           grepl <- base::grepl
[16:20:50.094]                           restarts <- computeRestarts(cond)
[16:20:50.094]                           for (restart in restarts) {
[16:20:50.094]                             name <- restart$name
[16:20:50.094]                             if (is.null(name)) 
[16:20:50.094]                               next
[16:20:50.094]                             if (!grepl(pattern, name)) 
[16:20:50.094]                               next
[16:20:50.094]                             invokeRestart(restart)
[16:20:50.094]                             muffled <- TRUE
[16:20:50.094]                             break
[16:20:50.094]                           }
[16:20:50.094]                         }
[16:20:50.094]                       }
[16:20:50.094]                       invisible(muffled)
[16:20:50.094]                     }
[16:20:50.094]                     muffleCondition(cond, pattern = "^muffle")
[16:20:50.094]                   }
[16:20:50.094]                 }
[16:20:50.094]             }
[16:20:50.094]         }))
[16:20:50.094]     }, error = function(ex) {
[16:20:50.094]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:50.094]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:50.094]                 ...future.rng), started = ...future.startTime, 
[16:20:50.094]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:50.094]             version = "1.8"), class = "FutureResult")
[16:20:50.094]     }, finally = {
[16:20:50.094]         if (!identical(...future.workdir, getwd())) 
[16:20:50.094]             setwd(...future.workdir)
[16:20:50.094]         {
[16:20:50.094]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:50.094]                 ...future.oldOptions$nwarnings <- NULL
[16:20:50.094]             }
[16:20:50.094]             base::options(...future.oldOptions)
[16:20:50.094]             if (.Platform$OS.type == "windows") {
[16:20:50.094]                 old_names <- names(...future.oldEnvVars)
[16:20:50.094]                 envs <- base::Sys.getenv()
[16:20:50.094]                 names <- names(envs)
[16:20:50.094]                 common <- intersect(names, old_names)
[16:20:50.094]                 added <- setdiff(names, old_names)
[16:20:50.094]                 removed <- setdiff(old_names, names)
[16:20:50.094]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:50.094]                   envs[common]]
[16:20:50.094]                 NAMES <- toupper(changed)
[16:20:50.094]                 args <- list()
[16:20:50.094]                 for (kk in seq_along(NAMES)) {
[16:20:50.094]                   name <- changed[[kk]]
[16:20:50.094]                   NAME <- NAMES[[kk]]
[16:20:50.094]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.094]                     next
[16:20:50.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:50.094]                 }
[16:20:50.094]                 NAMES <- toupper(added)
[16:20:50.094]                 for (kk in seq_along(NAMES)) {
[16:20:50.094]                   name <- added[[kk]]
[16:20:50.094]                   NAME <- NAMES[[kk]]
[16:20:50.094]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.094]                     next
[16:20:50.094]                   args[[name]] <- ""
[16:20:50.094]                 }
[16:20:50.094]                 NAMES <- toupper(removed)
[16:20:50.094]                 for (kk in seq_along(NAMES)) {
[16:20:50.094]                   name <- removed[[kk]]
[16:20:50.094]                   NAME <- NAMES[[kk]]
[16:20:50.094]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.094]                     next
[16:20:50.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:50.094]                 }
[16:20:50.094]                 if (length(args) > 0) 
[16:20:50.094]                   base::do.call(base::Sys.setenv, args = args)
[16:20:50.094]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:50.094]             }
[16:20:50.094]             else {
[16:20:50.094]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:50.094]             }
[16:20:50.094]             {
[16:20:50.094]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:50.094]                   0L) {
[16:20:50.094]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:50.094]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:50.094]                   base::options(opts)
[16:20:50.094]                 }
[16:20:50.094]                 {
[16:20:50.094]                   {
[16:20:50.094]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:50.094]                     NULL
[16:20:50.094]                   }
[16:20:50.094]                   options(future.plan = NULL)
[16:20:50.094]                   if (is.na(NA_character_)) 
[16:20:50.094]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:50.094]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:50.094]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:50.094]                     .init = FALSE)
[16:20:50.094]                 }
[16:20:50.094]             }
[16:20:50.094]         }
[16:20:50.094]     })
[16:20:50.094]     if (TRUE) {
[16:20:50.094]         base::sink(type = "output", split = FALSE)
[16:20:50.094]         if (TRUE) {
[16:20:50.094]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:50.094]         }
[16:20:50.094]         else {
[16:20:50.094]             ...future.result["stdout"] <- base::list(NULL)
[16:20:50.094]         }
[16:20:50.094]         base::close(...future.stdout)
[16:20:50.094]         ...future.stdout <- NULL
[16:20:50.094]     }
[16:20:50.094]     ...future.result$conditions <- ...future.conditions
[16:20:50.094]     ...future.result$finished <- base::Sys.time()
[16:20:50.094]     ...future.result
[16:20:50.094] }
[16:20:50.097] MultisessionFuture started
[16:20:50.097] - Launch lazy future ... done
[16:20:50.097] run() for ‘MultisessionFuture’ ... done
[16:20:50.098] result() for ClusterFuture ...
[16:20:50.098] receiveMessageFromWorker() for ClusterFuture ...
[16:20:50.098] - Validating connection of MultisessionFuture
[16:20:50.143] - received message: FutureResult
[16:20:50.143] - Received FutureResult
[16:20:50.143] - Erased future from FutureRegistry
[16:20:50.143] result() for ClusterFuture ...
[16:20:50.143] - result already collected: FutureResult
[16:20:50.144] result() for ClusterFuture ... done
[16:20:50.144] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:50.144] result() for ClusterFuture ... done
[16:20:50.144] result() for ClusterFuture ...
[16:20:50.144] - result already collected: FutureResult
[16:20:50.144] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[16:20:50.148] getGlobalsAndPackages() ...
[16:20:50.148] Searching for globals...
[16:20:50.150] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[16:20:50.150] Searching for globals ... DONE
[16:20:50.150] Resolving globals: FALSE
[16:20:50.151] 
[16:20:50.151] - packages: [2] ‘stats’, ‘datasets’
[16:20:50.151] getGlobalsAndPackages() ... DONE
[16:20:50.151] run() for ‘Future’ ...
[16:20:50.151] - state: ‘created’
[16:20:50.151] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:50.165] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:50.165] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:50.165]   - Field: ‘node’
[16:20:50.166]   - Field: ‘label’
[16:20:50.166]   - Field: ‘local’
[16:20:50.166]   - Field: ‘owner’
[16:20:50.166]   - Field: ‘envir’
[16:20:50.166]   - Field: ‘workers’
[16:20:50.166]   - Field: ‘packages’
[16:20:50.166]   - Field: ‘gc’
[16:20:50.166]   - Field: ‘conditions’
[16:20:50.166]   - Field: ‘persistent’
[16:20:50.166]   - Field: ‘expr’
[16:20:50.166]   - Field: ‘uuid’
[16:20:50.167]   - Field: ‘seed’
[16:20:50.167]   - Field: ‘version’
[16:20:50.167]   - Field: ‘result’
[16:20:50.167]   - Field: ‘asynchronous’
[16:20:50.167]   - Field: ‘calls’
[16:20:50.167]   - Field: ‘globals’
[16:20:50.167]   - Field: ‘stdout’
[16:20:50.167]   - Field: ‘earlySignal’
[16:20:50.167]   - Field: ‘lazy’
[16:20:50.167]   - Field: ‘state’
[16:20:50.167] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:50.168] - Launch lazy future ...
[16:20:50.168] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:20:50.168] Packages needed by future strategies (n = 0): <none>
[16:20:50.168] {
[16:20:50.168]     {
[16:20:50.168]         {
[16:20:50.168]             ...future.startTime <- base::Sys.time()
[16:20:50.168]             {
[16:20:50.168]                 {
[16:20:50.168]                   {
[16:20:50.168]                     {
[16:20:50.168]                       {
[16:20:50.168]                         base::local({
[16:20:50.168]                           has_future <- base::requireNamespace("future", 
[16:20:50.168]                             quietly = TRUE)
[16:20:50.168]                           if (has_future) {
[16:20:50.168]                             ns <- base::getNamespace("future")
[16:20:50.168]                             version <- ns[[".package"]][["version"]]
[16:20:50.168]                             if (is.null(version)) 
[16:20:50.168]                               version <- utils::packageVersion("future")
[16:20:50.168]                           }
[16:20:50.168]                           else {
[16:20:50.168]                             version <- NULL
[16:20:50.168]                           }
[16:20:50.168]                           if (!has_future || version < "1.8.0") {
[16:20:50.168]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:50.168]                               "", base::R.version$version.string), 
[16:20:50.168]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:50.168]                                 base::R.version$platform, 8 * 
[16:20:50.168]                                   base::.Machine$sizeof.pointer), 
[16:20:50.168]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:50.168]                                 "release", "version")], collapse = " "), 
[16:20:50.168]                               hostname = base::Sys.info()[["nodename"]])
[16:20:50.168]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:50.168]                               info)
[16:20:50.168]                             info <- base::paste(info, collapse = "; ")
[16:20:50.168]                             if (!has_future) {
[16:20:50.168]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:50.168]                                 info)
[16:20:50.168]                             }
[16:20:50.168]                             else {
[16:20:50.168]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:50.168]                                 info, version)
[16:20:50.168]                             }
[16:20:50.168]                             base::stop(msg)
[16:20:50.168]                           }
[16:20:50.168]                         })
[16:20:50.168]                       }
[16:20:50.168]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:50.168]                       base::options(mc.cores = 1L)
[16:20:50.168]                     }
[16:20:50.168]                     base::local({
[16:20:50.168]                       for (pkg in c("stats", "datasets")) {
[16:20:50.168]                         base::loadNamespace(pkg)
[16:20:50.168]                         base::library(pkg, character.only = TRUE)
[16:20:50.168]                       }
[16:20:50.168]                     })
[16:20:50.168]                   }
[16:20:50.168]                   ...future.strategy.old <- future::plan("list")
[16:20:50.168]                   options(future.plan = NULL)
[16:20:50.168]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:50.168]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:50.168]                 }
[16:20:50.168]                 ...future.workdir <- getwd()
[16:20:50.168]             }
[16:20:50.168]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:50.168]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:50.168]         }
[16:20:50.168]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:50.168]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:50.168]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:50.168]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:50.168]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:50.168]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:50.168]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:50.168]             base::names(...future.oldOptions))
[16:20:50.168]     }
[16:20:50.168]     if (FALSE) {
[16:20:50.168]     }
[16:20:50.168]     else {
[16:20:50.168]         if (TRUE) {
[16:20:50.168]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:50.168]                 open = "w")
[16:20:50.168]         }
[16:20:50.168]         else {
[16:20:50.168]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:50.168]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:50.168]         }
[16:20:50.168]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:50.168]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:50.168]             base::sink(type = "output", split = FALSE)
[16:20:50.168]             base::close(...future.stdout)
[16:20:50.168]         }, add = TRUE)
[16:20:50.168]     }
[16:20:50.168]     ...future.frame <- base::sys.nframe()
[16:20:50.168]     ...future.conditions <- base::list()
[16:20:50.168]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:50.168]     if (FALSE) {
[16:20:50.168]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:50.168]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:50.168]     }
[16:20:50.168]     ...future.result <- base::tryCatch({
[16:20:50.168]         base::withCallingHandlers({
[16:20:50.168]             ...future.value <- base::withVisible(base::local({
[16:20:50.168]                 ...future.makeSendCondition <- base::local({
[16:20:50.168]                   sendCondition <- NULL
[16:20:50.168]                   function(frame = 1L) {
[16:20:50.168]                     if (is.function(sendCondition)) 
[16:20:50.168]                       return(sendCondition)
[16:20:50.168]                     ns <- getNamespace("parallel")
[16:20:50.168]                     if (exists("sendData", mode = "function", 
[16:20:50.168]                       envir = ns)) {
[16:20:50.168]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:50.168]                         envir = ns)
[16:20:50.168]                       envir <- sys.frame(frame)
[16:20:50.168]                       master <- NULL
[16:20:50.168]                       while (!identical(envir, .GlobalEnv) && 
[16:20:50.168]                         !identical(envir, emptyenv())) {
[16:20:50.168]                         if (exists("master", mode = "list", envir = envir, 
[16:20:50.168]                           inherits = FALSE)) {
[16:20:50.168]                           master <- get("master", mode = "list", 
[16:20:50.168]                             envir = envir, inherits = FALSE)
[16:20:50.168]                           if (inherits(master, c("SOCKnode", 
[16:20:50.168]                             "SOCK0node"))) {
[16:20:50.168]                             sendCondition <<- function(cond) {
[16:20:50.168]                               data <- list(type = "VALUE", value = cond, 
[16:20:50.168]                                 success = TRUE)
[16:20:50.168]                               parallel_sendData(master, data)
[16:20:50.168]                             }
[16:20:50.168]                             return(sendCondition)
[16:20:50.168]                           }
[16:20:50.168]                         }
[16:20:50.168]                         frame <- frame + 1L
[16:20:50.168]                         envir <- sys.frame(frame)
[16:20:50.168]                       }
[16:20:50.168]                     }
[16:20:50.168]                     sendCondition <<- function(cond) NULL
[16:20:50.168]                   }
[16:20:50.168]                 })
[16:20:50.168]                 withCallingHandlers({
[16:20:50.168]                   {
[16:20:50.168]                     lm(dist ~ . + 0, data = cars)
[16:20:50.168]                   }
[16:20:50.168]                 }, immediateCondition = function(cond) {
[16:20:50.168]                   sendCondition <- ...future.makeSendCondition()
[16:20:50.168]                   sendCondition(cond)
[16:20:50.168]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.168]                   {
[16:20:50.168]                     inherits <- base::inherits
[16:20:50.168]                     invokeRestart <- base::invokeRestart
[16:20:50.168]                     is.null <- base::is.null
[16:20:50.168]                     muffled <- FALSE
[16:20:50.168]                     if (inherits(cond, "message")) {
[16:20:50.168]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:50.168]                       if (muffled) 
[16:20:50.168]                         invokeRestart("muffleMessage")
[16:20:50.168]                     }
[16:20:50.168]                     else if (inherits(cond, "warning")) {
[16:20:50.168]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:50.168]                       if (muffled) 
[16:20:50.168]                         invokeRestart("muffleWarning")
[16:20:50.168]                     }
[16:20:50.168]                     else if (inherits(cond, "condition")) {
[16:20:50.168]                       if (!is.null(pattern)) {
[16:20:50.168]                         computeRestarts <- base::computeRestarts
[16:20:50.168]                         grepl <- base::grepl
[16:20:50.168]                         restarts <- computeRestarts(cond)
[16:20:50.168]                         for (restart in restarts) {
[16:20:50.168]                           name <- restart$name
[16:20:50.168]                           if (is.null(name)) 
[16:20:50.168]                             next
[16:20:50.168]                           if (!grepl(pattern, name)) 
[16:20:50.168]                             next
[16:20:50.168]                           invokeRestart(restart)
[16:20:50.168]                           muffled <- TRUE
[16:20:50.168]                           break
[16:20:50.168]                         }
[16:20:50.168]                       }
[16:20:50.168]                     }
[16:20:50.168]                     invisible(muffled)
[16:20:50.168]                   }
[16:20:50.168]                   muffleCondition(cond)
[16:20:50.168]                 })
[16:20:50.168]             }))
[16:20:50.168]             future::FutureResult(value = ...future.value$value, 
[16:20:50.168]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:50.168]                   ...future.rng), globalenv = if (FALSE) 
[16:20:50.168]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:50.168]                     ...future.globalenv.names))
[16:20:50.168]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:50.168]         }, condition = base::local({
[16:20:50.168]             c <- base::c
[16:20:50.168]             inherits <- base::inherits
[16:20:50.168]             invokeRestart <- base::invokeRestart
[16:20:50.168]             length <- base::length
[16:20:50.168]             list <- base::list
[16:20:50.168]             seq.int <- base::seq.int
[16:20:50.168]             signalCondition <- base::signalCondition
[16:20:50.168]             sys.calls <- base::sys.calls
[16:20:50.168]             `[[` <- base::`[[`
[16:20:50.168]             `+` <- base::`+`
[16:20:50.168]             `<<-` <- base::`<<-`
[16:20:50.168]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:50.168]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:50.168]                   3L)]
[16:20:50.168]             }
[16:20:50.168]             function(cond) {
[16:20:50.168]                 is_error <- inherits(cond, "error")
[16:20:50.168]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:50.168]                   NULL)
[16:20:50.168]                 if (is_error) {
[16:20:50.168]                   sessionInformation <- function() {
[16:20:50.168]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:50.168]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:50.168]                       search = base::search(), system = base::Sys.info())
[16:20:50.168]                   }
[16:20:50.168]                   ...future.conditions[[length(...future.conditions) + 
[16:20:50.168]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:50.168]                     cond$call), session = sessionInformation(), 
[16:20:50.168]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:50.168]                   signalCondition(cond)
[16:20:50.168]                 }
[16:20:50.168]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:50.168]                 "immediateCondition"))) {
[16:20:50.168]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:50.168]                   ...future.conditions[[length(...future.conditions) + 
[16:20:50.168]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:50.168]                   if (TRUE && !signal) {
[16:20:50.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.168]                     {
[16:20:50.168]                       inherits <- base::inherits
[16:20:50.168]                       invokeRestart <- base::invokeRestart
[16:20:50.168]                       is.null <- base::is.null
[16:20:50.168]                       muffled <- FALSE
[16:20:50.168]                       if (inherits(cond, "message")) {
[16:20:50.168]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:50.168]                         if (muffled) 
[16:20:50.168]                           invokeRestart("muffleMessage")
[16:20:50.168]                       }
[16:20:50.168]                       else if (inherits(cond, "warning")) {
[16:20:50.168]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:50.168]                         if (muffled) 
[16:20:50.168]                           invokeRestart("muffleWarning")
[16:20:50.168]                       }
[16:20:50.168]                       else if (inherits(cond, "condition")) {
[16:20:50.168]                         if (!is.null(pattern)) {
[16:20:50.168]                           computeRestarts <- base::computeRestarts
[16:20:50.168]                           grepl <- base::grepl
[16:20:50.168]                           restarts <- computeRestarts(cond)
[16:20:50.168]                           for (restart in restarts) {
[16:20:50.168]                             name <- restart$name
[16:20:50.168]                             if (is.null(name)) 
[16:20:50.168]                               next
[16:20:50.168]                             if (!grepl(pattern, name)) 
[16:20:50.168]                               next
[16:20:50.168]                             invokeRestart(restart)
[16:20:50.168]                             muffled <- TRUE
[16:20:50.168]                             break
[16:20:50.168]                           }
[16:20:50.168]                         }
[16:20:50.168]                       }
[16:20:50.168]                       invisible(muffled)
[16:20:50.168]                     }
[16:20:50.168]                     muffleCondition(cond, pattern = "^muffle")
[16:20:50.168]                   }
[16:20:50.168]                 }
[16:20:50.168]                 else {
[16:20:50.168]                   if (TRUE) {
[16:20:50.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.168]                     {
[16:20:50.168]                       inherits <- base::inherits
[16:20:50.168]                       invokeRestart <- base::invokeRestart
[16:20:50.168]                       is.null <- base::is.null
[16:20:50.168]                       muffled <- FALSE
[16:20:50.168]                       if (inherits(cond, "message")) {
[16:20:50.168]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:50.168]                         if (muffled) 
[16:20:50.168]                           invokeRestart("muffleMessage")
[16:20:50.168]                       }
[16:20:50.168]                       else if (inherits(cond, "warning")) {
[16:20:50.168]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:50.168]                         if (muffled) 
[16:20:50.168]                           invokeRestart("muffleWarning")
[16:20:50.168]                       }
[16:20:50.168]                       else if (inherits(cond, "condition")) {
[16:20:50.168]                         if (!is.null(pattern)) {
[16:20:50.168]                           computeRestarts <- base::computeRestarts
[16:20:50.168]                           grepl <- base::grepl
[16:20:50.168]                           restarts <- computeRestarts(cond)
[16:20:50.168]                           for (restart in restarts) {
[16:20:50.168]                             name <- restart$name
[16:20:50.168]                             if (is.null(name)) 
[16:20:50.168]                               next
[16:20:50.168]                             if (!grepl(pattern, name)) 
[16:20:50.168]                               next
[16:20:50.168]                             invokeRestart(restart)
[16:20:50.168]                             muffled <- TRUE
[16:20:50.168]                             break
[16:20:50.168]                           }
[16:20:50.168]                         }
[16:20:50.168]                       }
[16:20:50.168]                       invisible(muffled)
[16:20:50.168]                     }
[16:20:50.168]                     muffleCondition(cond, pattern = "^muffle")
[16:20:50.168]                   }
[16:20:50.168]                 }
[16:20:50.168]             }
[16:20:50.168]         }))
[16:20:50.168]     }, error = function(ex) {
[16:20:50.168]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:50.168]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:50.168]                 ...future.rng), started = ...future.startTime, 
[16:20:50.168]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:50.168]             version = "1.8"), class = "FutureResult")
[16:20:50.168]     }, finally = {
[16:20:50.168]         if (!identical(...future.workdir, getwd())) 
[16:20:50.168]             setwd(...future.workdir)
[16:20:50.168]         {
[16:20:50.168]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:50.168]                 ...future.oldOptions$nwarnings <- NULL
[16:20:50.168]             }
[16:20:50.168]             base::options(...future.oldOptions)
[16:20:50.168]             if (.Platform$OS.type == "windows") {
[16:20:50.168]                 old_names <- names(...future.oldEnvVars)
[16:20:50.168]                 envs <- base::Sys.getenv()
[16:20:50.168]                 names <- names(envs)
[16:20:50.168]                 common <- intersect(names, old_names)
[16:20:50.168]                 added <- setdiff(names, old_names)
[16:20:50.168]                 removed <- setdiff(old_names, names)
[16:20:50.168]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:50.168]                   envs[common]]
[16:20:50.168]                 NAMES <- toupper(changed)
[16:20:50.168]                 args <- list()
[16:20:50.168]                 for (kk in seq_along(NAMES)) {
[16:20:50.168]                   name <- changed[[kk]]
[16:20:50.168]                   NAME <- NAMES[[kk]]
[16:20:50.168]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.168]                     next
[16:20:50.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:50.168]                 }
[16:20:50.168]                 NAMES <- toupper(added)
[16:20:50.168]                 for (kk in seq_along(NAMES)) {
[16:20:50.168]                   name <- added[[kk]]
[16:20:50.168]                   NAME <- NAMES[[kk]]
[16:20:50.168]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.168]                     next
[16:20:50.168]                   args[[name]] <- ""
[16:20:50.168]                 }
[16:20:50.168]                 NAMES <- toupper(removed)
[16:20:50.168]                 for (kk in seq_along(NAMES)) {
[16:20:50.168]                   name <- removed[[kk]]
[16:20:50.168]                   NAME <- NAMES[[kk]]
[16:20:50.168]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.168]                     next
[16:20:50.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:50.168]                 }
[16:20:50.168]                 if (length(args) > 0) 
[16:20:50.168]                   base::do.call(base::Sys.setenv, args = args)
[16:20:50.168]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:50.168]             }
[16:20:50.168]             else {
[16:20:50.168]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:50.168]             }
[16:20:50.168]             {
[16:20:50.168]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:50.168]                   0L) {
[16:20:50.168]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:50.168]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:50.168]                   base::options(opts)
[16:20:50.168]                 }
[16:20:50.168]                 {
[16:20:50.168]                   {
[16:20:50.168]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:50.168]                     NULL
[16:20:50.168]                   }
[16:20:50.168]                   options(future.plan = NULL)
[16:20:50.168]                   if (is.na(NA_character_)) 
[16:20:50.168]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:50.168]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:50.168]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:50.168]                     .init = FALSE)
[16:20:50.168]                 }
[16:20:50.168]             }
[16:20:50.168]         }
[16:20:50.168]     })
[16:20:50.168]     if (TRUE) {
[16:20:50.168]         base::sink(type = "output", split = FALSE)
[16:20:50.168]         if (TRUE) {
[16:20:50.168]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:50.168]         }
[16:20:50.168]         else {
[16:20:50.168]             ...future.result["stdout"] <- base::list(NULL)
[16:20:50.168]         }
[16:20:50.168]         base::close(...future.stdout)
[16:20:50.168]         ...future.stdout <- NULL
[16:20:50.168]     }
[16:20:50.168]     ...future.result$conditions <- ...future.conditions
[16:20:50.168]     ...future.result$finished <- base::Sys.time()
[16:20:50.168]     ...future.result
[16:20:50.168] }
[16:20:50.171] MultisessionFuture started
[16:20:50.172] - Launch lazy future ... done
[16:20:50.172] run() for ‘MultisessionFuture’ ... done
[16:20:50.172] result() for ClusterFuture ...
[16:20:50.172] receiveMessageFromWorker() for ClusterFuture ...
[16:20:50.172] - Validating connection of MultisessionFuture
[16:20:50.215] - received message: FutureResult
[16:20:50.215] - Received FutureResult
[16:20:50.215] - Erased future from FutureRegistry
[16:20:50.215] result() for ClusterFuture ...
[16:20:50.215] - result already collected: FutureResult
[16:20:50.215] result() for ClusterFuture ... done
[16:20:50.215] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:50.216] result() for ClusterFuture ... done
[16:20:50.216] result() for ClusterFuture ...
[16:20:50.216] - result already collected: FutureResult
[16:20:50.216] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[16:20:50.218] getGlobalsAndPackages() ...
[16:20:50.218] Searching for globals...
[16:20:50.220] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[16:20:50.220] Searching for globals ... DONE
[16:20:50.220] Resolving globals: FALSE
[16:20:50.221] 
[16:20:50.221] - packages: [2] ‘stats’, ‘datasets’
[16:20:50.221] getGlobalsAndPackages() ... DONE
[16:20:50.221] run() for ‘Future’ ...
[16:20:50.221] - state: ‘created’
[16:20:50.222] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:50.236] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:50.236] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:50.236]   - Field: ‘node’
[16:20:50.237]   - Field: ‘label’
[16:20:50.237]   - Field: ‘local’
[16:20:50.237]   - Field: ‘owner’
[16:20:50.237]   - Field: ‘envir’
[16:20:50.237]   - Field: ‘workers’
[16:20:50.237]   - Field: ‘packages’
[16:20:50.237]   - Field: ‘gc’
[16:20:50.237]   - Field: ‘conditions’
[16:20:50.237]   - Field: ‘persistent’
[16:20:50.237]   - Field: ‘expr’
[16:20:50.237]   - Field: ‘uuid’
[16:20:50.238]   - Field: ‘seed’
[16:20:50.238]   - Field: ‘version’
[16:20:50.238]   - Field: ‘result’
[16:20:50.238]   - Field: ‘asynchronous’
[16:20:50.238]   - Field: ‘calls’
[16:20:50.238]   - Field: ‘globals’
[16:20:50.238]   - Field: ‘stdout’
[16:20:50.238]   - Field: ‘earlySignal’
[16:20:50.238]   - Field: ‘lazy’
[16:20:50.238]   - Field: ‘state’
[16:20:50.239] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:50.239] - Launch lazy future ...
[16:20:50.239] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:20:50.239] Packages needed by future strategies (n = 0): <none>
[16:20:50.240] {
[16:20:50.240]     {
[16:20:50.240]         {
[16:20:50.240]             ...future.startTime <- base::Sys.time()
[16:20:50.240]             {
[16:20:50.240]                 {
[16:20:50.240]                   {
[16:20:50.240]                     {
[16:20:50.240]                       {
[16:20:50.240]                         base::local({
[16:20:50.240]                           has_future <- base::requireNamespace("future", 
[16:20:50.240]                             quietly = TRUE)
[16:20:50.240]                           if (has_future) {
[16:20:50.240]                             ns <- base::getNamespace("future")
[16:20:50.240]                             version <- ns[[".package"]][["version"]]
[16:20:50.240]                             if (is.null(version)) 
[16:20:50.240]                               version <- utils::packageVersion("future")
[16:20:50.240]                           }
[16:20:50.240]                           else {
[16:20:50.240]                             version <- NULL
[16:20:50.240]                           }
[16:20:50.240]                           if (!has_future || version < "1.8.0") {
[16:20:50.240]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:50.240]                               "", base::R.version$version.string), 
[16:20:50.240]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:50.240]                                 base::R.version$platform, 8 * 
[16:20:50.240]                                   base::.Machine$sizeof.pointer), 
[16:20:50.240]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:50.240]                                 "release", "version")], collapse = " "), 
[16:20:50.240]                               hostname = base::Sys.info()[["nodename"]])
[16:20:50.240]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:50.240]                               info)
[16:20:50.240]                             info <- base::paste(info, collapse = "; ")
[16:20:50.240]                             if (!has_future) {
[16:20:50.240]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:50.240]                                 info)
[16:20:50.240]                             }
[16:20:50.240]                             else {
[16:20:50.240]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:50.240]                                 info, version)
[16:20:50.240]                             }
[16:20:50.240]                             base::stop(msg)
[16:20:50.240]                           }
[16:20:50.240]                         })
[16:20:50.240]                       }
[16:20:50.240]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:50.240]                       base::options(mc.cores = 1L)
[16:20:50.240]                     }
[16:20:50.240]                     base::local({
[16:20:50.240]                       for (pkg in c("stats", "datasets")) {
[16:20:50.240]                         base::loadNamespace(pkg)
[16:20:50.240]                         base::library(pkg, character.only = TRUE)
[16:20:50.240]                       }
[16:20:50.240]                     })
[16:20:50.240]                   }
[16:20:50.240]                   ...future.strategy.old <- future::plan("list")
[16:20:50.240]                   options(future.plan = NULL)
[16:20:50.240]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:50.240]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:50.240]                 }
[16:20:50.240]                 ...future.workdir <- getwd()
[16:20:50.240]             }
[16:20:50.240]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:50.240]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:50.240]         }
[16:20:50.240]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:50.240]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:50.240]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:50.240]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:50.240]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:50.240]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:50.240]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:50.240]             base::names(...future.oldOptions))
[16:20:50.240]     }
[16:20:50.240]     if (FALSE) {
[16:20:50.240]     }
[16:20:50.240]     else {
[16:20:50.240]         if (TRUE) {
[16:20:50.240]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:50.240]                 open = "w")
[16:20:50.240]         }
[16:20:50.240]         else {
[16:20:50.240]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:50.240]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:50.240]         }
[16:20:50.240]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:50.240]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:50.240]             base::sink(type = "output", split = FALSE)
[16:20:50.240]             base::close(...future.stdout)
[16:20:50.240]         }, add = TRUE)
[16:20:50.240]     }
[16:20:50.240]     ...future.frame <- base::sys.nframe()
[16:20:50.240]     ...future.conditions <- base::list()
[16:20:50.240]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:50.240]     if (FALSE) {
[16:20:50.240]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:50.240]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:50.240]     }
[16:20:50.240]     ...future.result <- base::tryCatch({
[16:20:50.240]         base::withCallingHandlers({
[16:20:50.240]             ...future.value <- base::withVisible(base::local({
[16:20:50.240]                 ...future.makeSendCondition <- base::local({
[16:20:50.240]                   sendCondition <- NULL
[16:20:50.240]                   function(frame = 1L) {
[16:20:50.240]                     if (is.function(sendCondition)) 
[16:20:50.240]                       return(sendCondition)
[16:20:50.240]                     ns <- getNamespace("parallel")
[16:20:50.240]                     if (exists("sendData", mode = "function", 
[16:20:50.240]                       envir = ns)) {
[16:20:50.240]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:50.240]                         envir = ns)
[16:20:50.240]                       envir <- sys.frame(frame)
[16:20:50.240]                       master <- NULL
[16:20:50.240]                       while (!identical(envir, .GlobalEnv) && 
[16:20:50.240]                         !identical(envir, emptyenv())) {
[16:20:50.240]                         if (exists("master", mode = "list", envir = envir, 
[16:20:50.240]                           inherits = FALSE)) {
[16:20:50.240]                           master <- get("master", mode = "list", 
[16:20:50.240]                             envir = envir, inherits = FALSE)
[16:20:50.240]                           if (inherits(master, c("SOCKnode", 
[16:20:50.240]                             "SOCK0node"))) {
[16:20:50.240]                             sendCondition <<- function(cond) {
[16:20:50.240]                               data <- list(type = "VALUE", value = cond, 
[16:20:50.240]                                 success = TRUE)
[16:20:50.240]                               parallel_sendData(master, data)
[16:20:50.240]                             }
[16:20:50.240]                             return(sendCondition)
[16:20:50.240]                           }
[16:20:50.240]                         }
[16:20:50.240]                         frame <- frame + 1L
[16:20:50.240]                         envir <- sys.frame(frame)
[16:20:50.240]                       }
[16:20:50.240]                     }
[16:20:50.240]                     sendCondition <<- function(cond) NULL
[16:20:50.240]                   }
[16:20:50.240]                 })
[16:20:50.240]                 withCallingHandlers({
[16:20:50.240]                   {
[16:20:50.240]                     lm(dist ~ speed + speed^2, data = cars)
[16:20:50.240]                   }
[16:20:50.240]                 }, immediateCondition = function(cond) {
[16:20:50.240]                   sendCondition <- ...future.makeSendCondition()
[16:20:50.240]                   sendCondition(cond)
[16:20:50.240]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.240]                   {
[16:20:50.240]                     inherits <- base::inherits
[16:20:50.240]                     invokeRestart <- base::invokeRestart
[16:20:50.240]                     is.null <- base::is.null
[16:20:50.240]                     muffled <- FALSE
[16:20:50.240]                     if (inherits(cond, "message")) {
[16:20:50.240]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:50.240]                       if (muffled) 
[16:20:50.240]                         invokeRestart("muffleMessage")
[16:20:50.240]                     }
[16:20:50.240]                     else if (inherits(cond, "warning")) {
[16:20:50.240]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:50.240]                       if (muffled) 
[16:20:50.240]                         invokeRestart("muffleWarning")
[16:20:50.240]                     }
[16:20:50.240]                     else if (inherits(cond, "condition")) {
[16:20:50.240]                       if (!is.null(pattern)) {
[16:20:50.240]                         computeRestarts <- base::computeRestarts
[16:20:50.240]                         grepl <- base::grepl
[16:20:50.240]                         restarts <- computeRestarts(cond)
[16:20:50.240]                         for (restart in restarts) {
[16:20:50.240]                           name <- restart$name
[16:20:50.240]                           if (is.null(name)) 
[16:20:50.240]                             next
[16:20:50.240]                           if (!grepl(pattern, name)) 
[16:20:50.240]                             next
[16:20:50.240]                           invokeRestart(restart)
[16:20:50.240]                           muffled <- TRUE
[16:20:50.240]                           break
[16:20:50.240]                         }
[16:20:50.240]                       }
[16:20:50.240]                     }
[16:20:50.240]                     invisible(muffled)
[16:20:50.240]                   }
[16:20:50.240]                   muffleCondition(cond)
[16:20:50.240]                 })
[16:20:50.240]             }))
[16:20:50.240]             future::FutureResult(value = ...future.value$value, 
[16:20:50.240]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:50.240]                   ...future.rng), globalenv = if (FALSE) 
[16:20:50.240]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:50.240]                     ...future.globalenv.names))
[16:20:50.240]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:50.240]         }, condition = base::local({
[16:20:50.240]             c <- base::c
[16:20:50.240]             inherits <- base::inherits
[16:20:50.240]             invokeRestart <- base::invokeRestart
[16:20:50.240]             length <- base::length
[16:20:50.240]             list <- base::list
[16:20:50.240]             seq.int <- base::seq.int
[16:20:50.240]             signalCondition <- base::signalCondition
[16:20:50.240]             sys.calls <- base::sys.calls
[16:20:50.240]             `[[` <- base::`[[`
[16:20:50.240]             `+` <- base::`+`
[16:20:50.240]             `<<-` <- base::`<<-`
[16:20:50.240]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:50.240]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:50.240]                   3L)]
[16:20:50.240]             }
[16:20:50.240]             function(cond) {
[16:20:50.240]                 is_error <- inherits(cond, "error")
[16:20:50.240]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:50.240]                   NULL)
[16:20:50.240]                 if (is_error) {
[16:20:50.240]                   sessionInformation <- function() {
[16:20:50.240]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:50.240]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:50.240]                       search = base::search(), system = base::Sys.info())
[16:20:50.240]                   }
[16:20:50.240]                   ...future.conditions[[length(...future.conditions) + 
[16:20:50.240]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:50.240]                     cond$call), session = sessionInformation(), 
[16:20:50.240]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:50.240]                   signalCondition(cond)
[16:20:50.240]                 }
[16:20:50.240]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:50.240]                 "immediateCondition"))) {
[16:20:50.240]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:50.240]                   ...future.conditions[[length(...future.conditions) + 
[16:20:50.240]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:50.240]                   if (TRUE && !signal) {
[16:20:50.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.240]                     {
[16:20:50.240]                       inherits <- base::inherits
[16:20:50.240]                       invokeRestart <- base::invokeRestart
[16:20:50.240]                       is.null <- base::is.null
[16:20:50.240]                       muffled <- FALSE
[16:20:50.240]                       if (inherits(cond, "message")) {
[16:20:50.240]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:50.240]                         if (muffled) 
[16:20:50.240]                           invokeRestart("muffleMessage")
[16:20:50.240]                       }
[16:20:50.240]                       else if (inherits(cond, "warning")) {
[16:20:50.240]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:50.240]                         if (muffled) 
[16:20:50.240]                           invokeRestart("muffleWarning")
[16:20:50.240]                       }
[16:20:50.240]                       else if (inherits(cond, "condition")) {
[16:20:50.240]                         if (!is.null(pattern)) {
[16:20:50.240]                           computeRestarts <- base::computeRestarts
[16:20:50.240]                           grepl <- base::grepl
[16:20:50.240]                           restarts <- computeRestarts(cond)
[16:20:50.240]                           for (restart in restarts) {
[16:20:50.240]                             name <- restart$name
[16:20:50.240]                             if (is.null(name)) 
[16:20:50.240]                               next
[16:20:50.240]                             if (!grepl(pattern, name)) 
[16:20:50.240]                               next
[16:20:50.240]                             invokeRestart(restart)
[16:20:50.240]                             muffled <- TRUE
[16:20:50.240]                             break
[16:20:50.240]                           }
[16:20:50.240]                         }
[16:20:50.240]                       }
[16:20:50.240]                       invisible(muffled)
[16:20:50.240]                     }
[16:20:50.240]                     muffleCondition(cond, pattern = "^muffle")
[16:20:50.240]                   }
[16:20:50.240]                 }
[16:20:50.240]                 else {
[16:20:50.240]                   if (TRUE) {
[16:20:50.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.240]                     {
[16:20:50.240]                       inherits <- base::inherits
[16:20:50.240]                       invokeRestart <- base::invokeRestart
[16:20:50.240]                       is.null <- base::is.null
[16:20:50.240]                       muffled <- FALSE
[16:20:50.240]                       if (inherits(cond, "message")) {
[16:20:50.240]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:50.240]                         if (muffled) 
[16:20:50.240]                           invokeRestart("muffleMessage")
[16:20:50.240]                       }
[16:20:50.240]                       else if (inherits(cond, "warning")) {
[16:20:50.240]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:50.240]                         if (muffled) 
[16:20:50.240]                           invokeRestart("muffleWarning")
[16:20:50.240]                       }
[16:20:50.240]                       else if (inherits(cond, "condition")) {
[16:20:50.240]                         if (!is.null(pattern)) {
[16:20:50.240]                           computeRestarts <- base::computeRestarts
[16:20:50.240]                           grepl <- base::grepl
[16:20:50.240]                           restarts <- computeRestarts(cond)
[16:20:50.240]                           for (restart in restarts) {
[16:20:50.240]                             name <- restart$name
[16:20:50.240]                             if (is.null(name)) 
[16:20:50.240]                               next
[16:20:50.240]                             if (!grepl(pattern, name)) 
[16:20:50.240]                               next
[16:20:50.240]                             invokeRestart(restart)
[16:20:50.240]                             muffled <- TRUE
[16:20:50.240]                             break
[16:20:50.240]                           }
[16:20:50.240]                         }
[16:20:50.240]                       }
[16:20:50.240]                       invisible(muffled)
[16:20:50.240]                     }
[16:20:50.240]                     muffleCondition(cond, pattern = "^muffle")
[16:20:50.240]                   }
[16:20:50.240]                 }
[16:20:50.240]             }
[16:20:50.240]         }))
[16:20:50.240]     }, error = function(ex) {
[16:20:50.240]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:50.240]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:50.240]                 ...future.rng), started = ...future.startTime, 
[16:20:50.240]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:50.240]             version = "1.8"), class = "FutureResult")
[16:20:50.240]     }, finally = {
[16:20:50.240]         if (!identical(...future.workdir, getwd())) 
[16:20:50.240]             setwd(...future.workdir)
[16:20:50.240]         {
[16:20:50.240]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:50.240]                 ...future.oldOptions$nwarnings <- NULL
[16:20:50.240]             }
[16:20:50.240]             base::options(...future.oldOptions)
[16:20:50.240]             if (.Platform$OS.type == "windows") {
[16:20:50.240]                 old_names <- names(...future.oldEnvVars)
[16:20:50.240]                 envs <- base::Sys.getenv()
[16:20:50.240]                 names <- names(envs)
[16:20:50.240]                 common <- intersect(names, old_names)
[16:20:50.240]                 added <- setdiff(names, old_names)
[16:20:50.240]                 removed <- setdiff(old_names, names)
[16:20:50.240]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:50.240]                   envs[common]]
[16:20:50.240]                 NAMES <- toupper(changed)
[16:20:50.240]                 args <- list()
[16:20:50.240]                 for (kk in seq_along(NAMES)) {
[16:20:50.240]                   name <- changed[[kk]]
[16:20:50.240]                   NAME <- NAMES[[kk]]
[16:20:50.240]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.240]                     next
[16:20:50.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:50.240]                 }
[16:20:50.240]                 NAMES <- toupper(added)
[16:20:50.240]                 for (kk in seq_along(NAMES)) {
[16:20:50.240]                   name <- added[[kk]]
[16:20:50.240]                   NAME <- NAMES[[kk]]
[16:20:50.240]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.240]                     next
[16:20:50.240]                   args[[name]] <- ""
[16:20:50.240]                 }
[16:20:50.240]                 NAMES <- toupper(removed)
[16:20:50.240]                 for (kk in seq_along(NAMES)) {
[16:20:50.240]                   name <- removed[[kk]]
[16:20:50.240]                   NAME <- NAMES[[kk]]
[16:20:50.240]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.240]                     next
[16:20:50.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:50.240]                 }
[16:20:50.240]                 if (length(args) > 0) 
[16:20:50.240]                   base::do.call(base::Sys.setenv, args = args)
[16:20:50.240]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:50.240]             }
[16:20:50.240]             else {
[16:20:50.240]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:50.240]             }
[16:20:50.240]             {
[16:20:50.240]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:50.240]                   0L) {
[16:20:50.240]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:50.240]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:50.240]                   base::options(opts)
[16:20:50.240]                 }
[16:20:50.240]                 {
[16:20:50.240]                   {
[16:20:50.240]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:50.240]                     NULL
[16:20:50.240]                   }
[16:20:50.240]                   options(future.plan = NULL)
[16:20:50.240]                   if (is.na(NA_character_)) 
[16:20:50.240]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:50.240]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:50.240]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:50.240]                     .init = FALSE)
[16:20:50.240]                 }
[16:20:50.240]             }
[16:20:50.240]         }
[16:20:50.240]     })
[16:20:50.240]     if (TRUE) {
[16:20:50.240]         base::sink(type = "output", split = FALSE)
[16:20:50.240]         if (TRUE) {
[16:20:50.240]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:50.240]         }
[16:20:50.240]         else {
[16:20:50.240]             ...future.result["stdout"] <- base::list(NULL)
[16:20:50.240]         }
[16:20:50.240]         base::close(...future.stdout)
[16:20:50.240]         ...future.stdout <- NULL
[16:20:50.240]     }
[16:20:50.240]     ...future.result$conditions <- ...future.conditions
[16:20:50.240]     ...future.result$finished <- base::Sys.time()
[16:20:50.240]     ...future.result
[16:20:50.240] }
[16:20:50.243] MultisessionFuture started
[16:20:50.243] - Launch lazy future ... done
[16:20:50.243] run() for ‘MultisessionFuture’ ... done
[16:20:50.243] result() for ClusterFuture ...
[16:20:50.243] receiveMessageFromWorker() for ClusterFuture ...
[16:20:50.243] - Validating connection of MultisessionFuture
[16:20:50.287] - received message: FutureResult
[16:20:50.287] - Received FutureResult
[16:20:50.287] - Erased future from FutureRegistry
[16:20:50.287] result() for ClusterFuture ...
[16:20:50.287] - result already collected: FutureResult
[16:20:50.287] result() for ClusterFuture ... done
[16:20:50.287] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:50.287] result() for ClusterFuture ... done
[16:20:50.287] result() for ClusterFuture ...
[16:20:50.288] - result already collected: FutureResult
[16:20:50.288] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[16:20:50.290] getGlobalsAndPackages() ...
[16:20:50.290] Searching for globals...
[16:20:50.292] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[16:20:50.292] Searching for globals ... DONE
[16:20:50.292] Resolving globals: FALSE
[16:20:50.293] 
[16:20:50.293] - packages: [2] ‘stats’, ‘datasets’
[16:20:50.293] getGlobalsAndPackages() ... DONE
[16:20:50.293] run() for ‘Future’ ...
[16:20:50.293] - state: ‘created’
[16:20:50.293] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:50.307] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:50.307] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:50.307]   - Field: ‘node’
[16:20:50.308]   - Field: ‘label’
[16:20:50.308]   - Field: ‘local’
[16:20:50.308]   - Field: ‘owner’
[16:20:50.308]   - Field: ‘envir’
[16:20:50.308]   - Field: ‘workers’
[16:20:50.308]   - Field: ‘packages’
[16:20:50.308]   - Field: ‘gc’
[16:20:50.308]   - Field: ‘conditions’
[16:20:50.308]   - Field: ‘persistent’
[16:20:50.308]   - Field: ‘expr’
[16:20:50.309]   - Field: ‘uuid’
[16:20:50.309]   - Field: ‘seed’
[16:20:50.309]   - Field: ‘version’
[16:20:50.309]   - Field: ‘result’
[16:20:50.309]   - Field: ‘asynchronous’
[16:20:50.309]   - Field: ‘calls’
[16:20:50.309]   - Field: ‘globals’
[16:20:50.309]   - Field: ‘stdout’
[16:20:50.309]   - Field: ‘earlySignal’
[16:20:50.309]   - Field: ‘lazy’
[16:20:50.309]   - Field: ‘state’
[16:20:50.310] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:50.310] - Launch lazy future ...
[16:20:50.310] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:20:50.310] Packages needed by future strategies (n = 0): <none>
[16:20:50.311] {
[16:20:50.311]     {
[16:20:50.311]         {
[16:20:50.311]             ...future.startTime <- base::Sys.time()
[16:20:50.311]             {
[16:20:50.311]                 {
[16:20:50.311]                   {
[16:20:50.311]                     {
[16:20:50.311]                       {
[16:20:50.311]                         base::local({
[16:20:50.311]                           has_future <- base::requireNamespace("future", 
[16:20:50.311]                             quietly = TRUE)
[16:20:50.311]                           if (has_future) {
[16:20:50.311]                             ns <- base::getNamespace("future")
[16:20:50.311]                             version <- ns[[".package"]][["version"]]
[16:20:50.311]                             if (is.null(version)) 
[16:20:50.311]                               version <- utils::packageVersion("future")
[16:20:50.311]                           }
[16:20:50.311]                           else {
[16:20:50.311]                             version <- NULL
[16:20:50.311]                           }
[16:20:50.311]                           if (!has_future || version < "1.8.0") {
[16:20:50.311]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:50.311]                               "", base::R.version$version.string), 
[16:20:50.311]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:50.311]                                 base::R.version$platform, 8 * 
[16:20:50.311]                                   base::.Machine$sizeof.pointer), 
[16:20:50.311]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:50.311]                                 "release", "version")], collapse = " "), 
[16:20:50.311]                               hostname = base::Sys.info()[["nodename"]])
[16:20:50.311]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:50.311]                               info)
[16:20:50.311]                             info <- base::paste(info, collapse = "; ")
[16:20:50.311]                             if (!has_future) {
[16:20:50.311]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:50.311]                                 info)
[16:20:50.311]                             }
[16:20:50.311]                             else {
[16:20:50.311]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:50.311]                                 info, version)
[16:20:50.311]                             }
[16:20:50.311]                             base::stop(msg)
[16:20:50.311]                           }
[16:20:50.311]                         })
[16:20:50.311]                       }
[16:20:50.311]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:50.311]                       base::options(mc.cores = 1L)
[16:20:50.311]                     }
[16:20:50.311]                     base::local({
[16:20:50.311]                       for (pkg in c("stats", "datasets")) {
[16:20:50.311]                         base::loadNamespace(pkg)
[16:20:50.311]                         base::library(pkg, character.only = TRUE)
[16:20:50.311]                       }
[16:20:50.311]                     })
[16:20:50.311]                   }
[16:20:50.311]                   ...future.strategy.old <- future::plan("list")
[16:20:50.311]                   options(future.plan = NULL)
[16:20:50.311]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:50.311]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:50.311]                 }
[16:20:50.311]                 ...future.workdir <- getwd()
[16:20:50.311]             }
[16:20:50.311]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:50.311]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:50.311]         }
[16:20:50.311]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:50.311]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:50.311]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:50.311]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:50.311]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:50.311]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:50.311]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:50.311]             base::names(...future.oldOptions))
[16:20:50.311]     }
[16:20:50.311]     if (FALSE) {
[16:20:50.311]     }
[16:20:50.311]     else {
[16:20:50.311]         if (TRUE) {
[16:20:50.311]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:50.311]                 open = "w")
[16:20:50.311]         }
[16:20:50.311]         else {
[16:20:50.311]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:50.311]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:50.311]         }
[16:20:50.311]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:50.311]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:50.311]             base::sink(type = "output", split = FALSE)
[16:20:50.311]             base::close(...future.stdout)
[16:20:50.311]         }, add = TRUE)
[16:20:50.311]     }
[16:20:50.311]     ...future.frame <- base::sys.nframe()
[16:20:50.311]     ...future.conditions <- base::list()
[16:20:50.311]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:50.311]     if (FALSE) {
[16:20:50.311]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:50.311]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:50.311]     }
[16:20:50.311]     ...future.result <- base::tryCatch({
[16:20:50.311]         base::withCallingHandlers({
[16:20:50.311]             ...future.value <- base::withVisible(base::local({
[16:20:50.311]                 ...future.makeSendCondition <- base::local({
[16:20:50.311]                   sendCondition <- NULL
[16:20:50.311]                   function(frame = 1L) {
[16:20:50.311]                     if (is.function(sendCondition)) 
[16:20:50.311]                       return(sendCondition)
[16:20:50.311]                     ns <- getNamespace("parallel")
[16:20:50.311]                     if (exists("sendData", mode = "function", 
[16:20:50.311]                       envir = ns)) {
[16:20:50.311]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:50.311]                         envir = ns)
[16:20:50.311]                       envir <- sys.frame(frame)
[16:20:50.311]                       master <- NULL
[16:20:50.311]                       while (!identical(envir, .GlobalEnv) && 
[16:20:50.311]                         !identical(envir, emptyenv())) {
[16:20:50.311]                         if (exists("master", mode = "list", envir = envir, 
[16:20:50.311]                           inherits = FALSE)) {
[16:20:50.311]                           master <- get("master", mode = "list", 
[16:20:50.311]                             envir = envir, inherits = FALSE)
[16:20:50.311]                           if (inherits(master, c("SOCKnode", 
[16:20:50.311]                             "SOCK0node"))) {
[16:20:50.311]                             sendCondition <<- function(cond) {
[16:20:50.311]                               data <- list(type = "VALUE", value = cond, 
[16:20:50.311]                                 success = TRUE)
[16:20:50.311]                               parallel_sendData(master, data)
[16:20:50.311]                             }
[16:20:50.311]                             return(sendCondition)
[16:20:50.311]                           }
[16:20:50.311]                         }
[16:20:50.311]                         frame <- frame + 1L
[16:20:50.311]                         envir <- sys.frame(frame)
[16:20:50.311]                       }
[16:20:50.311]                     }
[16:20:50.311]                     sendCondition <<- function(cond) NULL
[16:20:50.311]                   }
[16:20:50.311]                 })
[16:20:50.311]                 withCallingHandlers({
[16:20:50.311]                   {
[16:20:50.311]                     lm(dist ~ speed + I(speed^2), data = cars)
[16:20:50.311]                   }
[16:20:50.311]                 }, immediateCondition = function(cond) {
[16:20:50.311]                   sendCondition <- ...future.makeSendCondition()
[16:20:50.311]                   sendCondition(cond)
[16:20:50.311]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.311]                   {
[16:20:50.311]                     inherits <- base::inherits
[16:20:50.311]                     invokeRestart <- base::invokeRestart
[16:20:50.311]                     is.null <- base::is.null
[16:20:50.311]                     muffled <- FALSE
[16:20:50.311]                     if (inherits(cond, "message")) {
[16:20:50.311]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:50.311]                       if (muffled) 
[16:20:50.311]                         invokeRestart("muffleMessage")
[16:20:50.311]                     }
[16:20:50.311]                     else if (inherits(cond, "warning")) {
[16:20:50.311]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:50.311]                       if (muffled) 
[16:20:50.311]                         invokeRestart("muffleWarning")
[16:20:50.311]                     }
[16:20:50.311]                     else if (inherits(cond, "condition")) {
[16:20:50.311]                       if (!is.null(pattern)) {
[16:20:50.311]                         computeRestarts <- base::computeRestarts
[16:20:50.311]                         grepl <- base::grepl
[16:20:50.311]                         restarts <- computeRestarts(cond)
[16:20:50.311]                         for (restart in restarts) {
[16:20:50.311]                           name <- restart$name
[16:20:50.311]                           if (is.null(name)) 
[16:20:50.311]                             next
[16:20:50.311]                           if (!grepl(pattern, name)) 
[16:20:50.311]                             next
[16:20:50.311]                           invokeRestart(restart)
[16:20:50.311]                           muffled <- TRUE
[16:20:50.311]                           break
[16:20:50.311]                         }
[16:20:50.311]                       }
[16:20:50.311]                     }
[16:20:50.311]                     invisible(muffled)
[16:20:50.311]                   }
[16:20:50.311]                   muffleCondition(cond)
[16:20:50.311]                 })
[16:20:50.311]             }))
[16:20:50.311]             future::FutureResult(value = ...future.value$value, 
[16:20:50.311]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:50.311]                   ...future.rng), globalenv = if (FALSE) 
[16:20:50.311]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:50.311]                     ...future.globalenv.names))
[16:20:50.311]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:50.311]         }, condition = base::local({
[16:20:50.311]             c <- base::c
[16:20:50.311]             inherits <- base::inherits
[16:20:50.311]             invokeRestart <- base::invokeRestart
[16:20:50.311]             length <- base::length
[16:20:50.311]             list <- base::list
[16:20:50.311]             seq.int <- base::seq.int
[16:20:50.311]             signalCondition <- base::signalCondition
[16:20:50.311]             sys.calls <- base::sys.calls
[16:20:50.311]             `[[` <- base::`[[`
[16:20:50.311]             `+` <- base::`+`
[16:20:50.311]             `<<-` <- base::`<<-`
[16:20:50.311]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:50.311]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:50.311]                   3L)]
[16:20:50.311]             }
[16:20:50.311]             function(cond) {
[16:20:50.311]                 is_error <- inherits(cond, "error")
[16:20:50.311]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:50.311]                   NULL)
[16:20:50.311]                 if (is_error) {
[16:20:50.311]                   sessionInformation <- function() {
[16:20:50.311]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:50.311]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:50.311]                       search = base::search(), system = base::Sys.info())
[16:20:50.311]                   }
[16:20:50.311]                   ...future.conditions[[length(...future.conditions) + 
[16:20:50.311]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:50.311]                     cond$call), session = sessionInformation(), 
[16:20:50.311]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:50.311]                   signalCondition(cond)
[16:20:50.311]                 }
[16:20:50.311]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:50.311]                 "immediateCondition"))) {
[16:20:50.311]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:50.311]                   ...future.conditions[[length(...future.conditions) + 
[16:20:50.311]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:50.311]                   if (TRUE && !signal) {
[16:20:50.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.311]                     {
[16:20:50.311]                       inherits <- base::inherits
[16:20:50.311]                       invokeRestart <- base::invokeRestart
[16:20:50.311]                       is.null <- base::is.null
[16:20:50.311]                       muffled <- FALSE
[16:20:50.311]                       if (inherits(cond, "message")) {
[16:20:50.311]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:50.311]                         if (muffled) 
[16:20:50.311]                           invokeRestart("muffleMessage")
[16:20:50.311]                       }
[16:20:50.311]                       else if (inherits(cond, "warning")) {
[16:20:50.311]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:50.311]                         if (muffled) 
[16:20:50.311]                           invokeRestart("muffleWarning")
[16:20:50.311]                       }
[16:20:50.311]                       else if (inherits(cond, "condition")) {
[16:20:50.311]                         if (!is.null(pattern)) {
[16:20:50.311]                           computeRestarts <- base::computeRestarts
[16:20:50.311]                           grepl <- base::grepl
[16:20:50.311]                           restarts <- computeRestarts(cond)
[16:20:50.311]                           for (restart in restarts) {
[16:20:50.311]                             name <- restart$name
[16:20:50.311]                             if (is.null(name)) 
[16:20:50.311]                               next
[16:20:50.311]                             if (!grepl(pattern, name)) 
[16:20:50.311]                               next
[16:20:50.311]                             invokeRestart(restart)
[16:20:50.311]                             muffled <- TRUE
[16:20:50.311]                             break
[16:20:50.311]                           }
[16:20:50.311]                         }
[16:20:50.311]                       }
[16:20:50.311]                       invisible(muffled)
[16:20:50.311]                     }
[16:20:50.311]                     muffleCondition(cond, pattern = "^muffle")
[16:20:50.311]                   }
[16:20:50.311]                 }
[16:20:50.311]                 else {
[16:20:50.311]                   if (TRUE) {
[16:20:50.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.311]                     {
[16:20:50.311]                       inherits <- base::inherits
[16:20:50.311]                       invokeRestart <- base::invokeRestart
[16:20:50.311]                       is.null <- base::is.null
[16:20:50.311]                       muffled <- FALSE
[16:20:50.311]                       if (inherits(cond, "message")) {
[16:20:50.311]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:50.311]                         if (muffled) 
[16:20:50.311]                           invokeRestart("muffleMessage")
[16:20:50.311]                       }
[16:20:50.311]                       else if (inherits(cond, "warning")) {
[16:20:50.311]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:50.311]                         if (muffled) 
[16:20:50.311]                           invokeRestart("muffleWarning")
[16:20:50.311]                       }
[16:20:50.311]                       else if (inherits(cond, "condition")) {
[16:20:50.311]                         if (!is.null(pattern)) {
[16:20:50.311]                           computeRestarts <- base::computeRestarts
[16:20:50.311]                           grepl <- base::grepl
[16:20:50.311]                           restarts <- computeRestarts(cond)
[16:20:50.311]                           for (restart in restarts) {
[16:20:50.311]                             name <- restart$name
[16:20:50.311]                             if (is.null(name)) 
[16:20:50.311]                               next
[16:20:50.311]                             if (!grepl(pattern, name)) 
[16:20:50.311]                               next
[16:20:50.311]                             invokeRestart(restart)
[16:20:50.311]                             muffled <- TRUE
[16:20:50.311]                             break
[16:20:50.311]                           }
[16:20:50.311]                         }
[16:20:50.311]                       }
[16:20:50.311]                       invisible(muffled)
[16:20:50.311]                     }
[16:20:50.311]                     muffleCondition(cond, pattern = "^muffle")
[16:20:50.311]                   }
[16:20:50.311]                 }
[16:20:50.311]             }
[16:20:50.311]         }))
[16:20:50.311]     }, error = function(ex) {
[16:20:50.311]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:50.311]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:50.311]                 ...future.rng), started = ...future.startTime, 
[16:20:50.311]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:50.311]             version = "1.8"), class = "FutureResult")
[16:20:50.311]     }, finally = {
[16:20:50.311]         if (!identical(...future.workdir, getwd())) 
[16:20:50.311]             setwd(...future.workdir)
[16:20:50.311]         {
[16:20:50.311]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:50.311]                 ...future.oldOptions$nwarnings <- NULL
[16:20:50.311]             }
[16:20:50.311]             base::options(...future.oldOptions)
[16:20:50.311]             if (.Platform$OS.type == "windows") {
[16:20:50.311]                 old_names <- names(...future.oldEnvVars)
[16:20:50.311]                 envs <- base::Sys.getenv()
[16:20:50.311]                 names <- names(envs)
[16:20:50.311]                 common <- intersect(names, old_names)
[16:20:50.311]                 added <- setdiff(names, old_names)
[16:20:50.311]                 removed <- setdiff(old_names, names)
[16:20:50.311]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:50.311]                   envs[common]]
[16:20:50.311]                 NAMES <- toupper(changed)
[16:20:50.311]                 args <- list()
[16:20:50.311]                 for (kk in seq_along(NAMES)) {
[16:20:50.311]                   name <- changed[[kk]]
[16:20:50.311]                   NAME <- NAMES[[kk]]
[16:20:50.311]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.311]                     next
[16:20:50.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:50.311]                 }
[16:20:50.311]                 NAMES <- toupper(added)
[16:20:50.311]                 for (kk in seq_along(NAMES)) {
[16:20:50.311]                   name <- added[[kk]]
[16:20:50.311]                   NAME <- NAMES[[kk]]
[16:20:50.311]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.311]                     next
[16:20:50.311]                   args[[name]] <- ""
[16:20:50.311]                 }
[16:20:50.311]                 NAMES <- toupper(removed)
[16:20:50.311]                 for (kk in seq_along(NAMES)) {
[16:20:50.311]                   name <- removed[[kk]]
[16:20:50.311]                   NAME <- NAMES[[kk]]
[16:20:50.311]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.311]                     next
[16:20:50.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:50.311]                 }
[16:20:50.311]                 if (length(args) > 0) 
[16:20:50.311]                   base::do.call(base::Sys.setenv, args = args)
[16:20:50.311]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:50.311]             }
[16:20:50.311]             else {
[16:20:50.311]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:50.311]             }
[16:20:50.311]             {
[16:20:50.311]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:50.311]                   0L) {
[16:20:50.311]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:50.311]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:50.311]                   base::options(opts)
[16:20:50.311]                 }
[16:20:50.311]                 {
[16:20:50.311]                   {
[16:20:50.311]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:50.311]                     NULL
[16:20:50.311]                   }
[16:20:50.311]                   options(future.plan = NULL)
[16:20:50.311]                   if (is.na(NA_character_)) 
[16:20:50.311]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:50.311]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:50.311]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:50.311]                     .init = FALSE)
[16:20:50.311]                 }
[16:20:50.311]             }
[16:20:50.311]         }
[16:20:50.311]     })
[16:20:50.311]     if (TRUE) {
[16:20:50.311]         base::sink(type = "output", split = FALSE)
[16:20:50.311]         if (TRUE) {
[16:20:50.311]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:50.311]         }
[16:20:50.311]         else {
[16:20:50.311]             ...future.result["stdout"] <- base::list(NULL)
[16:20:50.311]         }
[16:20:50.311]         base::close(...future.stdout)
[16:20:50.311]         ...future.stdout <- NULL
[16:20:50.311]     }
[16:20:50.311]     ...future.result$conditions <- ...future.conditions
[16:20:50.311]     ...future.result$finished <- base::Sys.time()
[16:20:50.311]     ...future.result
[16:20:50.311] }
[16:20:50.313] MultisessionFuture started
[16:20:50.314] - Launch lazy future ... done
[16:20:50.314] run() for ‘MultisessionFuture’ ... done
[16:20:50.314] result() for ClusterFuture ...
[16:20:50.314] receiveMessageFromWorker() for ClusterFuture ...
[16:20:50.314] - Validating connection of MultisessionFuture
[16:20:50.359] - received message: FutureResult
[16:20:50.359] - Received FutureResult
[16:20:50.359] - Erased future from FutureRegistry
[16:20:50.359] result() for ClusterFuture ...
[16:20:50.359] - result already collected: FutureResult
[16:20:50.359] result() for ClusterFuture ... done
[16:20:50.359] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:50.360] result() for ClusterFuture ... done
[16:20:50.360] result() for ClusterFuture ...
[16:20:50.360] - result already collected: FutureResult
[16:20:50.360] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[16:20:50.362] getGlobalsAndPackages() ...
[16:20:50.363] Searching for globals...
[16:20:50.364] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[16:20:50.364] Searching for globals ... DONE
[16:20:50.364] Resolving globals: FALSE
[16:20:50.365] 
[16:20:50.365] - packages: [2] ‘stats’, ‘datasets’
[16:20:50.365] getGlobalsAndPackages() ... DONE
[16:20:50.365] run() for ‘Future’ ...
[16:20:50.365] - state: ‘created’
[16:20:50.365] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:50.379] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:50.379] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:50.379]   - Field: ‘node’
[16:20:50.380]   - Field: ‘label’
[16:20:50.380]   - Field: ‘local’
[16:20:50.380]   - Field: ‘owner’
[16:20:50.380]   - Field: ‘envir’
[16:20:50.380]   - Field: ‘workers’
[16:20:50.380]   - Field: ‘packages’
[16:20:50.380]   - Field: ‘gc’
[16:20:50.380]   - Field: ‘conditions’
[16:20:50.380]   - Field: ‘persistent’
[16:20:50.380]   - Field: ‘expr’
[16:20:50.381]   - Field: ‘uuid’
[16:20:50.381]   - Field: ‘seed’
[16:20:50.381]   - Field: ‘version’
[16:20:50.381]   - Field: ‘result’
[16:20:50.381]   - Field: ‘asynchronous’
[16:20:50.381]   - Field: ‘calls’
[16:20:50.381]   - Field: ‘globals’
[16:20:50.381]   - Field: ‘stdout’
[16:20:50.381]   - Field: ‘earlySignal’
[16:20:50.381]   - Field: ‘lazy’
[16:20:50.381]   - Field: ‘state’
[16:20:50.382] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:50.382] - Launch lazy future ...
[16:20:50.382] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:20:50.382] Packages needed by future strategies (n = 0): <none>
[16:20:50.383] {
[16:20:50.383]     {
[16:20:50.383]         {
[16:20:50.383]             ...future.startTime <- base::Sys.time()
[16:20:50.383]             {
[16:20:50.383]                 {
[16:20:50.383]                   {
[16:20:50.383]                     {
[16:20:50.383]                       {
[16:20:50.383]                         base::local({
[16:20:50.383]                           has_future <- base::requireNamespace("future", 
[16:20:50.383]                             quietly = TRUE)
[16:20:50.383]                           if (has_future) {
[16:20:50.383]                             ns <- base::getNamespace("future")
[16:20:50.383]                             version <- ns[[".package"]][["version"]]
[16:20:50.383]                             if (is.null(version)) 
[16:20:50.383]                               version <- utils::packageVersion("future")
[16:20:50.383]                           }
[16:20:50.383]                           else {
[16:20:50.383]                             version <- NULL
[16:20:50.383]                           }
[16:20:50.383]                           if (!has_future || version < "1.8.0") {
[16:20:50.383]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:50.383]                               "", base::R.version$version.string), 
[16:20:50.383]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:50.383]                                 base::R.version$platform, 8 * 
[16:20:50.383]                                   base::.Machine$sizeof.pointer), 
[16:20:50.383]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:50.383]                                 "release", "version")], collapse = " "), 
[16:20:50.383]                               hostname = base::Sys.info()[["nodename"]])
[16:20:50.383]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:50.383]                               info)
[16:20:50.383]                             info <- base::paste(info, collapse = "; ")
[16:20:50.383]                             if (!has_future) {
[16:20:50.383]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:50.383]                                 info)
[16:20:50.383]                             }
[16:20:50.383]                             else {
[16:20:50.383]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:50.383]                                 info, version)
[16:20:50.383]                             }
[16:20:50.383]                             base::stop(msg)
[16:20:50.383]                           }
[16:20:50.383]                         })
[16:20:50.383]                       }
[16:20:50.383]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:50.383]                       base::options(mc.cores = 1L)
[16:20:50.383]                     }
[16:20:50.383]                     base::local({
[16:20:50.383]                       for (pkg in c("stats", "datasets")) {
[16:20:50.383]                         base::loadNamespace(pkg)
[16:20:50.383]                         base::library(pkg, character.only = TRUE)
[16:20:50.383]                       }
[16:20:50.383]                     })
[16:20:50.383]                   }
[16:20:50.383]                   ...future.strategy.old <- future::plan("list")
[16:20:50.383]                   options(future.plan = NULL)
[16:20:50.383]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:50.383]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:50.383]                 }
[16:20:50.383]                 ...future.workdir <- getwd()
[16:20:50.383]             }
[16:20:50.383]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:50.383]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:50.383]         }
[16:20:50.383]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:50.383]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:50.383]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:50.383]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:50.383]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:50.383]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:50.383]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:50.383]             base::names(...future.oldOptions))
[16:20:50.383]     }
[16:20:50.383]     if (FALSE) {
[16:20:50.383]     }
[16:20:50.383]     else {
[16:20:50.383]         if (TRUE) {
[16:20:50.383]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:50.383]                 open = "w")
[16:20:50.383]         }
[16:20:50.383]         else {
[16:20:50.383]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:50.383]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:50.383]         }
[16:20:50.383]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:50.383]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:50.383]             base::sink(type = "output", split = FALSE)
[16:20:50.383]             base::close(...future.stdout)
[16:20:50.383]         }, add = TRUE)
[16:20:50.383]     }
[16:20:50.383]     ...future.frame <- base::sys.nframe()
[16:20:50.383]     ...future.conditions <- base::list()
[16:20:50.383]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:50.383]     if (FALSE) {
[16:20:50.383]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:50.383]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:50.383]     }
[16:20:50.383]     ...future.result <- base::tryCatch({
[16:20:50.383]         base::withCallingHandlers({
[16:20:50.383]             ...future.value <- base::withVisible(base::local({
[16:20:50.383]                 ...future.makeSendCondition <- base::local({
[16:20:50.383]                   sendCondition <- NULL
[16:20:50.383]                   function(frame = 1L) {
[16:20:50.383]                     if (is.function(sendCondition)) 
[16:20:50.383]                       return(sendCondition)
[16:20:50.383]                     ns <- getNamespace("parallel")
[16:20:50.383]                     if (exists("sendData", mode = "function", 
[16:20:50.383]                       envir = ns)) {
[16:20:50.383]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:50.383]                         envir = ns)
[16:20:50.383]                       envir <- sys.frame(frame)
[16:20:50.383]                       master <- NULL
[16:20:50.383]                       while (!identical(envir, .GlobalEnv) && 
[16:20:50.383]                         !identical(envir, emptyenv())) {
[16:20:50.383]                         if (exists("master", mode = "list", envir = envir, 
[16:20:50.383]                           inherits = FALSE)) {
[16:20:50.383]                           master <- get("master", mode = "list", 
[16:20:50.383]                             envir = envir, inherits = FALSE)
[16:20:50.383]                           if (inherits(master, c("SOCKnode", 
[16:20:50.383]                             "SOCK0node"))) {
[16:20:50.383]                             sendCondition <<- function(cond) {
[16:20:50.383]                               data <- list(type = "VALUE", value = cond, 
[16:20:50.383]                                 success = TRUE)
[16:20:50.383]                               parallel_sendData(master, data)
[16:20:50.383]                             }
[16:20:50.383]                             return(sendCondition)
[16:20:50.383]                           }
[16:20:50.383]                         }
[16:20:50.383]                         frame <- frame + 1L
[16:20:50.383]                         envir <- sys.frame(frame)
[16:20:50.383]                       }
[16:20:50.383]                     }
[16:20:50.383]                     sendCondition <<- function(cond) NULL
[16:20:50.383]                   }
[16:20:50.383]                 })
[16:20:50.383]                 withCallingHandlers({
[16:20:50.383]                   {
[16:20:50.383]                     lm(dist ~ poly(speed, 2), data = cars)
[16:20:50.383]                   }
[16:20:50.383]                 }, immediateCondition = function(cond) {
[16:20:50.383]                   sendCondition <- ...future.makeSendCondition()
[16:20:50.383]                   sendCondition(cond)
[16:20:50.383]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.383]                   {
[16:20:50.383]                     inherits <- base::inherits
[16:20:50.383]                     invokeRestart <- base::invokeRestart
[16:20:50.383]                     is.null <- base::is.null
[16:20:50.383]                     muffled <- FALSE
[16:20:50.383]                     if (inherits(cond, "message")) {
[16:20:50.383]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:50.383]                       if (muffled) 
[16:20:50.383]                         invokeRestart("muffleMessage")
[16:20:50.383]                     }
[16:20:50.383]                     else if (inherits(cond, "warning")) {
[16:20:50.383]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:50.383]                       if (muffled) 
[16:20:50.383]                         invokeRestart("muffleWarning")
[16:20:50.383]                     }
[16:20:50.383]                     else if (inherits(cond, "condition")) {
[16:20:50.383]                       if (!is.null(pattern)) {
[16:20:50.383]                         computeRestarts <- base::computeRestarts
[16:20:50.383]                         grepl <- base::grepl
[16:20:50.383]                         restarts <- computeRestarts(cond)
[16:20:50.383]                         for (restart in restarts) {
[16:20:50.383]                           name <- restart$name
[16:20:50.383]                           if (is.null(name)) 
[16:20:50.383]                             next
[16:20:50.383]                           if (!grepl(pattern, name)) 
[16:20:50.383]                             next
[16:20:50.383]                           invokeRestart(restart)
[16:20:50.383]                           muffled <- TRUE
[16:20:50.383]                           break
[16:20:50.383]                         }
[16:20:50.383]                       }
[16:20:50.383]                     }
[16:20:50.383]                     invisible(muffled)
[16:20:50.383]                   }
[16:20:50.383]                   muffleCondition(cond)
[16:20:50.383]                 })
[16:20:50.383]             }))
[16:20:50.383]             future::FutureResult(value = ...future.value$value, 
[16:20:50.383]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:50.383]                   ...future.rng), globalenv = if (FALSE) 
[16:20:50.383]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:50.383]                     ...future.globalenv.names))
[16:20:50.383]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:50.383]         }, condition = base::local({
[16:20:50.383]             c <- base::c
[16:20:50.383]             inherits <- base::inherits
[16:20:50.383]             invokeRestart <- base::invokeRestart
[16:20:50.383]             length <- base::length
[16:20:50.383]             list <- base::list
[16:20:50.383]             seq.int <- base::seq.int
[16:20:50.383]             signalCondition <- base::signalCondition
[16:20:50.383]             sys.calls <- base::sys.calls
[16:20:50.383]             `[[` <- base::`[[`
[16:20:50.383]             `+` <- base::`+`
[16:20:50.383]             `<<-` <- base::`<<-`
[16:20:50.383]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:50.383]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:50.383]                   3L)]
[16:20:50.383]             }
[16:20:50.383]             function(cond) {
[16:20:50.383]                 is_error <- inherits(cond, "error")
[16:20:50.383]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:50.383]                   NULL)
[16:20:50.383]                 if (is_error) {
[16:20:50.383]                   sessionInformation <- function() {
[16:20:50.383]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:50.383]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:50.383]                       search = base::search(), system = base::Sys.info())
[16:20:50.383]                   }
[16:20:50.383]                   ...future.conditions[[length(...future.conditions) + 
[16:20:50.383]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:50.383]                     cond$call), session = sessionInformation(), 
[16:20:50.383]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:50.383]                   signalCondition(cond)
[16:20:50.383]                 }
[16:20:50.383]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:50.383]                 "immediateCondition"))) {
[16:20:50.383]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:50.383]                   ...future.conditions[[length(...future.conditions) + 
[16:20:50.383]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:50.383]                   if (TRUE && !signal) {
[16:20:50.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.383]                     {
[16:20:50.383]                       inherits <- base::inherits
[16:20:50.383]                       invokeRestart <- base::invokeRestart
[16:20:50.383]                       is.null <- base::is.null
[16:20:50.383]                       muffled <- FALSE
[16:20:50.383]                       if (inherits(cond, "message")) {
[16:20:50.383]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:50.383]                         if (muffled) 
[16:20:50.383]                           invokeRestart("muffleMessage")
[16:20:50.383]                       }
[16:20:50.383]                       else if (inherits(cond, "warning")) {
[16:20:50.383]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:50.383]                         if (muffled) 
[16:20:50.383]                           invokeRestart("muffleWarning")
[16:20:50.383]                       }
[16:20:50.383]                       else if (inherits(cond, "condition")) {
[16:20:50.383]                         if (!is.null(pattern)) {
[16:20:50.383]                           computeRestarts <- base::computeRestarts
[16:20:50.383]                           grepl <- base::grepl
[16:20:50.383]                           restarts <- computeRestarts(cond)
[16:20:50.383]                           for (restart in restarts) {
[16:20:50.383]                             name <- restart$name
[16:20:50.383]                             if (is.null(name)) 
[16:20:50.383]                               next
[16:20:50.383]                             if (!grepl(pattern, name)) 
[16:20:50.383]                               next
[16:20:50.383]                             invokeRestart(restart)
[16:20:50.383]                             muffled <- TRUE
[16:20:50.383]                             break
[16:20:50.383]                           }
[16:20:50.383]                         }
[16:20:50.383]                       }
[16:20:50.383]                       invisible(muffled)
[16:20:50.383]                     }
[16:20:50.383]                     muffleCondition(cond, pattern = "^muffle")
[16:20:50.383]                   }
[16:20:50.383]                 }
[16:20:50.383]                 else {
[16:20:50.383]                   if (TRUE) {
[16:20:50.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.383]                     {
[16:20:50.383]                       inherits <- base::inherits
[16:20:50.383]                       invokeRestart <- base::invokeRestart
[16:20:50.383]                       is.null <- base::is.null
[16:20:50.383]                       muffled <- FALSE
[16:20:50.383]                       if (inherits(cond, "message")) {
[16:20:50.383]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:50.383]                         if (muffled) 
[16:20:50.383]                           invokeRestart("muffleMessage")
[16:20:50.383]                       }
[16:20:50.383]                       else if (inherits(cond, "warning")) {
[16:20:50.383]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:50.383]                         if (muffled) 
[16:20:50.383]                           invokeRestart("muffleWarning")
[16:20:50.383]                       }
[16:20:50.383]                       else if (inherits(cond, "condition")) {
[16:20:50.383]                         if (!is.null(pattern)) {
[16:20:50.383]                           computeRestarts <- base::computeRestarts
[16:20:50.383]                           grepl <- base::grepl
[16:20:50.383]                           restarts <- computeRestarts(cond)
[16:20:50.383]                           for (restart in restarts) {
[16:20:50.383]                             name <- restart$name
[16:20:50.383]                             if (is.null(name)) 
[16:20:50.383]                               next
[16:20:50.383]                             if (!grepl(pattern, name)) 
[16:20:50.383]                               next
[16:20:50.383]                             invokeRestart(restart)
[16:20:50.383]                             muffled <- TRUE
[16:20:50.383]                             break
[16:20:50.383]                           }
[16:20:50.383]                         }
[16:20:50.383]                       }
[16:20:50.383]                       invisible(muffled)
[16:20:50.383]                     }
[16:20:50.383]                     muffleCondition(cond, pattern = "^muffle")
[16:20:50.383]                   }
[16:20:50.383]                 }
[16:20:50.383]             }
[16:20:50.383]         }))
[16:20:50.383]     }, error = function(ex) {
[16:20:50.383]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:50.383]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:50.383]                 ...future.rng), started = ...future.startTime, 
[16:20:50.383]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:50.383]             version = "1.8"), class = "FutureResult")
[16:20:50.383]     }, finally = {
[16:20:50.383]         if (!identical(...future.workdir, getwd())) 
[16:20:50.383]             setwd(...future.workdir)
[16:20:50.383]         {
[16:20:50.383]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:50.383]                 ...future.oldOptions$nwarnings <- NULL
[16:20:50.383]             }
[16:20:50.383]             base::options(...future.oldOptions)
[16:20:50.383]             if (.Platform$OS.type == "windows") {
[16:20:50.383]                 old_names <- names(...future.oldEnvVars)
[16:20:50.383]                 envs <- base::Sys.getenv()
[16:20:50.383]                 names <- names(envs)
[16:20:50.383]                 common <- intersect(names, old_names)
[16:20:50.383]                 added <- setdiff(names, old_names)
[16:20:50.383]                 removed <- setdiff(old_names, names)
[16:20:50.383]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:50.383]                   envs[common]]
[16:20:50.383]                 NAMES <- toupper(changed)
[16:20:50.383]                 args <- list()
[16:20:50.383]                 for (kk in seq_along(NAMES)) {
[16:20:50.383]                   name <- changed[[kk]]
[16:20:50.383]                   NAME <- NAMES[[kk]]
[16:20:50.383]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.383]                     next
[16:20:50.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:50.383]                 }
[16:20:50.383]                 NAMES <- toupper(added)
[16:20:50.383]                 for (kk in seq_along(NAMES)) {
[16:20:50.383]                   name <- added[[kk]]
[16:20:50.383]                   NAME <- NAMES[[kk]]
[16:20:50.383]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.383]                     next
[16:20:50.383]                   args[[name]] <- ""
[16:20:50.383]                 }
[16:20:50.383]                 NAMES <- toupper(removed)
[16:20:50.383]                 for (kk in seq_along(NAMES)) {
[16:20:50.383]                   name <- removed[[kk]]
[16:20:50.383]                   NAME <- NAMES[[kk]]
[16:20:50.383]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.383]                     next
[16:20:50.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:50.383]                 }
[16:20:50.383]                 if (length(args) > 0) 
[16:20:50.383]                   base::do.call(base::Sys.setenv, args = args)
[16:20:50.383]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:50.383]             }
[16:20:50.383]             else {
[16:20:50.383]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:50.383]             }
[16:20:50.383]             {
[16:20:50.383]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:50.383]                   0L) {
[16:20:50.383]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:50.383]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:50.383]                   base::options(opts)
[16:20:50.383]                 }
[16:20:50.383]                 {
[16:20:50.383]                   {
[16:20:50.383]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:50.383]                     NULL
[16:20:50.383]                   }
[16:20:50.383]                   options(future.plan = NULL)
[16:20:50.383]                   if (is.na(NA_character_)) 
[16:20:50.383]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:50.383]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:50.383]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:50.383]                     .init = FALSE)
[16:20:50.383]                 }
[16:20:50.383]             }
[16:20:50.383]         }
[16:20:50.383]     })
[16:20:50.383]     if (TRUE) {
[16:20:50.383]         base::sink(type = "output", split = FALSE)
[16:20:50.383]         if (TRUE) {
[16:20:50.383]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:50.383]         }
[16:20:50.383]         else {
[16:20:50.383]             ...future.result["stdout"] <- base::list(NULL)
[16:20:50.383]         }
[16:20:50.383]         base::close(...future.stdout)
[16:20:50.383]         ...future.stdout <- NULL
[16:20:50.383]     }
[16:20:50.383]     ...future.result$conditions <- ...future.conditions
[16:20:50.383]     ...future.result$finished <- base::Sys.time()
[16:20:50.383]     ...future.result
[16:20:50.383] }
[16:20:50.385] MultisessionFuture started
[16:20:50.386] - Launch lazy future ... done
[16:20:50.386] run() for ‘MultisessionFuture’ ... done
[16:20:50.386] result() for ClusterFuture ...
[16:20:50.386] receiveMessageFromWorker() for ClusterFuture ...
[16:20:50.386] - Validating connection of MultisessionFuture
[16:20:50.432] - received message: FutureResult
[16:20:50.432] - Received FutureResult
[16:20:50.432] - Erased future from FutureRegistry
[16:20:50.432] result() for ClusterFuture ...
[16:20:50.432] - result already collected: FutureResult
[16:20:50.432] result() for ClusterFuture ... done
[16:20:50.432] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:50.432] result() for ClusterFuture ... done
[16:20:50.432] result() for ClusterFuture ...
[16:20:50.433] - result already collected: FutureResult
[16:20:50.433] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[16:20:50.434] getGlobalsAndPackages() ...
[16:20:50.435] Searching for globals...
[16:20:50.439] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[16:20:50.439] Searching for globals ... DONE
[16:20:50.439] Resolving globals: FALSE
[16:20:50.439] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[16:20:50.440] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[16:20:50.440] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[16:20:50.440] 
[16:20:50.440] getGlobalsAndPackages() ... DONE
[16:20:50.440] run() for ‘Future’ ...
[16:20:50.441] - state: ‘created’
[16:20:50.441] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:50.454] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:50.455] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:50.455]   - Field: ‘node’
[16:20:50.455]   - Field: ‘label’
[16:20:50.455]   - Field: ‘local’
[16:20:50.455]   - Field: ‘owner’
[16:20:50.455]   - Field: ‘envir’
[16:20:50.455]   - Field: ‘workers’
[16:20:50.455]   - Field: ‘packages’
[16:20:50.455]   - Field: ‘gc’
[16:20:50.455]   - Field: ‘conditions’
[16:20:50.456]   - Field: ‘persistent’
[16:20:50.456]   - Field: ‘expr’
[16:20:50.456]   - Field: ‘uuid’
[16:20:50.458]   - Field: ‘seed’
[16:20:50.458]   - Field: ‘version’
[16:20:50.458]   - Field: ‘result’
[16:20:50.458]   - Field: ‘asynchronous’
[16:20:50.458]   - Field: ‘calls’
[16:20:50.458]   - Field: ‘globals’
[16:20:50.458]   - Field: ‘stdout’
[16:20:50.458]   - Field: ‘earlySignal’
[16:20:50.459]   - Field: ‘lazy’
[16:20:50.459]   - Field: ‘state’
[16:20:50.459] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:50.459] - Launch lazy future ...
[16:20:50.459] Packages needed by the future expression (n = 0): <none>
[16:20:50.459] Packages needed by future strategies (n = 0): <none>
[16:20:50.460] {
[16:20:50.460]     {
[16:20:50.460]         {
[16:20:50.460]             ...future.startTime <- base::Sys.time()
[16:20:50.460]             {
[16:20:50.460]                 {
[16:20:50.460]                   {
[16:20:50.460]                     {
[16:20:50.460]                       base::local({
[16:20:50.460]                         has_future <- base::requireNamespace("future", 
[16:20:50.460]                           quietly = TRUE)
[16:20:50.460]                         if (has_future) {
[16:20:50.460]                           ns <- base::getNamespace("future")
[16:20:50.460]                           version <- ns[[".package"]][["version"]]
[16:20:50.460]                           if (is.null(version)) 
[16:20:50.460]                             version <- utils::packageVersion("future")
[16:20:50.460]                         }
[16:20:50.460]                         else {
[16:20:50.460]                           version <- NULL
[16:20:50.460]                         }
[16:20:50.460]                         if (!has_future || version < "1.8.0") {
[16:20:50.460]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:50.460]                             "", base::R.version$version.string), 
[16:20:50.460]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:50.460]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:50.460]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:50.460]                               "release", "version")], collapse = " "), 
[16:20:50.460]                             hostname = base::Sys.info()[["nodename"]])
[16:20:50.460]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:50.460]                             info)
[16:20:50.460]                           info <- base::paste(info, collapse = "; ")
[16:20:50.460]                           if (!has_future) {
[16:20:50.460]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:50.460]                               info)
[16:20:50.460]                           }
[16:20:50.460]                           else {
[16:20:50.460]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:50.460]                               info, version)
[16:20:50.460]                           }
[16:20:50.460]                           base::stop(msg)
[16:20:50.460]                         }
[16:20:50.460]                       })
[16:20:50.460]                     }
[16:20:50.460]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:50.460]                     base::options(mc.cores = 1L)
[16:20:50.460]                   }
[16:20:50.460]                   ...future.strategy.old <- future::plan("list")
[16:20:50.460]                   options(future.plan = NULL)
[16:20:50.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:50.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:50.460]                 }
[16:20:50.460]                 ...future.workdir <- getwd()
[16:20:50.460]             }
[16:20:50.460]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:50.460]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:50.460]         }
[16:20:50.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:50.460]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:50.460]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:50.460]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:50.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:50.460]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:50.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:50.460]             base::names(...future.oldOptions))
[16:20:50.460]     }
[16:20:50.460]     if (FALSE) {
[16:20:50.460]     }
[16:20:50.460]     else {
[16:20:50.460]         if (TRUE) {
[16:20:50.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:50.460]                 open = "w")
[16:20:50.460]         }
[16:20:50.460]         else {
[16:20:50.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:50.460]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:50.460]         }
[16:20:50.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:50.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:50.460]             base::sink(type = "output", split = FALSE)
[16:20:50.460]             base::close(...future.stdout)
[16:20:50.460]         }, add = TRUE)
[16:20:50.460]     }
[16:20:50.460]     ...future.frame <- base::sys.nframe()
[16:20:50.460]     ...future.conditions <- base::list()
[16:20:50.460]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:50.460]     if (FALSE) {
[16:20:50.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:50.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:50.460]     }
[16:20:50.460]     ...future.result <- base::tryCatch({
[16:20:50.460]         base::withCallingHandlers({
[16:20:50.460]             ...future.value <- base::withVisible(base::local({
[16:20:50.460]                 ...future.makeSendCondition <- base::local({
[16:20:50.460]                   sendCondition <- NULL
[16:20:50.460]                   function(frame = 1L) {
[16:20:50.460]                     if (is.function(sendCondition)) 
[16:20:50.460]                       return(sendCondition)
[16:20:50.460]                     ns <- getNamespace("parallel")
[16:20:50.460]                     if (exists("sendData", mode = "function", 
[16:20:50.460]                       envir = ns)) {
[16:20:50.460]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:50.460]                         envir = ns)
[16:20:50.460]                       envir <- sys.frame(frame)
[16:20:50.460]                       master <- NULL
[16:20:50.460]                       while (!identical(envir, .GlobalEnv) && 
[16:20:50.460]                         !identical(envir, emptyenv())) {
[16:20:50.460]                         if (exists("master", mode = "list", envir = envir, 
[16:20:50.460]                           inherits = FALSE)) {
[16:20:50.460]                           master <- get("master", mode = "list", 
[16:20:50.460]                             envir = envir, inherits = FALSE)
[16:20:50.460]                           if (inherits(master, c("SOCKnode", 
[16:20:50.460]                             "SOCK0node"))) {
[16:20:50.460]                             sendCondition <<- function(cond) {
[16:20:50.460]                               data <- list(type = "VALUE", value = cond, 
[16:20:50.460]                                 success = TRUE)
[16:20:50.460]                               parallel_sendData(master, data)
[16:20:50.460]                             }
[16:20:50.460]                             return(sendCondition)
[16:20:50.460]                           }
[16:20:50.460]                         }
[16:20:50.460]                         frame <- frame + 1L
[16:20:50.460]                         envir <- sys.frame(frame)
[16:20:50.460]                       }
[16:20:50.460]                     }
[16:20:50.460]                     sendCondition <<- function(cond) NULL
[16:20:50.460]                   }
[16:20:50.460]                 })
[16:20:50.460]                 withCallingHandlers({
[16:20:50.460]                   {
[16:20:50.460]                     outer_function(1L)
[16:20:50.460]                   }
[16:20:50.460]                 }, immediateCondition = function(cond) {
[16:20:50.460]                   sendCondition <- ...future.makeSendCondition()
[16:20:50.460]                   sendCondition(cond)
[16:20:50.460]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.460]                   {
[16:20:50.460]                     inherits <- base::inherits
[16:20:50.460]                     invokeRestart <- base::invokeRestart
[16:20:50.460]                     is.null <- base::is.null
[16:20:50.460]                     muffled <- FALSE
[16:20:50.460]                     if (inherits(cond, "message")) {
[16:20:50.460]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:50.460]                       if (muffled) 
[16:20:50.460]                         invokeRestart("muffleMessage")
[16:20:50.460]                     }
[16:20:50.460]                     else if (inherits(cond, "warning")) {
[16:20:50.460]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:50.460]                       if (muffled) 
[16:20:50.460]                         invokeRestart("muffleWarning")
[16:20:50.460]                     }
[16:20:50.460]                     else if (inherits(cond, "condition")) {
[16:20:50.460]                       if (!is.null(pattern)) {
[16:20:50.460]                         computeRestarts <- base::computeRestarts
[16:20:50.460]                         grepl <- base::grepl
[16:20:50.460]                         restarts <- computeRestarts(cond)
[16:20:50.460]                         for (restart in restarts) {
[16:20:50.460]                           name <- restart$name
[16:20:50.460]                           if (is.null(name)) 
[16:20:50.460]                             next
[16:20:50.460]                           if (!grepl(pattern, name)) 
[16:20:50.460]                             next
[16:20:50.460]                           invokeRestart(restart)
[16:20:50.460]                           muffled <- TRUE
[16:20:50.460]                           break
[16:20:50.460]                         }
[16:20:50.460]                       }
[16:20:50.460]                     }
[16:20:50.460]                     invisible(muffled)
[16:20:50.460]                   }
[16:20:50.460]                   muffleCondition(cond)
[16:20:50.460]                 })
[16:20:50.460]             }))
[16:20:50.460]             future::FutureResult(value = ...future.value$value, 
[16:20:50.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:50.460]                   ...future.rng), globalenv = if (FALSE) 
[16:20:50.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:50.460]                     ...future.globalenv.names))
[16:20:50.460]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:50.460]         }, condition = base::local({
[16:20:50.460]             c <- base::c
[16:20:50.460]             inherits <- base::inherits
[16:20:50.460]             invokeRestart <- base::invokeRestart
[16:20:50.460]             length <- base::length
[16:20:50.460]             list <- base::list
[16:20:50.460]             seq.int <- base::seq.int
[16:20:50.460]             signalCondition <- base::signalCondition
[16:20:50.460]             sys.calls <- base::sys.calls
[16:20:50.460]             `[[` <- base::`[[`
[16:20:50.460]             `+` <- base::`+`
[16:20:50.460]             `<<-` <- base::`<<-`
[16:20:50.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:50.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:50.460]                   3L)]
[16:20:50.460]             }
[16:20:50.460]             function(cond) {
[16:20:50.460]                 is_error <- inherits(cond, "error")
[16:20:50.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:50.460]                   NULL)
[16:20:50.460]                 if (is_error) {
[16:20:50.460]                   sessionInformation <- function() {
[16:20:50.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:50.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:50.460]                       search = base::search(), system = base::Sys.info())
[16:20:50.460]                   }
[16:20:50.460]                   ...future.conditions[[length(...future.conditions) + 
[16:20:50.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:50.460]                     cond$call), session = sessionInformation(), 
[16:20:50.460]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:50.460]                   signalCondition(cond)
[16:20:50.460]                 }
[16:20:50.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:50.460]                 "immediateCondition"))) {
[16:20:50.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:50.460]                   ...future.conditions[[length(...future.conditions) + 
[16:20:50.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:50.460]                   if (TRUE && !signal) {
[16:20:50.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.460]                     {
[16:20:50.460]                       inherits <- base::inherits
[16:20:50.460]                       invokeRestart <- base::invokeRestart
[16:20:50.460]                       is.null <- base::is.null
[16:20:50.460]                       muffled <- FALSE
[16:20:50.460]                       if (inherits(cond, "message")) {
[16:20:50.460]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:50.460]                         if (muffled) 
[16:20:50.460]                           invokeRestart("muffleMessage")
[16:20:50.460]                       }
[16:20:50.460]                       else if (inherits(cond, "warning")) {
[16:20:50.460]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:50.460]                         if (muffled) 
[16:20:50.460]                           invokeRestart("muffleWarning")
[16:20:50.460]                       }
[16:20:50.460]                       else if (inherits(cond, "condition")) {
[16:20:50.460]                         if (!is.null(pattern)) {
[16:20:50.460]                           computeRestarts <- base::computeRestarts
[16:20:50.460]                           grepl <- base::grepl
[16:20:50.460]                           restarts <- computeRestarts(cond)
[16:20:50.460]                           for (restart in restarts) {
[16:20:50.460]                             name <- restart$name
[16:20:50.460]                             if (is.null(name)) 
[16:20:50.460]                               next
[16:20:50.460]                             if (!grepl(pattern, name)) 
[16:20:50.460]                               next
[16:20:50.460]                             invokeRestart(restart)
[16:20:50.460]                             muffled <- TRUE
[16:20:50.460]                             break
[16:20:50.460]                           }
[16:20:50.460]                         }
[16:20:50.460]                       }
[16:20:50.460]                       invisible(muffled)
[16:20:50.460]                     }
[16:20:50.460]                     muffleCondition(cond, pattern = "^muffle")
[16:20:50.460]                   }
[16:20:50.460]                 }
[16:20:50.460]                 else {
[16:20:50.460]                   if (TRUE) {
[16:20:50.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.460]                     {
[16:20:50.460]                       inherits <- base::inherits
[16:20:50.460]                       invokeRestart <- base::invokeRestart
[16:20:50.460]                       is.null <- base::is.null
[16:20:50.460]                       muffled <- FALSE
[16:20:50.460]                       if (inherits(cond, "message")) {
[16:20:50.460]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:50.460]                         if (muffled) 
[16:20:50.460]                           invokeRestart("muffleMessage")
[16:20:50.460]                       }
[16:20:50.460]                       else if (inherits(cond, "warning")) {
[16:20:50.460]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:50.460]                         if (muffled) 
[16:20:50.460]                           invokeRestart("muffleWarning")
[16:20:50.460]                       }
[16:20:50.460]                       else if (inherits(cond, "condition")) {
[16:20:50.460]                         if (!is.null(pattern)) {
[16:20:50.460]                           computeRestarts <- base::computeRestarts
[16:20:50.460]                           grepl <- base::grepl
[16:20:50.460]                           restarts <- computeRestarts(cond)
[16:20:50.460]                           for (restart in restarts) {
[16:20:50.460]                             name <- restart$name
[16:20:50.460]                             if (is.null(name)) 
[16:20:50.460]                               next
[16:20:50.460]                             if (!grepl(pattern, name)) 
[16:20:50.460]                               next
[16:20:50.460]                             invokeRestart(restart)
[16:20:50.460]                             muffled <- TRUE
[16:20:50.460]                             break
[16:20:50.460]                           }
[16:20:50.460]                         }
[16:20:50.460]                       }
[16:20:50.460]                       invisible(muffled)
[16:20:50.460]                     }
[16:20:50.460]                     muffleCondition(cond, pattern = "^muffle")
[16:20:50.460]                   }
[16:20:50.460]                 }
[16:20:50.460]             }
[16:20:50.460]         }))
[16:20:50.460]     }, error = function(ex) {
[16:20:50.460]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:50.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:50.460]                 ...future.rng), started = ...future.startTime, 
[16:20:50.460]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:50.460]             version = "1.8"), class = "FutureResult")
[16:20:50.460]     }, finally = {
[16:20:50.460]         if (!identical(...future.workdir, getwd())) 
[16:20:50.460]             setwd(...future.workdir)
[16:20:50.460]         {
[16:20:50.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:50.460]                 ...future.oldOptions$nwarnings <- NULL
[16:20:50.460]             }
[16:20:50.460]             base::options(...future.oldOptions)
[16:20:50.460]             if (.Platform$OS.type == "windows") {
[16:20:50.460]                 old_names <- names(...future.oldEnvVars)
[16:20:50.460]                 envs <- base::Sys.getenv()
[16:20:50.460]                 names <- names(envs)
[16:20:50.460]                 common <- intersect(names, old_names)
[16:20:50.460]                 added <- setdiff(names, old_names)
[16:20:50.460]                 removed <- setdiff(old_names, names)
[16:20:50.460]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:50.460]                   envs[common]]
[16:20:50.460]                 NAMES <- toupper(changed)
[16:20:50.460]                 args <- list()
[16:20:50.460]                 for (kk in seq_along(NAMES)) {
[16:20:50.460]                   name <- changed[[kk]]
[16:20:50.460]                   NAME <- NAMES[[kk]]
[16:20:50.460]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.460]                     next
[16:20:50.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:50.460]                 }
[16:20:50.460]                 NAMES <- toupper(added)
[16:20:50.460]                 for (kk in seq_along(NAMES)) {
[16:20:50.460]                   name <- added[[kk]]
[16:20:50.460]                   NAME <- NAMES[[kk]]
[16:20:50.460]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.460]                     next
[16:20:50.460]                   args[[name]] <- ""
[16:20:50.460]                 }
[16:20:50.460]                 NAMES <- toupper(removed)
[16:20:50.460]                 for (kk in seq_along(NAMES)) {
[16:20:50.460]                   name <- removed[[kk]]
[16:20:50.460]                   NAME <- NAMES[[kk]]
[16:20:50.460]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.460]                     next
[16:20:50.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:50.460]                 }
[16:20:50.460]                 if (length(args) > 0) 
[16:20:50.460]                   base::do.call(base::Sys.setenv, args = args)
[16:20:50.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:50.460]             }
[16:20:50.460]             else {
[16:20:50.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:50.460]             }
[16:20:50.460]             {
[16:20:50.460]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:50.460]                   0L) {
[16:20:50.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:50.460]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:50.460]                   base::options(opts)
[16:20:50.460]                 }
[16:20:50.460]                 {
[16:20:50.460]                   {
[16:20:50.460]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:50.460]                     NULL
[16:20:50.460]                   }
[16:20:50.460]                   options(future.plan = NULL)
[16:20:50.460]                   if (is.na(NA_character_)) 
[16:20:50.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:50.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:50.460]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:50.460]                     .init = FALSE)
[16:20:50.460]                 }
[16:20:50.460]             }
[16:20:50.460]         }
[16:20:50.460]     })
[16:20:50.460]     if (TRUE) {
[16:20:50.460]         base::sink(type = "output", split = FALSE)
[16:20:50.460]         if (TRUE) {
[16:20:50.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:50.460]         }
[16:20:50.460]         else {
[16:20:50.460]             ...future.result["stdout"] <- base::list(NULL)
[16:20:50.460]         }
[16:20:50.460]         base::close(...future.stdout)
[16:20:50.460]         ...future.stdout <- NULL
[16:20:50.460]     }
[16:20:50.460]     ...future.result$conditions <- ...future.conditions
[16:20:50.460]     ...future.result$finished <- base::Sys.time()
[16:20:50.460]     ...future.result
[16:20:50.460] }
[16:20:50.462] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[16:20:50.462] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[16:20:50.463] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[16:20:50.463] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[16:20:50.463] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[16:20:50.463] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[16:20:50.464] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[16:20:50.464] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[16:20:50.464] MultisessionFuture started
[16:20:50.464] - Launch lazy future ... done
[16:20:50.465] run() for ‘MultisessionFuture’ ... done
[16:20:50.465] result() for ClusterFuture ...
[16:20:50.465] receiveMessageFromWorker() for ClusterFuture ...
[16:20:50.465] - Validating connection of MultisessionFuture
[16:20:50.471] - received message: FutureResult
[16:20:50.471] - Received FutureResult
[16:20:50.471] - Erased future from FutureRegistry
[16:20:50.471] result() for ClusterFuture ...
[16:20:50.471] - result already collected: FutureResult
[16:20:50.471] result() for ClusterFuture ... done
[16:20:50.471] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:50.471] result() for ClusterFuture ... done
[16:20:50.471] result() for ClusterFuture ...
[16:20:50.471] - result already collected: FutureResult
[16:20:50.472] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[16:20:50.473] getGlobalsAndPackages() ...
[16:20:50.473] Searching for globals...
[16:20:50.477] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[16:20:50.477] Searching for globals ... DONE
[16:20:50.477] Resolving globals: FALSE
[16:20:50.478] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[16:20:50.478] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[16:20:50.478] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[16:20:50.479] 
[16:20:50.479] getGlobalsAndPackages() ... DONE
[16:20:50.479] run() for ‘Future’ ...
[16:20:50.479] - state: ‘created’
[16:20:50.479] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:50.493] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:50.493] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:50.493]   - Field: ‘node’
[16:20:50.493]   - Field: ‘label’
[16:20:50.493]   - Field: ‘local’
[16:20:50.494]   - Field: ‘owner’
[16:20:50.494]   - Field: ‘envir’
[16:20:50.494]   - Field: ‘workers’
[16:20:50.494]   - Field: ‘packages’
[16:20:50.494]   - Field: ‘gc’
[16:20:50.494]   - Field: ‘conditions’
[16:20:50.494]   - Field: ‘persistent’
[16:20:50.494]   - Field: ‘expr’
[16:20:50.494]   - Field: ‘uuid’
[16:20:50.494]   - Field: ‘seed’
[16:20:50.494]   - Field: ‘version’
[16:20:50.495]   - Field: ‘result’
[16:20:50.495]   - Field: ‘asynchronous’
[16:20:50.495]   - Field: ‘calls’
[16:20:50.495]   - Field: ‘globals’
[16:20:50.495]   - Field: ‘stdout’
[16:20:50.495]   - Field: ‘earlySignal’
[16:20:50.495]   - Field: ‘lazy’
[16:20:50.495]   - Field: ‘state’
[16:20:50.495] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:50.495] - Launch lazy future ...
[16:20:50.496] Packages needed by the future expression (n = 0): <none>
[16:20:50.496] Packages needed by future strategies (n = 0): <none>
[16:20:50.496] {
[16:20:50.496]     {
[16:20:50.496]         {
[16:20:50.496]             ...future.startTime <- base::Sys.time()
[16:20:50.496]             {
[16:20:50.496]                 {
[16:20:50.496]                   {
[16:20:50.496]                     {
[16:20:50.496]                       base::local({
[16:20:50.496]                         has_future <- base::requireNamespace("future", 
[16:20:50.496]                           quietly = TRUE)
[16:20:50.496]                         if (has_future) {
[16:20:50.496]                           ns <- base::getNamespace("future")
[16:20:50.496]                           version <- ns[[".package"]][["version"]]
[16:20:50.496]                           if (is.null(version)) 
[16:20:50.496]                             version <- utils::packageVersion("future")
[16:20:50.496]                         }
[16:20:50.496]                         else {
[16:20:50.496]                           version <- NULL
[16:20:50.496]                         }
[16:20:50.496]                         if (!has_future || version < "1.8.0") {
[16:20:50.496]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:50.496]                             "", base::R.version$version.string), 
[16:20:50.496]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:50.496]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:50.496]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:50.496]                               "release", "version")], collapse = " "), 
[16:20:50.496]                             hostname = base::Sys.info()[["nodename"]])
[16:20:50.496]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:50.496]                             info)
[16:20:50.496]                           info <- base::paste(info, collapse = "; ")
[16:20:50.496]                           if (!has_future) {
[16:20:50.496]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:50.496]                               info)
[16:20:50.496]                           }
[16:20:50.496]                           else {
[16:20:50.496]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:50.496]                               info, version)
[16:20:50.496]                           }
[16:20:50.496]                           base::stop(msg)
[16:20:50.496]                         }
[16:20:50.496]                       })
[16:20:50.496]                     }
[16:20:50.496]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:50.496]                     base::options(mc.cores = 1L)
[16:20:50.496]                   }
[16:20:50.496]                   ...future.strategy.old <- future::plan("list")
[16:20:50.496]                   options(future.plan = NULL)
[16:20:50.496]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:50.496]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:50.496]                 }
[16:20:50.496]                 ...future.workdir <- getwd()
[16:20:50.496]             }
[16:20:50.496]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:50.496]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:50.496]         }
[16:20:50.496]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:50.496]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:50.496]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:50.496]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:50.496]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:50.496]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:50.496]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:50.496]             base::names(...future.oldOptions))
[16:20:50.496]     }
[16:20:50.496]     if (FALSE) {
[16:20:50.496]     }
[16:20:50.496]     else {
[16:20:50.496]         if (TRUE) {
[16:20:50.496]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:50.496]                 open = "w")
[16:20:50.496]         }
[16:20:50.496]         else {
[16:20:50.496]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:50.496]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:50.496]         }
[16:20:50.496]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:50.496]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:50.496]             base::sink(type = "output", split = FALSE)
[16:20:50.496]             base::close(...future.stdout)
[16:20:50.496]         }, add = TRUE)
[16:20:50.496]     }
[16:20:50.496]     ...future.frame <- base::sys.nframe()
[16:20:50.496]     ...future.conditions <- base::list()
[16:20:50.496]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:50.496]     if (FALSE) {
[16:20:50.496]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:50.496]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:50.496]     }
[16:20:50.496]     ...future.result <- base::tryCatch({
[16:20:50.496]         base::withCallingHandlers({
[16:20:50.496]             ...future.value <- base::withVisible(base::local({
[16:20:50.496]                 ...future.makeSendCondition <- base::local({
[16:20:50.496]                   sendCondition <- NULL
[16:20:50.496]                   function(frame = 1L) {
[16:20:50.496]                     if (is.function(sendCondition)) 
[16:20:50.496]                       return(sendCondition)
[16:20:50.496]                     ns <- getNamespace("parallel")
[16:20:50.496]                     if (exists("sendData", mode = "function", 
[16:20:50.496]                       envir = ns)) {
[16:20:50.496]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:50.496]                         envir = ns)
[16:20:50.496]                       envir <- sys.frame(frame)
[16:20:50.496]                       master <- NULL
[16:20:50.496]                       while (!identical(envir, .GlobalEnv) && 
[16:20:50.496]                         !identical(envir, emptyenv())) {
[16:20:50.496]                         if (exists("master", mode = "list", envir = envir, 
[16:20:50.496]                           inherits = FALSE)) {
[16:20:50.496]                           master <- get("master", mode = "list", 
[16:20:50.496]                             envir = envir, inherits = FALSE)
[16:20:50.496]                           if (inherits(master, c("SOCKnode", 
[16:20:50.496]                             "SOCK0node"))) {
[16:20:50.496]                             sendCondition <<- function(cond) {
[16:20:50.496]                               data <- list(type = "VALUE", value = cond, 
[16:20:50.496]                                 success = TRUE)
[16:20:50.496]                               parallel_sendData(master, data)
[16:20:50.496]                             }
[16:20:50.496]                             return(sendCondition)
[16:20:50.496]                           }
[16:20:50.496]                         }
[16:20:50.496]                         frame <- frame + 1L
[16:20:50.496]                         envir <- sys.frame(frame)
[16:20:50.496]                       }
[16:20:50.496]                     }
[16:20:50.496]                     sendCondition <<- function(cond) NULL
[16:20:50.496]                   }
[16:20:50.496]                 })
[16:20:50.496]                 withCallingHandlers({
[16:20:50.496]                   {
[16:20:50.496]                     outer_function(1L)
[16:20:50.496]                   }
[16:20:50.496]                 }, immediateCondition = function(cond) {
[16:20:50.496]                   sendCondition <- ...future.makeSendCondition()
[16:20:50.496]                   sendCondition(cond)
[16:20:50.496]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.496]                   {
[16:20:50.496]                     inherits <- base::inherits
[16:20:50.496]                     invokeRestart <- base::invokeRestart
[16:20:50.496]                     is.null <- base::is.null
[16:20:50.496]                     muffled <- FALSE
[16:20:50.496]                     if (inherits(cond, "message")) {
[16:20:50.496]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:50.496]                       if (muffled) 
[16:20:50.496]                         invokeRestart("muffleMessage")
[16:20:50.496]                     }
[16:20:50.496]                     else if (inherits(cond, "warning")) {
[16:20:50.496]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:50.496]                       if (muffled) 
[16:20:50.496]                         invokeRestart("muffleWarning")
[16:20:50.496]                     }
[16:20:50.496]                     else if (inherits(cond, "condition")) {
[16:20:50.496]                       if (!is.null(pattern)) {
[16:20:50.496]                         computeRestarts <- base::computeRestarts
[16:20:50.496]                         grepl <- base::grepl
[16:20:50.496]                         restarts <- computeRestarts(cond)
[16:20:50.496]                         for (restart in restarts) {
[16:20:50.496]                           name <- restart$name
[16:20:50.496]                           if (is.null(name)) 
[16:20:50.496]                             next
[16:20:50.496]                           if (!grepl(pattern, name)) 
[16:20:50.496]                             next
[16:20:50.496]                           invokeRestart(restart)
[16:20:50.496]                           muffled <- TRUE
[16:20:50.496]                           break
[16:20:50.496]                         }
[16:20:50.496]                       }
[16:20:50.496]                     }
[16:20:50.496]                     invisible(muffled)
[16:20:50.496]                   }
[16:20:50.496]                   muffleCondition(cond)
[16:20:50.496]                 })
[16:20:50.496]             }))
[16:20:50.496]             future::FutureResult(value = ...future.value$value, 
[16:20:50.496]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:50.496]                   ...future.rng), globalenv = if (FALSE) 
[16:20:50.496]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:50.496]                     ...future.globalenv.names))
[16:20:50.496]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:50.496]         }, condition = base::local({
[16:20:50.496]             c <- base::c
[16:20:50.496]             inherits <- base::inherits
[16:20:50.496]             invokeRestart <- base::invokeRestart
[16:20:50.496]             length <- base::length
[16:20:50.496]             list <- base::list
[16:20:50.496]             seq.int <- base::seq.int
[16:20:50.496]             signalCondition <- base::signalCondition
[16:20:50.496]             sys.calls <- base::sys.calls
[16:20:50.496]             `[[` <- base::`[[`
[16:20:50.496]             `+` <- base::`+`
[16:20:50.496]             `<<-` <- base::`<<-`
[16:20:50.496]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:50.496]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:50.496]                   3L)]
[16:20:50.496]             }
[16:20:50.496]             function(cond) {
[16:20:50.496]                 is_error <- inherits(cond, "error")
[16:20:50.496]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:50.496]                   NULL)
[16:20:50.496]                 if (is_error) {
[16:20:50.496]                   sessionInformation <- function() {
[16:20:50.496]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:50.496]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:50.496]                       search = base::search(), system = base::Sys.info())
[16:20:50.496]                   }
[16:20:50.496]                   ...future.conditions[[length(...future.conditions) + 
[16:20:50.496]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:50.496]                     cond$call), session = sessionInformation(), 
[16:20:50.496]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:50.496]                   signalCondition(cond)
[16:20:50.496]                 }
[16:20:50.496]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:50.496]                 "immediateCondition"))) {
[16:20:50.496]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:50.496]                   ...future.conditions[[length(...future.conditions) + 
[16:20:50.496]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:50.496]                   if (TRUE && !signal) {
[16:20:50.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.496]                     {
[16:20:50.496]                       inherits <- base::inherits
[16:20:50.496]                       invokeRestart <- base::invokeRestart
[16:20:50.496]                       is.null <- base::is.null
[16:20:50.496]                       muffled <- FALSE
[16:20:50.496]                       if (inherits(cond, "message")) {
[16:20:50.496]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:50.496]                         if (muffled) 
[16:20:50.496]                           invokeRestart("muffleMessage")
[16:20:50.496]                       }
[16:20:50.496]                       else if (inherits(cond, "warning")) {
[16:20:50.496]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:50.496]                         if (muffled) 
[16:20:50.496]                           invokeRestart("muffleWarning")
[16:20:50.496]                       }
[16:20:50.496]                       else if (inherits(cond, "condition")) {
[16:20:50.496]                         if (!is.null(pattern)) {
[16:20:50.496]                           computeRestarts <- base::computeRestarts
[16:20:50.496]                           grepl <- base::grepl
[16:20:50.496]                           restarts <- computeRestarts(cond)
[16:20:50.496]                           for (restart in restarts) {
[16:20:50.496]                             name <- restart$name
[16:20:50.496]                             if (is.null(name)) 
[16:20:50.496]                               next
[16:20:50.496]                             if (!grepl(pattern, name)) 
[16:20:50.496]                               next
[16:20:50.496]                             invokeRestart(restart)
[16:20:50.496]                             muffled <- TRUE
[16:20:50.496]                             break
[16:20:50.496]                           }
[16:20:50.496]                         }
[16:20:50.496]                       }
[16:20:50.496]                       invisible(muffled)
[16:20:50.496]                     }
[16:20:50.496]                     muffleCondition(cond, pattern = "^muffle")
[16:20:50.496]                   }
[16:20:50.496]                 }
[16:20:50.496]                 else {
[16:20:50.496]                   if (TRUE) {
[16:20:50.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:50.496]                     {
[16:20:50.496]                       inherits <- base::inherits
[16:20:50.496]                       invokeRestart <- base::invokeRestart
[16:20:50.496]                       is.null <- base::is.null
[16:20:50.496]                       muffled <- FALSE
[16:20:50.496]                       if (inherits(cond, "message")) {
[16:20:50.496]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:50.496]                         if (muffled) 
[16:20:50.496]                           invokeRestart("muffleMessage")
[16:20:50.496]                       }
[16:20:50.496]                       else if (inherits(cond, "warning")) {
[16:20:50.496]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:50.496]                         if (muffled) 
[16:20:50.496]                           invokeRestart("muffleWarning")
[16:20:50.496]                       }
[16:20:50.496]                       else if (inherits(cond, "condition")) {
[16:20:50.496]                         if (!is.null(pattern)) {
[16:20:50.496]                           computeRestarts <- base::computeRestarts
[16:20:50.496]                           grepl <- base::grepl
[16:20:50.496]                           restarts <- computeRestarts(cond)
[16:20:50.496]                           for (restart in restarts) {
[16:20:50.496]                             name <- restart$name
[16:20:50.496]                             if (is.null(name)) 
[16:20:50.496]                               next
[16:20:50.496]                             if (!grepl(pattern, name)) 
[16:20:50.496]                               next
[16:20:50.496]                             invokeRestart(restart)
[16:20:50.496]                             muffled <- TRUE
[16:20:50.496]                             break
[16:20:50.496]                           }
[16:20:50.496]                         }
[16:20:50.496]                       }
[16:20:50.496]                       invisible(muffled)
[16:20:50.496]                     }
[16:20:50.496]                     muffleCondition(cond, pattern = "^muffle")
[16:20:50.496]                   }
[16:20:50.496]                 }
[16:20:50.496]             }
[16:20:50.496]         }))
[16:20:50.496]     }, error = function(ex) {
[16:20:50.496]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:50.496]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:50.496]                 ...future.rng), started = ...future.startTime, 
[16:20:50.496]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:50.496]             version = "1.8"), class = "FutureResult")
[16:20:50.496]     }, finally = {
[16:20:50.496]         if (!identical(...future.workdir, getwd())) 
[16:20:50.496]             setwd(...future.workdir)
[16:20:50.496]         {
[16:20:50.496]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:50.496]                 ...future.oldOptions$nwarnings <- NULL
[16:20:50.496]             }
[16:20:50.496]             base::options(...future.oldOptions)
[16:20:50.496]             if (.Platform$OS.type == "windows") {
[16:20:50.496]                 old_names <- names(...future.oldEnvVars)
[16:20:50.496]                 envs <- base::Sys.getenv()
[16:20:50.496]                 names <- names(envs)
[16:20:50.496]                 common <- intersect(names, old_names)
[16:20:50.496]                 added <- setdiff(names, old_names)
[16:20:50.496]                 removed <- setdiff(old_names, names)
[16:20:50.496]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:50.496]                   envs[common]]
[16:20:50.496]                 NAMES <- toupper(changed)
[16:20:50.496]                 args <- list()
[16:20:50.496]                 for (kk in seq_along(NAMES)) {
[16:20:50.496]                   name <- changed[[kk]]
[16:20:50.496]                   NAME <- NAMES[[kk]]
[16:20:50.496]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.496]                     next
[16:20:50.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:50.496]                 }
[16:20:50.496]                 NAMES <- toupper(added)
[16:20:50.496]                 for (kk in seq_along(NAMES)) {
[16:20:50.496]                   name <- added[[kk]]
[16:20:50.496]                   NAME <- NAMES[[kk]]
[16:20:50.496]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.496]                     next
[16:20:50.496]                   args[[name]] <- ""
[16:20:50.496]                 }
[16:20:50.496]                 NAMES <- toupper(removed)
[16:20:50.496]                 for (kk in seq_along(NAMES)) {
[16:20:50.496]                   name <- removed[[kk]]
[16:20:50.496]                   NAME <- NAMES[[kk]]
[16:20:50.496]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:50.496]                     next
[16:20:50.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:50.496]                 }
[16:20:50.496]                 if (length(args) > 0) 
[16:20:50.496]                   base::do.call(base::Sys.setenv, args = args)
[16:20:50.496]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:50.496]             }
[16:20:50.496]             else {
[16:20:50.496]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:50.496]             }
[16:20:50.496]             {
[16:20:50.496]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:50.496]                   0L) {
[16:20:50.496]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:50.496]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:50.496]                   base::options(opts)
[16:20:50.496]                 }
[16:20:50.496]                 {
[16:20:50.496]                   {
[16:20:50.496]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:50.496]                     NULL
[16:20:50.496]                   }
[16:20:50.496]                   options(future.plan = NULL)
[16:20:50.496]                   if (is.na(NA_character_)) 
[16:20:50.496]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:50.496]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:50.496]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:50.496]                     .init = FALSE)
[16:20:50.496]                 }
[16:20:50.496]             }
[16:20:50.496]         }
[16:20:50.496]     })
[16:20:50.496]     if (TRUE) {
[16:20:50.496]         base::sink(type = "output", split = FALSE)
[16:20:50.496]         if (TRUE) {
[16:20:50.496]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:50.496]         }
[16:20:50.496]         else {
[16:20:50.496]             ...future.result["stdout"] <- base::list(NULL)
[16:20:50.496]         }
[16:20:50.496]         base::close(...future.stdout)
[16:20:50.496]         ...future.stdout <- NULL
[16:20:50.496]     }
[16:20:50.496]     ...future.result$conditions <- ...future.conditions
[16:20:50.496]     ...future.result$finished <- base::Sys.time()
[16:20:50.496]     ...future.result
[16:20:50.496] }
[16:20:50.499] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[16:20:50.499] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[16:20:50.499] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[16:20:50.499] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[16:20:50.500] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[16:20:50.500] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[16:20:50.500] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[16:20:50.500] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[16:20:50.501] MultisessionFuture started
[16:20:50.501] - Launch lazy future ... done
[16:20:50.501] run() for ‘MultisessionFuture’ ... done
[16:20:50.501] result() for ClusterFuture ...
[16:20:50.502] receiveMessageFromWorker() for ClusterFuture ...
[16:20:50.502] - Validating connection of MultisessionFuture
[16:20:50.505] - received message: FutureResult
[16:20:50.505] - Received FutureResult
[16:20:50.505] - Erased future from FutureRegistry
[16:20:50.505] result() for ClusterFuture ...
[16:20:50.505] - result already collected: FutureResult
[16:20:50.505] result() for ClusterFuture ... done
[16:20:50.506] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:50.506] result() for ClusterFuture ... done
[16:20:50.506] result() for ClusterFuture ...
[16:20:50.506] - result already collected: FutureResult
[16:20:50.506] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 2 cores ... DONE
> 
> message("*** Globals - formulas ... DONE")
*** Globals - formulas ... DONE
> 
> source("incl/end.R")
[16:20:50.508] plan(): Setting new future strategy stack:
[16:20:50.508] List of future strategies:
[16:20:50.508] 1. FutureStrategy:
[16:20:50.508]    - args: function (..., envir = parent.frame())
[16:20:50.508]    - tweaked: FALSE
[16:20:50.508]    - call: future::plan(oplan)
[16:20:50.509] plan(): nbrOfWorkers() = 1
> 
