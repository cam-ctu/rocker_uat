
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:20:32.804] plan(): Setting new future strategy stack:
[16:20:32.804] List of future strategies:
[16:20:32.804] 1. sequential:
[16:20:32.804]    - args: function (..., envir = parent.frame())
[16:20:32.804]    - tweaked: FALSE
[16:20:32.804]    - call: future::plan("sequential")
[16:20:32.818] plan(): nbrOfWorkers() = 1
> 
> message("*** %<-% ...")
*** %<-% ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("*** %%<-%% with %s futures ...", sQuote(strategy)))
+     plan(strategy)
+ 
+     rm(list = intersect(c("x", "y"), ls()))
+ 
+     message("** Future evaluation without globals")
+     v1 %<-% { x <- 1 }
+     stopifnot(!exists("x", inherits = FALSE), identical(v1, 1))
+ 
+     message("** Future evaluation with globals")
+     a <- 2
+     v2 %<-% { x <- a }
+     stopifnot(!exists("x", inherits = FALSE), identical(v2, a))
+ 
+     message("** Future evaluation with errors")
+     v3 %<-% {
+       x <- 3
+       stop("Woops!")
+       x
+     }
+     stopifnot(!exists("x", inherits = FALSE))
+     res <- tryCatch(identical(v3, 3), error = identity)
+     stopifnot(inherits(res, "error"))
+ 
+ 
+     y <- listenv::listenv()
+     for (ii in 1:3) {
+       y[[ii]] %<-% {
+         if (ii %% 2 == 0) stop("Woops!")
+         ii
+       }
+     }
+     res <- tryCatch(as.list(y), error = identity)
+     stopifnot(inherits(res, "error"))
+     z <- y[c(1, 3)]
+     z <- unlist(z)
+     stopifnot(all(z == c(1, 3)))
+     res <- tryCatch(y[[2]], error = identity)
+     stopifnot(inherits(res, "error"))
+     res <- tryCatch(y[1:2], error = identity)
+     stopifnot(inherits(res, "error"))
+ 
+ 
+     message("** Future evaluation with a poor-man's \"progress bar\"")
+     v4 %<-% {
+       cat("Processing: ")
+       for (ii in 1:10) { cat(".") }
+       cat(" [100%]\n")
+       4
+     }
+ 
+ 
+     message("** Collecting results")
+     printf("v1 = %s\n", v1)
+     stopifnot(v1 == 1)
+ 
+     printf("v2 = %s\n", v2)
+     stopifnot(v2 == a)
+ 
+     stopifnot(tryCatch({
+       printf("v3 = %s\n", v3)
+     }, error = function(ex) {
+       printf("v3: <%s> (as expect)\n", class(ex)[1])
+       TRUE
+     }))
+ 
+     printf("v4 = %s\n", v4)
+     #stopifnot(v4 == 4)
+ 
+ 
+     message("** Left-to-right and right-to-left future assignments")
+     c %<-% 1
+     printf("c = %s\n", c)
+     1 %->% d
+     printf("d = %s\n", d)
+     stopifnot(d == c)
+ 
+ 
+ 
+     message("** Nested future assignments")
+     a %<-% {
+       b <- 1
+       c %<-% 2
+       3 -> d
+       4 %->% e
+       b + c + d + e
+     }
+     printf("a = %s\n", a)
+     stopifnot(a == 10)
+ 
+     { a + 1 } %->% b
+     printf("b = %s\n", b)
+     stopifnot(b == a + 1)
+ 
+     message(sprintf("*** %%<-%% with %s futures ... DONE", sQuote(strategy)))
+   } # for (strategy in ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
*** %<-% with ‘sequential’ futures ...
[16:20:32.871] plan(): Setting new future strategy stack:
[16:20:32.871] List of future strategies:
[16:20:32.871] 1. sequential:
[16:20:32.871]    - args: function (..., envir = parent.frame())
[16:20:32.871]    - tweaked: FALSE
[16:20:32.871]    - call: plan(strategy)
[16:20:32.883] plan(): nbrOfWorkers() = 1
** Future evaluation without globals
[16:20:32.884] getGlobalsAndPackages() ...
[16:20:32.885] Searching for globals...
[16:20:32.889] - globals found: [2] ‘{’, ‘<-’
[16:20:32.890] Searching for globals ... DONE
[16:20:32.890] Resolving globals: FALSE
[16:20:32.890] 
[16:20:32.890] 
[16:20:32.890] getGlobalsAndPackages() ... DONE
[16:20:32.891] run() for ‘Future’ ...
[16:20:32.891] - state: ‘created’
[16:20:32.892] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:32.892] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:32.892] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:32.892]   - Field: ‘label’
[16:20:32.892]   - Field: ‘local’
[16:20:32.892]   - Field: ‘owner’
[16:20:32.892]   - Field: ‘envir’
[16:20:32.892]   - Field: ‘packages’
[16:20:32.893]   - Field: ‘gc’
[16:20:32.893]   - Field: ‘conditions’
[16:20:32.893]   - Field: ‘expr’
[16:20:32.893]   - Field: ‘uuid’
[16:20:32.893]   - Field: ‘seed’
[16:20:32.893]   - Field: ‘version’
[16:20:32.893]   - Field: ‘result’
[16:20:32.893]   - Field: ‘asynchronous’
[16:20:32.893]   - Field: ‘calls’
[16:20:32.893]   - Field: ‘globals’
[16:20:32.894]   - Field: ‘stdout’
[16:20:32.894]   - Field: ‘earlySignal’
[16:20:32.894]   - Field: ‘lazy’
[16:20:32.894]   - Field: ‘state’
[16:20:32.894] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:32.894] - Launch lazy future ...
[16:20:32.895] Packages needed by the future expression (n = 0): <none>
[16:20:32.895] Packages needed by future strategies (n = 0): <none>
[16:20:32.896] {
[16:20:32.896]     {
[16:20:32.896]         {
[16:20:32.896]             ...future.startTime <- base::Sys.time()
[16:20:32.896]             {
[16:20:32.896]                 {
[16:20:32.896]                   {
[16:20:32.896]                     base::local({
[16:20:32.896]                       has_future <- base::requireNamespace("future", 
[16:20:32.896]                         quietly = TRUE)
[16:20:32.896]                       if (has_future) {
[16:20:32.896]                         ns <- base::getNamespace("future")
[16:20:32.896]                         version <- ns[[".package"]][["version"]]
[16:20:32.896]                         if (is.null(version)) 
[16:20:32.896]                           version <- utils::packageVersion("future")
[16:20:32.896]                       }
[16:20:32.896]                       else {
[16:20:32.896]                         version <- NULL
[16:20:32.896]                       }
[16:20:32.896]                       if (!has_future || version < "1.8.0") {
[16:20:32.896]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:32.896]                           "", base::R.version$version.string), 
[16:20:32.896]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:32.896]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:32.896]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:32.896]                             "release", "version")], collapse = " "), 
[16:20:32.896]                           hostname = base::Sys.info()[["nodename"]])
[16:20:32.896]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:32.896]                           info)
[16:20:32.896]                         info <- base::paste(info, collapse = "; ")
[16:20:32.896]                         if (!has_future) {
[16:20:32.896]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:32.896]                             info)
[16:20:32.896]                         }
[16:20:32.896]                         else {
[16:20:32.896]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:32.896]                             info, version)
[16:20:32.896]                         }
[16:20:32.896]                         base::stop(msg)
[16:20:32.896]                       }
[16:20:32.896]                     })
[16:20:32.896]                   }
[16:20:32.896]                   ...future.strategy.old <- future::plan("list")
[16:20:32.896]                   options(future.plan = NULL)
[16:20:32.896]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:32.896]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:32.896]                 }
[16:20:32.896]                 ...future.workdir <- getwd()
[16:20:32.896]             }
[16:20:32.896]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:32.896]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:32.896]         }
[16:20:32.896]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:32.896]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:32.896]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:32.896]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:32.896]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:32.896]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:32.896]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:32.896]             base::names(...future.oldOptions))
[16:20:32.896]     }
[16:20:32.896]     if (FALSE) {
[16:20:32.896]     }
[16:20:32.896]     else {
[16:20:32.896]         if (TRUE) {
[16:20:32.896]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:32.896]                 open = "w")
[16:20:32.896]         }
[16:20:32.896]         else {
[16:20:32.896]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:32.896]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:32.896]         }
[16:20:32.896]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:32.896]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:32.896]             base::sink(type = "output", split = FALSE)
[16:20:32.896]             base::close(...future.stdout)
[16:20:32.896]         }, add = TRUE)
[16:20:32.896]     }
[16:20:32.896]     ...future.frame <- base::sys.nframe()
[16:20:32.896]     ...future.conditions <- base::list()
[16:20:32.896]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:32.896]     if (FALSE) {
[16:20:32.896]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:32.896]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:32.896]     }
[16:20:32.896]     ...future.result <- base::tryCatch({
[16:20:32.896]         base::withCallingHandlers({
[16:20:32.896]             ...future.value <- base::withVisible(base::local({
[16:20:32.896]                 x <- 1
[16:20:32.896]             }))
[16:20:32.896]             future::FutureResult(value = ...future.value$value, 
[16:20:32.896]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:32.896]                   ...future.rng), globalenv = if (FALSE) 
[16:20:32.896]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:32.896]                     ...future.globalenv.names))
[16:20:32.896]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:32.896]         }, condition = base::local({
[16:20:32.896]             c <- base::c
[16:20:32.896]             inherits <- base::inherits
[16:20:32.896]             invokeRestart <- base::invokeRestart
[16:20:32.896]             length <- base::length
[16:20:32.896]             list <- base::list
[16:20:32.896]             seq.int <- base::seq.int
[16:20:32.896]             signalCondition <- base::signalCondition
[16:20:32.896]             sys.calls <- base::sys.calls
[16:20:32.896]             `[[` <- base::`[[`
[16:20:32.896]             `+` <- base::`+`
[16:20:32.896]             `<<-` <- base::`<<-`
[16:20:32.896]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:32.896]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:32.896]                   3L)]
[16:20:32.896]             }
[16:20:32.896]             function(cond) {
[16:20:32.896]                 is_error <- inherits(cond, "error")
[16:20:32.896]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:32.896]                   NULL)
[16:20:32.896]                 if (is_error) {
[16:20:32.896]                   sessionInformation <- function() {
[16:20:32.896]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:32.896]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:32.896]                       search = base::search(), system = base::Sys.info())
[16:20:32.896]                   }
[16:20:32.896]                   ...future.conditions[[length(...future.conditions) + 
[16:20:32.896]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:32.896]                     cond$call), session = sessionInformation(), 
[16:20:32.896]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:32.896]                   signalCondition(cond)
[16:20:32.896]                 }
[16:20:32.896]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:32.896]                 "immediateCondition"))) {
[16:20:32.896]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:32.896]                   ...future.conditions[[length(...future.conditions) + 
[16:20:32.896]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:32.896]                   if (TRUE && !signal) {
[16:20:32.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:32.896]                     {
[16:20:32.896]                       inherits <- base::inherits
[16:20:32.896]                       invokeRestart <- base::invokeRestart
[16:20:32.896]                       is.null <- base::is.null
[16:20:32.896]                       muffled <- FALSE
[16:20:32.896]                       if (inherits(cond, "message")) {
[16:20:32.896]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:32.896]                         if (muffled) 
[16:20:32.896]                           invokeRestart("muffleMessage")
[16:20:32.896]                       }
[16:20:32.896]                       else if (inherits(cond, "warning")) {
[16:20:32.896]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:32.896]                         if (muffled) 
[16:20:32.896]                           invokeRestart("muffleWarning")
[16:20:32.896]                       }
[16:20:32.896]                       else if (inherits(cond, "condition")) {
[16:20:32.896]                         if (!is.null(pattern)) {
[16:20:32.896]                           computeRestarts <- base::computeRestarts
[16:20:32.896]                           grepl <- base::grepl
[16:20:32.896]                           restarts <- computeRestarts(cond)
[16:20:32.896]                           for (restart in restarts) {
[16:20:32.896]                             name <- restart$name
[16:20:32.896]                             if (is.null(name)) 
[16:20:32.896]                               next
[16:20:32.896]                             if (!grepl(pattern, name)) 
[16:20:32.896]                               next
[16:20:32.896]                             invokeRestart(restart)
[16:20:32.896]                             muffled <- TRUE
[16:20:32.896]                             break
[16:20:32.896]                           }
[16:20:32.896]                         }
[16:20:32.896]                       }
[16:20:32.896]                       invisible(muffled)
[16:20:32.896]                     }
[16:20:32.896]                     muffleCondition(cond, pattern = "^muffle")
[16:20:32.896]                   }
[16:20:32.896]                 }
[16:20:32.896]                 else {
[16:20:32.896]                   if (TRUE) {
[16:20:32.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:32.896]                     {
[16:20:32.896]                       inherits <- base::inherits
[16:20:32.896]                       invokeRestart <- base::invokeRestart
[16:20:32.896]                       is.null <- base::is.null
[16:20:32.896]                       muffled <- FALSE
[16:20:32.896]                       if (inherits(cond, "message")) {
[16:20:32.896]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:32.896]                         if (muffled) 
[16:20:32.896]                           invokeRestart("muffleMessage")
[16:20:32.896]                       }
[16:20:32.896]                       else if (inherits(cond, "warning")) {
[16:20:32.896]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:32.896]                         if (muffled) 
[16:20:32.896]                           invokeRestart("muffleWarning")
[16:20:32.896]                       }
[16:20:32.896]                       else if (inherits(cond, "condition")) {
[16:20:32.896]                         if (!is.null(pattern)) {
[16:20:32.896]                           computeRestarts <- base::computeRestarts
[16:20:32.896]                           grepl <- base::grepl
[16:20:32.896]                           restarts <- computeRestarts(cond)
[16:20:32.896]                           for (restart in restarts) {
[16:20:32.896]                             name <- restart$name
[16:20:32.896]                             if (is.null(name)) 
[16:20:32.896]                               next
[16:20:32.896]                             if (!grepl(pattern, name)) 
[16:20:32.896]                               next
[16:20:32.896]                             invokeRestart(restart)
[16:20:32.896]                             muffled <- TRUE
[16:20:32.896]                             break
[16:20:32.896]                           }
[16:20:32.896]                         }
[16:20:32.896]                       }
[16:20:32.896]                       invisible(muffled)
[16:20:32.896]                     }
[16:20:32.896]                     muffleCondition(cond, pattern = "^muffle")
[16:20:32.896]                   }
[16:20:32.896]                 }
[16:20:32.896]             }
[16:20:32.896]         }))
[16:20:32.896]     }, error = function(ex) {
[16:20:32.896]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:32.896]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:32.896]                 ...future.rng), started = ...future.startTime, 
[16:20:32.896]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:32.896]             version = "1.8"), class = "FutureResult")
[16:20:32.896]     }, finally = {
[16:20:32.896]         if (!identical(...future.workdir, getwd())) 
[16:20:32.896]             setwd(...future.workdir)
[16:20:32.896]         {
[16:20:32.896]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:32.896]                 ...future.oldOptions$nwarnings <- NULL
[16:20:32.896]             }
[16:20:32.896]             base::options(...future.oldOptions)
[16:20:32.896]             if (.Platform$OS.type == "windows") {
[16:20:32.896]                 old_names <- names(...future.oldEnvVars)
[16:20:32.896]                 envs <- base::Sys.getenv()
[16:20:32.896]                 names <- names(envs)
[16:20:32.896]                 common <- intersect(names, old_names)
[16:20:32.896]                 added <- setdiff(names, old_names)
[16:20:32.896]                 removed <- setdiff(old_names, names)
[16:20:32.896]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:32.896]                   envs[common]]
[16:20:32.896]                 NAMES <- toupper(changed)
[16:20:32.896]                 args <- list()
[16:20:32.896]                 for (kk in seq_along(NAMES)) {
[16:20:32.896]                   name <- changed[[kk]]
[16:20:32.896]                   NAME <- NAMES[[kk]]
[16:20:32.896]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:32.896]                     next
[16:20:32.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:32.896]                 }
[16:20:32.896]                 NAMES <- toupper(added)
[16:20:32.896]                 for (kk in seq_along(NAMES)) {
[16:20:32.896]                   name <- added[[kk]]
[16:20:32.896]                   NAME <- NAMES[[kk]]
[16:20:32.896]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:32.896]                     next
[16:20:32.896]                   args[[name]] <- ""
[16:20:32.896]                 }
[16:20:32.896]                 NAMES <- toupper(removed)
[16:20:32.896]                 for (kk in seq_along(NAMES)) {
[16:20:32.896]                   name <- removed[[kk]]
[16:20:32.896]                   NAME <- NAMES[[kk]]
[16:20:32.896]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:32.896]                     next
[16:20:32.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:32.896]                 }
[16:20:32.896]                 if (length(args) > 0) 
[16:20:32.896]                   base::do.call(base::Sys.setenv, args = args)
[16:20:32.896]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:32.896]             }
[16:20:32.896]             else {
[16:20:32.896]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:32.896]             }
[16:20:32.896]             {
[16:20:32.896]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:32.896]                   0L) {
[16:20:32.896]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:32.896]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:32.896]                   base::options(opts)
[16:20:32.896]                 }
[16:20:32.896]                 {
[16:20:32.896]                   {
[16:20:32.896]                     NULL
[16:20:32.896]                     RNGkind("Mersenne-Twister")
[16:20:32.896]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:32.896]                       inherits = FALSE)
[16:20:32.896]                   }
[16:20:32.896]                   options(future.plan = NULL)
[16:20:32.896]                   if (is.na(NA_character_)) 
[16:20:32.896]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:32.896]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:32.896]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:32.896]                     .init = FALSE)
[16:20:32.896]                 }
[16:20:32.896]             }
[16:20:32.896]         }
[16:20:32.896]     })
[16:20:32.896]     if (TRUE) {
[16:20:32.896]         base::sink(type = "output", split = FALSE)
[16:20:32.896]         if (TRUE) {
[16:20:32.896]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:32.896]         }
[16:20:32.896]         else {
[16:20:32.896]             ...future.result["stdout"] <- base::list(NULL)
[16:20:32.896]         }
[16:20:32.896]         base::close(...future.stdout)
[16:20:32.896]         ...future.stdout <- NULL
[16:20:32.896]     }
[16:20:32.896]     ...future.result$conditions <- ...future.conditions
[16:20:32.896]     ...future.result$finished <- base::Sys.time()
[16:20:32.896]     ...future.result
[16:20:32.896] }
[16:20:32.898] plan(): Setting new future strategy stack:
[16:20:32.898] List of future strategies:
[16:20:32.898] 1. sequential:
[16:20:32.898]    - args: function (..., envir = parent.frame())
[16:20:32.898]    - tweaked: FALSE
[16:20:32.898]    - call: NULL
[16:20:32.898] plan(): nbrOfWorkers() = 1
[16:20:32.900] plan(): Setting new future strategy stack:
[16:20:32.900] List of future strategies:
[16:20:32.900] 1. sequential:
[16:20:32.900]    - args: function (..., envir = parent.frame())
[16:20:32.900]    - tweaked: FALSE
[16:20:32.900]    - call: plan(strategy)
[16:20:32.900] plan(): nbrOfWorkers() = 1
[16:20:32.900] SequentialFuture started (and completed)
[16:20:32.901] - Launch lazy future ... done
[16:20:32.901] run() for ‘SequentialFuture’ ... done
** Future evaluation with globals
[16:20:32.902] getGlobalsAndPackages() ...
[16:20:32.902] Searching for globals...
[16:20:32.903] - globals found: [3] ‘{’, ‘<-’, ‘a’
[16:20:32.903] Searching for globals ... DONE
[16:20:32.903] Resolving globals: FALSE
[16:20:32.904] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:32.904] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:20:32.904] - globals: [1] ‘a’
[16:20:32.904] 
[16:20:32.904] getGlobalsAndPackages() ... DONE
[16:20:32.905] run() for ‘Future’ ...
[16:20:32.905] - state: ‘created’
[16:20:32.905] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:32.905] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:32.905] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:32.905]   - Field: ‘label’
[16:20:32.905]   - Field: ‘local’
[16:20:32.905]   - Field: ‘owner’
[16:20:32.906]   - Field: ‘envir’
[16:20:32.906]   - Field: ‘packages’
[16:20:32.906]   - Field: ‘gc’
[16:20:32.906]   - Field: ‘conditions’
[16:20:32.906]   - Field: ‘expr’
[16:20:32.906]   - Field: ‘uuid’
[16:20:32.906]   - Field: ‘seed’
[16:20:32.906]   - Field: ‘version’
[16:20:32.906]   - Field: ‘result’
[16:20:32.906]   - Field: ‘asynchronous’
[16:20:32.906]   - Field: ‘calls’
[16:20:32.907]   - Field: ‘globals’
[16:20:32.907]   - Field: ‘stdout’
[16:20:32.907]   - Field: ‘earlySignal’
[16:20:32.907]   - Field: ‘lazy’
[16:20:32.907]   - Field: ‘state’
[16:20:32.907] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:32.907] - Launch lazy future ...
[16:20:32.907] Packages needed by the future expression (n = 0): <none>
[16:20:32.907] Packages needed by future strategies (n = 0): <none>
[16:20:32.908] {
[16:20:32.908]     {
[16:20:32.908]         {
[16:20:32.908]             ...future.startTime <- base::Sys.time()
[16:20:32.908]             {
[16:20:32.908]                 {
[16:20:32.908]                   {
[16:20:32.908]                     base::local({
[16:20:32.908]                       has_future <- base::requireNamespace("future", 
[16:20:32.908]                         quietly = TRUE)
[16:20:32.908]                       if (has_future) {
[16:20:32.908]                         ns <- base::getNamespace("future")
[16:20:32.908]                         version <- ns[[".package"]][["version"]]
[16:20:32.908]                         if (is.null(version)) 
[16:20:32.908]                           version <- utils::packageVersion("future")
[16:20:32.908]                       }
[16:20:32.908]                       else {
[16:20:32.908]                         version <- NULL
[16:20:32.908]                       }
[16:20:32.908]                       if (!has_future || version < "1.8.0") {
[16:20:32.908]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:32.908]                           "", base::R.version$version.string), 
[16:20:32.908]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:32.908]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:32.908]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:32.908]                             "release", "version")], collapse = " "), 
[16:20:32.908]                           hostname = base::Sys.info()[["nodename"]])
[16:20:32.908]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:32.908]                           info)
[16:20:32.908]                         info <- base::paste(info, collapse = "; ")
[16:20:32.908]                         if (!has_future) {
[16:20:32.908]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:32.908]                             info)
[16:20:32.908]                         }
[16:20:32.908]                         else {
[16:20:32.908]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:32.908]                             info, version)
[16:20:32.908]                         }
[16:20:32.908]                         base::stop(msg)
[16:20:32.908]                       }
[16:20:32.908]                     })
[16:20:32.908]                   }
[16:20:32.908]                   ...future.strategy.old <- future::plan("list")
[16:20:32.908]                   options(future.plan = NULL)
[16:20:32.908]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:32.908]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:32.908]                 }
[16:20:32.908]                 ...future.workdir <- getwd()
[16:20:32.908]             }
[16:20:32.908]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:32.908]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:32.908]         }
[16:20:32.908]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:32.908]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:32.908]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:32.908]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:32.908]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:32.908]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:32.908]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:32.908]             base::names(...future.oldOptions))
[16:20:32.908]     }
[16:20:32.908]     if (FALSE) {
[16:20:32.908]     }
[16:20:32.908]     else {
[16:20:32.908]         if (TRUE) {
[16:20:32.908]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:32.908]                 open = "w")
[16:20:32.908]         }
[16:20:32.908]         else {
[16:20:32.908]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:32.908]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:32.908]         }
[16:20:32.908]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:32.908]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:32.908]             base::sink(type = "output", split = FALSE)
[16:20:32.908]             base::close(...future.stdout)
[16:20:32.908]         }, add = TRUE)
[16:20:32.908]     }
[16:20:32.908]     ...future.frame <- base::sys.nframe()
[16:20:32.908]     ...future.conditions <- base::list()
[16:20:32.908]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:32.908]     if (FALSE) {
[16:20:32.908]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:32.908]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:32.908]     }
[16:20:32.908]     ...future.result <- base::tryCatch({
[16:20:32.908]         base::withCallingHandlers({
[16:20:32.908]             ...future.value <- base::withVisible(base::local({
[16:20:32.908]                 x <- a
[16:20:32.908]             }))
[16:20:32.908]             future::FutureResult(value = ...future.value$value, 
[16:20:32.908]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:32.908]                   ...future.rng), globalenv = if (FALSE) 
[16:20:32.908]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:32.908]                     ...future.globalenv.names))
[16:20:32.908]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:32.908]         }, condition = base::local({
[16:20:32.908]             c <- base::c
[16:20:32.908]             inherits <- base::inherits
[16:20:32.908]             invokeRestart <- base::invokeRestart
[16:20:32.908]             length <- base::length
[16:20:32.908]             list <- base::list
[16:20:32.908]             seq.int <- base::seq.int
[16:20:32.908]             signalCondition <- base::signalCondition
[16:20:32.908]             sys.calls <- base::sys.calls
[16:20:32.908]             `[[` <- base::`[[`
[16:20:32.908]             `+` <- base::`+`
[16:20:32.908]             `<<-` <- base::`<<-`
[16:20:32.908]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:32.908]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:32.908]                   3L)]
[16:20:32.908]             }
[16:20:32.908]             function(cond) {
[16:20:32.908]                 is_error <- inherits(cond, "error")
[16:20:32.908]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:32.908]                   NULL)
[16:20:32.908]                 if (is_error) {
[16:20:32.908]                   sessionInformation <- function() {
[16:20:32.908]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:32.908]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:32.908]                       search = base::search(), system = base::Sys.info())
[16:20:32.908]                   }
[16:20:32.908]                   ...future.conditions[[length(...future.conditions) + 
[16:20:32.908]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:32.908]                     cond$call), session = sessionInformation(), 
[16:20:32.908]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:32.908]                   signalCondition(cond)
[16:20:32.908]                 }
[16:20:32.908]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:32.908]                 "immediateCondition"))) {
[16:20:32.908]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:32.908]                   ...future.conditions[[length(...future.conditions) + 
[16:20:32.908]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:32.908]                   if (TRUE && !signal) {
[16:20:32.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:32.908]                     {
[16:20:32.908]                       inherits <- base::inherits
[16:20:32.908]                       invokeRestart <- base::invokeRestart
[16:20:32.908]                       is.null <- base::is.null
[16:20:32.908]                       muffled <- FALSE
[16:20:32.908]                       if (inherits(cond, "message")) {
[16:20:32.908]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:32.908]                         if (muffled) 
[16:20:32.908]                           invokeRestart("muffleMessage")
[16:20:32.908]                       }
[16:20:32.908]                       else if (inherits(cond, "warning")) {
[16:20:32.908]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:32.908]                         if (muffled) 
[16:20:32.908]                           invokeRestart("muffleWarning")
[16:20:32.908]                       }
[16:20:32.908]                       else if (inherits(cond, "condition")) {
[16:20:32.908]                         if (!is.null(pattern)) {
[16:20:32.908]                           computeRestarts <- base::computeRestarts
[16:20:32.908]                           grepl <- base::grepl
[16:20:32.908]                           restarts <- computeRestarts(cond)
[16:20:32.908]                           for (restart in restarts) {
[16:20:32.908]                             name <- restart$name
[16:20:32.908]                             if (is.null(name)) 
[16:20:32.908]                               next
[16:20:32.908]                             if (!grepl(pattern, name)) 
[16:20:32.908]                               next
[16:20:32.908]                             invokeRestart(restart)
[16:20:32.908]                             muffled <- TRUE
[16:20:32.908]                             break
[16:20:32.908]                           }
[16:20:32.908]                         }
[16:20:32.908]                       }
[16:20:32.908]                       invisible(muffled)
[16:20:32.908]                     }
[16:20:32.908]                     muffleCondition(cond, pattern = "^muffle")
[16:20:32.908]                   }
[16:20:32.908]                 }
[16:20:32.908]                 else {
[16:20:32.908]                   if (TRUE) {
[16:20:32.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:32.908]                     {
[16:20:32.908]                       inherits <- base::inherits
[16:20:32.908]                       invokeRestart <- base::invokeRestart
[16:20:32.908]                       is.null <- base::is.null
[16:20:32.908]                       muffled <- FALSE
[16:20:32.908]                       if (inherits(cond, "message")) {
[16:20:32.908]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:32.908]                         if (muffled) 
[16:20:32.908]                           invokeRestart("muffleMessage")
[16:20:32.908]                       }
[16:20:32.908]                       else if (inherits(cond, "warning")) {
[16:20:32.908]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:32.908]                         if (muffled) 
[16:20:32.908]                           invokeRestart("muffleWarning")
[16:20:32.908]                       }
[16:20:32.908]                       else if (inherits(cond, "condition")) {
[16:20:32.908]                         if (!is.null(pattern)) {
[16:20:32.908]                           computeRestarts <- base::computeRestarts
[16:20:32.908]                           grepl <- base::grepl
[16:20:32.908]                           restarts <- computeRestarts(cond)
[16:20:32.908]                           for (restart in restarts) {
[16:20:32.908]                             name <- restart$name
[16:20:32.908]                             if (is.null(name)) 
[16:20:32.908]                               next
[16:20:32.908]                             if (!grepl(pattern, name)) 
[16:20:32.908]                               next
[16:20:32.908]                             invokeRestart(restart)
[16:20:32.908]                             muffled <- TRUE
[16:20:32.908]                             break
[16:20:32.908]                           }
[16:20:32.908]                         }
[16:20:32.908]                       }
[16:20:32.908]                       invisible(muffled)
[16:20:32.908]                     }
[16:20:32.908]                     muffleCondition(cond, pattern = "^muffle")
[16:20:32.908]                   }
[16:20:32.908]                 }
[16:20:32.908]             }
[16:20:32.908]         }))
[16:20:32.908]     }, error = function(ex) {
[16:20:32.908]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:32.908]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:32.908]                 ...future.rng), started = ...future.startTime, 
[16:20:32.908]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:32.908]             version = "1.8"), class = "FutureResult")
[16:20:32.908]     }, finally = {
[16:20:32.908]         if (!identical(...future.workdir, getwd())) 
[16:20:32.908]             setwd(...future.workdir)
[16:20:32.908]         {
[16:20:32.908]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:32.908]                 ...future.oldOptions$nwarnings <- NULL
[16:20:32.908]             }
[16:20:32.908]             base::options(...future.oldOptions)
[16:20:32.908]             if (.Platform$OS.type == "windows") {
[16:20:32.908]                 old_names <- names(...future.oldEnvVars)
[16:20:32.908]                 envs <- base::Sys.getenv()
[16:20:32.908]                 names <- names(envs)
[16:20:32.908]                 common <- intersect(names, old_names)
[16:20:32.908]                 added <- setdiff(names, old_names)
[16:20:32.908]                 removed <- setdiff(old_names, names)
[16:20:32.908]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:32.908]                   envs[common]]
[16:20:32.908]                 NAMES <- toupper(changed)
[16:20:32.908]                 args <- list()
[16:20:32.908]                 for (kk in seq_along(NAMES)) {
[16:20:32.908]                   name <- changed[[kk]]
[16:20:32.908]                   NAME <- NAMES[[kk]]
[16:20:32.908]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:32.908]                     next
[16:20:32.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:32.908]                 }
[16:20:32.908]                 NAMES <- toupper(added)
[16:20:32.908]                 for (kk in seq_along(NAMES)) {
[16:20:32.908]                   name <- added[[kk]]
[16:20:32.908]                   NAME <- NAMES[[kk]]
[16:20:32.908]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:32.908]                     next
[16:20:32.908]                   args[[name]] <- ""
[16:20:32.908]                 }
[16:20:32.908]                 NAMES <- toupper(removed)
[16:20:32.908]                 for (kk in seq_along(NAMES)) {
[16:20:32.908]                   name <- removed[[kk]]
[16:20:32.908]                   NAME <- NAMES[[kk]]
[16:20:32.908]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:32.908]                     next
[16:20:32.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:32.908]                 }
[16:20:32.908]                 if (length(args) > 0) 
[16:20:32.908]                   base::do.call(base::Sys.setenv, args = args)
[16:20:32.908]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:32.908]             }
[16:20:32.908]             else {
[16:20:32.908]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:32.908]             }
[16:20:32.908]             {
[16:20:32.908]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:32.908]                   0L) {
[16:20:32.908]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:32.908]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:32.908]                   base::options(opts)
[16:20:32.908]                 }
[16:20:32.908]                 {
[16:20:32.908]                   {
[16:20:32.908]                     NULL
[16:20:32.908]                     RNGkind("Mersenne-Twister")
[16:20:32.908]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:32.908]                       inherits = FALSE)
[16:20:32.908]                   }
[16:20:32.908]                   options(future.plan = NULL)
[16:20:32.908]                   if (is.na(NA_character_)) 
[16:20:32.908]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:32.908]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:32.908]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:32.908]                     .init = FALSE)
[16:20:32.908]                 }
[16:20:32.908]             }
[16:20:32.908]         }
[16:20:32.908]     })
[16:20:32.908]     if (TRUE) {
[16:20:32.908]         base::sink(type = "output", split = FALSE)
[16:20:32.908]         if (TRUE) {
[16:20:32.908]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:32.908]         }
[16:20:32.908]         else {
[16:20:32.908]             ...future.result["stdout"] <- base::list(NULL)
[16:20:32.908]         }
[16:20:32.908]         base::close(...future.stdout)
[16:20:32.908]         ...future.stdout <- NULL
[16:20:32.908]     }
[16:20:32.908]     ...future.result$conditions <- ...future.conditions
[16:20:32.908]     ...future.result$finished <- base::Sys.time()
[16:20:32.908]     ...future.result
[16:20:32.908] }
[16:20:32.910] assign_globals() ...
[16:20:32.910] List of 1
[16:20:32.910]  $ a: num 2
[16:20:32.910]  - attr(*, "where")=List of 1
[16:20:32.910]   ..$ a:<environment: R_EmptyEnv> 
[16:20:32.910]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:32.910]  - attr(*, "resolved")= logi FALSE
[16:20:32.910]  - attr(*, "total_size")= num 56
[16:20:32.910]  - attr(*, "already-done")= logi TRUE
[16:20:32.918] - copied ‘a’ to environment
[16:20:32.918] assign_globals() ... done
[16:20:32.918] plan(): Setting new future strategy stack:
[16:20:32.918] List of future strategies:
[16:20:32.918] 1. sequential:
[16:20:32.918]    - args: function (..., envir = parent.frame())
[16:20:32.918]    - tweaked: FALSE
[16:20:32.918]    - call: NULL
[16:20:32.919] plan(): nbrOfWorkers() = 1
[16:20:32.919] plan(): Setting new future strategy stack:
[16:20:32.919] List of future strategies:
[16:20:32.919] 1. sequential:
[16:20:32.919]    - args: function (..., envir = parent.frame())
[16:20:32.919]    - tweaked: FALSE
[16:20:32.919]    - call: plan(strategy)
[16:20:32.920] plan(): nbrOfWorkers() = 1
[16:20:32.920] SequentialFuture started (and completed)
[16:20:32.920] - Launch lazy future ... done
[16:20:32.920] run() for ‘SequentialFuture’ ... done
** Future evaluation with errors
[16:20:32.921] getGlobalsAndPackages() ...
[16:20:32.921] Searching for globals...
[16:20:32.924] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[16:20:32.924] Searching for globals ... DONE
[16:20:32.924] Resolving globals: FALSE
[16:20:32.925] 
[16:20:32.925] 
[16:20:32.925] getGlobalsAndPackages() ... DONE
[16:20:32.925] run() for ‘Future’ ...
[16:20:32.925] - state: ‘created’
[16:20:32.925] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:32.926] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:32.926] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:32.926]   - Field: ‘label’
[16:20:32.926]   - Field: ‘local’
[16:20:32.926]   - Field: ‘owner’
[16:20:32.926]   - Field: ‘envir’
[16:20:32.926]   - Field: ‘packages’
[16:20:32.926]   - Field: ‘gc’
[16:20:32.926]   - Field: ‘conditions’
[16:20:32.926]   - Field: ‘expr’
[16:20:32.927]   - Field: ‘uuid’
[16:20:32.927]   - Field: ‘seed’
[16:20:32.927]   - Field: ‘version’
[16:20:32.927]   - Field: ‘result’
[16:20:32.927]   - Field: ‘asynchronous’
[16:20:32.927]   - Field: ‘calls’
[16:20:32.927]   - Field: ‘globals’
[16:20:32.927]   - Field: ‘stdout’
[16:20:32.927]   - Field: ‘earlySignal’
[16:20:32.927]   - Field: ‘lazy’
[16:20:32.927]   - Field: ‘state’
[16:20:32.928] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:32.928] - Launch lazy future ...
[16:20:32.928] Packages needed by the future expression (n = 0): <none>
[16:20:32.928] Packages needed by future strategies (n = 0): <none>
[16:20:32.928] {
[16:20:32.928]     {
[16:20:32.928]         {
[16:20:32.928]             ...future.startTime <- base::Sys.time()
[16:20:32.928]             {
[16:20:32.928]                 {
[16:20:32.928]                   {
[16:20:32.928]                     base::local({
[16:20:32.928]                       has_future <- base::requireNamespace("future", 
[16:20:32.928]                         quietly = TRUE)
[16:20:32.928]                       if (has_future) {
[16:20:32.928]                         ns <- base::getNamespace("future")
[16:20:32.928]                         version <- ns[[".package"]][["version"]]
[16:20:32.928]                         if (is.null(version)) 
[16:20:32.928]                           version <- utils::packageVersion("future")
[16:20:32.928]                       }
[16:20:32.928]                       else {
[16:20:32.928]                         version <- NULL
[16:20:32.928]                       }
[16:20:32.928]                       if (!has_future || version < "1.8.0") {
[16:20:32.928]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:32.928]                           "", base::R.version$version.string), 
[16:20:32.928]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:32.928]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:32.928]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:32.928]                             "release", "version")], collapse = " "), 
[16:20:32.928]                           hostname = base::Sys.info()[["nodename"]])
[16:20:32.928]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:32.928]                           info)
[16:20:32.928]                         info <- base::paste(info, collapse = "; ")
[16:20:32.928]                         if (!has_future) {
[16:20:32.928]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:32.928]                             info)
[16:20:32.928]                         }
[16:20:32.928]                         else {
[16:20:32.928]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:32.928]                             info, version)
[16:20:32.928]                         }
[16:20:32.928]                         base::stop(msg)
[16:20:32.928]                       }
[16:20:32.928]                     })
[16:20:32.928]                   }
[16:20:32.928]                   ...future.strategy.old <- future::plan("list")
[16:20:32.928]                   options(future.plan = NULL)
[16:20:32.928]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:32.928]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:32.928]                 }
[16:20:32.928]                 ...future.workdir <- getwd()
[16:20:32.928]             }
[16:20:32.928]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:32.928]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:32.928]         }
[16:20:32.928]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:32.928]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:32.928]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:32.928]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:32.928]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:32.928]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:32.928]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:32.928]             base::names(...future.oldOptions))
[16:20:32.928]     }
[16:20:32.928]     if (FALSE) {
[16:20:32.928]     }
[16:20:32.928]     else {
[16:20:32.928]         if (TRUE) {
[16:20:32.928]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:32.928]                 open = "w")
[16:20:32.928]         }
[16:20:32.928]         else {
[16:20:32.928]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:32.928]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:32.928]         }
[16:20:32.928]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:32.928]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:32.928]             base::sink(type = "output", split = FALSE)
[16:20:32.928]             base::close(...future.stdout)
[16:20:32.928]         }, add = TRUE)
[16:20:32.928]     }
[16:20:32.928]     ...future.frame <- base::sys.nframe()
[16:20:32.928]     ...future.conditions <- base::list()
[16:20:32.928]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:32.928]     if (FALSE) {
[16:20:32.928]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:32.928]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:32.928]     }
[16:20:32.928]     ...future.result <- base::tryCatch({
[16:20:32.928]         base::withCallingHandlers({
[16:20:32.928]             ...future.value <- base::withVisible(base::local({
[16:20:32.928]                 x <- 3
[16:20:32.928]                 stop("Woops!")
[16:20:32.928]                 x
[16:20:32.928]             }))
[16:20:32.928]             future::FutureResult(value = ...future.value$value, 
[16:20:32.928]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:32.928]                   ...future.rng), globalenv = if (FALSE) 
[16:20:32.928]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:32.928]                     ...future.globalenv.names))
[16:20:32.928]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:32.928]         }, condition = base::local({
[16:20:32.928]             c <- base::c
[16:20:32.928]             inherits <- base::inherits
[16:20:32.928]             invokeRestart <- base::invokeRestart
[16:20:32.928]             length <- base::length
[16:20:32.928]             list <- base::list
[16:20:32.928]             seq.int <- base::seq.int
[16:20:32.928]             signalCondition <- base::signalCondition
[16:20:32.928]             sys.calls <- base::sys.calls
[16:20:32.928]             `[[` <- base::`[[`
[16:20:32.928]             `+` <- base::`+`
[16:20:32.928]             `<<-` <- base::`<<-`
[16:20:32.928]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:32.928]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:32.928]                   3L)]
[16:20:32.928]             }
[16:20:32.928]             function(cond) {
[16:20:32.928]                 is_error <- inherits(cond, "error")
[16:20:32.928]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:32.928]                   NULL)
[16:20:32.928]                 if (is_error) {
[16:20:32.928]                   sessionInformation <- function() {
[16:20:32.928]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:32.928]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:32.928]                       search = base::search(), system = base::Sys.info())
[16:20:32.928]                   }
[16:20:32.928]                   ...future.conditions[[length(...future.conditions) + 
[16:20:32.928]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:32.928]                     cond$call), session = sessionInformation(), 
[16:20:32.928]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:32.928]                   signalCondition(cond)
[16:20:32.928]                 }
[16:20:32.928]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:32.928]                 "immediateCondition"))) {
[16:20:32.928]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:32.928]                   ...future.conditions[[length(...future.conditions) + 
[16:20:32.928]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:32.928]                   if (TRUE && !signal) {
[16:20:32.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:32.928]                     {
[16:20:32.928]                       inherits <- base::inherits
[16:20:32.928]                       invokeRestart <- base::invokeRestart
[16:20:32.928]                       is.null <- base::is.null
[16:20:32.928]                       muffled <- FALSE
[16:20:32.928]                       if (inherits(cond, "message")) {
[16:20:32.928]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:32.928]                         if (muffled) 
[16:20:32.928]                           invokeRestart("muffleMessage")
[16:20:32.928]                       }
[16:20:32.928]                       else if (inherits(cond, "warning")) {
[16:20:32.928]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:32.928]                         if (muffled) 
[16:20:32.928]                           invokeRestart("muffleWarning")
[16:20:32.928]                       }
[16:20:32.928]                       else if (inherits(cond, "condition")) {
[16:20:32.928]                         if (!is.null(pattern)) {
[16:20:32.928]                           computeRestarts <- base::computeRestarts
[16:20:32.928]                           grepl <- base::grepl
[16:20:32.928]                           restarts <- computeRestarts(cond)
[16:20:32.928]                           for (restart in restarts) {
[16:20:32.928]                             name <- restart$name
[16:20:32.928]                             if (is.null(name)) 
[16:20:32.928]                               next
[16:20:32.928]                             if (!grepl(pattern, name)) 
[16:20:32.928]                               next
[16:20:32.928]                             invokeRestart(restart)
[16:20:32.928]                             muffled <- TRUE
[16:20:32.928]                             break
[16:20:32.928]                           }
[16:20:32.928]                         }
[16:20:32.928]                       }
[16:20:32.928]                       invisible(muffled)
[16:20:32.928]                     }
[16:20:32.928]                     muffleCondition(cond, pattern = "^muffle")
[16:20:32.928]                   }
[16:20:32.928]                 }
[16:20:32.928]                 else {
[16:20:32.928]                   if (TRUE) {
[16:20:32.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:32.928]                     {
[16:20:32.928]                       inherits <- base::inherits
[16:20:32.928]                       invokeRestart <- base::invokeRestart
[16:20:32.928]                       is.null <- base::is.null
[16:20:32.928]                       muffled <- FALSE
[16:20:32.928]                       if (inherits(cond, "message")) {
[16:20:32.928]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:32.928]                         if (muffled) 
[16:20:32.928]                           invokeRestart("muffleMessage")
[16:20:32.928]                       }
[16:20:32.928]                       else if (inherits(cond, "warning")) {
[16:20:32.928]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:32.928]                         if (muffled) 
[16:20:32.928]                           invokeRestart("muffleWarning")
[16:20:32.928]                       }
[16:20:32.928]                       else if (inherits(cond, "condition")) {
[16:20:32.928]                         if (!is.null(pattern)) {
[16:20:32.928]                           computeRestarts <- base::computeRestarts
[16:20:32.928]                           grepl <- base::grepl
[16:20:32.928]                           restarts <- computeRestarts(cond)
[16:20:32.928]                           for (restart in restarts) {
[16:20:32.928]                             name <- restart$name
[16:20:32.928]                             if (is.null(name)) 
[16:20:32.928]                               next
[16:20:32.928]                             if (!grepl(pattern, name)) 
[16:20:32.928]                               next
[16:20:32.928]                             invokeRestart(restart)
[16:20:32.928]                             muffled <- TRUE
[16:20:32.928]                             break
[16:20:32.928]                           }
[16:20:32.928]                         }
[16:20:32.928]                       }
[16:20:32.928]                       invisible(muffled)
[16:20:32.928]                     }
[16:20:32.928]                     muffleCondition(cond, pattern = "^muffle")
[16:20:32.928]                   }
[16:20:32.928]                 }
[16:20:32.928]             }
[16:20:32.928]         }))
[16:20:32.928]     }, error = function(ex) {
[16:20:32.928]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:32.928]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:32.928]                 ...future.rng), started = ...future.startTime, 
[16:20:32.928]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:32.928]             version = "1.8"), class = "FutureResult")
[16:20:32.928]     }, finally = {
[16:20:32.928]         if (!identical(...future.workdir, getwd())) 
[16:20:32.928]             setwd(...future.workdir)
[16:20:32.928]         {
[16:20:32.928]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:32.928]                 ...future.oldOptions$nwarnings <- NULL
[16:20:32.928]             }
[16:20:32.928]             base::options(...future.oldOptions)
[16:20:32.928]             if (.Platform$OS.type == "windows") {
[16:20:32.928]                 old_names <- names(...future.oldEnvVars)
[16:20:32.928]                 envs <- base::Sys.getenv()
[16:20:32.928]                 names <- names(envs)
[16:20:32.928]                 common <- intersect(names, old_names)
[16:20:32.928]                 added <- setdiff(names, old_names)
[16:20:32.928]                 removed <- setdiff(old_names, names)
[16:20:32.928]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:32.928]                   envs[common]]
[16:20:32.928]                 NAMES <- toupper(changed)
[16:20:32.928]                 args <- list()
[16:20:32.928]                 for (kk in seq_along(NAMES)) {
[16:20:32.928]                   name <- changed[[kk]]
[16:20:32.928]                   NAME <- NAMES[[kk]]
[16:20:32.928]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:32.928]                     next
[16:20:32.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:32.928]                 }
[16:20:32.928]                 NAMES <- toupper(added)
[16:20:32.928]                 for (kk in seq_along(NAMES)) {
[16:20:32.928]                   name <- added[[kk]]
[16:20:32.928]                   NAME <- NAMES[[kk]]
[16:20:32.928]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:32.928]                     next
[16:20:32.928]                   args[[name]] <- ""
[16:20:32.928]                 }
[16:20:32.928]                 NAMES <- toupper(removed)
[16:20:32.928]                 for (kk in seq_along(NAMES)) {
[16:20:32.928]                   name <- removed[[kk]]
[16:20:32.928]                   NAME <- NAMES[[kk]]
[16:20:32.928]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:32.928]                     next
[16:20:32.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:32.928]                 }
[16:20:32.928]                 if (length(args) > 0) 
[16:20:32.928]                   base::do.call(base::Sys.setenv, args = args)
[16:20:32.928]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:32.928]             }
[16:20:32.928]             else {
[16:20:32.928]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:32.928]             }
[16:20:32.928]             {
[16:20:32.928]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:32.928]                   0L) {
[16:20:32.928]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:32.928]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:32.928]                   base::options(opts)
[16:20:32.928]                 }
[16:20:32.928]                 {
[16:20:32.928]                   {
[16:20:32.928]                     NULL
[16:20:32.928]                     RNGkind("Mersenne-Twister")
[16:20:32.928]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:32.928]                       inherits = FALSE)
[16:20:32.928]                   }
[16:20:32.928]                   options(future.plan = NULL)
[16:20:32.928]                   if (is.na(NA_character_)) 
[16:20:32.928]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:32.928]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:32.928]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:32.928]                     .init = FALSE)
[16:20:32.928]                 }
[16:20:32.928]             }
[16:20:32.928]         }
[16:20:32.928]     })
[16:20:32.928]     if (TRUE) {
[16:20:32.928]         base::sink(type = "output", split = FALSE)
[16:20:32.928]         if (TRUE) {
[16:20:32.928]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:32.928]         }
[16:20:32.928]         else {
[16:20:32.928]             ...future.result["stdout"] <- base::list(NULL)
[16:20:32.928]         }
[16:20:32.928]         base::close(...future.stdout)
[16:20:32.928]         ...future.stdout <- NULL
[16:20:32.928]     }
[16:20:32.928]     ...future.result$conditions <- ...future.conditions
[16:20:32.928]     ...future.result$finished <- base::Sys.time()
[16:20:32.928]     ...future.result
[16:20:32.928] }
[16:20:32.930] plan(): Setting new future strategy stack:
[16:20:32.930] List of future strategies:
[16:20:32.930] 1. sequential:
[16:20:32.930]    - args: function (..., envir = parent.frame())
[16:20:32.930]    - tweaked: FALSE
[16:20:32.930]    - call: NULL
[16:20:32.931] plan(): nbrOfWorkers() = 1
[16:20:32.932] plan(): Setting new future strategy stack:
[16:20:32.932] List of future strategies:
[16:20:32.932] 1. sequential:
[16:20:32.932]    - args: function (..., envir = parent.frame())
[16:20:32.932]    - tweaked: FALSE
[16:20:32.932]    - call: plan(strategy)
[16:20:32.932] plan(): nbrOfWorkers() = 1
[16:20:32.932] SequentialFuture started (and completed)
[16:20:32.932] signalConditions() ...
[16:20:32.932]  - include = ‘immediateCondition’
[16:20:32.932]  - exclude = 
[16:20:32.933]  - resignal = FALSE
[16:20:32.933]  - Number of conditions: 1
[16:20:32.933] signalConditions() ... done
[16:20:32.933] - Launch lazy future ... done
[16:20:32.933] run() for ‘SequentialFuture’ ... done
[16:20:32.933] signalConditions() ...
[16:20:32.933]  - include = ‘immediateCondition’
[16:20:32.933]  - exclude = 
[16:20:32.933]  - resignal = FALSE
[16:20:32.933]  - Number of conditions: 1
[16:20:32.934] signalConditions() ... done
[16:20:32.934] Future state: ‘finished’
[16:20:32.934] signalConditions() ...
[16:20:32.934]  - include = ‘condition’
[16:20:32.934]  - exclude = ‘immediateCondition’
[16:20:32.934]  - resignal = TRUE
[16:20:32.934]  - Number of conditions: 1
[16:20:32.934]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:20:32.934] signalConditions() ... done
[16:20:32.935] getGlobalsAndPackages() ...
[16:20:32.935] Searching for globals...
[16:20:32.937] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[16:20:32.937] Searching for globals ... DONE
[16:20:32.937] Resolving globals: FALSE
[16:20:32.938] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:32.938] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:20:32.938] - globals: [1] ‘ii’
[16:20:32.938] 
[16:20:32.938] getGlobalsAndPackages() ... DONE
[16:20:32.939] run() for ‘Future’ ...
[16:20:32.939] - state: ‘created’
[16:20:32.939] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:32.939] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:32.939] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:32.939]   - Field: ‘label’
[16:20:32.939]   - Field: ‘local’
[16:20:32.940]   - Field: ‘owner’
[16:20:32.940]   - Field: ‘envir’
[16:20:32.940]   - Field: ‘packages’
[16:20:32.940]   - Field: ‘gc’
[16:20:32.940]   - Field: ‘conditions’
[16:20:32.940]   - Field: ‘expr’
[16:20:32.940]   - Field: ‘uuid’
[16:20:32.940]   - Field: ‘seed’
[16:20:32.940]   - Field: ‘version’
[16:20:32.940]   - Field: ‘result’
[16:20:32.941]   - Field: ‘asynchronous’
[16:20:32.941]   - Field: ‘calls’
[16:20:32.941]   - Field: ‘globals’
[16:20:32.941]   - Field: ‘stdout’
[16:20:32.941]   - Field: ‘earlySignal’
[16:20:32.941]   - Field: ‘lazy’
[16:20:32.941]   - Field: ‘state’
[16:20:32.941] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:32.941] - Launch lazy future ...
[16:20:32.941] Packages needed by the future expression (n = 0): <none>
[16:20:32.942] Packages needed by future strategies (n = 0): <none>
[16:20:32.942] {
[16:20:32.942]     {
[16:20:32.942]         {
[16:20:32.942]             ...future.startTime <- base::Sys.time()
[16:20:32.942]             {
[16:20:32.942]                 {
[16:20:32.942]                   {
[16:20:32.942]                     base::local({
[16:20:32.942]                       has_future <- base::requireNamespace("future", 
[16:20:32.942]                         quietly = TRUE)
[16:20:32.942]                       if (has_future) {
[16:20:32.942]                         ns <- base::getNamespace("future")
[16:20:32.942]                         version <- ns[[".package"]][["version"]]
[16:20:32.942]                         if (is.null(version)) 
[16:20:32.942]                           version <- utils::packageVersion("future")
[16:20:32.942]                       }
[16:20:32.942]                       else {
[16:20:32.942]                         version <- NULL
[16:20:32.942]                       }
[16:20:32.942]                       if (!has_future || version < "1.8.0") {
[16:20:32.942]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:32.942]                           "", base::R.version$version.string), 
[16:20:32.942]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:32.942]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:32.942]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:32.942]                             "release", "version")], collapse = " "), 
[16:20:32.942]                           hostname = base::Sys.info()[["nodename"]])
[16:20:32.942]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:32.942]                           info)
[16:20:32.942]                         info <- base::paste(info, collapse = "; ")
[16:20:32.942]                         if (!has_future) {
[16:20:32.942]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:32.942]                             info)
[16:20:32.942]                         }
[16:20:32.942]                         else {
[16:20:32.942]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:32.942]                             info, version)
[16:20:32.942]                         }
[16:20:32.942]                         base::stop(msg)
[16:20:32.942]                       }
[16:20:32.942]                     })
[16:20:32.942]                   }
[16:20:32.942]                   ...future.strategy.old <- future::plan("list")
[16:20:32.942]                   options(future.plan = NULL)
[16:20:32.942]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:32.942]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:32.942]                 }
[16:20:32.942]                 ...future.workdir <- getwd()
[16:20:32.942]             }
[16:20:32.942]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:32.942]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:32.942]         }
[16:20:32.942]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:32.942]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:32.942]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:32.942]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:32.942]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:32.942]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:32.942]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:32.942]             base::names(...future.oldOptions))
[16:20:32.942]     }
[16:20:32.942]     if (FALSE) {
[16:20:32.942]     }
[16:20:32.942]     else {
[16:20:32.942]         if (TRUE) {
[16:20:32.942]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:32.942]                 open = "w")
[16:20:32.942]         }
[16:20:32.942]         else {
[16:20:32.942]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:32.942]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:32.942]         }
[16:20:32.942]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:32.942]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:32.942]             base::sink(type = "output", split = FALSE)
[16:20:32.942]             base::close(...future.stdout)
[16:20:32.942]         }, add = TRUE)
[16:20:32.942]     }
[16:20:32.942]     ...future.frame <- base::sys.nframe()
[16:20:32.942]     ...future.conditions <- base::list()
[16:20:32.942]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:32.942]     if (FALSE) {
[16:20:32.942]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:32.942]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:32.942]     }
[16:20:32.942]     ...future.result <- base::tryCatch({
[16:20:32.942]         base::withCallingHandlers({
[16:20:32.942]             ...future.value <- base::withVisible(base::local({
[16:20:32.942]                 if (ii%%2 == 0) 
[16:20:32.942]                   stop("Woops!")
[16:20:32.942]                 ii
[16:20:32.942]             }))
[16:20:32.942]             future::FutureResult(value = ...future.value$value, 
[16:20:32.942]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:32.942]                   ...future.rng), globalenv = if (FALSE) 
[16:20:32.942]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:32.942]                     ...future.globalenv.names))
[16:20:32.942]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:32.942]         }, condition = base::local({
[16:20:32.942]             c <- base::c
[16:20:32.942]             inherits <- base::inherits
[16:20:32.942]             invokeRestart <- base::invokeRestart
[16:20:32.942]             length <- base::length
[16:20:32.942]             list <- base::list
[16:20:32.942]             seq.int <- base::seq.int
[16:20:32.942]             signalCondition <- base::signalCondition
[16:20:32.942]             sys.calls <- base::sys.calls
[16:20:32.942]             `[[` <- base::`[[`
[16:20:32.942]             `+` <- base::`+`
[16:20:32.942]             `<<-` <- base::`<<-`
[16:20:32.942]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:32.942]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:32.942]                   3L)]
[16:20:32.942]             }
[16:20:32.942]             function(cond) {
[16:20:32.942]                 is_error <- inherits(cond, "error")
[16:20:32.942]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:32.942]                   NULL)
[16:20:32.942]                 if (is_error) {
[16:20:32.942]                   sessionInformation <- function() {
[16:20:32.942]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:32.942]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:32.942]                       search = base::search(), system = base::Sys.info())
[16:20:32.942]                   }
[16:20:32.942]                   ...future.conditions[[length(...future.conditions) + 
[16:20:32.942]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:32.942]                     cond$call), session = sessionInformation(), 
[16:20:32.942]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:32.942]                   signalCondition(cond)
[16:20:32.942]                 }
[16:20:32.942]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:32.942]                 "immediateCondition"))) {
[16:20:32.942]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:32.942]                   ...future.conditions[[length(...future.conditions) + 
[16:20:32.942]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:32.942]                   if (TRUE && !signal) {
[16:20:32.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:32.942]                     {
[16:20:32.942]                       inherits <- base::inherits
[16:20:32.942]                       invokeRestart <- base::invokeRestart
[16:20:32.942]                       is.null <- base::is.null
[16:20:32.942]                       muffled <- FALSE
[16:20:32.942]                       if (inherits(cond, "message")) {
[16:20:32.942]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:32.942]                         if (muffled) 
[16:20:32.942]                           invokeRestart("muffleMessage")
[16:20:32.942]                       }
[16:20:32.942]                       else if (inherits(cond, "warning")) {
[16:20:32.942]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:32.942]                         if (muffled) 
[16:20:32.942]                           invokeRestart("muffleWarning")
[16:20:32.942]                       }
[16:20:32.942]                       else if (inherits(cond, "condition")) {
[16:20:32.942]                         if (!is.null(pattern)) {
[16:20:32.942]                           computeRestarts <- base::computeRestarts
[16:20:32.942]                           grepl <- base::grepl
[16:20:32.942]                           restarts <- computeRestarts(cond)
[16:20:32.942]                           for (restart in restarts) {
[16:20:32.942]                             name <- restart$name
[16:20:32.942]                             if (is.null(name)) 
[16:20:32.942]                               next
[16:20:32.942]                             if (!grepl(pattern, name)) 
[16:20:32.942]                               next
[16:20:32.942]                             invokeRestart(restart)
[16:20:32.942]                             muffled <- TRUE
[16:20:32.942]                             break
[16:20:32.942]                           }
[16:20:32.942]                         }
[16:20:32.942]                       }
[16:20:32.942]                       invisible(muffled)
[16:20:32.942]                     }
[16:20:32.942]                     muffleCondition(cond, pattern = "^muffle")
[16:20:32.942]                   }
[16:20:32.942]                 }
[16:20:32.942]                 else {
[16:20:32.942]                   if (TRUE) {
[16:20:32.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:32.942]                     {
[16:20:32.942]                       inherits <- base::inherits
[16:20:32.942]                       invokeRestart <- base::invokeRestart
[16:20:32.942]                       is.null <- base::is.null
[16:20:32.942]                       muffled <- FALSE
[16:20:32.942]                       if (inherits(cond, "message")) {
[16:20:32.942]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:32.942]                         if (muffled) 
[16:20:32.942]                           invokeRestart("muffleMessage")
[16:20:32.942]                       }
[16:20:32.942]                       else if (inherits(cond, "warning")) {
[16:20:32.942]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:32.942]                         if (muffled) 
[16:20:32.942]                           invokeRestart("muffleWarning")
[16:20:32.942]                       }
[16:20:32.942]                       else if (inherits(cond, "condition")) {
[16:20:32.942]                         if (!is.null(pattern)) {
[16:20:32.942]                           computeRestarts <- base::computeRestarts
[16:20:32.942]                           grepl <- base::grepl
[16:20:32.942]                           restarts <- computeRestarts(cond)
[16:20:32.942]                           for (restart in restarts) {
[16:20:32.942]                             name <- restart$name
[16:20:32.942]                             if (is.null(name)) 
[16:20:32.942]                               next
[16:20:32.942]                             if (!grepl(pattern, name)) 
[16:20:32.942]                               next
[16:20:32.942]                             invokeRestart(restart)
[16:20:32.942]                             muffled <- TRUE
[16:20:32.942]                             break
[16:20:32.942]                           }
[16:20:32.942]                         }
[16:20:32.942]                       }
[16:20:32.942]                       invisible(muffled)
[16:20:32.942]                     }
[16:20:32.942]                     muffleCondition(cond, pattern = "^muffle")
[16:20:32.942]                   }
[16:20:32.942]                 }
[16:20:32.942]             }
[16:20:32.942]         }))
[16:20:32.942]     }, error = function(ex) {
[16:20:32.942]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:32.942]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:32.942]                 ...future.rng), started = ...future.startTime, 
[16:20:32.942]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:32.942]             version = "1.8"), class = "FutureResult")
[16:20:32.942]     }, finally = {
[16:20:32.942]         if (!identical(...future.workdir, getwd())) 
[16:20:32.942]             setwd(...future.workdir)
[16:20:32.942]         {
[16:20:32.942]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:32.942]                 ...future.oldOptions$nwarnings <- NULL
[16:20:32.942]             }
[16:20:32.942]             base::options(...future.oldOptions)
[16:20:32.942]             if (.Platform$OS.type == "windows") {
[16:20:32.942]                 old_names <- names(...future.oldEnvVars)
[16:20:32.942]                 envs <- base::Sys.getenv()
[16:20:32.942]                 names <- names(envs)
[16:20:32.942]                 common <- intersect(names, old_names)
[16:20:32.942]                 added <- setdiff(names, old_names)
[16:20:32.942]                 removed <- setdiff(old_names, names)
[16:20:32.942]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:32.942]                   envs[common]]
[16:20:32.942]                 NAMES <- toupper(changed)
[16:20:32.942]                 args <- list()
[16:20:32.942]                 for (kk in seq_along(NAMES)) {
[16:20:32.942]                   name <- changed[[kk]]
[16:20:32.942]                   NAME <- NAMES[[kk]]
[16:20:32.942]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:32.942]                     next
[16:20:32.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:32.942]                 }
[16:20:32.942]                 NAMES <- toupper(added)
[16:20:32.942]                 for (kk in seq_along(NAMES)) {
[16:20:32.942]                   name <- added[[kk]]
[16:20:32.942]                   NAME <- NAMES[[kk]]
[16:20:32.942]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:32.942]                     next
[16:20:32.942]                   args[[name]] <- ""
[16:20:32.942]                 }
[16:20:32.942]                 NAMES <- toupper(removed)
[16:20:32.942]                 for (kk in seq_along(NAMES)) {
[16:20:32.942]                   name <- removed[[kk]]
[16:20:32.942]                   NAME <- NAMES[[kk]]
[16:20:32.942]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:32.942]                     next
[16:20:32.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:32.942]                 }
[16:20:32.942]                 if (length(args) > 0) 
[16:20:32.942]                   base::do.call(base::Sys.setenv, args = args)
[16:20:32.942]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:32.942]             }
[16:20:32.942]             else {
[16:20:32.942]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:32.942]             }
[16:20:32.942]             {
[16:20:32.942]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:32.942]                   0L) {
[16:20:32.942]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:32.942]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:32.942]                   base::options(opts)
[16:20:32.942]                 }
[16:20:32.942]                 {
[16:20:32.942]                   {
[16:20:32.942]                     NULL
[16:20:32.942]                     RNGkind("Mersenne-Twister")
[16:20:32.942]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:32.942]                       inherits = FALSE)
[16:20:32.942]                   }
[16:20:32.942]                   options(future.plan = NULL)
[16:20:32.942]                   if (is.na(NA_character_)) 
[16:20:32.942]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:32.942]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:32.942]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:32.942]                     .init = FALSE)
[16:20:32.942]                 }
[16:20:32.942]             }
[16:20:32.942]         }
[16:20:32.942]     })
[16:20:32.942]     if (TRUE) {
[16:20:32.942]         base::sink(type = "output", split = FALSE)
[16:20:32.942]         if (TRUE) {
[16:20:32.942]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:32.942]         }
[16:20:32.942]         else {
[16:20:32.942]             ...future.result["stdout"] <- base::list(NULL)
[16:20:32.942]         }
[16:20:32.942]         base::close(...future.stdout)
[16:20:32.942]         ...future.stdout <- NULL
[16:20:32.942]     }
[16:20:32.942]     ...future.result$conditions <- ...future.conditions
[16:20:32.942]     ...future.result$finished <- base::Sys.time()
[16:20:32.942]     ...future.result
[16:20:32.942] }
[16:20:32.944] assign_globals() ...
[16:20:32.944] List of 1
[16:20:32.944]  $ ii: int 1
[16:20:32.944]  - attr(*, "where")=List of 1
[16:20:32.944]   ..$ ii:<environment: R_EmptyEnv> 
[16:20:32.944]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:32.944]  - attr(*, "resolved")= logi FALSE
[16:20:32.944]  - attr(*, "total_size")= num 56
[16:20:32.944]  - attr(*, "already-done")= logi TRUE
[16:20:32.948] - copied ‘ii’ to environment
[16:20:32.948] assign_globals() ... done
[16:20:32.948] plan(): Setting new future strategy stack:
[16:20:32.948] List of future strategies:
[16:20:32.948] 1. sequential:
[16:20:32.948]    - args: function (..., envir = parent.frame())
[16:20:32.948]    - tweaked: FALSE
[16:20:32.948]    - call: NULL
[16:20:32.948] plan(): nbrOfWorkers() = 1
[16:20:32.949] plan(): Setting new future strategy stack:
[16:20:32.949] List of future strategies:
[16:20:32.949] 1. sequential:
[16:20:32.949]    - args: function (..., envir = parent.frame())
[16:20:32.949]    - tweaked: FALSE
[16:20:32.949]    - call: plan(strategy)
[16:20:32.950] plan(): nbrOfWorkers() = 1
[16:20:32.950] SequentialFuture started (and completed)
[16:20:32.950] - Launch lazy future ... done
[16:20:32.950] run() for ‘SequentialFuture’ ... done
[16:20:32.950] getGlobalsAndPackages() ...
[16:20:32.951] Searching for globals...
[16:20:32.952] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[16:20:32.952] Searching for globals ... DONE
[16:20:32.952] Resolving globals: FALSE
[16:20:32.953] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:32.953] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:20:32.953] - globals: [1] ‘ii’
[16:20:32.953] 
[16:20:32.953] getGlobalsAndPackages() ... DONE
[16:20:32.953] run() for ‘Future’ ...
[16:20:32.954] - state: ‘created’
[16:20:32.954] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:32.954] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:32.954] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:32.954]   - Field: ‘label’
[16:20:32.954]   - Field: ‘local’
[16:20:32.954]   - Field: ‘owner’
[16:20:32.954]   - Field: ‘envir’
[16:20:32.955]   - Field: ‘packages’
[16:20:32.955]   - Field: ‘gc’
[16:20:32.955]   - Field: ‘conditions’
[16:20:32.955]   - Field: ‘expr’
[16:20:32.955]   - Field: ‘uuid’
[16:20:32.955]   - Field: ‘seed’
[16:20:32.955]   - Field: ‘version’
[16:20:32.955]   - Field: ‘result’
[16:20:32.955]   - Field: ‘asynchronous’
[16:20:32.955]   - Field: ‘calls’
[16:20:32.955]   - Field: ‘globals’
[16:20:32.956]   - Field: ‘stdout’
[16:20:32.956]   - Field: ‘earlySignal’
[16:20:32.956]   - Field: ‘lazy’
[16:20:32.956]   - Field: ‘state’
[16:20:32.956] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:32.956] - Launch lazy future ...
[16:20:32.956] Packages needed by the future expression (n = 0): <none>
[16:20:32.956] Packages needed by future strategies (n = 0): <none>
[16:20:32.957] {
[16:20:32.957]     {
[16:20:32.957]         {
[16:20:32.957]             ...future.startTime <- base::Sys.time()
[16:20:32.957]             {
[16:20:32.957]                 {
[16:20:32.957]                   {
[16:20:32.957]                     base::local({
[16:20:32.957]                       has_future <- base::requireNamespace("future", 
[16:20:32.957]                         quietly = TRUE)
[16:20:32.957]                       if (has_future) {
[16:20:32.957]                         ns <- base::getNamespace("future")
[16:20:32.957]                         version <- ns[[".package"]][["version"]]
[16:20:32.957]                         if (is.null(version)) 
[16:20:32.957]                           version <- utils::packageVersion("future")
[16:20:32.957]                       }
[16:20:32.957]                       else {
[16:20:32.957]                         version <- NULL
[16:20:32.957]                       }
[16:20:32.957]                       if (!has_future || version < "1.8.0") {
[16:20:32.957]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:32.957]                           "", base::R.version$version.string), 
[16:20:32.957]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:32.957]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:32.957]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:32.957]                             "release", "version")], collapse = " "), 
[16:20:32.957]                           hostname = base::Sys.info()[["nodename"]])
[16:20:32.957]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:32.957]                           info)
[16:20:32.957]                         info <- base::paste(info, collapse = "; ")
[16:20:32.957]                         if (!has_future) {
[16:20:32.957]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:32.957]                             info)
[16:20:32.957]                         }
[16:20:32.957]                         else {
[16:20:32.957]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:32.957]                             info, version)
[16:20:32.957]                         }
[16:20:32.957]                         base::stop(msg)
[16:20:32.957]                       }
[16:20:32.957]                     })
[16:20:32.957]                   }
[16:20:32.957]                   ...future.strategy.old <- future::plan("list")
[16:20:32.957]                   options(future.plan = NULL)
[16:20:32.957]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:32.957]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:32.957]                 }
[16:20:32.957]                 ...future.workdir <- getwd()
[16:20:32.957]             }
[16:20:32.957]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:32.957]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:32.957]         }
[16:20:32.957]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:32.957]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:32.957]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:32.957]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:32.957]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:32.957]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:32.957]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:32.957]             base::names(...future.oldOptions))
[16:20:32.957]     }
[16:20:32.957]     if (FALSE) {
[16:20:32.957]     }
[16:20:32.957]     else {
[16:20:32.957]         if (TRUE) {
[16:20:32.957]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:32.957]                 open = "w")
[16:20:32.957]         }
[16:20:32.957]         else {
[16:20:32.957]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:32.957]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:32.957]         }
[16:20:32.957]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:32.957]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:32.957]             base::sink(type = "output", split = FALSE)
[16:20:32.957]             base::close(...future.stdout)
[16:20:32.957]         }, add = TRUE)
[16:20:32.957]     }
[16:20:32.957]     ...future.frame <- base::sys.nframe()
[16:20:32.957]     ...future.conditions <- base::list()
[16:20:32.957]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:32.957]     if (FALSE) {
[16:20:32.957]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:32.957]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:32.957]     }
[16:20:32.957]     ...future.result <- base::tryCatch({
[16:20:32.957]         base::withCallingHandlers({
[16:20:32.957]             ...future.value <- base::withVisible(base::local({
[16:20:32.957]                 if (ii%%2 == 0) 
[16:20:32.957]                   stop("Woops!")
[16:20:32.957]                 ii
[16:20:32.957]             }))
[16:20:32.957]             future::FutureResult(value = ...future.value$value, 
[16:20:32.957]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:32.957]                   ...future.rng), globalenv = if (FALSE) 
[16:20:32.957]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:32.957]                     ...future.globalenv.names))
[16:20:32.957]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:32.957]         }, condition = base::local({
[16:20:32.957]             c <- base::c
[16:20:32.957]             inherits <- base::inherits
[16:20:32.957]             invokeRestart <- base::invokeRestart
[16:20:32.957]             length <- base::length
[16:20:32.957]             list <- base::list
[16:20:32.957]             seq.int <- base::seq.int
[16:20:32.957]             signalCondition <- base::signalCondition
[16:20:32.957]             sys.calls <- base::sys.calls
[16:20:32.957]             `[[` <- base::`[[`
[16:20:32.957]             `+` <- base::`+`
[16:20:32.957]             `<<-` <- base::`<<-`
[16:20:32.957]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:32.957]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:32.957]                   3L)]
[16:20:32.957]             }
[16:20:32.957]             function(cond) {
[16:20:32.957]                 is_error <- inherits(cond, "error")
[16:20:32.957]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:32.957]                   NULL)
[16:20:32.957]                 if (is_error) {
[16:20:32.957]                   sessionInformation <- function() {
[16:20:32.957]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:32.957]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:32.957]                       search = base::search(), system = base::Sys.info())
[16:20:32.957]                   }
[16:20:32.957]                   ...future.conditions[[length(...future.conditions) + 
[16:20:32.957]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:32.957]                     cond$call), session = sessionInformation(), 
[16:20:32.957]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:32.957]                   signalCondition(cond)
[16:20:32.957]                 }
[16:20:32.957]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:32.957]                 "immediateCondition"))) {
[16:20:32.957]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:32.957]                   ...future.conditions[[length(...future.conditions) + 
[16:20:32.957]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:32.957]                   if (TRUE && !signal) {
[16:20:32.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:32.957]                     {
[16:20:32.957]                       inherits <- base::inherits
[16:20:32.957]                       invokeRestart <- base::invokeRestart
[16:20:32.957]                       is.null <- base::is.null
[16:20:32.957]                       muffled <- FALSE
[16:20:32.957]                       if (inherits(cond, "message")) {
[16:20:32.957]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:32.957]                         if (muffled) 
[16:20:32.957]                           invokeRestart("muffleMessage")
[16:20:32.957]                       }
[16:20:32.957]                       else if (inherits(cond, "warning")) {
[16:20:32.957]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:32.957]                         if (muffled) 
[16:20:32.957]                           invokeRestart("muffleWarning")
[16:20:32.957]                       }
[16:20:32.957]                       else if (inherits(cond, "condition")) {
[16:20:32.957]                         if (!is.null(pattern)) {
[16:20:32.957]                           computeRestarts <- base::computeRestarts
[16:20:32.957]                           grepl <- base::grepl
[16:20:32.957]                           restarts <- computeRestarts(cond)
[16:20:32.957]                           for (restart in restarts) {
[16:20:32.957]                             name <- restart$name
[16:20:32.957]                             if (is.null(name)) 
[16:20:32.957]                               next
[16:20:32.957]                             if (!grepl(pattern, name)) 
[16:20:32.957]                               next
[16:20:32.957]                             invokeRestart(restart)
[16:20:32.957]                             muffled <- TRUE
[16:20:32.957]                             break
[16:20:32.957]                           }
[16:20:32.957]                         }
[16:20:32.957]                       }
[16:20:32.957]                       invisible(muffled)
[16:20:32.957]                     }
[16:20:32.957]                     muffleCondition(cond, pattern = "^muffle")
[16:20:32.957]                   }
[16:20:32.957]                 }
[16:20:32.957]                 else {
[16:20:32.957]                   if (TRUE) {
[16:20:32.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:32.957]                     {
[16:20:32.957]                       inherits <- base::inherits
[16:20:32.957]                       invokeRestart <- base::invokeRestart
[16:20:32.957]                       is.null <- base::is.null
[16:20:32.957]                       muffled <- FALSE
[16:20:32.957]                       if (inherits(cond, "message")) {
[16:20:32.957]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:32.957]                         if (muffled) 
[16:20:32.957]                           invokeRestart("muffleMessage")
[16:20:32.957]                       }
[16:20:32.957]                       else if (inherits(cond, "warning")) {
[16:20:32.957]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:32.957]                         if (muffled) 
[16:20:32.957]                           invokeRestart("muffleWarning")
[16:20:32.957]                       }
[16:20:32.957]                       else if (inherits(cond, "condition")) {
[16:20:32.957]                         if (!is.null(pattern)) {
[16:20:32.957]                           computeRestarts <- base::computeRestarts
[16:20:32.957]                           grepl <- base::grepl
[16:20:32.957]                           restarts <- computeRestarts(cond)
[16:20:32.957]                           for (restart in restarts) {
[16:20:32.957]                             name <- restart$name
[16:20:32.957]                             if (is.null(name)) 
[16:20:32.957]                               next
[16:20:32.957]                             if (!grepl(pattern, name)) 
[16:20:32.957]                               next
[16:20:32.957]                             invokeRestart(restart)
[16:20:32.957]                             muffled <- TRUE
[16:20:32.957]                             break
[16:20:32.957]                           }
[16:20:32.957]                         }
[16:20:32.957]                       }
[16:20:32.957]                       invisible(muffled)
[16:20:32.957]                     }
[16:20:32.957]                     muffleCondition(cond, pattern = "^muffle")
[16:20:32.957]                   }
[16:20:32.957]                 }
[16:20:32.957]             }
[16:20:32.957]         }))
[16:20:32.957]     }, error = function(ex) {
[16:20:32.957]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:32.957]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:32.957]                 ...future.rng), started = ...future.startTime, 
[16:20:32.957]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:32.957]             version = "1.8"), class = "FutureResult")
[16:20:32.957]     }, finally = {
[16:20:32.957]         if (!identical(...future.workdir, getwd())) 
[16:20:32.957]             setwd(...future.workdir)
[16:20:32.957]         {
[16:20:32.957]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:32.957]                 ...future.oldOptions$nwarnings <- NULL
[16:20:32.957]             }
[16:20:32.957]             base::options(...future.oldOptions)
[16:20:32.957]             if (.Platform$OS.type == "windows") {
[16:20:32.957]                 old_names <- names(...future.oldEnvVars)
[16:20:32.957]                 envs <- base::Sys.getenv()
[16:20:32.957]                 names <- names(envs)
[16:20:32.957]                 common <- intersect(names, old_names)
[16:20:32.957]                 added <- setdiff(names, old_names)
[16:20:32.957]                 removed <- setdiff(old_names, names)
[16:20:32.957]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:32.957]                   envs[common]]
[16:20:32.957]                 NAMES <- toupper(changed)
[16:20:32.957]                 args <- list()
[16:20:32.957]                 for (kk in seq_along(NAMES)) {
[16:20:32.957]                   name <- changed[[kk]]
[16:20:32.957]                   NAME <- NAMES[[kk]]
[16:20:32.957]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:32.957]                     next
[16:20:32.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:32.957]                 }
[16:20:32.957]                 NAMES <- toupper(added)
[16:20:32.957]                 for (kk in seq_along(NAMES)) {
[16:20:32.957]                   name <- added[[kk]]
[16:20:32.957]                   NAME <- NAMES[[kk]]
[16:20:32.957]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:32.957]                     next
[16:20:32.957]                   args[[name]] <- ""
[16:20:32.957]                 }
[16:20:32.957]                 NAMES <- toupper(removed)
[16:20:32.957]                 for (kk in seq_along(NAMES)) {
[16:20:32.957]                   name <- removed[[kk]]
[16:20:32.957]                   NAME <- NAMES[[kk]]
[16:20:32.957]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:32.957]                     next
[16:20:32.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:32.957]                 }
[16:20:32.957]                 if (length(args) > 0) 
[16:20:32.957]                   base::do.call(base::Sys.setenv, args = args)
[16:20:32.957]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:32.957]             }
[16:20:32.957]             else {
[16:20:32.957]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:32.957]             }
[16:20:32.957]             {
[16:20:32.957]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:32.957]                   0L) {
[16:20:32.957]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:32.957]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:32.957]                   base::options(opts)
[16:20:32.957]                 }
[16:20:32.957]                 {
[16:20:32.957]                   {
[16:20:32.957]                     NULL
[16:20:32.957]                     RNGkind("Mersenne-Twister")
[16:20:32.957]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:32.957]                       inherits = FALSE)
[16:20:32.957]                   }
[16:20:32.957]                   options(future.plan = NULL)
[16:20:32.957]                   if (is.na(NA_character_)) 
[16:20:32.957]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:32.957]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:32.957]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:32.957]                     .init = FALSE)
[16:20:32.957]                 }
[16:20:32.957]             }
[16:20:32.957]         }
[16:20:32.957]     })
[16:20:32.957]     if (TRUE) {
[16:20:32.957]         base::sink(type = "output", split = FALSE)
[16:20:32.957]         if (TRUE) {
[16:20:32.957]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:32.957]         }
[16:20:32.957]         else {
[16:20:32.957]             ...future.result["stdout"] <- base::list(NULL)
[16:20:32.957]         }
[16:20:32.957]         base::close(...future.stdout)
[16:20:32.957]         ...future.stdout <- NULL
[16:20:32.957]     }
[16:20:32.957]     ...future.result$conditions <- ...future.conditions
[16:20:32.957]     ...future.result$finished <- base::Sys.time()
[16:20:32.957]     ...future.result
[16:20:32.957] }
[16:20:32.958] assign_globals() ...
[16:20:32.958] List of 1
[16:20:32.958]  $ ii: int 2
[16:20:32.958]  - attr(*, "where")=List of 1
[16:20:32.958]   ..$ ii:<environment: R_EmptyEnv> 
[16:20:32.958]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:32.958]  - attr(*, "resolved")= logi FALSE
[16:20:32.958]  - attr(*, "total_size")= num 56
[16:20:32.958]  - attr(*, "already-done")= logi TRUE
[16:20:32.961] - copied ‘ii’ to environment
[16:20:32.961] assign_globals() ... done
[16:20:32.961] plan(): Setting new future strategy stack:
[16:20:32.961] List of future strategies:
[16:20:32.961] 1. sequential:
[16:20:32.961]    - args: function (..., envir = parent.frame())
[16:20:32.961]    - tweaked: FALSE
[16:20:32.961]    - call: NULL
[16:20:32.961] plan(): nbrOfWorkers() = 1
[16:20:32.962] plan(): Setting new future strategy stack:
[16:20:32.962] List of future strategies:
[16:20:32.962] 1. sequential:
[16:20:32.962]    - args: function (..., envir = parent.frame())
[16:20:32.962]    - tweaked: FALSE
[16:20:32.962]    - call: plan(strategy)
[16:20:32.963] plan(): nbrOfWorkers() = 1
[16:20:32.963] SequentialFuture started (and completed)
[16:20:32.963] signalConditions() ...
[16:20:32.963]  - include = ‘immediateCondition’
[16:20:32.963]  - exclude = 
[16:20:32.963]  - resignal = FALSE
[16:20:32.963]  - Number of conditions: 1
[16:20:32.963] signalConditions() ... done
[16:20:32.964] - Launch lazy future ... done
[16:20:32.964] run() for ‘SequentialFuture’ ... done
[16:20:32.964] getGlobalsAndPackages() ...
[16:20:32.964] Searching for globals...
[16:20:32.965] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[16:20:32.966] Searching for globals ... DONE
[16:20:32.966] Resolving globals: FALSE
[16:20:32.966] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:32.966] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:20:32.966] - globals: [1] ‘ii’
[16:20:32.967] 
[16:20:32.967] getGlobalsAndPackages() ... DONE
[16:20:32.967] run() for ‘Future’ ...
[16:20:32.967] - state: ‘created’
[16:20:32.967] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:32.967] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:32.967] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:32.968]   - Field: ‘label’
[16:20:32.968]   - Field: ‘local’
[16:20:32.968]   - Field: ‘owner’
[16:20:32.968]   - Field: ‘envir’
[16:20:32.968]   - Field: ‘packages’
[16:20:32.968]   - Field: ‘gc’
[16:20:32.968]   - Field: ‘conditions’
[16:20:32.968]   - Field: ‘expr’
[16:20:32.968]   - Field: ‘uuid’
[16:20:32.968]   - Field: ‘seed’
[16:20:32.969]   - Field: ‘version’
[16:20:32.969]   - Field: ‘result’
[16:20:32.969]   - Field: ‘asynchronous’
[16:20:32.969]   - Field: ‘calls’
[16:20:32.969]   - Field: ‘globals’
[16:20:32.969]   - Field: ‘stdout’
[16:20:32.969]   - Field: ‘earlySignal’
[16:20:32.969]   - Field: ‘lazy’
[16:20:32.969]   - Field: ‘state’
[16:20:32.969] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:32.969] - Launch lazy future ...
[16:20:32.970] Packages needed by the future expression (n = 0): <none>
[16:20:32.970] Packages needed by future strategies (n = 0): <none>
[16:20:32.970] {
[16:20:32.970]     {
[16:20:32.970]         {
[16:20:32.970]             ...future.startTime <- base::Sys.time()
[16:20:32.970]             {
[16:20:32.970]                 {
[16:20:32.970]                   {
[16:20:32.970]                     base::local({
[16:20:32.970]                       has_future <- base::requireNamespace("future", 
[16:20:32.970]                         quietly = TRUE)
[16:20:32.970]                       if (has_future) {
[16:20:32.970]                         ns <- base::getNamespace("future")
[16:20:32.970]                         version <- ns[[".package"]][["version"]]
[16:20:32.970]                         if (is.null(version)) 
[16:20:32.970]                           version <- utils::packageVersion("future")
[16:20:32.970]                       }
[16:20:32.970]                       else {
[16:20:32.970]                         version <- NULL
[16:20:32.970]                       }
[16:20:32.970]                       if (!has_future || version < "1.8.0") {
[16:20:32.970]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:32.970]                           "", base::R.version$version.string), 
[16:20:32.970]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:32.970]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:32.970]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:32.970]                             "release", "version")], collapse = " "), 
[16:20:32.970]                           hostname = base::Sys.info()[["nodename"]])
[16:20:32.970]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:32.970]                           info)
[16:20:32.970]                         info <- base::paste(info, collapse = "; ")
[16:20:32.970]                         if (!has_future) {
[16:20:32.970]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:32.970]                             info)
[16:20:32.970]                         }
[16:20:32.970]                         else {
[16:20:32.970]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:32.970]                             info, version)
[16:20:32.970]                         }
[16:20:32.970]                         base::stop(msg)
[16:20:32.970]                       }
[16:20:32.970]                     })
[16:20:32.970]                   }
[16:20:32.970]                   ...future.strategy.old <- future::plan("list")
[16:20:32.970]                   options(future.plan = NULL)
[16:20:32.970]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:32.970]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:32.970]                 }
[16:20:32.970]                 ...future.workdir <- getwd()
[16:20:32.970]             }
[16:20:32.970]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:32.970]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:32.970]         }
[16:20:32.970]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:32.970]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:32.970]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:32.970]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:32.970]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:32.970]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:32.970]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:32.970]             base::names(...future.oldOptions))
[16:20:32.970]     }
[16:20:32.970]     if (FALSE) {
[16:20:32.970]     }
[16:20:32.970]     else {
[16:20:32.970]         if (TRUE) {
[16:20:32.970]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:32.970]                 open = "w")
[16:20:32.970]         }
[16:20:32.970]         else {
[16:20:32.970]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:32.970]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:32.970]         }
[16:20:32.970]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:32.970]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:32.970]             base::sink(type = "output", split = FALSE)
[16:20:32.970]             base::close(...future.stdout)
[16:20:32.970]         }, add = TRUE)
[16:20:32.970]     }
[16:20:32.970]     ...future.frame <- base::sys.nframe()
[16:20:32.970]     ...future.conditions <- base::list()
[16:20:32.970]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:32.970]     if (FALSE) {
[16:20:32.970]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:32.970]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:32.970]     }
[16:20:32.970]     ...future.result <- base::tryCatch({
[16:20:32.970]         base::withCallingHandlers({
[16:20:32.970]             ...future.value <- base::withVisible(base::local({
[16:20:32.970]                 if (ii%%2 == 0) 
[16:20:32.970]                   stop("Woops!")
[16:20:32.970]                 ii
[16:20:32.970]             }))
[16:20:32.970]             future::FutureResult(value = ...future.value$value, 
[16:20:32.970]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:32.970]                   ...future.rng), globalenv = if (FALSE) 
[16:20:32.970]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:32.970]                     ...future.globalenv.names))
[16:20:32.970]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:32.970]         }, condition = base::local({
[16:20:32.970]             c <- base::c
[16:20:32.970]             inherits <- base::inherits
[16:20:32.970]             invokeRestart <- base::invokeRestart
[16:20:32.970]             length <- base::length
[16:20:32.970]             list <- base::list
[16:20:32.970]             seq.int <- base::seq.int
[16:20:32.970]             signalCondition <- base::signalCondition
[16:20:32.970]             sys.calls <- base::sys.calls
[16:20:32.970]             `[[` <- base::`[[`
[16:20:32.970]             `+` <- base::`+`
[16:20:32.970]             `<<-` <- base::`<<-`
[16:20:32.970]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:32.970]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:32.970]                   3L)]
[16:20:32.970]             }
[16:20:32.970]             function(cond) {
[16:20:32.970]                 is_error <- inherits(cond, "error")
[16:20:32.970]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:32.970]                   NULL)
[16:20:32.970]                 if (is_error) {
[16:20:32.970]                   sessionInformation <- function() {
[16:20:32.970]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:32.970]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:32.970]                       search = base::search(), system = base::Sys.info())
[16:20:32.970]                   }
[16:20:32.970]                   ...future.conditions[[length(...future.conditions) + 
[16:20:32.970]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:32.970]                     cond$call), session = sessionInformation(), 
[16:20:32.970]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:32.970]                   signalCondition(cond)
[16:20:32.970]                 }
[16:20:32.970]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:32.970]                 "immediateCondition"))) {
[16:20:32.970]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:32.970]                   ...future.conditions[[length(...future.conditions) + 
[16:20:32.970]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:32.970]                   if (TRUE && !signal) {
[16:20:32.970]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:32.970]                     {
[16:20:32.970]                       inherits <- base::inherits
[16:20:32.970]                       invokeRestart <- base::invokeRestart
[16:20:32.970]                       is.null <- base::is.null
[16:20:32.970]                       muffled <- FALSE
[16:20:32.970]                       if (inherits(cond, "message")) {
[16:20:32.970]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:32.970]                         if (muffled) 
[16:20:32.970]                           invokeRestart("muffleMessage")
[16:20:32.970]                       }
[16:20:32.970]                       else if (inherits(cond, "warning")) {
[16:20:32.970]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:32.970]                         if (muffled) 
[16:20:32.970]                           invokeRestart("muffleWarning")
[16:20:32.970]                       }
[16:20:32.970]                       else if (inherits(cond, "condition")) {
[16:20:32.970]                         if (!is.null(pattern)) {
[16:20:32.970]                           computeRestarts <- base::computeRestarts
[16:20:32.970]                           grepl <- base::grepl
[16:20:32.970]                           restarts <- computeRestarts(cond)
[16:20:32.970]                           for (restart in restarts) {
[16:20:32.970]                             name <- restart$name
[16:20:32.970]                             if (is.null(name)) 
[16:20:32.970]                               next
[16:20:32.970]                             if (!grepl(pattern, name)) 
[16:20:32.970]                               next
[16:20:32.970]                             invokeRestart(restart)
[16:20:32.970]                             muffled <- TRUE
[16:20:32.970]                             break
[16:20:32.970]                           }
[16:20:32.970]                         }
[16:20:32.970]                       }
[16:20:32.970]                       invisible(muffled)
[16:20:32.970]                     }
[16:20:32.970]                     muffleCondition(cond, pattern = "^muffle")
[16:20:32.970]                   }
[16:20:32.970]                 }
[16:20:32.970]                 else {
[16:20:32.970]                   if (TRUE) {
[16:20:32.970]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:32.970]                     {
[16:20:32.970]                       inherits <- base::inherits
[16:20:32.970]                       invokeRestart <- base::invokeRestart
[16:20:32.970]                       is.null <- base::is.null
[16:20:32.970]                       muffled <- FALSE
[16:20:32.970]                       if (inherits(cond, "message")) {
[16:20:32.970]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:32.970]                         if (muffled) 
[16:20:32.970]                           invokeRestart("muffleMessage")
[16:20:32.970]                       }
[16:20:32.970]                       else if (inherits(cond, "warning")) {
[16:20:32.970]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:32.970]                         if (muffled) 
[16:20:32.970]                           invokeRestart("muffleWarning")
[16:20:32.970]                       }
[16:20:32.970]                       else if (inherits(cond, "condition")) {
[16:20:32.970]                         if (!is.null(pattern)) {
[16:20:32.970]                           computeRestarts <- base::computeRestarts
[16:20:32.970]                           grepl <- base::grepl
[16:20:32.970]                           restarts <- computeRestarts(cond)
[16:20:32.970]                           for (restart in restarts) {
[16:20:32.970]                             name <- restart$name
[16:20:32.970]                             if (is.null(name)) 
[16:20:32.970]                               next
[16:20:32.970]                             if (!grepl(pattern, name)) 
[16:20:32.970]                               next
[16:20:32.970]                             invokeRestart(restart)
[16:20:32.970]                             muffled <- TRUE
[16:20:32.970]                             break
[16:20:32.970]                           }
[16:20:32.970]                         }
[16:20:32.970]                       }
[16:20:32.970]                       invisible(muffled)
[16:20:32.970]                     }
[16:20:32.970]                     muffleCondition(cond, pattern = "^muffle")
[16:20:32.970]                   }
[16:20:32.970]                 }
[16:20:32.970]             }
[16:20:32.970]         }))
[16:20:32.970]     }, error = function(ex) {
[16:20:32.970]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:32.970]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:32.970]                 ...future.rng), started = ...future.startTime, 
[16:20:32.970]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:32.970]             version = "1.8"), class = "FutureResult")
[16:20:32.970]     }, finally = {
[16:20:32.970]         if (!identical(...future.workdir, getwd())) 
[16:20:32.970]             setwd(...future.workdir)
[16:20:32.970]         {
[16:20:32.970]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:32.970]                 ...future.oldOptions$nwarnings <- NULL
[16:20:32.970]             }
[16:20:32.970]             base::options(...future.oldOptions)
[16:20:32.970]             if (.Platform$OS.type == "windows") {
[16:20:32.970]                 old_names <- names(...future.oldEnvVars)
[16:20:32.970]                 envs <- base::Sys.getenv()
[16:20:32.970]                 names <- names(envs)
[16:20:32.970]                 common <- intersect(names, old_names)
[16:20:32.970]                 added <- setdiff(names, old_names)
[16:20:32.970]                 removed <- setdiff(old_names, names)
[16:20:32.970]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:32.970]                   envs[common]]
[16:20:32.970]                 NAMES <- toupper(changed)
[16:20:32.970]                 args <- list()
[16:20:32.970]                 for (kk in seq_along(NAMES)) {
[16:20:32.970]                   name <- changed[[kk]]
[16:20:32.970]                   NAME <- NAMES[[kk]]
[16:20:32.970]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:32.970]                     next
[16:20:32.970]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:32.970]                 }
[16:20:32.970]                 NAMES <- toupper(added)
[16:20:32.970]                 for (kk in seq_along(NAMES)) {
[16:20:32.970]                   name <- added[[kk]]
[16:20:32.970]                   NAME <- NAMES[[kk]]
[16:20:32.970]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:32.970]                     next
[16:20:32.970]                   args[[name]] <- ""
[16:20:32.970]                 }
[16:20:32.970]                 NAMES <- toupper(removed)
[16:20:32.970]                 for (kk in seq_along(NAMES)) {
[16:20:32.970]                   name <- removed[[kk]]
[16:20:32.970]                   NAME <- NAMES[[kk]]
[16:20:32.970]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:32.970]                     next
[16:20:32.970]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:32.970]                 }
[16:20:32.970]                 if (length(args) > 0) 
[16:20:32.970]                   base::do.call(base::Sys.setenv, args = args)
[16:20:32.970]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:32.970]             }
[16:20:32.970]             else {
[16:20:32.970]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:32.970]             }
[16:20:32.970]             {
[16:20:32.970]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:32.970]                   0L) {
[16:20:32.970]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:32.970]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:32.970]                   base::options(opts)
[16:20:32.970]                 }
[16:20:32.970]                 {
[16:20:32.970]                   {
[16:20:32.970]                     NULL
[16:20:32.970]                     RNGkind("Mersenne-Twister")
[16:20:32.970]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:32.970]                       inherits = FALSE)
[16:20:32.970]                   }
[16:20:32.970]                   options(future.plan = NULL)
[16:20:32.970]                   if (is.na(NA_character_)) 
[16:20:32.970]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:32.970]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:32.970]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:32.970]                     .init = FALSE)
[16:20:32.970]                 }
[16:20:32.970]             }
[16:20:32.970]         }
[16:20:32.970]     })
[16:20:32.970]     if (TRUE) {
[16:20:32.970]         base::sink(type = "output", split = FALSE)
[16:20:32.970]         if (TRUE) {
[16:20:32.970]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:32.970]         }
[16:20:32.970]         else {
[16:20:32.970]             ...future.result["stdout"] <- base::list(NULL)
[16:20:32.970]         }
[16:20:32.970]         base::close(...future.stdout)
[16:20:32.970]         ...future.stdout <- NULL
[16:20:32.970]     }
[16:20:32.970]     ...future.result$conditions <- ...future.conditions
[16:20:32.970]     ...future.result$finished <- base::Sys.time()
[16:20:32.970]     ...future.result
[16:20:32.970] }
[16:20:32.972] assign_globals() ...
[16:20:32.972] List of 1
[16:20:32.972]  $ ii: int 3
[16:20:32.972]  - attr(*, "where")=List of 1
[16:20:32.972]   ..$ ii:<environment: R_EmptyEnv> 
[16:20:32.972]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:32.972]  - attr(*, "resolved")= logi FALSE
[16:20:32.972]  - attr(*, "total_size")= num 56
[16:20:32.972]  - attr(*, "already-done")= logi TRUE
[16:20:32.975] - copied ‘ii’ to environment
[16:20:32.975] assign_globals() ... done
[16:20:32.976] plan(): Setting new future strategy stack:
[16:20:32.976] List of future strategies:
[16:20:32.976] 1. sequential:
[16:20:32.976]    - args: function (..., envir = parent.frame())
[16:20:32.976]    - tweaked: FALSE
[16:20:32.976]    - call: NULL
[16:20:32.976] plan(): nbrOfWorkers() = 1
[16:20:32.977] plan(): Setting new future strategy stack:
[16:20:32.977] List of future strategies:
[16:20:32.977] 1. sequential:
[16:20:32.977]    - args: function (..., envir = parent.frame())
[16:20:32.977]    - tweaked: FALSE
[16:20:32.977]    - call: plan(strategy)
[16:20:32.977] plan(): nbrOfWorkers() = 1
[16:20:32.977] SequentialFuture started (and completed)
[16:20:32.977] - Launch lazy future ... done
[16:20:32.977] run() for ‘SequentialFuture’ ... done
[16:20:32.978] signalConditions() ...
[16:20:32.978]  - include = ‘immediateCondition’
[16:20:32.978]  - exclude = 
[16:20:32.978]  - resignal = FALSE
[16:20:32.978]  - Number of conditions: 1
[16:20:32.978] signalConditions() ... done
[16:20:32.978] Future state: ‘finished’
[16:20:32.978] signalConditions() ...
[16:20:32.979]  - include = ‘condition’
[16:20:32.979]  - exclude = ‘immediateCondition’
[16:20:32.979]  - resignal = TRUE
[16:20:32.979]  - Number of conditions: 1
[16:20:32.979]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:20:32.979] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[16:20:32.980] signalConditions() ...
[16:20:32.980]  - include = ‘immediateCondition’
[16:20:32.980]  - exclude = 
[16:20:32.980]  - resignal = FALSE
[16:20:32.981]  - Number of conditions: 1
[16:20:32.981] signalConditions() ... done
[16:20:32.981] Future state: ‘finished’
[16:20:32.981] signalConditions() ...
[16:20:32.981]  - include = ‘condition’
[16:20:32.981]  - exclude = ‘immediateCondition’
[16:20:32.981]  - resignal = TRUE
[16:20:32.981]  - Number of conditions: 1
[16:20:32.981]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:20:32.981] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[16:20:32.982] signalConditions() ...
[16:20:32.982]  - include = ‘immediateCondition’
[16:20:32.982]  - exclude = 
[16:20:32.982]  - resignal = FALSE
[16:20:32.982]  - Number of conditions: 1
[16:20:32.982] signalConditions() ... done
[16:20:32.982] Future state: ‘finished’
[16:20:32.982] signalConditions() ...
[16:20:32.982]  - include = ‘condition’
[16:20:32.983]  - exclude = ‘immediateCondition’
[16:20:32.983]  - resignal = TRUE
[16:20:32.983]  - Number of conditions: 1
[16:20:32.983]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:20:32.983] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[16:20:32.983] getGlobalsAndPackages() ...
[16:20:32.983] Searching for globals...
[16:20:32.985] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[16:20:32.985] Searching for globals ... DONE
[16:20:32.985] Resolving globals: FALSE
[16:20:32.986] 
[16:20:32.986] 
[16:20:32.986] getGlobalsAndPackages() ... DONE
[16:20:32.986] run() for ‘Future’ ...
[16:20:32.986] - state: ‘created’
[16:20:32.986] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:32.986] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:32.986] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:32.987]   - Field: ‘label’
[16:20:32.987]   - Field: ‘local’
[16:20:32.987]   - Field: ‘owner’
[16:20:32.987]   - Field: ‘envir’
[16:20:32.987]   - Field: ‘packages’
[16:20:32.987]   - Field: ‘gc’
[16:20:32.987]   - Field: ‘conditions’
[16:20:32.987]   - Field: ‘expr’
[16:20:32.987]   - Field: ‘uuid’
[16:20:32.987]   - Field: ‘seed’
[16:20:32.987]   - Field: ‘version’
[16:20:32.988]   - Field: ‘result’
[16:20:32.988]   - Field: ‘asynchronous’
[16:20:32.988]   - Field: ‘calls’
[16:20:32.988]   - Field: ‘globals’
[16:20:32.988]   - Field: ‘stdout’
[16:20:32.988]   - Field: ‘earlySignal’
[16:20:32.988]   - Field: ‘lazy’
[16:20:32.988]   - Field: ‘state’
[16:20:32.988] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:32.988] - Launch lazy future ...
[16:20:32.989] Packages needed by the future expression (n = 0): <none>
[16:20:32.989] Packages needed by future strategies (n = 0): <none>
[16:20:32.989] {
[16:20:32.989]     {
[16:20:32.989]         {
[16:20:32.989]             ...future.startTime <- base::Sys.time()
[16:20:32.989]             {
[16:20:32.989]                 {
[16:20:32.989]                   {
[16:20:32.989]                     base::local({
[16:20:32.989]                       has_future <- base::requireNamespace("future", 
[16:20:32.989]                         quietly = TRUE)
[16:20:32.989]                       if (has_future) {
[16:20:32.989]                         ns <- base::getNamespace("future")
[16:20:32.989]                         version <- ns[[".package"]][["version"]]
[16:20:32.989]                         if (is.null(version)) 
[16:20:32.989]                           version <- utils::packageVersion("future")
[16:20:32.989]                       }
[16:20:32.989]                       else {
[16:20:32.989]                         version <- NULL
[16:20:32.989]                       }
[16:20:32.989]                       if (!has_future || version < "1.8.0") {
[16:20:32.989]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:32.989]                           "", base::R.version$version.string), 
[16:20:32.989]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:32.989]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:32.989]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:32.989]                             "release", "version")], collapse = " "), 
[16:20:32.989]                           hostname = base::Sys.info()[["nodename"]])
[16:20:32.989]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:32.989]                           info)
[16:20:32.989]                         info <- base::paste(info, collapse = "; ")
[16:20:32.989]                         if (!has_future) {
[16:20:32.989]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:32.989]                             info)
[16:20:32.989]                         }
[16:20:32.989]                         else {
[16:20:32.989]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:32.989]                             info, version)
[16:20:32.989]                         }
[16:20:32.989]                         base::stop(msg)
[16:20:32.989]                       }
[16:20:32.989]                     })
[16:20:32.989]                   }
[16:20:32.989]                   ...future.strategy.old <- future::plan("list")
[16:20:32.989]                   options(future.plan = NULL)
[16:20:32.989]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:32.989]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:32.989]                 }
[16:20:32.989]                 ...future.workdir <- getwd()
[16:20:32.989]             }
[16:20:32.989]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:32.989]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:32.989]         }
[16:20:32.989]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:32.989]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:32.989]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:32.989]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:32.989]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:32.989]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:32.989]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:32.989]             base::names(...future.oldOptions))
[16:20:32.989]     }
[16:20:32.989]     if (FALSE) {
[16:20:32.989]     }
[16:20:32.989]     else {
[16:20:32.989]         if (TRUE) {
[16:20:32.989]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:32.989]                 open = "w")
[16:20:32.989]         }
[16:20:32.989]         else {
[16:20:32.989]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:32.989]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:32.989]         }
[16:20:32.989]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:32.989]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:32.989]             base::sink(type = "output", split = FALSE)
[16:20:32.989]             base::close(...future.stdout)
[16:20:32.989]         }, add = TRUE)
[16:20:32.989]     }
[16:20:32.989]     ...future.frame <- base::sys.nframe()
[16:20:32.989]     ...future.conditions <- base::list()
[16:20:32.989]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:32.989]     if (FALSE) {
[16:20:32.989]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:32.989]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:32.989]     }
[16:20:32.989]     ...future.result <- base::tryCatch({
[16:20:32.989]         base::withCallingHandlers({
[16:20:32.989]             ...future.value <- base::withVisible(base::local({
[16:20:32.989]                 cat("Processing: ")
[16:20:32.989]                 for (ii in 1:10) {
[16:20:32.989]                   cat(".")
[16:20:32.989]                 }
[16:20:32.989]                 cat(" [100%]\n")
[16:20:32.989]                 4
[16:20:32.989]             }))
[16:20:32.989]             future::FutureResult(value = ...future.value$value, 
[16:20:32.989]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:32.989]                   ...future.rng), globalenv = if (FALSE) 
[16:20:32.989]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:32.989]                     ...future.globalenv.names))
[16:20:32.989]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:32.989]         }, condition = base::local({
[16:20:32.989]             c <- base::c
[16:20:32.989]             inherits <- base::inherits
[16:20:32.989]             invokeRestart <- base::invokeRestart
[16:20:32.989]             length <- base::length
[16:20:32.989]             list <- base::list
[16:20:32.989]             seq.int <- base::seq.int
[16:20:32.989]             signalCondition <- base::signalCondition
[16:20:32.989]             sys.calls <- base::sys.calls
[16:20:32.989]             `[[` <- base::`[[`
[16:20:32.989]             `+` <- base::`+`
[16:20:32.989]             `<<-` <- base::`<<-`
[16:20:32.989]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:32.989]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:32.989]                   3L)]
[16:20:32.989]             }
[16:20:32.989]             function(cond) {
[16:20:32.989]                 is_error <- inherits(cond, "error")
[16:20:32.989]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:32.989]                   NULL)
[16:20:32.989]                 if (is_error) {
[16:20:32.989]                   sessionInformation <- function() {
[16:20:32.989]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:32.989]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:32.989]                       search = base::search(), system = base::Sys.info())
[16:20:32.989]                   }
[16:20:32.989]                   ...future.conditions[[length(...future.conditions) + 
[16:20:32.989]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:32.989]                     cond$call), session = sessionInformation(), 
[16:20:32.989]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:32.989]                   signalCondition(cond)
[16:20:32.989]                 }
[16:20:32.989]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:32.989]                 "immediateCondition"))) {
[16:20:32.989]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:32.989]                   ...future.conditions[[length(...future.conditions) + 
[16:20:32.989]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:32.989]                   if (TRUE && !signal) {
[16:20:32.989]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:32.989]                     {
[16:20:32.989]                       inherits <- base::inherits
[16:20:32.989]                       invokeRestart <- base::invokeRestart
[16:20:32.989]                       is.null <- base::is.null
[16:20:32.989]                       muffled <- FALSE
[16:20:32.989]                       if (inherits(cond, "message")) {
[16:20:32.989]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:32.989]                         if (muffled) 
[16:20:32.989]                           invokeRestart("muffleMessage")
[16:20:32.989]                       }
[16:20:32.989]                       else if (inherits(cond, "warning")) {
[16:20:32.989]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:32.989]                         if (muffled) 
[16:20:32.989]                           invokeRestart("muffleWarning")
[16:20:32.989]                       }
[16:20:32.989]                       else if (inherits(cond, "condition")) {
[16:20:32.989]                         if (!is.null(pattern)) {
[16:20:32.989]                           computeRestarts <- base::computeRestarts
[16:20:32.989]                           grepl <- base::grepl
[16:20:32.989]                           restarts <- computeRestarts(cond)
[16:20:32.989]                           for (restart in restarts) {
[16:20:32.989]                             name <- restart$name
[16:20:32.989]                             if (is.null(name)) 
[16:20:32.989]                               next
[16:20:32.989]                             if (!grepl(pattern, name)) 
[16:20:32.989]                               next
[16:20:32.989]                             invokeRestart(restart)
[16:20:32.989]                             muffled <- TRUE
[16:20:32.989]                             break
[16:20:32.989]                           }
[16:20:32.989]                         }
[16:20:32.989]                       }
[16:20:32.989]                       invisible(muffled)
[16:20:32.989]                     }
[16:20:32.989]                     muffleCondition(cond, pattern = "^muffle")
[16:20:32.989]                   }
[16:20:32.989]                 }
[16:20:32.989]                 else {
[16:20:32.989]                   if (TRUE) {
[16:20:32.989]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:32.989]                     {
[16:20:32.989]                       inherits <- base::inherits
[16:20:32.989]                       invokeRestart <- base::invokeRestart
[16:20:32.989]                       is.null <- base::is.null
[16:20:32.989]                       muffled <- FALSE
[16:20:32.989]                       if (inherits(cond, "message")) {
[16:20:32.989]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:32.989]                         if (muffled) 
[16:20:32.989]                           invokeRestart("muffleMessage")
[16:20:32.989]                       }
[16:20:32.989]                       else if (inherits(cond, "warning")) {
[16:20:32.989]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:32.989]                         if (muffled) 
[16:20:32.989]                           invokeRestart("muffleWarning")
[16:20:32.989]                       }
[16:20:32.989]                       else if (inherits(cond, "condition")) {
[16:20:32.989]                         if (!is.null(pattern)) {
[16:20:32.989]                           computeRestarts <- base::computeRestarts
[16:20:32.989]                           grepl <- base::grepl
[16:20:32.989]                           restarts <- computeRestarts(cond)
[16:20:32.989]                           for (restart in restarts) {
[16:20:32.989]                             name <- restart$name
[16:20:32.989]                             if (is.null(name)) 
[16:20:32.989]                               next
[16:20:32.989]                             if (!grepl(pattern, name)) 
[16:20:32.989]                               next
[16:20:32.989]                             invokeRestart(restart)
[16:20:32.989]                             muffled <- TRUE
[16:20:32.989]                             break
[16:20:32.989]                           }
[16:20:32.989]                         }
[16:20:32.989]                       }
[16:20:32.989]                       invisible(muffled)
[16:20:32.989]                     }
[16:20:32.989]                     muffleCondition(cond, pattern = "^muffle")
[16:20:32.989]                   }
[16:20:32.989]                 }
[16:20:32.989]             }
[16:20:32.989]         }))
[16:20:32.989]     }, error = function(ex) {
[16:20:32.989]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:32.989]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:32.989]                 ...future.rng), started = ...future.startTime, 
[16:20:32.989]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:32.989]             version = "1.8"), class = "FutureResult")
[16:20:32.989]     }, finally = {
[16:20:32.989]         if (!identical(...future.workdir, getwd())) 
[16:20:32.989]             setwd(...future.workdir)
[16:20:32.989]         {
[16:20:32.989]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:32.989]                 ...future.oldOptions$nwarnings <- NULL
[16:20:32.989]             }
[16:20:32.989]             base::options(...future.oldOptions)
[16:20:32.989]             if (.Platform$OS.type == "windows") {
[16:20:32.989]                 old_names <- names(...future.oldEnvVars)
[16:20:32.989]                 envs <- base::Sys.getenv()
[16:20:32.989]                 names <- names(envs)
[16:20:32.989]                 common <- intersect(names, old_names)
[16:20:32.989]                 added <- setdiff(names, old_names)
[16:20:32.989]                 removed <- setdiff(old_names, names)
[16:20:32.989]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:32.989]                   envs[common]]
[16:20:32.989]                 NAMES <- toupper(changed)
[16:20:32.989]                 args <- list()
[16:20:32.989]                 for (kk in seq_along(NAMES)) {
[16:20:32.989]                   name <- changed[[kk]]
[16:20:32.989]                   NAME <- NAMES[[kk]]
[16:20:32.989]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:32.989]                     next
[16:20:32.989]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:32.989]                 }
[16:20:32.989]                 NAMES <- toupper(added)
[16:20:32.989]                 for (kk in seq_along(NAMES)) {
[16:20:32.989]                   name <- added[[kk]]
[16:20:32.989]                   NAME <- NAMES[[kk]]
[16:20:32.989]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:32.989]                     next
[16:20:32.989]                   args[[name]] <- ""
[16:20:32.989]                 }
[16:20:32.989]                 NAMES <- toupper(removed)
[16:20:32.989]                 for (kk in seq_along(NAMES)) {
[16:20:32.989]                   name <- removed[[kk]]
[16:20:32.989]                   NAME <- NAMES[[kk]]
[16:20:32.989]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:32.989]                     next
[16:20:32.989]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:32.989]                 }
[16:20:32.989]                 if (length(args) > 0) 
[16:20:32.989]                   base::do.call(base::Sys.setenv, args = args)
[16:20:32.989]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:32.989]             }
[16:20:32.989]             else {
[16:20:32.989]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:32.989]             }
[16:20:32.989]             {
[16:20:32.989]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:32.989]                   0L) {
[16:20:32.989]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:32.989]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:32.989]                   base::options(opts)
[16:20:32.989]                 }
[16:20:32.989]                 {
[16:20:32.989]                   {
[16:20:32.989]                     NULL
[16:20:32.989]                     RNGkind("Mersenne-Twister")
[16:20:32.989]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:32.989]                       inherits = FALSE)
[16:20:32.989]                   }
[16:20:32.989]                   options(future.plan = NULL)
[16:20:32.989]                   if (is.na(NA_character_)) 
[16:20:32.989]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:32.989]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:32.989]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:32.989]                     .init = FALSE)
[16:20:32.989]                 }
[16:20:32.989]             }
[16:20:32.989]         }
[16:20:32.989]     })
[16:20:32.989]     if (TRUE) {
[16:20:32.989]         base::sink(type = "output", split = FALSE)
[16:20:32.989]         if (TRUE) {
[16:20:32.989]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:32.989]         }
[16:20:32.989]         else {
[16:20:32.989]             ...future.result["stdout"] <- base::list(NULL)
[16:20:32.989]         }
[16:20:32.989]         base::close(...future.stdout)
[16:20:32.989]         ...future.stdout <- NULL
[16:20:32.989]     }
[16:20:32.989]     ...future.result$conditions <- ...future.conditions
[16:20:32.989]     ...future.result$finished <- base::Sys.time()
[16:20:32.989]     ...future.result
[16:20:32.989] }
[16:20:32.991] plan(): Setting new future strategy stack:
[16:20:32.991] List of future strategies:
[16:20:32.991] 1. sequential:
[16:20:32.991]    - args: function (..., envir = parent.frame())
[16:20:32.991]    - tweaked: FALSE
[16:20:32.991]    - call: NULL
[16:20:32.991] plan(): nbrOfWorkers() = 1
[16:20:32.992] plan(): Setting new future strategy stack:
[16:20:32.992] List of future strategies:
[16:20:32.992] 1. sequential:
[16:20:32.992]    - args: function (..., envir = parent.frame())
[16:20:32.992]    - tweaked: FALSE
[16:20:32.992]    - call: plan(strategy)
[16:20:32.992] plan(): nbrOfWorkers() = 1
[16:20:32.992] SequentialFuture started (and completed)
[16:20:32.993] - Launch lazy future ... done
[16:20:32.993] run() for ‘SequentialFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[16:20:32.994] signalConditions() ...
[16:20:32.994]  - include = ‘immediateCondition’
[16:20:32.994]  - exclude = 
[16:20:32.994]  - resignal = FALSE
[16:20:32.994]  - Number of conditions: 1
[16:20:32.994] signalConditions() ... done
[16:20:32.994] Future state: ‘finished’
[16:20:32.995] signalConditions() ...
[16:20:32.995]  - include = ‘condition’
[16:20:32.995]  - exclude = ‘immediateCondition’
[16:20:32.995]  - resignal = TRUE
[16:20:32.995]  - Number of conditions: 1
[16:20:32.995]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:20:32.995] signalConditions() ... done
v3: <simpleError> (as expect)
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[16:20:32.995] getGlobalsAndPackages() ...
[16:20:32.996] Searching for globals...
[16:20:32.996] 
[16:20:32.996] Searching for globals ... DONE
[16:20:32.996] - globals: [0] <none>
[16:20:32.996] getGlobalsAndPackages() ... DONE
[16:20:32.996] run() for ‘Future’ ...
[16:20:32.996] - state: ‘created’
[16:20:32.997] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:32.997] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:32.998] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:32.998]   - Field: ‘label’
[16:20:32.998]   - Field: ‘local’
[16:20:32.998]   - Field: ‘owner’
[16:20:32.998]   - Field: ‘envir’
[16:20:32.998]   - Field: ‘packages’
[16:20:32.998]   - Field: ‘gc’
[16:20:32.999]   - Field: ‘conditions’
[16:20:32.999]   - Field: ‘expr’
[16:20:32.999]   - Field: ‘uuid’
[16:20:32.999]   - Field: ‘seed’
[16:20:32.999]   - Field: ‘version’
[16:20:32.999]   - Field: ‘result’
[16:20:32.999]   - Field: ‘asynchronous’
[16:20:32.999]   - Field: ‘calls’
[16:20:32.999]   - Field: ‘globals’
[16:20:32.999]   - Field: ‘stdout’
[16:20:32.999]   - Field: ‘earlySignal’
[16:20:32.999]   - Field: ‘lazy’
[16:20:33.000]   - Field: ‘state’
[16:20:33.000] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:33.000] - Launch lazy future ...
[16:20:33.000] Packages needed by the future expression (n = 0): <none>
[16:20:33.000] Packages needed by future strategies (n = 0): <none>
[16:20:33.000] {
[16:20:33.000]     {
[16:20:33.000]         {
[16:20:33.000]             ...future.startTime <- base::Sys.time()
[16:20:33.000]             {
[16:20:33.000]                 {
[16:20:33.000]                   {
[16:20:33.000]                     base::local({
[16:20:33.000]                       has_future <- base::requireNamespace("future", 
[16:20:33.000]                         quietly = TRUE)
[16:20:33.000]                       if (has_future) {
[16:20:33.000]                         ns <- base::getNamespace("future")
[16:20:33.000]                         version <- ns[[".package"]][["version"]]
[16:20:33.000]                         if (is.null(version)) 
[16:20:33.000]                           version <- utils::packageVersion("future")
[16:20:33.000]                       }
[16:20:33.000]                       else {
[16:20:33.000]                         version <- NULL
[16:20:33.000]                       }
[16:20:33.000]                       if (!has_future || version < "1.8.0") {
[16:20:33.000]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:33.000]                           "", base::R.version$version.string), 
[16:20:33.000]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:33.000]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:33.000]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:33.000]                             "release", "version")], collapse = " "), 
[16:20:33.000]                           hostname = base::Sys.info()[["nodename"]])
[16:20:33.000]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:33.000]                           info)
[16:20:33.000]                         info <- base::paste(info, collapse = "; ")
[16:20:33.000]                         if (!has_future) {
[16:20:33.000]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:33.000]                             info)
[16:20:33.000]                         }
[16:20:33.000]                         else {
[16:20:33.000]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:33.000]                             info, version)
[16:20:33.000]                         }
[16:20:33.000]                         base::stop(msg)
[16:20:33.000]                       }
[16:20:33.000]                     })
[16:20:33.000]                   }
[16:20:33.000]                   ...future.strategy.old <- future::plan("list")
[16:20:33.000]                   options(future.plan = NULL)
[16:20:33.000]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.000]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:33.000]                 }
[16:20:33.000]                 ...future.workdir <- getwd()
[16:20:33.000]             }
[16:20:33.000]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:33.000]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:33.000]         }
[16:20:33.000]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:33.000]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:33.000]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:33.000]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:33.000]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:33.000]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:33.000]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:33.000]             base::names(...future.oldOptions))
[16:20:33.000]     }
[16:20:33.000]     if (FALSE) {
[16:20:33.000]     }
[16:20:33.000]     else {
[16:20:33.000]         if (TRUE) {
[16:20:33.000]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:33.000]                 open = "w")
[16:20:33.000]         }
[16:20:33.000]         else {
[16:20:33.000]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:33.000]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:33.000]         }
[16:20:33.000]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:33.000]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:33.000]             base::sink(type = "output", split = FALSE)
[16:20:33.000]             base::close(...future.stdout)
[16:20:33.000]         }, add = TRUE)
[16:20:33.000]     }
[16:20:33.000]     ...future.frame <- base::sys.nframe()
[16:20:33.000]     ...future.conditions <- base::list()
[16:20:33.000]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:33.000]     if (FALSE) {
[16:20:33.000]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:33.000]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:33.000]     }
[16:20:33.000]     ...future.result <- base::tryCatch({
[16:20:33.000]         base::withCallingHandlers({
[16:20:33.000]             ...future.value <- base::withVisible(base::local(1))
[16:20:33.000]             future::FutureResult(value = ...future.value$value, 
[16:20:33.000]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.000]                   ...future.rng), globalenv = if (FALSE) 
[16:20:33.000]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:33.000]                     ...future.globalenv.names))
[16:20:33.000]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:33.000]         }, condition = base::local({
[16:20:33.000]             c <- base::c
[16:20:33.000]             inherits <- base::inherits
[16:20:33.000]             invokeRestart <- base::invokeRestart
[16:20:33.000]             length <- base::length
[16:20:33.000]             list <- base::list
[16:20:33.000]             seq.int <- base::seq.int
[16:20:33.000]             signalCondition <- base::signalCondition
[16:20:33.000]             sys.calls <- base::sys.calls
[16:20:33.000]             `[[` <- base::`[[`
[16:20:33.000]             `+` <- base::`+`
[16:20:33.000]             `<<-` <- base::`<<-`
[16:20:33.000]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:33.000]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:33.000]                   3L)]
[16:20:33.000]             }
[16:20:33.000]             function(cond) {
[16:20:33.000]                 is_error <- inherits(cond, "error")
[16:20:33.000]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:33.000]                   NULL)
[16:20:33.000]                 if (is_error) {
[16:20:33.000]                   sessionInformation <- function() {
[16:20:33.000]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:33.000]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:33.000]                       search = base::search(), system = base::Sys.info())
[16:20:33.000]                   }
[16:20:33.000]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.000]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:33.000]                     cond$call), session = sessionInformation(), 
[16:20:33.000]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:33.000]                   signalCondition(cond)
[16:20:33.000]                 }
[16:20:33.000]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:33.000]                 "immediateCondition"))) {
[16:20:33.000]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:33.000]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.000]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:33.000]                   if (TRUE && !signal) {
[16:20:33.000]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.000]                     {
[16:20:33.000]                       inherits <- base::inherits
[16:20:33.000]                       invokeRestart <- base::invokeRestart
[16:20:33.000]                       is.null <- base::is.null
[16:20:33.000]                       muffled <- FALSE
[16:20:33.000]                       if (inherits(cond, "message")) {
[16:20:33.000]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.000]                         if (muffled) 
[16:20:33.000]                           invokeRestart("muffleMessage")
[16:20:33.000]                       }
[16:20:33.000]                       else if (inherits(cond, "warning")) {
[16:20:33.000]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.000]                         if (muffled) 
[16:20:33.000]                           invokeRestart("muffleWarning")
[16:20:33.000]                       }
[16:20:33.000]                       else if (inherits(cond, "condition")) {
[16:20:33.000]                         if (!is.null(pattern)) {
[16:20:33.000]                           computeRestarts <- base::computeRestarts
[16:20:33.000]                           grepl <- base::grepl
[16:20:33.000]                           restarts <- computeRestarts(cond)
[16:20:33.000]                           for (restart in restarts) {
[16:20:33.000]                             name <- restart$name
[16:20:33.000]                             if (is.null(name)) 
[16:20:33.000]                               next
[16:20:33.000]                             if (!grepl(pattern, name)) 
[16:20:33.000]                               next
[16:20:33.000]                             invokeRestart(restart)
[16:20:33.000]                             muffled <- TRUE
[16:20:33.000]                             break
[16:20:33.000]                           }
[16:20:33.000]                         }
[16:20:33.000]                       }
[16:20:33.000]                       invisible(muffled)
[16:20:33.000]                     }
[16:20:33.000]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.000]                   }
[16:20:33.000]                 }
[16:20:33.000]                 else {
[16:20:33.000]                   if (TRUE) {
[16:20:33.000]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.000]                     {
[16:20:33.000]                       inherits <- base::inherits
[16:20:33.000]                       invokeRestart <- base::invokeRestart
[16:20:33.000]                       is.null <- base::is.null
[16:20:33.000]                       muffled <- FALSE
[16:20:33.000]                       if (inherits(cond, "message")) {
[16:20:33.000]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.000]                         if (muffled) 
[16:20:33.000]                           invokeRestart("muffleMessage")
[16:20:33.000]                       }
[16:20:33.000]                       else if (inherits(cond, "warning")) {
[16:20:33.000]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.000]                         if (muffled) 
[16:20:33.000]                           invokeRestart("muffleWarning")
[16:20:33.000]                       }
[16:20:33.000]                       else if (inherits(cond, "condition")) {
[16:20:33.000]                         if (!is.null(pattern)) {
[16:20:33.000]                           computeRestarts <- base::computeRestarts
[16:20:33.000]                           grepl <- base::grepl
[16:20:33.000]                           restarts <- computeRestarts(cond)
[16:20:33.000]                           for (restart in restarts) {
[16:20:33.000]                             name <- restart$name
[16:20:33.000]                             if (is.null(name)) 
[16:20:33.000]                               next
[16:20:33.000]                             if (!grepl(pattern, name)) 
[16:20:33.000]                               next
[16:20:33.000]                             invokeRestart(restart)
[16:20:33.000]                             muffled <- TRUE
[16:20:33.000]                             break
[16:20:33.000]                           }
[16:20:33.000]                         }
[16:20:33.000]                       }
[16:20:33.000]                       invisible(muffled)
[16:20:33.000]                     }
[16:20:33.000]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.000]                   }
[16:20:33.000]                 }
[16:20:33.000]             }
[16:20:33.000]         }))
[16:20:33.000]     }, error = function(ex) {
[16:20:33.000]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:33.000]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.000]                 ...future.rng), started = ...future.startTime, 
[16:20:33.000]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:33.000]             version = "1.8"), class = "FutureResult")
[16:20:33.000]     }, finally = {
[16:20:33.000]         if (!identical(...future.workdir, getwd())) 
[16:20:33.000]             setwd(...future.workdir)
[16:20:33.000]         {
[16:20:33.000]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:33.000]                 ...future.oldOptions$nwarnings <- NULL
[16:20:33.000]             }
[16:20:33.000]             base::options(...future.oldOptions)
[16:20:33.000]             if (.Platform$OS.type == "windows") {
[16:20:33.000]                 old_names <- names(...future.oldEnvVars)
[16:20:33.000]                 envs <- base::Sys.getenv()
[16:20:33.000]                 names <- names(envs)
[16:20:33.000]                 common <- intersect(names, old_names)
[16:20:33.000]                 added <- setdiff(names, old_names)
[16:20:33.000]                 removed <- setdiff(old_names, names)
[16:20:33.000]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:33.000]                   envs[common]]
[16:20:33.000]                 NAMES <- toupper(changed)
[16:20:33.000]                 args <- list()
[16:20:33.000]                 for (kk in seq_along(NAMES)) {
[16:20:33.000]                   name <- changed[[kk]]
[16:20:33.000]                   NAME <- NAMES[[kk]]
[16:20:33.000]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.000]                     next
[16:20:33.000]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.000]                 }
[16:20:33.000]                 NAMES <- toupper(added)
[16:20:33.000]                 for (kk in seq_along(NAMES)) {
[16:20:33.000]                   name <- added[[kk]]
[16:20:33.000]                   NAME <- NAMES[[kk]]
[16:20:33.000]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.000]                     next
[16:20:33.000]                   args[[name]] <- ""
[16:20:33.000]                 }
[16:20:33.000]                 NAMES <- toupper(removed)
[16:20:33.000]                 for (kk in seq_along(NAMES)) {
[16:20:33.000]                   name <- removed[[kk]]
[16:20:33.000]                   NAME <- NAMES[[kk]]
[16:20:33.000]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.000]                     next
[16:20:33.000]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.000]                 }
[16:20:33.000]                 if (length(args) > 0) 
[16:20:33.000]                   base::do.call(base::Sys.setenv, args = args)
[16:20:33.000]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:33.000]             }
[16:20:33.000]             else {
[16:20:33.000]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:33.000]             }
[16:20:33.000]             {
[16:20:33.000]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:33.000]                   0L) {
[16:20:33.000]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:33.000]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:33.000]                   base::options(opts)
[16:20:33.000]                 }
[16:20:33.000]                 {
[16:20:33.000]                   {
[16:20:33.000]                     NULL
[16:20:33.000]                     RNGkind("Mersenne-Twister")
[16:20:33.000]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:33.000]                       inherits = FALSE)
[16:20:33.000]                   }
[16:20:33.000]                   options(future.plan = NULL)
[16:20:33.000]                   if (is.na(NA_character_)) 
[16:20:33.000]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.000]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:33.000]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:33.000]                     .init = FALSE)
[16:20:33.000]                 }
[16:20:33.000]             }
[16:20:33.000]         }
[16:20:33.000]     })
[16:20:33.000]     if (TRUE) {
[16:20:33.000]         base::sink(type = "output", split = FALSE)
[16:20:33.000]         if (TRUE) {
[16:20:33.000]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:33.000]         }
[16:20:33.000]         else {
[16:20:33.000]             ...future.result["stdout"] <- base::list(NULL)
[16:20:33.000]         }
[16:20:33.000]         base::close(...future.stdout)
[16:20:33.000]         ...future.stdout <- NULL
[16:20:33.000]     }
[16:20:33.000]     ...future.result$conditions <- ...future.conditions
[16:20:33.000]     ...future.result$finished <- base::Sys.time()
[16:20:33.000]     ...future.result
[16:20:33.000] }
[16:20:33.002] plan(): Setting new future strategy stack:
[16:20:33.002] List of future strategies:
[16:20:33.002] 1. sequential:
[16:20:33.002]    - args: function (..., envir = parent.frame())
[16:20:33.002]    - tweaked: FALSE
[16:20:33.002]    - call: NULL
[16:20:33.003] plan(): nbrOfWorkers() = 1
[16:20:33.003] plan(): Setting new future strategy stack:
[16:20:33.003] List of future strategies:
[16:20:33.003] 1. sequential:
[16:20:33.003]    - args: function (..., envir = parent.frame())
[16:20:33.003]    - tweaked: FALSE
[16:20:33.003]    - call: plan(strategy)
[16:20:33.004] plan(): nbrOfWorkers() = 1
[16:20:33.004] SequentialFuture started (and completed)
[16:20:33.004] - Launch lazy future ... done
[16:20:33.004] run() for ‘SequentialFuture’ ... done
c = 1
[16:20:33.004] getGlobalsAndPackages() ...
[16:20:33.004] Searching for globals...
[16:20:33.005] 
[16:20:33.005] Searching for globals ... DONE
[16:20:33.005] - globals: [0] <none>
[16:20:33.005] getGlobalsAndPackages() ... DONE
[16:20:33.005] run() for ‘Future’ ...
[16:20:33.005] - state: ‘created’
[16:20:33.005] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:33.006] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:33.006] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:33.006]   - Field: ‘label’
[16:20:33.006]   - Field: ‘local’
[16:20:33.006]   - Field: ‘owner’
[16:20:33.006]   - Field: ‘envir’
[16:20:33.006]   - Field: ‘packages’
[16:20:33.006]   - Field: ‘gc’
[16:20:33.006]   - Field: ‘conditions’
[16:20:33.006]   - Field: ‘expr’
[16:20:33.007]   - Field: ‘uuid’
[16:20:33.007]   - Field: ‘seed’
[16:20:33.007]   - Field: ‘version’
[16:20:33.007]   - Field: ‘result’
[16:20:33.007]   - Field: ‘asynchronous’
[16:20:33.007]   - Field: ‘calls’
[16:20:33.007]   - Field: ‘globals’
[16:20:33.007]   - Field: ‘stdout’
[16:20:33.007]   - Field: ‘earlySignal’
[16:20:33.007]   - Field: ‘lazy’
[16:20:33.007]   - Field: ‘state’
[16:20:33.008] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:33.008] - Launch lazy future ...
[16:20:33.008] Packages needed by the future expression (n = 0): <none>
[16:20:33.008] Packages needed by future strategies (n = 0): <none>
[16:20:33.008] {
[16:20:33.008]     {
[16:20:33.008]         {
[16:20:33.008]             ...future.startTime <- base::Sys.time()
[16:20:33.008]             {
[16:20:33.008]                 {
[16:20:33.008]                   {
[16:20:33.008]                     base::local({
[16:20:33.008]                       has_future <- base::requireNamespace("future", 
[16:20:33.008]                         quietly = TRUE)
[16:20:33.008]                       if (has_future) {
[16:20:33.008]                         ns <- base::getNamespace("future")
[16:20:33.008]                         version <- ns[[".package"]][["version"]]
[16:20:33.008]                         if (is.null(version)) 
[16:20:33.008]                           version <- utils::packageVersion("future")
[16:20:33.008]                       }
[16:20:33.008]                       else {
[16:20:33.008]                         version <- NULL
[16:20:33.008]                       }
[16:20:33.008]                       if (!has_future || version < "1.8.0") {
[16:20:33.008]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:33.008]                           "", base::R.version$version.string), 
[16:20:33.008]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:33.008]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:33.008]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:33.008]                             "release", "version")], collapse = " "), 
[16:20:33.008]                           hostname = base::Sys.info()[["nodename"]])
[16:20:33.008]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:33.008]                           info)
[16:20:33.008]                         info <- base::paste(info, collapse = "; ")
[16:20:33.008]                         if (!has_future) {
[16:20:33.008]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:33.008]                             info)
[16:20:33.008]                         }
[16:20:33.008]                         else {
[16:20:33.008]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:33.008]                             info, version)
[16:20:33.008]                         }
[16:20:33.008]                         base::stop(msg)
[16:20:33.008]                       }
[16:20:33.008]                     })
[16:20:33.008]                   }
[16:20:33.008]                   ...future.strategy.old <- future::plan("list")
[16:20:33.008]                   options(future.plan = NULL)
[16:20:33.008]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.008]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:33.008]                 }
[16:20:33.008]                 ...future.workdir <- getwd()
[16:20:33.008]             }
[16:20:33.008]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:33.008]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:33.008]         }
[16:20:33.008]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:33.008]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:33.008]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:33.008]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:33.008]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:33.008]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:33.008]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:33.008]             base::names(...future.oldOptions))
[16:20:33.008]     }
[16:20:33.008]     if (FALSE) {
[16:20:33.008]     }
[16:20:33.008]     else {
[16:20:33.008]         if (TRUE) {
[16:20:33.008]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:33.008]                 open = "w")
[16:20:33.008]         }
[16:20:33.008]         else {
[16:20:33.008]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:33.008]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:33.008]         }
[16:20:33.008]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:33.008]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:33.008]             base::sink(type = "output", split = FALSE)
[16:20:33.008]             base::close(...future.stdout)
[16:20:33.008]         }, add = TRUE)
[16:20:33.008]     }
[16:20:33.008]     ...future.frame <- base::sys.nframe()
[16:20:33.008]     ...future.conditions <- base::list()
[16:20:33.008]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:33.008]     if (FALSE) {
[16:20:33.008]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:33.008]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:33.008]     }
[16:20:33.008]     ...future.result <- base::tryCatch({
[16:20:33.008]         base::withCallingHandlers({
[16:20:33.008]             ...future.value <- base::withVisible(base::local(1))
[16:20:33.008]             future::FutureResult(value = ...future.value$value, 
[16:20:33.008]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.008]                   ...future.rng), globalenv = if (FALSE) 
[16:20:33.008]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:33.008]                     ...future.globalenv.names))
[16:20:33.008]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:33.008]         }, condition = base::local({
[16:20:33.008]             c <- base::c
[16:20:33.008]             inherits <- base::inherits
[16:20:33.008]             invokeRestart <- base::invokeRestart
[16:20:33.008]             length <- base::length
[16:20:33.008]             list <- base::list
[16:20:33.008]             seq.int <- base::seq.int
[16:20:33.008]             signalCondition <- base::signalCondition
[16:20:33.008]             sys.calls <- base::sys.calls
[16:20:33.008]             `[[` <- base::`[[`
[16:20:33.008]             `+` <- base::`+`
[16:20:33.008]             `<<-` <- base::`<<-`
[16:20:33.008]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:33.008]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:33.008]                   3L)]
[16:20:33.008]             }
[16:20:33.008]             function(cond) {
[16:20:33.008]                 is_error <- inherits(cond, "error")
[16:20:33.008]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:33.008]                   NULL)
[16:20:33.008]                 if (is_error) {
[16:20:33.008]                   sessionInformation <- function() {
[16:20:33.008]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:33.008]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:33.008]                       search = base::search(), system = base::Sys.info())
[16:20:33.008]                   }
[16:20:33.008]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.008]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:33.008]                     cond$call), session = sessionInformation(), 
[16:20:33.008]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:33.008]                   signalCondition(cond)
[16:20:33.008]                 }
[16:20:33.008]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:33.008]                 "immediateCondition"))) {
[16:20:33.008]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:33.008]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.008]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:33.008]                   if (TRUE && !signal) {
[16:20:33.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.008]                     {
[16:20:33.008]                       inherits <- base::inherits
[16:20:33.008]                       invokeRestart <- base::invokeRestart
[16:20:33.008]                       is.null <- base::is.null
[16:20:33.008]                       muffled <- FALSE
[16:20:33.008]                       if (inherits(cond, "message")) {
[16:20:33.008]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.008]                         if (muffled) 
[16:20:33.008]                           invokeRestart("muffleMessage")
[16:20:33.008]                       }
[16:20:33.008]                       else if (inherits(cond, "warning")) {
[16:20:33.008]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.008]                         if (muffled) 
[16:20:33.008]                           invokeRestart("muffleWarning")
[16:20:33.008]                       }
[16:20:33.008]                       else if (inherits(cond, "condition")) {
[16:20:33.008]                         if (!is.null(pattern)) {
[16:20:33.008]                           computeRestarts <- base::computeRestarts
[16:20:33.008]                           grepl <- base::grepl
[16:20:33.008]                           restarts <- computeRestarts(cond)
[16:20:33.008]                           for (restart in restarts) {
[16:20:33.008]                             name <- restart$name
[16:20:33.008]                             if (is.null(name)) 
[16:20:33.008]                               next
[16:20:33.008]                             if (!grepl(pattern, name)) 
[16:20:33.008]                               next
[16:20:33.008]                             invokeRestart(restart)
[16:20:33.008]                             muffled <- TRUE
[16:20:33.008]                             break
[16:20:33.008]                           }
[16:20:33.008]                         }
[16:20:33.008]                       }
[16:20:33.008]                       invisible(muffled)
[16:20:33.008]                     }
[16:20:33.008]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.008]                   }
[16:20:33.008]                 }
[16:20:33.008]                 else {
[16:20:33.008]                   if (TRUE) {
[16:20:33.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.008]                     {
[16:20:33.008]                       inherits <- base::inherits
[16:20:33.008]                       invokeRestart <- base::invokeRestart
[16:20:33.008]                       is.null <- base::is.null
[16:20:33.008]                       muffled <- FALSE
[16:20:33.008]                       if (inherits(cond, "message")) {
[16:20:33.008]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.008]                         if (muffled) 
[16:20:33.008]                           invokeRestart("muffleMessage")
[16:20:33.008]                       }
[16:20:33.008]                       else if (inherits(cond, "warning")) {
[16:20:33.008]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.008]                         if (muffled) 
[16:20:33.008]                           invokeRestart("muffleWarning")
[16:20:33.008]                       }
[16:20:33.008]                       else if (inherits(cond, "condition")) {
[16:20:33.008]                         if (!is.null(pattern)) {
[16:20:33.008]                           computeRestarts <- base::computeRestarts
[16:20:33.008]                           grepl <- base::grepl
[16:20:33.008]                           restarts <- computeRestarts(cond)
[16:20:33.008]                           for (restart in restarts) {
[16:20:33.008]                             name <- restart$name
[16:20:33.008]                             if (is.null(name)) 
[16:20:33.008]                               next
[16:20:33.008]                             if (!grepl(pattern, name)) 
[16:20:33.008]                               next
[16:20:33.008]                             invokeRestart(restart)
[16:20:33.008]                             muffled <- TRUE
[16:20:33.008]                             break
[16:20:33.008]                           }
[16:20:33.008]                         }
[16:20:33.008]                       }
[16:20:33.008]                       invisible(muffled)
[16:20:33.008]                     }
[16:20:33.008]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.008]                   }
[16:20:33.008]                 }
[16:20:33.008]             }
[16:20:33.008]         }))
[16:20:33.008]     }, error = function(ex) {
[16:20:33.008]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:33.008]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.008]                 ...future.rng), started = ...future.startTime, 
[16:20:33.008]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:33.008]             version = "1.8"), class = "FutureResult")
[16:20:33.008]     }, finally = {
[16:20:33.008]         if (!identical(...future.workdir, getwd())) 
[16:20:33.008]             setwd(...future.workdir)
[16:20:33.008]         {
[16:20:33.008]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:33.008]                 ...future.oldOptions$nwarnings <- NULL
[16:20:33.008]             }
[16:20:33.008]             base::options(...future.oldOptions)
[16:20:33.008]             if (.Platform$OS.type == "windows") {
[16:20:33.008]                 old_names <- names(...future.oldEnvVars)
[16:20:33.008]                 envs <- base::Sys.getenv()
[16:20:33.008]                 names <- names(envs)
[16:20:33.008]                 common <- intersect(names, old_names)
[16:20:33.008]                 added <- setdiff(names, old_names)
[16:20:33.008]                 removed <- setdiff(old_names, names)
[16:20:33.008]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:33.008]                   envs[common]]
[16:20:33.008]                 NAMES <- toupper(changed)
[16:20:33.008]                 args <- list()
[16:20:33.008]                 for (kk in seq_along(NAMES)) {
[16:20:33.008]                   name <- changed[[kk]]
[16:20:33.008]                   NAME <- NAMES[[kk]]
[16:20:33.008]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.008]                     next
[16:20:33.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.008]                 }
[16:20:33.008]                 NAMES <- toupper(added)
[16:20:33.008]                 for (kk in seq_along(NAMES)) {
[16:20:33.008]                   name <- added[[kk]]
[16:20:33.008]                   NAME <- NAMES[[kk]]
[16:20:33.008]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.008]                     next
[16:20:33.008]                   args[[name]] <- ""
[16:20:33.008]                 }
[16:20:33.008]                 NAMES <- toupper(removed)
[16:20:33.008]                 for (kk in seq_along(NAMES)) {
[16:20:33.008]                   name <- removed[[kk]]
[16:20:33.008]                   NAME <- NAMES[[kk]]
[16:20:33.008]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.008]                     next
[16:20:33.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.008]                 }
[16:20:33.008]                 if (length(args) > 0) 
[16:20:33.008]                   base::do.call(base::Sys.setenv, args = args)
[16:20:33.008]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:33.008]             }
[16:20:33.008]             else {
[16:20:33.008]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:33.008]             }
[16:20:33.008]             {
[16:20:33.008]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:33.008]                   0L) {
[16:20:33.008]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:33.008]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:33.008]                   base::options(opts)
[16:20:33.008]                 }
[16:20:33.008]                 {
[16:20:33.008]                   {
[16:20:33.008]                     NULL
[16:20:33.008]                     RNGkind("Mersenne-Twister")
[16:20:33.008]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:33.008]                       inherits = FALSE)
[16:20:33.008]                   }
[16:20:33.008]                   options(future.plan = NULL)
[16:20:33.008]                   if (is.na(NA_character_)) 
[16:20:33.008]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.008]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:33.008]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:33.008]                     .init = FALSE)
[16:20:33.008]                 }
[16:20:33.008]             }
[16:20:33.008]         }
[16:20:33.008]     })
[16:20:33.008]     if (TRUE) {
[16:20:33.008]         base::sink(type = "output", split = FALSE)
[16:20:33.008]         if (TRUE) {
[16:20:33.008]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:33.008]         }
[16:20:33.008]         else {
[16:20:33.008]             ...future.result["stdout"] <- base::list(NULL)
[16:20:33.008]         }
[16:20:33.008]         base::close(...future.stdout)
[16:20:33.008]         ...future.stdout <- NULL
[16:20:33.008]     }
[16:20:33.008]     ...future.result$conditions <- ...future.conditions
[16:20:33.008]     ...future.result$finished <- base::Sys.time()
[16:20:33.008]     ...future.result
[16:20:33.008] }
[16:20:33.010] plan(): Setting new future strategy stack:
[16:20:33.010] List of future strategies:
[16:20:33.010] 1. sequential:
[16:20:33.010]    - args: function (..., envir = parent.frame())
[16:20:33.010]    - tweaked: FALSE
[16:20:33.010]    - call: NULL
[16:20:33.010] plan(): nbrOfWorkers() = 1
[16:20:33.011] plan(): Setting new future strategy stack:
[16:20:33.011] List of future strategies:
[16:20:33.011] 1. sequential:
[16:20:33.011]    - args: function (..., envir = parent.frame())
[16:20:33.011]    - tweaked: FALSE
[16:20:33.011]    - call: plan(strategy)
[16:20:33.011] plan(): nbrOfWorkers() = 1
[16:20:33.012] SequentialFuture started (and completed)
[16:20:33.012] - Launch lazy future ... done
[16:20:33.012] run() for ‘SequentialFuture’ ... done
d = 1
** Nested future assignments
[16:20:33.012] getGlobalsAndPackages() ...
[16:20:33.012] Searching for globals...
[16:20:33.016] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[16:20:33.016] Searching for globals ... DONE
[16:20:33.016] Resolving globals: FALSE
[16:20:33.016] 
[16:20:33.016] - packages: [1] ‘future’
[16:20:33.016] getGlobalsAndPackages() ... DONE
[16:20:33.017] run() for ‘Future’ ...
[16:20:33.017] - state: ‘created’
[16:20:33.017] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:33.017] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:33.017] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:33.017]   - Field: ‘label’
[16:20:33.017]   - Field: ‘local’
[16:20:33.017]   - Field: ‘owner’
[16:20:33.018]   - Field: ‘envir’
[16:20:33.018]   - Field: ‘packages’
[16:20:33.018]   - Field: ‘gc’
[16:20:33.018]   - Field: ‘conditions’
[16:20:33.018]   - Field: ‘expr’
[16:20:33.018]   - Field: ‘uuid’
[16:20:33.018]   - Field: ‘seed’
[16:20:33.018]   - Field: ‘version’
[16:20:33.018]   - Field: ‘result’
[16:20:33.018]   - Field: ‘asynchronous’
[16:20:33.018]   - Field: ‘calls’
[16:20:33.018]   - Field: ‘globals’
[16:20:33.019]   - Field: ‘stdout’
[16:20:33.019]   - Field: ‘earlySignal’
[16:20:33.019]   - Field: ‘lazy’
[16:20:33.019]   - Field: ‘state’
[16:20:33.019] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:33.019] - Launch lazy future ...
[16:20:33.019] Packages needed by the future expression (n = 1): ‘future’
[16:20:33.019] Packages needed by future strategies (n = 0): <none>
[16:20:33.020] {
[16:20:33.020]     {
[16:20:33.020]         {
[16:20:33.020]             ...future.startTime <- base::Sys.time()
[16:20:33.020]             {
[16:20:33.020]                 {
[16:20:33.020]                   {
[16:20:33.020]                     {
[16:20:33.020]                       base::local({
[16:20:33.020]                         has_future <- base::requireNamespace("future", 
[16:20:33.020]                           quietly = TRUE)
[16:20:33.020]                         if (has_future) {
[16:20:33.020]                           ns <- base::getNamespace("future")
[16:20:33.020]                           version <- ns[[".package"]][["version"]]
[16:20:33.020]                           if (is.null(version)) 
[16:20:33.020]                             version <- utils::packageVersion("future")
[16:20:33.020]                         }
[16:20:33.020]                         else {
[16:20:33.020]                           version <- NULL
[16:20:33.020]                         }
[16:20:33.020]                         if (!has_future || version < "1.8.0") {
[16:20:33.020]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:33.020]                             "", base::R.version$version.string), 
[16:20:33.020]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:33.020]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:33.020]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:33.020]                               "release", "version")], collapse = " "), 
[16:20:33.020]                             hostname = base::Sys.info()[["nodename"]])
[16:20:33.020]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:33.020]                             info)
[16:20:33.020]                           info <- base::paste(info, collapse = "; ")
[16:20:33.020]                           if (!has_future) {
[16:20:33.020]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:33.020]                               info)
[16:20:33.020]                           }
[16:20:33.020]                           else {
[16:20:33.020]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:33.020]                               info, version)
[16:20:33.020]                           }
[16:20:33.020]                           base::stop(msg)
[16:20:33.020]                         }
[16:20:33.020]                       })
[16:20:33.020]                     }
[16:20:33.020]                     base::local({
[16:20:33.020]                       for (pkg in "future") {
[16:20:33.020]                         base::loadNamespace(pkg)
[16:20:33.020]                         base::library(pkg, character.only = TRUE)
[16:20:33.020]                       }
[16:20:33.020]                     })
[16:20:33.020]                   }
[16:20:33.020]                   ...future.strategy.old <- future::plan("list")
[16:20:33.020]                   options(future.plan = NULL)
[16:20:33.020]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.020]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:33.020]                 }
[16:20:33.020]                 ...future.workdir <- getwd()
[16:20:33.020]             }
[16:20:33.020]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:33.020]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:33.020]         }
[16:20:33.020]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:33.020]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:33.020]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:33.020]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:33.020]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:33.020]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:33.020]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:33.020]             base::names(...future.oldOptions))
[16:20:33.020]     }
[16:20:33.020]     if (FALSE) {
[16:20:33.020]     }
[16:20:33.020]     else {
[16:20:33.020]         if (TRUE) {
[16:20:33.020]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:33.020]                 open = "w")
[16:20:33.020]         }
[16:20:33.020]         else {
[16:20:33.020]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:33.020]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:33.020]         }
[16:20:33.020]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:33.020]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:33.020]             base::sink(type = "output", split = FALSE)
[16:20:33.020]             base::close(...future.stdout)
[16:20:33.020]         }, add = TRUE)
[16:20:33.020]     }
[16:20:33.020]     ...future.frame <- base::sys.nframe()
[16:20:33.020]     ...future.conditions <- base::list()
[16:20:33.020]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:33.020]     if (FALSE) {
[16:20:33.020]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:33.020]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:33.020]     }
[16:20:33.020]     ...future.result <- base::tryCatch({
[16:20:33.020]         base::withCallingHandlers({
[16:20:33.020]             ...future.value <- base::withVisible(base::local({
[16:20:33.020]                 b <- 1
[16:20:33.020]                 c %<-% 2
[16:20:33.020]                 d <- 3
[16:20:33.020]                 4 %->% e
[16:20:33.020]                 b + c + d + e
[16:20:33.020]             }))
[16:20:33.020]             future::FutureResult(value = ...future.value$value, 
[16:20:33.020]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.020]                   ...future.rng), globalenv = if (FALSE) 
[16:20:33.020]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:33.020]                     ...future.globalenv.names))
[16:20:33.020]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:33.020]         }, condition = base::local({
[16:20:33.020]             c <- base::c
[16:20:33.020]             inherits <- base::inherits
[16:20:33.020]             invokeRestart <- base::invokeRestart
[16:20:33.020]             length <- base::length
[16:20:33.020]             list <- base::list
[16:20:33.020]             seq.int <- base::seq.int
[16:20:33.020]             signalCondition <- base::signalCondition
[16:20:33.020]             sys.calls <- base::sys.calls
[16:20:33.020]             `[[` <- base::`[[`
[16:20:33.020]             `+` <- base::`+`
[16:20:33.020]             `<<-` <- base::`<<-`
[16:20:33.020]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:33.020]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:33.020]                   3L)]
[16:20:33.020]             }
[16:20:33.020]             function(cond) {
[16:20:33.020]                 is_error <- inherits(cond, "error")
[16:20:33.020]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:33.020]                   NULL)
[16:20:33.020]                 if (is_error) {
[16:20:33.020]                   sessionInformation <- function() {
[16:20:33.020]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:33.020]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:33.020]                       search = base::search(), system = base::Sys.info())
[16:20:33.020]                   }
[16:20:33.020]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.020]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:33.020]                     cond$call), session = sessionInformation(), 
[16:20:33.020]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:33.020]                   signalCondition(cond)
[16:20:33.020]                 }
[16:20:33.020]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:33.020]                 "immediateCondition"))) {
[16:20:33.020]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:33.020]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.020]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:33.020]                   if (TRUE && !signal) {
[16:20:33.020]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.020]                     {
[16:20:33.020]                       inherits <- base::inherits
[16:20:33.020]                       invokeRestart <- base::invokeRestart
[16:20:33.020]                       is.null <- base::is.null
[16:20:33.020]                       muffled <- FALSE
[16:20:33.020]                       if (inherits(cond, "message")) {
[16:20:33.020]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.020]                         if (muffled) 
[16:20:33.020]                           invokeRestart("muffleMessage")
[16:20:33.020]                       }
[16:20:33.020]                       else if (inherits(cond, "warning")) {
[16:20:33.020]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.020]                         if (muffled) 
[16:20:33.020]                           invokeRestart("muffleWarning")
[16:20:33.020]                       }
[16:20:33.020]                       else if (inherits(cond, "condition")) {
[16:20:33.020]                         if (!is.null(pattern)) {
[16:20:33.020]                           computeRestarts <- base::computeRestarts
[16:20:33.020]                           grepl <- base::grepl
[16:20:33.020]                           restarts <- computeRestarts(cond)
[16:20:33.020]                           for (restart in restarts) {
[16:20:33.020]                             name <- restart$name
[16:20:33.020]                             if (is.null(name)) 
[16:20:33.020]                               next
[16:20:33.020]                             if (!grepl(pattern, name)) 
[16:20:33.020]                               next
[16:20:33.020]                             invokeRestart(restart)
[16:20:33.020]                             muffled <- TRUE
[16:20:33.020]                             break
[16:20:33.020]                           }
[16:20:33.020]                         }
[16:20:33.020]                       }
[16:20:33.020]                       invisible(muffled)
[16:20:33.020]                     }
[16:20:33.020]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.020]                   }
[16:20:33.020]                 }
[16:20:33.020]                 else {
[16:20:33.020]                   if (TRUE) {
[16:20:33.020]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.020]                     {
[16:20:33.020]                       inherits <- base::inherits
[16:20:33.020]                       invokeRestart <- base::invokeRestart
[16:20:33.020]                       is.null <- base::is.null
[16:20:33.020]                       muffled <- FALSE
[16:20:33.020]                       if (inherits(cond, "message")) {
[16:20:33.020]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.020]                         if (muffled) 
[16:20:33.020]                           invokeRestart("muffleMessage")
[16:20:33.020]                       }
[16:20:33.020]                       else if (inherits(cond, "warning")) {
[16:20:33.020]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.020]                         if (muffled) 
[16:20:33.020]                           invokeRestart("muffleWarning")
[16:20:33.020]                       }
[16:20:33.020]                       else if (inherits(cond, "condition")) {
[16:20:33.020]                         if (!is.null(pattern)) {
[16:20:33.020]                           computeRestarts <- base::computeRestarts
[16:20:33.020]                           grepl <- base::grepl
[16:20:33.020]                           restarts <- computeRestarts(cond)
[16:20:33.020]                           for (restart in restarts) {
[16:20:33.020]                             name <- restart$name
[16:20:33.020]                             if (is.null(name)) 
[16:20:33.020]                               next
[16:20:33.020]                             if (!grepl(pattern, name)) 
[16:20:33.020]                               next
[16:20:33.020]                             invokeRestart(restart)
[16:20:33.020]                             muffled <- TRUE
[16:20:33.020]                             break
[16:20:33.020]                           }
[16:20:33.020]                         }
[16:20:33.020]                       }
[16:20:33.020]                       invisible(muffled)
[16:20:33.020]                     }
[16:20:33.020]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.020]                   }
[16:20:33.020]                 }
[16:20:33.020]             }
[16:20:33.020]         }))
[16:20:33.020]     }, error = function(ex) {
[16:20:33.020]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:33.020]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.020]                 ...future.rng), started = ...future.startTime, 
[16:20:33.020]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:33.020]             version = "1.8"), class = "FutureResult")
[16:20:33.020]     }, finally = {
[16:20:33.020]         if (!identical(...future.workdir, getwd())) 
[16:20:33.020]             setwd(...future.workdir)
[16:20:33.020]         {
[16:20:33.020]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:33.020]                 ...future.oldOptions$nwarnings <- NULL
[16:20:33.020]             }
[16:20:33.020]             base::options(...future.oldOptions)
[16:20:33.020]             if (.Platform$OS.type == "windows") {
[16:20:33.020]                 old_names <- names(...future.oldEnvVars)
[16:20:33.020]                 envs <- base::Sys.getenv()
[16:20:33.020]                 names <- names(envs)
[16:20:33.020]                 common <- intersect(names, old_names)
[16:20:33.020]                 added <- setdiff(names, old_names)
[16:20:33.020]                 removed <- setdiff(old_names, names)
[16:20:33.020]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:33.020]                   envs[common]]
[16:20:33.020]                 NAMES <- toupper(changed)
[16:20:33.020]                 args <- list()
[16:20:33.020]                 for (kk in seq_along(NAMES)) {
[16:20:33.020]                   name <- changed[[kk]]
[16:20:33.020]                   NAME <- NAMES[[kk]]
[16:20:33.020]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.020]                     next
[16:20:33.020]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.020]                 }
[16:20:33.020]                 NAMES <- toupper(added)
[16:20:33.020]                 for (kk in seq_along(NAMES)) {
[16:20:33.020]                   name <- added[[kk]]
[16:20:33.020]                   NAME <- NAMES[[kk]]
[16:20:33.020]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.020]                     next
[16:20:33.020]                   args[[name]] <- ""
[16:20:33.020]                 }
[16:20:33.020]                 NAMES <- toupper(removed)
[16:20:33.020]                 for (kk in seq_along(NAMES)) {
[16:20:33.020]                   name <- removed[[kk]]
[16:20:33.020]                   NAME <- NAMES[[kk]]
[16:20:33.020]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.020]                     next
[16:20:33.020]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.020]                 }
[16:20:33.020]                 if (length(args) > 0) 
[16:20:33.020]                   base::do.call(base::Sys.setenv, args = args)
[16:20:33.020]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:33.020]             }
[16:20:33.020]             else {
[16:20:33.020]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:33.020]             }
[16:20:33.020]             {
[16:20:33.020]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:33.020]                   0L) {
[16:20:33.020]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:33.020]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:33.020]                   base::options(opts)
[16:20:33.020]                 }
[16:20:33.020]                 {
[16:20:33.020]                   {
[16:20:33.020]                     NULL
[16:20:33.020]                     RNGkind("Mersenne-Twister")
[16:20:33.020]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:33.020]                       inherits = FALSE)
[16:20:33.020]                   }
[16:20:33.020]                   options(future.plan = NULL)
[16:20:33.020]                   if (is.na(NA_character_)) 
[16:20:33.020]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.020]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:33.020]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:33.020]                     .init = FALSE)
[16:20:33.020]                 }
[16:20:33.020]             }
[16:20:33.020]         }
[16:20:33.020]     })
[16:20:33.020]     if (TRUE) {
[16:20:33.020]         base::sink(type = "output", split = FALSE)
[16:20:33.020]         if (TRUE) {
[16:20:33.020]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:33.020]         }
[16:20:33.020]         else {
[16:20:33.020]             ...future.result["stdout"] <- base::list(NULL)
[16:20:33.020]         }
[16:20:33.020]         base::close(...future.stdout)
[16:20:33.020]         ...future.stdout <- NULL
[16:20:33.020]     }
[16:20:33.020]     ...future.result$conditions <- ...future.conditions
[16:20:33.020]     ...future.result$finished <- base::Sys.time()
[16:20:33.020]     ...future.result
[16:20:33.020] }
[16:20:33.022] plan(): Setting new future strategy stack:
[16:20:33.022] List of future strategies:
[16:20:33.022] 1. sequential:
[16:20:33.022]    - args: function (..., envir = parent.frame())
[16:20:33.022]    - tweaked: FALSE
[16:20:33.022]    - call: NULL
[16:20:33.022] plan(): nbrOfWorkers() = 1
[16:20:33.054] plan(): Setting new future strategy stack:
[16:20:33.054] List of future strategies:
[16:20:33.054] 1. sequential:
[16:20:33.054]    - args: function (..., envir = parent.frame())
[16:20:33.054]    - tweaked: FALSE
[16:20:33.054]    - call: plan(strategy)
[16:20:33.054] plan(): nbrOfWorkers() = 1
[16:20:33.055] SequentialFuture started (and completed)
[16:20:33.055] signalConditions() ...
[16:20:33.055]  - include = ‘immediateCondition’
[16:20:33.055]  - exclude = 
[16:20:33.055]  - resignal = FALSE
[16:20:33.055]  - Number of conditions: 88
[16:20:33.055] signalConditions() ... done
[16:20:33.055] - Launch lazy future ... done
[16:20:33.055] run() for ‘SequentialFuture’ ... done
[16:20:33.055] signalConditions() ...
[16:20:33.056]  - include = ‘immediateCondition’
[16:20:33.056]  - exclude = 
[16:20:33.056]  - resignal = FALSE
[16:20:33.056]  - Number of conditions: 88
[16:20:33.056] signalConditions() ... done
[16:20:33.056] Future state: ‘finished’
[16:20:33.056] signalConditions() ...
[16:20:33.056]  - include = ‘condition’
[16:20:33.056]  - exclude = ‘immediateCondition’
[16:20:33.056]  - resignal = TRUE
[16:20:33.057]  - Number of conditions: 88
[16:20:33.057]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.023] getGlobalsAndPackages() ...
[16:20:33.057]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.023] Searching for globals...
[16:20:33.057]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.036] 
[16:20:33.057]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.036] Searching for globals ... DONE
[16:20:33.057]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.037] - globals: [0] <none>
[16:20:33.057]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.037] getGlobalsAndPackages() ... DONE
[16:20:33.057]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.037] run() for ‘Future’ ...
[16:20:33.058]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.037] - state: ‘created’
[16:20:33.058]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.037] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:33.058]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.037] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:33.058]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.037] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:33.058]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.038]   - Field: ‘label’
[16:20:33.058]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.038]   - Field: ‘local’
[16:20:33.058]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.038]   - Field: ‘owner’
[16:20:33.058]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.038]   - Field: ‘envir’
[16:20:33.059]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.038]   - Field: ‘packages’
[16:20:33.059]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.038]   - Field: ‘gc’
[16:20:33.059]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.038]   - Field: ‘conditions’
[16:20:33.059]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.038]   - Field: ‘expr’
[16:20:33.059]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.038]   - Field: ‘uuid’
[16:20:33.059]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.039]   - Field: ‘seed’
[16:20:33.059]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.039]   - Field: ‘version’
[16:20:33.059]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.039]   - Field: ‘result’
[16:20:33.060]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.039]   - Field: ‘asynchronous’
[16:20:33.060]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.039]   - Field: ‘calls’
[16:20:33.060]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.039]   - Field: ‘globals’
[16:20:33.060]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.039]   - Field: ‘stdout’
[16:20:33.060]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.039]   - Field: ‘earlySignal’
[16:20:33.060]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.039]   - Field: ‘lazy’
[16:20:33.060]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.040]   - Field: ‘state’
[16:20:33.060]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.040] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:33.061]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.040] - Launch lazy future ...
[16:20:33.061]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.040] Packages needed by the future expression (n = 0): <none>
[16:20:33.061]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.040] Packages needed by future strategies (n = 0): <none>
[16:20:33.061]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.040] {
[16:20:33.040]     {
[16:20:33.040]         {
[16:20:33.040]             ...future.startTime <- base::Sys.time()
[16:20:33.040]             {
[16:20:33.040]                 {
[16:20:33.040]                   {
[16:20:33.040]                     base::local({
[16:20:33.040]                       has_future <- base::requireNamespace("future", 
[16:20:33.040]                         quietly = TRUE)
[16:20:33.040]                       if (has_future) {
[16:20:33.040]                         ns <- base::getNamespace("future")
[16:20:33.040]                         version <- ns[[".package"]][["version"]]
[16:20:33.040]                         if (is.null(version)) 
[16:20:33.040]                           version <- utils::packageVersion("future")
[16:20:33.040]                       }
[16:20:33.040]                       else {
[16:20:33.040]                         version <- NULL
[16:20:33.040]                       }
[16:20:33.040]                       if (!has_future || version < "1.8.0") {
[16:20:33.040]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:33.040]                           "", base::R.version$version.string), 
[16:20:33.040]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:33.040]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:33.040]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:33.040]                             "release", "version")], collapse = " "), 
[16:20:33.040]                           hostname = base::Sys.info()[["nodename"]])
[16:20:33.040]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:33.040]                           info)
[16:20:33.040]                         info <- base::paste(info, collapse = "; ")
[16:20:33.040]                         if (!has_future) {
[16:20:33.040]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:33.040]                             info)
[16:20:33.040]                         }
[16:20:33.040]                         else {
[16:20:33.040]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:33.040]                             info, version)
[16:20:33.040]                         }
[16:20:33.040]                         base::stop(msg)
[16:20:33.040]                       }
[16:20:33.040]                     })
[16:20:33.040]                   }
[16:20:33.040]                   ...future.strategy.old <- future::plan("list")
[16:20:33.040]                   options(future.plan = NULL)
[16:20:33.040]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.040]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:33.040]                 }
[16:20:33.040]                 ...future.workdir <- getwd()
[16:20:33.040]             }
[16:20:33.040]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:33.040]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:33.040]         }
[16:20:33.040]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:33.040]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:33.040]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:33.040]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:33.040]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:33.040]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:33.040]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:33.040]             base::names(...future.oldOptions))
[16:20:33.040]     }
[16:20:33.040]     if (FALSE) {
[16:20:33.040]     }
[16:20:33.040]     else {
[16:20:33.040]         if (TRUE) {
[16:20:33.040]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:33.040]                 open = "w")
[16:20:33.040]         }
[16:20:33.040]         else {
[16:20:33.040]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:33.040]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:33.040]         }
[16:20:33.040]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:33.040]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:33.040]             base::sink(type = "output", split = FALSE)
[16:20:33.040]             base::close(...future.stdout)
[16:20:33.040]         }, add = TRUE)
[16:20:33.040]     }
[16:20:33.040]     ...future.frame <- base::sys.nframe()
[16:20:33.040]     ...future.conditions <- base::list()
[16:20:33.040]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:33.040]     if (FALSE) {
[16:20:33.040]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:33.040]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:33.040]     }
[16:20:33.040]     ...future.result <- base::tryCatch({
[16:20:33.040]         base::withCallingHandlers({
[16:20:33.040]             ...future.value <- base::withVisible(base::local(2))
[16:20:33.040]             future::FutureResult(value = ...future.value$value, 
[16:20:33.040]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.040]                   ...future.rng), globalenv = if (FALSE) 
[16:20:33.040]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:33.040]                     ...future.globalenv.names))
[16:20:33.040]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:33.040]         }, condition = base::local({
[16:20:33.040]             c <- base::c
[16:20:33.040]             inherits <- base::inherits
[16:20:33.040]             invokeRestart <- base::invokeRestart
[16:20:33.040]             length <- base::length
[16:20:33.040]             list <- base::list
[16:20:33.040]             seq.int <- base::seq.int
[16:20:33.040]             signalCondition <- base::signalCondition
[16:20:33.040]             sys.calls <- base::sys.calls
[16:20:33.040]             `[[` <- base::`[[`
[16:20:33.040]             `+` <- base::`+`
[16:20:33.040]             `<<-` <- base::`<<-`
[16:20:33.040]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:33.040]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:33.040]                   3L)]
[16:20:33.040]             }
[16:20:33.040]             function(cond) {
[16:20:33.040]                 is_error <- inherits(cond, "error")
[16:20:33.040]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:33.040]                   NULL)
[16:20:33.040]                 if (is_error) {
[16:20:33.040]                   sessionInformation <- function() {
[16:20:33.040]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:33.040]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:33.040]                       search = base::search(), system = base::Sys.info())
[16:20:33.040]                   }
[16:20:33.040]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.040]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:33.040]                     cond$call), session = sessionInformation(), 
[16:20:33.040]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:33.040]                   signalCondition(cond)
[16:20:33.040]                 }
[16:20:33.040]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:33.040]                 "immediateCondition"))) {
[16:20:33.040]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:33.040]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.040]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:33.040]                   if (TRUE && !signal) {
[16:20:33.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.040]                     {
[16:20:33.040]                       inherits <- base::inherits
[16:20:33.040]                       invokeRestart <- base::invokeRestart
[16:20:33.040]                       is.null <- base::is.null
[16:20:33.040]                       muffled <- FALSE
[16:20:33.040]                       if (inherits(cond, "message")) {
[16:20:33.040]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.040]                         if (muffled) 
[16:20:33.040]                           invokeRestart("muffleMessage")
[16:20:33.040]                       }
[16:20:33.040]                       else if (inherits(cond, "warning")) {
[16:20:33.040]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.040]                         if (muffled) 
[16:20:33.040]                           invokeRestart("muffleWarning")
[16:20:33.040]                       }
[16:20:33.040]                       else if (inherits(cond, "condition")) {
[16:20:33.040]                         if (!is.null(pattern)) {
[16:20:33.040]                           computeRestarts <- base::computeRestarts
[16:20:33.040]                           grepl <- base::grepl
[16:20:33.040]                           restarts <- computeRestarts(cond)
[16:20:33.040]                           for (restart in restarts) {
[16:20:33.040]                             name <- restart$name
[16:20:33.040]                             if (is.null(name)) 
[16:20:33.040]                               next
[16:20:33.040]                             if (!grepl(pattern, name)) 
[16:20:33.040]                               next
[16:20:33.040]                             invokeRestart(restart)
[16:20:33.040]                             muffled <- TRUE
[16:20:33.040]                             break
[16:20:33.040]                           }
[16:20:33.040]                         }
[16:20:33.040]                       }
[16:20:33.040]                       invisible(muffled)
[16:20:33.040]                     }
[16:20:33.040]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.040]                   }
[16:20:33.040]                 }
[16:20:33.040]                 else {
[16:20:33.040]                   if (TRUE) {
[16:20:33.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.040]                     {
[16:20:33.040]                       inherits <- base::inherits
[16:20:33.040]                       invokeRestart <- base::invokeRestart
[16:20:33.040]                       is.null <- base::is.null
[16:20:33.040]                       muffled <- FALSE
[16:20:33.040]                       if (inherits(cond, "message")) {
[16:20:33.040]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.040]                         if (muffled) 
[16:20:33.040]                           invokeRestart("muffleMessage")
[16:20:33.040]                       }
[16:20:33.040]                       else if (inherits(cond, "warning")) {
[16:20:33.040]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.040]                         if (muffled) 
[16:20:33.040]                           invokeRestart("muffleWarning")
[16:20:33.040]                       }
[16:20:33.040]                       else if (inherits(cond, "condition")) {
[16:20:33.040]                         if (!is.null(pattern)) {
[16:20:33.040]                           computeRestarts <- base::computeRestarts
[16:20:33.040]                           grepl <- base::grepl
[16:20:33.040]                           restarts <- computeRestarts(cond)
[16:20:33.040]                           for (restart in restarts) {
[16:20:33.040]                             name <- restart$name
[16:20:33.040]                             if (is.null(name)) 
[16:20:33.040]                               next
[16:20:33.040]                             if (!grepl(pattern, name)) 
[16:20:33.040]                               next
[16:20:33.040]                             invokeRestart(restart)
[16:20:33.040]                             muffled <- TRUE
[16:20:33.040]                             break
[16:20:33.040]                           }
[16:20:33.040]                         }
[16:20:33.040]                       }
[16:20:33.040]                       invisible(muffled)
[16:20:33.040]                     }
[16:20:33.040]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.040]                   }
[16:20:33.040]                 }
[16:20:33.040]             }
[16:20:33.040]         }))
[16:20:33.040]     }, error = function(ex) {
[16:20:33.040]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:33.040]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.040]                 ...future.rng), started = ...future.startTime, 
[16:20:33.040]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:33.040]             version = "1.8"), class = "FutureResult")
[16:20:33.040]     }, finally = {
[16:20:33.040]         if (!identical(...future.workdir, getwd())) 
[16:20:33.040]             setwd(...future.workdir)
[16:20:33.040]         {
[16:20:33.040]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:33.040]                 ...future.oldOptions$nwarnings <- NULL
[16:20:33.040]             }
[16:20:33.040]             base::options(...future.oldOptions)
[16:20:33.040]             if (.Platform$OS.type == "windows") {
[16:20:33.040]                 old_names <- names(...future.oldEnvVars)
[16:20:33.040]                 envs <- base::Sys.getenv()
[16:20:33.040]                 names <- names(envs)
[16:20:33.040]                 common <- intersect(names, old_names)
[16:20:33.040]                 added <- setdiff(names, old_names)
[16:20:33.040]                 removed <- setdiff(old_names, names)
[16:20:33.040]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:33.040]                   envs[common]]
[16:20:33.040]                 NAMES <- toupper(changed)
[16:20:33.040]                 args <- list()
[16:20:33.040]                 for (kk in seq_along(NAMES)) {
[16:20:33.040]                   name <- changed[[kk]]
[16:20:33.040]                   NAME <- NAMES[[kk]]
[16:20:33.040]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.040]                     next
[16:20:33.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.040]                 }
[16:20:33.040]                 NAMES <- toupper(added)
[16:20:33.040]                 for (kk in seq_along(NAMES)) {
[16:20:33.040]                   name <- added[[kk]]
[16:20:33.040]                   NAME <- NAMES[[kk]]
[16:20:33.040]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.040]                     next
[16:20:33.040]                   args[[name]] <- ""
[16:20:33.040]                 }
[16:20:33.040]                 NAMES <- toupper(removed)
[16:20:33.040]                 for (kk in seq_along(NAMES)) {
[16:20:33.040]                   name <- removed[[kk]]
[16:20:33.040]                   NAME <- NAMES[[kk]]
[16:20:33.040]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.040]                     next
[16:20:33.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.040]                 }
[16:20:33.040]                 if (length(args) > 0) 
[16:20:33.040]                   base::do.call(base::Sys.setenv, args = args)
[16:20:33.040]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:33.040]             }
[16:20:33.040]             else {
[16:20:33.040]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:33.040]             }
[16:20:33.040]             {
[16:20:33.040]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:33.040]                   0L) {
[16:20:33.040]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:33.040]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:33.040]                   base::options(opts)
[16:20:33.040]                 }
[16:20:33.040]                 {
[16:20:33.040]                   {
[16:20:33.040]                     NULL
[16:20:33.040]                     RNGkind("Mersenne-Twister")
[16:20:33.040]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:33.040]                       inherits = FALSE)
[16:20:33.040]                   }
[16:20:33.040]                   options(future.plan = NULL)
[16:20:33.040]                   if (is.na(NA_character_)) 
[16:20:33.040]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.040]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:33.040]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:33.040]                     .init = FALSE)
[16:20:33.040]                 }
[16:20:33.040]             }
[16:20:33.040]         }
[16:20:33.040]     })
[16:20:33.040]     if (TRUE) {
[16:20:33.040]         base::sink(type = "output", split = FALSE)
[16:20:33.040]         if (TRUE) {
[16:20:33.040]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:33.040]         }
[16:20:33.040]         else {
[16:20:33.040]             ...future.result["stdout"] <- base::list(NULL)
[16:20:33.040]         }
[16:20:33.040]         base::close(...future.stdout)
[16:20:33.040]         ...future.stdout <- NULL
[16:20:33.040]     }
[16:20:33.040]     ...future.result$conditions <- ...future.conditions
[16:20:33.040]     ...future.result$finished <- base::Sys.time()
[16:20:33.040]     ...future.result
[16:20:33.040] }
[16:20:33.061]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.043] plan(): Setting new future strategy stack:
[16:20:33.061]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.043] List of future strategies:
[16:20:33.043] 1. sequential:
[16:20:33.043]    - args: function (..., envir = parent.frame())
[16:20:33.043]    - tweaked: FALSE
[16:20:33.043]    - call: NULL
[16:20:33.061]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.044] plan(): nbrOfWorkers() = 1
[16:20:33.062]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.044] plan(): Setting new future strategy stack:
[16:20:33.062]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.044] List of future strategies:
[16:20:33.044] 1. sequential:
[16:20:33.044]    - args: function (..., envir = parent.frame())
[16:20:33.044]    - tweaked: FALSE
[16:20:33.044]    - call: NULL
[16:20:33.062]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.045] plan(): nbrOfWorkers() = 1
[16:20:33.062]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.045] SequentialFuture started (and completed)
[16:20:33.062]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.045] - Launch lazy future ... done
[16:20:33.062]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.045] run() for ‘SequentialFuture’ ... done
[16:20:33.062]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.045] getGlobalsAndPackages() ...
[16:20:33.062]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.046] Searching for globals...
[16:20:33.063]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.046] 
[16:20:33.063]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.046] Searching for globals ... DONE
[16:20:33.063]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.046] - globals: [0] <none>
[16:20:33.063]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.046] getGlobalsAndPackages() ... DONE
[16:20:33.063]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.046] run() for ‘Future’ ...
[16:20:33.063]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.046] - state: ‘created’
[16:20:33.063]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.047] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:33.063]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.047] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:33.064]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.047] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:33.064]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.047]   - Field: ‘label’
[16:20:33.064]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.047]   - Field: ‘local’
[16:20:33.064]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.047]   - Field: ‘owner’
[16:20:33.064]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.047]   - Field: ‘envir’
[16:20:33.064]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.048]   - Field: ‘packages’
[16:20:33.064]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.048]   - Field: ‘gc’
[16:20:33.065]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.048]   - Field: ‘conditions’
[16:20:33.065]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.048]   - Field: ‘expr’
[16:20:33.065]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.048]   - Field: ‘uuid’
[16:20:33.065]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.048]   - Field: ‘seed’
[16:20:33.065]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.048]   - Field: ‘version’
[16:20:33.065]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.048]   - Field: ‘result’
[16:20:33.066]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.048]   - Field: ‘asynchronous’
[16:20:33.067]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.048]   - Field: ‘calls’
[16:20:33.067]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.049]   - Field: ‘globals’
[16:20:33.067]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.049]   - Field: ‘stdout’
[16:20:33.067]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.049]   - Field: ‘earlySignal’
[16:20:33.067]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.049]   - Field: ‘lazy’
[16:20:33.067]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.049]   - Field: ‘state’
[16:20:33.067]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.049] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:33.068]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.049] - Launch lazy future ...
[16:20:33.068]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.049] Packages needed by the future expression (n = 0): <none>
[16:20:33.068]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.049] Packages needed by future strategies (n = 0): <none>
[16:20:33.068]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.050] {
[16:20:33.050]     {
[16:20:33.050]         {
[16:20:33.050]             ...future.startTime <- base::Sys.time()
[16:20:33.050]             {
[16:20:33.050]                 {
[16:20:33.050]                   {
[16:20:33.050]                     base::local({
[16:20:33.050]                       has_future <- base::requireNamespace("future", 
[16:20:33.050]                         quietly = TRUE)
[16:20:33.050]                       if (has_future) {
[16:20:33.050]                         ns <- base::getNamespace("future")
[16:20:33.050]                         version <- ns[[".package"]][["version"]]
[16:20:33.050]                         if (is.null(version)) 
[16:20:33.050]                           version <- utils::packageVersion("future")
[16:20:33.050]                       }
[16:20:33.050]                       else {
[16:20:33.050]                         version <- NULL
[16:20:33.050]                       }
[16:20:33.050]                       if (!has_future || version < "1.8.0") {
[16:20:33.050]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:33.050]                           "", base::R.version$version.string), 
[16:20:33.050]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:33.050]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:33.050]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:33.050]                             "release", "version")], collapse = " "), 
[16:20:33.050]                           hostname = base::Sys.info()[["nodename"]])
[16:20:33.050]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:33.050]                           info)
[16:20:33.050]                         info <- base::paste(info, collapse = "; ")
[16:20:33.050]                         if (!has_future) {
[16:20:33.050]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:33.050]                             info)
[16:20:33.050]                         }
[16:20:33.050]                         else {
[16:20:33.050]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:33.050]                             info, version)
[16:20:33.050]                         }
[16:20:33.050]                         base::stop(msg)
[16:20:33.050]                       }
[16:20:33.050]                     })
[16:20:33.050]                   }
[16:20:33.050]                   ...future.strategy.old <- future::plan("list")
[16:20:33.050]                   options(future.plan = NULL)
[16:20:33.050]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.050]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:33.050]                 }
[16:20:33.050]                 ...future.workdir <- getwd()
[16:20:33.050]             }
[16:20:33.050]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:33.050]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:33.050]         }
[16:20:33.050]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:33.050]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:33.050]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:33.050]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:33.050]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:33.050]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:33.050]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:33.050]             base::names(...future.oldOptions))
[16:20:33.050]     }
[16:20:33.050]     if (FALSE) {
[16:20:33.050]     }
[16:20:33.050]     else {
[16:20:33.050]         if (TRUE) {
[16:20:33.050]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:33.050]                 open = "w")
[16:20:33.050]         }
[16:20:33.050]         else {
[16:20:33.050]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:33.050]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:33.050]         }
[16:20:33.050]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:33.050]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:33.050]             base::sink(type = "output", split = FALSE)
[16:20:33.050]             base::close(...future.stdout)
[16:20:33.050]         }, add = TRUE)
[16:20:33.050]     }
[16:20:33.050]     ...future.frame <- base::sys.nframe()
[16:20:33.050]     ...future.conditions <- base::list()
[16:20:33.050]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:33.050]     if (FALSE) {
[16:20:33.050]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:33.050]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:33.050]     }
[16:20:33.050]     ...future.result <- base::tryCatch({
[16:20:33.050]         base::withCallingHandlers({
[16:20:33.050]             ...future.value <- base::withVisible(base::local(4))
[16:20:33.050]             future::FutureResult(value = ...future.value$value, 
[16:20:33.050]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.050]                   ...future.rng), globalenv = if (FALSE) 
[16:20:33.050]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:33.050]                     ...future.globalenv.names))
[16:20:33.050]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:33.050]         }, condition = base::local({
[16:20:33.050]             c <- base::c
[16:20:33.050]             inherits <- base::inherits
[16:20:33.050]             invokeRestart <- base::invokeRestart
[16:20:33.050]             length <- base::length
[16:20:33.050]             list <- base::list
[16:20:33.050]             seq.int <- base::seq.int
[16:20:33.050]             signalCondition <- base::signalCondition
[16:20:33.050]             sys.calls <- base::sys.calls
[16:20:33.050]             `[[` <- base::`[[`
[16:20:33.050]             `+` <- base::`+`
[16:20:33.050]             `<<-` <- base::`<<-`
[16:20:33.050]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:33.050]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:33.050]                   3L)]
[16:20:33.050]             }
[16:20:33.050]             function(cond) {
[16:20:33.050]                 is_error <- inherits(cond, "error")
[16:20:33.050]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:33.050]                   NULL)
[16:20:33.050]                 if (is_error) {
[16:20:33.050]                   sessionInformation <- function() {
[16:20:33.050]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:33.050]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:33.050]                       search = base::search(), system = base::Sys.info())
[16:20:33.050]                   }
[16:20:33.050]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.050]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:33.050]                     cond$call), session = sessionInformation(), 
[16:20:33.050]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:33.050]                   signalCondition(cond)
[16:20:33.050]                 }
[16:20:33.050]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:33.050]                 "immediateCondition"))) {
[16:20:33.050]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:33.050]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.050]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:33.050]                   if (TRUE && !signal) {
[16:20:33.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.050]                     {
[16:20:33.050]                       inherits <- base::inherits
[16:20:33.050]                       invokeRestart <- base::invokeRestart
[16:20:33.050]                       is.null <- base::is.null
[16:20:33.050]                       muffled <- FALSE
[16:20:33.050]                       if (inherits(cond, "message")) {
[16:20:33.050]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.050]                         if (muffled) 
[16:20:33.050]                           invokeRestart("muffleMessage")
[16:20:33.050]                       }
[16:20:33.050]                       else if (inherits(cond, "warning")) {
[16:20:33.050]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.050]                         if (muffled) 
[16:20:33.050]                           invokeRestart("muffleWarning")
[16:20:33.050]                       }
[16:20:33.050]                       else if (inherits(cond, "condition")) {
[16:20:33.050]                         if (!is.null(pattern)) {
[16:20:33.050]                           computeRestarts <- base::computeRestarts
[16:20:33.050]                           grepl <- base::grepl
[16:20:33.050]                           restarts <- computeRestarts(cond)
[16:20:33.050]                           for (restart in restarts) {
[16:20:33.050]                             name <- restart$name
[16:20:33.050]                             if (is.null(name)) 
[16:20:33.050]                               next
[16:20:33.050]                             if (!grepl(pattern, name)) 
[16:20:33.050]                               next
[16:20:33.050]                             invokeRestart(restart)
[16:20:33.050]                             muffled <- TRUE
[16:20:33.050]                             break
[16:20:33.050]                           }
[16:20:33.050]                         }
[16:20:33.050]                       }
[16:20:33.050]                       invisible(muffled)
[16:20:33.050]                     }
[16:20:33.050]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.050]                   }
[16:20:33.050]                 }
[16:20:33.050]                 else {
[16:20:33.050]                   if (TRUE) {
[16:20:33.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.050]                     {
[16:20:33.050]                       inherits <- base::inherits
[16:20:33.050]                       invokeRestart <- base::invokeRestart
[16:20:33.050]                       is.null <- base::is.null
[16:20:33.050]                       muffled <- FALSE
[16:20:33.050]                       if (inherits(cond, "message")) {
[16:20:33.050]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.050]                         if (muffled) 
[16:20:33.050]                           invokeRestart("muffleMessage")
[16:20:33.050]                       }
[16:20:33.050]                       else if (inherits(cond, "warning")) {
[16:20:33.050]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.050]                         if (muffled) 
[16:20:33.050]                           invokeRestart("muffleWarning")
[16:20:33.050]                       }
[16:20:33.050]                       else if (inherits(cond, "condition")) {
[16:20:33.050]                         if (!is.null(pattern)) {
[16:20:33.050]                           computeRestarts <- base::computeRestarts
[16:20:33.050]                           grepl <- base::grepl
[16:20:33.050]                           restarts <- computeRestarts(cond)
[16:20:33.050]                           for (restart in restarts) {
[16:20:33.050]                             name <- restart$name
[16:20:33.050]                             if (is.null(name)) 
[16:20:33.050]                               next
[16:20:33.050]                             if (!grepl(pattern, name)) 
[16:20:33.050]                               next
[16:20:33.050]                             invokeRestart(restart)
[16:20:33.050]                             muffled <- TRUE
[16:20:33.050]                             break
[16:20:33.050]                           }
[16:20:33.050]                         }
[16:20:33.050]                       }
[16:20:33.050]                       invisible(muffled)
[16:20:33.050]                     }
[16:20:33.050]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.050]                   }
[16:20:33.050]                 }
[16:20:33.050]             }
[16:20:33.050]         }))
[16:20:33.050]     }, error = function(ex) {
[16:20:33.050]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:33.050]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.050]                 ...future.rng), started = ...future.startTime, 
[16:20:33.050]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:33.050]             version = "1.8"), class = "FutureResult")
[16:20:33.050]     }, finally = {
[16:20:33.050]         if (!identical(...future.workdir, getwd())) 
[16:20:33.050]             setwd(...future.workdir)
[16:20:33.050]         {
[16:20:33.050]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:33.050]                 ...future.oldOptions$nwarnings <- NULL
[16:20:33.050]             }
[16:20:33.050]             base::options(...future.oldOptions)
[16:20:33.050]             if (.Platform$OS.type == "windows") {
[16:20:33.050]                 old_names <- names(...future.oldEnvVars)
[16:20:33.050]                 envs <- base::Sys.getenv()
[16:20:33.050]                 names <- names(envs)
[16:20:33.050]                 common <- intersect(names, old_names)
[16:20:33.050]                 added <- setdiff(names, old_names)
[16:20:33.050]                 removed <- setdiff(old_names, names)
[16:20:33.050]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:33.050]                   envs[common]]
[16:20:33.050]                 NAMES <- toupper(changed)
[16:20:33.050]                 args <- list()
[16:20:33.050]                 for (kk in seq_along(NAMES)) {
[16:20:33.050]                   name <- changed[[kk]]
[16:20:33.050]                   NAME <- NAMES[[kk]]
[16:20:33.050]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.050]                     next
[16:20:33.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.050]                 }
[16:20:33.050]                 NAMES <- toupper(added)
[16:20:33.050]                 for (kk in seq_along(NAMES)) {
[16:20:33.050]                   name <- added[[kk]]
[16:20:33.050]                   NAME <- NAMES[[kk]]
[16:20:33.050]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.050]                     next
[16:20:33.050]                   args[[name]] <- ""
[16:20:33.050]                 }
[16:20:33.050]                 NAMES <- toupper(removed)
[16:20:33.050]                 for (kk in seq_along(NAMES)) {
[16:20:33.050]                   name <- removed[[kk]]
[16:20:33.050]                   NAME <- NAMES[[kk]]
[16:20:33.050]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.050]                     next
[16:20:33.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.050]                 }
[16:20:33.050]                 if (length(args) > 0) 
[16:20:33.050]                   base::do.call(base::Sys.setenv, args = args)
[16:20:33.050]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:33.050]             }
[16:20:33.050]             else {
[16:20:33.050]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:33.050]             }
[16:20:33.050]             {
[16:20:33.050]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:33.050]                   0L) {
[16:20:33.050]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:33.050]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:33.050]                   base::options(opts)
[16:20:33.050]                 }
[16:20:33.050]                 {
[16:20:33.050]                   {
[16:20:33.050]                     NULL
[16:20:33.050]                     RNGkind("Mersenne-Twister")
[16:20:33.050]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:33.050]                       inherits = FALSE)
[16:20:33.050]                   }
[16:20:33.050]                   options(future.plan = NULL)
[16:20:33.050]                   if (is.na(NA_character_)) 
[16:20:33.050]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.050]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:33.050]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:33.050]                     .init = FALSE)
[16:20:33.050]                 }
[16:20:33.050]             }
[16:20:33.050]         }
[16:20:33.050]     })
[16:20:33.050]     if (TRUE) {
[16:20:33.050]         base::sink(type = "output", split = FALSE)
[16:20:33.050]         if (TRUE) {
[16:20:33.050]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:33.050]         }
[16:20:33.050]         else {
[16:20:33.050]             ...future.result["stdout"] <- base::list(NULL)
[16:20:33.050]         }
[16:20:33.050]         base::close(...future.stdout)
[16:20:33.050]         ...future.stdout <- NULL
[16:20:33.050]     }
[16:20:33.050]     ...future.result$conditions <- ...future.conditions
[16:20:33.050]     ...future.result$finished <- base::Sys.time()
[16:20:33.050]     ...future.result
[16:20:33.050] }
[16:20:33.068]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.051] plan(): Setting new future strategy stack:
[16:20:33.068]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.052] List of future strategies:
[16:20:33.052] 1. sequential:
[16:20:33.052]    - args: function (..., envir = parent.frame())
[16:20:33.052]    - tweaked: FALSE
[16:20:33.052]    - call: NULL
[16:20:33.068]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.052] plan(): nbrOfWorkers() = 1
[16:20:33.069]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.053] plan(): Setting new future strategy stack:
[16:20:33.069]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.053] List of future strategies:
[16:20:33.053] 1. sequential:
[16:20:33.053]    - args: function (..., envir = parent.frame())
[16:20:33.053]    - tweaked: FALSE
[16:20:33.053]    - call: NULL
[16:20:33.069]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.053] plan(): nbrOfWorkers() = 1
[16:20:33.069]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.053] SequentialFuture started (and completed)
[16:20:33.069]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.053] - Launch lazy future ... done
[16:20:33.069]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.053] run() for ‘SequentialFuture’ ... done
[16:20:33.069] signalConditions() ... done
a = 10
[16:20:33.070] getGlobalsAndPackages() ...
[16:20:33.070] Searching for globals...
[16:20:33.070] - globals found: [3] ‘{’, ‘+’, ‘a’
[16:20:33.071] Searching for globals ... DONE
[16:20:33.071] Resolving globals: FALSE
[16:20:33.071] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:33.071] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:20:33.072] - globals: [1] ‘a’
[16:20:33.072] 
[16:20:33.072] getGlobalsAndPackages() ... DONE
[16:20:33.072] run() for ‘Future’ ...
[16:20:33.072] - state: ‘created’
[16:20:33.072] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:33.072] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:33.073] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:33.073]   - Field: ‘label’
[16:20:33.073]   - Field: ‘local’
[16:20:33.073]   - Field: ‘owner’
[16:20:33.073]   - Field: ‘envir’
[16:20:33.073]   - Field: ‘packages’
[16:20:33.073]   - Field: ‘gc’
[16:20:33.073]   - Field: ‘conditions’
[16:20:33.073]   - Field: ‘expr’
[16:20:33.073]   - Field: ‘uuid’
[16:20:33.073]   - Field: ‘seed’
[16:20:33.074]   - Field: ‘version’
[16:20:33.074]   - Field: ‘result’
[16:20:33.074]   - Field: ‘asynchronous’
[16:20:33.074]   - Field: ‘calls’
[16:20:33.074]   - Field: ‘globals’
[16:20:33.074]   - Field: ‘stdout’
[16:20:33.074]   - Field: ‘earlySignal’
[16:20:33.074]   - Field: ‘lazy’
[16:20:33.074]   - Field: ‘state’
[16:20:33.074] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:33.074] - Launch lazy future ...
[16:20:33.075] Packages needed by the future expression (n = 0): <none>
[16:20:33.075] Packages needed by future strategies (n = 0): <none>
[16:20:33.075] {
[16:20:33.075]     {
[16:20:33.075]         {
[16:20:33.075]             ...future.startTime <- base::Sys.time()
[16:20:33.075]             {
[16:20:33.075]                 {
[16:20:33.075]                   {
[16:20:33.075]                     base::local({
[16:20:33.075]                       has_future <- base::requireNamespace("future", 
[16:20:33.075]                         quietly = TRUE)
[16:20:33.075]                       if (has_future) {
[16:20:33.075]                         ns <- base::getNamespace("future")
[16:20:33.075]                         version <- ns[[".package"]][["version"]]
[16:20:33.075]                         if (is.null(version)) 
[16:20:33.075]                           version <- utils::packageVersion("future")
[16:20:33.075]                       }
[16:20:33.075]                       else {
[16:20:33.075]                         version <- NULL
[16:20:33.075]                       }
[16:20:33.075]                       if (!has_future || version < "1.8.0") {
[16:20:33.075]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:33.075]                           "", base::R.version$version.string), 
[16:20:33.075]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:33.075]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:33.075]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:33.075]                             "release", "version")], collapse = " "), 
[16:20:33.075]                           hostname = base::Sys.info()[["nodename"]])
[16:20:33.075]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:33.075]                           info)
[16:20:33.075]                         info <- base::paste(info, collapse = "; ")
[16:20:33.075]                         if (!has_future) {
[16:20:33.075]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:33.075]                             info)
[16:20:33.075]                         }
[16:20:33.075]                         else {
[16:20:33.075]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:33.075]                             info, version)
[16:20:33.075]                         }
[16:20:33.075]                         base::stop(msg)
[16:20:33.075]                       }
[16:20:33.075]                     })
[16:20:33.075]                   }
[16:20:33.075]                   ...future.strategy.old <- future::plan("list")
[16:20:33.075]                   options(future.plan = NULL)
[16:20:33.075]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.075]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:33.075]                 }
[16:20:33.075]                 ...future.workdir <- getwd()
[16:20:33.075]             }
[16:20:33.075]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:33.075]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:33.075]         }
[16:20:33.075]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:33.075]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:33.075]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:33.075]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:33.075]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:33.075]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:33.075]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:33.075]             base::names(...future.oldOptions))
[16:20:33.075]     }
[16:20:33.075]     if (FALSE) {
[16:20:33.075]     }
[16:20:33.075]     else {
[16:20:33.075]         if (TRUE) {
[16:20:33.075]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:33.075]                 open = "w")
[16:20:33.075]         }
[16:20:33.075]         else {
[16:20:33.075]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:33.075]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:33.075]         }
[16:20:33.075]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:33.075]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:33.075]             base::sink(type = "output", split = FALSE)
[16:20:33.075]             base::close(...future.stdout)
[16:20:33.075]         }, add = TRUE)
[16:20:33.075]     }
[16:20:33.075]     ...future.frame <- base::sys.nframe()
[16:20:33.075]     ...future.conditions <- base::list()
[16:20:33.075]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:33.075]     if (FALSE) {
[16:20:33.075]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:33.075]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:33.075]     }
[16:20:33.075]     ...future.result <- base::tryCatch({
[16:20:33.075]         base::withCallingHandlers({
[16:20:33.075]             ...future.value <- base::withVisible(base::local({
[16:20:33.075]                 a + 1
[16:20:33.075]             }))
[16:20:33.075]             future::FutureResult(value = ...future.value$value, 
[16:20:33.075]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.075]                   ...future.rng), globalenv = if (FALSE) 
[16:20:33.075]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:33.075]                     ...future.globalenv.names))
[16:20:33.075]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:33.075]         }, condition = base::local({
[16:20:33.075]             c <- base::c
[16:20:33.075]             inherits <- base::inherits
[16:20:33.075]             invokeRestart <- base::invokeRestart
[16:20:33.075]             length <- base::length
[16:20:33.075]             list <- base::list
[16:20:33.075]             seq.int <- base::seq.int
[16:20:33.075]             signalCondition <- base::signalCondition
[16:20:33.075]             sys.calls <- base::sys.calls
[16:20:33.075]             `[[` <- base::`[[`
[16:20:33.075]             `+` <- base::`+`
[16:20:33.075]             `<<-` <- base::`<<-`
[16:20:33.075]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:33.075]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:33.075]                   3L)]
[16:20:33.075]             }
[16:20:33.075]             function(cond) {
[16:20:33.075]                 is_error <- inherits(cond, "error")
[16:20:33.075]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:33.075]                   NULL)
[16:20:33.075]                 if (is_error) {
[16:20:33.075]                   sessionInformation <- function() {
[16:20:33.075]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:33.075]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:33.075]                       search = base::search(), system = base::Sys.info())
[16:20:33.075]                   }
[16:20:33.075]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.075]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:33.075]                     cond$call), session = sessionInformation(), 
[16:20:33.075]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:33.075]                   signalCondition(cond)
[16:20:33.075]                 }
[16:20:33.075]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:33.075]                 "immediateCondition"))) {
[16:20:33.075]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:33.075]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.075]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:33.075]                   if (TRUE && !signal) {
[16:20:33.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.075]                     {
[16:20:33.075]                       inherits <- base::inherits
[16:20:33.075]                       invokeRestart <- base::invokeRestart
[16:20:33.075]                       is.null <- base::is.null
[16:20:33.075]                       muffled <- FALSE
[16:20:33.075]                       if (inherits(cond, "message")) {
[16:20:33.075]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.075]                         if (muffled) 
[16:20:33.075]                           invokeRestart("muffleMessage")
[16:20:33.075]                       }
[16:20:33.075]                       else if (inherits(cond, "warning")) {
[16:20:33.075]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.075]                         if (muffled) 
[16:20:33.075]                           invokeRestart("muffleWarning")
[16:20:33.075]                       }
[16:20:33.075]                       else if (inherits(cond, "condition")) {
[16:20:33.075]                         if (!is.null(pattern)) {
[16:20:33.075]                           computeRestarts <- base::computeRestarts
[16:20:33.075]                           grepl <- base::grepl
[16:20:33.075]                           restarts <- computeRestarts(cond)
[16:20:33.075]                           for (restart in restarts) {
[16:20:33.075]                             name <- restart$name
[16:20:33.075]                             if (is.null(name)) 
[16:20:33.075]                               next
[16:20:33.075]                             if (!grepl(pattern, name)) 
[16:20:33.075]                               next
[16:20:33.075]                             invokeRestart(restart)
[16:20:33.075]                             muffled <- TRUE
[16:20:33.075]                             break
[16:20:33.075]                           }
[16:20:33.075]                         }
[16:20:33.075]                       }
[16:20:33.075]                       invisible(muffled)
[16:20:33.075]                     }
[16:20:33.075]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.075]                   }
[16:20:33.075]                 }
[16:20:33.075]                 else {
[16:20:33.075]                   if (TRUE) {
[16:20:33.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.075]                     {
[16:20:33.075]                       inherits <- base::inherits
[16:20:33.075]                       invokeRestart <- base::invokeRestart
[16:20:33.075]                       is.null <- base::is.null
[16:20:33.075]                       muffled <- FALSE
[16:20:33.075]                       if (inherits(cond, "message")) {
[16:20:33.075]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.075]                         if (muffled) 
[16:20:33.075]                           invokeRestart("muffleMessage")
[16:20:33.075]                       }
[16:20:33.075]                       else if (inherits(cond, "warning")) {
[16:20:33.075]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.075]                         if (muffled) 
[16:20:33.075]                           invokeRestart("muffleWarning")
[16:20:33.075]                       }
[16:20:33.075]                       else if (inherits(cond, "condition")) {
[16:20:33.075]                         if (!is.null(pattern)) {
[16:20:33.075]                           computeRestarts <- base::computeRestarts
[16:20:33.075]                           grepl <- base::grepl
[16:20:33.075]                           restarts <- computeRestarts(cond)
[16:20:33.075]                           for (restart in restarts) {
[16:20:33.075]                             name <- restart$name
[16:20:33.075]                             if (is.null(name)) 
[16:20:33.075]                               next
[16:20:33.075]                             if (!grepl(pattern, name)) 
[16:20:33.075]                               next
[16:20:33.075]                             invokeRestart(restart)
[16:20:33.075]                             muffled <- TRUE
[16:20:33.075]                             break
[16:20:33.075]                           }
[16:20:33.075]                         }
[16:20:33.075]                       }
[16:20:33.075]                       invisible(muffled)
[16:20:33.075]                     }
[16:20:33.075]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.075]                   }
[16:20:33.075]                 }
[16:20:33.075]             }
[16:20:33.075]         }))
[16:20:33.075]     }, error = function(ex) {
[16:20:33.075]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:33.075]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.075]                 ...future.rng), started = ...future.startTime, 
[16:20:33.075]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:33.075]             version = "1.8"), class = "FutureResult")
[16:20:33.075]     }, finally = {
[16:20:33.075]         if (!identical(...future.workdir, getwd())) 
[16:20:33.075]             setwd(...future.workdir)
[16:20:33.075]         {
[16:20:33.075]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:33.075]                 ...future.oldOptions$nwarnings <- NULL
[16:20:33.075]             }
[16:20:33.075]             base::options(...future.oldOptions)
[16:20:33.075]             if (.Platform$OS.type == "windows") {
[16:20:33.075]                 old_names <- names(...future.oldEnvVars)
[16:20:33.075]                 envs <- base::Sys.getenv()
[16:20:33.075]                 names <- names(envs)
[16:20:33.075]                 common <- intersect(names, old_names)
[16:20:33.075]                 added <- setdiff(names, old_names)
[16:20:33.075]                 removed <- setdiff(old_names, names)
[16:20:33.075]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:33.075]                   envs[common]]
[16:20:33.075]                 NAMES <- toupper(changed)
[16:20:33.075]                 args <- list()
[16:20:33.075]                 for (kk in seq_along(NAMES)) {
[16:20:33.075]                   name <- changed[[kk]]
[16:20:33.075]                   NAME <- NAMES[[kk]]
[16:20:33.075]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.075]                     next
[16:20:33.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.075]                 }
[16:20:33.075]                 NAMES <- toupper(added)
[16:20:33.075]                 for (kk in seq_along(NAMES)) {
[16:20:33.075]                   name <- added[[kk]]
[16:20:33.075]                   NAME <- NAMES[[kk]]
[16:20:33.075]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.075]                     next
[16:20:33.075]                   args[[name]] <- ""
[16:20:33.075]                 }
[16:20:33.075]                 NAMES <- toupper(removed)
[16:20:33.075]                 for (kk in seq_along(NAMES)) {
[16:20:33.075]                   name <- removed[[kk]]
[16:20:33.075]                   NAME <- NAMES[[kk]]
[16:20:33.075]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.075]                     next
[16:20:33.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.075]                 }
[16:20:33.075]                 if (length(args) > 0) 
[16:20:33.075]                   base::do.call(base::Sys.setenv, args = args)
[16:20:33.075]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:33.075]             }
[16:20:33.075]             else {
[16:20:33.075]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:33.075]             }
[16:20:33.075]             {
[16:20:33.075]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:33.075]                   0L) {
[16:20:33.075]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:33.075]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:33.075]                   base::options(opts)
[16:20:33.075]                 }
[16:20:33.075]                 {
[16:20:33.075]                   {
[16:20:33.075]                     NULL
[16:20:33.075]                     RNGkind("Mersenne-Twister")
[16:20:33.075]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:33.075]                       inherits = FALSE)
[16:20:33.075]                   }
[16:20:33.075]                   options(future.plan = NULL)
[16:20:33.075]                   if (is.na(NA_character_)) 
[16:20:33.075]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.075]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:33.075]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:33.075]                     .init = FALSE)
[16:20:33.075]                 }
[16:20:33.075]             }
[16:20:33.075]         }
[16:20:33.075]     })
[16:20:33.075]     if (TRUE) {
[16:20:33.075]         base::sink(type = "output", split = FALSE)
[16:20:33.075]         if (TRUE) {
[16:20:33.075]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:33.075]         }
[16:20:33.075]         else {
[16:20:33.075]             ...future.result["stdout"] <- base::list(NULL)
[16:20:33.075]         }
[16:20:33.075]         base::close(...future.stdout)
[16:20:33.075]         ...future.stdout <- NULL
[16:20:33.075]     }
[16:20:33.075]     ...future.result$conditions <- ...future.conditions
[16:20:33.075]     ...future.result$finished <- base::Sys.time()
[16:20:33.075]     ...future.result
[16:20:33.075] }
[16:20:33.077] assign_globals() ...
[16:20:33.077] List of 1
[16:20:33.077]  $ a: num 10
[16:20:33.077]  - attr(*, "where")=List of 1
[16:20:33.077]   ..$ a:<environment: R_EmptyEnv> 
[16:20:33.077]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:33.077]  - attr(*, "resolved")= logi FALSE
[16:20:33.077]  - attr(*, "total_size")= num 56
[16:20:33.077]  - attr(*, "already-done")= logi TRUE
[16:20:33.079] - copied ‘a’ to environment
[16:20:33.079] assign_globals() ... done
[16:20:33.079] plan(): Setting new future strategy stack:
[16:20:33.080] List of future strategies:
[16:20:33.080] 1. sequential:
[16:20:33.080]    - args: function (..., envir = parent.frame())
[16:20:33.080]    - tweaked: FALSE
[16:20:33.080]    - call: NULL
[16:20:33.080] plan(): nbrOfWorkers() = 1
[16:20:33.081] plan(): Setting new future strategy stack:
[16:20:33.081] List of future strategies:
[16:20:33.081] 1. sequential:
[16:20:33.081]    - args: function (..., envir = parent.frame())
[16:20:33.081]    - tweaked: FALSE
[16:20:33.081]    - call: plan(strategy)
[16:20:33.081] plan(): nbrOfWorkers() = 1
[16:20:33.081] SequentialFuture started (and completed)
[16:20:33.081] - Launch lazy future ... done
[16:20:33.081] run() for ‘SequentialFuture’ ... done
b = 11
*** %<-% with ‘sequential’ futures ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
*** %<-% with ‘multicore’ futures ...
[16:20:33.086] plan(): Setting new future strategy stack:
[16:20:33.087] List of future strategies:
[16:20:33.087] 1. multicore:
[16:20:33.087]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:33.087]    - tweaked: FALSE
[16:20:33.087]    - call: plan(strategy)
[16:20:33.091] plan(): nbrOfWorkers() = 2
** Future evaluation without globals
[16:20:33.091] getGlobalsAndPackages() ...
[16:20:33.093] Searching for globals...
[16:20:33.093] - globals found: [2] ‘{’, ‘<-’
[16:20:33.094] Searching for globals ... DONE
[16:20:33.094] Resolving globals: FALSE
[16:20:33.094] 
[16:20:33.094] 
[16:20:33.094] getGlobalsAndPackages() ... DONE
[16:20:33.094] run() for ‘Future’ ...
[16:20:33.094] - state: ‘created’
[16:20:33.095] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:33.098] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:33.098] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:33.098]   - Field: ‘label’
[16:20:33.099]   - Field: ‘local’
[16:20:33.099]   - Field: ‘owner’
[16:20:33.099]   - Field: ‘envir’
[16:20:33.099]   - Field: ‘workers’
[16:20:33.099]   - Field: ‘packages’
[16:20:33.099]   - Field: ‘gc’
[16:20:33.099]   - Field: ‘job’
[16:20:33.099]   - Field: ‘conditions’
[16:20:33.099]   - Field: ‘expr’
[16:20:33.099]   - Field: ‘uuid’
[16:20:33.099]   - Field: ‘seed’
[16:20:33.100]   - Field: ‘version’
[16:20:33.100]   - Field: ‘result’
[16:20:33.100]   - Field: ‘asynchronous’
[16:20:33.100]   - Field: ‘calls’
[16:20:33.100]   - Field: ‘globals’
[16:20:33.100]   - Field: ‘stdout’
[16:20:33.100]   - Field: ‘earlySignal’
[16:20:33.100]   - Field: ‘lazy’
[16:20:33.100]   - Field: ‘state’
[16:20:33.100] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:33.101] - Launch lazy future ...
[16:20:33.101] Packages needed by the future expression (n = 0): <none>
[16:20:33.102] Packages needed by future strategies (n = 0): <none>
[16:20:33.102] {
[16:20:33.102]     {
[16:20:33.102]         {
[16:20:33.102]             ...future.startTime <- base::Sys.time()
[16:20:33.102]             {
[16:20:33.102]                 {
[16:20:33.102]                   {
[16:20:33.102]                     {
[16:20:33.102]                       base::local({
[16:20:33.102]                         has_future <- base::requireNamespace("future", 
[16:20:33.102]                           quietly = TRUE)
[16:20:33.102]                         if (has_future) {
[16:20:33.102]                           ns <- base::getNamespace("future")
[16:20:33.102]                           version <- ns[[".package"]][["version"]]
[16:20:33.102]                           if (is.null(version)) 
[16:20:33.102]                             version <- utils::packageVersion("future")
[16:20:33.102]                         }
[16:20:33.102]                         else {
[16:20:33.102]                           version <- NULL
[16:20:33.102]                         }
[16:20:33.102]                         if (!has_future || version < "1.8.0") {
[16:20:33.102]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:33.102]                             "", base::R.version$version.string), 
[16:20:33.102]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:33.102]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:33.102]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:33.102]                               "release", "version")], collapse = " "), 
[16:20:33.102]                             hostname = base::Sys.info()[["nodename"]])
[16:20:33.102]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:33.102]                             info)
[16:20:33.102]                           info <- base::paste(info, collapse = "; ")
[16:20:33.102]                           if (!has_future) {
[16:20:33.102]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:33.102]                               info)
[16:20:33.102]                           }
[16:20:33.102]                           else {
[16:20:33.102]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:33.102]                               info, version)
[16:20:33.102]                           }
[16:20:33.102]                           base::stop(msg)
[16:20:33.102]                         }
[16:20:33.102]                       })
[16:20:33.102]                     }
[16:20:33.102]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:33.102]                     base::options(mc.cores = 1L)
[16:20:33.102]                   }
[16:20:33.102]                   ...future.strategy.old <- future::plan("list")
[16:20:33.102]                   options(future.plan = NULL)
[16:20:33.102]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.102]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:33.102]                 }
[16:20:33.102]                 ...future.workdir <- getwd()
[16:20:33.102]             }
[16:20:33.102]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:33.102]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:33.102]         }
[16:20:33.102]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:33.102]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:33.102]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:33.102]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:33.102]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:33.102]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:33.102]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:33.102]             base::names(...future.oldOptions))
[16:20:33.102]     }
[16:20:33.102]     if (FALSE) {
[16:20:33.102]     }
[16:20:33.102]     else {
[16:20:33.102]         if (TRUE) {
[16:20:33.102]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:33.102]                 open = "w")
[16:20:33.102]         }
[16:20:33.102]         else {
[16:20:33.102]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:33.102]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:33.102]         }
[16:20:33.102]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:33.102]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:33.102]             base::sink(type = "output", split = FALSE)
[16:20:33.102]             base::close(...future.stdout)
[16:20:33.102]         }, add = TRUE)
[16:20:33.102]     }
[16:20:33.102]     ...future.frame <- base::sys.nframe()
[16:20:33.102]     ...future.conditions <- base::list()
[16:20:33.102]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:33.102]     if (FALSE) {
[16:20:33.102]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:33.102]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:33.102]     }
[16:20:33.102]     ...future.result <- base::tryCatch({
[16:20:33.102]         base::withCallingHandlers({
[16:20:33.102]             ...future.value <- base::withVisible(base::local({
[16:20:33.102]                 withCallingHandlers({
[16:20:33.102]                   {
[16:20:33.102]                     x <- 1
[16:20:33.102]                   }
[16:20:33.102]                 }, immediateCondition = function(cond) {
[16:20:33.102]                   save_rds <- function (object, pathname, ...) 
[16:20:33.102]                   {
[16:20:33.102]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:33.102]                     if (file_test("-f", pathname_tmp)) {
[16:20:33.102]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.102]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:33.102]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.102]                         fi_tmp[["mtime"]])
[16:20:33.102]                     }
[16:20:33.102]                     tryCatch({
[16:20:33.102]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:33.102]                     }, error = function(ex) {
[16:20:33.102]                       msg <- conditionMessage(ex)
[16:20:33.102]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.102]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:33.102]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.102]                         fi_tmp[["mtime"]], msg)
[16:20:33.102]                       ex$message <- msg
[16:20:33.102]                       stop(ex)
[16:20:33.102]                     })
[16:20:33.102]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:33.102]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:33.102]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:33.102]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.102]                       fi <- file.info(pathname)
[16:20:33.102]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:33.102]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.102]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:33.102]                         fi[["size"]], fi[["mtime"]])
[16:20:33.102]                       stop(msg)
[16:20:33.102]                     }
[16:20:33.102]                     invisible(pathname)
[16:20:33.102]                   }
[16:20:33.102]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:33.102]                     rootPath = tempdir()) 
[16:20:33.102]                   {
[16:20:33.102]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:33.102]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:33.102]                       tmpdir = path, fileext = ".rds")
[16:20:33.102]                     save_rds(obj, file)
[16:20:33.102]                   }
[16:20:33.102]                   saveImmediateCondition(cond, path = "/tmp/RtmpFUh73Z/.future/immediateConditions")
[16:20:33.102]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.102]                   {
[16:20:33.102]                     inherits <- base::inherits
[16:20:33.102]                     invokeRestart <- base::invokeRestart
[16:20:33.102]                     is.null <- base::is.null
[16:20:33.102]                     muffled <- FALSE
[16:20:33.102]                     if (inherits(cond, "message")) {
[16:20:33.102]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:33.102]                       if (muffled) 
[16:20:33.102]                         invokeRestart("muffleMessage")
[16:20:33.102]                     }
[16:20:33.102]                     else if (inherits(cond, "warning")) {
[16:20:33.102]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:33.102]                       if (muffled) 
[16:20:33.102]                         invokeRestart("muffleWarning")
[16:20:33.102]                     }
[16:20:33.102]                     else if (inherits(cond, "condition")) {
[16:20:33.102]                       if (!is.null(pattern)) {
[16:20:33.102]                         computeRestarts <- base::computeRestarts
[16:20:33.102]                         grepl <- base::grepl
[16:20:33.102]                         restarts <- computeRestarts(cond)
[16:20:33.102]                         for (restart in restarts) {
[16:20:33.102]                           name <- restart$name
[16:20:33.102]                           if (is.null(name)) 
[16:20:33.102]                             next
[16:20:33.102]                           if (!grepl(pattern, name)) 
[16:20:33.102]                             next
[16:20:33.102]                           invokeRestart(restart)
[16:20:33.102]                           muffled <- TRUE
[16:20:33.102]                           break
[16:20:33.102]                         }
[16:20:33.102]                       }
[16:20:33.102]                     }
[16:20:33.102]                     invisible(muffled)
[16:20:33.102]                   }
[16:20:33.102]                   muffleCondition(cond)
[16:20:33.102]                 })
[16:20:33.102]             }))
[16:20:33.102]             future::FutureResult(value = ...future.value$value, 
[16:20:33.102]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.102]                   ...future.rng), globalenv = if (FALSE) 
[16:20:33.102]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:33.102]                     ...future.globalenv.names))
[16:20:33.102]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:33.102]         }, condition = base::local({
[16:20:33.102]             c <- base::c
[16:20:33.102]             inherits <- base::inherits
[16:20:33.102]             invokeRestart <- base::invokeRestart
[16:20:33.102]             length <- base::length
[16:20:33.102]             list <- base::list
[16:20:33.102]             seq.int <- base::seq.int
[16:20:33.102]             signalCondition <- base::signalCondition
[16:20:33.102]             sys.calls <- base::sys.calls
[16:20:33.102]             `[[` <- base::`[[`
[16:20:33.102]             `+` <- base::`+`
[16:20:33.102]             `<<-` <- base::`<<-`
[16:20:33.102]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:33.102]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:33.102]                   3L)]
[16:20:33.102]             }
[16:20:33.102]             function(cond) {
[16:20:33.102]                 is_error <- inherits(cond, "error")
[16:20:33.102]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:33.102]                   NULL)
[16:20:33.102]                 if (is_error) {
[16:20:33.102]                   sessionInformation <- function() {
[16:20:33.102]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:33.102]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:33.102]                       search = base::search(), system = base::Sys.info())
[16:20:33.102]                   }
[16:20:33.102]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.102]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:33.102]                     cond$call), session = sessionInformation(), 
[16:20:33.102]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:33.102]                   signalCondition(cond)
[16:20:33.102]                 }
[16:20:33.102]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:33.102]                 "immediateCondition"))) {
[16:20:33.102]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:33.102]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.102]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:33.102]                   if (TRUE && !signal) {
[16:20:33.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.102]                     {
[16:20:33.102]                       inherits <- base::inherits
[16:20:33.102]                       invokeRestart <- base::invokeRestart
[16:20:33.102]                       is.null <- base::is.null
[16:20:33.102]                       muffled <- FALSE
[16:20:33.102]                       if (inherits(cond, "message")) {
[16:20:33.102]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.102]                         if (muffled) 
[16:20:33.102]                           invokeRestart("muffleMessage")
[16:20:33.102]                       }
[16:20:33.102]                       else if (inherits(cond, "warning")) {
[16:20:33.102]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.102]                         if (muffled) 
[16:20:33.102]                           invokeRestart("muffleWarning")
[16:20:33.102]                       }
[16:20:33.102]                       else if (inherits(cond, "condition")) {
[16:20:33.102]                         if (!is.null(pattern)) {
[16:20:33.102]                           computeRestarts <- base::computeRestarts
[16:20:33.102]                           grepl <- base::grepl
[16:20:33.102]                           restarts <- computeRestarts(cond)
[16:20:33.102]                           for (restart in restarts) {
[16:20:33.102]                             name <- restart$name
[16:20:33.102]                             if (is.null(name)) 
[16:20:33.102]                               next
[16:20:33.102]                             if (!grepl(pattern, name)) 
[16:20:33.102]                               next
[16:20:33.102]                             invokeRestart(restart)
[16:20:33.102]                             muffled <- TRUE
[16:20:33.102]                             break
[16:20:33.102]                           }
[16:20:33.102]                         }
[16:20:33.102]                       }
[16:20:33.102]                       invisible(muffled)
[16:20:33.102]                     }
[16:20:33.102]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.102]                   }
[16:20:33.102]                 }
[16:20:33.102]                 else {
[16:20:33.102]                   if (TRUE) {
[16:20:33.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.102]                     {
[16:20:33.102]                       inherits <- base::inherits
[16:20:33.102]                       invokeRestart <- base::invokeRestart
[16:20:33.102]                       is.null <- base::is.null
[16:20:33.102]                       muffled <- FALSE
[16:20:33.102]                       if (inherits(cond, "message")) {
[16:20:33.102]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.102]                         if (muffled) 
[16:20:33.102]                           invokeRestart("muffleMessage")
[16:20:33.102]                       }
[16:20:33.102]                       else if (inherits(cond, "warning")) {
[16:20:33.102]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.102]                         if (muffled) 
[16:20:33.102]                           invokeRestart("muffleWarning")
[16:20:33.102]                       }
[16:20:33.102]                       else if (inherits(cond, "condition")) {
[16:20:33.102]                         if (!is.null(pattern)) {
[16:20:33.102]                           computeRestarts <- base::computeRestarts
[16:20:33.102]                           grepl <- base::grepl
[16:20:33.102]                           restarts <- computeRestarts(cond)
[16:20:33.102]                           for (restart in restarts) {
[16:20:33.102]                             name <- restart$name
[16:20:33.102]                             if (is.null(name)) 
[16:20:33.102]                               next
[16:20:33.102]                             if (!grepl(pattern, name)) 
[16:20:33.102]                               next
[16:20:33.102]                             invokeRestart(restart)
[16:20:33.102]                             muffled <- TRUE
[16:20:33.102]                             break
[16:20:33.102]                           }
[16:20:33.102]                         }
[16:20:33.102]                       }
[16:20:33.102]                       invisible(muffled)
[16:20:33.102]                     }
[16:20:33.102]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.102]                   }
[16:20:33.102]                 }
[16:20:33.102]             }
[16:20:33.102]         }))
[16:20:33.102]     }, error = function(ex) {
[16:20:33.102]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:33.102]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.102]                 ...future.rng), started = ...future.startTime, 
[16:20:33.102]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:33.102]             version = "1.8"), class = "FutureResult")
[16:20:33.102]     }, finally = {
[16:20:33.102]         if (!identical(...future.workdir, getwd())) 
[16:20:33.102]             setwd(...future.workdir)
[16:20:33.102]         {
[16:20:33.102]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:33.102]                 ...future.oldOptions$nwarnings <- NULL
[16:20:33.102]             }
[16:20:33.102]             base::options(...future.oldOptions)
[16:20:33.102]             if (.Platform$OS.type == "windows") {
[16:20:33.102]                 old_names <- names(...future.oldEnvVars)
[16:20:33.102]                 envs <- base::Sys.getenv()
[16:20:33.102]                 names <- names(envs)
[16:20:33.102]                 common <- intersect(names, old_names)
[16:20:33.102]                 added <- setdiff(names, old_names)
[16:20:33.102]                 removed <- setdiff(old_names, names)
[16:20:33.102]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:33.102]                   envs[common]]
[16:20:33.102]                 NAMES <- toupper(changed)
[16:20:33.102]                 args <- list()
[16:20:33.102]                 for (kk in seq_along(NAMES)) {
[16:20:33.102]                   name <- changed[[kk]]
[16:20:33.102]                   NAME <- NAMES[[kk]]
[16:20:33.102]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.102]                     next
[16:20:33.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.102]                 }
[16:20:33.102]                 NAMES <- toupper(added)
[16:20:33.102]                 for (kk in seq_along(NAMES)) {
[16:20:33.102]                   name <- added[[kk]]
[16:20:33.102]                   NAME <- NAMES[[kk]]
[16:20:33.102]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.102]                     next
[16:20:33.102]                   args[[name]] <- ""
[16:20:33.102]                 }
[16:20:33.102]                 NAMES <- toupper(removed)
[16:20:33.102]                 for (kk in seq_along(NAMES)) {
[16:20:33.102]                   name <- removed[[kk]]
[16:20:33.102]                   NAME <- NAMES[[kk]]
[16:20:33.102]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.102]                     next
[16:20:33.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.102]                 }
[16:20:33.102]                 if (length(args) > 0) 
[16:20:33.102]                   base::do.call(base::Sys.setenv, args = args)
[16:20:33.102]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:33.102]             }
[16:20:33.102]             else {
[16:20:33.102]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:33.102]             }
[16:20:33.102]             {
[16:20:33.102]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:33.102]                   0L) {
[16:20:33.102]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:33.102]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:33.102]                   base::options(opts)
[16:20:33.102]                 }
[16:20:33.102]                 {
[16:20:33.102]                   {
[16:20:33.102]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:33.102]                     NULL
[16:20:33.102]                   }
[16:20:33.102]                   options(future.plan = NULL)
[16:20:33.102]                   if (is.na(NA_character_)) 
[16:20:33.102]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.102]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:33.102]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:33.102]                     .init = FALSE)
[16:20:33.102]                 }
[16:20:33.102]             }
[16:20:33.102]         }
[16:20:33.102]     })
[16:20:33.102]     if (TRUE) {
[16:20:33.102]         base::sink(type = "output", split = FALSE)
[16:20:33.102]         if (TRUE) {
[16:20:33.102]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:33.102]         }
[16:20:33.102]         else {
[16:20:33.102]             ...future.result["stdout"] <- base::list(NULL)
[16:20:33.102]         }
[16:20:33.102]         base::close(...future.stdout)
[16:20:33.102]         ...future.stdout <- NULL
[16:20:33.102]     }
[16:20:33.102]     ...future.result$conditions <- ...future.conditions
[16:20:33.102]     ...future.result$finished <- base::Sys.time()
[16:20:33.102]     ...future.result
[16:20:33.102] }
[16:20:33.104] requestCore(): workers = 2
[16:20:33.107] MulticoreFuture started
[16:20:33.108] - Launch lazy future ... done
[16:20:33.108] run() for ‘MulticoreFuture’ ... done
[16:20:33.108] plan(): Setting new future strategy stack:
[16:20:33.108] List of future strategies:
[16:20:33.108] 1. sequential:
[16:20:33.108]    - args: function (..., envir = parent.frame())
[16:20:33.108]    - tweaked: FALSE
[16:20:33.108]    - call: NULL
[16:20:33.109] plan(): nbrOfWorkers() = 1
[16:20:33.109] result() for MulticoreFuture ...
[16:20:33.111] plan(): Setting new future strategy stack:
[16:20:33.111] List of future strategies:
[16:20:33.111] 1. multicore:
[16:20:33.111]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:33.111]    - tweaked: FALSE
[16:20:33.111]    - call: plan(strategy)
[16:20:33.116] plan(): nbrOfWorkers() = 2
[16:20:33.121] result() for MulticoreFuture ...
[16:20:33.121] result() for MulticoreFuture ... done
[16:20:33.121] result() for MulticoreFuture ... done
[16:20:33.121] result() for MulticoreFuture ...
[16:20:33.121] result() for MulticoreFuture ... done
** Future evaluation with globals
[16:20:33.122] getGlobalsAndPackages() ...
[16:20:33.122] Searching for globals...
[16:20:33.123] - globals found: [3] ‘{’, ‘<-’, ‘a’
[16:20:33.123] Searching for globals ... DONE
[16:20:33.123] Resolving globals: FALSE
[16:20:33.124] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:33.124] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:20:33.124] - globals: [1] ‘a’
[16:20:33.124] 
[16:20:33.125] getGlobalsAndPackages() ... DONE
[16:20:33.125] run() for ‘Future’ ...
[16:20:33.125] - state: ‘created’
[16:20:33.125] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:33.129] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:33.129] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:33.129]   - Field: ‘label’
[16:20:33.130]   - Field: ‘local’
[16:20:33.130]   - Field: ‘owner’
[16:20:33.130]   - Field: ‘envir’
[16:20:33.130]   - Field: ‘workers’
[16:20:33.130]   - Field: ‘packages’
[16:20:33.130]   - Field: ‘gc’
[16:20:33.130]   - Field: ‘job’
[16:20:33.130]   - Field: ‘conditions’
[16:20:33.130]   - Field: ‘expr’
[16:20:33.131]   - Field: ‘uuid’
[16:20:33.131]   - Field: ‘seed’
[16:20:33.131]   - Field: ‘version’
[16:20:33.131]   - Field: ‘result’
[16:20:33.131]   - Field: ‘asynchronous’
[16:20:33.131]   - Field: ‘calls’
[16:20:33.131]   - Field: ‘globals’
[16:20:33.131]   - Field: ‘stdout’
[16:20:33.131]   - Field: ‘earlySignal’
[16:20:33.132]   - Field: ‘lazy’
[16:20:33.132]   - Field: ‘state’
[16:20:33.132] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:33.132] - Launch lazy future ...
[16:20:33.132] Packages needed by the future expression (n = 0): <none>
[16:20:33.132] Packages needed by future strategies (n = 0): <none>
[16:20:33.133] {
[16:20:33.133]     {
[16:20:33.133]         {
[16:20:33.133]             ...future.startTime <- base::Sys.time()
[16:20:33.133]             {
[16:20:33.133]                 {
[16:20:33.133]                   {
[16:20:33.133]                     {
[16:20:33.133]                       base::local({
[16:20:33.133]                         has_future <- base::requireNamespace("future", 
[16:20:33.133]                           quietly = TRUE)
[16:20:33.133]                         if (has_future) {
[16:20:33.133]                           ns <- base::getNamespace("future")
[16:20:33.133]                           version <- ns[[".package"]][["version"]]
[16:20:33.133]                           if (is.null(version)) 
[16:20:33.133]                             version <- utils::packageVersion("future")
[16:20:33.133]                         }
[16:20:33.133]                         else {
[16:20:33.133]                           version <- NULL
[16:20:33.133]                         }
[16:20:33.133]                         if (!has_future || version < "1.8.0") {
[16:20:33.133]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:33.133]                             "", base::R.version$version.string), 
[16:20:33.133]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:33.133]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:33.133]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:33.133]                               "release", "version")], collapse = " "), 
[16:20:33.133]                             hostname = base::Sys.info()[["nodename"]])
[16:20:33.133]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:33.133]                             info)
[16:20:33.133]                           info <- base::paste(info, collapse = "; ")
[16:20:33.133]                           if (!has_future) {
[16:20:33.133]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:33.133]                               info)
[16:20:33.133]                           }
[16:20:33.133]                           else {
[16:20:33.133]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:33.133]                               info, version)
[16:20:33.133]                           }
[16:20:33.133]                           base::stop(msg)
[16:20:33.133]                         }
[16:20:33.133]                       })
[16:20:33.133]                     }
[16:20:33.133]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:33.133]                     base::options(mc.cores = 1L)
[16:20:33.133]                   }
[16:20:33.133]                   ...future.strategy.old <- future::plan("list")
[16:20:33.133]                   options(future.plan = NULL)
[16:20:33.133]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.133]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:33.133]                 }
[16:20:33.133]                 ...future.workdir <- getwd()
[16:20:33.133]             }
[16:20:33.133]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:33.133]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:33.133]         }
[16:20:33.133]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:33.133]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:33.133]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:33.133]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:33.133]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:33.133]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:33.133]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:33.133]             base::names(...future.oldOptions))
[16:20:33.133]     }
[16:20:33.133]     if (FALSE) {
[16:20:33.133]     }
[16:20:33.133]     else {
[16:20:33.133]         if (TRUE) {
[16:20:33.133]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:33.133]                 open = "w")
[16:20:33.133]         }
[16:20:33.133]         else {
[16:20:33.133]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:33.133]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:33.133]         }
[16:20:33.133]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:33.133]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:33.133]             base::sink(type = "output", split = FALSE)
[16:20:33.133]             base::close(...future.stdout)
[16:20:33.133]         }, add = TRUE)
[16:20:33.133]     }
[16:20:33.133]     ...future.frame <- base::sys.nframe()
[16:20:33.133]     ...future.conditions <- base::list()
[16:20:33.133]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:33.133]     if (FALSE) {
[16:20:33.133]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:33.133]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:33.133]     }
[16:20:33.133]     ...future.result <- base::tryCatch({
[16:20:33.133]         base::withCallingHandlers({
[16:20:33.133]             ...future.value <- base::withVisible(base::local({
[16:20:33.133]                 withCallingHandlers({
[16:20:33.133]                   {
[16:20:33.133]                     x <- a
[16:20:33.133]                   }
[16:20:33.133]                 }, immediateCondition = function(cond) {
[16:20:33.133]                   save_rds <- function (object, pathname, ...) 
[16:20:33.133]                   {
[16:20:33.133]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:33.133]                     if (file_test("-f", pathname_tmp)) {
[16:20:33.133]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.133]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:33.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.133]                         fi_tmp[["mtime"]])
[16:20:33.133]                     }
[16:20:33.133]                     tryCatch({
[16:20:33.133]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:33.133]                     }, error = function(ex) {
[16:20:33.133]                       msg <- conditionMessage(ex)
[16:20:33.133]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.133]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:33.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.133]                         fi_tmp[["mtime"]], msg)
[16:20:33.133]                       ex$message <- msg
[16:20:33.133]                       stop(ex)
[16:20:33.133]                     })
[16:20:33.133]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:33.133]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:33.133]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:33.133]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.133]                       fi <- file.info(pathname)
[16:20:33.133]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:33.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.133]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:33.133]                         fi[["size"]], fi[["mtime"]])
[16:20:33.133]                       stop(msg)
[16:20:33.133]                     }
[16:20:33.133]                     invisible(pathname)
[16:20:33.133]                   }
[16:20:33.133]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:33.133]                     rootPath = tempdir()) 
[16:20:33.133]                   {
[16:20:33.133]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:33.133]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:33.133]                       tmpdir = path, fileext = ".rds")
[16:20:33.133]                     save_rds(obj, file)
[16:20:33.133]                   }
[16:20:33.133]                   saveImmediateCondition(cond, path = "/tmp/RtmpFUh73Z/.future/immediateConditions")
[16:20:33.133]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.133]                   {
[16:20:33.133]                     inherits <- base::inherits
[16:20:33.133]                     invokeRestart <- base::invokeRestart
[16:20:33.133]                     is.null <- base::is.null
[16:20:33.133]                     muffled <- FALSE
[16:20:33.133]                     if (inherits(cond, "message")) {
[16:20:33.133]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:33.133]                       if (muffled) 
[16:20:33.133]                         invokeRestart("muffleMessage")
[16:20:33.133]                     }
[16:20:33.133]                     else if (inherits(cond, "warning")) {
[16:20:33.133]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:33.133]                       if (muffled) 
[16:20:33.133]                         invokeRestart("muffleWarning")
[16:20:33.133]                     }
[16:20:33.133]                     else if (inherits(cond, "condition")) {
[16:20:33.133]                       if (!is.null(pattern)) {
[16:20:33.133]                         computeRestarts <- base::computeRestarts
[16:20:33.133]                         grepl <- base::grepl
[16:20:33.133]                         restarts <- computeRestarts(cond)
[16:20:33.133]                         for (restart in restarts) {
[16:20:33.133]                           name <- restart$name
[16:20:33.133]                           if (is.null(name)) 
[16:20:33.133]                             next
[16:20:33.133]                           if (!grepl(pattern, name)) 
[16:20:33.133]                             next
[16:20:33.133]                           invokeRestart(restart)
[16:20:33.133]                           muffled <- TRUE
[16:20:33.133]                           break
[16:20:33.133]                         }
[16:20:33.133]                       }
[16:20:33.133]                     }
[16:20:33.133]                     invisible(muffled)
[16:20:33.133]                   }
[16:20:33.133]                   muffleCondition(cond)
[16:20:33.133]                 })
[16:20:33.133]             }))
[16:20:33.133]             future::FutureResult(value = ...future.value$value, 
[16:20:33.133]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.133]                   ...future.rng), globalenv = if (FALSE) 
[16:20:33.133]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:33.133]                     ...future.globalenv.names))
[16:20:33.133]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:33.133]         }, condition = base::local({
[16:20:33.133]             c <- base::c
[16:20:33.133]             inherits <- base::inherits
[16:20:33.133]             invokeRestart <- base::invokeRestart
[16:20:33.133]             length <- base::length
[16:20:33.133]             list <- base::list
[16:20:33.133]             seq.int <- base::seq.int
[16:20:33.133]             signalCondition <- base::signalCondition
[16:20:33.133]             sys.calls <- base::sys.calls
[16:20:33.133]             `[[` <- base::`[[`
[16:20:33.133]             `+` <- base::`+`
[16:20:33.133]             `<<-` <- base::`<<-`
[16:20:33.133]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:33.133]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:33.133]                   3L)]
[16:20:33.133]             }
[16:20:33.133]             function(cond) {
[16:20:33.133]                 is_error <- inherits(cond, "error")
[16:20:33.133]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:33.133]                   NULL)
[16:20:33.133]                 if (is_error) {
[16:20:33.133]                   sessionInformation <- function() {
[16:20:33.133]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:33.133]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:33.133]                       search = base::search(), system = base::Sys.info())
[16:20:33.133]                   }
[16:20:33.133]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.133]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:33.133]                     cond$call), session = sessionInformation(), 
[16:20:33.133]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:33.133]                   signalCondition(cond)
[16:20:33.133]                 }
[16:20:33.133]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:33.133]                 "immediateCondition"))) {
[16:20:33.133]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:33.133]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.133]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:33.133]                   if (TRUE && !signal) {
[16:20:33.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.133]                     {
[16:20:33.133]                       inherits <- base::inherits
[16:20:33.133]                       invokeRestart <- base::invokeRestart
[16:20:33.133]                       is.null <- base::is.null
[16:20:33.133]                       muffled <- FALSE
[16:20:33.133]                       if (inherits(cond, "message")) {
[16:20:33.133]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.133]                         if (muffled) 
[16:20:33.133]                           invokeRestart("muffleMessage")
[16:20:33.133]                       }
[16:20:33.133]                       else if (inherits(cond, "warning")) {
[16:20:33.133]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.133]                         if (muffled) 
[16:20:33.133]                           invokeRestart("muffleWarning")
[16:20:33.133]                       }
[16:20:33.133]                       else if (inherits(cond, "condition")) {
[16:20:33.133]                         if (!is.null(pattern)) {
[16:20:33.133]                           computeRestarts <- base::computeRestarts
[16:20:33.133]                           grepl <- base::grepl
[16:20:33.133]                           restarts <- computeRestarts(cond)
[16:20:33.133]                           for (restart in restarts) {
[16:20:33.133]                             name <- restart$name
[16:20:33.133]                             if (is.null(name)) 
[16:20:33.133]                               next
[16:20:33.133]                             if (!grepl(pattern, name)) 
[16:20:33.133]                               next
[16:20:33.133]                             invokeRestart(restart)
[16:20:33.133]                             muffled <- TRUE
[16:20:33.133]                             break
[16:20:33.133]                           }
[16:20:33.133]                         }
[16:20:33.133]                       }
[16:20:33.133]                       invisible(muffled)
[16:20:33.133]                     }
[16:20:33.133]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.133]                   }
[16:20:33.133]                 }
[16:20:33.133]                 else {
[16:20:33.133]                   if (TRUE) {
[16:20:33.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.133]                     {
[16:20:33.133]                       inherits <- base::inherits
[16:20:33.133]                       invokeRestart <- base::invokeRestart
[16:20:33.133]                       is.null <- base::is.null
[16:20:33.133]                       muffled <- FALSE
[16:20:33.133]                       if (inherits(cond, "message")) {
[16:20:33.133]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.133]                         if (muffled) 
[16:20:33.133]                           invokeRestart("muffleMessage")
[16:20:33.133]                       }
[16:20:33.133]                       else if (inherits(cond, "warning")) {
[16:20:33.133]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.133]                         if (muffled) 
[16:20:33.133]                           invokeRestart("muffleWarning")
[16:20:33.133]                       }
[16:20:33.133]                       else if (inherits(cond, "condition")) {
[16:20:33.133]                         if (!is.null(pattern)) {
[16:20:33.133]                           computeRestarts <- base::computeRestarts
[16:20:33.133]                           grepl <- base::grepl
[16:20:33.133]                           restarts <- computeRestarts(cond)
[16:20:33.133]                           for (restart in restarts) {
[16:20:33.133]                             name <- restart$name
[16:20:33.133]                             if (is.null(name)) 
[16:20:33.133]                               next
[16:20:33.133]                             if (!grepl(pattern, name)) 
[16:20:33.133]                               next
[16:20:33.133]                             invokeRestart(restart)
[16:20:33.133]                             muffled <- TRUE
[16:20:33.133]                             break
[16:20:33.133]                           }
[16:20:33.133]                         }
[16:20:33.133]                       }
[16:20:33.133]                       invisible(muffled)
[16:20:33.133]                     }
[16:20:33.133]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.133]                   }
[16:20:33.133]                 }
[16:20:33.133]             }
[16:20:33.133]         }))
[16:20:33.133]     }, error = function(ex) {
[16:20:33.133]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:33.133]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.133]                 ...future.rng), started = ...future.startTime, 
[16:20:33.133]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:33.133]             version = "1.8"), class = "FutureResult")
[16:20:33.133]     }, finally = {
[16:20:33.133]         if (!identical(...future.workdir, getwd())) 
[16:20:33.133]             setwd(...future.workdir)
[16:20:33.133]         {
[16:20:33.133]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:33.133]                 ...future.oldOptions$nwarnings <- NULL
[16:20:33.133]             }
[16:20:33.133]             base::options(...future.oldOptions)
[16:20:33.133]             if (.Platform$OS.type == "windows") {
[16:20:33.133]                 old_names <- names(...future.oldEnvVars)
[16:20:33.133]                 envs <- base::Sys.getenv()
[16:20:33.133]                 names <- names(envs)
[16:20:33.133]                 common <- intersect(names, old_names)
[16:20:33.133]                 added <- setdiff(names, old_names)
[16:20:33.133]                 removed <- setdiff(old_names, names)
[16:20:33.133]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:33.133]                   envs[common]]
[16:20:33.133]                 NAMES <- toupper(changed)
[16:20:33.133]                 args <- list()
[16:20:33.133]                 for (kk in seq_along(NAMES)) {
[16:20:33.133]                   name <- changed[[kk]]
[16:20:33.133]                   NAME <- NAMES[[kk]]
[16:20:33.133]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.133]                     next
[16:20:33.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.133]                 }
[16:20:33.133]                 NAMES <- toupper(added)
[16:20:33.133]                 for (kk in seq_along(NAMES)) {
[16:20:33.133]                   name <- added[[kk]]
[16:20:33.133]                   NAME <- NAMES[[kk]]
[16:20:33.133]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.133]                     next
[16:20:33.133]                   args[[name]] <- ""
[16:20:33.133]                 }
[16:20:33.133]                 NAMES <- toupper(removed)
[16:20:33.133]                 for (kk in seq_along(NAMES)) {
[16:20:33.133]                   name <- removed[[kk]]
[16:20:33.133]                   NAME <- NAMES[[kk]]
[16:20:33.133]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.133]                     next
[16:20:33.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.133]                 }
[16:20:33.133]                 if (length(args) > 0) 
[16:20:33.133]                   base::do.call(base::Sys.setenv, args = args)
[16:20:33.133]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:33.133]             }
[16:20:33.133]             else {
[16:20:33.133]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:33.133]             }
[16:20:33.133]             {
[16:20:33.133]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:33.133]                   0L) {
[16:20:33.133]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:33.133]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:33.133]                   base::options(opts)
[16:20:33.133]                 }
[16:20:33.133]                 {
[16:20:33.133]                   {
[16:20:33.133]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:33.133]                     NULL
[16:20:33.133]                   }
[16:20:33.133]                   options(future.plan = NULL)
[16:20:33.133]                   if (is.na(NA_character_)) 
[16:20:33.133]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.133]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:33.133]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:33.133]                     .init = FALSE)
[16:20:33.133]                 }
[16:20:33.133]             }
[16:20:33.133]         }
[16:20:33.133]     })
[16:20:33.133]     if (TRUE) {
[16:20:33.133]         base::sink(type = "output", split = FALSE)
[16:20:33.133]         if (TRUE) {
[16:20:33.133]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:33.133]         }
[16:20:33.133]         else {
[16:20:33.133]             ...future.result["stdout"] <- base::list(NULL)
[16:20:33.133]         }
[16:20:33.133]         base::close(...future.stdout)
[16:20:33.133]         ...future.stdout <- NULL
[16:20:33.133]     }
[16:20:33.133]     ...future.result$conditions <- ...future.conditions
[16:20:33.133]     ...future.result$finished <- base::Sys.time()
[16:20:33.133]     ...future.result
[16:20:33.133] }
[16:20:33.135] assign_globals() ...
[16:20:33.135] List of 1
[16:20:33.135]  $ a: num 2
[16:20:33.135]  - attr(*, "where")=List of 1
[16:20:33.135]   ..$ a:<environment: R_EmptyEnv> 
[16:20:33.135]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:33.135]  - attr(*, "resolved")= logi FALSE
[16:20:33.135]  - attr(*, "total_size")= num 56
[16:20:33.135]  - attr(*, "already-done")= logi TRUE
[16:20:33.138] - copied ‘a’ to environment
[16:20:33.139] assign_globals() ... done
[16:20:33.141] requestCore(): workers = 2
[16:20:33.143] MulticoreFuture started
[16:20:33.143] - Launch lazy future ... done
[16:20:33.143] run() for ‘MulticoreFuture’ ... done
[16:20:33.144] result() for MulticoreFuture ...
[16:20:33.144] plan(): Setting new future strategy stack:
[16:20:33.144] List of future strategies:
[16:20:33.144] 1. sequential:
[16:20:33.144]    - args: function (..., envir = parent.frame())
[16:20:33.144]    - tweaked: FALSE
[16:20:33.144]    - call: NULL
[16:20:33.145] plan(): nbrOfWorkers() = 1
[16:20:33.148] plan(): Setting new future strategy stack:
[16:20:33.148] List of future strategies:
[16:20:33.148] 1. multicore:
[16:20:33.148]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:33.148]    - tweaked: FALSE
[16:20:33.148]    - call: plan(strategy)
[16:20:33.153] plan(): nbrOfWorkers() = 2
[16:20:33.154] result() for MulticoreFuture ...
[16:20:33.154] result() for MulticoreFuture ... done
[16:20:33.155] result() for MulticoreFuture ... done
[16:20:33.155] result() for MulticoreFuture ...
[16:20:33.155] result() for MulticoreFuture ... done
** Future evaluation with errors
[16:20:33.156] getGlobalsAndPackages() ...
[16:20:33.156] Searching for globals...
[16:20:33.158] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[16:20:33.158] Searching for globals ... DONE
[16:20:33.158] Resolving globals: FALSE
[16:20:33.159] 
[16:20:33.159] 
[16:20:33.159] getGlobalsAndPackages() ... DONE
[16:20:33.159] run() for ‘Future’ ...
[16:20:33.159] - state: ‘created’
[16:20:33.160] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:33.164] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:33.164] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:33.164]   - Field: ‘label’
[16:20:33.164]   - Field: ‘local’
[16:20:33.164]   - Field: ‘owner’
[16:20:33.164]   - Field: ‘envir’
[16:20:33.165]   - Field: ‘workers’
[16:20:33.165]   - Field: ‘packages’
[16:20:33.165]   - Field: ‘gc’
[16:20:33.165]   - Field: ‘job’
[16:20:33.165]   - Field: ‘conditions’
[16:20:33.165]   - Field: ‘expr’
[16:20:33.165]   - Field: ‘uuid’
[16:20:33.165]   - Field: ‘seed’
[16:20:33.166]   - Field: ‘version’
[16:20:33.166]   - Field: ‘result’
[16:20:33.166]   - Field: ‘asynchronous’
[16:20:33.166]   - Field: ‘calls’
[16:20:33.166]   - Field: ‘globals’
[16:20:33.166]   - Field: ‘stdout’
[16:20:33.166]   - Field: ‘earlySignal’
[16:20:33.166]   - Field: ‘lazy’
[16:20:33.167]   - Field: ‘state’
[16:20:33.167] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:33.167] - Launch lazy future ...
[16:20:33.167] Packages needed by the future expression (n = 0): <none>
[16:20:33.167] Packages needed by future strategies (n = 0): <none>
[16:20:33.168] {
[16:20:33.168]     {
[16:20:33.168]         {
[16:20:33.168]             ...future.startTime <- base::Sys.time()
[16:20:33.168]             {
[16:20:33.168]                 {
[16:20:33.168]                   {
[16:20:33.168]                     {
[16:20:33.168]                       base::local({
[16:20:33.168]                         has_future <- base::requireNamespace("future", 
[16:20:33.168]                           quietly = TRUE)
[16:20:33.168]                         if (has_future) {
[16:20:33.168]                           ns <- base::getNamespace("future")
[16:20:33.168]                           version <- ns[[".package"]][["version"]]
[16:20:33.168]                           if (is.null(version)) 
[16:20:33.168]                             version <- utils::packageVersion("future")
[16:20:33.168]                         }
[16:20:33.168]                         else {
[16:20:33.168]                           version <- NULL
[16:20:33.168]                         }
[16:20:33.168]                         if (!has_future || version < "1.8.0") {
[16:20:33.168]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:33.168]                             "", base::R.version$version.string), 
[16:20:33.168]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:33.168]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:33.168]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:33.168]                               "release", "version")], collapse = " "), 
[16:20:33.168]                             hostname = base::Sys.info()[["nodename"]])
[16:20:33.168]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:33.168]                             info)
[16:20:33.168]                           info <- base::paste(info, collapse = "; ")
[16:20:33.168]                           if (!has_future) {
[16:20:33.168]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:33.168]                               info)
[16:20:33.168]                           }
[16:20:33.168]                           else {
[16:20:33.168]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:33.168]                               info, version)
[16:20:33.168]                           }
[16:20:33.168]                           base::stop(msg)
[16:20:33.168]                         }
[16:20:33.168]                       })
[16:20:33.168]                     }
[16:20:33.168]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:33.168]                     base::options(mc.cores = 1L)
[16:20:33.168]                   }
[16:20:33.168]                   ...future.strategy.old <- future::plan("list")
[16:20:33.168]                   options(future.plan = NULL)
[16:20:33.168]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.168]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:33.168]                 }
[16:20:33.168]                 ...future.workdir <- getwd()
[16:20:33.168]             }
[16:20:33.168]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:33.168]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:33.168]         }
[16:20:33.168]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:33.168]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:33.168]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:33.168]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:33.168]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:33.168]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:33.168]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:33.168]             base::names(...future.oldOptions))
[16:20:33.168]     }
[16:20:33.168]     if (FALSE) {
[16:20:33.168]     }
[16:20:33.168]     else {
[16:20:33.168]         if (TRUE) {
[16:20:33.168]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:33.168]                 open = "w")
[16:20:33.168]         }
[16:20:33.168]         else {
[16:20:33.168]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:33.168]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:33.168]         }
[16:20:33.168]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:33.168]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:33.168]             base::sink(type = "output", split = FALSE)
[16:20:33.168]             base::close(...future.stdout)
[16:20:33.168]         }, add = TRUE)
[16:20:33.168]     }
[16:20:33.168]     ...future.frame <- base::sys.nframe()
[16:20:33.168]     ...future.conditions <- base::list()
[16:20:33.168]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:33.168]     if (FALSE) {
[16:20:33.168]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:33.168]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:33.168]     }
[16:20:33.168]     ...future.result <- base::tryCatch({
[16:20:33.168]         base::withCallingHandlers({
[16:20:33.168]             ...future.value <- base::withVisible(base::local({
[16:20:33.168]                 withCallingHandlers({
[16:20:33.168]                   {
[16:20:33.168]                     x <- 3
[16:20:33.168]                     stop("Woops!")
[16:20:33.168]                     x
[16:20:33.168]                   }
[16:20:33.168]                 }, immediateCondition = function(cond) {
[16:20:33.168]                   save_rds <- function (object, pathname, ...) 
[16:20:33.168]                   {
[16:20:33.168]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:33.168]                     if (file_test("-f", pathname_tmp)) {
[16:20:33.168]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.168]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:33.168]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.168]                         fi_tmp[["mtime"]])
[16:20:33.168]                     }
[16:20:33.168]                     tryCatch({
[16:20:33.168]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:33.168]                     }, error = function(ex) {
[16:20:33.168]                       msg <- conditionMessage(ex)
[16:20:33.168]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.168]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:33.168]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.168]                         fi_tmp[["mtime"]], msg)
[16:20:33.168]                       ex$message <- msg
[16:20:33.168]                       stop(ex)
[16:20:33.168]                     })
[16:20:33.168]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:33.168]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:33.168]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:33.168]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.168]                       fi <- file.info(pathname)
[16:20:33.168]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:33.168]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.168]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:33.168]                         fi[["size"]], fi[["mtime"]])
[16:20:33.168]                       stop(msg)
[16:20:33.168]                     }
[16:20:33.168]                     invisible(pathname)
[16:20:33.168]                   }
[16:20:33.168]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:33.168]                     rootPath = tempdir()) 
[16:20:33.168]                   {
[16:20:33.168]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:33.168]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:33.168]                       tmpdir = path, fileext = ".rds")
[16:20:33.168]                     save_rds(obj, file)
[16:20:33.168]                   }
[16:20:33.168]                   saveImmediateCondition(cond, path = "/tmp/RtmpFUh73Z/.future/immediateConditions")
[16:20:33.168]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.168]                   {
[16:20:33.168]                     inherits <- base::inherits
[16:20:33.168]                     invokeRestart <- base::invokeRestart
[16:20:33.168]                     is.null <- base::is.null
[16:20:33.168]                     muffled <- FALSE
[16:20:33.168]                     if (inherits(cond, "message")) {
[16:20:33.168]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:33.168]                       if (muffled) 
[16:20:33.168]                         invokeRestart("muffleMessage")
[16:20:33.168]                     }
[16:20:33.168]                     else if (inherits(cond, "warning")) {
[16:20:33.168]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:33.168]                       if (muffled) 
[16:20:33.168]                         invokeRestart("muffleWarning")
[16:20:33.168]                     }
[16:20:33.168]                     else if (inherits(cond, "condition")) {
[16:20:33.168]                       if (!is.null(pattern)) {
[16:20:33.168]                         computeRestarts <- base::computeRestarts
[16:20:33.168]                         grepl <- base::grepl
[16:20:33.168]                         restarts <- computeRestarts(cond)
[16:20:33.168]                         for (restart in restarts) {
[16:20:33.168]                           name <- restart$name
[16:20:33.168]                           if (is.null(name)) 
[16:20:33.168]                             next
[16:20:33.168]                           if (!grepl(pattern, name)) 
[16:20:33.168]                             next
[16:20:33.168]                           invokeRestart(restart)
[16:20:33.168]                           muffled <- TRUE
[16:20:33.168]                           break
[16:20:33.168]                         }
[16:20:33.168]                       }
[16:20:33.168]                     }
[16:20:33.168]                     invisible(muffled)
[16:20:33.168]                   }
[16:20:33.168]                   muffleCondition(cond)
[16:20:33.168]                 })
[16:20:33.168]             }))
[16:20:33.168]             future::FutureResult(value = ...future.value$value, 
[16:20:33.168]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.168]                   ...future.rng), globalenv = if (FALSE) 
[16:20:33.168]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:33.168]                     ...future.globalenv.names))
[16:20:33.168]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:33.168]         }, condition = base::local({
[16:20:33.168]             c <- base::c
[16:20:33.168]             inherits <- base::inherits
[16:20:33.168]             invokeRestart <- base::invokeRestart
[16:20:33.168]             length <- base::length
[16:20:33.168]             list <- base::list
[16:20:33.168]             seq.int <- base::seq.int
[16:20:33.168]             signalCondition <- base::signalCondition
[16:20:33.168]             sys.calls <- base::sys.calls
[16:20:33.168]             `[[` <- base::`[[`
[16:20:33.168]             `+` <- base::`+`
[16:20:33.168]             `<<-` <- base::`<<-`
[16:20:33.168]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:33.168]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:33.168]                   3L)]
[16:20:33.168]             }
[16:20:33.168]             function(cond) {
[16:20:33.168]                 is_error <- inherits(cond, "error")
[16:20:33.168]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:33.168]                   NULL)
[16:20:33.168]                 if (is_error) {
[16:20:33.168]                   sessionInformation <- function() {
[16:20:33.168]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:33.168]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:33.168]                       search = base::search(), system = base::Sys.info())
[16:20:33.168]                   }
[16:20:33.168]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.168]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:33.168]                     cond$call), session = sessionInformation(), 
[16:20:33.168]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:33.168]                   signalCondition(cond)
[16:20:33.168]                 }
[16:20:33.168]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:33.168]                 "immediateCondition"))) {
[16:20:33.168]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:33.168]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.168]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:33.168]                   if (TRUE && !signal) {
[16:20:33.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.168]                     {
[16:20:33.168]                       inherits <- base::inherits
[16:20:33.168]                       invokeRestart <- base::invokeRestart
[16:20:33.168]                       is.null <- base::is.null
[16:20:33.168]                       muffled <- FALSE
[16:20:33.168]                       if (inherits(cond, "message")) {
[16:20:33.168]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.168]                         if (muffled) 
[16:20:33.168]                           invokeRestart("muffleMessage")
[16:20:33.168]                       }
[16:20:33.168]                       else if (inherits(cond, "warning")) {
[16:20:33.168]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.168]                         if (muffled) 
[16:20:33.168]                           invokeRestart("muffleWarning")
[16:20:33.168]                       }
[16:20:33.168]                       else if (inherits(cond, "condition")) {
[16:20:33.168]                         if (!is.null(pattern)) {
[16:20:33.168]                           computeRestarts <- base::computeRestarts
[16:20:33.168]                           grepl <- base::grepl
[16:20:33.168]                           restarts <- computeRestarts(cond)
[16:20:33.168]                           for (restart in restarts) {
[16:20:33.168]                             name <- restart$name
[16:20:33.168]                             if (is.null(name)) 
[16:20:33.168]                               next
[16:20:33.168]                             if (!grepl(pattern, name)) 
[16:20:33.168]                               next
[16:20:33.168]                             invokeRestart(restart)
[16:20:33.168]                             muffled <- TRUE
[16:20:33.168]                             break
[16:20:33.168]                           }
[16:20:33.168]                         }
[16:20:33.168]                       }
[16:20:33.168]                       invisible(muffled)
[16:20:33.168]                     }
[16:20:33.168]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.168]                   }
[16:20:33.168]                 }
[16:20:33.168]                 else {
[16:20:33.168]                   if (TRUE) {
[16:20:33.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.168]                     {
[16:20:33.168]                       inherits <- base::inherits
[16:20:33.168]                       invokeRestart <- base::invokeRestart
[16:20:33.168]                       is.null <- base::is.null
[16:20:33.168]                       muffled <- FALSE
[16:20:33.168]                       if (inherits(cond, "message")) {
[16:20:33.168]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.168]                         if (muffled) 
[16:20:33.168]                           invokeRestart("muffleMessage")
[16:20:33.168]                       }
[16:20:33.168]                       else if (inherits(cond, "warning")) {
[16:20:33.168]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.168]                         if (muffled) 
[16:20:33.168]                           invokeRestart("muffleWarning")
[16:20:33.168]                       }
[16:20:33.168]                       else if (inherits(cond, "condition")) {
[16:20:33.168]                         if (!is.null(pattern)) {
[16:20:33.168]                           computeRestarts <- base::computeRestarts
[16:20:33.168]                           grepl <- base::grepl
[16:20:33.168]                           restarts <- computeRestarts(cond)
[16:20:33.168]                           for (restart in restarts) {
[16:20:33.168]                             name <- restart$name
[16:20:33.168]                             if (is.null(name)) 
[16:20:33.168]                               next
[16:20:33.168]                             if (!grepl(pattern, name)) 
[16:20:33.168]                               next
[16:20:33.168]                             invokeRestart(restart)
[16:20:33.168]                             muffled <- TRUE
[16:20:33.168]                             break
[16:20:33.168]                           }
[16:20:33.168]                         }
[16:20:33.168]                       }
[16:20:33.168]                       invisible(muffled)
[16:20:33.168]                     }
[16:20:33.168]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.168]                   }
[16:20:33.168]                 }
[16:20:33.168]             }
[16:20:33.168]         }))
[16:20:33.168]     }, error = function(ex) {
[16:20:33.168]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:33.168]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.168]                 ...future.rng), started = ...future.startTime, 
[16:20:33.168]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:33.168]             version = "1.8"), class = "FutureResult")
[16:20:33.168]     }, finally = {
[16:20:33.168]         if (!identical(...future.workdir, getwd())) 
[16:20:33.168]             setwd(...future.workdir)
[16:20:33.168]         {
[16:20:33.168]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:33.168]                 ...future.oldOptions$nwarnings <- NULL
[16:20:33.168]             }
[16:20:33.168]             base::options(...future.oldOptions)
[16:20:33.168]             if (.Platform$OS.type == "windows") {
[16:20:33.168]                 old_names <- names(...future.oldEnvVars)
[16:20:33.168]                 envs <- base::Sys.getenv()
[16:20:33.168]                 names <- names(envs)
[16:20:33.168]                 common <- intersect(names, old_names)
[16:20:33.168]                 added <- setdiff(names, old_names)
[16:20:33.168]                 removed <- setdiff(old_names, names)
[16:20:33.168]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:33.168]                   envs[common]]
[16:20:33.168]                 NAMES <- toupper(changed)
[16:20:33.168]                 args <- list()
[16:20:33.168]                 for (kk in seq_along(NAMES)) {
[16:20:33.168]                   name <- changed[[kk]]
[16:20:33.168]                   NAME <- NAMES[[kk]]
[16:20:33.168]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.168]                     next
[16:20:33.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.168]                 }
[16:20:33.168]                 NAMES <- toupper(added)
[16:20:33.168]                 for (kk in seq_along(NAMES)) {
[16:20:33.168]                   name <- added[[kk]]
[16:20:33.168]                   NAME <- NAMES[[kk]]
[16:20:33.168]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.168]                     next
[16:20:33.168]                   args[[name]] <- ""
[16:20:33.168]                 }
[16:20:33.168]                 NAMES <- toupper(removed)
[16:20:33.168]                 for (kk in seq_along(NAMES)) {
[16:20:33.168]                   name <- removed[[kk]]
[16:20:33.168]                   NAME <- NAMES[[kk]]
[16:20:33.168]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.168]                     next
[16:20:33.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.168]                 }
[16:20:33.168]                 if (length(args) > 0) 
[16:20:33.168]                   base::do.call(base::Sys.setenv, args = args)
[16:20:33.168]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:33.168]             }
[16:20:33.168]             else {
[16:20:33.168]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:33.168]             }
[16:20:33.168]             {
[16:20:33.168]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:33.168]                   0L) {
[16:20:33.168]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:33.168]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:33.168]                   base::options(opts)
[16:20:33.168]                 }
[16:20:33.168]                 {
[16:20:33.168]                   {
[16:20:33.168]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:33.168]                     NULL
[16:20:33.168]                   }
[16:20:33.168]                   options(future.plan = NULL)
[16:20:33.168]                   if (is.na(NA_character_)) 
[16:20:33.168]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.168]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:33.168]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:33.168]                     .init = FALSE)
[16:20:33.168]                 }
[16:20:33.168]             }
[16:20:33.168]         }
[16:20:33.168]     })
[16:20:33.168]     if (TRUE) {
[16:20:33.168]         base::sink(type = "output", split = FALSE)
[16:20:33.168]         if (TRUE) {
[16:20:33.168]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:33.168]         }
[16:20:33.168]         else {
[16:20:33.168]             ...future.result["stdout"] <- base::list(NULL)
[16:20:33.168]         }
[16:20:33.168]         base::close(...future.stdout)
[16:20:33.168]         ...future.stdout <- NULL
[16:20:33.168]     }
[16:20:33.168]     ...future.result$conditions <- ...future.conditions
[16:20:33.168]     ...future.result$finished <- base::Sys.time()
[16:20:33.168]     ...future.result
[16:20:33.168] }
[16:20:33.170] requestCore(): workers = 2
[16:20:33.172] MulticoreFuture started
[16:20:33.172] - Launch lazy future ... done
[16:20:33.173] run() for ‘MulticoreFuture’ ... done
[16:20:33.173] result() for MulticoreFuture ...
[16:20:33.173] plan(): Setting new future strategy stack:
[16:20:33.174] List of future strategies:
[16:20:33.174] 1. sequential:
[16:20:33.174]    - args: function (..., envir = parent.frame())
[16:20:33.174]    - tweaked: FALSE
[16:20:33.174]    - call: NULL
[16:20:33.174] plan(): nbrOfWorkers() = 1
[16:20:33.176] plan(): Setting new future strategy stack:
[16:20:33.176] List of future strategies:
[16:20:33.176] 1. multicore:
[16:20:33.176]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:33.176]    - tweaked: FALSE
[16:20:33.176]    - call: plan(strategy)
[16:20:33.181] plan(): nbrOfWorkers() = 2
[16:20:33.186] result() for MulticoreFuture ...
[16:20:33.186] result() for MulticoreFuture ... done
[16:20:33.186] signalConditions() ...
[16:20:33.187]  - include = ‘immediateCondition’
[16:20:33.187]  - exclude = 
[16:20:33.187]  - resignal = FALSE
[16:20:33.187]  - Number of conditions: 1
[16:20:33.187] signalConditions() ... done
[16:20:33.187] result() for MulticoreFuture ... done
[16:20:33.187] result() for MulticoreFuture ...
[16:20:33.187] result() for MulticoreFuture ... done
[16:20:33.187] signalConditions() ...
[16:20:33.188]  - include = ‘immediateCondition’
[16:20:33.188]  - exclude = 
[16:20:33.188]  - resignal = FALSE
[16:20:33.188]  - Number of conditions: 1
[16:20:33.188] signalConditions() ... done
[16:20:33.188] Future state: ‘finished’
[16:20:33.188] result() for MulticoreFuture ...
[16:20:33.188] result() for MulticoreFuture ... done
[16:20:33.189] signalConditions() ...
[16:20:33.189]  - include = ‘condition’
[16:20:33.189]  - exclude = ‘immediateCondition’
[16:20:33.189]  - resignal = TRUE
[16:20:33.189]  - Number of conditions: 1
[16:20:33.189]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:20:33.189] signalConditions() ... done
[16:20:33.190] getGlobalsAndPackages() ...
[16:20:33.190] Searching for globals...
[16:20:33.192] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[16:20:33.192] Searching for globals ... DONE
[16:20:33.192] Resolving globals: FALSE
[16:20:33.193] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:33.193] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:20:33.194] - globals: [1] ‘ii’
[16:20:33.194] 
[16:20:33.194] getGlobalsAndPackages() ... DONE
[16:20:33.194] run() for ‘Future’ ...
[16:20:33.194] - state: ‘created’
[16:20:33.194] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:33.199] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:33.199] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:33.199]   - Field: ‘label’
[16:20:33.199]   - Field: ‘local’
[16:20:33.199]   - Field: ‘owner’
[16:20:33.200]   - Field: ‘envir’
[16:20:33.200]   - Field: ‘workers’
[16:20:33.200]   - Field: ‘packages’
[16:20:33.200]   - Field: ‘gc’
[16:20:33.200]   - Field: ‘job’
[16:20:33.200]   - Field: ‘conditions’
[16:20:33.200]   - Field: ‘expr’
[16:20:33.200]   - Field: ‘uuid’
[16:20:33.201]   - Field: ‘seed’
[16:20:33.201]   - Field: ‘version’
[16:20:33.201]   - Field: ‘result’
[16:20:33.201]   - Field: ‘asynchronous’
[16:20:33.201]   - Field: ‘calls’
[16:20:33.201]   - Field: ‘globals’
[16:20:33.201]   - Field: ‘stdout’
[16:20:33.201]   - Field: ‘earlySignal’
[16:20:33.202]   - Field: ‘lazy’
[16:20:33.204]   - Field: ‘state’
[16:20:33.204] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:33.204] - Launch lazy future ...
[16:20:33.205] Packages needed by the future expression (n = 0): <none>
[16:20:33.205] Packages needed by future strategies (n = 0): <none>
[16:20:33.205] {
[16:20:33.205]     {
[16:20:33.205]         {
[16:20:33.205]             ...future.startTime <- base::Sys.time()
[16:20:33.205]             {
[16:20:33.205]                 {
[16:20:33.205]                   {
[16:20:33.205]                     {
[16:20:33.205]                       base::local({
[16:20:33.205]                         has_future <- base::requireNamespace("future", 
[16:20:33.205]                           quietly = TRUE)
[16:20:33.205]                         if (has_future) {
[16:20:33.205]                           ns <- base::getNamespace("future")
[16:20:33.205]                           version <- ns[[".package"]][["version"]]
[16:20:33.205]                           if (is.null(version)) 
[16:20:33.205]                             version <- utils::packageVersion("future")
[16:20:33.205]                         }
[16:20:33.205]                         else {
[16:20:33.205]                           version <- NULL
[16:20:33.205]                         }
[16:20:33.205]                         if (!has_future || version < "1.8.0") {
[16:20:33.205]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:33.205]                             "", base::R.version$version.string), 
[16:20:33.205]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:33.205]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:33.205]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:33.205]                               "release", "version")], collapse = " "), 
[16:20:33.205]                             hostname = base::Sys.info()[["nodename"]])
[16:20:33.205]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:33.205]                             info)
[16:20:33.205]                           info <- base::paste(info, collapse = "; ")
[16:20:33.205]                           if (!has_future) {
[16:20:33.205]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:33.205]                               info)
[16:20:33.205]                           }
[16:20:33.205]                           else {
[16:20:33.205]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:33.205]                               info, version)
[16:20:33.205]                           }
[16:20:33.205]                           base::stop(msg)
[16:20:33.205]                         }
[16:20:33.205]                       })
[16:20:33.205]                     }
[16:20:33.205]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:33.205]                     base::options(mc.cores = 1L)
[16:20:33.205]                   }
[16:20:33.205]                   ...future.strategy.old <- future::plan("list")
[16:20:33.205]                   options(future.plan = NULL)
[16:20:33.205]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.205]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:33.205]                 }
[16:20:33.205]                 ...future.workdir <- getwd()
[16:20:33.205]             }
[16:20:33.205]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:33.205]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:33.205]         }
[16:20:33.205]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:33.205]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:33.205]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:33.205]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:33.205]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:33.205]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:33.205]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:33.205]             base::names(...future.oldOptions))
[16:20:33.205]     }
[16:20:33.205]     if (FALSE) {
[16:20:33.205]     }
[16:20:33.205]     else {
[16:20:33.205]         if (TRUE) {
[16:20:33.205]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:33.205]                 open = "w")
[16:20:33.205]         }
[16:20:33.205]         else {
[16:20:33.205]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:33.205]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:33.205]         }
[16:20:33.205]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:33.205]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:33.205]             base::sink(type = "output", split = FALSE)
[16:20:33.205]             base::close(...future.stdout)
[16:20:33.205]         }, add = TRUE)
[16:20:33.205]     }
[16:20:33.205]     ...future.frame <- base::sys.nframe()
[16:20:33.205]     ...future.conditions <- base::list()
[16:20:33.205]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:33.205]     if (FALSE) {
[16:20:33.205]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:33.205]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:33.205]     }
[16:20:33.205]     ...future.result <- base::tryCatch({
[16:20:33.205]         base::withCallingHandlers({
[16:20:33.205]             ...future.value <- base::withVisible(base::local({
[16:20:33.205]                 withCallingHandlers({
[16:20:33.205]                   {
[16:20:33.205]                     if (ii%%2 == 0) 
[16:20:33.205]                       stop("Woops!")
[16:20:33.205]                     ii
[16:20:33.205]                   }
[16:20:33.205]                 }, immediateCondition = function(cond) {
[16:20:33.205]                   save_rds <- function (object, pathname, ...) 
[16:20:33.205]                   {
[16:20:33.205]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:33.205]                     if (file_test("-f", pathname_tmp)) {
[16:20:33.205]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.205]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:33.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.205]                         fi_tmp[["mtime"]])
[16:20:33.205]                     }
[16:20:33.205]                     tryCatch({
[16:20:33.205]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:33.205]                     }, error = function(ex) {
[16:20:33.205]                       msg <- conditionMessage(ex)
[16:20:33.205]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.205]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:33.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.205]                         fi_tmp[["mtime"]], msg)
[16:20:33.205]                       ex$message <- msg
[16:20:33.205]                       stop(ex)
[16:20:33.205]                     })
[16:20:33.205]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:33.205]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:33.205]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:33.205]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.205]                       fi <- file.info(pathname)
[16:20:33.205]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:33.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.205]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:33.205]                         fi[["size"]], fi[["mtime"]])
[16:20:33.205]                       stop(msg)
[16:20:33.205]                     }
[16:20:33.205]                     invisible(pathname)
[16:20:33.205]                   }
[16:20:33.205]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:33.205]                     rootPath = tempdir()) 
[16:20:33.205]                   {
[16:20:33.205]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:33.205]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:33.205]                       tmpdir = path, fileext = ".rds")
[16:20:33.205]                     save_rds(obj, file)
[16:20:33.205]                   }
[16:20:33.205]                   saveImmediateCondition(cond, path = "/tmp/RtmpFUh73Z/.future/immediateConditions")
[16:20:33.205]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.205]                   {
[16:20:33.205]                     inherits <- base::inherits
[16:20:33.205]                     invokeRestart <- base::invokeRestart
[16:20:33.205]                     is.null <- base::is.null
[16:20:33.205]                     muffled <- FALSE
[16:20:33.205]                     if (inherits(cond, "message")) {
[16:20:33.205]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:33.205]                       if (muffled) 
[16:20:33.205]                         invokeRestart("muffleMessage")
[16:20:33.205]                     }
[16:20:33.205]                     else if (inherits(cond, "warning")) {
[16:20:33.205]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:33.205]                       if (muffled) 
[16:20:33.205]                         invokeRestart("muffleWarning")
[16:20:33.205]                     }
[16:20:33.205]                     else if (inherits(cond, "condition")) {
[16:20:33.205]                       if (!is.null(pattern)) {
[16:20:33.205]                         computeRestarts <- base::computeRestarts
[16:20:33.205]                         grepl <- base::grepl
[16:20:33.205]                         restarts <- computeRestarts(cond)
[16:20:33.205]                         for (restart in restarts) {
[16:20:33.205]                           name <- restart$name
[16:20:33.205]                           if (is.null(name)) 
[16:20:33.205]                             next
[16:20:33.205]                           if (!grepl(pattern, name)) 
[16:20:33.205]                             next
[16:20:33.205]                           invokeRestart(restart)
[16:20:33.205]                           muffled <- TRUE
[16:20:33.205]                           break
[16:20:33.205]                         }
[16:20:33.205]                       }
[16:20:33.205]                     }
[16:20:33.205]                     invisible(muffled)
[16:20:33.205]                   }
[16:20:33.205]                   muffleCondition(cond)
[16:20:33.205]                 })
[16:20:33.205]             }))
[16:20:33.205]             future::FutureResult(value = ...future.value$value, 
[16:20:33.205]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.205]                   ...future.rng), globalenv = if (FALSE) 
[16:20:33.205]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:33.205]                     ...future.globalenv.names))
[16:20:33.205]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:33.205]         }, condition = base::local({
[16:20:33.205]             c <- base::c
[16:20:33.205]             inherits <- base::inherits
[16:20:33.205]             invokeRestart <- base::invokeRestart
[16:20:33.205]             length <- base::length
[16:20:33.205]             list <- base::list
[16:20:33.205]             seq.int <- base::seq.int
[16:20:33.205]             signalCondition <- base::signalCondition
[16:20:33.205]             sys.calls <- base::sys.calls
[16:20:33.205]             `[[` <- base::`[[`
[16:20:33.205]             `+` <- base::`+`
[16:20:33.205]             `<<-` <- base::`<<-`
[16:20:33.205]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:33.205]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:33.205]                   3L)]
[16:20:33.205]             }
[16:20:33.205]             function(cond) {
[16:20:33.205]                 is_error <- inherits(cond, "error")
[16:20:33.205]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:33.205]                   NULL)
[16:20:33.205]                 if (is_error) {
[16:20:33.205]                   sessionInformation <- function() {
[16:20:33.205]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:33.205]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:33.205]                       search = base::search(), system = base::Sys.info())
[16:20:33.205]                   }
[16:20:33.205]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.205]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:33.205]                     cond$call), session = sessionInformation(), 
[16:20:33.205]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:33.205]                   signalCondition(cond)
[16:20:33.205]                 }
[16:20:33.205]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:33.205]                 "immediateCondition"))) {
[16:20:33.205]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:33.205]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.205]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:33.205]                   if (TRUE && !signal) {
[16:20:33.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.205]                     {
[16:20:33.205]                       inherits <- base::inherits
[16:20:33.205]                       invokeRestart <- base::invokeRestart
[16:20:33.205]                       is.null <- base::is.null
[16:20:33.205]                       muffled <- FALSE
[16:20:33.205]                       if (inherits(cond, "message")) {
[16:20:33.205]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.205]                         if (muffled) 
[16:20:33.205]                           invokeRestart("muffleMessage")
[16:20:33.205]                       }
[16:20:33.205]                       else if (inherits(cond, "warning")) {
[16:20:33.205]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.205]                         if (muffled) 
[16:20:33.205]                           invokeRestart("muffleWarning")
[16:20:33.205]                       }
[16:20:33.205]                       else if (inherits(cond, "condition")) {
[16:20:33.205]                         if (!is.null(pattern)) {
[16:20:33.205]                           computeRestarts <- base::computeRestarts
[16:20:33.205]                           grepl <- base::grepl
[16:20:33.205]                           restarts <- computeRestarts(cond)
[16:20:33.205]                           for (restart in restarts) {
[16:20:33.205]                             name <- restart$name
[16:20:33.205]                             if (is.null(name)) 
[16:20:33.205]                               next
[16:20:33.205]                             if (!grepl(pattern, name)) 
[16:20:33.205]                               next
[16:20:33.205]                             invokeRestart(restart)
[16:20:33.205]                             muffled <- TRUE
[16:20:33.205]                             break
[16:20:33.205]                           }
[16:20:33.205]                         }
[16:20:33.205]                       }
[16:20:33.205]                       invisible(muffled)
[16:20:33.205]                     }
[16:20:33.205]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.205]                   }
[16:20:33.205]                 }
[16:20:33.205]                 else {
[16:20:33.205]                   if (TRUE) {
[16:20:33.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.205]                     {
[16:20:33.205]                       inherits <- base::inherits
[16:20:33.205]                       invokeRestart <- base::invokeRestart
[16:20:33.205]                       is.null <- base::is.null
[16:20:33.205]                       muffled <- FALSE
[16:20:33.205]                       if (inherits(cond, "message")) {
[16:20:33.205]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.205]                         if (muffled) 
[16:20:33.205]                           invokeRestart("muffleMessage")
[16:20:33.205]                       }
[16:20:33.205]                       else if (inherits(cond, "warning")) {
[16:20:33.205]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.205]                         if (muffled) 
[16:20:33.205]                           invokeRestart("muffleWarning")
[16:20:33.205]                       }
[16:20:33.205]                       else if (inherits(cond, "condition")) {
[16:20:33.205]                         if (!is.null(pattern)) {
[16:20:33.205]                           computeRestarts <- base::computeRestarts
[16:20:33.205]                           grepl <- base::grepl
[16:20:33.205]                           restarts <- computeRestarts(cond)
[16:20:33.205]                           for (restart in restarts) {
[16:20:33.205]                             name <- restart$name
[16:20:33.205]                             if (is.null(name)) 
[16:20:33.205]                               next
[16:20:33.205]                             if (!grepl(pattern, name)) 
[16:20:33.205]                               next
[16:20:33.205]                             invokeRestart(restart)
[16:20:33.205]                             muffled <- TRUE
[16:20:33.205]                             break
[16:20:33.205]                           }
[16:20:33.205]                         }
[16:20:33.205]                       }
[16:20:33.205]                       invisible(muffled)
[16:20:33.205]                     }
[16:20:33.205]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.205]                   }
[16:20:33.205]                 }
[16:20:33.205]             }
[16:20:33.205]         }))
[16:20:33.205]     }, error = function(ex) {
[16:20:33.205]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:33.205]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.205]                 ...future.rng), started = ...future.startTime, 
[16:20:33.205]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:33.205]             version = "1.8"), class = "FutureResult")
[16:20:33.205]     }, finally = {
[16:20:33.205]         if (!identical(...future.workdir, getwd())) 
[16:20:33.205]             setwd(...future.workdir)
[16:20:33.205]         {
[16:20:33.205]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:33.205]                 ...future.oldOptions$nwarnings <- NULL
[16:20:33.205]             }
[16:20:33.205]             base::options(...future.oldOptions)
[16:20:33.205]             if (.Platform$OS.type == "windows") {
[16:20:33.205]                 old_names <- names(...future.oldEnvVars)
[16:20:33.205]                 envs <- base::Sys.getenv()
[16:20:33.205]                 names <- names(envs)
[16:20:33.205]                 common <- intersect(names, old_names)
[16:20:33.205]                 added <- setdiff(names, old_names)
[16:20:33.205]                 removed <- setdiff(old_names, names)
[16:20:33.205]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:33.205]                   envs[common]]
[16:20:33.205]                 NAMES <- toupper(changed)
[16:20:33.205]                 args <- list()
[16:20:33.205]                 for (kk in seq_along(NAMES)) {
[16:20:33.205]                   name <- changed[[kk]]
[16:20:33.205]                   NAME <- NAMES[[kk]]
[16:20:33.205]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.205]                     next
[16:20:33.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.205]                 }
[16:20:33.205]                 NAMES <- toupper(added)
[16:20:33.205]                 for (kk in seq_along(NAMES)) {
[16:20:33.205]                   name <- added[[kk]]
[16:20:33.205]                   NAME <- NAMES[[kk]]
[16:20:33.205]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.205]                     next
[16:20:33.205]                   args[[name]] <- ""
[16:20:33.205]                 }
[16:20:33.205]                 NAMES <- toupper(removed)
[16:20:33.205]                 for (kk in seq_along(NAMES)) {
[16:20:33.205]                   name <- removed[[kk]]
[16:20:33.205]                   NAME <- NAMES[[kk]]
[16:20:33.205]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.205]                     next
[16:20:33.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.205]                 }
[16:20:33.205]                 if (length(args) > 0) 
[16:20:33.205]                   base::do.call(base::Sys.setenv, args = args)
[16:20:33.205]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:33.205]             }
[16:20:33.205]             else {
[16:20:33.205]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:33.205]             }
[16:20:33.205]             {
[16:20:33.205]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:33.205]                   0L) {
[16:20:33.205]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:33.205]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:33.205]                   base::options(opts)
[16:20:33.205]                 }
[16:20:33.205]                 {
[16:20:33.205]                   {
[16:20:33.205]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:33.205]                     NULL
[16:20:33.205]                   }
[16:20:33.205]                   options(future.plan = NULL)
[16:20:33.205]                   if (is.na(NA_character_)) 
[16:20:33.205]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.205]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:33.205]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:33.205]                     .init = FALSE)
[16:20:33.205]                 }
[16:20:33.205]             }
[16:20:33.205]         }
[16:20:33.205]     })
[16:20:33.205]     if (TRUE) {
[16:20:33.205]         base::sink(type = "output", split = FALSE)
[16:20:33.205]         if (TRUE) {
[16:20:33.205]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:33.205]         }
[16:20:33.205]         else {
[16:20:33.205]             ...future.result["stdout"] <- base::list(NULL)
[16:20:33.205]         }
[16:20:33.205]         base::close(...future.stdout)
[16:20:33.205]         ...future.stdout <- NULL
[16:20:33.205]     }
[16:20:33.205]     ...future.result$conditions <- ...future.conditions
[16:20:33.205]     ...future.result$finished <- base::Sys.time()
[16:20:33.205]     ...future.result
[16:20:33.205] }
[16:20:33.208] assign_globals() ...
[16:20:33.208] List of 1
[16:20:33.208]  $ ii: int 1
[16:20:33.208]  - attr(*, "where")=List of 1
[16:20:33.208]   ..$ ii:<environment: R_EmptyEnv> 
[16:20:33.208]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:33.208]  - attr(*, "resolved")= logi FALSE
[16:20:33.208]  - attr(*, "total_size")= num 56
[16:20:33.208]  - attr(*, "already-done")= logi TRUE
[16:20:33.211] - copied ‘ii’ to environment
[16:20:33.211] assign_globals() ... done
[16:20:33.212] requestCore(): workers = 2
[16:20:33.213] MulticoreFuture started
[16:20:33.214] - Launch lazy future ... done
[16:20:33.214] run() for ‘MulticoreFuture’ ... done
[16:20:33.214] plan(): Setting new future strategy stack:
[16:20:33.215] getGlobalsAndPackages() ...
[16:20:33.215] Searching for globals...
[16:20:33.215] List of future strategies:
[16:20:33.215] 1. sequential:
[16:20:33.215]    - args: function (..., envir = parent.frame())
[16:20:33.215]    - tweaked: FALSE
[16:20:33.215]    - call: NULL
[16:20:33.215] plan(): nbrOfWorkers() = 1
[16:20:33.217] plan(): Setting new future strategy stack:
[16:20:33.217] List of future strategies:
[16:20:33.217] 1. multicore:
[16:20:33.217]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:33.217]    - tweaked: FALSE
[16:20:33.217]    - call: plan(strategy)
[16:20:33.219] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[16:20:33.219] Searching for globals ... DONE
[16:20:33.219] Resolving globals: FALSE
[16:20:33.220] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:33.221] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:20:33.221] - globals: [1] ‘ii’
[16:20:33.221] 
[16:20:33.221] getGlobalsAndPackages() ... DONE
[16:20:33.222] run() for ‘Future’ ...
[16:20:33.222] - state: ‘created’
[16:20:33.222] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:33.222] plan(): nbrOfWorkers() = 2
[16:20:33.227] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:33.227] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:33.227]   - Field: ‘label’
[16:20:33.227]   - Field: ‘local’
[16:20:33.227]   - Field: ‘owner’
[16:20:33.227]   - Field: ‘envir’
[16:20:33.228]   - Field: ‘workers’
[16:20:33.228]   - Field: ‘packages’
[16:20:33.228]   - Field: ‘gc’
[16:20:33.228]   - Field: ‘job’
[16:20:33.228]   - Field: ‘conditions’
[16:20:33.228]   - Field: ‘expr’
[16:20:33.228]   - Field: ‘uuid’
[16:20:33.229]   - Field: ‘seed’
[16:20:33.229]   - Field: ‘version’
[16:20:33.229]   - Field: ‘result’
[16:20:33.229]   - Field: ‘asynchronous’
[16:20:33.229]   - Field: ‘calls’
[16:20:33.229]   - Field: ‘globals’
[16:20:33.229]   - Field: ‘stdout’
[16:20:33.230]   - Field: ‘earlySignal’
[16:20:33.230]   - Field: ‘lazy’
[16:20:33.230]   - Field: ‘state’
[16:20:33.230] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:33.230] - Launch lazy future ...
[16:20:33.231] Packages needed by the future expression (n = 0): <none>
[16:20:33.231] Packages needed by future strategies (n = 0): <none>
[16:20:33.231] {
[16:20:33.231]     {
[16:20:33.231]         {
[16:20:33.231]             ...future.startTime <- base::Sys.time()
[16:20:33.231]             {
[16:20:33.231]                 {
[16:20:33.231]                   {
[16:20:33.231]                     {
[16:20:33.231]                       base::local({
[16:20:33.231]                         has_future <- base::requireNamespace("future", 
[16:20:33.231]                           quietly = TRUE)
[16:20:33.231]                         if (has_future) {
[16:20:33.231]                           ns <- base::getNamespace("future")
[16:20:33.231]                           version <- ns[[".package"]][["version"]]
[16:20:33.231]                           if (is.null(version)) 
[16:20:33.231]                             version <- utils::packageVersion("future")
[16:20:33.231]                         }
[16:20:33.231]                         else {
[16:20:33.231]                           version <- NULL
[16:20:33.231]                         }
[16:20:33.231]                         if (!has_future || version < "1.8.0") {
[16:20:33.231]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:33.231]                             "", base::R.version$version.string), 
[16:20:33.231]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:33.231]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:33.231]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:33.231]                               "release", "version")], collapse = " "), 
[16:20:33.231]                             hostname = base::Sys.info()[["nodename"]])
[16:20:33.231]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:33.231]                             info)
[16:20:33.231]                           info <- base::paste(info, collapse = "; ")
[16:20:33.231]                           if (!has_future) {
[16:20:33.231]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:33.231]                               info)
[16:20:33.231]                           }
[16:20:33.231]                           else {
[16:20:33.231]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:33.231]                               info, version)
[16:20:33.231]                           }
[16:20:33.231]                           base::stop(msg)
[16:20:33.231]                         }
[16:20:33.231]                       })
[16:20:33.231]                     }
[16:20:33.231]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:33.231]                     base::options(mc.cores = 1L)
[16:20:33.231]                   }
[16:20:33.231]                   ...future.strategy.old <- future::plan("list")
[16:20:33.231]                   options(future.plan = NULL)
[16:20:33.231]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.231]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:33.231]                 }
[16:20:33.231]                 ...future.workdir <- getwd()
[16:20:33.231]             }
[16:20:33.231]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:33.231]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:33.231]         }
[16:20:33.231]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:33.231]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:33.231]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:33.231]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:33.231]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:33.231]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:33.231]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:33.231]             base::names(...future.oldOptions))
[16:20:33.231]     }
[16:20:33.231]     if (FALSE) {
[16:20:33.231]     }
[16:20:33.231]     else {
[16:20:33.231]         if (TRUE) {
[16:20:33.231]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:33.231]                 open = "w")
[16:20:33.231]         }
[16:20:33.231]         else {
[16:20:33.231]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:33.231]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:33.231]         }
[16:20:33.231]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:33.231]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:33.231]             base::sink(type = "output", split = FALSE)
[16:20:33.231]             base::close(...future.stdout)
[16:20:33.231]         }, add = TRUE)
[16:20:33.231]     }
[16:20:33.231]     ...future.frame <- base::sys.nframe()
[16:20:33.231]     ...future.conditions <- base::list()
[16:20:33.231]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:33.231]     if (FALSE) {
[16:20:33.231]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:33.231]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:33.231]     }
[16:20:33.231]     ...future.result <- base::tryCatch({
[16:20:33.231]         base::withCallingHandlers({
[16:20:33.231]             ...future.value <- base::withVisible(base::local({
[16:20:33.231]                 withCallingHandlers({
[16:20:33.231]                   {
[16:20:33.231]                     if (ii%%2 == 0) 
[16:20:33.231]                       stop("Woops!")
[16:20:33.231]                     ii
[16:20:33.231]                   }
[16:20:33.231]                 }, immediateCondition = function(cond) {
[16:20:33.231]                   save_rds <- function (object, pathname, ...) 
[16:20:33.231]                   {
[16:20:33.231]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:33.231]                     if (file_test("-f", pathname_tmp)) {
[16:20:33.231]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.231]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:33.231]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.231]                         fi_tmp[["mtime"]])
[16:20:33.231]                     }
[16:20:33.231]                     tryCatch({
[16:20:33.231]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:33.231]                     }, error = function(ex) {
[16:20:33.231]                       msg <- conditionMessage(ex)
[16:20:33.231]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.231]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:33.231]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.231]                         fi_tmp[["mtime"]], msg)
[16:20:33.231]                       ex$message <- msg
[16:20:33.231]                       stop(ex)
[16:20:33.231]                     })
[16:20:33.231]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:33.231]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:33.231]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:33.231]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.231]                       fi <- file.info(pathname)
[16:20:33.231]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:33.231]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.231]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:33.231]                         fi[["size"]], fi[["mtime"]])
[16:20:33.231]                       stop(msg)
[16:20:33.231]                     }
[16:20:33.231]                     invisible(pathname)
[16:20:33.231]                   }
[16:20:33.231]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:33.231]                     rootPath = tempdir()) 
[16:20:33.231]                   {
[16:20:33.231]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:33.231]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:33.231]                       tmpdir = path, fileext = ".rds")
[16:20:33.231]                     save_rds(obj, file)
[16:20:33.231]                   }
[16:20:33.231]                   saveImmediateCondition(cond, path = "/tmp/RtmpFUh73Z/.future/immediateConditions")
[16:20:33.231]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.231]                   {
[16:20:33.231]                     inherits <- base::inherits
[16:20:33.231]                     invokeRestart <- base::invokeRestart
[16:20:33.231]                     is.null <- base::is.null
[16:20:33.231]                     muffled <- FALSE
[16:20:33.231]                     if (inherits(cond, "message")) {
[16:20:33.231]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:33.231]                       if (muffled) 
[16:20:33.231]                         invokeRestart("muffleMessage")
[16:20:33.231]                     }
[16:20:33.231]                     else if (inherits(cond, "warning")) {
[16:20:33.231]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:33.231]                       if (muffled) 
[16:20:33.231]                         invokeRestart("muffleWarning")
[16:20:33.231]                     }
[16:20:33.231]                     else if (inherits(cond, "condition")) {
[16:20:33.231]                       if (!is.null(pattern)) {
[16:20:33.231]                         computeRestarts <- base::computeRestarts
[16:20:33.231]                         grepl <- base::grepl
[16:20:33.231]                         restarts <- computeRestarts(cond)
[16:20:33.231]                         for (restart in restarts) {
[16:20:33.231]                           name <- restart$name
[16:20:33.231]                           if (is.null(name)) 
[16:20:33.231]                             next
[16:20:33.231]                           if (!grepl(pattern, name)) 
[16:20:33.231]                             next
[16:20:33.231]                           invokeRestart(restart)
[16:20:33.231]                           muffled <- TRUE
[16:20:33.231]                           break
[16:20:33.231]                         }
[16:20:33.231]                       }
[16:20:33.231]                     }
[16:20:33.231]                     invisible(muffled)
[16:20:33.231]                   }
[16:20:33.231]                   muffleCondition(cond)
[16:20:33.231]                 })
[16:20:33.231]             }))
[16:20:33.231]             future::FutureResult(value = ...future.value$value, 
[16:20:33.231]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.231]                   ...future.rng), globalenv = if (FALSE) 
[16:20:33.231]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:33.231]                     ...future.globalenv.names))
[16:20:33.231]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:33.231]         }, condition = base::local({
[16:20:33.231]             c <- base::c
[16:20:33.231]             inherits <- base::inherits
[16:20:33.231]             invokeRestart <- base::invokeRestart
[16:20:33.231]             length <- base::length
[16:20:33.231]             list <- base::list
[16:20:33.231]             seq.int <- base::seq.int
[16:20:33.231]             signalCondition <- base::signalCondition
[16:20:33.231]             sys.calls <- base::sys.calls
[16:20:33.231]             `[[` <- base::`[[`
[16:20:33.231]             `+` <- base::`+`
[16:20:33.231]             `<<-` <- base::`<<-`
[16:20:33.231]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:33.231]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:33.231]                   3L)]
[16:20:33.231]             }
[16:20:33.231]             function(cond) {
[16:20:33.231]                 is_error <- inherits(cond, "error")
[16:20:33.231]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:33.231]                   NULL)
[16:20:33.231]                 if (is_error) {
[16:20:33.231]                   sessionInformation <- function() {
[16:20:33.231]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:33.231]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:33.231]                       search = base::search(), system = base::Sys.info())
[16:20:33.231]                   }
[16:20:33.231]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.231]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:33.231]                     cond$call), session = sessionInformation(), 
[16:20:33.231]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:33.231]                   signalCondition(cond)
[16:20:33.231]                 }
[16:20:33.231]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:33.231]                 "immediateCondition"))) {
[16:20:33.231]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:33.231]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.231]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:33.231]                   if (TRUE && !signal) {
[16:20:33.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.231]                     {
[16:20:33.231]                       inherits <- base::inherits
[16:20:33.231]                       invokeRestart <- base::invokeRestart
[16:20:33.231]                       is.null <- base::is.null
[16:20:33.231]                       muffled <- FALSE
[16:20:33.231]                       if (inherits(cond, "message")) {
[16:20:33.231]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.231]                         if (muffled) 
[16:20:33.231]                           invokeRestart("muffleMessage")
[16:20:33.231]                       }
[16:20:33.231]                       else if (inherits(cond, "warning")) {
[16:20:33.231]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.231]                         if (muffled) 
[16:20:33.231]                           invokeRestart("muffleWarning")
[16:20:33.231]                       }
[16:20:33.231]                       else if (inherits(cond, "condition")) {
[16:20:33.231]                         if (!is.null(pattern)) {
[16:20:33.231]                           computeRestarts <- base::computeRestarts
[16:20:33.231]                           grepl <- base::grepl
[16:20:33.231]                           restarts <- computeRestarts(cond)
[16:20:33.231]                           for (restart in restarts) {
[16:20:33.231]                             name <- restart$name
[16:20:33.231]                             if (is.null(name)) 
[16:20:33.231]                               next
[16:20:33.231]                             if (!grepl(pattern, name)) 
[16:20:33.231]                               next
[16:20:33.231]                             invokeRestart(restart)
[16:20:33.231]                             muffled <- TRUE
[16:20:33.231]                             break
[16:20:33.231]                           }
[16:20:33.231]                         }
[16:20:33.231]                       }
[16:20:33.231]                       invisible(muffled)
[16:20:33.231]                     }
[16:20:33.231]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.231]                   }
[16:20:33.231]                 }
[16:20:33.231]                 else {
[16:20:33.231]                   if (TRUE) {
[16:20:33.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.231]                     {
[16:20:33.231]                       inherits <- base::inherits
[16:20:33.231]                       invokeRestart <- base::invokeRestart
[16:20:33.231]                       is.null <- base::is.null
[16:20:33.231]                       muffled <- FALSE
[16:20:33.231]                       if (inherits(cond, "message")) {
[16:20:33.231]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.231]                         if (muffled) 
[16:20:33.231]                           invokeRestart("muffleMessage")
[16:20:33.231]                       }
[16:20:33.231]                       else if (inherits(cond, "warning")) {
[16:20:33.231]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.231]                         if (muffled) 
[16:20:33.231]                           invokeRestart("muffleWarning")
[16:20:33.231]                       }
[16:20:33.231]                       else if (inherits(cond, "condition")) {
[16:20:33.231]                         if (!is.null(pattern)) {
[16:20:33.231]                           computeRestarts <- base::computeRestarts
[16:20:33.231]                           grepl <- base::grepl
[16:20:33.231]                           restarts <- computeRestarts(cond)
[16:20:33.231]                           for (restart in restarts) {
[16:20:33.231]                             name <- restart$name
[16:20:33.231]                             if (is.null(name)) 
[16:20:33.231]                               next
[16:20:33.231]                             if (!grepl(pattern, name)) 
[16:20:33.231]                               next
[16:20:33.231]                             invokeRestart(restart)
[16:20:33.231]                             muffled <- TRUE
[16:20:33.231]                             break
[16:20:33.231]                           }
[16:20:33.231]                         }
[16:20:33.231]                       }
[16:20:33.231]                       invisible(muffled)
[16:20:33.231]                     }
[16:20:33.231]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.231]                   }
[16:20:33.231]                 }
[16:20:33.231]             }
[16:20:33.231]         }))
[16:20:33.231]     }, error = function(ex) {
[16:20:33.231]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:33.231]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.231]                 ...future.rng), started = ...future.startTime, 
[16:20:33.231]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:33.231]             version = "1.8"), class = "FutureResult")
[16:20:33.231]     }, finally = {
[16:20:33.231]         if (!identical(...future.workdir, getwd())) 
[16:20:33.231]             setwd(...future.workdir)
[16:20:33.231]         {
[16:20:33.231]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:33.231]                 ...future.oldOptions$nwarnings <- NULL
[16:20:33.231]             }
[16:20:33.231]             base::options(...future.oldOptions)
[16:20:33.231]             if (.Platform$OS.type == "windows") {
[16:20:33.231]                 old_names <- names(...future.oldEnvVars)
[16:20:33.231]                 envs <- base::Sys.getenv()
[16:20:33.231]                 names <- names(envs)
[16:20:33.231]                 common <- intersect(names, old_names)
[16:20:33.231]                 added <- setdiff(names, old_names)
[16:20:33.231]                 removed <- setdiff(old_names, names)
[16:20:33.231]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:33.231]                   envs[common]]
[16:20:33.231]                 NAMES <- toupper(changed)
[16:20:33.231]                 args <- list()
[16:20:33.231]                 for (kk in seq_along(NAMES)) {
[16:20:33.231]                   name <- changed[[kk]]
[16:20:33.231]                   NAME <- NAMES[[kk]]
[16:20:33.231]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.231]                     next
[16:20:33.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.231]                 }
[16:20:33.231]                 NAMES <- toupper(added)
[16:20:33.231]                 for (kk in seq_along(NAMES)) {
[16:20:33.231]                   name <- added[[kk]]
[16:20:33.231]                   NAME <- NAMES[[kk]]
[16:20:33.231]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.231]                     next
[16:20:33.231]                   args[[name]] <- ""
[16:20:33.231]                 }
[16:20:33.231]                 NAMES <- toupper(removed)
[16:20:33.231]                 for (kk in seq_along(NAMES)) {
[16:20:33.231]                   name <- removed[[kk]]
[16:20:33.231]                   NAME <- NAMES[[kk]]
[16:20:33.231]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.231]                     next
[16:20:33.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.231]                 }
[16:20:33.231]                 if (length(args) > 0) 
[16:20:33.231]                   base::do.call(base::Sys.setenv, args = args)
[16:20:33.231]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:33.231]             }
[16:20:33.231]             else {
[16:20:33.231]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:33.231]             }
[16:20:33.231]             {
[16:20:33.231]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:33.231]                   0L) {
[16:20:33.231]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:33.231]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:33.231]                   base::options(opts)
[16:20:33.231]                 }
[16:20:33.231]                 {
[16:20:33.231]                   {
[16:20:33.231]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:33.231]                     NULL
[16:20:33.231]                   }
[16:20:33.231]                   options(future.plan = NULL)
[16:20:33.231]                   if (is.na(NA_character_)) 
[16:20:33.231]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.231]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:33.231]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:33.231]                     .init = FALSE)
[16:20:33.231]                 }
[16:20:33.231]             }
[16:20:33.231]         }
[16:20:33.231]     })
[16:20:33.231]     if (TRUE) {
[16:20:33.231]         base::sink(type = "output", split = FALSE)
[16:20:33.231]         if (TRUE) {
[16:20:33.231]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:33.231]         }
[16:20:33.231]         else {
[16:20:33.231]             ...future.result["stdout"] <- base::list(NULL)
[16:20:33.231]         }
[16:20:33.231]         base::close(...future.stdout)
[16:20:33.231]         ...future.stdout <- NULL
[16:20:33.231]     }
[16:20:33.231]     ...future.result$conditions <- ...future.conditions
[16:20:33.231]     ...future.result$finished <- base::Sys.time()
[16:20:33.231]     ...future.result
[16:20:33.231] }
[16:20:33.235] assign_globals() ...
[16:20:33.235] List of 1
[16:20:33.235]  $ ii: int 2
[16:20:33.235]  - attr(*, "where")=List of 1
[16:20:33.235]   ..$ ii:<environment: R_EmptyEnv> 
[16:20:33.235]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:33.235]  - attr(*, "resolved")= logi FALSE
[16:20:33.235]  - attr(*, "total_size")= num 56
[16:20:33.235]  - attr(*, "already-done")= logi TRUE
[16:20:33.238] - copied ‘ii’ to environment
[16:20:33.238] assign_globals() ... done
[16:20:33.239] requestCore(): workers = 2
[16:20:33.241] MulticoreFuture started
[16:20:33.241] - Launch lazy future ... done
[16:20:33.241] run() for ‘MulticoreFuture’ ... done
[16:20:33.242] plan(): Setting new future strategy stack:
[16:20:33.243] getGlobalsAndPackages() ...
[16:20:33.243] Searching for globals...
[16:20:33.242] List of future strategies:
[16:20:33.242] 1. sequential:
[16:20:33.242]    - args: function (..., envir = parent.frame())
[16:20:33.242]    - tweaked: FALSE
[16:20:33.242]    - call: NULL
[16:20:33.244] plan(): nbrOfWorkers() = 1
[16:20:33.246] plan(): Setting new future strategy stack:
[16:20:33.246] List of future strategies:
[16:20:33.246] 1. multicore:
[16:20:33.246]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:33.246]    - tweaked: FALSE
[16:20:33.246]    - call: plan(strategy)
[16:20:33.247] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[16:20:33.248] Searching for globals ... DONE
[16:20:33.248] Resolving globals: FALSE
[16:20:33.249] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:33.250] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:20:33.253] plan(): nbrOfWorkers() = 2
[16:20:33.250] - globals: [1] ‘ii’
[16:20:33.255] 
[16:20:33.255] getGlobalsAndPackages() ... DONE
[16:20:33.256] run() for ‘Future’ ...
[16:20:33.256] - state: ‘created’
[16:20:33.256] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:33.262] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:33.262] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:33.262]   - Field: ‘label’
[16:20:33.262]   - Field: ‘local’
[16:20:33.262]   - Field: ‘owner’
[16:20:33.263]   - Field: ‘envir’
[16:20:33.263]   - Field: ‘workers’
[16:20:33.263]   - Field: ‘packages’
[16:20:33.263]   - Field: ‘gc’
[16:20:33.263]   - Field: ‘job’
[16:20:33.263]   - Field: ‘conditions’
[16:20:33.264]   - Field: ‘expr’
[16:20:33.264]   - Field: ‘uuid’
[16:20:33.264]   - Field: ‘seed’
[16:20:33.264]   - Field: ‘version’
[16:20:33.264]   - Field: ‘result’
[16:20:33.265]   - Field: ‘asynchronous’
[16:20:33.265]   - Field: ‘calls’
[16:20:33.265]   - Field: ‘globals’
[16:20:33.265]   - Field: ‘stdout’
[16:20:33.265]   - Field: ‘earlySignal’
[16:20:33.265]   - Field: ‘lazy’
[16:20:33.265]   - Field: ‘state’
[16:20:33.266] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:33.266] - Launch lazy future ...
[16:20:33.266] Packages needed by the future expression (n = 0): <none>
[16:20:33.266] Packages needed by future strategies (n = 0): <none>
[16:20:33.267] {
[16:20:33.267]     {
[16:20:33.267]         {
[16:20:33.267]             ...future.startTime <- base::Sys.time()
[16:20:33.267]             {
[16:20:33.267]                 {
[16:20:33.267]                   {
[16:20:33.267]                     {
[16:20:33.267]                       base::local({
[16:20:33.267]                         has_future <- base::requireNamespace("future", 
[16:20:33.267]                           quietly = TRUE)
[16:20:33.267]                         if (has_future) {
[16:20:33.267]                           ns <- base::getNamespace("future")
[16:20:33.267]                           version <- ns[[".package"]][["version"]]
[16:20:33.267]                           if (is.null(version)) 
[16:20:33.267]                             version <- utils::packageVersion("future")
[16:20:33.267]                         }
[16:20:33.267]                         else {
[16:20:33.267]                           version <- NULL
[16:20:33.267]                         }
[16:20:33.267]                         if (!has_future || version < "1.8.0") {
[16:20:33.267]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:33.267]                             "", base::R.version$version.string), 
[16:20:33.267]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:33.267]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:33.267]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:33.267]                               "release", "version")], collapse = " "), 
[16:20:33.267]                             hostname = base::Sys.info()[["nodename"]])
[16:20:33.267]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:33.267]                             info)
[16:20:33.267]                           info <- base::paste(info, collapse = "; ")
[16:20:33.267]                           if (!has_future) {
[16:20:33.267]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:33.267]                               info)
[16:20:33.267]                           }
[16:20:33.267]                           else {
[16:20:33.267]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:33.267]                               info, version)
[16:20:33.267]                           }
[16:20:33.267]                           base::stop(msg)
[16:20:33.267]                         }
[16:20:33.267]                       })
[16:20:33.267]                     }
[16:20:33.267]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:33.267]                     base::options(mc.cores = 1L)
[16:20:33.267]                   }
[16:20:33.267]                   ...future.strategy.old <- future::plan("list")
[16:20:33.267]                   options(future.plan = NULL)
[16:20:33.267]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.267]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:33.267]                 }
[16:20:33.267]                 ...future.workdir <- getwd()
[16:20:33.267]             }
[16:20:33.267]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:33.267]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:33.267]         }
[16:20:33.267]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:33.267]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:33.267]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:33.267]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:33.267]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:33.267]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:33.267]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:33.267]             base::names(...future.oldOptions))
[16:20:33.267]     }
[16:20:33.267]     if (FALSE) {
[16:20:33.267]     }
[16:20:33.267]     else {
[16:20:33.267]         if (TRUE) {
[16:20:33.267]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:33.267]                 open = "w")
[16:20:33.267]         }
[16:20:33.267]         else {
[16:20:33.267]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:33.267]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:33.267]         }
[16:20:33.267]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:33.267]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:33.267]             base::sink(type = "output", split = FALSE)
[16:20:33.267]             base::close(...future.stdout)
[16:20:33.267]         }, add = TRUE)
[16:20:33.267]     }
[16:20:33.267]     ...future.frame <- base::sys.nframe()
[16:20:33.267]     ...future.conditions <- base::list()
[16:20:33.267]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:33.267]     if (FALSE) {
[16:20:33.267]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:33.267]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:33.267]     }
[16:20:33.267]     ...future.result <- base::tryCatch({
[16:20:33.267]         base::withCallingHandlers({
[16:20:33.267]             ...future.value <- base::withVisible(base::local({
[16:20:33.267]                 withCallingHandlers({
[16:20:33.267]                   {
[16:20:33.267]                     if (ii%%2 == 0) 
[16:20:33.267]                       stop("Woops!")
[16:20:33.267]                     ii
[16:20:33.267]                   }
[16:20:33.267]                 }, immediateCondition = function(cond) {
[16:20:33.267]                   save_rds <- function (object, pathname, ...) 
[16:20:33.267]                   {
[16:20:33.267]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:33.267]                     if (file_test("-f", pathname_tmp)) {
[16:20:33.267]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.267]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:33.267]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.267]                         fi_tmp[["mtime"]])
[16:20:33.267]                     }
[16:20:33.267]                     tryCatch({
[16:20:33.267]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:33.267]                     }, error = function(ex) {
[16:20:33.267]                       msg <- conditionMessage(ex)
[16:20:33.267]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.267]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:33.267]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.267]                         fi_tmp[["mtime"]], msg)
[16:20:33.267]                       ex$message <- msg
[16:20:33.267]                       stop(ex)
[16:20:33.267]                     })
[16:20:33.267]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:33.267]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:33.267]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:33.267]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.267]                       fi <- file.info(pathname)
[16:20:33.267]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:33.267]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.267]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:33.267]                         fi[["size"]], fi[["mtime"]])
[16:20:33.267]                       stop(msg)
[16:20:33.267]                     }
[16:20:33.267]                     invisible(pathname)
[16:20:33.267]                   }
[16:20:33.267]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:33.267]                     rootPath = tempdir()) 
[16:20:33.267]                   {
[16:20:33.267]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:33.267]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:33.267]                       tmpdir = path, fileext = ".rds")
[16:20:33.267]                     save_rds(obj, file)
[16:20:33.267]                   }
[16:20:33.267]                   saveImmediateCondition(cond, path = "/tmp/RtmpFUh73Z/.future/immediateConditions")
[16:20:33.267]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.267]                   {
[16:20:33.267]                     inherits <- base::inherits
[16:20:33.267]                     invokeRestart <- base::invokeRestart
[16:20:33.267]                     is.null <- base::is.null
[16:20:33.267]                     muffled <- FALSE
[16:20:33.267]                     if (inherits(cond, "message")) {
[16:20:33.267]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:33.267]                       if (muffled) 
[16:20:33.267]                         invokeRestart("muffleMessage")
[16:20:33.267]                     }
[16:20:33.267]                     else if (inherits(cond, "warning")) {
[16:20:33.267]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:33.267]                       if (muffled) 
[16:20:33.267]                         invokeRestart("muffleWarning")
[16:20:33.267]                     }
[16:20:33.267]                     else if (inherits(cond, "condition")) {
[16:20:33.267]                       if (!is.null(pattern)) {
[16:20:33.267]                         computeRestarts <- base::computeRestarts
[16:20:33.267]                         grepl <- base::grepl
[16:20:33.267]                         restarts <- computeRestarts(cond)
[16:20:33.267]                         for (restart in restarts) {
[16:20:33.267]                           name <- restart$name
[16:20:33.267]                           if (is.null(name)) 
[16:20:33.267]                             next
[16:20:33.267]                           if (!grepl(pattern, name)) 
[16:20:33.267]                             next
[16:20:33.267]                           invokeRestart(restart)
[16:20:33.267]                           muffled <- TRUE
[16:20:33.267]                           break
[16:20:33.267]                         }
[16:20:33.267]                       }
[16:20:33.267]                     }
[16:20:33.267]                     invisible(muffled)
[16:20:33.267]                   }
[16:20:33.267]                   muffleCondition(cond)
[16:20:33.267]                 })
[16:20:33.267]             }))
[16:20:33.267]             future::FutureResult(value = ...future.value$value, 
[16:20:33.267]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.267]                   ...future.rng), globalenv = if (FALSE) 
[16:20:33.267]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:33.267]                     ...future.globalenv.names))
[16:20:33.267]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:33.267]         }, condition = base::local({
[16:20:33.267]             c <- base::c
[16:20:33.267]             inherits <- base::inherits
[16:20:33.267]             invokeRestart <- base::invokeRestart
[16:20:33.267]             length <- base::length
[16:20:33.267]             list <- base::list
[16:20:33.267]             seq.int <- base::seq.int
[16:20:33.267]             signalCondition <- base::signalCondition
[16:20:33.267]             sys.calls <- base::sys.calls
[16:20:33.267]             `[[` <- base::`[[`
[16:20:33.267]             `+` <- base::`+`
[16:20:33.267]             `<<-` <- base::`<<-`
[16:20:33.267]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:33.267]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:33.267]                   3L)]
[16:20:33.267]             }
[16:20:33.267]             function(cond) {
[16:20:33.267]                 is_error <- inherits(cond, "error")
[16:20:33.267]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:33.267]                   NULL)
[16:20:33.267]                 if (is_error) {
[16:20:33.267]                   sessionInformation <- function() {
[16:20:33.267]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:33.267]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:33.267]                       search = base::search(), system = base::Sys.info())
[16:20:33.267]                   }
[16:20:33.267]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.267]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:33.267]                     cond$call), session = sessionInformation(), 
[16:20:33.267]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:33.267]                   signalCondition(cond)
[16:20:33.267]                 }
[16:20:33.267]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:33.267]                 "immediateCondition"))) {
[16:20:33.267]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:33.267]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.267]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:33.267]                   if (TRUE && !signal) {
[16:20:33.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.267]                     {
[16:20:33.267]                       inherits <- base::inherits
[16:20:33.267]                       invokeRestart <- base::invokeRestart
[16:20:33.267]                       is.null <- base::is.null
[16:20:33.267]                       muffled <- FALSE
[16:20:33.267]                       if (inherits(cond, "message")) {
[16:20:33.267]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.267]                         if (muffled) 
[16:20:33.267]                           invokeRestart("muffleMessage")
[16:20:33.267]                       }
[16:20:33.267]                       else if (inherits(cond, "warning")) {
[16:20:33.267]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.267]                         if (muffled) 
[16:20:33.267]                           invokeRestart("muffleWarning")
[16:20:33.267]                       }
[16:20:33.267]                       else if (inherits(cond, "condition")) {
[16:20:33.267]                         if (!is.null(pattern)) {
[16:20:33.267]                           computeRestarts <- base::computeRestarts
[16:20:33.267]                           grepl <- base::grepl
[16:20:33.267]                           restarts <- computeRestarts(cond)
[16:20:33.267]                           for (restart in restarts) {
[16:20:33.267]                             name <- restart$name
[16:20:33.267]                             if (is.null(name)) 
[16:20:33.267]                               next
[16:20:33.267]                             if (!grepl(pattern, name)) 
[16:20:33.267]                               next
[16:20:33.267]                             invokeRestart(restart)
[16:20:33.267]                             muffled <- TRUE
[16:20:33.267]                             break
[16:20:33.267]                           }
[16:20:33.267]                         }
[16:20:33.267]                       }
[16:20:33.267]                       invisible(muffled)
[16:20:33.267]                     }
[16:20:33.267]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.267]                   }
[16:20:33.267]                 }
[16:20:33.267]                 else {
[16:20:33.267]                   if (TRUE) {
[16:20:33.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.267]                     {
[16:20:33.267]                       inherits <- base::inherits
[16:20:33.267]                       invokeRestart <- base::invokeRestart
[16:20:33.267]                       is.null <- base::is.null
[16:20:33.267]                       muffled <- FALSE
[16:20:33.267]                       if (inherits(cond, "message")) {
[16:20:33.267]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.267]                         if (muffled) 
[16:20:33.267]                           invokeRestart("muffleMessage")
[16:20:33.267]                       }
[16:20:33.267]                       else if (inherits(cond, "warning")) {
[16:20:33.267]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.267]                         if (muffled) 
[16:20:33.267]                           invokeRestart("muffleWarning")
[16:20:33.267]                       }
[16:20:33.267]                       else if (inherits(cond, "condition")) {
[16:20:33.267]                         if (!is.null(pattern)) {
[16:20:33.267]                           computeRestarts <- base::computeRestarts
[16:20:33.267]                           grepl <- base::grepl
[16:20:33.267]                           restarts <- computeRestarts(cond)
[16:20:33.267]                           for (restart in restarts) {
[16:20:33.267]                             name <- restart$name
[16:20:33.267]                             if (is.null(name)) 
[16:20:33.267]                               next
[16:20:33.267]                             if (!grepl(pattern, name)) 
[16:20:33.267]                               next
[16:20:33.267]                             invokeRestart(restart)
[16:20:33.267]                             muffled <- TRUE
[16:20:33.267]                             break
[16:20:33.267]                           }
[16:20:33.267]                         }
[16:20:33.267]                       }
[16:20:33.267]                       invisible(muffled)
[16:20:33.267]                     }
[16:20:33.267]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.267]                   }
[16:20:33.267]                 }
[16:20:33.267]             }
[16:20:33.267]         }))
[16:20:33.267]     }, error = function(ex) {
[16:20:33.267]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:33.267]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.267]                 ...future.rng), started = ...future.startTime, 
[16:20:33.267]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:33.267]             version = "1.8"), class = "FutureResult")
[16:20:33.267]     }, finally = {
[16:20:33.267]         if (!identical(...future.workdir, getwd())) 
[16:20:33.267]             setwd(...future.workdir)
[16:20:33.267]         {
[16:20:33.267]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:33.267]                 ...future.oldOptions$nwarnings <- NULL
[16:20:33.267]             }
[16:20:33.267]             base::options(...future.oldOptions)
[16:20:33.267]             if (.Platform$OS.type == "windows") {
[16:20:33.267]                 old_names <- names(...future.oldEnvVars)
[16:20:33.267]                 envs <- base::Sys.getenv()
[16:20:33.267]                 names <- names(envs)
[16:20:33.267]                 common <- intersect(names, old_names)
[16:20:33.267]                 added <- setdiff(names, old_names)
[16:20:33.267]                 removed <- setdiff(old_names, names)
[16:20:33.267]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:33.267]                   envs[common]]
[16:20:33.267]                 NAMES <- toupper(changed)
[16:20:33.267]                 args <- list()
[16:20:33.267]                 for (kk in seq_along(NAMES)) {
[16:20:33.267]                   name <- changed[[kk]]
[16:20:33.267]                   NAME <- NAMES[[kk]]
[16:20:33.267]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.267]                     next
[16:20:33.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.267]                 }
[16:20:33.267]                 NAMES <- toupper(added)
[16:20:33.267]                 for (kk in seq_along(NAMES)) {
[16:20:33.267]                   name <- added[[kk]]
[16:20:33.267]                   NAME <- NAMES[[kk]]
[16:20:33.267]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.267]                     next
[16:20:33.267]                   args[[name]] <- ""
[16:20:33.267]                 }
[16:20:33.267]                 NAMES <- toupper(removed)
[16:20:33.267]                 for (kk in seq_along(NAMES)) {
[16:20:33.267]                   name <- removed[[kk]]
[16:20:33.267]                   NAME <- NAMES[[kk]]
[16:20:33.267]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.267]                     next
[16:20:33.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.267]                 }
[16:20:33.267]                 if (length(args) > 0) 
[16:20:33.267]                   base::do.call(base::Sys.setenv, args = args)
[16:20:33.267]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:33.267]             }
[16:20:33.267]             else {
[16:20:33.267]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:33.267]             }
[16:20:33.267]             {
[16:20:33.267]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:33.267]                   0L) {
[16:20:33.267]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:33.267]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:33.267]                   base::options(opts)
[16:20:33.267]                 }
[16:20:33.267]                 {
[16:20:33.267]                   {
[16:20:33.267]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:33.267]                     NULL
[16:20:33.267]                   }
[16:20:33.267]                   options(future.plan = NULL)
[16:20:33.267]                   if (is.na(NA_character_)) 
[16:20:33.267]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.267]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:33.267]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:33.267]                     .init = FALSE)
[16:20:33.267]                 }
[16:20:33.267]             }
[16:20:33.267]         }
[16:20:33.267]     })
[16:20:33.267]     if (TRUE) {
[16:20:33.267]         base::sink(type = "output", split = FALSE)
[16:20:33.267]         if (TRUE) {
[16:20:33.267]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:33.267]         }
[16:20:33.267]         else {
[16:20:33.267]             ...future.result["stdout"] <- base::list(NULL)
[16:20:33.267]         }
[16:20:33.267]         base::close(...future.stdout)
[16:20:33.267]         ...future.stdout <- NULL
[16:20:33.267]     }
[16:20:33.267]     ...future.result$conditions <- ...future.conditions
[16:20:33.267]     ...future.result$finished <- base::Sys.time()
[16:20:33.267]     ...future.result
[16:20:33.267] }
[16:20:33.270] assign_globals() ...
[16:20:33.270] List of 1
[16:20:33.270]  $ ii: int 3
[16:20:33.270]  - attr(*, "where")=List of 1
[16:20:33.270]   ..$ ii:<environment: R_EmptyEnv> 
[16:20:33.270]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:33.270]  - attr(*, "resolved")= logi FALSE
[16:20:33.270]  - attr(*, "total_size")= num 56
[16:20:33.270]  - attr(*, "already-done")= logi TRUE
[16:20:33.274] - copied ‘ii’ to environment
[16:20:33.274] assign_globals() ... done
[16:20:33.274] requestCore(): workers = 2
[16:20:33.274] Poll #1 (0): usedCores() = 2, workers = 2
[16:20:33.286] result() for MulticoreFuture ...
[16:20:33.286] result() for MulticoreFuture ...
[16:20:33.286] result() for MulticoreFuture ... done
[16:20:33.287] result() for MulticoreFuture ... done
[16:20:33.287] result() for MulticoreFuture ...
[16:20:33.287] result() for MulticoreFuture ... done
[16:20:33.289] MulticoreFuture started
[16:20:33.290] - Launch lazy future ... done
[16:20:33.290] run() for ‘MulticoreFuture’ ... done
[16:20:33.291] plan(): Setting new future strategy stack:
[16:20:33.291] result() for MulticoreFuture ...
[16:20:33.291] result() for MulticoreFuture ... done
[16:20:33.291] result() for MulticoreFuture ...
[16:20:33.292] result() for MulticoreFuture ... done
[16:20:33.291] List of future strategies:
[16:20:33.291] 1. sequential:
[16:20:33.291]    - args: function (..., envir = parent.frame())
[16:20:33.291]    - tweaked: FALSE
[16:20:33.291]    - call: NULL
[16:20:33.292] result() for MulticoreFuture ...
[16:20:33.292] plan(): nbrOfWorkers() = 1
[16:20:33.295] plan(): Setting new future strategy stack:
[16:20:33.295] List of future strategies:
[16:20:33.295] 1. multicore:
[16:20:33.295]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:33.295]    - tweaked: FALSE
[16:20:33.295]    - call: plan(strategy)
[16:20:33.297] result() for MulticoreFuture ...
[16:20:33.297] result() for MulticoreFuture ... done
[16:20:33.297] signalConditions() ...
[16:20:33.297]  - include = ‘immediateCondition’
[16:20:33.298]  - exclude = 
[16:20:33.298]  - resignal = FALSE
[16:20:33.298]  - Number of conditions: 1
[16:20:33.298] signalConditions() ... done
[16:20:33.298] result() for MulticoreFuture ... done
[16:20:33.298] result() for MulticoreFuture ...
[16:20:33.299] result() for MulticoreFuture ... done
[16:20:33.299] signalConditions() ...
[16:20:33.299]  - include = ‘immediateCondition’
[16:20:33.299]  - exclude = 
[16:20:33.299]  - resignal = FALSE
[16:20:33.300]  - Number of conditions: 1
[16:20:33.300] signalConditions() ... done
[16:20:33.300] Future state: ‘finished’
[16:20:33.301] result() for MulticoreFuture ...
[16:20:33.301] result() for MulticoreFuture ... done
[16:20:33.301] signalConditions() ...
[16:20:33.301]  - include = ‘condition’
[16:20:33.301]  - exclude = ‘immediateCondition’
[16:20:33.302]  - resignal = TRUE
[16:20:33.302] plan(): nbrOfWorkers() = 2
[16:20:33.302]  - Number of conditions: 1
[16:20:33.302]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:20:33.302] signalConditions() ... done
[16:20:33.303] result() for MulticoreFuture ...
[16:20:33.303] result() for MulticoreFuture ...
[16:20:33.304] result() for MulticoreFuture ... done
[16:20:33.304] result() for MulticoreFuture ... done
[16:20:33.304] result() for MulticoreFuture ...
[16:20:33.304] result() for MulticoreFuture ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[16:20:33.305] result() for MulticoreFuture ...
[16:20:33.305] result() for MulticoreFuture ... done
[16:20:33.305] result() for MulticoreFuture ...
[16:20:33.305] result() for MulticoreFuture ... done
[16:20:33.306] signalConditions() ...
[16:20:33.306]  - include = ‘immediateCondition’
[16:20:33.306]  - exclude = 
[16:20:33.306]  - resignal = FALSE
[16:20:33.306]  - Number of conditions: 1
[16:20:33.306] signalConditions() ... done
[16:20:33.306] Future state: ‘finished’
[16:20:33.306] result() for MulticoreFuture ...
[16:20:33.307] result() for MulticoreFuture ... done
[16:20:33.307] signalConditions() ...
[16:20:33.307]  - include = ‘condition’
[16:20:33.307]  - exclude = ‘immediateCondition’
[16:20:33.307]  - resignal = TRUE
[16:20:33.307]  - Number of conditions: 1
[16:20:33.307]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:20:33.307] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[16:20:33.308] result() for MulticoreFuture ...
[16:20:33.308] result() for MulticoreFuture ... done
[16:20:33.308] result() for MulticoreFuture ...
[16:20:33.308] result() for MulticoreFuture ... done
[16:20:33.308] signalConditions() ...
[16:20:33.308]  - include = ‘immediateCondition’
[16:20:33.308]  - exclude = 
[16:20:33.309]  - resignal = FALSE
[16:20:33.309]  - Number of conditions: 1
[16:20:33.309] signalConditions() ... done
[16:20:33.309] Future state: ‘finished’
[16:20:33.309] result() for MulticoreFuture ...
[16:20:33.309] result() for MulticoreFuture ... done
[16:20:33.309] signalConditions() ...
[16:20:33.309]  - include = ‘condition’
[16:20:33.309]  - exclude = ‘immediateCondition’
[16:20:33.310]  - resignal = TRUE
[16:20:33.312]  - Number of conditions: 1
[16:20:33.313]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:20:33.313] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[16:20:33.313] getGlobalsAndPackages() ...
[16:20:33.313] Searching for globals...
[16:20:33.316] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[16:20:33.317] Searching for globals ... DONE
[16:20:33.317] Resolving globals: FALSE
[16:20:33.317] 
[16:20:33.317] 
[16:20:33.317] getGlobalsAndPackages() ... DONE
[16:20:33.318] run() for ‘Future’ ...
[16:20:33.318] - state: ‘created’
[16:20:33.318] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:33.322] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:33.322] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:33.322]   - Field: ‘label’
[16:20:33.322]   - Field: ‘local’
[16:20:33.323]   - Field: ‘owner’
[16:20:33.323]   - Field: ‘envir’
[16:20:33.323]   - Field: ‘workers’
[16:20:33.323]   - Field: ‘packages’
[16:20:33.323]   - Field: ‘gc’
[16:20:33.323]   - Field: ‘job’
[16:20:33.323]   - Field: ‘conditions’
[16:20:33.323]   - Field: ‘expr’
[16:20:33.324]   - Field: ‘uuid’
[16:20:33.324]   - Field: ‘seed’
[16:20:33.324]   - Field: ‘version’
[16:20:33.324]   - Field: ‘result’
[16:20:33.324]   - Field: ‘asynchronous’
[16:20:33.324]   - Field: ‘calls’
[16:20:33.324]   - Field: ‘globals’
[16:20:33.324]   - Field: ‘stdout’
[16:20:33.325]   - Field: ‘earlySignal’
[16:20:33.325]   - Field: ‘lazy’
[16:20:33.325]   - Field: ‘state’
[16:20:33.325] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:33.325] - Launch lazy future ...
[16:20:33.325] Packages needed by the future expression (n = 0): <none>
[16:20:33.325] Packages needed by future strategies (n = 0): <none>
[16:20:33.326] {
[16:20:33.326]     {
[16:20:33.326]         {
[16:20:33.326]             ...future.startTime <- base::Sys.time()
[16:20:33.326]             {
[16:20:33.326]                 {
[16:20:33.326]                   {
[16:20:33.326]                     {
[16:20:33.326]                       base::local({
[16:20:33.326]                         has_future <- base::requireNamespace("future", 
[16:20:33.326]                           quietly = TRUE)
[16:20:33.326]                         if (has_future) {
[16:20:33.326]                           ns <- base::getNamespace("future")
[16:20:33.326]                           version <- ns[[".package"]][["version"]]
[16:20:33.326]                           if (is.null(version)) 
[16:20:33.326]                             version <- utils::packageVersion("future")
[16:20:33.326]                         }
[16:20:33.326]                         else {
[16:20:33.326]                           version <- NULL
[16:20:33.326]                         }
[16:20:33.326]                         if (!has_future || version < "1.8.0") {
[16:20:33.326]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:33.326]                             "", base::R.version$version.string), 
[16:20:33.326]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:33.326]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:33.326]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:33.326]                               "release", "version")], collapse = " "), 
[16:20:33.326]                             hostname = base::Sys.info()[["nodename"]])
[16:20:33.326]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:33.326]                             info)
[16:20:33.326]                           info <- base::paste(info, collapse = "; ")
[16:20:33.326]                           if (!has_future) {
[16:20:33.326]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:33.326]                               info)
[16:20:33.326]                           }
[16:20:33.326]                           else {
[16:20:33.326]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:33.326]                               info, version)
[16:20:33.326]                           }
[16:20:33.326]                           base::stop(msg)
[16:20:33.326]                         }
[16:20:33.326]                       })
[16:20:33.326]                     }
[16:20:33.326]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:33.326]                     base::options(mc.cores = 1L)
[16:20:33.326]                   }
[16:20:33.326]                   ...future.strategy.old <- future::plan("list")
[16:20:33.326]                   options(future.plan = NULL)
[16:20:33.326]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.326]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:33.326]                 }
[16:20:33.326]                 ...future.workdir <- getwd()
[16:20:33.326]             }
[16:20:33.326]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:33.326]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:33.326]         }
[16:20:33.326]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:33.326]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:33.326]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:33.326]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:33.326]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:33.326]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:33.326]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:33.326]             base::names(...future.oldOptions))
[16:20:33.326]     }
[16:20:33.326]     if (FALSE) {
[16:20:33.326]     }
[16:20:33.326]     else {
[16:20:33.326]         if (TRUE) {
[16:20:33.326]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:33.326]                 open = "w")
[16:20:33.326]         }
[16:20:33.326]         else {
[16:20:33.326]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:33.326]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:33.326]         }
[16:20:33.326]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:33.326]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:33.326]             base::sink(type = "output", split = FALSE)
[16:20:33.326]             base::close(...future.stdout)
[16:20:33.326]         }, add = TRUE)
[16:20:33.326]     }
[16:20:33.326]     ...future.frame <- base::sys.nframe()
[16:20:33.326]     ...future.conditions <- base::list()
[16:20:33.326]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:33.326]     if (FALSE) {
[16:20:33.326]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:33.326]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:33.326]     }
[16:20:33.326]     ...future.result <- base::tryCatch({
[16:20:33.326]         base::withCallingHandlers({
[16:20:33.326]             ...future.value <- base::withVisible(base::local({
[16:20:33.326]                 withCallingHandlers({
[16:20:33.326]                   {
[16:20:33.326]                     cat("Processing: ")
[16:20:33.326]                     for (ii in 1:10) {
[16:20:33.326]                       cat(".")
[16:20:33.326]                     }
[16:20:33.326]                     cat(" [100%]\n")
[16:20:33.326]                     4
[16:20:33.326]                   }
[16:20:33.326]                 }, immediateCondition = function(cond) {
[16:20:33.326]                   save_rds <- function (object, pathname, ...) 
[16:20:33.326]                   {
[16:20:33.326]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:33.326]                     if (file_test("-f", pathname_tmp)) {
[16:20:33.326]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.326]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:33.326]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.326]                         fi_tmp[["mtime"]])
[16:20:33.326]                     }
[16:20:33.326]                     tryCatch({
[16:20:33.326]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:33.326]                     }, error = function(ex) {
[16:20:33.326]                       msg <- conditionMessage(ex)
[16:20:33.326]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.326]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:33.326]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.326]                         fi_tmp[["mtime"]], msg)
[16:20:33.326]                       ex$message <- msg
[16:20:33.326]                       stop(ex)
[16:20:33.326]                     })
[16:20:33.326]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:33.326]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:33.326]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:33.326]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.326]                       fi <- file.info(pathname)
[16:20:33.326]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:33.326]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.326]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:33.326]                         fi[["size"]], fi[["mtime"]])
[16:20:33.326]                       stop(msg)
[16:20:33.326]                     }
[16:20:33.326]                     invisible(pathname)
[16:20:33.326]                   }
[16:20:33.326]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:33.326]                     rootPath = tempdir()) 
[16:20:33.326]                   {
[16:20:33.326]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:33.326]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:33.326]                       tmpdir = path, fileext = ".rds")
[16:20:33.326]                     save_rds(obj, file)
[16:20:33.326]                   }
[16:20:33.326]                   saveImmediateCondition(cond, path = "/tmp/RtmpFUh73Z/.future/immediateConditions")
[16:20:33.326]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.326]                   {
[16:20:33.326]                     inherits <- base::inherits
[16:20:33.326]                     invokeRestart <- base::invokeRestart
[16:20:33.326]                     is.null <- base::is.null
[16:20:33.326]                     muffled <- FALSE
[16:20:33.326]                     if (inherits(cond, "message")) {
[16:20:33.326]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:33.326]                       if (muffled) 
[16:20:33.326]                         invokeRestart("muffleMessage")
[16:20:33.326]                     }
[16:20:33.326]                     else if (inherits(cond, "warning")) {
[16:20:33.326]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:33.326]                       if (muffled) 
[16:20:33.326]                         invokeRestart("muffleWarning")
[16:20:33.326]                     }
[16:20:33.326]                     else if (inherits(cond, "condition")) {
[16:20:33.326]                       if (!is.null(pattern)) {
[16:20:33.326]                         computeRestarts <- base::computeRestarts
[16:20:33.326]                         grepl <- base::grepl
[16:20:33.326]                         restarts <- computeRestarts(cond)
[16:20:33.326]                         for (restart in restarts) {
[16:20:33.326]                           name <- restart$name
[16:20:33.326]                           if (is.null(name)) 
[16:20:33.326]                             next
[16:20:33.326]                           if (!grepl(pattern, name)) 
[16:20:33.326]                             next
[16:20:33.326]                           invokeRestart(restart)
[16:20:33.326]                           muffled <- TRUE
[16:20:33.326]                           break
[16:20:33.326]                         }
[16:20:33.326]                       }
[16:20:33.326]                     }
[16:20:33.326]                     invisible(muffled)
[16:20:33.326]                   }
[16:20:33.326]                   muffleCondition(cond)
[16:20:33.326]                 })
[16:20:33.326]             }))
[16:20:33.326]             future::FutureResult(value = ...future.value$value, 
[16:20:33.326]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.326]                   ...future.rng), globalenv = if (FALSE) 
[16:20:33.326]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:33.326]                     ...future.globalenv.names))
[16:20:33.326]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:33.326]         }, condition = base::local({
[16:20:33.326]             c <- base::c
[16:20:33.326]             inherits <- base::inherits
[16:20:33.326]             invokeRestart <- base::invokeRestart
[16:20:33.326]             length <- base::length
[16:20:33.326]             list <- base::list
[16:20:33.326]             seq.int <- base::seq.int
[16:20:33.326]             signalCondition <- base::signalCondition
[16:20:33.326]             sys.calls <- base::sys.calls
[16:20:33.326]             `[[` <- base::`[[`
[16:20:33.326]             `+` <- base::`+`
[16:20:33.326]             `<<-` <- base::`<<-`
[16:20:33.326]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:33.326]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:33.326]                   3L)]
[16:20:33.326]             }
[16:20:33.326]             function(cond) {
[16:20:33.326]                 is_error <- inherits(cond, "error")
[16:20:33.326]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:33.326]                   NULL)
[16:20:33.326]                 if (is_error) {
[16:20:33.326]                   sessionInformation <- function() {
[16:20:33.326]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:33.326]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:33.326]                       search = base::search(), system = base::Sys.info())
[16:20:33.326]                   }
[16:20:33.326]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.326]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:33.326]                     cond$call), session = sessionInformation(), 
[16:20:33.326]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:33.326]                   signalCondition(cond)
[16:20:33.326]                 }
[16:20:33.326]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:33.326]                 "immediateCondition"))) {
[16:20:33.326]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:33.326]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.326]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:33.326]                   if (TRUE && !signal) {
[16:20:33.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.326]                     {
[16:20:33.326]                       inherits <- base::inherits
[16:20:33.326]                       invokeRestart <- base::invokeRestart
[16:20:33.326]                       is.null <- base::is.null
[16:20:33.326]                       muffled <- FALSE
[16:20:33.326]                       if (inherits(cond, "message")) {
[16:20:33.326]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.326]                         if (muffled) 
[16:20:33.326]                           invokeRestart("muffleMessage")
[16:20:33.326]                       }
[16:20:33.326]                       else if (inherits(cond, "warning")) {
[16:20:33.326]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.326]                         if (muffled) 
[16:20:33.326]                           invokeRestart("muffleWarning")
[16:20:33.326]                       }
[16:20:33.326]                       else if (inherits(cond, "condition")) {
[16:20:33.326]                         if (!is.null(pattern)) {
[16:20:33.326]                           computeRestarts <- base::computeRestarts
[16:20:33.326]                           grepl <- base::grepl
[16:20:33.326]                           restarts <- computeRestarts(cond)
[16:20:33.326]                           for (restart in restarts) {
[16:20:33.326]                             name <- restart$name
[16:20:33.326]                             if (is.null(name)) 
[16:20:33.326]                               next
[16:20:33.326]                             if (!grepl(pattern, name)) 
[16:20:33.326]                               next
[16:20:33.326]                             invokeRestart(restart)
[16:20:33.326]                             muffled <- TRUE
[16:20:33.326]                             break
[16:20:33.326]                           }
[16:20:33.326]                         }
[16:20:33.326]                       }
[16:20:33.326]                       invisible(muffled)
[16:20:33.326]                     }
[16:20:33.326]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.326]                   }
[16:20:33.326]                 }
[16:20:33.326]                 else {
[16:20:33.326]                   if (TRUE) {
[16:20:33.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.326]                     {
[16:20:33.326]                       inherits <- base::inherits
[16:20:33.326]                       invokeRestart <- base::invokeRestart
[16:20:33.326]                       is.null <- base::is.null
[16:20:33.326]                       muffled <- FALSE
[16:20:33.326]                       if (inherits(cond, "message")) {
[16:20:33.326]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.326]                         if (muffled) 
[16:20:33.326]                           invokeRestart("muffleMessage")
[16:20:33.326]                       }
[16:20:33.326]                       else if (inherits(cond, "warning")) {
[16:20:33.326]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.326]                         if (muffled) 
[16:20:33.326]                           invokeRestart("muffleWarning")
[16:20:33.326]                       }
[16:20:33.326]                       else if (inherits(cond, "condition")) {
[16:20:33.326]                         if (!is.null(pattern)) {
[16:20:33.326]                           computeRestarts <- base::computeRestarts
[16:20:33.326]                           grepl <- base::grepl
[16:20:33.326]                           restarts <- computeRestarts(cond)
[16:20:33.326]                           for (restart in restarts) {
[16:20:33.326]                             name <- restart$name
[16:20:33.326]                             if (is.null(name)) 
[16:20:33.326]                               next
[16:20:33.326]                             if (!grepl(pattern, name)) 
[16:20:33.326]                               next
[16:20:33.326]                             invokeRestart(restart)
[16:20:33.326]                             muffled <- TRUE
[16:20:33.326]                             break
[16:20:33.326]                           }
[16:20:33.326]                         }
[16:20:33.326]                       }
[16:20:33.326]                       invisible(muffled)
[16:20:33.326]                     }
[16:20:33.326]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.326]                   }
[16:20:33.326]                 }
[16:20:33.326]             }
[16:20:33.326]         }))
[16:20:33.326]     }, error = function(ex) {
[16:20:33.326]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:33.326]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.326]                 ...future.rng), started = ...future.startTime, 
[16:20:33.326]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:33.326]             version = "1.8"), class = "FutureResult")
[16:20:33.326]     }, finally = {
[16:20:33.326]         if (!identical(...future.workdir, getwd())) 
[16:20:33.326]             setwd(...future.workdir)
[16:20:33.326]         {
[16:20:33.326]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:33.326]                 ...future.oldOptions$nwarnings <- NULL
[16:20:33.326]             }
[16:20:33.326]             base::options(...future.oldOptions)
[16:20:33.326]             if (.Platform$OS.type == "windows") {
[16:20:33.326]                 old_names <- names(...future.oldEnvVars)
[16:20:33.326]                 envs <- base::Sys.getenv()
[16:20:33.326]                 names <- names(envs)
[16:20:33.326]                 common <- intersect(names, old_names)
[16:20:33.326]                 added <- setdiff(names, old_names)
[16:20:33.326]                 removed <- setdiff(old_names, names)
[16:20:33.326]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:33.326]                   envs[common]]
[16:20:33.326]                 NAMES <- toupper(changed)
[16:20:33.326]                 args <- list()
[16:20:33.326]                 for (kk in seq_along(NAMES)) {
[16:20:33.326]                   name <- changed[[kk]]
[16:20:33.326]                   NAME <- NAMES[[kk]]
[16:20:33.326]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.326]                     next
[16:20:33.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.326]                 }
[16:20:33.326]                 NAMES <- toupper(added)
[16:20:33.326]                 for (kk in seq_along(NAMES)) {
[16:20:33.326]                   name <- added[[kk]]
[16:20:33.326]                   NAME <- NAMES[[kk]]
[16:20:33.326]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.326]                     next
[16:20:33.326]                   args[[name]] <- ""
[16:20:33.326]                 }
[16:20:33.326]                 NAMES <- toupper(removed)
[16:20:33.326]                 for (kk in seq_along(NAMES)) {
[16:20:33.326]                   name <- removed[[kk]]
[16:20:33.326]                   NAME <- NAMES[[kk]]
[16:20:33.326]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.326]                     next
[16:20:33.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.326]                 }
[16:20:33.326]                 if (length(args) > 0) 
[16:20:33.326]                   base::do.call(base::Sys.setenv, args = args)
[16:20:33.326]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:33.326]             }
[16:20:33.326]             else {
[16:20:33.326]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:33.326]             }
[16:20:33.326]             {
[16:20:33.326]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:33.326]                   0L) {
[16:20:33.326]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:33.326]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:33.326]                   base::options(opts)
[16:20:33.326]                 }
[16:20:33.326]                 {
[16:20:33.326]                   {
[16:20:33.326]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:33.326]                     NULL
[16:20:33.326]                   }
[16:20:33.326]                   options(future.plan = NULL)
[16:20:33.326]                   if (is.na(NA_character_)) 
[16:20:33.326]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.326]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:33.326]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:33.326]                     .init = FALSE)
[16:20:33.326]                 }
[16:20:33.326]             }
[16:20:33.326]         }
[16:20:33.326]     })
[16:20:33.326]     if (TRUE) {
[16:20:33.326]         base::sink(type = "output", split = FALSE)
[16:20:33.326]         if (TRUE) {
[16:20:33.326]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:33.326]         }
[16:20:33.326]         else {
[16:20:33.326]             ...future.result["stdout"] <- base::list(NULL)
[16:20:33.326]         }
[16:20:33.326]         base::close(...future.stdout)
[16:20:33.326]         ...future.stdout <- NULL
[16:20:33.326]     }
[16:20:33.326]     ...future.result$conditions <- ...future.conditions
[16:20:33.326]     ...future.result$finished <- base::Sys.time()
[16:20:33.326]     ...future.result
[16:20:33.326] }
[16:20:33.328] requestCore(): workers = 2
[16:20:33.330] MulticoreFuture started
[16:20:33.330] - Launch lazy future ... done
[16:20:33.331] run() for ‘MulticoreFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[16:20:33.331] plan(): Setting new future strategy stack:
[16:20:33.332] result() for MulticoreFuture ...
[16:20:33.332] result() for MulticoreFuture ... done
[16:20:33.332] result() for MulticoreFuture ...
[16:20:33.332] result() for MulticoreFuture ... done
[16:20:33.332] List of future strategies:
[16:20:33.332] 1. sequential:
[16:20:33.332]    - args: function (..., envir = parent.frame())
[16:20:33.332]    - tweaked: FALSE
[16:20:33.332]    - call: NULL
[16:20:33.332] signalConditions() ...
[16:20:33.332] plan(): nbrOfWorkers() = 1
[16:20:33.332]  - include = ‘immediateCondition’
[16:20:33.333]  - exclude = 
[16:20:33.333]  - resignal = FALSE
[16:20:33.333]  - Number of conditions: 1
[16:20:33.333] signalConditions() ... done
[16:20:33.333] Future state: ‘finished’
[16:20:33.333] result() for MulticoreFuture ...
[16:20:33.334] result() for MulticoreFuture ... done
[16:20:33.334] signalConditions() ...
[16:20:33.334]  - include = ‘condition’
[16:20:33.334]  - exclude = ‘immediateCondition’
[16:20:33.334]  - resignal = TRUE
[16:20:33.334] plan(): Setting new future strategy stack:
[16:20:33.334]  - Number of conditions: 1
[16:20:33.334]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:20:33.335] signalConditions() ... done
v3: <simpleError> (as expect)
[16:20:33.334] List of future strategies:
[16:20:33.334] 1. multicore:
[16:20:33.334]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:33.334]    - tweaked: FALSE
[16:20:33.334]    - call: plan(strategy)
[16:20:33.335] result() for MulticoreFuture ...
[16:20:33.339] plan(): nbrOfWorkers() = 2
[16:20:33.340] result() for MulticoreFuture ...
[16:20:33.340] result() for MulticoreFuture ... done
[16:20:33.340] result() for MulticoreFuture ... done
[16:20:33.340] result() for MulticoreFuture ...
[16:20:33.340] result() for MulticoreFuture ... done
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[16:20:33.341] getGlobalsAndPackages() ...
[16:20:33.341] Searching for globals...
[16:20:33.342] 
[16:20:33.342] Searching for globals ... DONE
[16:20:33.342] - globals: [0] <none>
[16:20:33.342] getGlobalsAndPackages() ... DONE
[16:20:33.342] run() for ‘Future’ ...
[16:20:33.342] - state: ‘created’
[16:20:33.342] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:33.347] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:33.347] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:33.347]   - Field: ‘label’
[16:20:33.347]   - Field: ‘local’
[16:20:33.347]   - Field: ‘owner’
[16:20:33.347]   - Field: ‘envir’
[16:20:33.347]   - Field: ‘workers’
[16:20:33.348]   - Field: ‘packages’
[16:20:33.348]   - Field: ‘gc’
[16:20:33.348]   - Field: ‘job’
[16:20:33.348]   - Field: ‘conditions’
[16:20:33.348]   - Field: ‘expr’
[16:20:33.348]   - Field: ‘uuid’
[16:20:33.348]   - Field: ‘seed’
[16:20:33.348]   - Field: ‘version’
[16:20:33.349]   - Field: ‘result’
[16:20:33.349]   - Field: ‘asynchronous’
[16:20:33.349]   - Field: ‘calls’
[16:20:33.349]   - Field: ‘globals’
[16:20:33.349]   - Field: ‘stdout’
[16:20:33.349]   - Field: ‘earlySignal’
[16:20:33.349]   - Field: ‘lazy’
[16:20:33.349]   - Field: ‘state’
[16:20:33.349] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:33.350] - Launch lazy future ...
[16:20:33.350] Packages needed by the future expression (n = 0): <none>
[16:20:33.350] Packages needed by future strategies (n = 0): <none>
[16:20:33.351] {
[16:20:33.351]     {
[16:20:33.351]         {
[16:20:33.351]             ...future.startTime <- base::Sys.time()
[16:20:33.351]             {
[16:20:33.351]                 {
[16:20:33.351]                   {
[16:20:33.351]                     {
[16:20:33.351]                       base::local({
[16:20:33.351]                         has_future <- base::requireNamespace("future", 
[16:20:33.351]                           quietly = TRUE)
[16:20:33.351]                         if (has_future) {
[16:20:33.351]                           ns <- base::getNamespace("future")
[16:20:33.351]                           version <- ns[[".package"]][["version"]]
[16:20:33.351]                           if (is.null(version)) 
[16:20:33.351]                             version <- utils::packageVersion("future")
[16:20:33.351]                         }
[16:20:33.351]                         else {
[16:20:33.351]                           version <- NULL
[16:20:33.351]                         }
[16:20:33.351]                         if (!has_future || version < "1.8.0") {
[16:20:33.351]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:33.351]                             "", base::R.version$version.string), 
[16:20:33.351]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:33.351]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:33.351]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:33.351]                               "release", "version")], collapse = " "), 
[16:20:33.351]                             hostname = base::Sys.info()[["nodename"]])
[16:20:33.351]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:33.351]                             info)
[16:20:33.351]                           info <- base::paste(info, collapse = "; ")
[16:20:33.351]                           if (!has_future) {
[16:20:33.351]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:33.351]                               info)
[16:20:33.351]                           }
[16:20:33.351]                           else {
[16:20:33.351]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:33.351]                               info, version)
[16:20:33.351]                           }
[16:20:33.351]                           base::stop(msg)
[16:20:33.351]                         }
[16:20:33.351]                       })
[16:20:33.351]                     }
[16:20:33.351]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:33.351]                     base::options(mc.cores = 1L)
[16:20:33.351]                   }
[16:20:33.351]                   ...future.strategy.old <- future::plan("list")
[16:20:33.351]                   options(future.plan = NULL)
[16:20:33.351]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.351]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:33.351]                 }
[16:20:33.351]                 ...future.workdir <- getwd()
[16:20:33.351]             }
[16:20:33.351]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:33.351]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:33.351]         }
[16:20:33.351]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:33.351]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:33.351]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:33.351]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:33.351]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:33.351]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:33.351]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:33.351]             base::names(...future.oldOptions))
[16:20:33.351]     }
[16:20:33.351]     if (FALSE) {
[16:20:33.351]     }
[16:20:33.351]     else {
[16:20:33.351]         if (TRUE) {
[16:20:33.351]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:33.351]                 open = "w")
[16:20:33.351]         }
[16:20:33.351]         else {
[16:20:33.351]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:33.351]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:33.351]         }
[16:20:33.351]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:33.351]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:33.351]             base::sink(type = "output", split = FALSE)
[16:20:33.351]             base::close(...future.stdout)
[16:20:33.351]         }, add = TRUE)
[16:20:33.351]     }
[16:20:33.351]     ...future.frame <- base::sys.nframe()
[16:20:33.351]     ...future.conditions <- base::list()
[16:20:33.351]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:33.351]     if (FALSE) {
[16:20:33.351]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:33.351]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:33.351]     }
[16:20:33.351]     ...future.result <- base::tryCatch({
[16:20:33.351]         base::withCallingHandlers({
[16:20:33.351]             ...future.value <- base::withVisible(base::local({
[16:20:33.351]                 withCallingHandlers({
[16:20:33.351]                   1
[16:20:33.351]                 }, immediateCondition = function(cond) {
[16:20:33.351]                   save_rds <- function (object, pathname, ...) 
[16:20:33.351]                   {
[16:20:33.351]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:33.351]                     if (file_test("-f", pathname_tmp)) {
[16:20:33.351]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.351]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:33.351]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.351]                         fi_tmp[["mtime"]])
[16:20:33.351]                     }
[16:20:33.351]                     tryCatch({
[16:20:33.351]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:33.351]                     }, error = function(ex) {
[16:20:33.351]                       msg <- conditionMessage(ex)
[16:20:33.351]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.351]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:33.351]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.351]                         fi_tmp[["mtime"]], msg)
[16:20:33.351]                       ex$message <- msg
[16:20:33.351]                       stop(ex)
[16:20:33.351]                     })
[16:20:33.351]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:33.351]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:33.351]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:33.351]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.351]                       fi <- file.info(pathname)
[16:20:33.351]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:33.351]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.351]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:33.351]                         fi[["size"]], fi[["mtime"]])
[16:20:33.351]                       stop(msg)
[16:20:33.351]                     }
[16:20:33.351]                     invisible(pathname)
[16:20:33.351]                   }
[16:20:33.351]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:33.351]                     rootPath = tempdir()) 
[16:20:33.351]                   {
[16:20:33.351]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:33.351]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:33.351]                       tmpdir = path, fileext = ".rds")
[16:20:33.351]                     save_rds(obj, file)
[16:20:33.351]                   }
[16:20:33.351]                   saveImmediateCondition(cond, path = "/tmp/RtmpFUh73Z/.future/immediateConditions")
[16:20:33.351]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.351]                   {
[16:20:33.351]                     inherits <- base::inherits
[16:20:33.351]                     invokeRestart <- base::invokeRestart
[16:20:33.351]                     is.null <- base::is.null
[16:20:33.351]                     muffled <- FALSE
[16:20:33.351]                     if (inherits(cond, "message")) {
[16:20:33.351]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:33.351]                       if (muffled) 
[16:20:33.351]                         invokeRestart("muffleMessage")
[16:20:33.351]                     }
[16:20:33.351]                     else if (inherits(cond, "warning")) {
[16:20:33.351]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:33.351]                       if (muffled) 
[16:20:33.351]                         invokeRestart("muffleWarning")
[16:20:33.351]                     }
[16:20:33.351]                     else if (inherits(cond, "condition")) {
[16:20:33.351]                       if (!is.null(pattern)) {
[16:20:33.351]                         computeRestarts <- base::computeRestarts
[16:20:33.351]                         grepl <- base::grepl
[16:20:33.351]                         restarts <- computeRestarts(cond)
[16:20:33.351]                         for (restart in restarts) {
[16:20:33.351]                           name <- restart$name
[16:20:33.351]                           if (is.null(name)) 
[16:20:33.351]                             next
[16:20:33.351]                           if (!grepl(pattern, name)) 
[16:20:33.351]                             next
[16:20:33.351]                           invokeRestart(restart)
[16:20:33.351]                           muffled <- TRUE
[16:20:33.351]                           break
[16:20:33.351]                         }
[16:20:33.351]                       }
[16:20:33.351]                     }
[16:20:33.351]                     invisible(muffled)
[16:20:33.351]                   }
[16:20:33.351]                   muffleCondition(cond)
[16:20:33.351]                 })
[16:20:33.351]             }))
[16:20:33.351]             future::FutureResult(value = ...future.value$value, 
[16:20:33.351]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.351]                   ...future.rng), globalenv = if (FALSE) 
[16:20:33.351]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:33.351]                     ...future.globalenv.names))
[16:20:33.351]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:33.351]         }, condition = base::local({
[16:20:33.351]             c <- base::c
[16:20:33.351]             inherits <- base::inherits
[16:20:33.351]             invokeRestart <- base::invokeRestart
[16:20:33.351]             length <- base::length
[16:20:33.351]             list <- base::list
[16:20:33.351]             seq.int <- base::seq.int
[16:20:33.351]             signalCondition <- base::signalCondition
[16:20:33.351]             sys.calls <- base::sys.calls
[16:20:33.351]             `[[` <- base::`[[`
[16:20:33.351]             `+` <- base::`+`
[16:20:33.351]             `<<-` <- base::`<<-`
[16:20:33.351]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:33.351]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:33.351]                   3L)]
[16:20:33.351]             }
[16:20:33.351]             function(cond) {
[16:20:33.351]                 is_error <- inherits(cond, "error")
[16:20:33.351]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:33.351]                   NULL)
[16:20:33.351]                 if (is_error) {
[16:20:33.351]                   sessionInformation <- function() {
[16:20:33.351]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:33.351]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:33.351]                       search = base::search(), system = base::Sys.info())
[16:20:33.351]                   }
[16:20:33.351]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.351]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:33.351]                     cond$call), session = sessionInformation(), 
[16:20:33.351]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:33.351]                   signalCondition(cond)
[16:20:33.351]                 }
[16:20:33.351]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:33.351]                 "immediateCondition"))) {
[16:20:33.351]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:33.351]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.351]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:33.351]                   if (TRUE && !signal) {
[16:20:33.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.351]                     {
[16:20:33.351]                       inherits <- base::inherits
[16:20:33.351]                       invokeRestart <- base::invokeRestart
[16:20:33.351]                       is.null <- base::is.null
[16:20:33.351]                       muffled <- FALSE
[16:20:33.351]                       if (inherits(cond, "message")) {
[16:20:33.351]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.351]                         if (muffled) 
[16:20:33.351]                           invokeRestart("muffleMessage")
[16:20:33.351]                       }
[16:20:33.351]                       else if (inherits(cond, "warning")) {
[16:20:33.351]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.351]                         if (muffled) 
[16:20:33.351]                           invokeRestart("muffleWarning")
[16:20:33.351]                       }
[16:20:33.351]                       else if (inherits(cond, "condition")) {
[16:20:33.351]                         if (!is.null(pattern)) {
[16:20:33.351]                           computeRestarts <- base::computeRestarts
[16:20:33.351]                           grepl <- base::grepl
[16:20:33.351]                           restarts <- computeRestarts(cond)
[16:20:33.351]                           for (restart in restarts) {
[16:20:33.351]                             name <- restart$name
[16:20:33.351]                             if (is.null(name)) 
[16:20:33.351]                               next
[16:20:33.351]                             if (!grepl(pattern, name)) 
[16:20:33.351]                               next
[16:20:33.351]                             invokeRestart(restart)
[16:20:33.351]                             muffled <- TRUE
[16:20:33.351]                             break
[16:20:33.351]                           }
[16:20:33.351]                         }
[16:20:33.351]                       }
[16:20:33.351]                       invisible(muffled)
[16:20:33.351]                     }
[16:20:33.351]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.351]                   }
[16:20:33.351]                 }
[16:20:33.351]                 else {
[16:20:33.351]                   if (TRUE) {
[16:20:33.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.351]                     {
[16:20:33.351]                       inherits <- base::inherits
[16:20:33.351]                       invokeRestart <- base::invokeRestart
[16:20:33.351]                       is.null <- base::is.null
[16:20:33.351]                       muffled <- FALSE
[16:20:33.351]                       if (inherits(cond, "message")) {
[16:20:33.351]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.351]                         if (muffled) 
[16:20:33.351]                           invokeRestart("muffleMessage")
[16:20:33.351]                       }
[16:20:33.351]                       else if (inherits(cond, "warning")) {
[16:20:33.351]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.351]                         if (muffled) 
[16:20:33.351]                           invokeRestart("muffleWarning")
[16:20:33.351]                       }
[16:20:33.351]                       else if (inherits(cond, "condition")) {
[16:20:33.351]                         if (!is.null(pattern)) {
[16:20:33.351]                           computeRestarts <- base::computeRestarts
[16:20:33.351]                           grepl <- base::grepl
[16:20:33.351]                           restarts <- computeRestarts(cond)
[16:20:33.351]                           for (restart in restarts) {
[16:20:33.351]                             name <- restart$name
[16:20:33.351]                             if (is.null(name)) 
[16:20:33.351]                               next
[16:20:33.351]                             if (!grepl(pattern, name)) 
[16:20:33.351]                               next
[16:20:33.351]                             invokeRestart(restart)
[16:20:33.351]                             muffled <- TRUE
[16:20:33.351]                             break
[16:20:33.351]                           }
[16:20:33.351]                         }
[16:20:33.351]                       }
[16:20:33.351]                       invisible(muffled)
[16:20:33.351]                     }
[16:20:33.351]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.351]                   }
[16:20:33.351]                 }
[16:20:33.351]             }
[16:20:33.351]         }))
[16:20:33.351]     }, error = function(ex) {
[16:20:33.351]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:33.351]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.351]                 ...future.rng), started = ...future.startTime, 
[16:20:33.351]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:33.351]             version = "1.8"), class = "FutureResult")
[16:20:33.351]     }, finally = {
[16:20:33.351]         if (!identical(...future.workdir, getwd())) 
[16:20:33.351]             setwd(...future.workdir)
[16:20:33.351]         {
[16:20:33.351]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:33.351]                 ...future.oldOptions$nwarnings <- NULL
[16:20:33.351]             }
[16:20:33.351]             base::options(...future.oldOptions)
[16:20:33.351]             if (.Platform$OS.type == "windows") {
[16:20:33.351]                 old_names <- names(...future.oldEnvVars)
[16:20:33.351]                 envs <- base::Sys.getenv()
[16:20:33.351]                 names <- names(envs)
[16:20:33.351]                 common <- intersect(names, old_names)
[16:20:33.351]                 added <- setdiff(names, old_names)
[16:20:33.351]                 removed <- setdiff(old_names, names)
[16:20:33.351]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:33.351]                   envs[common]]
[16:20:33.351]                 NAMES <- toupper(changed)
[16:20:33.351]                 args <- list()
[16:20:33.351]                 for (kk in seq_along(NAMES)) {
[16:20:33.351]                   name <- changed[[kk]]
[16:20:33.351]                   NAME <- NAMES[[kk]]
[16:20:33.351]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.351]                     next
[16:20:33.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.351]                 }
[16:20:33.351]                 NAMES <- toupper(added)
[16:20:33.351]                 for (kk in seq_along(NAMES)) {
[16:20:33.351]                   name <- added[[kk]]
[16:20:33.351]                   NAME <- NAMES[[kk]]
[16:20:33.351]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.351]                     next
[16:20:33.351]                   args[[name]] <- ""
[16:20:33.351]                 }
[16:20:33.351]                 NAMES <- toupper(removed)
[16:20:33.351]                 for (kk in seq_along(NAMES)) {
[16:20:33.351]                   name <- removed[[kk]]
[16:20:33.351]                   NAME <- NAMES[[kk]]
[16:20:33.351]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.351]                     next
[16:20:33.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.351]                 }
[16:20:33.351]                 if (length(args) > 0) 
[16:20:33.351]                   base::do.call(base::Sys.setenv, args = args)
[16:20:33.351]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:33.351]             }
[16:20:33.351]             else {
[16:20:33.351]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:33.351]             }
[16:20:33.351]             {
[16:20:33.351]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:33.351]                   0L) {
[16:20:33.351]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:33.351]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:33.351]                   base::options(opts)
[16:20:33.351]                 }
[16:20:33.351]                 {
[16:20:33.351]                   {
[16:20:33.351]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:33.351]                     NULL
[16:20:33.351]                   }
[16:20:33.351]                   options(future.plan = NULL)
[16:20:33.351]                   if (is.na(NA_character_)) 
[16:20:33.351]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.351]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:33.351]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:33.351]                     .init = FALSE)
[16:20:33.351]                 }
[16:20:33.351]             }
[16:20:33.351]         }
[16:20:33.351]     })
[16:20:33.351]     if (TRUE) {
[16:20:33.351]         base::sink(type = "output", split = FALSE)
[16:20:33.351]         if (TRUE) {
[16:20:33.351]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:33.351]         }
[16:20:33.351]         else {
[16:20:33.351]             ...future.result["stdout"] <- base::list(NULL)
[16:20:33.351]         }
[16:20:33.351]         base::close(...future.stdout)
[16:20:33.351]         ...future.stdout <- NULL
[16:20:33.351]     }
[16:20:33.351]     ...future.result$conditions <- ...future.conditions
[16:20:33.351]     ...future.result$finished <- base::Sys.time()
[16:20:33.351]     ...future.result
[16:20:33.351] }
[16:20:33.355] requestCore(): workers = 2
[16:20:33.357] MulticoreFuture started
[16:20:33.357] - Launch lazy future ... done
[16:20:33.357] run() for ‘MulticoreFuture’ ... done
[16:20:33.358] result() for MulticoreFuture ...
[16:20:33.358] plan(): Setting new future strategy stack:
[16:20:33.358] List of future strategies:
[16:20:33.358] 1. sequential:
[16:20:33.358]    - args: function (..., envir = parent.frame())
[16:20:33.358]    - tweaked: FALSE
[16:20:33.358]    - call: NULL
[16:20:33.359] plan(): nbrOfWorkers() = 1
[16:20:33.361] plan(): Setting new future strategy stack:
[16:20:33.362] List of future strategies:
[16:20:33.362] 1. multicore:
[16:20:33.362]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:33.362]    - tweaked: FALSE
[16:20:33.362]    - call: plan(strategy)
[16:20:33.367] plan(): nbrOfWorkers() = 2
[16:20:33.368] result() for MulticoreFuture ...
[16:20:33.368] result() for MulticoreFuture ... done
[16:20:33.368] result() for MulticoreFuture ... done
[16:20:33.369] result() for MulticoreFuture ...
[16:20:33.369] result() for MulticoreFuture ... done
c = 1
[16:20:33.369] getGlobalsAndPackages() ...
[16:20:33.369] Searching for globals...
[16:20:33.370] 
[16:20:33.370] Searching for globals ... DONE
[16:20:33.370] - globals: [0] <none>
[16:20:33.370] getGlobalsAndPackages() ... DONE
[16:20:33.371] run() for ‘Future’ ...
[16:20:33.371] - state: ‘created’
[16:20:33.371] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:33.375] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:33.375] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:33.376]   - Field: ‘label’
[16:20:33.376]   - Field: ‘local’
[16:20:33.376]   - Field: ‘owner’
[16:20:33.376]   - Field: ‘envir’
[16:20:33.376]   - Field: ‘workers’
[16:20:33.376]   - Field: ‘packages’
[16:20:33.376]   - Field: ‘gc’
[16:20:33.377]   - Field: ‘job’
[16:20:33.377]   - Field: ‘conditions’
[16:20:33.377]   - Field: ‘expr’
[16:20:33.377]   - Field: ‘uuid’
[16:20:33.377]   - Field: ‘seed’
[16:20:33.377]   - Field: ‘version’
[16:20:33.377]   - Field: ‘result’
[16:20:33.377]   - Field: ‘asynchronous’
[16:20:33.377]   - Field: ‘calls’
[16:20:33.378]   - Field: ‘globals’
[16:20:33.378]   - Field: ‘stdout’
[16:20:33.378]   - Field: ‘earlySignal’
[16:20:33.378]   - Field: ‘lazy’
[16:20:33.378]   - Field: ‘state’
[16:20:33.378] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:33.378] - Launch lazy future ...
[16:20:33.379] Packages needed by the future expression (n = 0): <none>
[16:20:33.379] Packages needed by future strategies (n = 0): <none>
[16:20:33.379] {
[16:20:33.379]     {
[16:20:33.379]         {
[16:20:33.379]             ...future.startTime <- base::Sys.time()
[16:20:33.379]             {
[16:20:33.379]                 {
[16:20:33.379]                   {
[16:20:33.379]                     {
[16:20:33.379]                       base::local({
[16:20:33.379]                         has_future <- base::requireNamespace("future", 
[16:20:33.379]                           quietly = TRUE)
[16:20:33.379]                         if (has_future) {
[16:20:33.379]                           ns <- base::getNamespace("future")
[16:20:33.379]                           version <- ns[[".package"]][["version"]]
[16:20:33.379]                           if (is.null(version)) 
[16:20:33.379]                             version <- utils::packageVersion("future")
[16:20:33.379]                         }
[16:20:33.379]                         else {
[16:20:33.379]                           version <- NULL
[16:20:33.379]                         }
[16:20:33.379]                         if (!has_future || version < "1.8.0") {
[16:20:33.379]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:33.379]                             "", base::R.version$version.string), 
[16:20:33.379]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:33.379]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:33.379]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:33.379]                               "release", "version")], collapse = " "), 
[16:20:33.379]                             hostname = base::Sys.info()[["nodename"]])
[16:20:33.379]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:33.379]                             info)
[16:20:33.379]                           info <- base::paste(info, collapse = "; ")
[16:20:33.379]                           if (!has_future) {
[16:20:33.379]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:33.379]                               info)
[16:20:33.379]                           }
[16:20:33.379]                           else {
[16:20:33.379]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:33.379]                               info, version)
[16:20:33.379]                           }
[16:20:33.379]                           base::stop(msg)
[16:20:33.379]                         }
[16:20:33.379]                       })
[16:20:33.379]                     }
[16:20:33.379]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:33.379]                     base::options(mc.cores = 1L)
[16:20:33.379]                   }
[16:20:33.379]                   ...future.strategy.old <- future::plan("list")
[16:20:33.379]                   options(future.plan = NULL)
[16:20:33.379]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.379]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:33.379]                 }
[16:20:33.379]                 ...future.workdir <- getwd()
[16:20:33.379]             }
[16:20:33.379]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:33.379]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:33.379]         }
[16:20:33.379]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:33.379]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:33.379]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:33.379]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:33.379]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:33.379]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:33.379]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:33.379]             base::names(...future.oldOptions))
[16:20:33.379]     }
[16:20:33.379]     if (FALSE) {
[16:20:33.379]     }
[16:20:33.379]     else {
[16:20:33.379]         if (TRUE) {
[16:20:33.379]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:33.379]                 open = "w")
[16:20:33.379]         }
[16:20:33.379]         else {
[16:20:33.379]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:33.379]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:33.379]         }
[16:20:33.379]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:33.379]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:33.379]             base::sink(type = "output", split = FALSE)
[16:20:33.379]             base::close(...future.stdout)
[16:20:33.379]         }, add = TRUE)
[16:20:33.379]     }
[16:20:33.379]     ...future.frame <- base::sys.nframe()
[16:20:33.379]     ...future.conditions <- base::list()
[16:20:33.379]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:33.379]     if (FALSE) {
[16:20:33.379]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:33.379]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:33.379]     }
[16:20:33.379]     ...future.result <- base::tryCatch({
[16:20:33.379]         base::withCallingHandlers({
[16:20:33.379]             ...future.value <- base::withVisible(base::local({
[16:20:33.379]                 withCallingHandlers({
[16:20:33.379]                   1
[16:20:33.379]                 }, immediateCondition = function(cond) {
[16:20:33.379]                   save_rds <- function (object, pathname, ...) 
[16:20:33.379]                   {
[16:20:33.379]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:33.379]                     if (file_test("-f", pathname_tmp)) {
[16:20:33.379]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.379]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:33.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.379]                         fi_tmp[["mtime"]])
[16:20:33.379]                     }
[16:20:33.379]                     tryCatch({
[16:20:33.379]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:33.379]                     }, error = function(ex) {
[16:20:33.379]                       msg <- conditionMessage(ex)
[16:20:33.379]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.379]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:33.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.379]                         fi_tmp[["mtime"]], msg)
[16:20:33.379]                       ex$message <- msg
[16:20:33.379]                       stop(ex)
[16:20:33.379]                     })
[16:20:33.379]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:33.379]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:33.379]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:33.379]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.379]                       fi <- file.info(pathname)
[16:20:33.379]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:33.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.379]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:33.379]                         fi[["size"]], fi[["mtime"]])
[16:20:33.379]                       stop(msg)
[16:20:33.379]                     }
[16:20:33.379]                     invisible(pathname)
[16:20:33.379]                   }
[16:20:33.379]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:33.379]                     rootPath = tempdir()) 
[16:20:33.379]                   {
[16:20:33.379]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:33.379]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:33.379]                       tmpdir = path, fileext = ".rds")
[16:20:33.379]                     save_rds(obj, file)
[16:20:33.379]                   }
[16:20:33.379]                   saveImmediateCondition(cond, path = "/tmp/RtmpFUh73Z/.future/immediateConditions")
[16:20:33.379]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.379]                   {
[16:20:33.379]                     inherits <- base::inherits
[16:20:33.379]                     invokeRestart <- base::invokeRestart
[16:20:33.379]                     is.null <- base::is.null
[16:20:33.379]                     muffled <- FALSE
[16:20:33.379]                     if (inherits(cond, "message")) {
[16:20:33.379]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:33.379]                       if (muffled) 
[16:20:33.379]                         invokeRestart("muffleMessage")
[16:20:33.379]                     }
[16:20:33.379]                     else if (inherits(cond, "warning")) {
[16:20:33.379]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:33.379]                       if (muffled) 
[16:20:33.379]                         invokeRestart("muffleWarning")
[16:20:33.379]                     }
[16:20:33.379]                     else if (inherits(cond, "condition")) {
[16:20:33.379]                       if (!is.null(pattern)) {
[16:20:33.379]                         computeRestarts <- base::computeRestarts
[16:20:33.379]                         grepl <- base::grepl
[16:20:33.379]                         restarts <- computeRestarts(cond)
[16:20:33.379]                         for (restart in restarts) {
[16:20:33.379]                           name <- restart$name
[16:20:33.379]                           if (is.null(name)) 
[16:20:33.379]                             next
[16:20:33.379]                           if (!grepl(pattern, name)) 
[16:20:33.379]                             next
[16:20:33.379]                           invokeRestart(restart)
[16:20:33.379]                           muffled <- TRUE
[16:20:33.379]                           break
[16:20:33.379]                         }
[16:20:33.379]                       }
[16:20:33.379]                     }
[16:20:33.379]                     invisible(muffled)
[16:20:33.379]                   }
[16:20:33.379]                   muffleCondition(cond)
[16:20:33.379]                 })
[16:20:33.379]             }))
[16:20:33.379]             future::FutureResult(value = ...future.value$value, 
[16:20:33.379]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.379]                   ...future.rng), globalenv = if (FALSE) 
[16:20:33.379]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:33.379]                     ...future.globalenv.names))
[16:20:33.379]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:33.379]         }, condition = base::local({
[16:20:33.379]             c <- base::c
[16:20:33.379]             inherits <- base::inherits
[16:20:33.379]             invokeRestart <- base::invokeRestart
[16:20:33.379]             length <- base::length
[16:20:33.379]             list <- base::list
[16:20:33.379]             seq.int <- base::seq.int
[16:20:33.379]             signalCondition <- base::signalCondition
[16:20:33.379]             sys.calls <- base::sys.calls
[16:20:33.379]             `[[` <- base::`[[`
[16:20:33.379]             `+` <- base::`+`
[16:20:33.379]             `<<-` <- base::`<<-`
[16:20:33.379]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:33.379]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:33.379]                   3L)]
[16:20:33.379]             }
[16:20:33.379]             function(cond) {
[16:20:33.379]                 is_error <- inherits(cond, "error")
[16:20:33.379]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:33.379]                   NULL)
[16:20:33.379]                 if (is_error) {
[16:20:33.379]                   sessionInformation <- function() {
[16:20:33.379]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:33.379]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:33.379]                       search = base::search(), system = base::Sys.info())
[16:20:33.379]                   }
[16:20:33.379]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.379]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:33.379]                     cond$call), session = sessionInformation(), 
[16:20:33.379]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:33.379]                   signalCondition(cond)
[16:20:33.379]                 }
[16:20:33.379]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:33.379]                 "immediateCondition"))) {
[16:20:33.379]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:33.379]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.379]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:33.379]                   if (TRUE && !signal) {
[16:20:33.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.379]                     {
[16:20:33.379]                       inherits <- base::inherits
[16:20:33.379]                       invokeRestart <- base::invokeRestart
[16:20:33.379]                       is.null <- base::is.null
[16:20:33.379]                       muffled <- FALSE
[16:20:33.379]                       if (inherits(cond, "message")) {
[16:20:33.379]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.379]                         if (muffled) 
[16:20:33.379]                           invokeRestart("muffleMessage")
[16:20:33.379]                       }
[16:20:33.379]                       else if (inherits(cond, "warning")) {
[16:20:33.379]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.379]                         if (muffled) 
[16:20:33.379]                           invokeRestart("muffleWarning")
[16:20:33.379]                       }
[16:20:33.379]                       else if (inherits(cond, "condition")) {
[16:20:33.379]                         if (!is.null(pattern)) {
[16:20:33.379]                           computeRestarts <- base::computeRestarts
[16:20:33.379]                           grepl <- base::grepl
[16:20:33.379]                           restarts <- computeRestarts(cond)
[16:20:33.379]                           for (restart in restarts) {
[16:20:33.379]                             name <- restart$name
[16:20:33.379]                             if (is.null(name)) 
[16:20:33.379]                               next
[16:20:33.379]                             if (!grepl(pattern, name)) 
[16:20:33.379]                               next
[16:20:33.379]                             invokeRestart(restart)
[16:20:33.379]                             muffled <- TRUE
[16:20:33.379]                             break
[16:20:33.379]                           }
[16:20:33.379]                         }
[16:20:33.379]                       }
[16:20:33.379]                       invisible(muffled)
[16:20:33.379]                     }
[16:20:33.379]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.379]                   }
[16:20:33.379]                 }
[16:20:33.379]                 else {
[16:20:33.379]                   if (TRUE) {
[16:20:33.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.379]                     {
[16:20:33.379]                       inherits <- base::inherits
[16:20:33.379]                       invokeRestart <- base::invokeRestart
[16:20:33.379]                       is.null <- base::is.null
[16:20:33.379]                       muffled <- FALSE
[16:20:33.379]                       if (inherits(cond, "message")) {
[16:20:33.379]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.379]                         if (muffled) 
[16:20:33.379]                           invokeRestart("muffleMessage")
[16:20:33.379]                       }
[16:20:33.379]                       else if (inherits(cond, "warning")) {
[16:20:33.379]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.379]                         if (muffled) 
[16:20:33.379]                           invokeRestart("muffleWarning")
[16:20:33.379]                       }
[16:20:33.379]                       else if (inherits(cond, "condition")) {
[16:20:33.379]                         if (!is.null(pattern)) {
[16:20:33.379]                           computeRestarts <- base::computeRestarts
[16:20:33.379]                           grepl <- base::grepl
[16:20:33.379]                           restarts <- computeRestarts(cond)
[16:20:33.379]                           for (restart in restarts) {
[16:20:33.379]                             name <- restart$name
[16:20:33.379]                             if (is.null(name)) 
[16:20:33.379]                               next
[16:20:33.379]                             if (!grepl(pattern, name)) 
[16:20:33.379]                               next
[16:20:33.379]                             invokeRestart(restart)
[16:20:33.379]                             muffled <- TRUE
[16:20:33.379]                             break
[16:20:33.379]                           }
[16:20:33.379]                         }
[16:20:33.379]                       }
[16:20:33.379]                       invisible(muffled)
[16:20:33.379]                     }
[16:20:33.379]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.379]                   }
[16:20:33.379]                 }
[16:20:33.379]             }
[16:20:33.379]         }))
[16:20:33.379]     }, error = function(ex) {
[16:20:33.379]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:33.379]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.379]                 ...future.rng), started = ...future.startTime, 
[16:20:33.379]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:33.379]             version = "1.8"), class = "FutureResult")
[16:20:33.379]     }, finally = {
[16:20:33.379]         if (!identical(...future.workdir, getwd())) 
[16:20:33.379]             setwd(...future.workdir)
[16:20:33.379]         {
[16:20:33.379]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:33.379]                 ...future.oldOptions$nwarnings <- NULL
[16:20:33.379]             }
[16:20:33.379]             base::options(...future.oldOptions)
[16:20:33.379]             if (.Platform$OS.type == "windows") {
[16:20:33.379]                 old_names <- names(...future.oldEnvVars)
[16:20:33.379]                 envs <- base::Sys.getenv()
[16:20:33.379]                 names <- names(envs)
[16:20:33.379]                 common <- intersect(names, old_names)
[16:20:33.379]                 added <- setdiff(names, old_names)
[16:20:33.379]                 removed <- setdiff(old_names, names)
[16:20:33.379]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:33.379]                   envs[common]]
[16:20:33.379]                 NAMES <- toupper(changed)
[16:20:33.379]                 args <- list()
[16:20:33.379]                 for (kk in seq_along(NAMES)) {
[16:20:33.379]                   name <- changed[[kk]]
[16:20:33.379]                   NAME <- NAMES[[kk]]
[16:20:33.379]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.379]                     next
[16:20:33.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.379]                 }
[16:20:33.379]                 NAMES <- toupper(added)
[16:20:33.379]                 for (kk in seq_along(NAMES)) {
[16:20:33.379]                   name <- added[[kk]]
[16:20:33.379]                   NAME <- NAMES[[kk]]
[16:20:33.379]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.379]                     next
[16:20:33.379]                   args[[name]] <- ""
[16:20:33.379]                 }
[16:20:33.379]                 NAMES <- toupper(removed)
[16:20:33.379]                 for (kk in seq_along(NAMES)) {
[16:20:33.379]                   name <- removed[[kk]]
[16:20:33.379]                   NAME <- NAMES[[kk]]
[16:20:33.379]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.379]                     next
[16:20:33.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.379]                 }
[16:20:33.379]                 if (length(args) > 0) 
[16:20:33.379]                   base::do.call(base::Sys.setenv, args = args)
[16:20:33.379]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:33.379]             }
[16:20:33.379]             else {
[16:20:33.379]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:33.379]             }
[16:20:33.379]             {
[16:20:33.379]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:33.379]                   0L) {
[16:20:33.379]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:33.379]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:33.379]                   base::options(opts)
[16:20:33.379]                 }
[16:20:33.379]                 {
[16:20:33.379]                   {
[16:20:33.379]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:33.379]                     NULL
[16:20:33.379]                   }
[16:20:33.379]                   options(future.plan = NULL)
[16:20:33.379]                   if (is.na(NA_character_)) 
[16:20:33.379]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.379]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:33.379]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:33.379]                     .init = FALSE)
[16:20:33.379]                 }
[16:20:33.379]             }
[16:20:33.379]         }
[16:20:33.379]     })
[16:20:33.379]     if (TRUE) {
[16:20:33.379]         base::sink(type = "output", split = FALSE)
[16:20:33.379]         if (TRUE) {
[16:20:33.379]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:33.379]         }
[16:20:33.379]         else {
[16:20:33.379]             ...future.result["stdout"] <- base::list(NULL)
[16:20:33.379]         }
[16:20:33.379]         base::close(...future.stdout)
[16:20:33.379]         ...future.stdout <- NULL
[16:20:33.379]     }
[16:20:33.379]     ...future.result$conditions <- ...future.conditions
[16:20:33.379]     ...future.result$finished <- base::Sys.time()
[16:20:33.379]     ...future.result
[16:20:33.379] }
[16:20:33.382] requestCore(): workers = 2
[16:20:33.384] MulticoreFuture started
[16:20:33.384] - Launch lazy future ... done
[16:20:33.384] run() for ‘MulticoreFuture’ ... done
[16:20:33.385] result() for MulticoreFuture ...
[16:20:33.385] plan(): Setting new future strategy stack:
[16:20:33.385] List of future strategies:
[16:20:33.385] 1. sequential:
[16:20:33.385]    - args: function (..., envir = parent.frame())
[16:20:33.385]    - tweaked: FALSE
[16:20:33.385]    - call: NULL
[16:20:33.386] plan(): nbrOfWorkers() = 1
[16:20:33.388] plan(): Setting new future strategy stack:
[16:20:33.388] List of future strategies:
[16:20:33.388] 1. multicore:
[16:20:33.388]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:33.388]    - tweaked: FALSE
[16:20:33.388]    - call: plan(strategy)
[16:20:33.393] plan(): nbrOfWorkers() = 2
[16:20:33.394] result() for MulticoreFuture ...
[16:20:33.394] result() for MulticoreFuture ... done
[16:20:33.394] result() for MulticoreFuture ... done
[16:20:33.394] result() for MulticoreFuture ...
[16:20:33.394] result() for MulticoreFuture ... done
d = 1
** Nested future assignments
[16:20:33.395] getGlobalsAndPackages() ...
[16:20:33.395] Searching for globals...
[16:20:33.400] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[16:20:33.400] Searching for globals ... DONE
[16:20:33.400] Resolving globals: FALSE
[16:20:33.401] 
[16:20:33.401] - packages: [1] ‘future’
[16:20:33.401] getGlobalsAndPackages() ... DONE
[16:20:33.401] run() for ‘Future’ ...
[16:20:33.402] - state: ‘created’
[16:20:33.402] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:33.406] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:33.406] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:33.406]   - Field: ‘label’
[16:20:33.406]   - Field: ‘local’
[16:20:33.406]   - Field: ‘owner’
[16:20:33.407]   - Field: ‘envir’
[16:20:33.407]   - Field: ‘workers’
[16:20:33.407]   - Field: ‘packages’
[16:20:33.407]   - Field: ‘gc’
[16:20:33.407]   - Field: ‘job’
[16:20:33.407]   - Field: ‘conditions’
[16:20:33.407]   - Field: ‘expr’
[16:20:33.407]   - Field: ‘uuid’
[16:20:33.407]   - Field: ‘seed’
[16:20:33.408]   - Field: ‘version’
[16:20:33.410]   - Field: ‘result’
[16:20:33.410]   - Field: ‘asynchronous’
[16:20:33.410]   - Field: ‘calls’
[16:20:33.411]   - Field: ‘globals’
[16:20:33.411]   - Field: ‘stdout’
[16:20:33.411]   - Field: ‘earlySignal’
[16:20:33.411]   - Field: ‘lazy’
[16:20:33.411]   - Field: ‘state’
[16:20:33.411] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:33.411] - Launch lazy future ...
[16:20:33.412] Packages needed by the future expression (n = 1): ‘future’
[16:20:33.412] Packages needed by future strategies (n = 0): <none>
[16:20:33.413] {
[16:20:33.413]     {
[16:20:33.413]         {
[16:20:33.413]             ...future.startTime <- base::Sys.time()
[16:20:33.413]             {
[16:20:33.413]                 {
[16:20:33.413]                   {
[16:20:33.413]                     {
[16:20:33.413]                       {
[16:20:33.413]                         base::local({
[16:20:33.413]                           has_future <- base::requireNamespace("future", 
[16:20:33.413]                             quietly = TRUE)
[16:20:33.413]                           if (has_future) {
[16:20:33.413]                             ns <- base::getNamespace("future")
[16:20:33.413]                             version <- ns[[".package"]][["version"]]
[16:20:33.413]                             if (is.null(version)) 
[16:20:33.413]                               version <- utils::packageVersion("future")
[16:20:33.413]                           }
[16:20:33.413]                           else {
[16:20:33.413]                             version <- NULL
[16:20:33.413]                           }
[16:20:33.413]                           if (!has_future || version < "1.8.0") {
[16:20:33.413]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:33.413]                               "", base::R.version$version.string), 
[16:20:33.413]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:33.413]                                 base::R.version$platform, 8 * 
[16:20:33.413]                                   base::.Machine$sizeof.pointer), 
[16:20:33.413]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:33.413]                                 "release", "version")], collapse = " "), 
[16:20:33.413]                               hostname = base::Sys.info()[["nodename"]])
[16:20:33.413]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:33.413]                               info)
[16:20:33.413]                             info <- base::paste(info, collapse = "; ")
[16:20:33.413]                             if (!has_future) {
[16:20:33.413]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:33.413]                                 info)
[16:20:33.413]                             }
[16:20:33.413]                             else {
[16:20:33.413]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:33.413]                                 info, version)
[16:20:33.413]                             }
[16:20:33.413]                             base::stop(msg)
[16:20:33.413]                           }
[16:20:33.413]                         })
[16:20:33.413]                       }
[16:20:33.413]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:33.413]                       base::options(mc.cores = 1L)
[16:20:33.413]                     }
[16:20:33.413]                     base::local({
[16:20:33.413]                       for (pkg in "future") {
[16:20:33.413]                         base::loadNamespace(pkg)
[16:20:33.413]                         base::library(pkg, character.only = TRUE)
[16:20:33.413]                       }
[16:20:33.413]                     })
[16:20:33.413]                   }
[16:20:33.413]                   ...future.strategy.old <- future::plan("list")
[16:20:33.413]                   options(future.plan = NULL)
[16:20:33.413]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.413]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:33.413]                 }
[16:20:33.413]                 ...future.workdir <- getwd()
[16:20:33.413]             }
[16:20:33.413]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:33.413]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:33.413]         }
[16:20:33.413]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:33.413]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:33.413]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:33.413]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:33.413]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:33.413]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:33.413]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:33.413]             base::names(...future.oldOptions))
[16:20:33.413]     }
[16:20:33.413]     if (FALSE) {
[16:20:33.413]     }
[16:20:33.413]     else {
[16:20:33.413]         if (TRUE) {
[16:20:33.413]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:33.413]                 open = "w")
[16:20:33.413]         }
[16:20:33.413]         else {
[16:20:33.413]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:33.413]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:33.413]         }
[16:20:33.413]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:33.413]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:33.413]             base::sink(type = "output", split = FALSE)
[16:20:33.413]             base::close(...future.stdout)
[16:20:33.413]         }, add = TRUE)
[16:20:33.413]     }
[16:20:33.413]     ...future.frame <- base::sys.nframe()
[16:20:33.413]     ...future.conditions <- base::list()
[16:20:33.413]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:33.413]     if (FALSE) {
[16:20:33.413]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:33.413]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:33.413]     }
[16:20:33.413]     ...future.result <- base::tryCatch({
[16:20:33.413]         base::withCallingHandlers({
[16:20:33.413]             ...future.value <- base::withVisible(base::local({
[16:20:33.413]                 withCallingHandlers({
[16:20:33.413]                   {
[16:20:33.413]                     b <- 1
[16:20:33.413]                     c %<-% 2
[16:20:33.413]                     d <- 3
[16:20:33.413]                     4 %->% e
[16:20:33.413]                     b + c + d + e
[16:20:33.413]                   }
[16:20:33.413]                 }, immediateCondition = function(cond) {
[16:20:33.413]                   save_rds <- function (object, pathname, ...) 
[16:20:33.413]                   {
[16:20:33.413]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:33.413]                     if (file_test("-f", pathname_tmp)) {
[16:20:33.413]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.413]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:33.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.413]                         fi_tmp[["mtime"]])
[16:20:33.413]                     }
[16:20:33.413]                     tryCatch({
[16:20:33.413]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:33.413]                     }, error = function(ex) {
[16:20:33.413]                       msg <- conditionMessage(ex)
[16:20:33.413]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.413]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:33.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.413]                         fi_tmp[["mtime"]], msg)
[16:20:33.413]                       ex$message <- msg
[16:20:33.413]                       stop(ex)
[16:20:33.413]                     })
[16:20:33.413]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:33.413]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:33.413]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:33.413]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.413]                       fi <- file.info(pathname)
[16:20:33.413]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:33.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.413]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:33.413]                         fi[["size"]], fi[["mtime"]])
[16:20:33.413]                       stop(msg)
[16:20:33.413]                     }
[16:20:33.413]                     invisible(pathname)
[16:20:33.413]                   }
[16:20:33.413]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:33.413]                     rootPath = tempdir()) 
[16:20:33.413]                   {
[16:20:33.413]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:33.413]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:33.413]                       tmpdir = path, fileext = ".rds")
[16:20:33.413]                     save_rds(obj, file)
[16:20:33.413]                   }
[16:20:33.413]                   saveImmediateCondition(cond, path = "/tmp/RtmpFUh73Z/.future/immediateConditions")
[16:20:33.413]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.413]                   {
[16:20:33.413]                     inherits <- base::inherits
[16:20:33.413]                     invokeRestart <- base::invokeRestart
[16:20:33.413]                     is.null <- base::is.null
[16:20:33.413]                     muffled <- FALSE
[16:20:33.413]                     if (inherits(cond, "message")) {
[16:20:33.413]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:33.413]                       if (muffled) 
[16:20:33.413]                         invokeRestart("muffleMessage")
[16:20:33.413]                     }
[16:20:33.413]                     else if (inherits(cond, "warning")) {
[16:20:33.413]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:33.413]                       if (muffled) 
[16:20:33.413]                         invokeRestart("muffleWarning")
[16:20:33.413]                     }
[16:20:33.413]                     else if (inherits(cond, "condition")) {
[16:20:33.413]                       if (!is.null(pattern)) {
[16:20:33.413]                         computeRestarts <- base::computeRestarts
[16:20:33.413]                         grepl <- base::grepl
[16:20:33.413]                         restarts <- computeRestarts(cond)
[16:20:33.413]                         for (restart in restarts) {
[16:20:33.413]                           name <- restart$name
[16:20:33.413]                           if (is.null(name)) 
[16:20:33.413]                             next
[16:20:33.413]                           if (!grepl(pattern, name)) 
[16:20:33.413]                             next
[16:20:33.413]                           invokeRestart(restart)
[16:20:33.413]                           muffled <- TRUE
[16:20:33.413]                           break
[16:20:33.413]                         }
[16:20:33.413]                       }
[16:20:33.413]                     }
[16:20:33.413]                     invisible(muffled)
[16:20:33.413]                   }
[16:20:33.413]                   muffleCondition(cond)
[16:20:33.413]                 })
[16:20:33.413]             }))
[16:20:33.413]             future::FutureResult(value = ...future.value$value, 
[16:20:33.413]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.413]                   ...future.rng), globalenv = if (FALSE) 
[16:20:33.413]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:33.413]                     ...future.globalenv.names))
[16:20:33.413]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:33.413]         }, condition = base::local({
[16:20:33.413]             c <- base::c
[16:20:33.413]             inherits <- base::inherits
[16:20:33.413]             invokeRestart <- base::invokeRestart
[16:20:33.413]             length <- base::length
[16:20:33.413]             list <- base::list
[16:20:33.413]             seq.int <- base::seq.int
[16:20:33.413]             signalCondition <- base::signalCondition
[16:20:33.413]             sys.calls <- base::sys.calls
[16:20:33.413]             `[[` <- base::`[[`
[16:20:33.413]             `+` <- base::`+`
[16:20:33.413]             `<<-` <- base::`<<-`
[16:20:33.413]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:33.413]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:33.413]                   3L)]
[16:20:33.413]             }
[16:20:33.413]             function(cond) {
[16:20:33.413]                 is_error <- inherits(cond, "error")
[16:20:33.413]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:33.413]                   NULL)
[16:20:33.413]                 if (is_error) {
[16:20:33.413]                   sessionInformation <- function() {
[16:20:33.413]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:33.413]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:33.413]                       search = base::search(), system = base::Sys.info())
[16:20:33.413]                   }
[16:20:33.413]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.413]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:33.413]                     cond$call), session = sessionInformation(), 
[16:20:33.413]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:33.413]                   signalCondition(cond)
[16:20:33.413]                 }
[16:20:33.413]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:33.413]                 "immediateCondition"))) {
[16:20:33.413]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:33.413]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.413]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:33.413]                   if (TRUE && !signal) {
[16:20:33.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.413]                     {
[16:20:33.413]                       inherits <- base::inherits
[16:20:33.413]                       invokeRestart <- base::invokeRestart
[16:20:33.413]                       is.null <- base::is.null
[16:20:33.413]                       muffled <- FALSE
[16:20:33.413]                       if (inherits(cond, "message")) {
[16:20:33.413]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.413]                         if (muffled) 
[16:20:33.413]                           invokeRestart("muffleMessage")
[16:20:33.413]                       }
[16:20:33.413]                       else if (inherits(cond, "warning")) {
[16:20:33.413]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.413]                         if (muffled) 
[16:20:33.413]                           invokeRestart("muffleWarning")
[16:20:33.413]                       }
[16:20:33.413]                       else if (inherits(cond, "condition")) {
[16:20:33.413]                         if (!is.null(pattern)) {
[16:20:33.413]                           computeRestarts <- base::computeRestarts
[16:20:33.413]                           grepl <- base::grepl
[16:20:33.413]                           restarts <- computeRestarts(cond)
[16:20:33.413]                           for (restart in restarts) {
[16:20:33.413]                             name <- restart$name
[16:20:33.413]                             if (is.null(name)) 
[16:20:33.413]                               next
[16:20:33.413]                             if (!grepl(pattern, name)) 
[16:20:33.413]                               next
[16:20:33.413]                             invokeRestart(restart)
[16:20:33.413]                             muffled <- TRUE
[16:20:33.413]                             break
[16:20:33.413]                           }
[16:20:33.413]                         }
[16:20:33.413]                       }
[16:20:33.413]                       invisible(muffled)
[16:20:33.413]                     }
[16:20:33.413]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.413]                   }
[16:20:33.413]                 }
[16:20:33.413]                 else {
[16:20:33.413]                   if (TRUE) {
[16:20:33.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.413]                     {
[16:20:33.413]                       inherits <- base::inherits
[16:20:33.413]                       invokeRestart <- base::invokeRestart
[16:20:33.413]                       is.null <- base::is.null
[16:20:33.413]                       muffled <- FALSE
[16:20:33.413]                       if (inherits(cond, "message")) {
[16:20:33.413]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.413]                         if (muffled) 
[16:20:33.413]                           invokeRestart("muffleMessage")
[16:20:33.413]                       }
[16:20:33.413]                       else if (inherits(cond, "warning")) {
[16:20:33.413]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.413]                         if (muffled) 
[16:20:33.413]                           invokeRestart("muffleWarning")
[16:20:33.413]                       }
[16:20:33.413]                       else if (inherits(cond, "condition")) {
[16:20:33.413]                         if (!is.null(pattern)) {
[16:20:33.413]                           computeRestarts <- base::computeRestarts
[16:20:33.413]                           grepl <- base::grepl
[16:20:33.413]                           restarts <- computeRestarts(cond)
[16:20:33.413]                           for (restart in restarts) {
[16:20:33.413]                             name <- restart$name
[16:20:33.413]                             if (is.null(name)) 
[16:20:33.413]                               next
[16:20:33.413]                             if (!grepl(pattern, name)) 
[16:20:33.413]                               next
[16:20:33.413]                             invokeRestart(restart)
[16:20:33.413]                             muffled <- TRUE
[16:20:33.413]                             break
[16:20:33.413]                           }
[16:20:33.413]                         }
[16:20:33.413]                       }
[16:20:33.413]                       invisible(muffled)
[16:20:33.413]                     }
[16:20:33.413]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.413]                   }
[16:20:33.413]                 }
[16:20:33.413]             }
[16:20:33.413]         }))
[16:20:33.413]     }, error = function(ex) {
[16:20:33.413]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:33.413]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.413]                 ...future.rng), started = ...future.startTime, 
[16:20:33.413]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:33.413]             version = "1.8"), class = "FutureResult")
[16:20:33.413]     }, finally = {
[16:20:33.413]         if (!identical(...future.workdir, getwd())) 
[16:20:33.413]             setwd(...future.workdir)
[16:20:33.413]         {
[16:20:33.413]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:33.413]                 ...future.oldOptions$nwarnings <- NULL
[16:20:33.413]             }
[16:20:33.413]             base::options(...future.oldOptions)
[16:20:33.413]             if (.Platform$OS.type == "windows") {
[16:20:33.413]                 old_names <- names(...future.oldEnvVars)
[16:20:33.413]                 envs <- base::Sys.getenv()
[16:20:33.413]                 names <- names(envs)
[16:20:33.413]                 common <- intersect(names, old_names)
[16:20:33.413]                 added <- setdiff(names, old_names)
[16:20:33.413]                 removed <- setdiff(old_names, names)
[16:20:33.413]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:33.413]                   envs[common]]
[16:20:33.413]                 NAMES <- toupper(changed)
[16:20:33.413]                 args <- list()
[16:20:33.413]                 for (kk in seq_along(NAMES)) {
[16:20:33.413]                   name <- changed[[kk]]
[16:20:33.413]                   NAME <- NAMES[[kk]]
[16:20:33.413]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.413]                     next
[16:20:33.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.413]                 }
[16:20:33.413]                 NAMES <- toupper(added)
[16:20:33.413]                 for (kk in seq_along(NAMES)) {
[16:20:33.413]                   name <- added[[kk]]
[16:20:33.413]                   NAME <- NAMES[[kk]]
[16:20:33.413]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.413]                     next
[16:20:33.413]                   args[[name]] <- ""
[16:20:33.413]                 }
[16:20:33.413]                 NAMES <- toupper(removed)
[16:20:33.413]                 for (kk in seq_along(NAMES)) {
[16:20:33.413]                   name <- removed[[kk]]
[16:20:33.413]                   NAME <- NAMES[[kk]]
[16:20:33.413]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.413]                     next
[16:20:33.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.413]                 }
[16:20:33.413]                 if (length(args) > 0) 
[16:20:33.413]                   base::do.call(base::Sys.setenv, args = args)
[16:20:33.413]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:33.413]             }
[16:20:33.413]             else {
[16:20:33.413]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:33.413]             }
[16:20:33.413]             {
[16:20:33.413]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:33.413]                   0L) {
[16:20:33.413]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:33.413]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:33.413]                   base::options(opts)
[16:20:33.413]                 }
[16:20:33.413]                 {
[16:20:33.413]                   {
[16:20:33.413]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:33.413]                     NULL
[16:20:33.413]                   }
[16:20:33.413]                   options(future.plan = NULL)
[16:20:33.413]                   if (is.na(NA_character_)) 
[16:20:33.413]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.413]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:33.413]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:33.413]                     .init = FALSE)
[16:20:33.413]                 }
[16:20:33.413]             }
[16:20:33.413]         }
[16:20:33.413]     })
[16:20:33.413]     if (TRUE) {
[16:20:33.413]         base::sink(type = "output", split = FALSE)
[16:20:33.413]         if (TRUE) {
[16:20:33.413]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:33.413]         }
[16:20:33.413]         else {
[16:20:33.413]             ...future.result["stdout"] <- base::list(NULL)
[16:20:33.413]         }
[16:20:33.413]         base::close(...future.stdout)
[16:20:33.413]         ...future.stdout <- NULL
[16:20:33.413]     }
[16:20:33.413]     ...future.result$conditions <- ...future.conditions
[16:20:33.413]     ...future.result$finished <- base::Sys.time()
[16:20:33.413]     ...future.result
[16:20:33.413] }
[16:20:33.415] requestCore(): workers = 2
[16:20:33.417] MulticoreFuture started
[16:20:33.417] - Launch lazy future ... done
[16:20:33.417] run() for ‘MulticoreFuture’ ... done
[16:20:33.418] result() for MulticoreFuture ...
[16:20:33.418] plan(): Setting new future strategy stack:
[16:20:33.419] List of future strategies:
[16:20:33.419] 1. sequential:
[16:20:33.419]    - args: function (..., envir = parent.frame())
[16:20:33.419]    - tweaked: FALSE
[16:20:33.419]    - call: NULL
[16:20:33.419] plan(): nbrOfWorkers() = 1
[16:20:33.453] plan(): Setting new future strategy stack:
[16:20:33.453] List of future strategies:
[16:20:33.453] 1. multicore:
[16:20:33.453]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:33.453]    - tweaked: FALSE
[16:20:33.453]    - call: plan(strategy)
[16:20:33.458] plan(): nbrOfWorkers() = 2
[16:20:33.459] result() for MulticoreFuture ...
[16:20:33.460] result() for MulticoreFuture ... done
[16:20:33.460] signalConditions() ...
[16:20:33.460]  - include = ‘immediateCondition’
[16:20:33.460]  - exclude = 
[16:20:33.460]  - resignal = FALSE
[16:20:33.460]  - Number of conditions: 88
[16:20:33.461] signalConditions() ... done
[16:20:33.461] result() for MulticoreFuture ... done
[16:20:33.461] result() for MulticoreFuture ...
[16:20:33.461] result() for MulticoreFuture ... done
[16:20:33.461] signalConditions() ...
[16:20:33.461]  - include = ‘immediateCondition’
[16:20:33.461]  - exclude = 
[16:20:33.461]  - resignal = FALSE
[16:20:33.462]  - Number of conditions: 88
[16:20:33.462] signalConditions() ... done
[16:20:33.462] Future state: ‘finished’
[16:20:33.462] result() for MulticoreFuture ...
[16:20:33.462] result() for MulticoreFuture ... done
[16:20:33.462] signalConditions() ...
[16:20:33.462]  - include = ‘condition’
[16:20:33.463]  - exclude = ‘immediateCondition’
[16:20:33.463]  - resignal = TRUE
[16:20:33.463]  - Number of conditions: 88
[16:20:33.463]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.421] getGlobalsAndPackages() ...
[16:20:33.463]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.421] Searching for globals...
[16:20:33.463]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.422] 
[16:20:33.463]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.422] Searching for globals ... DONE
[16:20:33.464]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.423] - globals: [0] <none>
[16:20:33.464]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.423] getGlobalsAndPackages() ... DONE
[16:20:33.464]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.424] run() for ‘Future’ ...
[16:20:33.464]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.424] - state: ‘created’
[16:20:33.464]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.424] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:33.465]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.425] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:33.465]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.425] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:33.465]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.425]   - Field: ‘label’
[16:20:33.465]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.425]   - Field: ‘local’
[16:20:33.465]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.425]   - Field: ‘owner’
[16:20:33.465]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.426]   - Field: ‘envir’
[16:20:33.466]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.426]   - Field: ‘packages’
[16:20:33.466]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.426]   - Field: ‘gc’
[16:20:33.466]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.426]   - Field: ‘conditions’
[16:20:33.466]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.426]   - Field: ‘expr’
[16:20:33.466]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.427]   - Field: ‘uuid’
[16:20:33.467]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.427]   - Field: ‘seed’
[16:20:33.467]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.427]   - Field: ‘version’
[16:20:33.467]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.427]   - Field: ‘result’
[16:20:33.467]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.427]   - Field: ‘asynchronous’
[16:20:33.467]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.427]   - Field: ‘calls’
[16:20:33.467]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.428]   - Field: ‘globals’
[16:20:33.468]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.428]   - Field: ‘stdout’
[16:20:33.468]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.428]   - Field: ‘earlySignal’
[16:20:33.468]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.428]   - Field: ‘lazy’
[16:20:33.468]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.428]   - Field: ‘state’
[16:20:33.468]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.429] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:33.468]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.429] - Launch lazy future ...
[16:20:33.469]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.429] Packages needed by the future expression (n = 0): <none>
[16:20:33.469]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.429] Packages needed by future strategies (n = 0): <none>
[16:20:33.469]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.430] {
[16:20:33.430]     {
[16:20:33.430]         {
[16:20:33.430]             ...future.startTime <- base::Sys.time()
[16:20:33.430]             {
[16:20:33.430]                 {
[16:20:33.430]                   {
[16:20:33.430]                     base::local({
[16:20:33.430]                       has_future <- base::requireNamespace("future", 
[16:20:33.430]                         quietly = TRUE)
[16:20:33.430]                       if (has_future) {
[16:20:33.430]                         ns <- base::getNamespace("future")
[16:20:33.430]                         version <- ns[[".package"]][["version"]]
[16:20:33.430]                         if (is.null(version)) 
[16:20:33.430]                           version <- utils::packageVersion("future")
[16:20:33.430]                       }
[16:20:33.430]                       else {
[16:20:33.430]                         version <- NULL
[16:20:33.430]                       }
[16:20:33.430]                       if (!has_future || version < "1.8.0") {
[16:20:33.430]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:33.430]                           "", base::R.version$version.string), 
[16:20:33.430]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:33.430]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:33.430]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:33.430]                             "release", "version")], collapse = " "), 
[16:20:33.430]                           hostname = base::Sys.info()[["nodename"]])
[16:20:33.430]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:33.430]                           info)
[16:20:33.430]                         info <- base::paste(info, collapse = "; ")
[16:20:33.430]                         if (!has_future) {
[16:20:33.430]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:33.430]                             info)
[16:20:33.430]                         }
[16:20:33.430]                         else {
[16:20:33.430]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:33.430]                             info, version)
[16:20:33.430]                         }
[16:20:33.430]                         base::stop(msg)
[16:20:33.430]                       }
[16:20:33.430]                     })
[16:20:33.430]                   }
[16:20:33.430]                   ...future.strategy.old <- future::plan("list")
[16:20:33.430]                   options(future.plan = NULL)
[16:20:33.430]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.430]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:33.430]                 }
[16:20:33.430]                 ...future.workdir <- getwd()
[16:20:33.430]             }
[16:20:33.430]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:33.430]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:33.430]         }
[16:20:33.430]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:33.430]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:33.430]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:33.430]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:33.430]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:33.430]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:33.430]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:33.430]             base::names(...future.oldOptions))
[16:20:33.430]     }
[16:20:33.430]     if (FALSE) {
[16:20:33.430]     }
[16:20:33.430]     else {
[16:20:33.430]         if (TRUE) {
[16:20:33.430]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:33.430]                 open = "w")
[16:20:33.430]         }
[16:20:33.430]         else {
[16:20:33.430]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:33.430]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:33.430]         }
[16:20:33.430]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:33.430]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:33.430]             base::sink(type = "output", split = FALSE)
[16:20:33.430]             base::close(...future.stdout)
[16:20:33.430]         }, add = TRUE)
[16:20:33.430]     }
[16:20:33.430]     ...future.frame <- base::sys.nframe()
[16:20:33.430]     ...future.conditions <- base::list()
[16:20:33.430]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:33.430]     if (FALSE) {
[16:20:33.430]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:33.430]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:33.430]     }
[16:20:33.430]     ...future.result <- base::tryCatch({
[16:20:33.430]         base::withCallingHandlers({
[16:20:33.430]             ...future.value <- base::withVisible(base::local(2))
[16:20:33.430]             future::FutureResult(value = ...future.value$value, 
[16:20:33.430]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.430]                   ...future.rng), globalenv = if (FALSE) 
[16:20:33.430]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:33.430]                     ...future.globalenv.names))
[16:20:33.430]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:33.430]         }, condition = base::local({
[16:20:33.430]             c <- base::c
[16:20:33.430]             inherits <- base::inherits
[16:20:33.430]             invokeRestart <- base::invokeRestart
[16:20:33.430]             length <- base::length
[16:20:33.430]             list <- base::list
[16:20:33.430]             seq.int <- base::seq.int
[16:20:33.430]             signalCondition <- base::signalCondition
[16:20:33.430]             sys.calls <- base::sys.calls
[16:20:33.430]             `[[` <- base::`[[`
[16:20:33.430]             `+` <- base::`+`
[16:20:33.430]             `<<-` <- base::`<<-`
[16:20:33.430]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:33.430]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:33.430]                   3L)]
[16:20:33.430]             }
[16:20:33.430]             function(cond) {
[16:20:33.430]                 is_error <- inherits(cond, "error")
[16:20:33.430]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:33.430]                   NULL)
[16:20:33.430]                 if (is_error) {
[16:20:33.430]                   sessionInformation <- function() {
[16:20:33.430]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:33.430]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:33.430]                       search = base::search(), system = base::Sys.info())
[16:20:33.430]                   }
[16:20:33.430]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.430]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:33.430]                     cond$call), session = sessionInformation(), 
[16:20:33.430]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:33.430]                   signalCondition(cond)
[16:20:33.430]                 }
[16:20:33.430]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:33.430]                 "immediateCondition"))) {
[16:20:33.430]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:33.430]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.430]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:33.430]                   if (TRUE && !signal) {
[16:20:33.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.430]                     {
[16:20:33.430]                       inherits <- base::inherits
[16:20:33.430]                       invokeRestart <- base::invokeRestart
[16:20:33.430]                       is.null <- base::is.null
[16:20:33.430]                       muffled <- FALSE
[16:20:33.430]                       if (inherits(cond, "message")) {
[16:20:33.430]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.430]                         if (muffled) 
[16:20:33.430]                           invokeRestart("muffleMessage")
[16:20:33.430]                       }
[16:20:33.430]                       else if (inherits(cond, "warning")) {
[16:20:33.430]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.430]                         if (muffled) 
[16:20:33.430]                           invokeRestart("muffleWarning")
[16:20:33.430]                       }
[16:20:33.430]                       else if (inherits(cond, "condition")) {
[16:20:33.430]                         if (!is.null(pattern)) {
[16:20:33.430]                           computeRestarts <- base::computeRestarts
[16:20:33.430]                           grepl <- base::grepl
[16:20:33.430]                           restarts <- computeRestarts(cond)
[16:20:33.430]                           for (restart in restarts) {
[16:20:33.430]                             name <- restart$name
[16:20:33.430]                             if (is.null(name)) 
[16:20:33.430]                               next
[16:20:33.430]                             if (!grepl(pattern, name)) 
[16:20:33.430]                               next
[16:20:33.430]                             invokeRestart(restart)
[16:20:33.430]                             muffled <- TRUE
[16:20:33.430]                             break
[16:20:33.430]                           }
[16:20:33.430]                         }
[16:20:33.430]                       }
[16:20:33.430]                       invisible(muffled)
[16:20:33.430]                     }
[16:20:33.430]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.430]                   }
[16:20:33.430]                 }
[16:20:33.430]                 else {
[16:20:33.430]                   if (TRUE) {
[16:20:33.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.430]                     {
[16:20:33.430]                       inherits <- base::inherits
[16:20:33.430]                       invokeRestart <- base::invokeRestart
[16:20:33.430]                       is.null <- base::is.null
[16:20:33.430]                       muffled <- FALSE
[16:20:33.430]                       if (inherits(cond, "message")) {
[16:20:33.430]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.430]                         if (muffled) 
[16:20:33.430]                           invokeRestart("muffleMessage")
[16:20:33.430]                       }
[16:20:33.430]                       else if (inherits(cond, "warning")) {
[16:20:33.430]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.430]                         if (muffled) 
[16:20:33.430]                           invokeRestart("muffleWarning")
[16:20:33.430]                       }
[16:20:33.430]                       else if (inherits(cond, "condition")) {
[16:20:33.430]                         if (!is.null(pattern)) {
[16:20:33.430]                           computeRestarts <- base::computeRestarts
[16:20:33.430]                           grepl <- base::grepl
[16:20:33.430]                           restarts <- computeRestarts(cond)
[16:20:33.430]                           for (restart in restarts) {
[16:20:33.430]                             name <- restart$name
[16:20:33.430]                             if (is.null(name)) 
[16:20:33.430]                               next
[16:20:33.430]                             if (!grepl(pattern, name)) 
[16:20:33.430]                               next
[16:20:33.430]                             invokeRestart(restart)
[16:20:33.430]                             muffled <- TRUE
[16:20:33.430]                             break
[16:20:33.430]                           }
[16:20:33.430]                         }
[16:20:33.430]                       }
[16:20:33.430]                       invisible(muffled)
[16:20:33.430]                     }
[16:20:33.430]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.430]                   }
[16:20:33.430]                 }
[16:20:33.430]             }
[16:20:33.430]         }))
[16:20:33.430]     }, error = function(ex) {
[16:20:33.430]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:33.430]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.430]                 ...future.rng), started = ...future.startTime, 
[16:20:33.430]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:33.430]             version = "1.8"), class = "FutureResult")
[16:20:33.430]     }, finally = {
[16:20:33.430]         if (!identical(...future.workdir, getwd())) 
[16:20:33.430]             setwd(...future.workdir)
[16:20:33.430]         {
[16:20:33.430]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:33.430]                 ...future.oldOptions$nwarnings <- NULL
[16:20:33.430]             }
[16:20:33.430]             base::options(...future.oldOptions)
[16:20:33.430]             if (.Platform$OS.type == "windows") {
[16:20:33.430]                 old_names <- names(...future.oldEnvVars)
[16:20:33.430]                 envs <- base::Sys.getenv()
[16:20:33.430]                 names <- names(envs)
[16:20:33.430]                 common <- intersect(names, old_names)
[16:20:33.430]                 added <- setdiff(names, old_names)
[16:20:33.430]                 removed <- setdiff(old_names, names)
[16:20:33.430]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:33.430]                   envs[common]]
[16:20:33.430]                 NAMES <- toupper(changed)
[16:20:33.430]                 args <- list()
[16:20:33.430]                 for (kk in seq_along(NAMES)) {
[16:20:33.430]                   name <- changed[[kk]]
[16:20:33.430]                   NAME <- NAMES[[kk]]
[16:20:33.430]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.430]                     next
[16:20:33.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.430]                 }
[16:20:33.430]                 NAMES <- toupper(added)
[16:20:33.430]                 for (kk in seq_along(NAMES)) {
[16:20:33.430]                   name <- added[[kk]]
[16:20:33.430]                   NAME <- NAMES[[kk]]
[16:20:33.430]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.430]                     next
[16:20:33.430]                   args[[name]] <- ""
[16:20:33.430]                 }
[16:20:33.430]                 NAMES <- toupper(removed)
[16:20:33.430]                 for (kk in seq_along(NAMES)) {
[16:20:33.430]                   name <- removed[[kk]]
[16:20:33.430]                   NAME <- NAMES[[kk]]
[16:20:33.430]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.430]                     next
[16:20:33.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.430]                 }
[16:20:33.430]                 if (length(args) > 0) 
[16:20:33.430]                   base::do.call(base::Sys.setenv, args = args)
[16:20:33.430]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:33.430]             }
[16:20:33.430]             else {
[16:20:33.430]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:33.430]             }
[16:20:33.430]             {
[16:20:33.430]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:33.430]                   0L) {
[16:20:33.430]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:33.430]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:33.430]                   base::options(opts)
[16:20:33.430]                 }
[16:20:33.430]                 {
[16:20:33.430]                   {
[16:20:33.430]                     NULL
[16:20:33.430]                     RNGkind("Mersenne-Twister")
[16:20:33.430]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:33.430]                       inherits = FALSE)
[16:20:33.430]                   }
[16:20:33.430]                   options(future.plan = NULL)
[16:20:33.430]                   if (is.na(NA_character_)) 
[16:20:33.430]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.430]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:33.430]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:33.430]                     .init = FALSE)
[16:20:33.430]                 }
[16:20:33.430]             }
[16:20:33.430]         }
[16:20:33.430]     })
[16:20:33.430]     if (TRUE) {
[16:20:33.430]         base::sink(type = "output", split = FALSE)
[16:20:33.430]         if (TRUE) {
[16:20:33.430]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:33.430]         }
[16:20:33.430]         else {
[16:20:33.430]             ...future.result["stdout"] <- base::list(NULL)
[16:20:33.430]         }
[16:20:33.430]         base::close(...future.stdout)
[16:20:33.430]         ...future.stdout <- NULL
[16:20:33.430]     }
[16:20:33.430]     ...future.result$conditions <- ...future.conditions
[16:20:33.430]     ...future.result$finished <- base::Sys.time()
[16:20:33.430]     ...future.result
[16:20:33.430] }
[16:20:33.469]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.433] plan(): Setting new future strategy stack:
[16:20:33.469]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.433] List of future strategies:
[16:20:33.433] 1. sequential:
[16:20:33.433]    - args: function (..., envir = parent.frame())
[16:20:33.433]    - tweaked: FALSE
[16:20:33.433]    - call: NULL
[16:20:33.469]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.434] plan(): nbrOfWorkers() = 1
[16:20:33.470]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.435] plan(): Setting new future strategy stack:
[16:20:33.470]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.435] List of future strategies:
[16:20:33.435] 1. sequential:
[16:20:33.435]    - args: function (..., envir = parent.frame())
[16:20:33.435]    - tweaked: FALSE
[16:20:33.435]    - call: NULL
[16:20:33.470]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.435] plan(): nbrOfWorkers() = 1
[16:20:33.470]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.436] SequentialFuture started (and completed)
[16:20:33.470]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.436] - Launch lazy future ... done
[16:20:33.470]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.436] run() for ‘SequentialFuture’ ... done
[16:20:33.471]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.437] getGlobalsAndPackages() ...
[16:20:33.471]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.437] Searching for globals...
[16:20:33.471]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.437] 
[16:20:33.471]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.437] Searching for globals ... DONE
[16:20:33.471]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.438] - globals: [0] <none>
[16:20:33.471]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.438] getGlobalsAndPackages() ... DONE
[16:20:33.471]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.438] run() for ‘Future’ ...
[16:20:33.472]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.438] - state: ‘created’
[16:20:33.472]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.438] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:33.472]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.439] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:33.472]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.439] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:33.472]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.439]   - Field: ‘label’
[16:20:33.472]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.439]   - Field: ‘local’
[16:20:33.473]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.440]   - Field: ‘owner’
[16:20:33.473]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.440]   - Field: ‘envir’
[16:20:33.473]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.440]   - Field: ‘packages’
[16:20:33.473]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.440]   - Field: ‘gc’
[16:20:33.473]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.440]   - Field: ‘conditions’
[16:20:33.473]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.440]   - Field: ‘expr’
[16:20:33.474]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.441]   - Field: ‘uuid’
[16:20:33.474]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.441]   - Field: ‘seed’
[16:20:33.474]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.441]   - Field: ‘version’
[16:20:33.474]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.441]   - Field: ‘result’
[16:20:33.474]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.441]   - Field: ‘asynchronous’
[16:20:33.474]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.441]   - Field: ‘calls’
[16:20:33.475]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.441]   - Field: ‘globals’
[16:20:33.475]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.442]   - Field: ‘stdout’
[16:20:33.475]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.442]   - Field: ‘earlySignal’
[16:20:33.475]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.442]   - Field: ‘lazy’
[16:20:33.475]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.442]   - Field: ‘state’
[16:20:33.475]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.442] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:33.475]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.442] - Launch lazy future ...
[16:20:33.476]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.443] Packages needed by the future expression (n = 0): <none>
[16:20:33.476]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.443] Packages needed by future strategies (n = 0): <none>
[16:20:33.476]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.443] {
[16:20:33.443]     {
[16:20:33.443]         {
[16:20:33.443]             ...future.startTime <- base::Sys.time()
[16:20:33.443]             {
[16:20:33.443]                 {
[16:20:33.443]                   {
[16:20:33.443]                     base::local({
[16:20:33.443]                       has_future <- base::requireNamespace("future", 
[16:20:33.443]                         quietly = TRUE)
[16:20:33.443]                       if (has_future) {
[16:20:33.443]                         ns <- base::getNamespace("future")
[16:20:33.443]                         version <- ns[[".package"]][["version"]]
[16:20:33.443]                         if (is.null(version)) 
[16:20:33.443]                           version <- utils::packageVersion("future")
[16:20:33.443]                       }
[16:20:33.443]                       else {
[16:20:33.443]                         version <- NULL
[16:20:33.443]                       }
[16:20:33.443]                       if (!has_future || version < "1.8.0") {
[16:20:33.443]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:33.443]                           "", base::R.version$version.string), 
[16:20:33.443]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:33.443]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:33.443]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:33.443]                             "release", "version")], collapse = " "), 
[16:20:33.443]                           hostname = base::Sys.info()[["nodename"]])
[16:20:33.443]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:33.443]                           info)
[16:20:33.443]                         info <- base::paste(info, collapse = "; ")
[16:20:33.443]                         if (!has_future) {
[16:20:33.443]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:33.443]                             info)
[16:20:33.443]                         }
[16:20:33.443]                         else {
[16:20:33.443]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:33.443]                             info, version)
[16:20:33.443]                         }
[16:20:33.443]                         base::stop(msg)
[16:20:33.443]                       }
[16:20:33.443]                     })
[16:20:33.443]                   }
[16:20:33.443]                   ...future.strategy.old <- future::plan("list")
[16:20:33.443]                   options(future.plan = NULL)
[16:20:33.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:33.443]                 }
[16:20:33.443]                 ...future.workdir <- getwd()
[16:20:33.443]             }
[16:20:33.443]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:33.443]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:33.443]         }
[16:20:33.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:33.443]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:33.443]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:33.443]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:33.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:33.443]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:33.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:33.443]             base::names(...future.oldOptions))
[16:20:33.443]     }
[16:20:33.443]     if (FALSE) {
[16:20:33.443]     }
[16:20:33.443]     else {
[16:20:33.443]         if (TRUE) {
[16:20:33.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:33.443]                 open = "w")
[16:20:33.443]         }
[16:20:33.443]         else {
[16:20:33.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:33.443]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:33.443]         }
[16:20:33.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:33.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:33.443]             base::sink(type = "output", split = FALSE)
[16:20:33.443]             base::close(...future.stdout)
[16:20:33.443]         }, add = TRUE)
[16:20:33.443]     }
[16:20:33.443]     ...future.frame <- base::sys.nframe()
[16:20:33.443]     ...future.conditions <- base::list()
[16:20:33.443]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:33.443]     if (FALSE) {
[16:20:33.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:33.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:33.443]     }
[16:20:33.443]     ...future.result <- base::tryCatch({
[16:20:33.443]         base::withCallingHandlers({
[16:20:33.443]             ...future.value <- base::withVisible(base::local(4))
[16:20:33.443]             future::FutureResult(value = ...future.value$value, 
[16:20:33.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.443]                   ...future.rng), globalenv = if (FALSE) 
[16:20:33.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:33.443]                     ...future.globalenv.names))
[16:20:33.443]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:33.443]         }, condition = base::local({
[16:20:33.443]             c <- base::c
[16:20:33.443]             inherits <- base::inherits
[16:20:33.443]             invokeRestart <- base::invokeRestart
[16:20:33.443]             length <- base::length
[16:20:33.443]             list <- base::list
[16:20:33.443]             seq.int <- base::seq.int
[16:20:33.443]             signalCondition <- base::signalCondition
[16:20:33.443]             sys.calls <- base::sys.calls
[16:20:33.443]             `[[` <- base::`[[`
[16:20:33.443]             `+` <- base::`+`
[16:20:33.443]             `<<-` <- base::`<<-`
[16:20:33.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:33.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:33.443]                   3L)]
[16:20:33.443]             }
[16:20:33.443]             function(cond) {
[16:20:33.443]                 is_error <- inherits(cond, "error")
[16:20:33.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:33.443]                   NULL)
[16:20:33.443]                 if (is_error) {
[16:20:33.443]                   sessionInformation <- function() {
[16:20:33.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:33.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:33.443]                       search = base::search(), system = base::Sys.info())
[16:20:33.443]                   }
[16:20:33.443]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:33.443]                     cond$call), session = sessionInformation(), 
[16:20:33.443]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:33.443]                   signalCondition(cond)
[16:20:33.443]                 }
[16:20:33.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:33.443]                 "immediateCondition"))) {
[16:20:33.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:33.443]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:33.443]                   if (TRUE && !signal) {
[16:20:33.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.443]                     {
[16:20:33.443]                       inherits <- base::inherits
[16:20:33.443]                       invokeRestart <- base::invokeRestart
[16:20:33.443]                       is.null <- base::is.null
[16:20:33.443]                       muffled <- FALSE
[16:20:33.443]                       if (inherits(cond, "message")) {
[16:20:33.443]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.443]                         if (muffled) 
[16:20:33.443]                           invokeRestart("muffleMessage")
[16:20:33.443]                       }
[16:20:33.443]                       else if (inherits(cond, "warning")) {
[16:20:33.443]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.443]                         if (muffled) 
[16:20:33.443]                           invokeRestart("muffleWarning")
[16:20:33.443]                       }
[16:20:33.443]                       else if (inherits(cond, "condition")) {
[16:20:33.443]                         if (!is.null(pattern)) {
[16:20:33.443]                           computeRestarts <- base::computeRestarts
[16:20:33.443]                           grepl <- base::grepl
[16:20:33.443]                           restarts <- computeRestarts(cond)
[16:20:33.443]                           for (restart in restarts) {
[16:20:33.443]                             name <- restart$name
[16:20:33.443]                             if (is.null(name)) 
[16:20:33.443]                               next
[16:20:33.443]                             if (!grepl(pattern, name)) 
[16:20:33.443]                               next
[16:20:33.443]                             invokeRestart(restart)
[16:20:33.443]                             muffled <- TRUE
[16:20:33.443]                             break
[16:20:33.443]                           }
[16:20:33.443]                         }
[16:20:33.443]                       }
[16:20:33.443]                       invisible(muffled)
[16:20:33.443]                     }
[16:20:33.443]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.443]                   }
[16:20:33.443]                 }
[16:20:33.443]                 else {
[16:20:33.443]                   if (TRUE) {
[16:20:33.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.443]                     {
[16:20:33.443]                       inherits <- base::inherits
[16:20:33.443]                       invokeRestart <- base::invokeRestart
[16:20:33.443]                       is.null <- base::is.null
[16:20:33.443]                       muffled <- FALSE
[16:20:33.443]                       if (inherits(cond, "message")) {
[16:20:33.443]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.443]                         if (muffled) 
[16:20:33.443]                           invokeRestart("muffleMessage")
[16:20:33.443]                       }
[16:20:33.443]                       else if (inherits(cond, "warning")) {
[16:20:33.443]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.443]                         if (muffled) 
[16:20:33.443]                           invokeRestart("muffleWarning")
[16:20:33.443]                       }
[16:20:33.443]                       else if (inherits(cond, "condition")) {
[16:20:33.443]                         if (!is.null(pattern)) {
[16:20:33.443]                           computeRestarts <- base::computeRestarts
[16:20:33.443]                           grepl <- base::grepl
[16:20:33.443]                           restarts <- computeRestarts(cond)
[16:20:33.443]                           for (restart in restarts) {
[16:20:33.443]                             name <- restart$name
[16:20:33.443]                             if (is.null(name)) 
[16:20:33.443]                               next
[16:20:33.443]                             if (!grepl(pattern, name)) 
[16:20:33.443]                               next
[16:20:33.443]                             invokeRestart(restart)
[16:20:33.443]                             muffled <- TRUE
[16:20:33.443]                             break
[16:20:33.443]                           }
[16:20:33.443]                         }
[16:20:33.443]                       }
[16:20:33.443]                       invisible(muffled)
[16:20:33.443]                     }
[16:20:33.443]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.443]                   }
[16:20:33.443]                 }
[16:20:33.443]             }
[16:20:33.443]         }))
[16:20:33.443]     }, error = function(ex) {
[16:20:33.443]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:33.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.443]                 ...future.rng), started = ...future.startTime, 
[16:20:33.443]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:33.443]             version = "1.8"), class = "FutureResult")
[16:20:33.443]     }, finally = {
[16:20:33.443]         if (!identical(...future.workdir, getwd())) 
[16:20:33.443]             setwd(...future.workdir)
[16:20:33.443]         {
[16:20:33.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:33.443]                 ...future.oldOptions$nwarnings <- NULL
[16:20:33.443]             }
[16:20:33.443]             base::options(...future.oldOptions)
[16:20:33.443]             if (.Platform$OS.type == "windows") {
[16:20:33.443]                 old_names <- names(...future.oldEnvVars)
[16:20:33.443]                 envs <- base::Sys.getenv()
[16:20:33.443]                 names <- names(envs)
[16:20:33.443]                 common <- intersect(names, old_names)
[16:20:33.443]                 added <- setdiff(names, old_names)
[16:20:33.443]                 removed <- setdiff(old_names, names)
[16:20:33.443]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:33.443]                   envs[common]]
[16:20:33.443]                 NAMES <- toupper(changed)
[16:20:33.443]                 args <- list()
[16:20:33.443]                 for (kk in seq_along(NAMES)) {
[16:20:33.443]                   name <- changed[[kk]]
[16:20:33.443]                   NAME <- NAMES[[kk]]
[16:20:33.443]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.443]                     next
[16:20:33.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.443]                 }
[16:20:33.443]                 NAMES <- toupper(added)
[16:20:33.443]                 for (kk in seq_along(NAMES)) {
[16:20:33.443]                   name <- added[[kk]]
[16:20:33.443]                   NAME <- NAMES[[kk]]
[16:20:33.443]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.443]                     next
[16:20:33.443]                   args[[name]] <- ""
[16:20:33.443]                 }
[16:20:33.443]                 NAMES <- toupper(removed)
[16:20:33.443]                 for (kk in seq_along(NAMES)) {
[16:20:33.443]                   name <- removed[[kk]]
[16:20:33.443]                   NAME <- NAMES[[kk]]
[16:20:33.443]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.443]                     next
[16:20:33.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.443]                 }
[16:20:33.443]                 if (length(args) > 0) 
[16:20:33.443]                   base::do.call(base::Sys.setenv, args = args)
[16:20:33.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:33.443]             }
[16:20:33.443]             else {
[16:20:33.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:33.443]             }
[16:20:33.443]             {
[16:20:33.443]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:33.443]                   0L) {
[16:20:33.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:33.443]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:33.443]                   base::options(opts)
[16:20:33.443]                 }
[16:20:33.443]                 {
[16:20:33.443]                   {
[16:20:33.443]                     NULL
[16:20:33.443]                     RNGkind("Mersenne-Twister")
[16:20:33.443]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:33.443]                       inherits = FALSE)
[16:20:33.443]                   }
[16:20:33.443]                   options(future.plan = NULL)
[16:20:33.443]                   if (is.na(NA_character_)) 
[16:20:33.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:33.443]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:33.443]                     .init = FALSE)
[16:20:33.443]                 }
[16:20:33.443]             }
[16:20:33.443]         }
[16:20:33.443]     })
[16:20:33.443]     if (TRUE) {
[16:20:33.443]         base::sink(type = "output", split = FALSE)
[16:20:33.443]         if (TRUE) {
[16:20:33.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:33.443]         }
[16:20:33.443]         else {
[16:20:33.443]             ...future.result["stdout"] <- base::list(NULL)
[16:20:33.443]         }
[16:20:33.443]         base::close(...future.stdout)
[16:20:33.443]         ...future.stdout <- NULL
[16:20:33.443]     }
[16:20:33.443]     ...future.result$conditions <- ...future.conditions
[16:20:33.443]     ...future.result$finished <- base::Sys.time()
[16:20:33.443]     ...future.result
[16:20:33.443] }
[16:20:33.476]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.446] plan(): Setting new future strategy stack:
[16:20:33.476]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.446] List of future strategies:
[16:20:33.446] 1. sequential:
[16:20:33.446]    - args: function (..., envir = parent.frame())
[16:20:33.446]    - tweaked: FALSE
[16:20:33.446]    - call: NULL
[16:20:33.477]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.446] plan(): nbrOfWorkers() = 1
[16:20:33.477]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.447] plan(): Setting new future strategy stack:
[16:20:33.479]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.447] List of future strategies:
[16:20:33.447] 1. sequential:
[16:20:33.447]    - args: function (..., envir = parent.frame())
[16:20:33.447]    - tweaked: FALSE
[16:20:33.447]    - call: NULL
[16:20:33.479]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.451] plan(): nbrOfWorkers() = 1
[16:20:33.479]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.451] SequentialFuture started (and completed)
[16:20:33.480]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.451] - Launch lazy future ... done
[16:20:33.480]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[16:20:33.451] run() for ‘SequentialFuture’ ... done
[16:20:33.480] signalConditions() ... done
a = 10
[16:20:33.481] getGlobalsAndPackages() ...
[16:20:33.481] Searching for globals...
[16:20:33.482] - globals found: [3] ‘{’, ‘+’, ‘a’
[16:20:33.482] Searching for globals ... DONE
[16:20:33.482] Resolving globals: FALSE
[16:20:33.483] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:33.483] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:20:33.483] - globals: [1] ‘a’
[16:20:33.483] 
[16:20:33.484] getGlobalsAndPackages() ... DONE
[16:20:33.484] run() for ‘Future’ ...
[16:20:33.484] - state: ‘created’
[16:20:33.484] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:33.488] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:33.488] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:33.488]   - Field: ‘label’
[16:20:33.489]   - Field: ‘local’
[16:20:33.489]   - Field: ‘owner’
[16:20:33.489]   - Field: ‘envir’
[16:20:33.489]   - Field: ‘workers’
[16:20:33.489]   - Field: ‘packages’
[16:20:33.489]   - Field: ‘gc’
[16:20:33.489]   - Field: ‘job’
[16:20:33.489]   - Field: ‘conditions’
[16:20:33.490]   - Field: ‘expr’
[16:20:33.490]   - Field: ‘uuid’
[16:20:33.490]   - Field: ‘seed’
[16:20:33.490]   - Field: ‘version’
[16:20:33.490]   - Field: ‘result’
[16:20:33.490]   - Field: ‘asynchronous’
[16:20:33.490]   - Field: ‘calls’
[16:20:33.490]   - Field: ‘globals’
[16:20:33.490]   - Field: ‘stdout’
[16:20:33.490]   - Field: ‘earlySignal’
[16:20:33.491]   - Field: ‘lazy’
[16:20:33.491]   - Field: ‘state’
[16:20:33.491] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:33.491] - Launch lazy future ...
[16:20:33.491] Packages needed by the future expression (n = 0): <none>
[16:20:33.491] Packages needed by future strategies (n = 0): <none>
[16:20:33.492] {
[16:20:33.492]     {
[16:20:33.492]         {
[16:20:33.492]             ...future.startTime <- base::Sys.time()
[16:20:33.492]             {
[16:20:33.492]                 {
[16:20:33.492]                   {
[16:20:33.492]                     {
[16:20:33.492]                       base::local({
[16:20:33.492]                         has_future <- base::requireNamespace("future", 
[16:20:33.492]                           quietly = TRUE)
[16:20:33.492]                         if (has_future) {
[16:20:33.492]                           ns <- base::getNamespace("future")
[16:20:33.492]                           version <- ns[[".package"]][["version"]]
[16:20:33.492]                           if (is.null(version)) 
[16:20:33.492]                             version <- utils::packageVersion("future")
[16:20:33.492]                         }
[16:20:33.492]                         else {
[16:20:33.492]                           version <- NULL
[16:20:33.492]                         }
[16:20:33.492]                         if (!has_future || version < "1.8.0") {
[16:20:33.492]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:33.492]                             "", base::R.version$version.string), 
[16:20:33.492]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:33.492]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:33.492]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:33.492]                               "release", "version")], collapse = " "), 
[16:20:33.492]                             hostname = base::Sys.info()[["nodename"]])
[16:20:33.492]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:33.492]                             info)
[16:20:33.492]                           info <- base::paste(info, collapse = "; ")
[16:20:33.492]                           if (!has_future) {
[16:20:33.492]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:33.492]                               info)
[16:20:33.492]                           }
[16:20:33.492]                           else {
[16:20:33.492]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:33.492]                               info, version)
[16:20:33.492]                           }
[16:20:33.492]                           base::stop(msg)
[16:20:33.492]                         }
[16:20:33.492]                       })
[16:20:33.492]                     }
[16:20:33.492]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:33.492]                     base::options(mc.cores = 1L)
[16:20:33.492]                   }
[16:20:33.492]                   ...future.strategy.old <- future::plan("list")
[16:20:33.492]                   options(future.plan = NULL)
[16:20:33.492]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.492]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:33.492]                 }
[16:20:33.492]                 ...future.workdir <- getwd()
[16:20:33.492]             }
[16:20:33.492]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:33.492]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:33.492]         }
[16:20:33.492]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:33.492]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:33.492]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:33.492]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:33.492]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:33.492]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:33.492]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:33.492]             base::names(...future.oldOptions))
[16:20:33.492]     }
[16:20:33.492]     if (FALSE) {
[16:20:33.492]     }
[16:20:33.492]     else {
[16:20:33.492]         if (TRUE) {
[16:20:33.492]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:33.492]                 open = "w")
[16:20:33.492]         }
[16:20:33.492]         else {
[16:20:33.492]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:33.492]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:33.492]         }
[16:20:33.492]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:33.492]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:33.492]             base::sink(type = "output", split = FALSE)
[16:20:33.492]             base::close(...future.stdout)
[16:20:33.492]         }, add = TRUE)
[16:20:33.492]     }
[16:20:33.492]     ...future.frame <- base::sys.nframe()
[16:20:33.492]     ...future.conditions <- base::list()
[16:20:33.492]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:33.492]     if (FALSE) {
[16:20:33.492]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:33.492]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:33.492]     }
[16:20:33.492]     ...future.result <- base::tryCatch({
[16:20:33.492]         base::withCallingHandlers({
[16:20:33.492]             ...future.value <- base::withVisible(base::local({
[16:20:33.492]                 withCallingHandlers({
[16:20:33.492]                   {
[16:20:33.492]                     a + 1
[16:20:33.492]                   }
[16:20:33.492]                 }, immediateCondition = function(cond) {
[16:20:33.492]                   save_rds <- function (object, pathname, ...) 
[16:20:33.492]                   {
[16:20:33.492]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:33.492]                     if (file_test("-f", pathname_tmp)) {
[16:20:33.492]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.492]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:33.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.492]                         fi_tmp[["mtime"]])
[16:20:33.492]                     }
[16:20:33.492]                     tryCatch({
[16:20:33.492]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:33.492]                     }, error = function(ex) {
[16:20:33.492]                       msg <- conditionMessage(ex)
[16:20:33.492]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.492]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:33.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.492]                         fi_tmp[["mtime"]], msg)
[16:20:33.492]                       ex$message <- msg
[16:20:33.492]                       stop(ex)
[16:20:33.492]                     })
[16:20:33.492]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:33.492]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:33.492]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:33.492]                       fi_tmp <- file.info(pathname_tmp)
[16:20:33.492]                       fi <- file.info(pathname)
[16:20:33.492]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:33.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:33.492]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:33.492]                         fi[["size"]], fi[["mtime"]])
[16:20:33.492]                       stop(msg)
[16:20:33.492]                     }
[16:20:33.492]                     invisible(pathname)
[16:20:33.492]                   }
[16:20:33.492]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:33.492]                     rootPath = tempdir()) 
[16:20:33.492]                   {
[16:20:33.492]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:33.492]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:33.492]                       tmpdir = path, fileext = ".rds")
[16:20:33.492]                     save_rds(obj, file)
[16:20:33.492]                   }
[16:20:33.492]                   saveImmediateCondition(cond, path = "/tmp/RtmpFUh73Z/.future/immediateConditions")
[16:20:33.492]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.492]                   {
[16:20:33.492]                     inherits <- base::inherits
[16:20:33.492]                     invokeRestart <- base::invokeRestart
[16:20:33.492]                     is.null <- base::is.null
[16:20:33.492]                     muffled <- FALSE
[16:20:33.492]                     if (inherits(cond, "message")) {
[16:20:33.492]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:33.492]                       if (muffled) 
[16:20:33.492]                         invokeRestart("muffleMessage")
[16:20:33.492]                     }
[16:20:33.492]                     else if (inherits(cond, "warning")) {
[16:20:33.492]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:33.492]                       if (muffled) 
[16:20:33.492]                         invokeRestart("muffleWarning")
[16:20:33.492]                     }
[16:20:33.492]                     else if (inherits(cond, "condition")) {
[16:20:33.492]                       if (!is.null(pattern)) {
[16:20:33.492]                         computeRestarts <- base::computeRestarts
[16:20:33.492]                         grepl <- base::grepl
[16:20:33.492]                         restarts <- computeRestarts(cond)
[16:20:33.492]                         for (restart in restarts) {
[16:20:33.492]                           name <- restart$name
[16:20:33.492]                           if (is.null(name)) 
[16:20:33.492]                             next
[16:20:33.492]                           if (!grepl(pattern, name)) 
[16:20:33.492]                             next
[16:20:33.492]                           invokeRestart(restart)
[16:20:33.492]                           muffled <- TRUE
[16:20:33.492]                           break
[16:20:33.492]                         }
[16:20:33.492]                       }
[16:20:33.492]                     }
[16:20:33.492]                     invisible(muffled)
[16:20:33.492]                   }
[16:20:33.492]                   muffleCondition(cond)
[16:20:33.492]                 })
[16:20:33.492]             }))
[16:20:33.492]             future::FutureResult(value = ...future.value$value, 
[16:20:33.492]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.492]                   ...future.rng), globalenv = if (FALSE) 
[16:20:33.492]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:33.492]                     ...future.globalenv.names))
[16:20:33.492]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:33.492]         }, condition = base::local({
[16:20:33.492]             c <- base::c
[16:20:33.492]             inherits <- base::inherits
[16:20:33.492]             invokeRestart <- base::invokeRestart
[16:20:33.492]             length <- base::length
[16:20:33.492]             list <- base::list
[16:20:33.492]             seq.int <- base::seq.int
[16:20:33.492]             signalCondition <- base::signalCondition
[16:20:33.492]             sys.calls <- base::sys.calls
[16:20:33.492]             `[[` <- base::`[[`
[16:20:33.492]             `+` <- base::`+`
[16:20:33.492]             `<<-` <- base::`<<-`
[16:20:33.492]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:33.492]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:33.492]                   3L)]
[16:20:33.492]             }
[16:20:33.492]             function(cond) {
[16:20:33.492]                 is_error <- inherits(cond, "error")
[16:20:33.492]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:33.492]                   NULL)
[16:20:33.492]                 if (is_error) {
[16:20:33.492]                   sessionInformation <- function() {
[16:20:33.492]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:33.492]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:33.492]                       search = base::search(), system = base::Sys.info())
[16:20:33.492]                   }
[16:20:33.492]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.492]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:33.492]                     cond$call), session = sessionInformation(), 
[16:20:33.492]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:33.492]                   signalCondition(cond)
[16:20:33.492]                 }
[16:20:33.492]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:33.492]                 "immediateCondition"))) {
[16:20:33.492]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:33.492]                   ...future.conditions[[length(...future.conditions) + 
[16:20:33.492]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:33.492]                   if (TRUE && !signal) {
[16:20:33.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.492]                     {
[16:20:33.492]                       inherits <- base::inherits
[16:20:33.492]                       invokeRestart <- base::invokeRestart
[16:20:33.492]                       is.null <- base::is.null
[16:20:33.492]                       muffled <- FALSE
[16:20:33.492]                       if (inherits(cond, "message")) {
[16:20:33.492]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.492]                         if (muffled) 
[16:20:33.492]                           invokeRestart("muffleMessage")
[16:20:33.492]                       }
[16:20:33.492]                       else if (inherits(cond, "warning")) {
[16:20:33.492]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.492]                         if (muffled) 
[16:20:33.492]                           invokeRestart("muffleWarning")
[16:20:33.492]                       }
[16:20:33.492]                       else if (inherits(cond, "condition")) {
[16:20:33.492]                         if (!is.null(pattern)) {
[16:20:33.492]                           computeRestarts <- base::computeRestarts
[16:20:33.492]                           grepl <- base::grepl
[16:20:33.492]                           restarts <- computeRestarts(cond)
[16:20:33.492]                           for (restart in restarts) {
[16:20:33.492]                             name <- restart$name
[16:20:33.492]                             if (is.null(name)) 
[16:20:33.492]                               next
[16:20:33.492]                             if (!grepl(pattern, name)) 
[16:20:33.492]                               next
[16:20:33.492]                             invokeRestart(restart)
[16:20:33.492]                             muffled <- TRUE
[16:20:33.492]                             break
[16:20:33.492]                           }
[16:20:33.492]                         }
[16:20:33.492]                       }
[16:20:33.492]                       invisible(muffled)
[16:20:33.492]                     }
[16:20:33.492]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.492]                   }
[16:20:33.492]                 }
[16:20:33.492]                 else {
[16:20:33.492]                   if (TRUE) {
[16:20:33.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:33.492]                     {
[16:20:33.492]                       inherits <- base::inherits
[16:20:33.492]                       invokeRestart <- base::invokeRestart
[16:20:33.492]                       is.null <- base::is.null
[16:20:33.492]                       muffled <- FALSE
[16:20:33.492]                       if (inherits(cond, "message")) {
[16:20:33.492]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:33.492]                         if (muffled) 
[16:20:33.492]                           invokeRestart("muffleMessage")
[16:20:33.492]                       }
[16:20:33.492]                       else if (inherits(cond, "warning")) {
[16:20:33.492]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:33.492]                         if (muffled) 
[16:20:33.492]                           invokeRestart("muffleWarning")
[16:20:33.492]                       }
[16:20:33.492]                       else if (inherits(cond, "condition")) {
[16:20:33.492]                         if (!is.null(pattern)) {
[16:20:33.492]                           computeRestarts <- base::computeRestarts
[16:20:33.492]                           grepl <- base::grepl
[16:20:33.492]                           restarts <- computeRestarts(cond)
[16:20:33.492]                           for (restart in restarts) {
[16:20:33.492]                             name <- restart$name
[16:20:33.492]                             if (is.null(name)) 
[16:20:33.492]                               next
[16:20:33.492]                             if (!grepl(pattern, name)) 
[16:20:33.492]                               next
[16:20:33.492]                             invokeRestart(restart)
[16:20:33.492]                             muffled <- TRUE
[16:20:33.492]                             break
[16:20:33.492]                           }
[16:20:33.492]                         }
[16:20:33.492]                       }
[16:20:33.492]                       invisible(muffled)
[16:20:33.492]                     }
[16:20:33.492]                     muffleCondition(cond, pattern = "^muffle")
[16:20:33.492]                   }
[16:20:33.492]                 }
[16:20:33.492]             }
[16:20:33.492]         }))
[16:20:33.492]     }, error = function(ex) {
[16:20:33.492]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:33.492]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:33.492]                 ...future.rng), started = ...future.startTime, 
[16:20:33.492]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:33.492]             version = "1.8"), class = "FutureResult")
[16:20:33.492]     }, finally = {
[16:20:33.492]         if (!identical(...future.workdir, getwd())) 
[16:20:33.492]             setwd(...future.workdir)
[16:20:33.492]         {
[16:20:33.492]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:33.492]                 ...future.oldOptions$nwarnings <- NULL
[16:20:33.492]             }
[16:20:33.492]             base::options(...future.oldOptions)
[16:20:33.492]             if (.Platform$OS.type == "windows") {
[16:20:33.492]                 old_names <- names(...future.oldEnvVars)
[16:20:33.492]                 envs <- base::Sys.getenv()
[16:20:33.492]                 names <- names(envs)
[16:20:33.492]                 common <- intersect(names, old_names)
[16:20:33.492]                 added <- setdiff(names, old_names)
[16:20:33.492]                 removed <- setdiff(old_names, names)
[16:20:33.492]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:33.492]                   envs[common]]
[16:20:33.492]                 NAMES <- toupper(changed)
[16:20:33.492]                 args <- list()
[16:20:33.492]                 for (kk in seq_along(NAMES)) {
[16:20:33.492]                   name <- changed[[kk]]
[16:20:33.492]                   NAME <- NAMES[[kk]]
[16:20:33.492]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.492]                     next
[16:20:33.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.492]                 }
[16:20:33.492]                 NAMES <- toupper(added)
[16:20:33.492]                 for (kk in seq_along(NAMES)) {
[16:20:33.492]                   name <- added[[kk]]
[16:20:33.492]                   NAME <- NAMES[[kk]]
[16:20:33.492]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.492]                     next
[16:20:33.492]                   args[[name]] <- ""
[16:20:33.492]                 }
[16:20:33.492]                 NAMES <- toupper(removed)
[16:20:33.492]                 for (kk in seq_along(NAMES)) {
[16:20:33.492]                   name <- removed[[kk]]
[16:20:33.492]                   NAME <- NAMES[[kk]]
[16:20:33.492]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:33.492]                     next
[16:20:33.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:33.492]                 }
[16:20:33.492]                 if (length(args) > 0) 
[16:20:33.492]                   base::do.call(base::Sys.setenv, args = args)
[16:20:33.492]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:33.492]             }
[16:20:33.492]             else {
[16:20:33.492]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:33.492]             }
[16:20:33.492]             {
[16:20:33.492]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:33.492]                   0L) {
[16:20:33.492]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:33.492]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:33.492]                   base::options(opts)
[16:20:33.492]                 }
[16:20:33.492]                 {
[16:20:33.492]                   {
[16:20:33.492]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:33.492]                     NULL
[16:20:33.492]                   }
[16:20:33.492]                   options(future.plan = NULL)
[16:20:33.492]                   if (is.na(NA_character_)) 
[16:20:33.492]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:33.492]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:33.492]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:33.492]                     .init = FALSE)
[16:20:33.492]                 }
[16:20:33.492]             }
[16:20:33.492]         }
[16:20:33.492]     })
[16:20:33.492]     if (TRUE) {
[16:20:33.492]         base::sink(type = "output", split = FALSE)
[16:20:33.492]         if (TRUE) {
[16:20:33.492]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:33.492]         }
[16:20:33.492]         else {
[16:20:33.492]             ...future.result["stdout"] <- base::list(NULL)
[16:20:33.492]         }
[16:20:33.492]         base::close(...future.stdout)
[16:20:33.492]         ...future.stdout <- NULL
[16:20:33.492]     }
[16:20:33.492]     ...future.result$conditions <- ...future.conditions
[16:20:33.492]     ...future.result$finished <- base::Sys.time()
[16:20:33.492]     ...future.result
[16:20:33.492] }
[16:20:33.494] assign_globals() ...
[16:20:33.494] List of 1
[16:20:33.494]  $ a: num 10
[16:20:33.494]  - attr(*, "where")=List of 1
[16:20:33.494]   ..$ a:<environment: R_EmptyEnv> 
[16:20:33.494]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:33.494]  - attr(*, "resolved")= logi FALSE
[16:20:33.494]  - attr(*, "total_size")= num 56
[16:20:33.494]  - attr(*, "already-done")= logi TRUE
[16:20:33.497] - copied ‘a’ to environment
[16:20:33.497] assign_globals() ... done
[16:20:33.497] requestCore(): workers = 2
[16:20:33.499] MulticoreFuture started
[16:20:33.499] - Launch lazy future ... done
[16:20:33.499] run() for ‘MulticoreFuture’ ... done
[16:20:33.500] result() for MulticoreFuture ...
[16:20:33.500] plan(): Setting new future strategy stack:
[16:20:33.500] List of future strategies:
[16:20:33.500] 1. sequential:
[16:20:33.500]    - args: function (..., envir = parent.frame())
[16:20:33.500]    - tweaked: FALSE
[16:20:33.500]    - call: NULL
[16:20:33.501] plan(): nbrOfWorkers() = 1
[16:20:33.503] plan(): Setting new future strategy stack:
[16:20:33.503] List of future strategies:
[16:20:33.503] 1. multicore:
[16:20:33.503]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:33.503]    - tweaked: FALSE
[16:20:33.503]    - call: plan(strategy)
[16:20:33.508] plan(): nbrOfWorkers() = 2
[16:20:33.509] result() for MulticoreFuture ...
[16:20:33.509] result() for MulticoreFuture ... done
[16:20:33.509] result() for MulticoreFuture ... done
[16:20:33.509] result() for MulticoreFuture ...
[16:20:33.510] result() for MulticoreFuture ... done
b = 11
*** %<-% with ‘multicore’ futures ... DONE
*** %<-% with ‘multisession’ futures ...
[16:20:33.510] plan(): Setting new future strategy stack:
[16:20:33.510] List of future strategies:
[16:20:33.510] 1. multisession:
[16:20:33.510]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:20:33.510]    - tweaked: FALSE
[16:20:33.510]    - call: plan(strategy)
[16:20:33.511] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:20:33.511] multisession:
[16:20:33.511] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:20:33.511] - tweaked: FALSE
[16:20:33.511] - call: plan(strategy)
[16:20:33.518] getGlobalsAndPackages() ...
[16:20:33.518] Not searching for globals
[16:20:33.518] - globals: [0] <none>
[16:20:33.518] getGlobalsAndPackages() ... DONE
[16:20:33.519] [local output] makeClusterPSOCK() ...
[16:20:33.566] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:20:33.567] [local output] Base port: 11257
[16:20:33.567] [local output] Getting setup options for 2 cluster nodes ...
[16:20:33.567] [local output]  - Node 1 of 2 ...
[16:20:33.568] [local output] localMachine=TRUE => revtunnel=FALSE

[16:20:33.568] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpFUh73Z/worker.rank=1.parallelly.parent=80612.13ae433cb5bf2.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpFUh73Z/worker.rank=1.parallelly.parent=80612.13ae433cb5bf2.pid")'’
[16:20:33.756] - Possible to infer worker's PID: TRUE
[16:20:33.756] [local output] Rscript port: 11257

[16:20:33.757] [local output]  - Node 2 of 2 ...
[16:20:33.757] [local output] localMachine=TRUE => revtunnel=FALSE

[16:20:33.758] [local output] Rscript port: 11257

[16:20:33.758] [local output] Getting setup options for 2 cluster nodes ... done
[16:20:33.758] [local output]  - Parallel setup requested for some PSOCK nodes
[16:20:33.759] [local output] Setting up PSOCK nodes in parallel
[16:20:33.759] List of 36
[16:20:33.759]  $ worker          : chr "localhost"
[16:20:33.759]   ..- attr(*, "localhost")= logi TRUE
[16:20:33.759]  $ master          : chr "localhost"
[16:20:33.759]  $ port            : int 11257
[16:20:33.759]  $ connectTimeout  : num 120
[16:20:33.759]  $ timeout         : num 2592000
[16:20:33.759]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:20:33.759]  $ homogeneous     : logi TRUE
[16:20:33.759]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:20:33.759]  $ rscript_envs    : NULL
[16:20:33.759]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:20:33.759]  $ rscript_startup : NULL
[16:20:33.759]  $ rscript_sh      : chr "sh"
[16:20:33.759]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:20:33.759]  $ methods         : logi TRUE
[16:20:33.759]  $ socketOptions   : chr "no-delay"
[16:20:33.759]  $ useXDR          : logi FALSE
[16:20:33.759]  $ outfile         : chr "/dev/null"
[16:20:33.759]  $ renice          : int NA
[16:20:33.759]  $ rshcmd          : NULL
[16:20:33.759]  $ user            : chr(0) 
[16:20:33.759]  $ revtunnel       : logi FALSE
[16:20:33.759]  $ rshlogfile      : NULL
[16:20:33.759]  $ rshopts         : chr(0) 
[16:20:33.759]  $ rank            : int 1
[16:20:33.759]  $ manual          : logi FALSE
[16:20:33.759]  $ dryrun          : logi FALSE
[16:20:33.759]  $ quiet           : logi FALSE
[16:20:33.759]  $ setup_strategy  : chr "parallel"
[16:20:33.759]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:20:33.759]  $ pidfile         : chr "/tmp/RtmpFUh73Z/worker.rank=1.parallelly.parent=80612.13ae433cb5bf2.pid"
[16:20:33.759]  $ rshcmd_label    : NULL
[16:20:33.759]  $ rsh_call        : NULL
[16:20:33.759]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:20:33.759]  $ localMachine    : logi TRUE
[16:20:33.759]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:20:33.759]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:20:33.759]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:20:33.759]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:20:33.759]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:20:33.759]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:20:33.759]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:20:33.759]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:20:33.759]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:20:33.759]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:20:33.759]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:20:33.759]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:20:33.759]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:20:33.759]  $ arguments       :List of 28
[16:20:33.759]   ..$ worker          : chr "localhost"
[16:20:33.759]   ..$ master          : NULL
[16:20:33.759]   ..$ port            : int 11257
[16:20:33.759]   ..$ connectTimeout  : num 120
[16:20:33.759]   ..$ timeout         : num 2592000
[16:20:33.759]   ..$ rscript         : NULL
[16:20:33.759]   ..$ homogeneous     : NULL
[16:20:33.759]   ..$ rscript_args    : NULL
[16:20:33.759]   ..$ rscript_envs    : NULL
[16:20:33.759]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:20:33.759]   ..$ rscript_startup : NULL
[16:20:33.759]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:20:33.759]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:20:33.759]   ..$ methods         : logi TRUE
[16:20:33.759]   ..$ socketOptions   : chr "no-delay"
[16:20:33.759]   ..$ useXDR          : logi FALSE
[16:20:33.759]   ..$ outfile         : chr "/dev/null"
[16:20:33.759]   ..$ renice          : int NA
[16:20:33.759]   ..$ rshcmd          : NULL
[16:20:33.759]   ..$ user            : NULL
[16:20:33.759]   ..$ revtunnel       : logi NA
[16:20:33.759]   ..$ rshlogfile      : NULL
[16:20:33.759]   ..$ rshopts         : NULL
[16:20:33.759]   ..$ rank            : int 1
[16:20:33.759]   ..$ manual          : logi FALSE
[16:20:33.759]   ..$ dryrun          : logi FALSE
[16:20:33.759]   ..$ quiet           : logi FALSE
[16:20:33.759]   ..$ setup_strategy  : chr "parallel"
[16:20:33.759]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:20:33.776] [local output] System call to launch all workers:
[16:20:33.776] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpFUh73Z/worker.rank=1.parallelly.parent=80612.13ae433cb5bf2.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11257 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:20:33.776] [local output] Starting PSOCK main server
[16:20:33.781] [local output] Workers launched
[16:20:33.782] [local output] Waiting for workers to connect back
[16:20:33.782]  - [local output] 0 workers out of 2 ready
[16:20:34.026]  - [local output] 0 workers out of 2 ready
[16:20:34.027]  - [local output] 1 workers out of 2 ready
[16:20:34.027]  - [local output] 2 workers out of 2 ready
[16:20:34.027] [local output] Launching of workers completed
[16:20:34.027] [local output] Collecting session information from workers
[16:20:34.028] [local output]  - Worker #1 of 2
[16:20:34.029] [local output]  - Worker #2 of 2
[16:20:34.029] [local output] makeClusterPSOCK() ... done
[16:20:34.040] Packages needed by the future expression (n = 0): <none>
[16:20:34.040] Packages needed by future strategies (n = 0): <none>
[16:20:34.041] {
[16:20:34.041]     {
[16:20:34.041]         {
[16:20:34.041]             ...future.startTime <- base::Sys.time()
[16:20:34.041]             {
[16:20:34.041]                 {
[16:20:34.041]                   {
[16:20:34.041]                     {
[16:20:34.041]                       base::local({
[16:20:34.041]                         has_future <- base::requireNamespace("future", 
[16:20:34.041]                           quietly = TRUE)
[16:20:34.041]                         if (has_future) {
[16:20:34.041]                           ns <- base::getNamespace("future")
[16:20:34.041]                           version <- ns[[".package"]][["version"]]
[16:20:34.041]                           if (is.null(version)) 
[16:20:34.041]                             version <- utils::packageVersion("future")
[16:20:34.041]                         }
[16:20:34.041]                         else {
[16:20:34.041]                           version <- NULL
[16:20:34.041]                         }
[16:20:34.041]                         if (!has_future || version < "1.8.0") {
[16:20:34.041]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:34.041]                             "", base::R.version$version.string), 
[16:20:34.041]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:34.041]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:34.041]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:34.041]                               "release", "version")], collapse = " "), 
[16:20:34.041]                             hostname = base::Sys.info()[["nodename"]])
[16:20:34.041]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:34.041]                             info)
[16:20:34.041]                           info <- base::paste(info, collapse = "; ")
[16:20:34.041]                           if (!has_future) {
[16:20:34.041]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:34.041]                               info)
[16:20:34.041]                           }
[16:20:34.041]                           else {
[16:20:34.041]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:34.041]                               info, version)
[16:20:34.041]                           }
[16:20:34.041]                           base::stop(msg)
[16:20:34.041]                         }
[16:20:34.041]                       })
[16:20:34.041]                     }
[16:20:34.041]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:34.041]                     base::options(mc.cores = 1L)
[16:20:34.041]                   }
[16:20:34.041]                   ...future.strategy.old <- future::plan("list")
[16:20:34.041]                   options(future.plan = NULL)
[16:20:34.041]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.041]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:34.041]                 }
[16:20:34.041]                 ...future.workdir <- getwd()
[16:20:34.041]             }
[16:20:34.041]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:34.041]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:34.041]         }
[16:20:34.041]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:34.041]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:34.041]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:34.041]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:34.041]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:34.041]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:34.041]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:34.041]             base::names(...future.oldOptions))
[16:20:34.041]     }
[16:20:34.041]     if (FALSE) {
[16:20:34.041]     }
[16:20:34.041]     else {
[16:20:34.041]         if (TRUE) {
[16:20:34.041]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:34.041]                 open = "w")
[16:20:34.041]         }
[16:20:34.041]         else {
[16:20:34.041]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:34.041]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:34.041]         }
[16:20:34.041]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:34.041]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:34.041]             base::sink(type = "output", split = FALSE)
[16:20:34.041]             base::close(...future.stdout)
[16:20:34.041]         }, add = TRUE)
[16:20:34.041]     }
[16:20:34.041]     ...future.frame <- base::sys.nframe()
[16:20:34.041]     ...future.conditions <- base::list()
[16:20:34.041]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:34.041]     if (FALSE) {
[16:20:34.041]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:34.041]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:34.041]     }
[16:20:34.041]     ...future.result <- base::tryCatch({
[16:20:34.041]         base::withCallingHandlers({
[16:20:34.041]             ...future.value <- base::withVisible(base::local({
[16:20:34.041]                 ...future.makeSendCondition <- base::local({
[16:20:34.041]                   sendCondition <- NULL
[16:20:34.041]                   function(frame = 1L) {
[16:20:34.041]                     if (is.function(sendCondition)) 
[16:20:34.041]                       return(sendCondition)
[16:20:34.041]                     ns <- getNamespace("parallel")
[16:20:34.041]                     if (exists("sendData", mode = "function", 
[16:20:34.041]                       envir = ns)) {
[16:20:34.041]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:34.041]                         envir = ns)
[16:20:34.041]                       envir <- sys.frame(frame)
[16:20:34.041]                       master <- NULL
[16:20:34.041]                       while (!identical(envir, .GlobalEnv) && 
[16:20:34.041]                         !identical(envir, emptyenv())) {
[16:20:34.041]                         if (exists("master", mode = "list", envir = envir, 
[16:20:34.041]                           inherits = FALSE)) {
[16:20:34.041]                           master <- get("master", mode = "list", 
[16:20:34.041]                             envir = envir, inherits = FALSE)
[16:20:34.041]                           if (inherits(master, c("SOCKnode", 
[16:20:34.041]                             "SOCK0node"))) {
[16:20:34.041]                             sendCondition <<- function(cond) {
[16:20:34.041]                               data <- list(type = "VALUE", value = cond, 
[16:20:34.041]                                 success = TRUE)
[16:20:34.041]                               parallel_sendData(master, data)
[16:20:34.041]                             }
[16:20:34.041]                             return(sendCondition)
[16:20:34.041]                           }
[16:20:34.041]                         }
[16:20:34.041]                         frame <- frame + 1L
[16:20:34.041]                         envir <- sys.frame(frame)
[16:20:34.041]                       }
[16:20:34.041]                     }
[16:20:34.041]                     sendCondition <<- function(cond) NULL
[16:20:34.041]                   }
[16:20:34.041]                 })
[16:20:34.041]                 withCallingHandlers({
[16:20:34.041]                   NA
[16:20:34.041]                 }, immediateCondition = function(cond) {
[16:20:34.041]                   sendCondition <- ...future.makeSendCondition()
[16:20:34.041]                   sendCondition(cond)
[16:20:34.041]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.041]                   {
[16:20:34.041]                     inherits <- base::inherits
[16:20:34.041]                     invokeRestart <- base::invokeRestart
[16:20:34.041]                     is.null <- base::is.null
[16:20:34.041]                     muffled <- FALSE
[16:20:34.041]                     if (inherits(cond, "message")) {
[16:20:34.041]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:34.041]                       if (muffled) 
[16:20:34.041]                         invokeRestart("muffleMessage")
[16:20:34.041]                     }
[16:20:34.041]                     else if (inherits(cond, "warning")) {
[16:20:34.041]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:34.041]                       if (muffled) 
[16:20:34.041]                         invokeRestart("muffleWarning")
[16:20:34.041]                     }
[16:20:34.041]                     else if (inherits(cond, "condition")) {
[16:20:34.041]                       if (!is.null(pattern)) {
[16:20:34.041]                         computeRestarts <- base::computeRestarts
[16:20:34.041]                         grepl <- base::grepl
[16:20:34.041]                         restarts <- computeRestarts(cond)
[16:20:34.041]                         for (restart in restarts) {
[16:20:34.041]                           name <- restart$name
[16:20:34.041]                           if (is.null(name)) 
[16:20:34.041]                             next
[16:20:34.041]                           if (!grepl(pattern, name)) 
[16:20:34.041]                             next
[16:20:34.041]                           invokeRestart(restart)
[16:20:34.041]                           muffled <- TRUE
[16:20:34.041]                           break
[16:20:34.041]                         }
[16:20:34.041]                       }
[16:20:34.041]                     }
[16:20:34.041]                     invisible(muffled)
[16:20:34.041]                   }
[16:20:34.041]                   muffleCondition(cond)
[16:20:34.041]                 })
[16:20:34.041]             }))
[16:20:34.041]             future::FutureResult(value = ...future.value$value, 
[16:20:34.041]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.041]                   ...future.rng), globalenv = if (FALSE) 
[16:20:34.041]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:34.041]                     ...future.globalenv.names))
[16:20:34.041]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:34.041]         }, condition = base::local({
[16:20:34.041]             c <- base::c
[16:20:34.041]             inherits <- base::inherits
[16:20:34.041]             invokeRestart <- base::invokeRestart
[16:20:34.041]             length <- base::length
[16:20:34.041]             list <- base::list
[16:20:34.041]             seq.int <- base::seq.int
[16:20:34.041]             signalCondition <- base::signalCondition
[16:20:34.041]             sys.calls <- base::sys.calls
[16:20:34.041]             `[[` <- base::`[[`
[16:20:34.041]             `+` <- base::`+`
[16:20:34.041]             `<<-` <- base::`<<-`
[16:20:34.041]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:34.041]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:34.041]                   3L)]
[16:20:34.041]             }
[16:20:34.041]             function(cond) {
[16:20:34.041]                 is_error <- inherits(cond, "error")
[16:20:34.041]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:34.041]                   NULL)
[16:20:34.041]                 if (is_error) {
[16:20:34.041]                   sessionInformation <- function() {
[16:20:34.041]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:34.041]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:34.041]                       search = base::search(), system = base::Sys.info())
[16:20:34.041]                   }
[16:20:34.041]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.041]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:34.041]                     cond$call), session = sessionInformation(), 
[16:20:34.041]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:34.041]                   signalCondition(cond)
[16:20:34.041]                 }
[16:20:34.041]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:34.041]                 "immediateCondition"))) {
[16:20:34.041]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:34.041]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.041]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:34.041]                   if (TRUE && !signal) {
[16:20:34.041]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.041]                     {
[16:20:34.041]                       inherits <- base::inherits
[16:20:34.041]                       invokeRestart <- base::invokeRestart
[16:20:34.041]                       is.null <- base::is.null
[16:20:34.041]                       muffled <- FALSE
[16:20:34.041]                       if (inherits(cond, "message")) {
[16:20:34.041]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.041]                         if (muffled) 
[16:20:34.041]                           invokeRestart("muffleMessage")
[16:20:34.041]                       }
[16:20:34.041]                       else if (inherits(cond, "warning")) {
[16:20:34.041]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.041]                         if (muffled) 
[16:20:34.041]                           invokeRestart("muffleWarning")
[16:20:34.041]                       }
[16:20:34.041]                       else if (inherits(cond, "condition")) {
[16:20:34.041]                         if (!is.null(pattern)) {
[16:20:34.041]                           computeRestarts <- base::computeRestarts
[16:20:34.041]                           grepl <- base::grepl
[16:20:34.041]                           restarts <- computeRestarts(cond)
[16:20:34.041]                           for (restart in restarts) {
[16:20:34.041]                             name <- restart$name
[16:20:34.041]                             if (is.null(name)) 
[16:20:34.041]                               next
[16:20:34.041]                             if (!grepl(pattern, name)) 
[16:20:34.041]                               next
[16:20:34.041]                             invokeRestart(restart)
[16:20:34.041]                             muffled <- TRUE
[16:20:34.041]                             break
[16:20:34.041]                           }
[16:20:34.041]                         }
[16:20:34.041]                       }
[16:20:34.041]                       invisible(muffled)
[16:20:34.041]                     }
[16:20:34.041]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.041]                   }
[16:20:34.041]                 }
[16:20:34.041]                 else {
[16:20:34.041]                   if (TRUE) {
[16:20:34.041]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.041]                     {
[16:20:34.041]                       inherits <- base::inherits
[16:20:34.041]                       invokeRestart <- base::invokeRestart
[16:20:34.041]                       is.null <- base::is.null
[16:20:34.041]                       muffled <- FALSE
[16:20:34.041]                       if (inherits(cond, "message")) {
[16:20:34.041]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.041]                         if (muffled) 
[16:20:34.041]                           invokeRestart("muffleMessage")
[16:20:34.041]                       }
[16:20:34.041]                       else if (inherits(cond, "warning")) {
[16:20:34.041]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.041]                         if (muffled) 
[16:20:34.041]                           invokeRestart("muffleWarning")
[16:20:34.041]                       }
[16:20:34.041]                       else if (inherits(cond, "condition")) {
[16:20:34.041]                         if (!is.null(pattern)) {
[16:20:34.041]                           computeRestarts <- base::computeRestarts
[16:20:34.041]                           grepl <- base::grepl
[16:20:34.041]                           restarts <- computeRestarts(cond)
[16:20:34.041]                           for (restart in restarts) {
[16:20:34.041]                             name <- restart$name
[16:20:34.041]                             if (is.null(name)) 
[16:20:34.041]                               next
[16:20:34.041]                             if (!grepl(pattern, name)) 
[16:20:34.041]                               next
[16:20:34.041]                             invokeRestart(restart)
[16:20:34.041]                             muffled <- TRUE
[16:20:34.041]                             break
[16:20:34.041]                           }
[16:20:34.041]                         }
[16:20:34.041]                       }
[16:20:34.041]                       invisible(muffled)
[16:20:34.041]                     }
[16:20:34.041]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.041]                   }
[16:20:34.041]                 }
[16:20:34.041]             }
[16:20:34.041]         }))
[16:20:34.041]     }, error = function(ex) {
[16:20:34.041]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:34.041]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.041]                 ...future.rng), started = ...future.startTime, 
[16:20:34.041]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:34.041]             version = "1.8"), class = "FutureResult")
[16:20:34.041]     }, finally = {
[16:20:34.041]         if (!identical(...future.workdir, getwd())) 
[16:20:34.041]             setwd(...future.workdir)
[16:20:34.041]         {
[16:20:34.041]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:34.041]                 ...future.oldOptions$nwarnings <- NULL
[16:20:34.041]             }
[16:20:34.041]             base::options(...future.oldOptions)
[16:20:34.041]             if (.Platform$OS.type == "windows") {
[16:20:34.041]                 old_names <- names(...future.oldEnvVars)
[16:20:34.041]                 envs <- base::Sys.getenv()
[16:20:34.041]                 names <- names(envs)
[16:20:34.041]                 common <- intersect(names, old_names)
[16:20:34.041]                 added <- setdiff(names, old_names)
[16:20:34.041]                 removed <- setdiff(old_names, names)
[16:20:34.041]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:34.041]                   envs[common]]
[16:20:34.041]                 NAMES <- toupper(changed)
[16:20:34.041]                 args <- list()
[16:20:34.041]                 for (kk in seq_along(NAMES)) {
[16:20:34.041]                   name <- changed[[kk]]
[16:20:34.041]                   NAME <- NAMES[[kk]]
[16:20:34.041]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.041]                     next
[16:20:34.041]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.041]                 }
[16:20:34.041]                 NAMES <- toupper(added)
[16:20:34.041]                 for (kk in seq_along(NAMES)) {
[16:20:34.041]                   name <- added[[kk]]
[16:20:34.041]                   NAME <- NAMES[[kk]]
[16:20:34.041]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.041]                     next
[16:20:34.041]                   args[[name]] <- ""
[16:20:34.041]                 }
[16:20:34.041]                 NAMES <- toupper(removed)
[16:20:34.041]                 for (kk in seq_along(NAMES)) {
[16:20:34.041]                   name <- removed[[kk]]
[16:20:34.041]                   NAME <- NAMES[[kk]]
[16:20:34.041]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.041]                     next
[16:20:34.041]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.041]                 }
[16:20:34.041]                 if (length(args) > 0) 
[16:20:34.041]                   base::do.call(base::Sys.setenv, args = args)
[16:20:34.041]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:34.041]             }
[16:20:34.041]             else {
[16:20:34.041]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:34.041]             }
[16:20:34.041]             {
[16:20:34.041]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:34.041]                   0L) {
[16:20:34.041]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:34.041]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:34.041]                   base::options(opts)
[16:20:34.041]                 }
[16:20:34.041]                 {
[16:20:34.041]                   {
[16:20:34.041]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:34.041]                     NULL
[16:20:34.041]                   }
[16:20:34.041]                   options(future.plan = NULL)
[16:20:34.041]                   if (is.na(NA_character_)) 
[16:20:34.041]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.041]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:34.041]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:34.041]                     .init = FALSE)
[16:20:34.041]                 }
[16:20:34.041]             }
[16:20:34.041]         }
[16:20:34.041]     })
[16:20:34.041]     if (TRUE) {
[16:20:34.041]         base::sink(type = "output", split = FALSE)
[16:20:34.041]         if (TRUE) {
[16:20:34.041]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:34.041]         }
[16:20:34.041]         else {
[16:20:34.041]             ...future.result["stdout"] <- base::list(NULL)
[16:20:34.041]         }
[16:20:34.041]         base::close(...future.stdout)
[16:20:34.041]         ...future.stdout <- NULL
[16:20:34.041]     }
[16:20:34.041]     ...future.result$conditions <- ...future.conditions
[16:20:34.041]     ...future.result$finished <- base::Sys.time()
[16:20:34.041]     ...future.result
[16:20:34.041] }
[16:20:34.094] MultisessionFuture started
[16:20:34.095] result() for ClusterFuture ...
[16:20:34.095] receiveMessageFromWorker() for ClusterFuture ...
[16:20:34.095] - Validating connection of MultisessionFuture
[16:20:34.128] - received message: FutureResult
[16:20:34.128] - Received FutureResult
[16:20:34.128] - Erased future from FutureRegistry
[16:20:34.128] result() for ClusterFuture ...
[16:20:34.128] - result already collected: FutureResult
[16:20:34.129] result() for ClusterFuture ... done
[16:20:34.129] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:34.129] result() for ClusterFuture ... done
[16:20:34.129] result() for ClusterFuture ...
[16:20:34.129] - result already collected: FutureResult
[16:20:34.129] result() for ClusterFuture ... done
[16:20:34.129] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:20:34.133] plan(): nbrOfWorkers() = 2
** Future evaluation without globals
[16:20:34.134] getGlobalsAndPackages() ...
[16:20:34.134] Searching for globals...
[16:20:34.135] - globals found: [2] ‘{’, ‘<-’
[16:20:34.135] Searching for globals ... DONE
[16:20:34.136] Resolving globals: FALSE
[16:20:34.136] 
[16:20:34.136] 
[16:20:34.136] getGlobalsAndPackages() ... DONE
[16:20:34.137] run() for ‘Future’ ...
[16:20:34.137] - state: ‘created’
[16:20:34.137] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:34.151] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:34.152] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:34.152]   - Field: ‘node’
[16:20:34.152]   - Field: ‘label’
[16:20:34.152]   - Field: ‘local’
[16:20:34.152]   - Field: ‘owner’
[16:20:34.152]   - Field: ‘envir’
[16:20:34.152]   - Field: ‘workers’
[16:20:34.152]   - Field: ‘packages’
[16:20:34.152]   - Field: ‘gc’
[16:20:34.153]   - Field: ‘conditions’
[16:20:34.153]   - Field: ‘persistent’
[16:20:34.153]   - Field: ‘expr’
[16:20:34.153]   - Field: ‘uuid’
[16:20:34.153]   - Field: ‘seed’
[16:20:34.153]   - Field: ‘version’
[16:20:34.153]   - Field: ‘result’
[16:20:34.153]   - Field: ‘asynchronous’
[16:20:34.153]   - Field: ‘calls’
[16:20:34.154]   - Field: ‘globals’
[16:20:34.154]   - Field: ‘stdout’
[16:20:34.154]   - Field: ‘earlySignal’
[16:20:34.154]   - Field: ‘lazy’
[16:20:34.154]   - Field: ‘state’
[16:20:34.154] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:34.154] - Launch lazy future ...
[16:20:34.155] Packages needed by the future expression (n = 0): <none>
[16:20:34.155] Packages needed by future strategies (n = 0): <none>
[16:20:34.155] {
[16:20:34.155]     {
[16:20:34.155]         {
[16:20:34.155]             ...future.startTime <- base::Sys.time()
[16:20:34.155]             {
[16:20:34.155]                 {
[16:20:34.155]                   {
[16:20:34.155]                     {
[16:20:34.155]                       base::local({
[16:20:34.155]                         has_future <- base::requireNamespace("future", 
[16:20:34.155]                           quietly = TRUE)
[16:20:34.155]                         if (has_future) {
[16:20:34.155]                           ns <- base::getNamespace("future")
[16:20:34.155]                           version <- ns[[".package"]][["version"]]
[16:20:34.155]                           if (is.null(version)) 
[16:20:34.155]                             version <- utils::packageVersion("future")
[16:20:34.155]                         }
[16:20:34.155]                         else {
[16:20:34.155]                           version <- NULL
[16:20:34.155]                         }
[16:20:34.155]                         if (!has_future || version < "1.8.0") {
[16:20:34.155]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:34.155]                             "", base::R.version$version.string), 
[16:20:34.155]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:34.155]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:34.155]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:34.155]                               "release", "version")], collapse = " "), 
[16:20:34.155]                             hostname = base::Sys.info()[["nodename"]])
[16:20:34.155]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:34.155]                             info)
[16:20:34.155]                           info <- base::paste(info, collapse = "; ")
[16:20:34.155]                           if (!has_future) {
[16:20:34.155]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:34.155]                               info)
[16:20:34.155]                           }
[16:20:34.155]                           else {
[16:20:34.155]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:34.155]                               info, version)
[16:20:34.155]                           }
[16:20:34.155]                           base::stop(msg)
[16:20:34.155]                         }
[16:20:34.155]                       })
[16:20:34.155]                     }
[16:20:34.155]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:34.155]                     base::options(mc.cores = 1L)
[16:20:34.155]                   }
[16:20:34.155]                   ...future.strategy.old <- future::plan("list")
[16:20:34.155]                   options(future.plan = NULL)
[16:20:34.155]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.155]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:34.155]                 }
[16:20:34.155]                 ...future.workdir <- getwd()
[16:20:34.155]             }
[16:20:34.155]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:34.155]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:34.155]         }
[16:20:34.155]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:34.155]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:34.155]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:34.155]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:34.155]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:34.155]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:34.155]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:34.155]             base::names(...future.oldOptions))
[16:20:34.155]     }
[16:20:34.155]     if (FALSE) {
[16:20:34.155]     }
[16:20:34.155]     else {
[16:20:34.155]         if (TRUE) {
[16:20:34.155]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:34.155]                 open = "w")
[16:20:34.155]         }
[16:20:34.155]         else {
[16:20:34.155]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:34.155]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:34.155]         }
[16:20:34.155]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:34.155]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:34.155]             base::sink(type = "output", split = FALSE)
[16:20:34.155]             base::close(...future.stdout)
[16:20:34.155]         }, add = TRUE)
[16:20:34.155]     }
[16:20:34.155]     ...future.frame <- base::sys.nframe()
[16:20:34.155]     ...future.conditions <- base::list()
[16:20:34.155]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:34.155]     if (FALSE) {
[16:20:34.155]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:34.155]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:34.155]     }
[16:20:34.155]     ...future.result <- base::tryCatch({
[16:20:34.155]         base::withCallingHandlers({
[16:20:34.155]             ...future.value <- base::withVisible(base::local({
[16:20:34.155]                 ...future.makeSendCondition <- base::local({
[16:20:34.155]                   sendCondition <- NULL
[16:20:34.155]                   function(frame = 1L) {
[16:20:34.155]                     if (is.function(sendCondition)) 
[16:20:34.155]                       return(sendCondition)
[16:20:34.155]                     ns <- getNamespace("parallel")
[16:20:34.155]                     if (exists("sendData", mode = "function", 
[16:20:34.155]                       envir = ns)) {
[16:20:34.155]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:34.155]                         envir = ns)
[16:20:34.155]                       envir <- sys.frame(frame)
[16:20:34.155]                       master <- NULL
[16:20:34.155]                       while (!identical(envir, .GlobalEnv) && 
[16:20:34.155]                         !identical(envir, emptyenv())) {
[16:20:34.155]                         if (exists("master", mode = "list", envir = envir, 
[16:20:34.155]                           inherits = FALSE)) {
[16:20:34.155]                           master <- get("master", mode = "list", 
[16:20:34.155]                             envir = envir, inherits = FALSE)
[16:20:34.155]                           if (inherits(master, c("SOCKnode", 
[16:20:34.155]                             "SOCK0node"))) {
[16:20:34.155]                             sendCondition <<- function(cond) {
[16:20:34.155]                               data <- list(type = "VALUE", value = cond, 
[16:20:34.155]                                 success = TRUE)
[16:20:34.155]                               parallel_sendData(master, data)
[16:20:34.155]                             }
[16:20:34.155]                             return(sendCondition)
[16:20:34.155]                           }
[16:20:34.155]                         }
[16:20:34.155]                         frame <- frame + 1L
[16:20:34.155]                         envir <- sys.frame(frame)
[16:20:34.155]                       }
[16:20:34.155]                     }
[16:20:34.155]                     sendCondition <<- function(cond) NULL
[16:20:34.155]                   }
[16:20:34.155]                 })
[16:20:34.155]                 withCallingHandlers({
[16:20:34.155]                   {
[16:20:34.155]                     x <- 1
[16:20:34.155]                   }
[16:20:34.155]                 }, immediateCondition = function(cond) {
[16:20:34.155]                   sendCondition <- ...future.makeSendCondition()
[16:20:34.155]                   sendCondition(cond)
[16:20:34.155]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.155]                   {
[16:20:34.155]                     inherits <- base::inherits
[16:20:34.155]                     invokeRestart <- base::invokeRestart
[16:20:34.155]                     is.null <- base::is.null
[16:20:34.155]                     muffled <- FALSE
[16:20:34.155]                     if (inherits(cond, "message")) {
[16:20:34.155]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:34.155]                       if (muffled) 
[16:20:34.155]                         invokeRestart("muffleMessage")
[16:20:34.155]                     }
[16:20:34.155]                     else if (inherits(cond, "warning")) {
[16:20:34.155]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:34.155]                       if (muffled) 
[16:20:34.155]                         invokeRestart("muffleWarning")
[16:20:34.155]                     }
[16:20:34.155]                     else if (inherits(cond, "condition")) {
[16:20:34.155]                       if (!is.null(pattern)) {
[16:20:34.155]                         computeRestarts <- base::computeRestarts
[16:20:34.155]                         grepl <- base::grepl
[16:20:34.155]                         restarts <- computeRestarts(cond)
[16:20:34.155]                         for (restart in restarts) {
[16:20:34.155]                           name <- restart$name
[16:20:34.155]                           if (is.null(name)) 
[16:20:34.155]                             next
[16:20:34.155]                           if (!grepl(pattern, name)) 
[16:20:34.155]                             next
[16:20:34.155]                           invokeRestart(restart)
[16:20:34.155]                           muffled <- TRUE
[16:20:34.155]                           break
[16:20:34.155]                         }
[16:20:34.155]                       }
[16:20:34.155]                     }
[16:20:34.155]                     invisible(muffled)
[16:20:34.155]                   }
[16:20:34.155]                   muffleCondition(cond)
[16:20:34.155]                 })
[16:20:34.155]             }))
[16:20:34.155]             future::FutureResult(value = ...future.value$value, 
[16:20:34.155]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.155]                   ...future.rng), globalenv = if (FALSE) 
[16:20:34.155]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:34.155]                     ...future.globalenv.names))
[16:20:34.155]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:34.155]         }, condition = base::local({
[16:20:34.155]             c <- base::c
[16:20:34.155]             inherits <- base::inherits
[16:20:34.155]             invokeRestart <- base::invokeRestart
[16:20:34.155]             length <- base::length
[16:20:34.155]             list <- base::list
[16:20:34.155]             seq.int <- base::seq.int
[16:20:34.155]             signalCondition <- base::signalCondition
[16:20:34.155]             sys.calls <- base::sys.calls
[16:20:34.155]             `[[` <- base::`[[`
[16:20:34.155]             `+` <- base::`+`
[16:20:34.155]             `<<-` <- base::`<<-`
[16:20:34.155]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:34.155]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:34.155]                   3L)]
[16:20:34.155]             }
[16:20:34.155]             function(cond) {
[16:20:34.155]                 is_error <- inherits(cond, "error")
[16:20:34.155]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:34.155]                   NULL)
[16:20:34.155]                 if (is_error) {
[16:20:34.155]                   sessionInformation <- function() {
[16:20:34.155]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:34.155]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:34.155]                       search = base::search(), system = base::Sys.info())
[16:20:34.155]                   }
[16:20:34.155]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.155]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:34.155]                     cond$call), session = sessionInformation(), 
[16:20:34.155]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:34.155]                   signalCondition(cond)
[16:20:34.155]                 }
[16:20:34.155]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:34.155]                 "immediateCondition"))) {
[16:20:34.155]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:34.155]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.155]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:34.155]                   if (TRUE && !signal) {
[16:20:34.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.155]                     {
[16:20:34.155]                       inherits <- base::inherits
[16:20:34.155]                       invokeRestart <- base::invokeRestart
[16:20:34.155]                       is.null <- base::is.null
[16:20:34.155]                       muffled <- FALSE
[16:20:34.155]                       if (inherits(cond, "message")) {
[16:20:34.155]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.155]                         if (muffled) 
[16:20:34.155]                           invokeRestart("muffleMessage")
[16:20:34.155]                       }
[16:20:34.155]                       else if (inherits(cond, "warning")) {
[16:20:34.155]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.155]                         if (muffled) 
[16:20:34.155]                           invokeRestart("muffleWarning")
[16:20:34.155]                       }
[16:20:34.155]                       else if (inherits(cond, "condition")) {
[16:20:34.155]                         if (!is.null(pattern)) {
[16:20:34.155]                           computeRestarts <- base::computeRestarts
[16:20:34.155]                           grepl <- base::grepl
[16:20:34.155]                           restarts <- computeRestarts(cond)
[16:20:34.155]                           for (restart in restarts) {
[16:20:34.155]                             name <- restart$name
[16:20:34.155]                             if (is.null(name)) 
[16:20:34.155]                               next
[16:20:34.155]                             if (!grepl(pattern, name)) 
[16:20:34.155]                               next
[16:20:34.155]                             invokeRestart(restart)
[16:20:34.155]                             muffled <- TRUE
[16:20:34.155]                             break
[16:20:34.155]                           }
[16:20:34.155]                         }
[16:20:34.155]                       }
[16:20:34.155]                       invisible(muffled)
[16:20:34.155]                     }
[16:20:34.155]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.155]                   }
[16:20:34.155]                 }
[16:20:34.155]                 else {
[16:20:34.155]                   if (TRUE) {
[16:20:34.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.155]                     {
[16:20:34.155]                       inherits <- base::inherits
[16:20:34.155]                       invokeRestart <- base::invokeRestart
[16:20:34.155]                       is.null <- base::is.null
[16:20:34.155]                       muffled <- FALSE
[16:20:34.155]                       if (inherits(cond, "message")) {
[16:20:34.155]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.155]                         if (muffled) 
[16:20:34.155]                           invokeRestart("muffleMessage")
[16:20:34.155]                       }
[16:20:34.155]                       else if (inherits(cond, "warning")) {
[16:20:34.155]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.155]                         if (muffled) 
[16:20:34.155]                           invokeRestart("muffleWarning")
[16:20:34.155]                       }
[16:20:34.155]                       else if (inherits(cond, "condition")) {
[16:20:34.155]                         if (!is.null(pattern)) {
[16:20:34.155]                           computeRestarts <- base::computeRestarts
[16:20:34.155]                           grepl <- base::grepl
[16:20:34.155]                           restarts <- computeRestarts(cond)
[16:20:34.155]                           for (restart in restarts) {
[16:20:34.155]                             name <- restart$name
[16:20:34.155]                             if (is.null(name)) 
[16:20:34.155]                               next
[16:20:34.155]                             if (!grepl(pattern, name)) 
[16:20:34.155]                               next
[16:20:34.155]                             invokeRestart(restart)
[16:20:34.155]                             muffled <- TRUE
[16:20:34.155]                             break
[16:20:34.155]                           }
[16:20:34.155]                         }
[16:20:34.155]                       }
[16:20:34.155]                       invisible(muffled)
[16:20:34.155]                     }
[16:20:34.155]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.155]                   }
[16:20:34.155]                 }
[16:20:34.155]             }
[16:20:34.155]         }))
[16:20:34.155]     }, error = function(ex) {
[16:20:34.155]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:34.155]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.155]                 ...future.rng), started = ...future.startTime, 
[16:20:34.155]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:34.155]             version = "1.8"), class = "FutureResult")
[16:20:34.155]     }, finally = {
[16:20:34.155]         if (!identical(...future.workdir, getwd())) 
[16:20:34.155]             setwd(...future.workdir)
[16:20:34.155]         {
[16:20:34.155]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:34.155]                 ...future.oldOptions$nwarnings <- NULL
[16:20:34.155]             }
[16:20:34.155]             base::options(...future.oldOptions)
[16:20:34.155]             if (.Platform$OS.type == "windows") {
[16:20:34.155]                 old_names <- names(...future.oldEnvVars)
[16:20:34.155]                 envs <- base::Sys.getenv()
[16:20:34.155]                 names <- names(envs)
[16:20:34.155]                 common <- intersect(names, old_names)
[16:20:34.155]                 added <- setdiff(names, old_names)
[16:20:34.155]                 removed <- setdiff(old_names, names)
[16:20:34.155]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:34.155]                   envs[common]]
[16:20:34.155]                 NAMES <- toupper(changed)
[16:20:34.155]                 args <- list()
[16:20:34.155]                 for (kk in seq_along(NAMES)) {
[16:20:34.155]                   name <- changed[[kk]]
[16:20:34.155]                   NAME <- NAMES[[kk]]
[16:20:34.155]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.155]                     next
[16:20:34.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.155]                 }
[16:20:34.155]                 NAMES <- toupper(added)
[16:20:34.155]                 for (kk in seq_along(NAMES)) {
[16:20:34.155]                   name <- added[[kk]]
[16:20:34.155]                   NAME <- NAMES[[kk]]
[16:20:34.155]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.155]                     next
[16:20:34.155]                   args[[name]] <- ""
[16:20:34.155]                 }
[16:20:34.155]                 NAMES <- toupper(removed)
[16:20:34.155]                 for (kk in seq_along(NAMES)) {
[16:20:34.155]                   name <- removed[[kk]]
[16:20:34.155]                   NAME <- NAMES[[kk]]
[16:20:34.155]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.155]                     next
[16:20:34.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.155]                 }
[16:20:34.155]                 if (length(args) > 0) 
[16:20:34.155]                   base::do.call(base::Sys.setenv, args = args)
[16:20:34.155]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:34.155]             }
[16:20:34.155]             else {
[16:20:34.155]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:34.155]             }
[16:20:34.155]             {
[16:20:34.155]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:34.155]                   0L) {
[16:20:34.155]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:34.155]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:34.155]                   base::options(opts)
[16:20:34.155]                 }
[16:20:34.155]                 {
[16:20:34.155]                   {
[16:20:34.155]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:34.155]                     NULL
[16:20:34.155]                   }
[16:20:34.155]                   options(future.plan = NULL)
[16:20:34.155]                   if (is.na(NA_character_)) 
[16:20:34.155]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.155]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:34.155]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:34.155]                     .init = FALSE)
[16:20:34.155]                 }
[16:20:34.155]             }
[16:20:34.155]         }
[16:20:34.155]     })
[16:20:34.155]     if (TRUE) {
[16:20:34.155]         base::sink(type = "output", split = FALSE)
[16:20:34.155]         if (TRUE) {
[16:20:34.155]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:34.155]         }
[16:20:34.155]         else {
[16:20:34.155]             ...future.result["stdout"] <- base::list(NULL)
[16:20:34.155]         }
[16:20:34.155]         base::close(...future.stdout)
[16:20:34.155]         ...future.stdout <- NULL
[16:20:34.155]     }
[16:20:34.155]     ...future.result$conditions <- ...future.conditions
[16:20:34.155]     ...future.result$finished <- base::Sys.time()
[16:20:34.155]     ...future.result
[16:20:34.155] }
[16:20:34.159] MultisessionFuture started
[16:20:34.159] - Launch lazy future ... done
[16:20:34.159] run() for ‘MultisessionFuture’ ... done
[16:20:34.159] result() for ClusterFuture ...
[16:20:34.160] receiveMessageFromWorker() for ClusterFuture ...
[16:20:34.160] - Validating connection of MultisessionFuture
[16:20:34.164] - received message: FutureResult
[16:20:34.164] - Received FutureResult
[16:20:34.164] - Erased future from FutureRegistry
[16:20:34.165] result() for ClusterFuture ...
[16:20:34.165] - result already collected: FutureResult
[16:20:34.165] result() for ClusterFuture ... done
[16:20:34.165] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:34.165] result() for ClusterFuture ... done
[16:20:34.165] result() for ClusterFuture ...
[16:20:34.165] - result already collected: FutureResult
[16:20:34.165] result() for ClusterFuture ... done
** Future evaluation with globals
[16:20:34.166] getGlobalsAndPackages() ...
[16:20:34.166] Searching for globals...
[16:20:34.167] - globals found: [3] ‘{’, ‘<-’, ‘a’
[16:20:34.167] Searching for globals ... DONE
[16:20:34.167] Resolving globals: FALSE
[16:20:34.168] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:34.168] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:20:34.168] - globals: [1] ‘a’
[16:20:34.169] 
[16:20:34.169] getGlobalsAndPackages() ... DONE
[16:20:34.169] run() for ‘Future’ ...
[16:20:34.169] - state: ‘created’
[16:20:34.169] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:34.183] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:34.184] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:34.184]   - Field: ‘node’
[16:20:34.184]   - Field: ‘label’
[16:20:34.184]   - Field: ‘local’
[16:20:34.184]   - Field: ‘owner’
[16:20:34.184]   - Field: ‘envir’
[16:20:34.184]   - Field: ‘workers’
[16:20:34.184]   - Field: ‘packages’
[16:20:34.184]   - Field: ‘gc’
[16:20:34.185]   - Field: ‘conditions’
[16:20:34.185]   - Field: ‘persistent’
[16:20:34.185]   - Field: ‘expr’
[16:20:34.185]   - Field: ‘uuid’
[16:20:34.185]   - Field: ‘seed’
[16:20:34.185]   - Field: ‘version’
[16:20:34.185]   - Field: ‘result’
[16:20:34.185]   - Field: ‘asynchronous’
[16:20:34.186]   - Field: ‘calls’
[16:20:34.186]   - Field: ‘globals’
[16:20:34.186]   - Field: ‘stdout’
[16:20:34.186]   - Field: ‘earlySignal’
[16:20:34.186]   - Field: ‘lazy’
[16:20:34.186]   - Field: ‘state’
[16:20:34.186] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:34.186] - Launch lazy future ...
[16:20:34.187] Packages needed by the future expression (n = 0): <none>
[16:20:34.187] Packages needed by future strategies (n = 0): <none>
[16:20:34.187] {
[16:20:34.187]     {
[16:20:34.187]         {
[16:20:34.187]             ...future.startTime <- base::Sys.time()
[16:20:34.187]             {
[16:20:34.187]                 {
[16:20:34.187]                   {
[16:20:34.187]                     {
[16:20:34.187]                       base::local({
[16:20:34.187]                         has_future <- base::requireNamespace("future", 
[16:20:34.187]                           quietly = TRUE)
[16:20:34.187]                         if (has_future) {
[16:20:34.187]                           ns <- base::getNamespace("future")
[16:20:34.187]                           version <- ns[[".package"]][["version"]]
[16:20:34.187]                           if (is.null(version)) 
[16:20:34.187]                             version <- utils::packageVersion("future")
[16:20:34.187]                         }
[16:20:34.187]                         else {
[16:20:34.187]                           version <- NULL
[16:20:34.187]                         }
[16:20:34.187]                         if (!has_future || version < "1.8.0") {
[16:20:34.187]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:34.187]                             "", base::R.version$version.string), 
[16:20:34.187]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:34.187]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:34.187]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:34.187]                               "release", "version")], collapse = " "), 
[16:20:34.187]                             hostname = base::Sys.info()[["nodename"]])
[16:20:34.187]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:34.187]                             info)
[16:20:34.187]                           info <- base::paste(info, collapse = "; ")
[16:20:34.187]                           if (!has_future) {
[16:20:34.187]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:34.187]                               info)
[16:20:34.187]                           }
[16:20:34.187]                           else {
[16:20:34.187]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:34.187]                               info, version)
[16:20:34.187]                           }
[16:20:34.187]                           base::stop(msg)
[16:20:34.187]                         }
[16:20:34.187]                       })
[16:20:34.187]                     }
[16:20:34.187]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:34.187]                     base::options(mc.cores = 1L)
[16:20:34.187]                   }
[16:20:34.187]                   ...future.strategy.old <- future::plan("list")
[16:20:34.187]                   options(future.plan = NULL)
[16:20:34.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:34.187]                 }
[16:20:34.187]                 ...future.workdir <- getwd()
[16:20:34.187]             }
[16:20:34.187]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:34.187]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:34.187]         }
[16:20:34.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:34.187]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:34.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:34.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:34.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:34.187]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:34.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:34.187]             base::names(...future.oldOptions))
[16:20:34.187]     }
[16:20:34.187]     if (FALSE) {
[16:20:34.187]     }
[16:20:34.187]     else {
[16:20:34.187]         if (TRUE) {
[16:20:34.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:34.187]                 open = "w")
[16:20:34.187]         }
[16:20:34.187]         else {
[16:20:34.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:34.187]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:34.187]         }
[16:20:34.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:34.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:34.187]             base::sink(type = "output", split = FALSE)
[16:20:34.187]             base::close(...future.stdout)
[16:20:34.187]         }, add = TRUE)
[16:20:34.187]     }
[16:20:34.187]     ...future.frame <- base::sys.nframe()
[16:20:34.187]     ...future.conditions <- base::list()
[16:20:34.187]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:34.187]     if (FALSE) {
[16:20:34.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:34.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:34.187]     }
[16:20:34.187]     ...future.result <- base::tryCatch({
[16:20:34.187]         base::withCallingHandlers({
[16:20:34.187]             ...future.value <- base::withVisible(base::local({
[16:20:34.187]                 ...future.makeSendCondition <- base::local({
[16:20:34.187]                   sendCondition <- NULL
[16:20:34.187]                   function(frame = 1L) {
[16:20:34.187]                     if (is.function(sendCondition)) 
[16:20:34.187]                       return(sendCondition)
[16:20:34.187]                     ns <- getNamespace("parallel")
[16:20:34.187]                     if (exists("sendData", mode = "function", 
[16:20:34.187]                       envir = ns)) {
[16:20:34.187]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:34.187]                         envir = ns)
[16:20:34.187]                       envir <- sys.frame(frame)
[16:20:34.187]                       master <- NULL
[16:20:34.187]                       while (!identical(envir, .GlobalEnv) && 
[16:20:34.187]                         !identical(envir, emptyenv())) {
[16:20:34.187]                         if (exists("master", mode = "list", envir = envir, 
[16:20:34.187]                           inherits = FALSE)) {
[16:20:34.187]                           master <- get("master", mode = "list", 
[16:20:34.187]                             envir = envir, inherits = FALSE)
[16:20:34.187]                           if (inherits(master, c("SOCKnode", 
[16:20:34.187]                             "SOCK0node"))) {
[16:20:34.187]                             sendCondition <<- function(cond) {
[16:20:34.187]                               data <- list(type = "VALUE", value = cond, 
[16:20:34.187]                                 success = TRUE)
[16:20:34.187]                               parallel_sendData(master, data)
[16:20:34.187]                             }
[16:20:34.187]                             return(sendCondition)
[16:20:34.187]                           }
[16:20:34.187]                         }
[16:20:34.187]                         frame <- frame + 1L
[16:20:34.187]                         envir <- sys.frame(frame)
[16:20:34.187]                       }
[16:20:34.187]                     }
[16:20:34.187]                     sendCondition <<- function(cond) NULL
[16:20:34.187]                   }
[16:20:34.187]                 })
[16:20:34.187]                 withCallingHandlers({
[16:20:34.187]                   {
[16:20:34.187]                     x <- a
[16:20:34.187]                   }
[16:20:34.187]                 }, immediateCondition = function(cond) {
[16:20:34.187]                   sendCondition <- ...future.makeSendCondition()
[16:20:34.187]                   sendCondition(cond)
[16:20:34.187]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.187]                   {
[16:20:34.187]                     inherits <- base::inherits
[16:20:34.187]                     invokeRestart <- base::invokeRestart
[16:20:34.187]                     is.null <- base::is.null
[16:20:34.187]                     muffled <- FALSE
[16:20:34.187]                     if (inherits(cond, "message")) {
[16:20:34.187]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:34.187]                       if (muffled) 
[16:20:34.187]                         invokeRestart("muffleMessage")
[16:20:34.187]                     }
[16:20:34.187]                     else if (inherits(cond, "warning")) {
[16:20:34.187]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:34.187]                       if (muffled) 
[16:20:34.187]                         invokeRestart("muffleWarning")
[16:20:34.187]                     }
[16:20:34.187]                     else if (inherits(cond, "condition")) {
[16:20:34.187]                       if (!is.null(pattern)) {
[16:20:34.187]                         computeRestarts <- base::computeRestarts
[16:20:34.187]                         grepl <- base::grepl
[16:20:34.187]                         restarts <- computeRestarts(cond)
[16:20:34.187]                         for (restart in restarts) {
[16:20:34.187]                           name <- restart$name
[16:20:34.187]                           if (is.null(name)) 
[16:20:34.187]                             next
[16:20:34.187]                           if (!grepl(pattern, name)) 
[16:20:34.187]                             next
[16:20:34.187]                           invokeRestart(restart)
[16:20:34.187]                           muffled <- TRUE
[16:20:34.187]                           break
[16:20:34.187]                         }
[16:20:34.187]                       }
[16:20:34.187]                     }
[16:20:34.187]                     invisible(muffled)
[16:20:34.187]                   }
[16:20:34.187]                   muffleCondition(cond)
[16:20:34.187]                 })
[16:20:34.187]             }))
[16:20:34.187]             future::FutureResult(value = ...future.value$value, 
[16:20:34.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.187]                   ...future.rng), globalenv = if (FALSE) 
[16:20:34.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:34.187]                     ...future.globalenv.names))
[16:20:34.187]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:34.187]         }, condition = base::local({
[16:20:34.187]             c <- base::c
[16:20:34.187]             inherits <- base::inherits
[16:20:34.187]             invokeRestart <- base::invokeRestart
[16:20:34.187]             length <- base::length
[16:20:34.187]             list <- base::list
[16:20:34.187]             seq.int <- base::seq.int
[16:20:34.187]             signalCondition <- base::signalCondition
[16:20:34.187]             sys.calls <- base::sys.calls
[16:20:34.187]             `[[` <- base::`[[`
[16:20:34.187]             `+` <- base::`+`
[16:20:34.187]             `<<-` <- base::`<<-`
[16:20:34.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:34.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:34.187]                   3L)]
[16:20:34.187]             }
[16:20:34.187]             function(cond) {
[16:20:34.187]                 is_error <- inherits(cond, "error")
[16:20:34.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:34.187]                   NULL)
[16:20:34.187]                 if (is_error) {
[16:20:34.187]                   sessionInformation <- function() {
[16:20:34.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:34.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:34.187]                       search = base::search(), system = base::Sys.info())
[16:20:34.187]                   }
[16:20:34.187]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:34.187]                     cond$call), session = sessionInformation(), 
[16:20:34.187]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:34.187]                   signalCondition(cond)
[16:20:34.187]                 }
[16:20:34.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:34.187]                 "immediateCondition"))) {
[16:20:34.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:34.187]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:34.187]                   if (TRUE && !signal) {
[16:20:34.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.187]                     {
[16:20:34.187]                       inherits <- base::inherits
[16:20:34.187]                       invokeRestart <- base::invokeRestart
[16:20:34.187]                       is.null <- base::is.null
[16:20:34.187]                       muffled <- FALSE
[16:20:34.187]                       if (inherits(cond, "message")) {
[16:20:34.187]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.187]                         if (muffled) 
[16:20:34.187]                           invokeRestart("muffleMessage")
[16:20:34.187]                       }
[16:20:34.187]                       else if (inherits(cond, "warning")) {
[16:20:34.187]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.187]                         if (muffled) 
[16:20:34.187]                           invokeRestart("muffleWarning")
[16:20:34.187]                       }
[16:20:34.187]                       else if (inherits(cond, "condition")) {
[16:20:34.187]                         if (!is.null(pattern)) {
[16:20:34.187]                           computeRestarts <- base::computeRestarts
[16:20:34.187]                           grepl <- base::grepl
[16:20:34.187]                           restarts <- computeRestarts(cond)
[16:20:34.187]                           for (restart in restarts) {
[16:20:34.187]                             name <- restart$name
[16:20:34.187]                             if (is.null(name)) 
[16:20:34.187]                               next
[16:20:34.187]                             if (!grepl(pattern, name)) 
[16:20:34.187]                               next
[16:20:34.187]                             invokeRestart(restart)
[16:20:34.187]                             muffled <- TRUE
[16:20:34.187]                             break
[16:20:34.187]                           }
[16:20:34.187]                         }
[16:20:34.187]                       }
[16:20:34.187]                       invisible(muffled)
[16:20:34.187]                     }
[16:20:34.187]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.187]                   }
[16:20:34.187]                 }
[16:20:34.187]                 else {
[16:20:34.187]                   if (TRUE) {
[16:20:34.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.187]                     {
[16:20:34.187]                       inherits <- base::inherits
[16:20:34.187]                       invokeRestart <- base::invokeRestart
[16:20:34.187]                       is.null <- base::is.null
[16:20:34.187]                       muffled <- FALSE
[16:20:34.187]                       if (inherits(cond, "message")) {
[16:20:34.187]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.187]                         if (muffled) 
[16:20:34.187]                           invokeRestart("muffleMessage")
[16:20:34.187]                       }
[16:20:34.187]                       else if (inherits(cond, "warning")) {
[16:20:34.187]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.187]                         if (muffled) 
[16:20:34.187]                           invokeRestart("muffleWarning")
[16:20:34.187]                       }
[16:20:34.187]                       else if (inherits(cond, "condition")) {
[16:20:34.187]                         if (!is.null(pattern)) {
[16:20:34.187]                           computeRestarts <- base::computeRestarts
[16:20:34.187]                           grepl <- base::grepl
[16:20:34.187]                           restarts <- computeRestarts(cond)
[16:20:34.187]                           for (restart in restarts) {
[16:20:34.187]                             name <- restart$name
[16:20:34.187]                             if (is.null(name)) 
[16:20:34.187]                               next
[16:20:34.187]                             if (!grepl(pattern, name)) 
[16:20:34.187]                               next
[16:20:34.187]                             invokeRestart(restart)
[16:20:34.187]                             muffled <- TRUE
[16:20:34.187]                             break
[16:20:34.187]                           }
[16:20:34.187]                         }
[16:20:34.187]                       }
[16:20:34.187]                       invisible(muffled)
[16:20:34.187]                     }
[16:20:34.187]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.187]                   }
[16:20:34.187]                 }
[16:20:34.187]             }
[16:20:34.187]         }))
[16:20:34.187]     }, error = function(ex) {
[16:20:34.187]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:34.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.187]                 ...future.rng), started = ...future.startTime, 
[16:20:34.187]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:34.187]             version = "1.8"), class = "FutureResult")
[16:20:34.187]     }, finally = {
[16:20:34.187]         if (!identical(...future.workdir, getwd())) 
[16:20:34.187]             setwd(...future.workdir)
[16:20:34.187]         {
[16:20:34.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:34.187]                 ...future.oldOptions$nwarnings <- NULL
[16:20:34.187]             }
[16:20:34.187]             base::options(...future.oldOptions)
[16:20:34.187]             if (.Platform$OS.type == "windows") {
[16:20:34.187]                 old_names <- names(...future.oldEnvVars)
[16:20:34.187]                 envs <- base::Sys.getenv()
[16:20:34.187]                 names <- names(envs)
[16:20:34.187]                 common <- intersect(names, old_names)
[16:20:34.187]                 added <- setdiff(names, old_names)
[16:20:34.187]                 removed <- setdiff(old_names, names)
[16:20:34.187]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:34.187]                   envs[common]]
[16:20:34.187]                 NAMES <- toupper(changed)
[16:20:34.187]                 args <- list()
[16:20:34.187]                 for (kk in seq_along(NAMES)) {
[16:20:34.187]                   name <- changed[[kk]]
[16:20:34.187]                   NAME <- NAMES[[kk]]
[16:20:34.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.187]                     next
[16:20:34.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.187]                 }
[16:20:34.187]                 NAMES <- toupper(added)
[16:20:34.187]                 for (kk in seq_along(NAMES)) {
[16:20:34.187]                   name <- added[[kk]]
[16:20:34.187]                   NAME <- NAMES[[kk]]
[16:20:34.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.187]                     next
[16:20:34.187]                   args[[name]] <- ""
[16:20:34.187]                 }
[16:20:34.187]                 NAMES <- toupper(removed)
[16:20:34.187]                 for (kk in seq_along(NAMES)) {
[16:20:34.187]                   name <- removed[[kk]]
[16:20:34.187]                   NAME <- NAMES[[kk]]
[16:20:34.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.187]                     next
[16:20:34.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.187]                 }
[16:20:34.187]                 if (length(args) > 0) 
[16:20:34.187]                   base::do.call(base::Sys.setenv, args = args)
[16:20:34.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:34.187]             }
[16:20:34.187]             else {
[16:20:34.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:34.187]             }
[16:20:34.187]             {
[16:20:34.187]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:34.187]                   0L) {
[16:20:34.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:34.187]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:34.187]                   base::options(opts)
[16:20:34.187]                 }
[16:20:34.187]                 {
[16:20:34.187]                   {
[16:20:34.187]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:34.187]                     NULL
[16:20:34.187]                   }
[16:20:34.187]                   options(future.plan = NULL)
[16:20:34.187]                   if (is.na(NA_character_)) 
[16:20:34.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:34.187]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:34.187]                     .init = FALSE)
[16:20:34.187]                 }
[16:20:34.187]             }
[16:20:34.187]         }
[16:20:34.187]     })
[16:20:34.187]     if (TRUE) {
[16:20:34.187]         base::sink(type = "output", split = FALSE)
[16:20:34.187]         if (TRUE) {
[16:20:34.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:34.187]         }
[16:20:34.187]         else {
[16:20:34.187]             ...future.result["stdout"] <- base::list(NULL)
[16:20:34.187]         }
[16:20:34.187]         base::close(...future.stdout)
[16:20:34.187]         ...future.stdout <- NULL
[16:20:34.187]     }
[16:20:34.187]     ...future.result$conditions <- ...future.conditions
[16:20:34.187]     ...future.result$finished <- base::Sys.time()
[16:20:34.187]     ...future.result
[16:20:34.187] }
[16:20:34.190] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:20:34.190] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:20:34.191] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:20:34.191] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:20:34.192] MultisessionFuture started
[16:20:34.192] - Launch lazy future ... done
[16:20:34.192] run() for ‘MultisessionFuture’ ... done
[16:20:34.192] result() for ClusterFuture ...
[16:20:34.192] receiveMessageFromWorker() for ClusterFuture ...
[16:20:34.193] - Validating connection of MultisessionFuture
[16:20:34.194] - received message: FutureResult
[16:20:34.194] - Received FutureResult
[16:20:34.194] - Erased future from FutureRegistry
[16:20:34.194] result() for ClusterFuture ...
[16:20:34.194] - result already collected: FutureResult
[16:20:34.194] result() for ClusterFuture ... done
[16:20:34.194] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:34.194] result() for ClusterFuture ... done
[16:20:34.195] result() for ClusterFuture ...
[16:20:34.195] - result already collected: FutureResult
[16:20:34.195] result() for ClusterFuture ... done
** Future evaluation with errors
[16:20:34.195] getGlobalsAndPackages() ...
[16:20:34.195] Searching for globals...
[16:20:34.197] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[16:20:34.197] Searching for globals ... DONE
[16:20:34.197] Resolving globals: FALSE
[16:20:34.198] 
[16:20:34.198] 
[16:20:34.198] getGlobalsAndPackages() ... DONE
[16:20:34.198] run() for ‘Future’ ...
[16:20:34.198] - state: ‘created’
[16:20:34.199] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:34.213] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:34.213] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:34.213]   - Field: ‘node’
[16:20:34.213]   - Field: ‘label’
[16:20:34.213]   - Field: ‘local’
[16:20:34.213]   - Field: ‘owner’
[16:20:34.213]   - Field: ‘envir’
[16:20:34.214]   - Field: ‘workers’
[16:20:34.214]   - Field: ‘packages’
[16:20:34.214]   - Field: ‘gc’
[16:20:34.214]   - Field: ‘conditions’
[16:20:34.214]   - Field: ‘persistent’
[16:20:34.214]   - Field: ‘expr’
[16:20:34.214]   - Field: ‘uuid’
[16:20:34.214]   - Field: ‘seed’
[16:20:34.214]   - Field: ‘version’
[16:20:34.215]   - Field: ‘result’
[16:20:34.215]   - Field: ‘asynchronous’
[16:20:34.215]   - Field: ‘calls’
[16:20:34.215]   - Field: ‘globals’
[16:20:34.215]   - Field: ‘stdout’
[16:20:34.215]   - Field: ‘earlySignal’
[16:20:34.215]   - Field: ‘lazy’
[16:20:34.215]   - Field: ‘state’
[16:20:34.215] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:34.216] - Launch lazy future ...
[16:20:34.216] Packages needed by the future expression (n = 0): <none>
[16:20:34.216] Packages needed by future strategies (n = 0): <none>
[16:20:34.217] {
[16:20:34.217]     {
[16:20:34.217]         {
[16:20:34.217]             ...future.startTime <- base::Sys.time()
[16:20:34.217]             {
[16:20:34.217]                 {
[16:20:34.217]                   {
[16:20:34.217]                     {
[16:20:34.217]                       base::local({
[16:20:34.217]                         has_future <- base::requireNamespace("future", 
[16:20:34.217]                           quietly = TRUE)
[16:20:34.217]                         if (has_future) {
[16:20:34.217]                           ns <- base::getNamespace("future")
[16:20:34.217]                           version <- ns[[".package"]][["version"]]
[16:20:34.217]                           if (is.null(version)) 
[16:20:34.217]                             version <- utils::packageVersion("future")
[16:20:34.217]                         }
[16:20:34.217]                         else {
[16:20:34.217]                           version <- NULL
[16:20:34.217]                         }
[16:20:34.217]                         if (!has_future || version < "1.8.0") {
[16:20:34.217]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:34.217]                             "", base::R.version$version.string), 
[16:20:34.217]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:34.217]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:34.217]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:34.217]                               "release", "version")], collapse = " "), 
[16:20:34.217]                             hostname = base::Sys.info()[["nodename"]])
[16:20:34.217]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:34.217]                             info)
[16:20:34.217]                           info <- base::paste(info, collapse = "; ")
[16:20:34.217]                           if (!has_future) {
[16:20:34.217]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:34.217]                               info)
[16:20:34.217]                           }
[16:20:34.217]                           else {
[16:20:34.217]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:34.217]                               info, version)
[16:20:34.217]                           }
[16:20:34.217]                           base::stop(msg)
[16:20:34.217]                         }
[16:20:34.217]                       })
[16:20:34.217]                     }
[16:20:34.217]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:34.217]                     base::options(mc.cores = 1L)
[16:20:34.217]                   }
[16:20:34.217]                   ...future.strategy.old <- future::plan("list")
[16:20:34.217]                   options(future.plan = NULL)
[16:20:34.217]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.217]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:34.217]                 }
[16:20:34.217]                 ...future.workdir <- getwd()
[16:20:34.217]             }
[16:20:34.217]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:34.217]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:34.217]         }
[16:20:34.217]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:34.217]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:34.217]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:34.217]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:34.217]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:34.217]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:34.217]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:34.217]             base::names(...future.oldOptions))
[16:20:34.217]     }
[16:20:34.217]     if (FALSE) {
[16:20:34.217]     }
[16:20:34.217]     else {
[16:20:34.217]         if (TRUE) {
[16:20:34.217]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:34.217]                 open = "w")
[16:20:34.217]         }
[16:20:34.217]         else {
[16:20:34.217]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:34.217]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:34.217]         }
[16:20:34.217]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:34.217]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:34.217]             base::sink(type = "output", split = FALSE)
[16:20:34.217]             base::close(...future.stdout)
[16:20:34.217]         }, add = TRUE)
[16:20:34.217]     }
[16:20:34.217]     ...future.frame <- base::sys.nframe()
[16:20:34.217]     ...future.conditions <- base::list()
[16:20:34.217]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:34.217]     if (FALSE) {
[16:20:34.217]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:34.217]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:34.217]     }
[16:20:34.217]     ...future.result <- base::tryCatch({
[16:20:34.217]         base::withCallingHandlers({
[16:20:34.217]             ...future.value <- base::withVisible(base::local({
[16:20:34.217]                 ...future.makeSendCondition <- base::local({
[16:20:34.217]                   sendCondition <- NULL
[16:20:34.217]                   function(frame = 1L) {
[16:20:34.217]                     if (is.function(sendCondition)) 
[16:20:34.217]                       return(sendCondition)
[16:20:34.217]                     ns <- getNamespace("parallel")
[16:20:34.217]                     if (exists("sendData", mode = "function", 
[16:20:34.217]                       envir = ns)) {
[16:20:34.217]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:34.217]                         envir = ns)
[16:20:34.217]                       envir <- sys.frame(frame)
[16:20:34.217]                       master <- NULL
[16:20:34.217]                       while (!identical(envir, .GlobalEnv) && 
[16:20:34.217]                         !identical(envir, emptyenv())) {
[16:20:34.217]                         if (exists("master", mode = "list", envir = envir, 
[16:20:34.217]                           inherits = FALSE)) {
[16:20:34.217]                           master <- get("master", mode = "list", 
[16:20:34.217]                             envir = envir, inherits = FALSE)
[16:20:34.217]                           if (inherits(master, c("SOCKnode", 
[16:20:34.217]                             "SOCK0node"))) {
[16:20:34.217]                             sendCondition <<- function(cond) {
[16:20:34.217]                               data <- list(type = "VALUE", value = cond, 
[16:20:34.217]                                 success = TRUE)
[16:20:34.217]                               parallel_sendData(master, data)
[16:20:34.217]                             }
[16:20:34.217]                             return(sendCondition)
[16:20:34.217]                           }
[16:20:34.217]                         }
[16:20:34.217]                         frame <- frame + 1L
[16:20:34.217]                         envir <- sys.frame(frame)
[16:20:34.217]                       }
[16:20:34.217]                     }
[16:20:34.217]                     sendCondition <<- function(cond) NULL
[16:20:34.217]                   }
[16:20:34.217]                 })
[16:20:34.217]                 withCallingHandlers({
[16:20:34.217]                   {
[16:20:34.217]                     x <- 3
[16:20:34.217]                     stop("Woops!")
[16:20:34.217]                     x
[16:20:34.217]                   }
[16:20:34.217]                 }, immediateCondition = function(cond) {
[16:20:34.217]                   sendCondition <- ...future.makeSendCondition()
[16:20:34.217]                   sendCondition(cond)
[16:20:34.217]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.217]                   {
[16:20:34.217]                     inherits <- base::inherits
[16:20:34.217]                     invokeRestart <- base::invokeRestart
[16:20:34.217]                     is.null <- base::is.null
[16:20:34.217]                     muffled <- FALSE
[16:20:34.217]                     if (inherits(cond, "message")) {
[16:20:34.217]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:34.217]                       if (muffled) 
[16:20:34.217]                         invokeRestart("muffleMessage")
[16:20:34.217]                     }
[16:20:34.217]                     else if (inherits(cond, "warning")) {
[16:20:34.217]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:34.217]                       if (muffled) 
[16:20:34.217]                         invokeRestart("muffleWarning")
[16:20:34.217]                     }
[16:20:34.217]                     else if (inherits(cond, "condition")) {
[16:20:34.217]                       if (!is.null(pattern)) {
[16:20:34.217]                         computeRestarts <- base::computeRestarts
[16:20:34.217]                         grepl <- base::grepl
[16:20:34.217]                         restarts <- computeRestarts(cond)
[16:20:34.217]                         for (restart in restarts) {
[16:20:34.217]                           name <- restart$name
[16:20:34.217]                           if (is.null(name)) 
[16:20:34.217]                             next
[16:20:34.217]                           if (!grepl(pattern, name)) 
[16:20:34.217]                             next
[16:20:34.217]                           invokeRestart(restart)
[16:20:34.217]                           muffled <- TRUE
[16:20:34.217]                           break
[16:20:34.217]                         }
[16:20:34.217]                       }
[16:20:34.217]                     }
[16:20:34.217]                     invisible(muffled)
[16:20:34.217]                   }
[16:20:34.217]                   muffleCondition(cond)
[16:20:34.217]                 })
[16:20:34.217]             }))
[16:20:34.217]             future::FutureResult(value = ...future.value$value, 
[16:20:34.217]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.217]                   ...future.rng), globalenv = if (FALSE) 
[16:20:34.217]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:34.217]                     ...future.globalenv.names))
[16:20:34.217]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:34.217]         }, condition = base::local({
[16:20:34.217]             c <- base::c
[16:20:34.217]             inherits <- base::inherits
[16:20:34.217]             invokeRestart <- base::invokeRestart
[16:20:34.217]             length <- base::length
[16:20:34.217]             list <- base::list
[16:20:34.217]             seq.int <- base::seq.int
[16:20:34.217]             signalCondition <- base::signalCondition
[16:20:34.217]             sys.calls <- base::sys.calls
[16:20:34.217]             `[[` <- base::`[[`
[16:20:34.217]             `+` <- base::`+`
[16:20:34.217]             `<<-` <- base::`<<-`
[16:20:34.217]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:34.217]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:34.217]                   3L)]
[16:20:34.217]             }
[16:20:34.217]             function(cond) {
[16:20:34.217]                 is_error <- inherits(cond, "error")
[16:20:34.217]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:34.217]                   NULL)
[16:20:34.217]                 if (is_error) {
[16:20:34.217]                   sessionInformation <- function() {
[16:20:34.217]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:34.217]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:34.217]                       search = base::search(), system = base::Sys.info())
[16:20:34.217]                   }
[16:20:34.217]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.217]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:34.217]                     cond$call), session = sessionInformation(), 
[16:20:34.217]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:34.217]                   signalCondition(cond)
[16:20:34.217]                 }
[16:20:34.217]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:34.217]                 "immediateCondition"))) {
[16:20:34.217]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:34.217]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.217]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:34.217]                   if (TRUE && !signal) {
[16:20:34.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.217]                     {
[16:20:34.217]                       inherits <- base::inherits
[16:20:34.217]                       invokeRestart <- base::invokeRestart
[16:20:34.217]                       is.null <- base::is.null
[16:20:34.217]                       muffled <- FALSE
[16:20:34.217]                       if (inherits(cond, "message")) {
[16:20:34.217]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.217]                         if (muffled) 
[16:20:34.217]                           invokeRestart("muffleMessage")
[16:20:34.217]                       }
[16:20:34.217]                       else if (inherits(cond, "warning")) {
[16:20:34.217]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.217]                         if (muffled) 
[16:20:34.217]                           invokeRestart("muffleWarning")
[16:20:34.217]                       }
[16:20:34.217]                       else if (inherits(cond, "condition")) {
[16:20:34.217]                         if (!is.null(pattern)) {
[16:20:34.217]                           computeRestarts <- base::computeRestarts
[16:20:34.217]                           grepl <- base::grepl
[16:20:34.217]                           restarts <- computeRestarts(cond)
[16:20:34.217]                           for (restart in restarts) {
[16:20:34.217]                             name <- restart$name
[16:20:34.217]                             if (is.null(name)) 
[16:20:34.217]                               next
[16:20:34.217]                             if (!grepl(pattern, name)) 
[16:20:34.217]                               next
[16:20:34.217]                             invokeRestart(restart)
[16:20:34.217]                             muffled <- TRUE
[16:20:34.217]                             break
[16:20:34.217]                           }
[16:20:34.217]                         }
[16:20:34.217]                       }
[16:20:34.217]                       invisible(muffled)
[16:20:34.217]                     }
[16:20:34.217]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.217]                   }
[16:20:34.217]                 }
[16:20:34.217]                 else {
[16:20:34.217]                   if (TRUE) {
[16:20:34.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.217]                     {
[16:20:34.217]                       inherits <- base::inherits
[16:20:34.217]                       invokeRestart <- base::invokeRestart
[16:20:34.217]                       is.null <- base::is.null
[16:20:34.217]                       muffled <- FALSE
[16:20:34.217]                       if (inherits(cond, "message")) {
[16:20:34.217]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.217]                         if (muffled) 
[16:20:34.217]                           invokeRestart("muffleMessage")
[16:20:34.217]                       }
[16:20:34.217]                       else if (inherits(cond, "warning")) {
[16:20:34.217]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.217]                         if (muffled) 
[16:20:34.217]                           invokeRestart("muffleWarning")
[16:20:34.217]                       }
[16:20:34.217]                       else if (inherits(cond, "condition")) {
[16:20:34.217]                         if (!is.null(pattern)) {
[16:20:34.217]                           computeRestarts <- base::computeRestarts
[16:20:34.217]                           grepl <- base::grepl
[16:20:34.217]                           restarts <- computeRestarts(cond)
[16:20:34.217]                           for (restart in restarts) {
[16:20:34.217]                             name <- restart$name
[16:20:34.217]                             if (is.null(name)) 
[16:20:34.217]                               next
[16:20:34.217]                             if (!grepl(pattern, name)) 
[16:20:34.217]                               next
[16:20:34.217]                             invokeRestart(restart)
[16:20:34.217]                             muffled <- TRUE
[16:20:34.217]                             break
[16:20:34.217]                           }
[16:20:34.217]                         }
[16:20:34.217]                       }
[16:20:34.217]                       invisible(muffled)
[16:20:34.217]                     }
[16:20:34.217]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.217]                   }
[16:20:34.217]                 }
[16:20:34.217]             }
[16:20:34.217]         }))
[16:20:34.217]     }, error = function(ex) {
[16:20:34.217]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:34.217]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.217]                 ...future.rng), started = ...future.startTime, 
[16:20:34.217]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:34.217]             version = "1.8"), class = "FutureResult")
[16:20:34.217]     }, finally = {
[16:20:34.217]         if (!identical(...future.workdir, getwd())) 
[16:20:34.217]             setwd(...future.workdir)
[16:20:34.217]         {
[16:20:34.217]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:34.217]                 ...future.oldOptions$nwarnings <- NULL
[16:20:34.217]             }
[16:20:34.217]             base::options(...future.oldOptions)
[16:20:34.217]             if (.Platform$OS.type == "windows") {
[16:20:34.217]                 old_names <- names(...future.oldEnvVars)
[16:20:34.217]                 envs <- base::Sys.getenv()
[16:20:34.217]                 names <- names(envs)
[16:20:34.217]                 common <- intersect(names, old_names)
[16:20:34.217]                 added <- setdiff(names, old_names)
[16:20:34.217]                 removed <- setdiff(old_names, names)
[16:20:34.217]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:34.217]                   envs[common]]
[16:20:34.217]                 NAMES <- toupper(changed)
[16:20:34.217]                 args <- list()
[16:20:34.217]                 for (kk in seq_along(NAMES)) {
[16:20:34.217]                   name <- changed[[kk]]
[16:20:34.217]                   NAME <- NAMES[[kk]]
[16:20:34.217]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.217]                     next
[16:20:34.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.217]                 }
[16:20:34.217]                 NAMES <- toupper(added)
[16:20:34.217]                 for (kk in seq_along(NAMES)) {
[16:20:34.217]                   name <- added[[kk]]
[16:20:34.217]                   NAME <- NAMES[[kk]]
[16:20:34.217]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.217]                     next
[16:20:34.217]                   args[[name]] <- ""
[16:20:34.217]                 }
[16:20:34.217]                 NAMES <- toupper(removed)
[16:20:34.217]                 for (kk in seq_along(NAMES)) {
[16:20:34.217]                   name <- removed[[kk]]
[16:20:34.217]                   NAME <- NAMES[[kk]]
[16:20:34.217]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.217]                     next
[16:20:34.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.217]                 }
[16:20:34.217]                 if (length(args) > 0) 
[16:20:34.217]                   base::do.call(base::Sys.setenv, args = args)
[16:20:34.217]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:34.217]             }
[16:20:34.217]             else {
[16:20:34.217]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:34.217]             }
[16:20:34.217]             {
[16:20:34.217]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:34.217]                   0L) {
[16:20:34.217]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:34.217]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:34.217]                   base::options(opts)
[16:20:34.217]                 }
[16:20:34.217]                 {
[16:20:34.217]                   {
[16:20:34.217]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:34.217]                     NULL
[16:20:34.217]                   }
[16:20:34.217]                   options(future.plan = NULL)
[16:20:34.217]                   if (is.na(NA_character_)) 
[16:20:34.217]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.217]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:34.217]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:34.217]                     .init = FALSE)
[16:20:34.217]                 }
[16:20:34.217]             }
[16:20:34.217]         }
[16:20:34.217]     })
[16:20:34.217]     if (TRUE) {
[16:20:34.217]         base::sink(type = "output", split = FALSE)
[16:20:34.217]         if (TRUE) {
[16:20:34.217]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:34.217]         }
[16:20:34.217]         else {
[16:20:34.217]             ...future.result["stdout"] <- base::list(NULL)
[16:20:34.217]         }
[16:20:34.217]         base::close(...future.stdout)
[16:20:34.217]         ...future.stdout <- NULL
[16:20:34.217]     }
[16:20:34.217]     ...future.result$conditions <- ...future.conditions
[16:20:34.217]     ...future.result$finished <- base::Sys.time()
[16:20:34.217]     ...future.result
[16:20:34.217] }
[16:20:34.220] MultisessionFuture started
[16:20:34.220] - Launch lazy future ... done
[16:20:34.220] run() for ‘MultisessionFuture’ ... done
[16:20:34.221] result() for ClusterFuture ...
[16:20:34.221] receiveMessageFromWorker() for ClusterFuture ...
[16:20:34.221] - Validating connection of MultisessionFuture
[16:20:34.223] - received message: FutureResult
[16:20:34.223] - Received FutureResult
[16:20:34.223] - Erased future from FutureRegistry
[16:20:34.223] result() for ClusterFuture ...
[16:20:34.223] - result already collected: FutureResult
[16:20:34.223] result() for ClusterFuture ... done
[16:20:34.223] signalConditions() ...
[16:20:34.223]  - include = ‘immediateCondition’
[16:20:34.224]  - exclude = 
[16:20:34.224]  - resignal = FALSE
[16:20:34.224]  - Number of conditions: 1
[16:20:34.224] signalConditions() ... done
[16:20:34.224] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:34.224] result() for ClusterFuture ... done
[16:20:34.224] result() for ClusterFuture ...
[16:20:34.224] - result already collected: FutureResult
[16:20:34.224] result() for ClusterFuture ... done
[16:20:34.225] signalConditions() ...
[16:20:34.225]  - include = ‘immediateCondition’
[16:20:34.225]  - exclude = 
[16:20:34.225]  - resignal = FALSE
[16:20:34.225]  - Number of conditions: 1
[16:20:34.225] signalConditions() ... done
[16:20:34.225] Future state: ‘finished’
[16:20:34.225] result() for ClusterFuture ...
[16:20:34.226] - result already collected: FutureResult
[16:20:34.226] result() for ClusterFuture ... done
[16:20:34.226] signalConditions() ...
[16:20:34.226]  - include = ‘condition’
[16:20:34.226]  - exclude = ‘immediateCondition’
[16:20:34.226]  - resignal = TRUE
[16:20:34.226]  - Number of conditions: 1
[16:20:34.226]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:20:34.226] signalConditions() ... done
[16:20:34.227] getGlobalsAndPackages() ...
[16:20:34.227] Searching for globals...
[16:20:34.229] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[16:20:34.229] Searching for globals ... DONE
[16:20:34.229] Resolving globals: FALSE
[16:20:34.230] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:34.230] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:20:34.230] - globals: [1] ‘ii’
[16:20:34.230] 
[16:20:34.231] getGlobalsAndPackages() ... DONE
[16:20:34.231] run() for ‘Future’ ...
[16:20:34.231] - state: ‘created’
[16:20:34.231] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:34.249] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:34.249] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:34.249]   - Field: ‘node’
[16:20:34.249]   - Field: ‘label’
[16:20:34.250]   - Field: ‘local’
[16:20:34.250]   - Field: ‘owner’
[16:20:34.250]   - Field: ‘envir’
[16:20:34.250]   - Field: ‘workers’
[16:20:34.250]   - Field: ‘packages’
[16:20:34.250]   - Field: ‘gc’
[16:20:34.250]   - Field: ‘conditions’
[16:20:34.250]   - Field: ‘persistent’
[16:20:34.250]   - Field: ‘expr’
[16:20:34.250]   - Field: ‘uuid’
[16:20:34.250]   - Field: ‘seed’
[16:20:34.251]   - Field: ‘version’
[16:20:34.251]   - Field: ‘result’
[16:20:34.251]   - Field: ‘asynchronous’
[16:20:34.251]   - Field: ‘calls’
[16:20:34.251]   - Field: ‘globals’
[16:20:34.251]   - Field: ‘stdout’
[16:20:34.251]   - Field: ‘earlySignal’
[16:20:34.251]   - Field: ‘lazy’
[16:20:34.251]   - Field: ‘state’
[16:20:34.251] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:34.251] - Launch lazy future ...
[16:20:34.252] Packages needed by the future expression (n = 0): <none>
[16:20:34.252] Packages needed by future strategies (n = 0): <none>
[16:20:34.252] {
[16:20:34.252]     {
[16:20:34.252]         {
[16:20:34.252]             ...future.startTime <- base::Sys.time()
[16:20:34.252]             {
[16:20:34.252]                 {
[16:20:34.252]                   {
[16:20:34.252]                     {
[16:20:34.252]                       base::local({
[16:20:34.252]                         has_future <- base::requireNamespace("future", 
[16:20:34.252]                           quietly = TRUE)
[16:20:34.252]                         if (has_future) {
[16:20:34.252]                           ns <- base::getNamespace("future")
[16:20:34.252]                           version <- ns[[".package"]][["version"]]
[16:20:34.252]                           if (is.null(version)) 
[16:20:34.252]                             version <- utils::packageVersion("future")
[16:20:34.252]                         }
[16:20:34.252]                         else {
[16:20:34.252]                           version <- NULL
[16:20:34.252]                         }
[16:20:34.252]                         if (!has_future || version < "1.8.0") {
[16:20:34.252]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:34.252]                             "", base::R.version$version.string), 
[16:20:34.252]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:34.252]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:34.252]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:34.252]                               "release", "version")], collapse = " "), 
[16:20:34.252]                             hostname = base::Sys.info()[["nodename"]])
[16:20:34.252]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:34.252]                             info)
[16:20:34.252]                           info <- base::paste(info, collapse = "; ")
[16:20:34.252]                           if (!has_future) {
[16:20:34.252]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:34.252]                               info)
[16:20:34.252]                           }
[16:20:34.252]                           else {
[16:20:34.252]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:34.252]                               info, version)
[16:20:34.252]                           }
[16:20:34.252]                           base::stop(msg)
[16:20:34.252]                         }
[16:20:34.252]                       })
[16:20:34.252]                     }
[16:20:34.252]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:34.252]                     base::options(mc.cores = 1L)
[16:20:34.252]                   }
[16:20:34.252]                   ...future.strategy.old <- future::plan("list")
[16:20:34.252]                   options(future.plan = NULL)
[16:20:34.252]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.252]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:34.252]                 }
[16:20:34.252]                 ...future.workdir <- getwd()
[16:20:34.252]             }
[16:20:34.252]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:34.252]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:34.252]         }
[16:20:34.252]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:34.252]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:34.252]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:34.252]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:34.252]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:34.252]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:34.252]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:34.252]             base::names(...future.oldOptions))
[16:20:34.252]     }
[16:20:34.252]     if (FALSE) {
[16:20:34.252]     }
[16:20:34.252]     else {
[16:20:34.252]         if (TRUE) {
[16:20:34.252]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:34.252]                 open = "w")
[16:20:34.252]         }
[16:20:34.252]         else {
[16:20:34.252]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:34.252]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:34.252]         }
[16:20:34.252]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:34.252]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:34.252]             base::sink(type = "output", split = FALSE)
[16:20:34.252]             base::close(...future.stdout)
[16:20:34.252]         }, add = TRUE)
[16:20:34.252]     }
[16:20:34.252]     ...future.frame <- base::sys.nframe()
[16:20:34.252]     ...future.conditions <- base::list()
[16:20:34.252]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:34.252]     if (FALSE) {
[16:20:34.252]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:34.252]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:34.252]     }
[16:20:34.252]     ...future.result <- base::tryCatch({
[16:20:34.252]         base::withCallingHandlers({
[16:20:34.252]             ...future.value <- base::withVisible(base::local({
[16:20:34.252]                 ...future.makeSendCondition <- base::local({
[16:20:34.252]                   sendCondition <- NULL
[16:20:34.252]                   function(frame = 1L) {
[16:20:34.252]                     if (is.function(sendCondition)) 
[16:20:34.252]                       return(sendCondition)
[16:20:34.252]                     ns <- getNamespace("parallel")
[16:20:34.252]                     if (exists("sendData", mode = "function", 
[16:20:34.252]                       envir = ns)) {
[16:20:34.252]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:34.252]                         envir = ns)
[16:20:34.252]                       envir <- sys.frame(frame)
[16:20:34.252]                       master <- NULL
[16:20:34.252]                       while (!identical(envir, .GlobalEnv) && 
[16:20:34.252]                         !identical(envir, emptyenv())) {
[16:20:34.252]                         if (exists("master", mode = "list", envir = envir, 
[16:20:34.252]                           inherits = FALSE)) {
[16:20:34.252]                           master <- get("master", mode = "list", 
[16:20:34.252]                             envir = envir, inherits = FALSE)
[16:20:34.252]                           if (inherits(master, c("SOCKnode", 
[16:20:34.252]                             "SOCK0node"))) {
[16:20:34.252]                             sendCondition <<- function(cond) {
[16:20:34.252]                               data <- list(type = "VALUE", value = cond, 
[16:20:34.252]                                 success = TRUE)
[16:20:34.252]                               parallel_sendData(master, data)
[16:20:34.252]                             }
[16:20:34.252]                             return(sendCondition)
[16:20:34.252]                           }
[16:20:34.252]                         }
[16:20:34.252]                         frame <- frame + 1L
[16:20:34.252]                         envir <- sys.frame(frame)
[16:20:34.252]                       }
[16:20:34.252]                     }
[16:20:34.252]                     sendCondition <<- function(cond) NULL
[16:20:34.252]                   }
[16:20:34.252]                 })
[16:20:34.252]                 withCallingHandlers({
[16:20:34.252]                   {
[16:20:34.252]                     if (ii%%2 == 0) 
[16:20:34.252]                       stop("Woops!")
[16:20:34.252]                     ii
[16:20:34.252]                   }
[16:20:34.252]                 }, immediateCondition = function(cond) {
[16:20:34.252]                   sendCondition <- ...future.makeSendCondition()
[16:20:34.252]                   sendCondition(cond)
[16:20:34.252]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.252]                   {
[16:20:34.252]                     inherits <- base::inherits
[16:20:34.252]                     invokeRestart <- base::invokeRestart
[16:20:34.252]                     is.null <- base::is.null
[16:20:34.252]                     muffled <- FALSE
[16:20:34.252]                     if (inherits(cond, "message")) {
[16:20:34.252]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:34.252]                       if (muffled) 
[16:20:34.252]                         invokeRestart("muffleMessage")
[16:20:34.252]                     }
[16:20:34.252]                     else if (inherits(cond, "warning")) {
[16:20:34.252]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:34.252]                       if (muffled) 
[16:20:34.252]                         invokeRestart("muffleWarning")
[16:20:34.252]                     }
[16:20:34.252]                     else if (inherits(cond, "condition")) {
[16:20:34.252]                       if (!is.null(pattern)) {
[16:20:34.252]                         computeRestarts <- base::computeRestarts
[16:20:34.252]                         grepl <- base::grepl
[16:20:34.252]                         restarts <- computeRestarts(cond)
[16:20:34.252]                         for (restart in restarts) {
[16:20:34.252]                           name <- restart$name
[16:20:34.252]                           if (is.null(name)) 
[16:20:34.252]                             next
[16:20:34.252]                           if (!grepl(pattern, name)) 
[16:20:34.252]                             next
[16:20:34.252]                           invokeRestart(restart)
[16:20:34.252]                           muffled <- TRUE
[16:20:34.252]                           break
[16:20:34.252]                         }
[16:20:34.252]                       }
[16:20:34.252]                     }
[16:20:34.252]                     invisible(muffled)
[16:20:34.252]                   }
[16:20:34.252]                   muffleCondition(cond)
[16:20:34.252]                 })
[16:20:34.252]             }))
[16:20:34.252]             future::FutureResult(value = ...future.value$value, 
[16:20:34.252]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.252]                   ...future.rng), globalenv = if (FALSE) 
[16:20:34.252]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:34.252]                     ...future.globalenv.names))
[16:20:34.252]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:34.252]         }, condition = base::local({
[16:20:34.252]             c <- base::c
[16:20:34.252]             inherits <- base::inherits
[16:20:34.252]             invokeRestart <- base::invokeRestart
[16:20:34.252]             length <- base::length
[16:20:34.252]             list <- base::list
[16:20:34.252]             seq.int <- base::seq.int
[16:20:34.252]             signalCondition <- base::signalCondition
[16:20:34.252]             sys.calls <- base::sys.calls
[16:20:34.252]             `[[` <- base::`[[`
[16:20:34.252]             `+` <- base::`+`
[16:20:34.252]             `<<-` <- base::`<<-`
[16:20:34.252]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:34.252]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:34.252]                   3L)]
[16:20:34.252]             }
[16:20:34.252]             function(cond) {
[16:20:34.252]                 is_error <- inherits(cond, "error")
[16:20:34.252]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:34.252]                   NULL)
[16:20:34.252]                 if (is_error) {
[16:20:34.252]                   sessionInformation <- function() {
[16:20:34.252]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:34.252]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:34.252]                       search = base::search(), system = base::Sys.info())
[16:20:34.252]                   }
[16:20:34.252]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.252]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:34.252]                     cond$call), session = sessionInformation(), 
[16:20:34.252]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:34.252]                   signalCondition(cond)
[16:20:34.252]                 }
[16:20:34.252]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:34.252]                 "immediateCondition"))) {
[16:20:34.252]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:34.252]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.252]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:34.252]                   if (TRUE && !signal) {
[16:20:34.252]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.252]                     {
[16:20:34.252]                       inherits <- base::inherits
[16:20:34.252]                       invokeRestart <- base::invokeRestart
[16:20:34.252]                       is.null <- base::is.null
[16:20:34.252]                       muffled <- FALSE
[16:20:34.252]                       if (inherits(cond, "message")) {
[16:20:34.252]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.252]                         if (muffled) 
[16:20:34.252]                           invokeRestart("muffleMessage")
[16:20:34.252]                       }
[16:20:34.252]                       else if (inherits(cond, "warning")) {
[16:20:34.252]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.252]                         if (muffled) 
[16:20:34.252]                           invokeRestart("muffleWarning")
[16:20:34.252]                       }
[16:20:34.252]                       else if (inherits(cond, "condition")) {
[16:20:34.252]                         if (!is.null(pattern)) {
[16:20:34.252]                           computeRestarts <- base::computeRestarts
[16:20:34.252]                           grepl <- base::grepl
[16:20:34.252]                           restarts <- computeRestarts(cond)
[16:20:34.252]                           for (restart in restarts) {
[16:20:34.252]                             name <- restart$name
[16:20:34.252]                             if (is.null(name)) 
[16:20:34.252]                               next
[16:20:34.252]                             if (!grepl(pattern, name)) 
[16:20:34.252]                               next
[16:20:34.252]                             invokeRestart(restart)
[16:20:34.252]                             muffled <- TRUE
[16:20:34.252]                             break
[16:20:34.252]                           }
[16:20:34.252]                         }
[16:20:34.252]                       }
[16:20:34.252]                       invisible(muffled)
[16:20:34.252]                     }
[16:20:34.252]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.252]                   }
[16:20:34.252]                 }
[16:20:34.252]                 else {
[16:20:34.252]                   if (TRUE) {
[16:20:34.252]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.252]                     {
[16:20:34.252]                       inherits <- base::inherits
[16:20:34.252]                       invokeRestart <- base::invokeRestart
[16:20:34.252]                       is.null <- base::is.null
[16:20:34.252]                       muffled <- FALSE
[16:20:34.252]                       if (inherits(cond, "message")) {
[16:20:34.252]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.252]                         if (muffled) 
[16:20:34.252]                           invokeRestart("muffleMessage")
[16:20:34.252]                       }
[16:20:34.252]                       else if (inherits(cond, "warning")) {
[16:20:34.252]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.252]                         if (muffled) 
[16:20:34.252]                           invokeRestart("muffleWarning")
[16:20:34.252]                       }
[16:20:34.252]                       else if (inherits(cond, "condition")) {
[16:20:34.252]                         if (!is.null(pattern)) {
[16:20:34.252]                           computeRestarts <- base::computeRestarts
[16:20:34.252]                           grepl <- base::grepl
[16:20:34.252]                           restarts <- computeRestarts(cond)
[16:20:34.252]                           for (restart in restarts) {
[16:20:34.252]                             name <- restart$name
[16:20:34.252]                             if (is.null(name)) 
[16:20:34.252]                               next
[16:20:34.252]                             if (!grepl(pattern, name)) 
[16:20:34.252]                               next
[16:20:34.252]                             invokeRestart(restart)
[16:20:34.252]                             muffled <- TRUE
[16:20:34.252]                             break
[16:20:34.252]                           }
[16:20:34.252]                         }
[16:20:34.252]                       }
[16:20:34.252]                       invisible(muffled)
[16:20:34.252]                     }
[16:20:34.252]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.252]                   }
[16:20:34.252]                 }
[16:20:34.252]             }
[16:20:34.252]         }))
[16:20:34.252]     }, error = function(ex) {
[16:20:34.252]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:34.252]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.252]                 ...future.rng), started = ...future.startTime, 
[16:20:34.252]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:34.252]             version = "1.8"), class = "FutureResult")
[16:20:34.252]     }, finally = {
[16:20:34.252]         if (!identical(...future.workdir, getwd())) 
[16:20:34.252]             setwd(...future.workdir)
[16:20:34.252]         {
[16:20:34.252]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:34.252]                 ...future.oldOptions$nwarnings <- NULL
[16:20:34.252]             }
[16:20:34.252]             base::options(...future.oldOptions)
[16:20:34.252]             if (.Platform$OS.type == "windows") {
[16:20:34.252]                 old_names <- names(...future.oldEnvVars)
[16:20:34.252]                 envs <- base::Sys.getenv()
[16:20:34.252]                 names <- names(envs)
[16:20:34.252]                 common <- intersect(names, old_names)
[16:20:34.252]                 added <- setdiff(names, old_names)
[16:20:34.252]                 removed <- setdiff(old_names, names)
[16:20:34.252]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:34.252]                   envs[common]]
[16:20:34.252]                 NAMES <- toupper(changed)
[16:20:34.252]                 args <- list()
[16:20:34.252]                 for (kk in seq_along(NAMES)) {
[16:20:34.252]                   name <- changed[[kk]]
[16:20:34.252]                   NAME <- NAMES[[kk]]
[16:20:34.252]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.252]                     next
[16:20:34.252]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.252]                 }
[16:20:34.252]                 NAMES <- toupper(added)
[16:20:34.252]                 for (kk in seq_along(NAMES)) {
[16:20:34.252]                   name <- added[[kk]]
[16:20:34.252]                   NAME <- NAMES[[kk]]
[16:20:34.252]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.252]                     next
[16:20:34.252]                   args[[name]] <- ""
[16:20:34.252]                 }
[16:20:34.252]                 NAMES <- toupper(removed)
[16:20:34.252]                 for (kk in seq_along(NAMES)) {
[16:20:34.252]                   name <- removed[[kk]]
[16:20:34.252]                   NAME <- NAMES[[kk]]
[16:20:34.252]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.252]                     next
[16:20:34.252]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.252]                 }
[16:20:34.252]                 if (length(args) > 0) 
[16:20:34.252]                   base::do.call(base::Sys.setenv, args = args)
[16:20:34.252]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:34.252]             }
[16:20:34.252]             else {
[16:20:34.252]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:34.252]             }
[16:20:34.252]             {
[16:20:34.252]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:34.252]                   0L) {
[16:20:34.252]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:34.252]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:34.252]                   base::options(opts)
[16:20:34.252]                 }
[16:20:34.252]                 {
[16:20:34.252]                   {
[16:20:34.252]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:34.252]                     NULL
[16:20:34.252]                   }
[16:20:34.252]                   options(future.plan = NULL)
[16:20:34.252]                   if (is.na(NA_character_)) 
[16:20:34.252]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.252]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:34.252]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:34.252]                     .init = FALSE)
[16:20:34.252]                 }
[16:20:34.252]             }
[16:20:34.252]         }
[16:20:34.252]     })
[16:20:34.252]     if (TRUE) {
[16:20:34.252]         base::sink(type = "output", split = FALSE)
[16:20:34.252]         if (TRUE) {
[16:20:34.252]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:34.252]         }
[16:20:34.252]         else {
[16:20:34.252]             ...future.result["stdout"] <- base::list(NULL)
[16:20:34.252]         }
[16:20:34.252]         base::close(...future.stdout)
[16:20:34.252]         ...future.stdout <- NULL
[16:20:34.252]     }
[16:20:34.252]     ...future.result$conditions <- ...future.conditions
[16:20:34.252]     ...future.result$finished <- base::Sys.time()
[16:20:34.252]     ...future.result
[16:20:34.252] }
[16:20:34.255] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:20:34.255] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:20:34.255] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:20:34.256] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:20:34.256] MultisessionFuture started
[16:20:34.256] - Launch lazy future ... done
[16:20:34.256] run() for ‘MultisessionFuture’ ... done
[16:20:34.257] getGlobalsAndPackages() ...
[16:20:34.257] Searching for globals...
[16:20:34.259] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[16:20:34.259] Searching for globals ... DONE
[16:20:34.259] Resolving globals: FALSE
[16:20:34.260] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:34.260] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:20:34.260] - globals: [1] ‘ii’
[16:20:34.260] 
[16:20:34.261] getGlobalsAndPackages() ... DONE
[16:20:34.261] run() for ‘Future’ ...
[16:20:34.261] - state: ‘created’
[16:20:34.261] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:34.274] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:34.275] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:34.275]   - Field: ‘node’
[16:20:34.275]   - Field: ‘label’
[16:20:34.275]   - Field: ‘local’
[16:20:34.275]   - Field: ‘owner’
[16:20:34.275]   - Field: ‘envir’
[16:20:34.275]   - Field: ‘workers’
[16:20:34.275]   - Field: ‘packages’
[16:20:34.275]   - Field: ‘gc’
[16:20:34.275]   - Field: ‘conditions’
[16:20:34.276]   - Field: ‘persistent’
[16:20:34.276]   - Field: ‘expr’
[16:20:34.276]   - Field: ‘uuid’
[16:20:34.276]   - Field: ‘seed’
[16:20:34.276]   - Field: ‘version’
[16:20:34.276]   - Field: ‘result’
[16:20:34.276]   - Field: ‘asynchronous’
[16:20:34.276]   - Field: ‘calls’
[16:20:34.276]   - Field: ‘globals’
[16:20:34.277]   - Field: ‘stdout’
[16:20:34.277]   - Field: ‘earlySignal’
[16:20:34.277]   - Field: ‘lazy’
[16:20:34.277]   - Field: ‘state’
[16:20:34.277] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:34.277] - Launch lazy future ...
[16:20:34.277] Packages needed by the future expression (n = 0): <none>
[16:20:34.277] Packages needed by future strategies (n = 0): <none>
[16:20:34.278] {
[16:20:34.278]     {
[16:20:34.278]         {
[16:20:34.278]             ...future.startTime <- base::Sys.time()
[16:20:34.278]             {
[16:20:34.278]                 {
[16:20:34.278]                   {
[16:20:34.278]                     {
[16:20:34.278]                       base::local({
[16:20:34.278]                         has_future <- base::requireNamespace("future", 
[16:20:34.278]                           quietly = TRUE)
[16:20:34.278]                         if (has_future) {
[16:20:34.278]                           ns <- base::getNamespace("future")
[16:20:34.278]                           version <- ns[[".package"]][["version"]]
[16:20:34.278]                           if (is.null(version)) 
[16:20:34.278]                             version <- utils::packageVersion("future")
[16:20:34.278]                         }
[16:20:34.278]                         else {
[16:20:34.278]                           version <- NULL
[16:20:34.278]                         }
[16:20:34.278]                         if (!has_future || version < "1.8.0") {
[16:20:34.278]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:34.278]                             "", base::R.version$version.string), 
[16:20:34.278]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:34.278]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:34.278]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:34.278]                               "release", "version")], collapse = " "), 
[16:20:34.278]                             hostname = base::Sys.info()[["nodename"]])
[16:20:34.278]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:34.278]                             info)
[16:20:34.278]                           info <- base::paste(info, collapse = "; ")
[16:20:34.278]                           if (!has_future) {
[16:20:34.278]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:34.278]                               info)
[16:20:34.278]                           }
[16:20:34.278]                           else {
[16:20:34.278]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:34.278]                               info, version)
[16:20:34.278]                           }
[16:20:34.278]                           base::stop(msg)
[16:20:34.278]                         }
[16:20:34.278]                       })
[16:20:34.278]                     }
[16:20:34.278]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:34.278]                     base::options(mc.cores = 1L)
[16:20:34.278]                   }
[16:20:34.278]                   ...future.strategy.old <- future::plan("list")
[16:20:34.278]                   options(future.plan = NULL)
[16:20:34.278]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.278]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:34.278]                 }
[16:20:34.278]                 ...future.workdir <- getwd()
[16:20:34.278]             }
[16:20:34.278]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:34.278]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:34.278]         }
[16:20:34.278]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:34.278]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:34.278]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:34.278]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:34.278]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:34.278]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:34.278]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:34.278]             base::names(...future.oldOptions))
[16:20:34.278]     }
[16:20:34.278]     if (FALSE) {
[16:20:34.278]     }
[16:20:34.278]     else {
[16:20:34.278]         if (TRUE) {
[16:20:34.278]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:34.278]                 open = "w")
[16:20:34.278]         }
[16:20:34.278]         else {
[16:20:34.278]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:34.278]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:34.278]         }
[16:20:34.278]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:34.278]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:34.278]             base::sink(type = "output", split = FALSE)
[16:20:34.278]             base::close(...future.stdout)
[16:20:34.278]         }, add = TRUE)
[16:20:34.278]     }
[16:20:34.278]     ...future.frame <- base::sys.nframe()
[16:20:34.278]     ...future.conditions <- base::list()
[16:20:34.278]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:34.278]     if (FALSE) {
[16:20:34.278]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:34.278]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:34.278]     }
[16:20:34.278]     ...future.result <- base::tryCatch({
[16:20:34.278]         base::withCallingHandlers({
[16:20:34.278]             ...future.value <- base::withVisible(base::local({
[16:20:34.278]                 ...future.makeSendCondition <- base::local({
[16:20:34.278]                   sendCondition <- NULL
[16:20:34.278]                   function(frame = 1L) {
[16:20:34.278]                     if (is.function(sendCondition)) 
[16:20:34.278]                       return(sendCondition)
[16:20:34.278]                     ns <- getNamespace("parallel")
[16:20:34.278]                     if (exists("sendData", mode = "function", 
[16:20:34.278]                       envir = ns)) {
[16:20:34.278]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:34.278]                         envir = ns)
[16:20:34.278]                       envir <- sys.frame(frame)
[16:20:34.278]                       master <- NULL
[16:20:34.278]                       while (!identical(envir, .GlobalEnv) && 
[16:20:34.278]                         !identical(envir, emptyenv())) {
[16:20:34.278]                         if (exists("master", mode = "list", envir = envir, 
[16:20:34.278]                           inherits = FALSE)) {
[16:20:34.278]                           master <- get("master", mode = "list", 
[16:20:34.278]                             envir = envir, inherits = FALSE)
[16:20:34.278]                           if (inherits(master, c("SOCKnode", 
[16:20:34.278]                             "SOCK0node"))) {
[16:20:34.278]                             sendCondition <<- function(cond) {
[16:20:34.278]                               data <- list(type = "VALUE", value = cond, 
[16:20:34.278]                                 success = TRUE)
[16:20:34.278]                               parallel_sendData(master, data)
[16:20:34.278]                             }
[16:20:34.278]                             return(sendCondition)
[16:20:34.278]                           }
[16:20:34.278]                         }
[16:20:34.278]                         frame <- frame + 1L
[16:20:34.278]                         envir <- sys.frame(frame)
[16:20:34.278]                       }
[16:20:34.278]                     }
[16:20:34.278]                     sendCondition <<- function(cond) NULL
[16:20:34.278]                   }
[16:20:34.278]                 })
[16:20:34.278]                 withCallingHandlers({
[16:20:34.278]                   {
[16:20:34.278]                     if (ii%%2 == 0) 
[16:20:34.278]                       stop("Woops!")
[16:20:34.278]                     ii
[16:20:34.278]                   }
[16:20:34.278]                 }, immediateCondition = function(cond) {
[16:20:34.278]                   sendCondition <- ...future.makeSendCondition()
[16:20:34.278]                   sendCondition(cond)
[16:20:34.278]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.278]                   {
[16:20:34.278]                     inherits <- base::inherits
[16:20:34.278]                     invokeRestart <- base::invokeRestart
[16:20:34.278]                     is.null <- base::is.null
[16:20:34.278]                     muffled <- FALSE
[16:20:34.278]                     if (inherits(cond, "message")) {
[16:20:34.278]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:34.278]                       if (muffled) 
[16:20:34.278]                         invokeRestart("muffleMessage")
[16:20:34.278]                     }
[16:20:34.278]                     else if (inherits(cond, "warning")) {
[16:20:34.278]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:34.278]                       if (muffled) 
[16:20:34.278]                         invokeRestart("muffleWarning")
[16:20:34.278]                     }
[16:20:34.278]                     else if (inherits(cond, "condition")) {
[16:20:34.278]                       if (!is.null(pattern)) {
[16:20:34.278]                         computeRestarts <- base::computeRestarts
[16:20:34.278]                         grepl <- base::grepl
[16:20:34.278]                         restarts <- computeRestarts(cond)
[16:20:34.278]                         for (restart in restarts) {
[16:20:34.278]                           name <- restart$name
[16:20:34.278]                           if (is.null(name)) 
[16:20:34.278]                             next
[16:20:34.278]                           if (!grepl(pattern, name)) 
[16:20:34.278]                             next
[16:20:34.278]                           invokeRestart(restart)
[16:20:34.278]                           muffled <- TRUE
[16:20:34.278]                           break
[16:20:34.278]                         }
[16:20:34.278]                       }
[16:20:34.278]                     }
[16:20:34.278]                     invisible(muffled)
[16:20:34.278]                   }
[16:20:34.278]                   muffleCondition(cond)
[16:20:34.278]                 })
[16:20:34.278]             }))
[16:20:34.278]             future::FutureResult(value = ...future.value$value, 
[16:20:34.278]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.278]                   ...future.rng), globalenv = if (FALSE) 
[16:20:34.278]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:34.278]                     ...future.globalenv.names))
[16:20:34.278]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:34.278]         }, condition = base::local({
[16:20:34.278]             c <- base::c
[16:20:34.278]             inherits <- base::inherits
[16:20:34.278]             invokeRestart <- base::invokeRestart
[16:20:34.278]             length <- base::length
[16:20:34.278]             list <- base::list
[16:20:34.278]             seq.int <- base::seq.int
[16:20:34.278]             signalCondition <- base::signalCondition
[16:20:34.278]             sys.calls <- base::sys.calls
[16:20:34.278]             `[[` <- base::`[[`
[16:20:34.278]             `+` <- base::`+`
[16:20:34.278]             `<<-` <- base::`<<-`
[16:20:34.278]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:34.278]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:34.278]                   3L)]
[16:20:34.278]             }
[16:20:34.278]             function(cond) {
[16:20:34.278]                 is_error <- inherits(cond, "error")
[16:20:34.278]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:34.278]                   NULL)
[16:20:34.278]                 if (is_error) {
[16:20:34.278]                   sessionInformation <- function() {
[16:20:34.278]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:34.278]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:34.278]                       search = base::search(), system = base::Sys.info())
[16:20:34.278]                   }
[16:20:34.278]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.278]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:34.278]                     cond$call), session = sessionInformation(), 
[16:20:34.278]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:34.278]                   signalCondition(cond)
[16:20:34.278]                 }
[16:20:34.278]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:34.278]                 "immediateCondition"))) {
[16:20:34.278]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:34.278]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.278]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:34.278]                   if (TRUE && !signal) {
[16:20:34.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.278]                     {
[16:20:34.278]                       inherits <- base::inherits
[16:20:34.278]                       invokeRestart <- base::invokeRestart
[16:20:34.278]                       is.null <- base::is.null
[16:20:34.278]                       muffled <- FALSE
[16:20:34.278]                       if (inherits(cond, "message")) {
[16:20:34.278]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.278]                         if (muffled) 
[16:20:34.278]                           invokeRestart("muffleMessage")
[16:20:34.278]                       }
[16:20:34.278]                       else if (inherits(cond, "warning")) {
[16:20:34.278]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.278]                         if (muffled) 
[16:20:34.278]                           invokeRestart("muffleWarning")
[16:20:34.278]                       }
[16:20:34.278]                       else if (inherits(cond, "condition")) {
[16:20:34.278]                         if (!is.null(pattern)) {
[16:20:34.278]                           computeRestarts <- base::computeRestarts
[16:20:34.278]                           grepl <- base::grepl
[16:20:34.278]                           restarts <- computeRestarts(cond)
[16:20:34.278]                           for (restart in restarts) {
[16:20:34.278]                             name <- restart$name
[16:20:34.278]                             if (is.null(name)) 
[16:20:34.278]                               next
[16:20:34.278]                             if (!grepl(pattern, name)) 
[16:20:34.278]                               next
[16:20:34.278]                             invokeRestart(restart)
[16:20:34.278]                             muffled <- TRUE
[16:20:34.278]                             break
[16:20:34.278]                           }
[16:20:34.278]                         }
[16:20:34.278]                       }
[16:20:34.278]                       invisible(muffled)
[16:20:34.278]                     }
[16:20:34.278]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.278]                   }
[16:20:34.278]                 }
[16:20:34.278]                 else {
[16:20:34.278]                   if (TRUE) {
[16:20:34.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.278]                     {
[16:20:34.278]                       inherits <- base::inherits
[16:20:34.278]                       invokeRestart <- base::invokeRestart
[16:20:34.278]                       is.null <- base::is.null
[16:20:34.278]                       muffled <- FALSE
[16:20:34.278]                       if (inherits(cond, "message")) {
[16:20:34.278]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.278]                         if (muffled) 
[16:20:34.278]                           invokeRestart("muffleMessage")
[16:20:34.278]                       }
[16:20:34.278]                       else if (inherits(cond, "warning")) {
[16:20:34.278]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.278]                         if (muffled) 
[16:20:34.278]                           invokeRestart("muffleWarning")
[16:20:34.278]                       }
[16:20:34.278]                       else if (inherits(cond, "condition")) {
[16:20:34.278]                         if (!is.null(pattern)) {
[16:20:34.278]                           computeRestarts <- base::computeRestarts
[16:20:34.278]                           grepl <- base::grepl
[16:20:34.278]                           restarts <- computeRestarts(cond)
[16:20:34.278]                           for (restart in restarts) {
[16:20:34.278]                             name <- restart$name
[16:20:34.278]                             if (is.null(name)) 
[16:20:34.278]                               next
[16:20:34.278]                             if (!grepl(pattern, name)) 
[16:20:34.278]                               next
[16:20:34.278]                             invokeRestart(restart)
[16:20:34.278]                             muffled <- TRUE
[16:20:34.278]                             break
[16:20:34.278]                           }
[16:20:34.278]                         }
[16:20:34.278]                       }
[16:20:34.278]                       invisible(muffled)
[16:20:34.278]                     }
[16:20:34.278]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.278]                   }
[16:20:34.278]                 }
[16:20:34.278]             }
[16:20:34.278]         }))
[16:20:34.278]     }, error = function(ex) {
[16:20:34.278]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:34.278]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.278]                 ...future.rng), started = ...future.startTime, 
[16:20:34.278]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:34.278]             version = "1.8"), class = "FutureResult")
[16:20:34.278]     }, finally = {
[16:20:34.278]         if (!identical(...future.workdir, getwd())) 
[16:20:34.278]             setwd(...future.workdir)
[16:20:34.278]         {
[16:20:34.278]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:34.278]                 ...future.oldOptions$nwarnings <- NULL
[16:20:34.278]             }
[16:20:34.278]             base::options(...future.oldOptions)
[16:20:34.278]             if (.Platform$OS.type == "windows") {
[16:20:34.278]                 old_names <- names(...future.oldEnvVars)
[16:20:34.278]                 envs <- base::Sys.getenv()
[16:20:34.278]                 names <- names(envs)
[16:20:34.278]                 common <- intersect(names, old_names)
[16:20:34.278]                 added <- setdiff(names, old_names)
[16:20:34.278]                 removed <- setdiff(old_names, names)
[16:20:34.278]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:34.278]                   envs[common]]
[16:20:34.278]                 NAMES <- toupper(changed)
[16:20:34.278]                 args <- list()
[16:20:34.278]                 for (kk in seq_along(NAMES)) {
[16:20:34.278]                   name <- changed[[kk]]
[16:20:34.278]                   NAME <- NAMES[[kk]]
[16:20:34.278]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.278]                     next
[16:20:34.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.278]                 }
[16:20:34.278]                 NAMES <- toupper(added)
[16:20:34.278]                 for (kk in seq_along(NAMES)) {
[16:20:34.278]                   name <- added[[kk]]
[16:20:34.278]                   NAME <- NAMES[[kk]]
[16:20:34.278]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.278]                     next
[16:20:34.278]                   args[[name]] <- ""
[16:20:34.278]                 }
[16:20:34.278]                 NAMES <- toupper(removed)
[16:20:34.278]                 for (kk in seq_along(NAMES)) {
[16:20:34.278]                   name <- removed[[kk]]
[16:20:34.278]                   NAME <- NAMES[[kk]]
[16:20:34.278]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.278]                     next
[16:20:34.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.278]                 }
[16:20:34.278]                 if (length(args) > 0) 
[16:20:34.278]                   base::do.call(base::Sys.setenv, args = args)
[16:20:34.278]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:34.278]             }
[16:20:34.278]             else {
[16:20:34.278]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:34.278]             }
[16:20:34.278]             {
[16:20:34.278]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:34.278]                   0L) {
[16:20:34.278]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:34.278]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:34.278]                   base::options(opts)
[16:20:34.278]                 }
[16:20:34.278]                 {
[16:20:34.278]                   {
[16:20:34.278]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:34.278]                     NULL
[16:20:34.278]                   }
[16:20:34.278]                   options(future.plan = NULL)
[16:20:34.278]                   if (is.na(NA_character_)) 
[16:20:34.278]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.278]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:34.278]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:34.278]                     .init = FALSE)
[16:20:34.278]                 }
[16:20:34.278]             }
[16:20:34.278]         }
[16:20:34.278]     })
[16:20:34.278]     if (TRUE) {
[16:20:34.278]         base::sink(type = "output", split = FALSE)
[16:20:34.278]         if (TRUE) {
[16:20:34.278]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:34.278]         }
[16:20:34.278]         else {
[16:20:34.278]             ...future.result["stdout"] <- base::list(NULL)
[16:20:34.278]         }
[16:20:34.278]         base::close(...future.stdout)
[16:20:34.278]         ...future.stdout <- NULL
[16:20:34.278]     }
[16:20:34.278]     ...future.result$conditions <- ...future.conditions
[16:20:34.278]     ...future.result$finished <- base::Sys.time()
[16:20:34.278]     ...future.result
[16:20:34.278] }
[16:20:34.330] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[16:20:34.331] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[16:20:34.331] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[16:20:34.331] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[16:20:34.332] MultisessionFuture started
[16:20:34.332] - Launch lazy future ... done
[16:20:34.332] run() for ‘MultisessionFuture’ ... done
[16:20:34.332] getGlobalsAndPackages() ...
[16:20:34.332] Searching for globals...
[16:20:34.334] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[16:20:34.334] Searching for globals ... DONE
[16:20:34.334] Resolving globals: FALSE
[16:20:34.335] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:34.335] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:20:34.335] - globals: [1] ‘ii’
[16:20:34.335] 
[16:20:34.335] getGlobalsAndPackages() ... DONE
[16:20:34.336] run() for ‘Future’ ...
[16:20:34.336] - state: ‘created’
[16:20:34.336] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:34.351] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:34.351] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:34.351]   - Field: ‘node’
[16:20:34.351]   - Field: ‘label’
[16:20:34.351]   - Field: ‘local’
[16:20:34.351]   - Field: ‘owner’
[16:20:34.351]   - Field: ‘envir’
[16:20:34.352]   - Field: ‘workers’
[16:20:34.352]   - Field: ‘packages’
[16:20:34.352]   - Field: ‘gc’
[16:20:34.352]   - Field: ‘conditions’
[16:20:34.352]   - Field: ‘persistent’
[16:20:34.352]   - Field: ‘expr’
[16:20:34.352]   - Field: ‘uuid’
[16:20:34.352]   - Field: ‘seed’
[16:20:34.352]   - Field: ‘version’
[16:20:34.352]   - Field: ‘result’
[16:20:34.352]   - Field: ‘asynchronous’
[16:20:34.353]   - Field: ‘calls’
[16:20:34.353]   - Field: ‘globals’
[16:20:34.353]   - Field: ‘stdout’
[16:20:34.353]   - Field: ‘earlySignal’
[16:20:34.353]   - Field: ‘lazy’
[16:20:34.353]   - Field: ‘state’
[16:20:34.353] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:34.353] - Launch lazy future ...
[16:20:34.354] Packages needed by the future expression (n = 0): <none>
[16:20:34.354] Packages needed by future strategies (n = 0): <none>
[16:20:34.354] {
[16:20:34.354]     {
[16:20:34.354]         {
[16:20:34.354]             ...future.startTime <- base::Sys.time()
[16:20:34.354]             {
[16:20:34.354]                 {
[16:20:34.354]                   {
[16:20:34.354]                     {
[16:20:34.354]                       base::local({
[16:20:34.354]                         has_future <- base::requireNamespace("future", 
[16:20:34.354]                           quietly = TRUE)
[16:20:34.354]                         if (has_future) {
[16:20:34.354]                           ns <- base::getNamespace("future")
[16:20:34.354]                           version <- ns[[".package"]][["version"]]
[16:20:34.354]                           if (is.null(version)) 
[16:20:34.354]                             version <- utils::packageVersion("future")
[16:20:34.354]                         }
[16:20:34.354]                         else {
[16:20:34.354]                           version <- NULL
[16:20:34.354]                         }
[16:20:34.354]                         if (!has_future || version < "1.8.0") {
[16:20:34.354]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:34.354]                             "", base::R.version$version.string), 
[16:20:34.354]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:34.354]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:34.354]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:34.354]                               "release", "version")], collapse = " "), 
[16:20:34.354]                             hostname = base::Sys.info()[["nodename"]])
[16:20:34.354]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:34.354]                             info)
[16:20:34.354]                           info <- base::paste(info, collapse = "; ")
[16:20:34.354]                           if (!has_future) {
[16:20:34.354]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:34.354]                               info)
[16:20:34.354]                           }
[16:20:34.354]                           else {
[16:20:34.354]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:34.354]                               info, version)
[16:20:34.354]                           }
[16:20:34.354]                           base::stop(msg)
[16:20:34.354]                         }
[16:20:34.354]                       })
[16:20:34.354]                     }
[16:20:34.354]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:34.354]                     base::options(mc.cores = 1L)
[16:20:34.354]                   }
[16:20:34.354]                   ...future.strategy.old <- future::plan("list")
[16:20:34.354]                   options(future.plan = NULL)
[16:20:34.354]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.354]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:34.354]                 }
[16:20:34.354]                 ...future.workdir <- getwd()
[16:20:34.354]             }
[16:20:34.354]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:34.354]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:34.354]         }
[16:20:34.354]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:34.354]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:34.354]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:34.354]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:34.354]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:34.354]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:34.354]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:34.354]             base::names(...future.oldOptions))
[16:20:34.354]     }
[16:20:34.354]     if (FALSE) {
[16:20:34.354]     }
[16:20:34.354]     else {
[16:20:34.354]         if (TRUE) {
[16:20:34.354]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:34.354]                 open = "w")
[16:20:34.354]         }
[16:20:34.354]         else {
[16:20:34.354]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:34.354]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:34.354]         }
[16:20:34.354]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:34.354]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:34.354]             base::sink(type = "output", split = FALSE)
[16:20:34.354]             base::close(...future.stdout)
[16:20:34.354]         }, add = TRUE)
[16:20:34.354]     }
[16:20:34.354]     ...future.frame <- base::sys.nframe()
[16:20:34.354]     ...future.conditions <- base::list()
[16:20:34.354]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:34.354]     if (FALSE) {
[16:20:34.354]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:34.354]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:34.354]     }
[16:20:34.354]     ...future.result <- base::tryCatch({
[16:20:34.354]         base::withCallingHandlers({
[16:20:34.354]             ...future.value <- base::withVisible(base::local({
[16:20:34.354]                 ...future.makeSendCondition <- base::local({
[16:20:34.354]                   sendCondition <- NULL
[16:20:34.354]                   function(frame = 1L) {
[16:20:34.354]                     if (is.function(sendCondition)) 
[16:20:34.354]                       return(sendCondition)
[16:20:34.354]                     ns <- getNamespace("parallel")
[16:20:34.354]                     if (exists("sendData", mode = "function", 
[16:20:34.354]                       envir = ns)) {
[16:20:34.354]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:34.354]                         envir = ns)
[16:20:34.354]                       envir <- sys.frame(frame)
[16:20:34.354]                       master <- NULL
[16:20:34.354]                       while (!identical(envir, .GlobalEnv) && 
[16:20:34.354]                         !identical(envir, emptyenv())) {
[16:20:34.354]                         if (exists("master", mode = "list", envir = envir, 
[16:20:34.354]                           inherits = FALSE)) {
[16:20:34.354]                           master <- get("master", mode = "list", 
[16:20:34.354]                             envir = envir, inherits = FALSE)
[16:20:34.354]                           if (inherits(master, c("SOCKnode", 
[16:20:34.354]                             "SOCK0node"))) {
[16:20:34.354]                             sendCondition <<- function(cond) {
[16:20:34.354]                               data <- list(type = "VALUE", value = cond, 
[16:20:34.354]                                 success = TRUE)
[16:20:34.354]                               parallel_sendData(master, data)
[16:20:34.354]                             }
[16:20:34.354]                             return(sendCondition)
[16:20:34.354]                           }
[16:20:34.354]                         }
[16:20:34.354]                         frame <- frame + 1L
[16:20:34.354]                         envir <- sys.frame(frame)
[16:20:34.354]                       }
[16:20:34.354]                     }
[16:20:34.354]                     sendCondition <<- function(cond) NULL
[16:20:34.354]                   }
[16:20:34.354]                 })
[16:20:34.354]                 withCallingHandlers({
[16:20:34.354]                   {
[16:20:34.354]                     if (ii%%2 == 0) 
[16:20:34.354]                       stop("Woops!")
[16:20:34.354]                     ii
[16:20:34.354]                   }
[16:20:34.354]                 }, immediateCondition = function(cond) {
[16:20:34.354]                   sendCondition <- ...future.makeSendCondition()
[16:20:34.354]                   sendCondition(cond)
[16:20:34.354]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.354]                   {
[16:20:34.354]                     inherits <- base::inherits
[16:20:34.354]                     invokeRestart <- base::invokeRestart
[16:20:34.354]                     is.null <- base::is.null
[16:20:34.354]                     muffled <- FALSE
[16:20:34.354]                     if (inherits(cond, "message")) {
[16:20:34.354]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:34.354]                       if (muffled) 
[16:20:34.354]                         invokeRestart("muffleMessage")
[16:20:34.354]                     }
[16:20:34.354]                     else if (inherits(cond, "warning")) {
[16:20:34.354]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:34.354]                       if (muffled) 
[16:20:34.354]                         invokeRestart("muffleWarning")
[16:20:34.354]                     }
[16:20:34.354]                     else if (inherits(cond, "condition")) {
[16:20:34.354]                       if (!is.null(pattern)) {
[16:20:34.354]                         computeRestarts <- base::computeRestarts
[16:20:34.354]                         grepl <- base::grepl
[16:20:34.354]                         restarts <- computeRestarts(cond)
[16:20:34.354]                         for (restart in restarts) {
[16:20:34.354]                           name <- restart$name
[16:20:34.354]                           if (is.null(name)) 
[16:20:34.354]                             next
[16:20:34.354]                           if (!grepl(pattern, name)) 
[16:20:34.354]                             next
[16:20:34.354]                           invokeRestart(restart)
[16:20:34.354]                           muffled <- TRUE
[16:20:34.354]                           break
[16:20:34.354]                         }
[16:20:34.354]                       }
[16:20:34.354]                     }
[16:20:34.354]                     invisible(muffled)
[16:20:34.354]                   }
[16:20:34.354]                   muffleCondition(cond)
[16:20:34.354]                 })
[16:20:34.354]             }))
[16:20:34.354]             future::FutureResult(value = ...future.value$value, 
[16:20:34.354]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.354]                   ...future.rng), globalenv = if (FALSE) 
[16:20:34.354]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:34.354]                     ...future.globalenv.names))
[16:20:34.354]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:34.354]         }, condition = base::local({
[16:20:34.354]             c <- base::c
[16:20:34.354]             inherits <- base::inherits
[16:20:34.354]             invokeRestart <- base::invokeRestart
[16:20:34.354]             length <- base::length
[16:20:34.354]             list <- base::list
[16:20:34.354]             seq.int <- base::seq.int
[16:20:34.354]             signalCondition <- base::signalCondition
[16:20:34.354]             sys.calls <- base::sys.calls
[16:20:34.354]             `[[` <- base::`[[`
[16:20:34.354]             `+` <- base::`+`
[16:20:34.354]             `<<-` <- base::`<<-`
[16:20:34.354]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:34.354]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:34.354]                   3L)]
[16:20:34.354]             }
[16:20:34.354]             function(cond) {
[16:20:34.354]                 is_error <- inherits(cond, "error")
[16:20:34.354]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:34.354]                   NULL)
[16:20:34.354]                 if (is_error) {
[16:20:34.354]                   sessionInformation <- function() {
[16:20:34.354]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:34.354]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:34.354]                       search = base::search(), system = base::Sys.info())
[16:20:34.354]                   }
[16:20:34.354]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.354]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:34.354]                     cond$call), session = sessionInformation(), 
[16:20:34.354]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:34.354]                   signalCondition(cond)
[16:20:34.354]                 }
[16:20:34.354]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:34.354]                 "immediateCondition"))) {
[16:20:34.354]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:34.354]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.354]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:34.354]                   if (TRUE && !signal) {
[16:20:34.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.354]                     {
[16:20:34.354]                       inherits <- base::inherits
[16:20:34.354]                       invokeRestart <- base::invokeRestart
[16:20:34.354]                       is.null <- base::is.null
[16:20:34.354]                       muffled <- FALSE
[16:20:34.354]                       if (inherits(cond, "message")) {
[16:20:34.354]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.354]                         if (muffled) 
[16:20:34.354]                           invokeRestart("muffleMessage")
[16:20:34.354]                       }
[16:20:34.354]                       else if (inherits(cond, "warning")) {
[16:20:34.354]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.354]                         if (muffled) 
[16:20:34.354]                           invokeRestart("muffleWarning")
[16:20:34.354]                       }
[16:20:34.354]                       else if (inherits(cond, "condition")) {
[16:20:34.354]                         if (!is.null(pattern)) {
[16:20:34.354]                           computeRestarts <- base::computeRestarts
[16:20:34.354]                           grepl <- base::grepl
[16:20:34.354]                           restarts <- computeRestarts(cond)
[16:20:34.354]                           for (restart in restarts) {
[16:20:34.354]                             name <- restart$name
[16:20:34.354]                             if (is.null(name)) 
[16:20:34.354]                               next
[16:20:34.354]                             if (!grepl(pattern, name)) 
[16:20:34.354]                               next
[16:20:34.354]                             invokeRestart(restart)
[16:20:34.354]                             muffled <- TRUE
[16:20:34.354]                             break
[16:20:34.354]                           }
[16:20:34.354]                         }
[16:20:34.354]                       }
[16:20:34.354]                       invisible(muffled)
[16:20:34.354]                     }
[16:20:34.354]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.354]                   }
[16:20:34.354]                 }
[16:20:34.354]                 else {
[16:20:34.354]                   if (TRUE) {
[16:20:34.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.354]                     {
[16:20:34.354]                       inherits <- base::inherits
[16:20:34.354]                       invokeRestart <- base::invokeRestart
[16:20:34.354]                       is.null <- base::is.null
[16:20:34.354]                       muffled <- FALSE
[16:20:34.354]                       if (inherits(cond, "message")) {
[16:20:34.354]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.354]                         if (muffled) 
[16:20:34.354]                           invokeRestart("muffleMessage")
[16:20:34.354]                       }
[16:20:34.354]                       else if (inherits(cond, "warning")) {
[16:20:34.354]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.354]                         if (muffled) 
[16:20:34.354]                           invokeRestart("muffleWarning")
[16:20:34.354]                       }
[16:20:34.354]                       else if (inherits(cond, "condition")) {
[16:20:34.354]                         if (!is.null(pattern)) {
[16:20:34.354]                           computeRestarts <- base::computeRestarts
[16:20:34.354]                           grepl <- base::grepl
[16:20:34.354]                           restarts <- computeRestarts(cond)
[16:20:34.354]                           for (restart in restarts) {
[16:20:34.354]                             name <- restart$name
[16:20:34.354]                             if (is.null(name)) 
[16:20:34.354]                               next
[16:20:34.354]                             if (!grepl(pattern, name)) 
[16:20:34.354]                               next
[16:20:34.354]                             invokeRestart(restart)
[16:20:34.354]                             muffled <- TRUE
[16:20:34.354]                             break
[16:20:34.354]                           }
[16:20:34.354]                         }
[16:20:34.354]                       }
[16:20:34.354]                       invisible(muffled)
[16:20:34.354]                     }
[16:20:34.354]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.354]                   }
[16:20:34.354]                 }
[16:20:34.354]             }
[16:20:34.354]         }))
[16:20:34.354]     }, error = function(ex) {
[16:20:34.354]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:34.354]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.354]                 ...future.rng), started = ...future.startTime, 
[16:20:34.354]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:34.354]             version = "1.8"), class = "FutureResult")
[16:20:34.354]     }, finally = {
[16:20:34.354]         if (!identical(...future.workdir, getwd())) 
[16:20:34.354]             setwd(...future.workdir)
[16:20:34.354]         {
[16:20:34.354]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:34.354]                 ...future.oldOptions$nwarnings <- NULL
[16:20:34.354]             }
[16:20:34.354]             base::options(...future.oldOptions)
[16:20:34.354]             if (.Platform$OS.type == "windows") {
[16:20:34.354]                 old_names <- names(...future.oldEnvVars)
[16:20:34.354]                 envs <- base::Sys.getenv()
[16:20:34.354]                 names <- names(envs)
[16:20:34.354]                 common <- intersect(names, old_names)
[16:20:34.354]                 added <- setdiff(names, old_names)
[16:20:34.354]                 removed <- setdiff(old_names, names)
[16:20:34.354]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:34.354]                   envs[common]]
[16:20:34.354]                 NAMES <- toupper(changed)
[16:20:34.354]                 args <- list()
[16:20:34.354]                 for (kk in seq_along(NAMES)) {
[16:20:34.354]                   name <- changed[[kk]]
[16:20:34.354]                   NAME <- NAMES[[kk]]
[16:20:34.354]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.354]                     next
[16:20:34.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.354]                 }
[16:20:34.354]                 NAMES <- toupper(added)
[16:20:34.354]                 for (kk in seq_along(NAMES)) {
[16:20:34.354]                   name <- added[[kk]]
[16:20:34.354]                   NAME <- NAMES[[kk]]
[16:20:34.354]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.354]                     next
[16:20:34.354]                   args[[name]] <- ""
[16:20:34.354]                 }
[16:20:34.354]                 NAMES <- toupper(removed)
[16:20:34.354]                 for (kk in seq_along(NAMES)) {
[16:20:34.354]                   name <- removed[[kk]]
[16:20:34.354]                   NAME <- NAMES[[kk]]
[16:20:34.354]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.354]                     next
[16:20:34.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.354]                 }
[16:20:34.354]                 if (length(args) > 0) 
[16:20:34.354]                   base::do.call(base::Sys.setenv, args = args)
[16:20:34.354]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:34.354]             }
[16:20:34.354]             else {
[16:20:34.354]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:34.354]             }
[16:20:34.354]             {
[16:20:34.354]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:34.354]                   0L) {
[16:20:34.354]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:34.354]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:34.354]                   base::options(opts)
[16:20:34.354]                 }
[16:20:34.354]                 {
[16:20:34.354]                   {
[16:20:34.354]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:34.354]                     NULL
[16:20:34.354]                   }
[16:20:34.354]                   options(future.plan = NULL)
[16:20:34.354]                   if (is.na(NA_character_)) 
[16:20:34.354]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.354]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:34.354]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:34.354]                     .init = FALSE)
[16:20:34.354]                 }
[16:20:34.354]             }
[16:20:34.354]         }
[16:20:34.354]     })
[16:20:34.354]     if (TRUE) {
[16:20:34.354]         base::sink(type = "output", split = FALSE)
[16:20:34.354]         if (TRUE) {
[16:20:34.354]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:34.354]         }
[16:20:34.354]         else {
[16:20:34.354]             ...future.result["stdout"] <- base::list(NULL)
[16:20:34.354]         }
[16:20:34.354]         base::close(...future.stdout)
[16:20:34.354]         ...future.stdout <- NULL
[16:20:34.354]     }
[16:20:34.354]     ...future.result$conditions <- ...future.conditions
[16:20:34.354]     ...future.result$finished <- base::Sys.time()
[16:20:34.354]     ...future.result
[16:20:34.354] }
[16:20:34.356] Poll #1 (0): usedNodes() = 2, workers = 2
[16:20:34.376] receiveMessageFromWorker() for ClusterFuture ...
[16:20:34.376] - Validating connection of MultisessionFuture
[16:20:34.376] - received message: FutureResult
[16:20:34.376] - Received FutureResult
[16:20:34.376] - Erased future from FutureRegistry
[16:20:34.376] result() for ClusterFuture ...
[16:20:34.376] - result already collected: FutureResult
[16:20:34.377] result() for ClusterFuture ... done
[16:20:34.377] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:34.377] result() for ClusterFuture ...
[16:20:34.377] - result already collected: FutureResult
[16:20:34.377] result() for ClusterFuture ... done
[16:20:34.377] result() for ClusterFuture ...
[16:20:34.377] - result already collected: FutureResult
[16:20:34.377] result() for ClusterFuture ... done
[16:20:34.378] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:20:34.378] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:20:34.378] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:20:34.379] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:20:34.379] MultisessionFuture started
[16:20:34.379] - Launch lazy future ... done
[16:20:34.379] run() for ‘MultisessionFuture’ ... done
[16:20:34.380] result() for ClusterFuture ...
[16:20:34.380] - result already collected: FutureResult
[16:20:34.380] result() for ClusterFuture ... done
[16:20:34.380] result() for ClusterFuture ...
[16:20:34.380] - result already collected: FutureResult
[16:20:34.380] result() for ClusterFuture ... done
[16:20:34.381] result() for ClusterFuture ...
[16:20:34.381] receiveMessageFromWorker() for ClusterFuture ...
[16:20:34.381] - Validating connection of MultisessionFuture
[16:20:34.382] - received message: FutureResult
[16:20:34.382] - Received FutureResult
[16:20:34.382] - Erased future from FutureRegistry
[16:20:34.382] result() for ClusterFuture ...
[16:20:34.382] - result already collected: FutureResult
[16:20:34.382] result() for ClusterFuture ... done
[16:20:34.382] signalConditions() ...
[16:20:34.382]  - include = ‘immediateCondition’
[16:20:34.382]  - exclude = 
[16:20:34.383]  - resignal = FALSE
[16:20:34.383]  - Number of conditions: 1
[16:20:34.383] signalConditions() ... done
[16:20:34.383] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:34.383] result() for ClusterFuture ... done
[16:20:34.383] result() for ClusterFuture ...
[16:20:34.383] - result already collected: FutureResult
[16:20:34.383] result() for ClusterFuture ... done
[16:20:34.383] signalConditions() ...
[16:20:34.383]  - include = ‘immediateCondition’
[16:20:34.383]  - exclude = 
[16:20:34.384]  - resignal = FALSE
[16:20:34.384]  - Number of conditions: 1
[16:20:34.384] signalConditions() ... done
[16:20:34.384] Future state: ‘finished’
[16:20:34.384] result() for ClusterFuture ...
[16:20:34.384] - result already collected: FutureResult
[16:20:34.384] result() for ClusterFuture ... done
[16:20:34.384] signalConditions() ...
[16:20:34.384]  - include = ‘condition’
[16:20:34.384]  - exclude = ‘immediateCondition’
[16:20:34.385]  - resignal = TRUE
[16:20:34.385]  - Number of conditions: 1
[16:20:34.385]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:20:34.385] signalConditions() ... done
[16:20:34.385] result() for ClusterFuture ...
[16:20:34.385] receiveMessageFromWorker() for ClusterFuture ...
[16:20:34.385] - Validating connection of MultisessionFuture
[16:20:34.386] - received message: FutureResult
[16:20:34.386] - Received FutureResult
[16:20:34.386] - Erased future from FutureRegistry
[16:20:34.386] result() for ClusterFuture ...
[16:20:34.386] - result already collected: FutureResult
[16:20:34.386] result() for ClusterFuture ... done
[16:20:34.386] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:34.386] result() for ClusterFuture ... done
[16:20:34.386] result() for ClusterFuture ...
[16:20:34.386] - result already collected: FutureResult
[16:20:34.386] result() for ClusterFuture ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[16:20:34.387] result() for ClusterFuture ...
[16:20:34.387] - result already collected: FutureResult
[16:20:34.387] result() for ClusterFuture ... done
[16:20:34.387] result() for ClusterFuture ...
[16:20:34.387] - result already collected: FutureResult
[16:20:34.387] result() for ClusterFuture ... done
[16:20:34.387] signalConditions() ...
[16:20:34.387]  - include = ‘immediateCondition’
[16:20:34.387]  - exclude = 
[16:20:34.388]  - resignal = FALSE
[16:20:34.388]  - Number of conditions: 1
[16:20:34.388] signalConditions() ... done
[16:20:34.388] Future state: ‘finished’
[16:20:34.388] result() for ClusterFuture ...
[16:20:34.388] - result already collected: FutureResult
[16:20:34.388] result() for ClusterFuture ... done
[16:20:34.388] signalConditions() ...
[16:20:34.388]  - include = ‘condition’
[16:20:34.388]  - exclude = ‘immediateCondition’
[16:20:34.389]  - resignal = TRUE
[16:20:34.389]  - Number of conditions: 1
[16:20:34.389]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:20:34.389] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[16:20:34.389] result() for ClusterFuture ...
[16:20:34.389] - result already collected: FutureResult
[16:20:34.389] result() for ClusterFuture ... done
[16:20:34.389] result() for ClusterFuture ...
[16:20:34.389] - result already collected: FutureResult
[16:20:34.390] result() for ClusterFuture ... done
[16:20:34.390] signalConditions() ...
[16:20:34.390]  - include = ‘immediateCondition’
[16:20:34.390]  - exclude = 
[16:20:34.390]  - resignal = FALSE
[16:20:34.390]  - Number of conditions: 1
[16:20:34.390] signalConditions() ... done
[16:20:34.390] Future state: ‘finished’
[16:20:34.390] result() for ClusterFuture ...
[16:20:34.390] - result already collected: FutureResult
[16:20:34.390] result() for ClusterFuture ... done
[16:20:34.391] signalConditions() ...
[16:20:34.391]  - include = ‘condition’
[16:20:34.391]  - exclude = ‘immediateCondition’
[16:20:34.391]  - resignal = TRUE
[16:20:34.391]  - Number of conditions: 1
[16:20:34.391]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:20:34.391] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[16:20:34.391] getGlobalsAndPackages() ...
[16:20:34.391] Searching for globals...
[16:20:34.393] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[16:20:34.394] Searching for globals ... DONE
[16:20:34.394] Resolving globals: FALSE
[16:20:34.394] 
[16:20:34.394] 
[16:20:34.394] getGlobalsAndPackages() ... DONE
[16:20:34.394] run() for ‘Future’ ...
[16:20:34.395] - state: ‘created’
[16:20:34.395] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:34.408] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:34.408] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:34.409]   - Field: ‘node’
[16:20:34.409]   - Field: ‘label’
[16:20:34.409]   - Field: ‘local’
[16:20:34.409]   - Field: ‘owner’
[16:20:34.409]   - Field: ‘envir’
[16:20:34.409]   - Field: ‘workers’
[16:20:34.409]   - Field: ‘packages’
[16:20:34.409]   - Field: ‘gc’
[16:20:34.409]   - Field: ‘conditions’
[16:20:34.409]   - Field: ‘persistent’
[16:20:34.409]   - Field: ‘expr’
[16:20:34.410]   - Field: ‘uuid’
[16:20:34.410]   - Field: ‘seed’
[16:20:34.410]   - Field: ‘version’
[16:20:34.410]   - Field: ‘result’
[16:20:34.410]   - Field: ‘asynchronous’
[16:20:34.410]   - Field: ‘calls’
[16:20:34.410]   - Field: ‘globals’
[16:20:34.410]   - Field: ‘stdout’
[16:20:34.410]   - Field: ‘earlySignal’
[16:20:34.410]   - Field: ‘lazy’
[16:20:34.410]   - Field: ‘state’
[16:20:34.411] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:34.411] - Launch lazy future ...
[16:20:34.411] Packages needed by the future expression (n = 0): <none>
[16:20:34.411] Packages needed by future strategies (n = 0): <none>
[16:20:34.411] {
[16:20:34.411]     {
[16:20:34.411]         {
[16:20:34.411]             ...future.startTime <- base::Sys.time()
[16:20:34.411]             {
[16:20:34.411]                 {
[16:20:34.411]                   {
[16:20:34.411]                     {
[16:20:34.411]                       base::local({
[16:20:34.411]                         has_future <- base::requireNamespace("future", 
[16:20:34.411]                           quietly = TRUE)
[16:20:34.411]                         if (has_future) {
[16:20:34.411]                           ns <- base::getNamespace("future")
[16:20:34.411]                           version <- ns[[".package"]][["version"]]
[16:20:34.411]                           if (is.null(version)) 
[16:20:34.411]                             version <- utils::packageVersion("future")
[16:20:34.411]                         }
[16:20:34.411]                         else {
[16:20:34.411]                           version <- NULL
[16:20:34.411]                         }
[16:20:34.411]                         if (!has_future || version < "1.8.0") {
[16:20:34.411]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:34.411]                             "", base::R.version$version.string), 
[16:20:34.411]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:34.411]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:34.411]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:34.411]                               "release", "version")], collapse = " "), 
[16:20:34.411]                             hostname = base::Sys.info()[["nodename"]])
[16:20:34.411]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:34.411]                             info)
[16:20:34.411]                           info <- base::paste(info, collapse = "; ")
[16:20:34.411]                           if (!has_future) {
[16:20:34.411]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:34.411]                               info)
[16:20:34.411]                           }
[16:20:34.411]                           else {
[16:20:34.411]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:34.411]                               info, version)
[16:20:34.411]                           }
[16:20:34.411]                           base::stop(msg)
[16:20:34.411]                         }
[16:20:34.411]                       })
[16:20:34.411]                     }
[16:20:34.411]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:34.411]                     base::options(mc.cores = 1L)
[16:20:34.411]                   }
[16:20:34.411]                   ...future.strategy.old <- future::plan("list")
[16:20:34.411]                   options(future.plan = NULL)
[16:20:34.411]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.411]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:34.411]                 }
[16:20:34.411]                 ...future.workdir <- getwd()
[16:20:34.411]             }
[16:20:34.411]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:34.411]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:34.411]         }
[16:20:34.411]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:34.411]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:34.411]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:34.411]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:34.411]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:34.411]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:34.411]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:34.411]             base::names(...future.oldOptions))
[16:20:34.411]     }
[16:20:34.411]     if (FALSE) {
[16:20:34.411]     }
[16:20:34.411]     else {
[16:20:34.411]         if (TRUE) {
[16:20:34.411]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:34.411]                 open = "w")
[16:20:34.411]         }
[16:20:34.411]         else {
[16:20:34.411]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:34.411]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:34.411]         }
[16:20:34.411]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:34.411]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:34.411]             base::sink(type = "output", split = FALSE)
[16:20:34.411]             base::close(...future.stdout)
[16:20:34.411]         }, add = TRUE)
[16:20:34.411]     }
[16:20:34.411]     ...future.frame <- base::sys.nframe()
[16:20:34.411]     ...future.conditions <- base::list()
[16:20:34.411]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:34.411]     if (FALSE) {
[16:20:34.411]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:34.411]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:34.411]     }
[16:20:34.411]     ...future.result <- base::tryCatch({
[16:20:34.411]         base::withCallingHandlers({
[16:20:34.411]             ...future.value <- base::withVisible(base::local({
[16:20:34.411]                 ...future.makeSendCondition <- base::local({
[16:20:34.411]                   sendCondition <- NULL
[16:20:34.411]                   function(frame = 1L) {
[16:20:34.411]                     if (is.function(sendCondition)) 
[16:20:34.411]                       return(sendCondition)
[16:20:34.411]                     ns <- getNamespace("parallel")
[16:20:34.411]                     if (exists("sendData", mode = "function", 
[16:20:34.411]                       envir = ns)) {
[16:20:34.411]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:34.411]                         envir = ns)
[16:20:34.411]                       envir <- sys.frame(frame)
[16:20:34.411]                       master <- NULL
[16:20:34.411]                       while (!identical(envir, .GlobalEnv) && 
[16:20:34.411]                         !identical(envir, emptyenv())) {
[16:20:34.411]                         if (exists("master", mode = "list", envir = envir, 
[16:20:34.411]                           inherits = FALSE)) {
[16:20:34.411]                           master <- get("master", mode = "list", 
[16:20:34.411]                             envir = envir, inherits = FALSE)
[16:20:34.411]                           if (inherits(master, c("SOCKnode", 
[16:20:34.411]                             "SOCK0node"))) {
[16:20:34.411]                             sendCondition <<- function(cond) {
[16:20:34.411]                               data <- list(type = "VALUE", value = cond, 
[16:20:34.411]                                 success = TRUE)
[16:20:34.411]                               parallel_sendData(master, data)
[16:20:34.411]                             }
[16:20:34.411]                             return(sendCondition)
[16:20:34.411]                           }
[16:20:34.411]                         }
[16:20:34.411]                         frame <- frame + 1L
[16:20:34.411]                         envir <- sys.frame(frame)
[16:20:34.411]                       }
[16:20:34.411]                     }
[16:20:34.411]                     sendCondition <<- function(cond) NULL
[16:20:34.411]                   }
[16:20:34.411]                 })
[16:20:34.411]                 withCallingHandlers({
[16:20:34.411]                   {
[16:20:34.411]                     cat("Processing: ")
[16:20:34.411]                     for (ii in 1:10) {
[16:20:34.411]                       cat(".")
[16:20:34.411]                     }
[16:20:34.411]                     cat(" [100%]\n")
[16:20:34.411]                     4
[16:20:34.411]                   }
[16:20:34.411]                 }, immediateCondition = function(cond) {
[16:20:34.411]                   sendCondition <- ...future.makeSendCondition()
[16:20:34.411]                   sendCondition(cond)
[16:20:34.411]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.411]                   {
[16:20:34.411]                     inherits <- base::inherits
[16:20:34.411]                     invokeRestart <- base::invokeRestart
[16:20:34.411]                     is.null <- base::is.null
[16:20:34.411]                     muffled <- FALSE
[16:20:34.411]                     if (inherits(cond, "message")) {
[16:20:34.411]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:34.411]                       if (muffled) 
[16:20:34.411]                         invokeRestart("muffleMessage")
[16:20:34.411]                     }
[16:20:34.411]                     else if (inherits(cond, "warning")) {
[16:20:34.411]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:34.411]                       if (muffled) 
[16:20:34.411]                         invokeRestart("muffleWarning")
[16:20:34.411]                     }
[16:20:34.411]                     else if (inherits(cond, "condition")) {
[16:20:34.411]                       if (!is.null(pattern)) {
[16:20:34.411]                         computeRestarts <- base::computeRestarts
[16:20:34.411]                         grepl <- base::grepl
[16:20:34.411]                         restarts <- computeRestarts(cond)
[16:20:34.411]                         for (restart in restarts) {
[16:20:34.411]                           name <- restart$name
[16:20:34.411]                           if (is.null(name)) 
[16:20:34.411]                             next
[16:20:34.411]                           if (!grepl(pattern, name)) 
[16:20:34.411]                             next
[16:20:34.411]                           invokeRestart(restart)
[16:20:34.411]                           muffled <- TRUE
[16:20:34.411]                           break
[16:20:34.411]                         }
[16:20:34.411]                       }
[16:20:34.411]                     }
[16:20:34.411]                     invisible(muffled)
[16:20:34.411]                   }
[16:20:34.411]                   muffleCondition(cond)
[16:20:34.411]                 })
[16:20:34.411]             }))
[16:20:34.411]             future::FutureResult(value = ...future.value$value, 
[16:20:34.411]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.411]                   ...future.rng), globalenv = if (FALSE) 
[16:20:34.411]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:34.411]                     ...future.globalenv.names))
[16:20:34.411]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:34.411]         }, condition = base::local({
[16:20:34.411]             c <- base::c
[16:20:34.411]             inherits <- base::inherits
[16:20:34.411]             invokeRestart <- base::invokeRestart
[16:20:34.411]             length <- base::length
[16:20:34.411]             list <- base::list
[16:20:34.411]             seq.int <- base::seq.int
[16:20:34.411]             signalCondition <- base::signalCondition
[16:20:34.411]             sys.calls <- base::sys.calls
[16:20:34.411]             `[[` <- base::`[[`
[16:20:34.411]             `+` <- base::`+`
[16:20:34.411]             `<<-` <- base::`<<-`
[16:20:34.411]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:34.411]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:34.411]                   3L)]
[16:20:34.411]             }
[16:20:34.411]             function(cond) {
[16:20:34.411]                 is_error <- inherits(cond, "error")
[16:20:34.411]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:34.411]                   NULL)
[16:20:34.411]                 if (is_error) {
[16:20:34.411]                   sessionInformation <- function() {
[16:20:34.411]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:34.411]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:34.411]                       search = base::search(), system = base::Sys.info())
[16:20:34.411]                   }
[16:20:34.411]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.411]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:34.411]                     cond$call), session = sessionInformation(), 
[16:20:34.411]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:34.411]                   signalCondition(cond)
[16:20:34.411]                 }
[16:20:34.411]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:34.411]                 "immediateCondition"))) {
[16:20:34.411]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:34.411]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.411]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:34.411]                   if (TRUE && !signal) {
[16:20:34.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.411]                     {
[16:20:34.411]                       inherits <- base::inherits
[16:20:34.411]                       invokeRestart <- base::invokeRestart
[16:20:34.411]                       is.null <- base::is.null
[16:20:34.411]                       muffled <- FALSE
[16:20:34.411]                       if (inherits(cond, "message")) {
[16:20:34.411]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.411]                         if (muffled) 
[16:20:34.411]                           invokeRestart("muffleMessage")
[16:20:34.411]                       }
[16:20:34.411]                       else if (inherits(cond, "warning")) {
[16:20:34.411]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.411]                         if (muffled) 
[16:20:34.411]                           invokeRestart("muffleWarning")
[16:20:34.411]                       }
[16:20:34.411]                       else if (inherits(cond, "condition")) {
[16:20:34.411]                         if (!is.null(pattern)) {
[16:20:34.411]                           computeRestarts <- base::computeRestarts
[16:20:34.411]                           grepl <- base::grepl
[16:20:34.411]                           restarts <- computeRestarts(cond)
[16:20:34.411]                           for (restart in restarts) {
[16:20:34.411]                             name <- restart$name
[16:20:34.411]                             if (is.null(name)) 
[16:20:34.411]                               next
[16:20:34.411]                             if (!grepl(pattern, name)) 
[16:20:34.411]                               next
[16:20:34.411]                             invokeRestart(restart)
[16:20:34.411]                             muffled <- TRUE
[16:20:34.411]                             break
[16:20:34.411]                           }
[16:20:34.411]                         }
[16:20:34.411]                       }
[16:20:34.411]                       invisible(muffled)
[16:20:34.411]                     }
[16:20:34.411]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.411]                   }
[16:20:34.411]                 }
[16:20:34.411]                 else {
[16:20:34.411]                   if (TRUE) {
[16:20:34.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.411]                     {
[16:20:34.411]                       inherits <- base::inherits
[16:20:34.411]                       invokeRestart <- base::invokeRestart
[16:20:34.411]                       is.null <- base::is.null
[16:20:34.411]                       muffled <- FALSE
[16:20:34.411]                       if (inherits(cond, "message")) {
[16:20:34.411]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.411]                         if (muffled) 
[16:20:34.411]                           invokeRestart("muffleMessage")
[16:20:34.411]                       }
[16:20:34.411]                       else if (inherits(cond, "warning")) {
[16:20:34.411]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.411]                         if (muffled) 
[16:20:34.411]                           invokeRestart("muffleWarning")
[16:20:34.411]                       }
[16:20:34.411]                       else if (inherits(cond, "condition")) {
[16:20:34.411]                         if (!is.null(pattern)) {
[16:20:34.411]                           computeRestarts <- base::computeRestarts
[16:20:34.411]                           grepl <- base::grepl
[16:20:34.411]                           restarts <- computeRestarts(cond)
[16:20:34.411]                           for (restart in restarts) {
[16:20:34.411]                             name <- restart$name
[16:20:34.411]                             if (is.null(name)) 
[16:20:34.411]                               next
[16:20:34.411]                             if (!grepl(pattern, name)) 
[16:20:34.411]                               next
[16:20:34.411]                             invokeRestart(restart)
[16:20:34.411]                             muffled <- TRUE
[16:20:34.411]                             break
[16:20:34.411]                           }
[16:20:34.411]                         }
[16:20:34.411]                       }
[16:20:34.411]                       invisible(muffled)
[16:20:34.411]                     }
[16:20:34.411]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.411]                   }
[16:20:34.411]                 }
[16:20:34.411]             }
[16:20:34.411]         }))
[16:20:34.411]     }, error = function(ex) {
[16:20:34.411]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:34.411]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.411]                 ...future.rng), started = ...future.startTime, 
[16:20:34.411]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:34.411]             version = "1.8"), class = "FutureResult")
[16:20:34.411]     }, finally = {
[16:20:34.411]         if (!identical(...future.workdir, getwd())) 
[16:20:34.411]             setwd(...future.workdir)
[16:20:34.411]         {
[16:20:34.411]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:34.411]                 ...future.oldOptions$nwarnings <- NULL
[16:20:34.411]             }
[16:20:34.411]             base::options(...future.oldOptions)
[16:20:34.411]             if (.Platform$OS.type == "windows") {
[16:20:34.411]                 old_names <- names(...future.oldEnvVars)
[16:20:34.411]                 envs <- base::Sys.getenv()
[16:20:34.411]                 names <- names(envs)
[16:20:34.411]                 common <- intersect(names, old_names)
[16:20:34.411]                 added <- setdiff(names, old_names)
[16:20:34.411]                 removed <- setdiff(old_names, names)
[16:20:34.411]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:34.411]                   envs[common]]
[16:20:34.411]                 NAMES <- toupper(changed)
[16:20:34.411]                 args <- list()
[16:20:34.411]                 for (kk in seq_along(NAMES)) {
[16:20:34.411]                   name <- changed[[kk]]
[16:20:34.411]                   NAME <- NAMES[[kk]]
[16:20:34.411]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.411]                     next
[16:20:34.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.411]                 }
[16:20:34.411]                 NAMES <- toupper(added)
[16:20:34.411]                 for (kk in seq_along(NAMES)) {
[16:20:34.411]                   name <- added[[kk]]
[16:20:34.411]                   NAME <- NAMES[[kk]]
[16:20:34.411]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.411]                     next
[16:20:34.411]                   args[[name]] <- ""
[16:20:34.411]                 }
[16:20:34.411]                 NAMES <- toupper(removed)
[16:20:34.411]                 for (kk in seq_along(NAMES)) {
[16:20:34.411]                   name <- removed[[kk]]
[16:20:34.411]                   NAME <- NAMES[[kk]]
[16:20:34.411]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.411]                     next
[16:20:34.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.411]                 }
[16:20:34.411]                 if (length(args) > 0) 
[16:20:34.411]                   base::do.call(base::Sys.setenv, args = args)
[16:20:34.411]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:34.411]             }
[16:20:34.411]             else {
[16:20:34.411]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:34.411]             }
[16:20:34.411]             {
[16:20:34.411]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:34.411]                   0L) {
[16:20:34.411]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:34.411]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:34.411]                   base::options(opts)
[16:20:34.411]                 }
[16:20:34.411]                 {
[16:20:34.411]                   {
[16:20:34.411]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:34.411]                     NULL
[16:20:34.411]                   }
[16:20:34.411]                   options(future.plan = NULL)
[16:20:34.411]                   if (is.na(NA_character_)) 
[16:20:34.411]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.411]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:34.411]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:34.411]                     .init = FALSE)
[16:20:34.411]                 }
[16:20:34.411]             }
[16:20:34.411]         }
[16:20:34.411]     })
[16:20:34.411]     if (TRUE) {
[16:20:34.411]         base::sink(type = "output", split = FALSE)
[16:20:34.411]         if (TRUE) {
[16:20:34.411]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:34.411]         }
[16:20:34.411]         else {
[16:20:34.411]             ...future.result["stdout"] <- base::list(NULL)
[16:20:34.411]         }
[16:20:34.411]         base::close(...future.stdout)
[16:20:34.411]         ...future.stdout <- NULL
[16:20:34.411]     }
[16:20:34.411]     ...future.result$conditions <- ...future.conditions
[16:20:34.411]     ...future.result$finished <- base::Sys.time()
[16:20:34.411]     ...future.result
[16:20:34.411] }
[16:20:34.414] MultisessionFuture started
[16:20:34.415] - Launch lazy future ... done
[16:20:34.415] run() for ‘MultisessionFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[16:20:34.415] result() for ClusterFuture ...
[16:20:34.415] - result already collected: FutureResult
[16:20:34.416] result() for ClusterFuture ... done
[16:20:34.416] result() for ClusterFuture ...
[16:20:34.416] - result already collected: FutureResult
[16:20:34.416] result() for ClusterFuture ... done
[16:20:34.416] signalConditions() ...
[16:20:34.416]  - include = ‘immediateCondition’
[16:20:34.416]  - exclude = 
[16:20:34.417]  - resignal = FALSE
[16:20:34.417]  - Number of conditions: 1
[16:20:34.417] signalConditions() ... done
[16:20:34.417] Future state: ‘finished’
[16:20:34.417] result() for ClusterFuture ...
[16:20:34.417] - result already collected: FutureResult
[16:20:34.417] result() for ClusterFuture ... done
[16:20:34.417] signalConditions() ...
[16:20:34.418]  - include = ‘condition’
[16:20:34.418]  - exclude = ‘immediateCondition’
[16:20:34.418]  - resignal = TRUE
[16:20:34.418]  - Number of conditions: 1
[16:20:34.418]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:20:34.418] signalConditions() ... done
v3: <simpleError> (as expect)
[16:20:34.418] result() for ClusterFuture ...
[16:20:34.418] receiveMessageFromWorker() for ClusterFuture ...
[16:20:34.418] - Validating connection of MultisessionFuture
[16:20:34.419] - received message: FutureResult
[16:20:34.419] - Received FutureResult
[16:20:34.419] - Erased future from FutureRegistry
[16:20:34.419] result() for ClusterFuture ...
[16:20:34.419] - result already collected: FutureResult
[16:20:34.419] result() for ClusterFuture ... done
[16:20:34.419] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:34.419] result() for ClusterFuture ... done
[16:20:34.419] result() for ClusterFuture ...
[16:20:34.419] - result already collected: FutureResult
[16:20:34.419] result() for ClusterFuture ... done
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[16:20:34.420] getGlobalsAndPackages() ...
[16:20:34.420] Searching for globals...
[16:20:34.420] 
[16:20:34.420] Searching for globals ... DONE
[16:20:34.420] - globals: [0] <none>
[16:20:34.421] getGlobalsAndPackages() ... DONE
[16:20:34.421] run() for ‘Future’ ...
[16:20:34.421] - state: ‘created’
[16:20:34.421] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:34.434] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:34.435] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:34.435]   - Field: ‘node’
[16:20:34.435]   - Field: ‘label’
[16:20:34.435]   - Field: ‘local’
[16:20:34.435]   - Field: ‘owner’
[16:20:34.435]   - Field: ‘envir’
[16:20:34.435]   - Field: ‘workers’
[16:20:34.435]   - Field: ‘packages’
[16:20:34.435]   - Field: ‘gc’
[16:20:34.435]   - Field: ‘conditions’
[16:20:34.436]   - Field: ‘persistent’
[16:20:34.436]   - Field: ‘expr’
[16:20:34.436]   - Field: ‘uuid’
[16:20:34.436]   - Field: ‘seed’
[16:20:34.436]   - Field: ‘version’
[16:20:34.436]   - Field: ‘result’
[16:20:34.436]   - Field: ‘asynchronous’
[16:20:34.436]   - Field: ‘calls’
[16:20:34.436]   - Field: ‘globals’
[16:20:34.436]   - Field: ‘stdout’
[16:20:34.437]   - Field: ‘earlySignal’
[16:20:34.437]   - Field: ‘lazy’
[16:20:34.437]   - Field: ‘state’
[16:20:34.437] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:34.437] - Launch lazy future ...
[16:20:34.437] Packages needed by the future expression (n = 0): <none>
[16:20:34.437] Packages needed by future strategies (n = 0): <none>
[16:20:34.440] {
[16:20:34.440]     {
[16:20:34.440]         {
[16:20:34.440]             ...future.startTime <- base::Sys.time()
[16:20:34.440]             {
[16:20:34.440]                 {
[16:20:34.440]                   {
[16:20:34.440]                     {
[16:20:34.440]                       base::local({
[16:20:34.440]                         has_future <- base::requireNamespace("future", 
[16:20:34.440]                           quietly = TRUE)
[16:20:34.440]                         if (has_future) {
[16:20:34.440]                           ns <- base::getNamespace("future")
[16:20:34.440]                           version <- ns[[".package"]][["version"]]
[16:20:34.440]                           if (is.null(version)) 
[16:20:34.440]                             version <- utils::packageVersion("future")
[16:20:34.440]                         }
[16:20:34.440]                         else {
[16:20:34.440]                           version <- NULL
[16:20:34.440]                         }
[16:20:34.440]                         if (!has_future || version < "1.8.0") {
[16:20:34.440]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:34.440]                             "", base::R.version$version.string), 
[16:20:34.440]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:34.440]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:34.440]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:34.440]                               "release", "version")], collapse = " "), 
[16:20:34.440]                             hostname = base::Sys.info()[["nodename"]])
[16:20:34.440]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:34.440]                             info)
[16:20:34.440]                           info <- base::paste(info, collapse = "; ")
[16:20:34.440]                           if (!has_future) {
[16:20:34.440]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:34.440]                               info)
[16:20:34.440]                           }
[16:20:34.440]                           else {
[16:20:34.440]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:34.440]                               info, version)
[16:20:34.440]                           }
[16:20:34.440]                           base::stop(msg)
[16:20:34.440]                         }
[16:20:34.440]                       })
[16:20:34.440]                     }
[16:20:34.440]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:34.440]                     base::options(mc.cores = 1L)
[16:20:34.440]                   }
[16:20:34.440]                   ...future.strategy.old <- future::plan("list")
[16:20:34.440]                   options(future.plan = NULL)
[16:20:34.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:34.440]                 }
[16:20:34.440]                 ...future.workdir <- getwd()
[16:20:34.440]             }
[16:20:34.440]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:34.440]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:34.440]         }
[16:20:34.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:34.440]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:34.440]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:34.440]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:34.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:34.440]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:34.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:34.440]             base::names(...future.oldOptions))
[16:20:34.440]     }
[16:20:34.440]     if (FALSE) {
[16:20:34.440]     }
[16:20:34.440]     else {
[16:20:34.440]         if (TRUE) {
[16:20:34.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:34.440]                 open = "w")
[16:20:34.440]         }
[16:20:34.440]         else {
[16:20:34.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:34.440]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:34.440]         }
[16:20:34.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:34.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:34.440]             base::sink(type = "output", split = FALSE)
[16:20:34.440]             base::close(...future.stdout)
[16:20:34.440]         }, add = TRUE)
[16:20:34.440]     }
[16:20:34.440]     ...future.frame <- base::sys.nframe()
[16:20:34.440]     ...future.conditions <- base::list()
[16:20:34.440]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:34.440]     if (FALSE) {
[16:20:34.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:34.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:34.440]     }
[16:20:34.440]     ...future.result <- base::tryCatch({
[16:20:34.440]         base::withCallingHandlers({
[16:20:34.440]             ...future.value <- base::withVisible(base::local({
[16:20:34.440]                 ...future.makeSendCondition <- base::local({
[16:20:34.440]                   sendCondition <- NULL
[16:20:34.440]                   function(frame = 1L) {
[16:20:34.440]                     if (is.function(sendCondition)) 
[16:20:34.440]                       return(sendCondition)
[16:20:34.440]                     ns <- getNamespace("parallel")
[16:20:34.440]                     if (exists("sendData", mode = "function", 
[16:20:34.440]                       envir = ns)) {
[16:20:34.440]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:34.440]                         envir = ns)
[16:20:34.440]                       envir <- sys.frame(frame)
[16:20:34.440]                       master <- NULL
[16:20:34.440]                       while (!identical(envir, .GlobalEnv) && 
[16:20:34.440]                         !identical(envir, emptyenv())) {
[16:20:34.440]                         if (exists("master", mode = "list", envir = envir, 
[16:20:34.440]                           inherits = FALSE)) {
[16:20:34.440]                           master <- get("master", mode = "list", 
[16:20:34.440]                             envir = envir, inherits = FALSE)
[16:20:34.440]                           if (inherits(master, c("SOCKnode", 
[16:20:34.440]                             "SOCK0node"))) {
[16:20:34.440]                             sendCondition <<- function(cond) {
[16:20:34.440]                               data <- list(type = "VALUE", value = cond, 
[16:20:34.440]                                 success = TRUE)
[16:20:34.440]                               parallel_sendData(master, data)
[16:20:34.440]                             }
[16:20:34.440]                             return(sendCondition)
[16:20:34.440]                           }
[16:20:34.440]                         }
[16:20:34.440]                         frame <- frame + 1L
[16:20:34.440]                         envir <- sys.frame(frame)
[16:20:34.440]                       }
[16:20:34.440]                     }
[16:20:34.440]                     sendCondition <<- function(cond) NULL
[16:20:34.440]                   }
[16:20:34.440]                 })
[16:20:34.440]                 withCallingHandlers({
[16:20:34.440]                   1
[16:20:34.440]                 }, immediateCondition = function(cond) {
[16:20:34.440]                   sendCondition <- ...future.makeSendCondition()
[16:20:34.440]                   sendCondition(cond)
[16:20:34.440]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.440]                   {
[16:20:34.440]                     inherits <- base::inherits
[16:20:34.440]                     invokeRestart <- base::invokeRestart
[16:20:34.440]                     is.null <- base::is.null
[16:20:34.440]                     muffled <- FALSE
[16:20:34.440]                     if (inherits(cond, "message")) {
[16:20:34.440]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:34.440]                       if (muffled) 
[16:20:34.440]                         invokeRestart("muffleMessage")
[16:20:34.440]                     }
[16:20:34.440]                     else if (inherits(cond, "warning")) {
[16:20:34.440]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:34.440]                       if (muffled) 
[16:20:34.440]                         invokeRestart("muffleWarning")
[16:20:34.440]                     }
[16:20:34.440]                     else if (inherits(cond, "condition")) {
[16:20:34.440]                       if (!is.null(pattern)) {
[16:20:34.440]                         computeRestarts <- base::computeRestarts
[16:20:34.440]                         grepl <- base::grepl
[16:20:34.440]                         restarts <- computeRestarts(cond)
[16:20:34.440]                         for (restart in restarts) {
[16:20:34.440]                           name <- restart$name
[16:20:34.440]                           if (is.null(name)) 
[16:20:34.440]                             next
[16:20:34.440]                           if (!grepl(pattern, name)) 
[16:20:34.440]                             next
[16:20:34.440]                           invokeRestart(restart)
[16:20:34.440]                           muffled <- TRUE
[16:20:34.440]                           break
[16:20:34.440]                         }
[16:20:34.440]                       }
[16:20:34.440]                     }
[16:20:34.440]                     invisible(muffled)
[16:20:34.440]                   }
[16:20:34.440]                   muffleCondition(cond)
[16:20:34.440]                 })
[16:20:34.440]             }))
[16:20:34.440]             future::FutureResult(value = ...future.value$value, 
[16:20:34.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.440]                   ...future.rng), globalenv = if (FALSE) 
[16:20:34.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:34.440]                     ...future.globalenv.names))
[16:20:34.440]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:34.440]         }, condition = base::local({
[16:20:34.440]             c <- base::c
[16:20:34.440]             inherits <- base::inherits
[16:20:34.440]             invokeRestart <- base::invokeRestart
[16:20:34.440]             length <- base::length
[16:20:34.440]             list <- base::list
[16:20:34.440]             seq.int <- base::seq.int
[16:20:34.440]             signalCondition <- base::signalCondition
[16:20:34.440]             sys.calls <- base::sys.calls
[16:20:34.440]             `[[` <- base::`[[`
[16:20:34.440]             `+` <- base::`+`
[16:20:34.440]             `<<-` <- base::`<<-`
[16:20:34.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:34.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:34.440]                   3L)]
[16:20:34.440]             }
[16:20:34.440]             function(cond) {
[16:20:34.440]                 is_error <- inherits(cond, "error")
[16:20:34.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:34.440]                   NULL)
[16:20:34.440]                 if (is_error) {
[16:20:34.440]                   sessionInformation <- function() {
[16:20:34.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:34.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:34.440]                       search = base::search(), system = base::Sys.info())
[16:20:34.440]                   }
[16:20:34.440]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:34.440]                     cond$call), session = sessionInformation(), 
[16:20:34.440]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:34.440]                   signalCondition(cond)
[16:20:34.440]                 }
[16:20:34.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:34.440]                 "immediateCondition"))) {
[16:20:34.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:34.440]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:34.440]                   if (TRUE && !signal) {
[16:20:34.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.440]                     {
[16:20:34.440]                       inherits <- base::inherits
[16:20:34.440]                       invokeRestart <- base::invokeRestart
[16:20:34.440]                       is.null <- base::is.null
[16:20:34.440]                       muffled <- FALSE
[16:20:34.440]                       if (inherits(cond, "message")) {
[16:20:34.440]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.440]                         if (muffled) 
[16:20:34.440]                           invokeRestart("muffleMessage")
[16:20:34.440]                       }
[16:20:34.440]                       else if (inherits(cond, "warning")) {
[16:20:34.440]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.440]                         if (muffled) 
[16:20:34.440]                           invokeRestart("muffleWarning")
[16:20:34.440]                       }
[16:20:34.440]                       else if (inherits(cond, "condition")) {
[16:20:34.440]                         if (!is.null(pattern)) {
[16:20:34.440]                           computeRestarts <- base::computeRestarts
[16:20:34.440]                           grepl <- base::grepl
[16:20:34.440]                           restarts <- computeRestarts(cond)
[16:20:34.440]                           for (restart in restarts) {
[16:20:34.440]                             name <- restart$name
[16:20:34.440]                             if (is.null(name)) 
[16:20:34.440]                               next
[16:20:34.440]                             if (!grepl(pattern, name)) 
[16:20:34.440]                               next
[16:20:34.440]                             invokeRestart(restart)
[16:20:34.440]                             muffled <- TRUE
[16:20:34.440]                             break
[16:20:34.440]                           }
[16:20:34.440]                         }
[16:20:34.440]                       }
[16:20:34.440]                       invisible(muffled)
[16:20:34.440]                     }
[16:20:34.440]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.440]                   }
[16:20:34.440]                 }
[16:20:34.440]                 else {
[16:20:34.440]                   if (TRUE) {
[16:20:34.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.440]                     {
[16:20:34.440]                       inherits <- base::inherits
[16:20:34.440]                       invokeRestart <- base::invokeRestart
[16:20:34.440]                       is.null <- base::is.null
[16:20:34.440]                       muffled <- FALSE
[16:20:34.440]                       if (inherits(cond, "message")) {
[16:20:34.440]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.440]                         if (muffled) 
[16:20:34.440]                           invokeRestart("muffleMessage")
[16:20:34.440]                       }
[16:20:34.440]                       else if (inherits(cond, "warning")) {
[16:20:34.440]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.440]                         if (muffled) 
[16:20:34.440]                           invokeRestart("muffleWarning")
[16:20:34.440]                       }
[16:20:34.440]                       else if (inherits(cond, "condition")) {
[16:20:34.440]                         if (!is.null(pattern)) {
[16:20:34.440]                           computeRestarts <- base::computeRestarts
[16:20:34.440]                           grepl <- base::grepl
[16:20:34.440]                           restarts <- computeRestarts(cond)
[16:20:34.440]                           for (restart in restarts) {
[16:20:34.440]                             name <- restart$name
[16:20:34.440]                             if (is.null(name)) 
[16:20:34.440]                               next
[16:20:34.440]                             if (!grepl(pattern, name)) 
[16:20:34.440]                               next
[16:20:34.440]                             invokeRestart(restart)
[16:20:34.440]                             muffled <- TRUE
[16:20:34.440]                             break
[16:20:34.440]                           }
[16:20:34.440]                         }
[16:20:34.440]                       }
[16:20:34.440]                       invisible(muffled)
[16:20:34.440]                     }
[16:20:34.440]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.440]                   }
[16:20:34.440]                 }
[16:20:34.440]             }
[16:20:34.440]         }))
[16:20:34.440]     }, error = function(ex) {
[16:20:34.440]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:34.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.440]                 ...future.rng), started = ...future.startTime, 
[16:20:34.440]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:34.440]             version = "1.8"), class = "FutureResult")
[16:20:34.440]     }, finally = {
[16:20:34.440]         if (!identical(...future.workdir, getwd())) 
[16:20:34.440]             setwd(...future.workdir)
[16:20:34.440]         {
[16:20:34.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:34.440]                 ...future.oldOptions$nwarnings <- NULL
[16:20:34.440]             }
[16:20:34.440]             base::options(...future.oldOptions)
[16:20:34.440]             if (.Platform$OS.type == "windows") {
[16:20:34.440]                 old_names <- names(...future.oldEnvVars)
[16:20:34.440]                 envs <- base::Sys.getenv()
[16:20:34.440]                 names <- names(envs)
[16:20:34.440]                 common <- intersect(names, old_names)
[16:20:34.440]                 added <- setdiff(names, old_names)
[16:20:34.440]                 removed <- setdiff(old_names, names)
[16:20:34.440]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:34.440]                   envs[common]]
[16:20:34.440]                 NAMES <- toupper(changed)
[16:20:34.440]                 args <- list()
[16:20:34.440]                 for (kk in seq_along(NAMES)) {
[16:20:34.440]                   name <- changed[[kk]]
[16:20:34.440]                   NAME <- NAMES[[kk]]
[16:20:34.440]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.440]                     next
[16:20:34.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.440]                 }
[16:20:34.440]                 NAMES <- toupper(added)
[16:20:34.440]                 for (kk in seq_along(NAMES)) {
[16:20:34.440]                   name <- added[[kk]]
[16:20:34.440]                   NAME <- NAMES[[kk]]
[16:20:34.440]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.440]                     next
[16:20:34.440]                   args[[name]] <- ""
[16:20:34.440]                 }
[16:20:34.440]                 NAMES <- toupper(removed)
[16:20:34.440]                 for (kk in seq_along(NAMES)) {
[16:20:34.440]                   name <- removed[[kk]]
[16:20:34.440]                   NAME <- NAMES[[kk]]
[16:20:34.440]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.440]                     next
[16:20:34.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.440]                 }
[16:20:34.440]                 if (length(args) > 0) 
[16:20:34.440]                   base::do.call(base::Sys.setenv, args = args)
[16:20:34.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:34.440]             }
[16:20:34.440]             else {
[16:20:34.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:34.440]             }
[16:20:34.440]             {
[16:20:34.440]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:34.440]                   0L) {
[16:20:34.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:34.440]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:34.440]                   base::options(opts)
[16:20:34.440]                 }
[16:20:34.440]                 {
[16:20:34.440]                   {
[16:20:34.440]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:34.440]                     NULL
[16:20:34.440]                   }
[16:20:34.440]                   options(future.plan = NULL)
[16:20:34.440]                   if (is.na(NA_character_)) 
[16:20:34.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:34.440]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:34.440]                     .init = FALSE)
[16:20:34.440]                 }
[16:20:34.440]             }
[16:20:34.440]         }
[16:20:34.440]     })
[16:20:34.440]     if (TRUE) {
[16:20:34.440]         base::sink(type = "output", split = FALSE)
[16:20:34.440]         if (TRUE) {
[16:20:34.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:34.440]         }
[16:20:34.440]         else {
[16:20:34.440]             ...future.result["stdout"] <- base::list(NULL)
[16:20:34.440]         }
[16:20:34.440]         base::close(...future.stdout)
[16:20:34.440]         ...future.stdout <- NULL
[16:20:34.440]     }
[16:20:34.440]     ...future.result$conditions <- ...future.conditions
[16:20:34.440]     ...future.result$finished <- base::Sys.time()
[16:20:34.440]     ...future.result
[16:20:34.440] }
[16:20:34.443] MultisessionFuture started
[16:20:34.443] - Launch lazy future ... done
[16:20:34.443] run() for ‘MultisessionFuture’ ... done
[16:20:34.443] result() for ClusterFuture ...
[16:20:34.443] receiveMessageFromWorker() for ClusterFuture ...
[16:20:34.443] - Validating connection of MultisessionFuture
[16:20:34.444] - received message: FutureResult
[16:20:34.445] - Received FutureResult
[16:20:34.445] - Erased future from FutureRegistry
[16:20:34.445] result() for ClusterFuture ...
[16:20:34.445] - result already collected: FutureResult
[16:20:34.445] result() for ClusterFuture ... done
[16:20:34.445] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:34.445] result() for ClusterFuture ... done
[16:20:34.445] result() for ClusterFuture ...
[16:20:34.445] - result already collected: FutureResult
[16:20:34.445] result() for ClusterFuture ... done
c = 1
[16:20:34.446] getGlobalsAndPackages() ...
[16:20:34.446] Searching for globals...
[16:20:34.446] 
[16:20:34.446] Searching for globals ... DONE
[16:20:34.446] - globals: [0] <none>
[16:20:34.446] getGlobalsAndPackages() ... DONE
[16:20:34.447] run() for ‘Future’ ...
[16:20:34.447] - state: ‘created’
[16:20:34.447] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:34.460] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:34.460] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:34.460]   - Field: ‘node’
[16:20:34.460]   - Field: ‘label’
[16:20:34.461]   - Field: ‘local’
[16:20:34.461]   - Field: ‘owner’
[16:20:34.461]   - Field: ‘envir’
[16:20:34.461]   - Field: ‘workers’
[16:20:34.461]   - Field: ‘packages’
[16:20:34.461]   - Field: ‘gc’
[16:20:34.461]   - Field: ‘conditions’
[16:20:34.461]   - Field: ‘persistent’
[16:20:34.461]   - Field: ‘expr’
[16:20:34.461]   - Field: ‘uuid’
[16:20:34.461]   - Field: ‘seed’
[16:20:34.462]   - Field: ‘version’
[16:20:34.462]   - Field: ‘result’
[16:20:34.462]   - Field: ‘asynchronous’
[16:20:34.462]   - Field: ‘calls’
[16:20:34.462]   - Field: ‘globals’
[16:20:34.462]   - Field: ‘stdout’
[16:20:34.462]   - Field: ‘earlySignal’
[16:20:34.462]   - Field: ‘lazy’
[16:20:34.462]   - Field: ‘state’
[16:20:34.462] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:34.462] - Launch lazy future ...
[16:20:34.463] Packages needed by the future expression (n = 0): <none>
[16:20:34.463] Packages needed by future strategies (n = 0): <none>
[16:20:34.463] {
[16:20:34.463]     {
[16:20:34.463]         {
[16:20:34.463]             ...future.startTime <- base::Sys.time()
[16:20:34.463]             {
[16:20:34.463]                 {
[16:20:34.463]                   {
[16:20:34.463]                     {
[16:20:34.463]                       base::local({
[16:20:34.463]                         has_future <- base::requireNamespace("future", 
[16:20:34.463]                           quietly = TRUE)
[16:20:34.463]                         if (has_future) {
[16:20:34.463]                           ns <- base::getNamespace("future")
[16:20:34.463]                           version <- ns[[".package"]][["version"]]
[16:20:34.463]                           if (is.null(version)) 
[16:20:34.463]                             version <- utils::packageVersion("future")
[16:20:34.463]                         }
[16:20:34.463]                         else {
[16:20:34.463]                           version <- NULL
[16:20:34.463]                         }
[16:20:34.463]                         if (!has_future || version < "1.8.0") {
[16:20:34.463]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:34.463]                             "", base::R.version$version.string), 
[16:20:34.463]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:34.463]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:34.463]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:34.463]                               "release", "version")], collapse = " "), 
[16:20:34.463]                             hostname = base::Sys.info()[["nodename"]])
[16:20:34.463]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:34.463]                             info)
[16:20:34.463]                           info <- base::paste(info, collapse = "; ")
[16:20:34.463]                           if (!has_future) {
[16:20:34.463]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:34.463]                               info)
[16:20:34.463]                           }
[16:20:34.463]                           else {
[16:20:34.463]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:34.463]                               info, version)
[16:20:34.463]                           }
[16:20:34.463]                           base::stop(msg)
[16:20:34.463]                         }
[16:20:34.463]                       })
[16:20:34.463]                     }
[16:20:34.463]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:34.463]                     base::options(mc.cores = 1L)
[16:20:34.463]                   }
[16:20:34.463]                   ...future.strategy.old <- future::plan("list")
[16:20:34.463]                   options(future.plan = NULL)
[16:20:34.463]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.463]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:34.463]                 }
[16:20:34.463]                 ...future.workdir <- getwd()
[16:20:34.463]             }
[16:20:34.463]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:34.463]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:34.463]         }
[16:20:34.463]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:34.463]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:34.463]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:34.463]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:34.463]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:34.463]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:34.463]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:34.463]             base::names(...future.oldOptions))
[16:20:34.463]     }
[16:20:34.463]     if (FALSE) {
[16:20:34.463]     }
[16:20:34.463]     else {
[16:20:34.463]         if (TRUE) {
[16:20:34.463]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:34.463]                 open = "w")
[16:20:34.463]         }
[16:20:34.463]         else {
[16:20:34.463]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:34.463]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:34.463]         }
[16:20:34.463]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:34.463]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:34.463]             base::sink(type = "output", split = FALSE)
[16:20:34.463]             base::close(...future.stdout)
[16:20:34.463]         }, add = TRUE)
[16:20:34.463]     }
[16:20:34.463]     ...future.frame <- base::sys.nframe()
[16:20:34.463]     ...future.conditions <- base::list()
[16:20:34.463]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:34.463]     if (FALSE) {
[16:20:34.463]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:34.463]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:34.463]     }
[16:20:34.463]     ...future.result <- base::tryCatch({
[16:20:34.463]         base::withCallingHandlers({
[16:20:34.463]             ...future.value <- base::withVisible(base::local({
[16:20:34.463]                 ...future.makeSendCondition <- base::local({
[16:20:34.463]                   sendCondition <- NULL
[16:20:34.463]                   function(frame = 1L) {
[16:20:34.463]                     if (is.function(sendCondition)) 
[16:20:34.463]                       return(sendCondition)
[16:20:34.463]                     ns <- getNamespace("parallel")
[16:20:34.463]                     if (exists("sendData", mode = "function", 
[16:20:34.463]                       envir = ns)) {
[16:20:34.463]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:34.463]                         envir = ns)
[16:20:34.463]                       envir <- sys.frame(frame)
[16:20:34.463]                       master <- NULL
[16:20:34.463]                       while (!identical(envir, .GlobalEnv) && 
[16:20:34.463]                         !identical(envir, emptyenv())) {
[16:20:34.463]                         if (exists("master", mode = "list", envir = envir, 
[16:20:34.463]                           inherits = FALSE)) {
[16:20:34.463]                           master <- get("master", mode = "list", 
[16:20:34.463]                             envir = envir, inherits = FALSE)
[16:20:34.463]                           if (inherits(master, c("SOCKnode", 
[16:20:34.463]                             "SOCK0node"))) {
[16:20:34.463]                             sendCondition <<- function(cond) {
[16:20:34.463]                               data <- list(type = "VALUE", value = cond, 
[16:20:34.463]                                 success = TRUE)
[16:20:34.463]                               parallel_sendData(master, data)
[16:20:34.463]                             }
[16:20:34.463]                             return(sendCondition)
[16:20:34.463]                           }
[16:20:34.463]                         }
[16:20:34.463]                         frame <- frame + 1L
[16:20:34.463]                         envir <- sys.frame(frame)
[16:20:34.463]                       }
[16:20:34.463]                     }
[16:20:34.463]                     sendCondition <<- function(cond) NULL
[16:20:34.463]                   }
[16:20:34.463]                 })
[16:20:34.463]                 withCallingHandlers({
[16:20:34.463]                   1
[16:20:34.463]                 }, immediateCondition = function(cond) {
[16:20:34.463]                   sendCondition <- ...future.makeSendCondition()
[16:20:34.463]                   sendCondition(cond)
[16:20:34.463]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.463]                   {
[16:20:34.463]                     inherits <- base::inherits
[16:20:34.463]                     invokeRestart <- base::invokeRestart
[16:20:34.463]                     is.null <- base::is.null
[16:20:34.463]                     muffled <- FALSE
[16:20:34.463]                     if (inherits(cond, "message")) {
[16:20:34.463]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:34.463]                       if (muffled) 
[16:20:34.463]                         invokeRestart("muffleMessage")
[16:20:34.463]                     }
[16:20:34.463]                     else if (inherits(cond, "warning")) {
[16:20:34.463]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:34.463]                       if (muffled) 
[16:20:34.463]                         invokeRestart("muffleWarning")
[16:20:34.463]                     }
[16:20:34.463]                     else if (inherits(cond, "condition")) {
[16:20:34.463]                       if (!is.null(pattern)) {
[16:20:34.463]                         computeRestarts <- base::computeRestarts
[16:20:34.463]                         grepl <- base::grepl
[16:20:34.463]                         restarts <- computeRestarts(cond)
[16:20:34.463]                         for (restart in restarts) {
[16:20:34.463]                           name <- restart$name
[16:20:34.463]                           if (is.null(name)) 
[16:20:34.463]                             next
[16:20:34.463]                           if (!grepl(pattern, name)) 
[16:20:34.463]                             next
[16:20:34.463]                           invokeRestart(restart)
[16:20:34.463]                           muffled <- TRUE
[16:20:34.463]                           break
[16:20:34.463]                         }
[16:20:34.463]                       }
[16:20:34.463]                     }
[16:20:34.463]                     invisible(muffled)
[16:20:34.463]                   }
[16:20:34.463]                   muffleCondition(cond)
[16:20:34.463]                 })
[16:20:34.463]             }))
[16:20:34.463]             future::FutureResult(value = ...future.value$value, 
[16:20:34.463]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.463]                   ...future.rng), globalenv = if (FALSE) 
[16:20:34.463]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:34.463]                     ...future.globalenv.names))
[16:20:34.463]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:34.463]         }, condition = base::local({
[16:20:34.463]             c <- base::c
[16:20:34.463]             inherits <- base::inherits
[16:20:34.463]             invokeRestart <- base::invokeRestart
[16:20:34.463]             length <- base::length
[16:20:34.463]             list <- base::list
[16:20:34.463]             seq.int <- base::seq.int
[16:20:34.463]             signalCondition <- base::signalCondition
[16:20:34.463]             sys.calls <- base::sys.calls
[16:20:34.463]             `[[` <- base::`[[`
[16:20:34.463]             `+` <- base::`+`
[16:20:34.463]             `<<-` <- base::`<<-`
[16:20:34.463]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:34.463]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:34.463]                   3L)]
[16:20:34.463]             }
[16:20:34.463]             function(cond) {
[16:20:34.463]                 is_error <- inherits(cond, "error")
[16:20:34.463]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:34.463]                   NULL)
[16:20:34.463]                 if (is_error) {
[16:20:34.463]                   sessionInformation <- function() {
[16:20:34.463]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:34.463]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:34.463]                       search = base::search(), system = base::Sys.info())
[16:20:34.463]                   }
[16:20:34.463]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.463]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:34.463]                     cond$call), session = sessionInformation(), 
[16:20:34.463]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:34.463]                   signalCondition(cond)
[16:20:34.463]                 }
[16:20:34.463]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:34.463]                 "immediateCondition"))) {
[16:20:34.463]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:34.463]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.463]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:34.463]                   if (TRUE && !signal) {
[16:20:34.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.463]                     {
[16:20:34.463]                       inherits <- base::inherits
[16:20:34.463]                       invokeRestart <- base::invokeRestart
[16:20:34.463]                       is.null <- base::is.null
[16:20:34.463]                       muffled <- FALSE
[16:20:34.463]                       if (inherits(cond, "message")) {
[16:20:34.463]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.463]                         if (muffled) 
[16:20:34.463]                           invokeRestart("muffleMessage")
[16:20:34.463]                       }
[16:20:34.463]                       else if (inherits(cond, "warning")) {
[16:20:34.463]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.463]                         if (muffled) 
[16:20:34.463]                           invokeRestart("muffleWarning")
[16:20:34.463]                       }
[16:20:34.463]                       else if (inherits(cond, "condition")) {
[16:20:34.463]                         if (!is.null(pattern)) {
[16:20:34.463]                           computeRestarts <- base::computeRestarts
[16:20:34.463]                           grepl <- base::grepl
[16:20:34.463]                           restarts <- computeRestarts(cond)
[16:20:34.463]                           for (restart in restarts) {
[16:20:34.463]                             name <- restart$name
[16:20:34.463]                             if (is.null(name)) 
[16:20:34.463]                               next
[16:20:34.463]                             if (!grepl(pattern, name)) 
[16:20:34.463]                               next
[16:20:34.463]                             invokeRestart(restart)
[16:20:34.463]                             muffled <- TRUE
[16:20:34.463]                             break
[16:20:34.463]                           }
[16:20:34.463]                         }
[16:20:34.463]                       }
[16:20:34.463]                       invisible(muffled)
[16:20:34.463]                     }
[16:20:34.463]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.463]                   }
[16:20:34.463]                 }
[16:20:34.463]                 else {
[16:20:34.463]                   if (TRUE) {
[16:20:34.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.463]                     {
[16:20:34.463]                       inherits <- base::inherits
[16:20:34.463]                       invokeRestart <- base::invokeRestart
[16:20:34.463]                       is.null <- base::is.null
[16:20:34.463]                       muffled <- FALSE
[16:20:34.463]                       if (inherits(cond, "message")) {
[16:20:34.463]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.463]                         if (muffled) 
[16:20:34.463]                           invokeRestart("muffleMessage")
[16:20:34.463]                       }
[16:20:34.463]                       else if (inherits(cond, "warning")) {
[16:20:34.463]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.463]                         if (muffled) 
[16:20:34.463]                           invokeRestart("muffleWarning")
[16:20:34.463]                       }
[16:20:34.463]                       else if (inherits(cond, "condition")) {
[16:20:34.463]                         if (!is.null(pattern)) {
[16:20:34.463]                           computeRestarts <- base::computeRestarts
[16:20:34.463]                           grepl <- base::grepl
[16:20:34.463]                           restarts <- computeRestarts(cond)
[16:20:34.463]                           for (restart in restarts) {
[16:20:34.463]                             name <- restart$name
[16:20:34.463]                             if (is.null(name)) 
[16:20:34.463]                               next
[16:20:34.463]                             if (!grepl(pattern, name)) 
[16:20:34.463]                               next
[16:20:34.463]                             invokeRestart(restart)
[16:20:34.463]                             muffled <- TRUE
[16:20:34.463]                             break
[16:20:34.463]                           }
[16:20:34.463]                         }
[16:20:34.463]                       }
[16:20:34.463]                       invisible(muffled)
[16:20:34.463]                     }
[16:20:34.463]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.463]                   }
[16:20:34.463]                 }
[16:20:34.463]             }
[16:20:34.463]         }))
[16:20:34.463]     }, error = function(ex) {
[16:20:34.463]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:34.463]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.463]                 ...future.rng), started = ...future.startTime, 
[16:20:34.463]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:34.463]             version = "1.8"), class = "FutureResult")
[16:20:34.463]     }, finally = {
[16:20:34.463]         if (!identical(...future.workdir, getwd())) 
[16:20:34.463]             setwd(...future.workdir)
[16:20:34.463]         {
[16:20:34.463]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:34.463]                 ...future.oldOptions$nwarnings <- NULL
[16:20:34.463]             }
[16:20:34.463]             base::options(...future.oldOptions)
[16:20:34.463]             if (.Platform$OS.type == "windows") {
[16:20:34.463]                 old_names <- names(...future.oldEnvVars)
[16:20:34.463]                 envs <- base::Sys.getenv()
[16:20:34.463]                 names <- names(envs)
[16:20:34.463]                 common <- intersect(names, old_names)
[16:20:34.463]                 added <- setdiff(names, old_names)
[16:20:34.463]                 removed <- setdiff(old_names, names)
[16:20:34.463]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:34.463]                   envs[common]]
[16:20:34.463]                 NAMES <- toupper(changed)
[16:20:34.463]                 args <- list()
[16:20:34.463]                 for (kk in seq_along(NAMES)) {
[16:20:34.463]                   name <- changed[[kk]]
[16:20:34.463]                   NAME <- NAMES[[kk]]
[16:20:34.463]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.463]                     next
[16:20:34.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.463]                 }
[16:20:34.463]                 NAMES <- toupper(added)
[16:20:34.463]                 for (kk in seq_along(NAMES)) {
[16:20:34.463]                   name <- added[[kk]]
[16:20:34.463]                   NAME <- NAMES[[kk]]
[16:20:34.463]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.463]                     next
[16:20:34.463]                   args[[name]] <- ""
[16:20:34.463]                 }
[16:20:34.463]                 NAMES <- toupper(removed)
[16:20:34.463]                 for (kk in seq_along(NAMES)) {
[16:20:34.463]                   name <- removed[[kk]]
[16:20:34.463]                   NAME <- NAMES[[kk]]
[16:20:34.463]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.463]                     next
[16:20:34.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.463]                 }
[16:20:34.463]                 if (length(args) > 0) 
[16:20:34.463]                   base::do.call(base::Sys.setenv, args = args)
[16:20:34.463]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:34.463]             }
[16:20:34.463]             else {
[16:20:34.463]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:34.463]             }
[16:20:34.463]             {
[16:20:34.463]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:34.463]                   0L) {
[16:20:34.463]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:34.463]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:34.463]                   base::options(opts)
[16:20:34.463]                 }
[16:20:34.463]                 {
[16:20:34.463]                   {
[16:20:34.463]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:34.463]                     NULL
[16:20:34.463]                   }
[16:20:34.463]                   options(future.plan = NULL)
[16:20:34.463]                   if (is.na(NA_character_)) 
[16:20:34.463]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.463]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:34.463]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:34.463]                     .init = FALSE)
[16:20:34.463]                 }
[16:20:34.463]             }
[16:20:34.463]         }
[16:20:34.463]     })
[16:20:34.463]     if (TRUE) {
[16:20:34.463]         base::sink(type = "output", split = FALSE)
[16:20:34.463]         if (TRUE) {
[16:20:34.463]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:34.463]         }
[16:20:34.463]         else {
[16:20:34.463]             ...future.result["stdout"] <- base::list(NULL)
[16:20:34.463]         }
[16:20:34.463]         base::close(...future.stdout)
[16:20:34.463]         ...future.stdout <- NULL
[16:20:34.463]     }
[16:20:34.463]     ...future.result$conditions <- ...future.conditions
[16:20:34.463]     ...future.result$finished <- base::Sys.time()
[16:20:34.463]     ...future.result
[16:20:34.463] }
[16:20:34.466] MultisessionFuture started
[16:20:34.466] - Launch lazy future ... done
[16:20:34.466] run() for ‘MultisessionFuture’ ... done
[16:20:34.467] result() for ClusterFuture ...
[16:20:34.467] receiveMessageFromWorker() for ClusterFuture ...
[16:20:34.467] - Validating connection of MultisessionFuture
[16:20:34.468] - received message: FutureResult
[16:20:34.468] - Received FutureResult
[16:20:34.468] - Erased future from FutureRegistry
[16:20:34.468] result() for ClusterFuture ...
[16:20:34.468] - result already collected: FutureResult
[16:20:34.468] result() for ClusterFuture ... done
[16:20:34.468] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:34.469] result() for ClusterFuture ... done
[16:20:34.469] result() for ClusterFuture ...
[16:20:34.469] - result already collected: FutureResult
[16:20:34.469] result() for ClusterFuture ... done
d = 1
** Nested future assignments
[16:20:34.469] getGlobalsAndPackages() ...
[16:20:34.469] Searching for globals...
[16:20:34.473] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[16:20:34.473] Searching for globals ... DONE
[16:20:34.473] Resolving globals: FALSE
[16:20:34.473] 
[16:20:34.474] - packages: [1] ‘future’
[16:20:34.474] getGlobalsAndPackages() ... DONE
[16:20:34.474] run() for ‘Future’ ...
[16:20:34.474] - state: ‘created’
[16:20:34.474] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:34.489] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:34.489] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:34.490]   - Field: ‘node’
[16:20:34.490]   - Field: ‘label’
[16:20:34.490]   - Field: ‘local’
[16:20:34.490]   - Field: ‘owner’
[16:20:34.490]   - Field: ‘envir’
[16:20:34.490]   - Field: ‘workers’
[16:20:34.490]   - Field: ‘packages’
[16:20:34.490]   - Field: ‘gc’
[16:20:34.490]   - Field: ‘conditions’
[16:20:34.490]   - Field: ‘persistent’
[16:20:34.491]   - Field: ‘expr’
[16:20:34.491]   - Field: ‘uuid’
[16:20:34.491]   - Field: ‘seed’
[16:20:34.491]   - Field: ‘version’
[16:20:34.491]   - Field: ‘result’
[16:20:34.491]   - Field: ‘asynchronous’
[16:20:34.491]   - Field: ‘calls’
[16:20:34.491]   - Field: ‘globals’
[16:20:34.491]   - Field: ‘stdout’
[16:20:34.491]   - Field: ‘earlySignal’
[16:20:34.491]   - Field: ‘lazy’
[16:20:34.492]   - Field: ‘state’
[16:20:34.492] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:34.492] - Launch lazy future ...
[16:20:34.492] Packages needed by the future expression (n = 1): ‘future’
[16:20:34.492] Packages needed by future strategies (n = 0): <none>
[16:20:34.493] {
[16:20:34.493]     {
[16:20:34.493]         {
[16:20:34.493]             ...future.startTime <- base::Sys.time()
[16:20:34.493]             {
[16:20:34.493]                 {
[16:20:34.493]                   {
[16:20:34.493]                     {
[16:20:34.493]                       {
[16:20:34.493]                         base::local({
[16:20:34.493]                           has_future <- base::requireNamespace("future", 
[16:20:34.493]                             quietly = TRUE)
[16:20:34.493]                           if (has_future) {
[16:20:34.493]                             ns <- base::getNamespace("future")
[16:20:34.493]                             version <- ns[[".package"]][["version"]]
[16:20:34.493]                             if (is.null(version)) 
[16:20:34.493]                               version <- utils::packageVersion("future")
[16:20:34.493]                           }
[16:20:34.493]                           else {
[16:20:34.493]                             version <- NULL
[16:20:34.493]                           }
[16:20:34.493]                           if (!has_future || version < "1.8.0") {
[16:20:34.493]                             info <- base::c(r_version = base::gsub("R version ", 
[16:20:34.493]                               "", base::R.version$version.string), 
[16:20:34.493]                               platform = base::sprintf("%s (%s-bit)", 
[16:20:34.493]                                 base::R.version$platform, 8 * 
[16:20:34.493]                                   base::.Machine$sizeof.pointer), 
[16:20:34.493]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:34.493]                                 "release", "version")], collapse = " "), 
[16:20:34.493]                               hostname = base::Sys.info()[["nodename"]])
[16:20:34.493]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:20:34.493]                               info)
[16:20:34.493]                             info <- base::paste(info, collapse = "; ")
[16:20:34.493]                             if (!has_future) {
[16:20:34.493]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:34.493]                                 info)
[16:20:34.493]                             }
[16:20:34.493]                             else {
[16:20:34.493]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:34.493]                                 info, version)
[16:20:34.493]                             }
[16:20:34.493]                             base::stop(msg)
[16:20:34.493]                           }
[16:20:34.493]                         })
[16:20:34.493]                       }
[16:20:34.493]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:34.493]                       base::options(mc.cores = 1L)
[16:20:34.493]                     }
[16:20:34.493]                     base::local({
[16:20:34.493]                       for (pkg in "future") {
[16:20:34.493]                         base::loadNamespace(pkg)
[16:20:34.493]                         base::library(pkg, character.only = TRUE)
[16:20:34.493]                       }
[16:20:34.493]                     })
[16:20:34.493]                   }
[16:20:34.493]                   ...future.strategy.old <- future::plan("list")
[16:20:34.493]                   options(future.plan = NULL)
[16:20:34.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:34.493]                 }
[16:20:34.493]                 ...future.workdir <- getwd()
[16:20:34.493]             }
[16:20:34.493]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:34.493]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:34.493]         }
[16:20:34.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:34.493]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:34.493]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:34.493]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:34.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:34.493]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:34.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:34.493]             base::names(...future.oldOptions))
[16:20:34.493]     }
[16:20:34.493]     if (FALSE) {
[16:20:34.493]     }
[16:20:34.493]     else {
[16:20:34.493]         if (TRUE) {
[16:20:34.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:34.493]                 open = "w")
[16:20:34.493]         }
[16:20:34.493]         else {
[16:20:34.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:34.493]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:34.493]         }
[16:20:34.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:34.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:34.493]             base::sink(type = "output", split = FALSE)
[16:20:34.493]             base::close(...future.stdout)
[16:20:34.493]         }, add = TRUE)
[16:20:34.493]     }
[16:20:34.493]     ...future.frame <- base::sys.nframe()
[16:20:34.493]     ...future.conditions <- base::list()
[16:20:34.493]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:34.493]     if (FALSE) {
[16:20:34.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:34.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:34.493]     }
[16:20:34.493]     ...future.result <- base::tryCatch({
[16:20:34.493]         base::withCallingHandlers({
[16:20:34.493]             ...future.value <- base::withVisible(base::local({
[16:20:34.493]                 ...future.makeSendCondition <- base::local({
[16:20:34.493]                   sendCondition <- NULL
[16:20:34.493]                   function(frame = 1L) {
[16:20:34.493]                     if (is.function(sendCondition)) 
[16:20:34.493]                       return(sendCondition)
[16:20:34.493]                     ns <- getNamespace("parallel")
[16:20:34.493]                     if (exists("sendData", mode = "function", 
[16:20:34.493]                       envir = ns)) {
[16:20:34.493]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:34.493]                         envir = ns)
[16:20:34.493]                       envir <- sys.frame(frame)
[16:20:34.493]                       master <- NULL
[16:20:34.493]                       while (!identical(envir, .GlobalEnv) && 
[16:20:34.493]                         !identical(envir, emptyenv())) {
[16:20:34.493]                         if (exists("master", mode = "list", envir = envir, 
[16:20:34.493]                           inherits = FALSE)) {
[16:20:34.493]                           master <- get("master", mode = "list", 
[16:20:34.493]                             envir = envir, inherits = FALSE)
[16:20:34.493]                           if (inherits(master, c("SOCKnode", 
[16:20:34.493]                             "SOCK0node"))) {
[16:20:34.493]                             sendCondition <<- function(cond) {
[16:20:34.493]                               data <- list(type = "VALUE", value = cond, 
[16:20:34.493]                                 success = TRUE)
[16:20:34.493]                               parallel_sendData(master, data)
[16:20:34.493]                             }
[16:20:34.493]                             return(sendCondition)
[16:20:34.493]                           }
[16:20:34.493]                         }
[16:20:34.493]                         frame <- frame + 1L
[16:20:34.493]                         envir <- sys.frame(frame)
[16:20:34.493]                       }
[16:20:34.493]                     }
[16:20:34.493]                     sendCondition <<- function(cond) NULL
[16:20:34.493]                   }
[16:20:34.493]                 })
[16:20:34.493]                 withCallingHandlers({
[16:20:34.493]                   {
[16:20:34.493]                     b <- 1
[16:20:34.493]                     c %<-% 2
[16:20:34.493]                     d <- 3
[16:20:34.493]                     4 %->% e
[16:20:34.493]                     b + c + d + e
[16:20:34.493]                   }
[16:20:34.493]                 }, immediateCondition = function(cond) {
[16:20:34.493]                   sendCondition <- ...future.makeSendCondition()
[16:20:34.493]                   sendCondition(cond)
[16:20:34.493]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.493]                   {
[16:20:34.493]                     inherits <- base::inherits
[16:20:34.493]                     invokeRestart <- base::invokeRestart
[16:20:34.493]                     is.null <- base::is.null
[16:20:34.493]                     muffled <- FALSE
[16:20:34.493]                     if (inherits(cond, "message")) {
[16:20:34.493]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:34.493]                       if (muffled) 
[16:20:34.493]                         invokeRestart("muffleMessage")
[16:20:34.493]                     }
[16:20:34.493]                     else if (inherits(cond, "warning")) {
[16:20:34.493]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:34.493]                       if (muffled) 
[16:20:34.493]                         invokeRestart("muffleWarning")
[16:20:34.493]                     }
[16:20:34.493]                     else if (inherits(cond, "condition")) {
[16:20:34.493]                       if (!is.null(pattern)) {
[16:20:34.493]                         computeRestarts <- base::computeRestarts
[16:20:34.493]                         grepl <- base::grepl
[16:20:34.493]                         restarts <- computeRestarts(cond)
[16:20:34.493]                         for (restart in restarts) {
[16:20:34.493]                           name <- restart$name
[16:20:34.493]                           if (is.null(name)) 
[16:20:34.493]                             next
[16:20:34.493]                           if (!grepl(pattern, name)) 
[16:20:34.493]                             next
[16:20:34.493]                           invokeRestart(restart)
[16:20:34.493]                           muffled <- TRUE
[16:20:34.493]                           break
[16:20:34.493]                         }
[16:20:34.493]                       }
[16:20:34.493]                     }
[16:20:34.493]                     invisible(muffled)
[16:20:34.493]                   }
[16:20:34.493]                   muffleCondition(cond)
[16:20:34.493]                 })
[16:20:34.493]             }))
[16:20:34.493]             future::FutureResult(value = ...future.value$value, 
[16:20:34.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.493]                   ...future.rng), globalenv = if (FALSE) 
[16:20:34.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:34.493]                     ...future.globalenv.names))
[16:20:34.493]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:34.493]         }, condition = base::local({
[16:20:34.493]             c <- base::c
[16:20:34.493]             inherits <- base::inherits
[16:20:34.493]             invokeRestart <- base::invokeRestart
[16:20:34.493]             length <- base::length
[16:20:34.493]             list <- base::list
[16:20:34.493]             seq.int <- base::seq.int
[16:20:34.493]             signalCondition <- base::signalCondition
[16:20:34.493]             sys.calls <- base::sys.calls
[16:20:34.493]             `[[` <- base::`[[`
[16:20:34.493]             `+` <- base::`+`
[16:20:34.493]             `<<-` <- base::`<<-`
[16:20:34.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:34.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:34.493]                   3L)]
[16:20:34.493]             }
[16:20:34.493]             function(cond) {
[16:20:34.493]                 is_error <- inherits(cond, "error")
[16:20:34.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:34.493]                   NULL)
[16:20:34.493]                 if (is_error) {
[16:20:34.493]                   sessionInformation <- function() {
[16:20:34.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:34.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:34.493]                       search = base::search(), system = base::Sys.info())
[16:20:34.493]                   }
[16:20:34.493]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:34.493]                     cond$call), session = sessionInformation(), 
[16:20:34.493]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:34.493]                   signalCondition(cond)
[16:20:34.493]                 }
[16:20:34.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:34.493]                 "immediateCondition"))) {
[16:20:34.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:34.493]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:34.493]                   if (TRUE && !signal) {
[16:20:34.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.493]                     {
[16:20:34.493]                       inherits <- base::inherits
[16:20:34.493]                       invokeRestart <- base::invokeRestart
[16:20:34.493]                       is.null <- base::is.null
[16:20:34.493]                       muffled <- FALSE
[16:20:34.493]                       if (inherits(cond, "message")) {
[16:20:34.493]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.493]                         if (muffled) 
[16:20:34.493]                           invokeRestart("muffleMessage")
[16:20:34.493]                       }
[16:20:34.493]                       else if (inherits(cond, "warning")) {
[16:20:34.493]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.493]                         if (muffled) 
[16:20:34.493]                           invokeRestart("muffleWarning")
[16:20:34.493]                       }
[16:20:34.493]                       else if (inherits(cond, "condition")) {
[16:20:34.493]                         if (!is.null(pattern)) {
[16:20:34.493]                           computeRestarts <- base::computeRestarts
[16:20:34.493]                           grepl <- base::grepl
[16:20:34.493]                           restarts <- computeRestarts(cond)
[16:20:34.493]                           for (restart in restarts) {
[16:20:34.493]                             name <- restart$name
[16:20:34.493]                             if (is.null(name)) 
[16:20:34.493]                               next
[16:20:34.493]                             if (!grepl(pattern, name)) 
[16:20:34.493]                               next
[16:20:34.493]                             invokeRestart(restart)
[16:20:34.493]                             muffled <- TRUE
[16:20:34.493]                             break
[16:20:34.493]                           }
[16:20:34.493]                         }
[16:20:34.493]                       }
[16:20:34.493]                       invisible(muffled)
[16:20:34.493]                     }
[16:20:34.493]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.493]                   }
[16:20:34.493]                 }
[16:20:34.493]                 else {
[16:20:34.493]                   if (TRUE) {
[16:20:34.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.493]                     {
[16:20:34.493]                       inherits <- base::inherits
[16:20:34.493]                       invokeRestart <- base::invokeRestart
[16:20:34.493]                       is.null <- base::is.null
[16:20:34.493]                       muffled <- FALSE
[16:20:34.493]                       if (inherits(cond, "message")) {
[16:20:34.493]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.493]                         if (muffled) 
[16:20:34.493]                           invokeRestart("muffleMessage")
[16:20:34.493]                       }
[16:20:34.493]                       else if (inherits(cond, "warning")) {
[16:20:34.493]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.493]                         if (muffled) 
[16:20:34.493]                           invokeRestart("muffleWarning")
[16:20:34.493]                       }
[16:20:34.493]                       else if (inherits(cond, "condition")) {
[16:20:34.493]                         if (!is.null(pattern)) {
[16:20:34.493]                           computeRestarts <- base::computeRestarts
[16:20:34.493]                           grepl <- base::grepl
[16:20:34.493]                           restarts <- computeRestarts(cond)
[16:20:34.493]                           for (restart in restarts) {
[16:20:34.493]                             name <- restart$name
[16:20:34.493]                             if (is.null(name)) 
[16:20:34.493]                               next
[16:20:34.493]                             if (!grepl(pattern, name)) 
[16:20:34.493]                               next
[16:20:34.493]                             invokeRestart(restart)
[16:20:34.493]                             muffled <- TRUE
[16:20:34.493]                             break
[16:20:34.493]                           }
[16:20:34.493]                         }
[16:20:34.493]                       }
[16:20:34.493]                       invisible(muffled)
[16:20:34.493]                     }
[16:20:34.493]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.493]                   }
[16:20:34.493]                 }
[16:20:34.493]             }
[16:20:34.493]         }))
[16:20:34.493]     }, error = function(ex) {
[16:20:34.493]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:34.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.493]                 ...future.rng), started = ...future.startTime, 
[16:20:34.493]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:34.493]             version = "1.8"), class = "FutureResult")
[16:20:34.493]     }, finally = {
[16:20:34.493]         if (!identical(...future.workdir, getwd())) 
[16:20:34.493]             setwd(...future.workdir)
[16:20:34.493]         {
[16:20:34.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:34.493]                 ...future.oldOptions$nwarnings <- NULL
[16:20:34.493]             }
[16:20:34.493]             base::options(...future.oldOptions)
[16:20:34.493]             if (.Platform$OS.type == "windows") {
[16:20:34.493]                 old_names <- names(...future.oldEnvVars)
[16:20:34.493]                 envs <- base::Sys.getenv()
[16:20:34.493]                 names <- names(envs)
[16:20:34.493]                 common <- intersect(names, old_names)
[16:20:34.493]                 added <- setdiff(names, old_names)
[16:20:34.493]                 removed <- setdiff(old_names, names)
[16:20:34.493]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:34.493]                   envs[common]]
[16:20:34.493]                 NAMES <- toupper(changed)
[16:20:34.493]                 args <- list()
[16:20:34.493]                 for (kk in seq_along(NAMES)) {
[16:20:34.493]                   name <- changed[[kk]]
[16:20:34.493]                   NAME <- NAMES[[kk]]
[16:20:34.493]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.493]                     next
[16:20:34.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.493]                 }
[16:20:34.493]                 NAMES <- toupper(added)
[16:20:34.493]                 for (kk in seq_along(NAMES)) {
[16:20:34.493]                   name <- added[[kk]]
[16:20:34.493]                   NAME <- NAMES[[kk]]
[16:20:34.493]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.493]                     next
[16:20:34.493]                   args[[name]] <- ""
[16:20:34.493]                 }
[16:20:34.493]                 NAMES <- toupper(removed)
[16:20:34.493]                 for (kk in seq_along(NAMES)) {
[16:20:34.493]                   name <- removed[[kk]]
[16:20:34.493]                   NAME <- NAMES[[kk]]
[16:20:34.493]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.493]                     next
[16:20:34.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.493]                 }
[16:20:34.493]                 if (length(args) > 0) 
[16:20:34.493]                   base::do.call(base::Sys.setenv, args = args)
[16:20:34.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:34.493]             }
[16:20:34.493]             else {
[16:20:34.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:34.493]             }
[16:20:34.493]             {
[16:20:34.493]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:34.493]                   0L) {
[16:20:34.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:34.493]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:34.493]                   base::options(opts)
[16:20:34.493]                 }
[16:20:34.493]                 {
[16:20:34.493]                   {
[16:20:34.493]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:34.493]                     NULL
[16:20:34.493]                   }
[16:20:34.493]                   options(future.plan = NULL)
[16:20:34.493]                   if (is.na(NA_character_)) 
[16:20:34.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:34.493]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:34.493]                     .init = FALSE)
[16:20:34.493]                 }
[16:20:34.493]             }
[16:20:34.493]         }
[16:20:34.493]     })
[16:20:34.493]     if (TRUE) {
[16:20:34.493]         base::sink(type = "output", split = FALSE)
[16:20:34.493]         if (TRUE) {
[16:20:34.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:34.493]         }
[16:20:34.493]         else {
[16:20:34.493]             ...future.result["stdout"] <- base::list(NULL)
[16:20:34.493]         }
[16:20:34.493]         base::close(...future.stdout)
[16:20:34.493]         ...future.stdout <- NULL
[16:20:34.493]     }
[16:20:34.493]     ...future.result$conditions <- ...future.conditions
[16:20:34.493]     ...future.result$finished <- base::Sys.time()
[16:20:34.493]     ...future.result
[16:20:34.493] }
[16:20:34.495] MultisessionFuture started
[16:20:34.496] - Launch lazy future ... done
[16:20:34.496] run() for ‘MultisessionFuture’ ... done
[16:20:34.496] result() for ClusterFuture ...
[16:20:34.496] receiveMessageFromWorker() for ClusterFuture ...
[16:20:34.496] - Validating connection of MultisessionFuture
[16:20:34.551] - received message: FutureResult
[16:20:34.551] - Received FutureResult
[16:20:34.551] - Erased future from FutureRegistry
[16:20:34.551] result() for ClusterFuture ...
[16:20:34.552] - result already collected: FutureResult
[16:20:34.552] result() for ClusterFuture ... done
[16:20:34.552] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:34.552] result() for ClusterFuture ... done
[16:20:34.552] result() for ClusterFuture ...
[16:20:34.552] - result already collected: FutureResult
[16:20:34.552] result() for ClusterFuture ... done
a = 10
[16:20:34.552] getGlobalsAndPackages() ...
[16:20:34.553] Searching for globals...
[16:20:34.553] - globals found: [3] ‘{’, ‘+’, ‘a’
[16:20:34.554] Searching for globals ... DONE
[16:20:34.554] Resolving globals: FALSE
[16:20:34.554] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:34.554] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:20:34.554] - globals: [1] ‘a’
[16:20:34.555] 
[16:20:34.555] getGlobalsAndPackages() ... DONE
[16:20:34.555] run() for ‘Future’ ...
[16:20:34.555] - state: ‘created’
[16:20:34.555] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:34.569] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:34.569] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:34.569]   - Field: ‘node’
[16:20:34.569]   - Field: ‘label’
[16:20:34.569]   - Field: ‘local’
[16:20:34.569]   - Field: ‘owner’
[16:20:34.570]   - Field: ‘envir’
[16:20:34.570]   - Field: ‘workers’
[16:20:34.570]   - Field: ‘packages’
[16:20:34.570]   - Field: ‘gc’
[16:20:34.570]   - Field: ‘conditions’
[16:20:34.570]   - Field: ‘persistent’
[16:20:34.570]   - Field: ‘expr’
[16:20:34.570]   - Field: ‘uuid’
[16:20:34.570]   - Field: ‘seed’
[16:20:34.570]   - Field: ‘version’
[16:20:34.570]   - Field: ‘result’
[16:20:34.571]   - Field: ‘asynchronous’
[16:20:34.571]   - Field: ‘calls’
[16:20:34.571]   - Field: ‘globals’
[16:20:34.571]   - Field: ‘stdout’
[16:20:34.571]   - Field: ‘earlySignal’
[16:20:34.571]   - Field: ‘lazy’
[16:20:34.571]   - Field: ‘state’
[16:20:34.571] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:34.571] - Launch lazy future ...
[16:20:34.572] Packages needed by the future expression (n = 0): <none>
[16:20:34.572] Packages needed by future strategies (n = 0): <none>
[16:20:34.572] {
[16:20:34.572]     {
[16:20:34.572]         {
[16:20:34.572]             ...future.startTime <- base::Sys.time()
[16:20:34.572]             {
[16:20:34.572]                 {
[16:20:34.572]                   {
[16:20:34.572]                     {
[16:20:34.572]                       base::local({
[16:20:34.572]                         has_future <- base::requireNamespace("future", 
[16:20:34.572]                           quietly = TRUE)
[16:20:34.572]                         if (has_future) {
[16:20:34.572]                           ns <- base::getNamespace("future")
[16:20:34.572]                           version <- ns[[".package"]][["version"]]
[16:20:34.572]                           if (is.null(version)) 
[16:20:34.572]                             version <- utils::packageVersion("future")
[16:20:34.572]                         }
[16:20:34.572]                         else {
[16:20:34.572]                           version <- NULL
[16:20:34.572]                         }
[16:20:34.572]                         if (!has_future || version < "1.8.0") {
[16:20:34.572]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:34.572]                             "", base::R.version$version.string), 
[16:20:34.572]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:34.572]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:34.572]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:34.572]                               "release", "version")], collapse = " "), 
[16:20:34.572]                             hostname = base::Sys.info()[["nodename"]])
[16:20:34.572]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:34.572]                             info)
[16:20:34.572]                           info <- base::paste(info, collapse = "; ")
[16:20:34.572]                           if (!has_future) {
[16:20:34.572]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:34.572]                               info)
[16:20:34.572]                           }
[16:20:34.572]                           else {
[16:20:34.572]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:34.572]                               info, version)
[16:20:34.572]                           }
[16:20:34.572]                           base::stop(msg)
[16:20:34.572]                         }
[16:20:34.572]                       })
[16:20:34.572]                     }
[16:20:34.572]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:34.572]                     base::options(mc.cores = 1L)
[16:20:34.572]                   }
[16:20:34.572]                   ...future.strategy.old <- future::plan("list")
[16:20:34.572]                   options(future.plan = NULL)
[16:20:34.572]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.572]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:34.572]                 }
[16:20:34.572]                 ...future.workdir <- getwd()
[16:20:34.572]             }
[16:20:34.572]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:34.572]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:34.572]         }
[16:20:34.572]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:34.572]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:34.572]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:34.572]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:34.572]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:34.572]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:34.572]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:34.572]             base::names(...future.oldOptions))
[16:20:34.572]     }
[16:20:34.572]     if (FALSE) {
[16:20:34.572]     }
[16:20:34.572]     else {
[16:20:34.572]         if (TRUE) {
[16:20:34.572]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:34.572]                 open = "w")
[16:20:34.572]         }
[16:20:34.572]         else {
[16:20:34.572]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:34.572]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:34.572]         }
[16:20:34.572]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:34.572]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:34.572]             base::sink(type = "output", split = FALSE)
[16:20:34.572]             base::close(...future.stdout)
[16:20:34.572]         }, add = TRUE)
[16:20:34.572]     }
[16:20:34.572]     ...future.frame <- base::sys.nframe()
[16:20:34.572]     ...future.conditions <- base::list()
[16:20:34.572]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:34.572]     if (FALSE) {
[16:20:34.572]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:34.572]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:34.572]     }
[16:20:34.572]     ...future.result <- base::tryCatch({
[16:20:34.572]         base::withCallingHandlers({
[16:20:34.572]             ...future.value <- base::withVisible(base::local({
[16:20:34.572]                 ...future.makeSendCondition <- base::local({
[16:20:34.572]                   sendCondition <- NULL
[16:20:34.572]                   function(frame = 1L) {
[16:20:34.572]                     if (is.function(sendCondition)) 
[16:20:34.572]                       return(sendCondition)
[16:20:34.572]                     ns <- getNamespace("parallel")
[16:20:34.572]                     if (exists("sendData", mode = "function", 
[16:20:34.572]                       envir = ns)) {
[16:20:34.572]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:34.572]                         envir = ns)
[16:20:34.572]                       envir <- sys.frame(frame)
[16:20:34.572]                       master <- NULL
[16:20:34.572]                       while (!identical(envir, .GlobalEnv) && 
[16:20:34.572]                         !identical(envir, emptyenv())) {
[16:20:34.572]                         if (exists("master", mode = "list", envir = envir, 
[16:20:34.572]                           inherits = FALSE)) {
[16:20:34.572]                           master <- get("master", mode = "list", 
[16:20:34.572]                             envir = envir, inherits = FALSE)
[16:20:34.572]                           if (inherits(master, c("SOCKnode", 
[16:20:34.572]                             "SOCK0node"))) {
[16:20:34.572]                             sendCondition <<- function(cond) {
[16:20:34.572]                               data <- list(type = "VALUE", value = cond, 
[16:20:34.572]                                 success = TRUE)
[16:20:34.572]                               parallel_sendData(master, data)
[16:20:34.572]                             }
[16:20:34.572]                             return(sendCondition)
[16:20:34.572]                           }
[16:20:34.572]                         }
[16:20:34.572]                         frame <- frame + 1L
[16:20:34.572]                         envir <- sys.frame(frame)
[16:20:34.572]                       }
[16:20:34.572]                     }
[16:20:34.572]                     sendCondition <<- function(cond) NULL
[16:20:34.572]                   }
[16:20:34.572]                 })
[16:20:34.572]                 withCallingHandlers({
[16:20:34.572]                   {
[16:20:34.572]                     a + 1
[16:20:34.572]                   }
[16:20:34.572]                 }, immediateCondition = function(cond) {
[16:20:34.572]                   sendCondition <- ...future.makeSendCondition()
[16:20:34.572]                   sendCondition(cond)
[16:20:34.572]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.572]                   {
[16:20:34.572]                     inherits <- base::inherits
[16:20:34.572]                     invokeRestart <- base::invokeRestart
[16:20:34.572]                     is.null <- base::is.null
[16:20:34.572]                     muffled <- FALSE
[16:20:34.572]                     if (inherits(cond, "message")) {
[16:20:34.572]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:34.572]                       if (muffled) 
[16:20:34.572]                         invokeRestart("muffleMessage")
[16:20:34.572]                     }
[16:20:34.572]                     else if (inherits(cond, "warning")) {
[16:20:34.572]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:34.572]                       if (muffled) 
[16:20:34.572]                         invokeRestart("muffleWarning")
[16:20:34.572]                     }
[16:20:34.572]                     else if (inherits(cond, "condition")) {
[16:20:34.572]                       if (!is.null(pattern)) {
[16:20:34.572]                         computeRestarts <- base::computeRestarts
[16:20:34.572]                         grepl <- base::grepl
[16:20:34.572]                         restarts <- computeRestarts(cond)
[16:20:34.572]                         for (restart in restarts) {
[16:20:34.572]                           name <- restart$name
[16:20:34.572]                           if (is.null(name)) 
[16:20:34.572]                             next
[16:20:34.572]                           if (!grepl(pattern, name)) 
[16:20:34.572]                             next
[16:20:34.572]                           invokeRestart(restart)
[16:20:34.572]                           muffled <- TRUE
[16:20:34.572]                           break
[16:20:34.572]                         }
[16:20:34.572]                       }
[16:20:34.572]                     }
[16:20:34.572]                     invisible(muffled)
[16:20:34.572]                   }
[16:20:34.572]                   muffleCondition(cond)
[16:20:34.572]                 })
[16:20:34.572]             }))
[16:20:34.572]             future::FutureResult(value = ...future.value$value, 
[16:20:34.572]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.572]                   ...future.rng), globalenv = if (FALSE) 
[16:20:34.572]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:34.572]                     ...future.globalenv.names))
[16:20:34.572]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:34.572]         }, condition = base::local({
[16:20:34.572]             c <- base::c
[16:20:34.572]             inherits <- base::inherits
[16:20:34.572]             invokeRestart <- base::invokeRestart
[16:20:34.572]             length <- base::length
[16:20:34.572]             list <- base::list
[16:20:34.572]             seq.int <- base::seq.int
[16:20:34.572]             signalCondition <- base::signalCondition
[16:20:34.572]             sys.calls <- base::sys.calls
[16:20:34.572]             `[[` <- base::`[[`
[16:20:34.572]             `+` <- base::`+`
[16:20:34.572]             `<<-` <- base::`<<-`
[16:20:34.572]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:34.572]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:34.572]                   3L)]
[16:20:34.572]             }
[16:20:34.572]             function(cond) {
[16:20:34.572]                 is_error <- inherits(cond, "error")
[16:20:34.572]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:34.572]                   NULL)
[16:20:34.572]                 if (is_error) {
[16:20:34.572]                   sessionInformation <- function() {
[16:20:34.572]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:34.572]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:34.572]                       search = base::search(), system = base::Sys.info())
[16:20:34.572]                   }
[16:20:34.572]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.572]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:34.572]                     cond$call), session = sessionInformation(), 
[16:20:34.572]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:34.572]                   signalCondition(cond)
[16:20:34.572]                 }
[16:20:34.572]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:34.572]                 "immediateCondition"))) {
[16:20:34.572]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:34.572]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.572]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:34.572]                   if (TRUE && !signal) {
[16:20:34.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.572]                     {
[16:20:34.572]                       inherits <- base::inherits
[16:20:34.572]                       invokeRestart <- base::invokeRestart
[16:20:34.572]                       is.null <- base::is.null
[16:20:34.572]                       muffled <- FALSE
[16:20:34.572]                       if (inherits(cond, "message")) {
[16:20:34.572]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.572]                         if (muffled) 
[16:20:34.572]                           invokeRestart("muffleMessage")
[16:20:34.572]                       }
[16:20:34.572]                       else if (inherits(cond, "warning")) {
[16:20:34.572]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.572]                         if (muffled) 
[16:20:34.572]                           invokeRestart("muffleWarning")
[16:20:34.572]                       }
[16:20:34.572]                       else if (inherits(cond, "condition")) {
[16:20:34.572]                         if (!is.null(pattern)) {
[16:20:34.572]                           computeRestarts <- base::computeRestarts
[16:20:34.572]                           grepl <- base::grepl
[16:20:34.572]                           restarts <- computeRestarts(cond)
[16:20:34.572]                           for (restart in restarts) {
[16:20:34.572]                             name <- restart$name
[16:20:34.572]                             if (is.null(name)) 
[16:20:34.572]                               next
[16:20:34.572]                             if (!grepl(pattern, name)) 
[16:20:34.572]                               next
[16:20:34.572]                             invokeRestart(restart)
[16:20:34.572]                             muffled <- TRUE
[16:20:34.572]                             break
[16:20:34.572]                           }
[16:20:34.572]                         }
[16:20:34.572]                       }
[16:20:34.572]                       invisible(muffled)
[16:20:34.572]                     }
[16:20:34.572]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.572]                   }
[16:20:34.572]                 }
[16:20:34.572]                 else {
[16:20:34.572]                   if (TRUE) {
[16:20:34.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.572]                     {
[16:20:34.572]                       inherits <- base::inherits
[16:20:34.572]                       invokeRestart <- base::invokeRestart
[16:20:34.572]                       is.null <- base::is.null
[16:20:34.572]                       muffled <- FALSE
[16:20:34.572]                       if (inherits(cond, "message")) {
[16:20:34.572]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.572]                         if (muffled) 
[16:20:34.572]                           invokeRestart("muffleMessage")
[16:20:34.572]                       }
[16:20:34.572]                       else if (inherits(cond, "warning")) {
[16:20:34.572]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.572]                         if (muffled) 
[16:20:34.572]                           invokeRestart("muffleWarning")
[16:20:34.572]                       }
[16:20:34.572]                       else if (inherits(cond, "condition")) {
[16:20:34.572]                         if (!is.null(pattern)) {
[16:20:34.572]                           computeRestarts <- base::computeRestarts
[16:20:34.572]                           grepl <- base::grepl
[16:20:34.572]                           restarts <- computeRestarts(cond)
[16:20:34.572]                           for (restart in restarts) {
[16:20:34.572]                             name <- restart$name
[16:20:34.572]                             if (is.null(name)) 
[16:20:34.572]                               next
[16:20:34.572]                             if (!grepl(pattern, name)) 
[16:20:34.572]                               next
[16:20:34.572]                             invokeRestart(restart)
[16:20:34.572]                             muffled <- TRUE
[16:20:34.572]                             break
[16:20:34.572]                           }
[16:20:34.572]                         }
[16:20:34.572]                       }
[16:20:34.572]                       invisible(muffled)
[16:20:34.572]                     }
[16:20:34.572]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.572]                   }
[16:20:34.572]                 }
[16:20:34.572]             }
[16:20:34.572]         }))
[16:20:34.572]     }, error = function(ex) {
[16:20:34.572]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:34.572]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.572]                 ...future.rng), started = ...future.startTime, 
[16:20:34.572]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:34.572]             version = "1.8"), class = "FutureResult")
[16:20:34.572]     }, finally = {
[16:20:34.572]         if (!identical(...future.workdir, getwd())) 
[16:20:34.572]             setwd(...future.workdir)
[16:20:34.572]         {
[16:20:34.572]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:34.572]                 ...future.oldOptions$nwarnings <- NULL
[16:20:34.572]             }
[16:20:34.572]             base::options(...future.oldOptions)
[16:20:34.572]             if (.Platform$OS.type == "windows") {
[16:20:34.572]                 old_names <- names(...future.oldEnvVars)
[16:20:34.572]                 envs <- base::Sys.getenv()
[16:20:34.572]                 names <- names(envs)
[16:20:34.572]                 common <- intersect(names, old_names)
[16:20:34.572]                 added <- setdiff(names, old_names)
[16:20:34.572]                 removed <- setdiff(old_names, names)
[16:20:34.572]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:34.572]                   envs[common]]
[16:20:34.572]                 NAMES <- toupper(changed)
[16:20:34.572]                 args <- list()
[16:20:34.572]                 for (kk in seq_along(NAMES)) {
[16:20:34.572]                   name <- changed[[kk]]
[16:20:34.572]                   NAME <- NAMES[[kk]]
[16:20:34.572]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.572]                     next
[16:20:34.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.572]                 }
[16:20:34.572]                 NAMES <- toupper(added)
[16:20:34.572]                 for (kk in seq_along(NAMES)) {
[16:20:34.572]                   name <- added[[kk]]
[16:20:34.572]                   NAME <- NAMES[[kk]]
[16:20:34.572]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.572]                     next
[16:20:34.572]                   args[[name]] <- ""
[16:20:34.572]                 }
[16:20:34.572]                 NAMES <- toupper(removed)
[16:20:34.572]                 for (kk in seq_along(NAMES)) {
[16:20:34.572]                   name <- removed[[kk]]
[16:20:34.572]                   NAME <- NAMES[[kk]]
[16:20:34.572]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.572]                     next
[16:20:34.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.572]                 }
[16:20:34.572]                 if (length(args) > 0) 
[16:20:34.572]                   base::do.call(base::Sys.setenv, args = args)
[16:20:34.572]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:34.572]             }
[16:20:34.572]             else {
[16:20:34.572]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:34.572]             }
[16:20:34.572]             {
[16:20:34.572]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:34.572]                   0L) {
[16:20:34.572]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:34.572]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:34.572]                   base::options(opts)
[16:20:34.572]                 }
[16:20:34.572]                 {
[16:20:34.572]                   {
[16:20:34.572]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:34.572]                     NULL
[16:20:34.572]                   }
[16:20:34.572]                   options(future.plan = NULL)
[16:20:34.572]                   if (is.na(NA_character_)) 
[16:20:34.572]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.572]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:34.572]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:34.572]                     .init = FALSE)
[16:20:34.572]                 }
[16:20:34.572]             }
[16:20:34.572]         }
[16:20:34.572]     })
[16:20:34.572]     if (TRUE) {
[16:20:34.572]         base::sink(type = "output", split = FALSE)
[16:20:34.572]         if (TRUE) {
[16:20:34.572]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:34.572]         }
[16:20:34.572]         else {
[16:20:34.572]             ...future.result["stdout"] <- base::list(NULL)
[16:20:34.572]         }
[16:20:34.572]         base::close(...future.stdout)
[16:20:34.572]         ...future.stdout <- NULL
[16:20:34.572]     }
[16:20:34.572]     ...future.result$conditions <- ...future.conditions
[16:20:34.572]     ...future.result$finished <- base::Sys.time()
[16:20:34.572]     ...future.result
[16:20:34.572] }
[16:20:34.575] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:20:34.575] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:20:34.575] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:20:34.575] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:20:34.576] MultisessionFuture started
[16:20:34.576] - Launch lazy future ... done
[16:20:34.576] run() for ‘MultisessionFuture’ ... done
[16:20:34.576] result() for ClusterFuture ...
[16:20:34.577] receiveMessageFromWorker() for ClusterFuture ...
[16:20:34.577] - Validating connection of MultisessionFuture
[16:20:34.578] - received message: FutureResult
[16:20:34.578] - Received FutureResult
[16:20:34.578] - Erased future from FutureRegistry
[16:20:34.578] result() for ClusterFuture ...
[16:20:34.578] - result already collected: FutureResult
[16:20:34.578] result() for ClusterFuture ... done
[16:20:34.578] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:34.578] result() for ClusterFuture ... done
[16:20:34.578] result() for ClusterFuture ...
[16:20:34.578] - result already collected: FutureResult
[16:20:34.579] result() for ClusterFuture ... done
b = 11
*** %<-% with ‘multisession’ futures ... DONE
Testing with 2 cores ... DONE
> 
> message("*** %<-% ... DONE")
*** %<-% ... DONE
> 
> source("incl/end.R")
[16:20:34.579] plan(): Setting new future strategy stack:
[16:20:34.579] List of future strategies:
[16:20:34.579] 1. FutureStrategy:
[16:20:34.579]    - args: function (..., envir = parent.frame())
[16:20:34.579]    - tweaked: FALSE
[16:20:34.579]    - call: future::plan(oplan)
[16:20:34.580] plan(): nbrOfWorkers() = 1
> 
